*ABSCOM
      SUBROUTINE ABSCOM(N, V, W, ABSTOL, NFAIL)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE COMPUTES THE NUMBER OF TIMES THE
C     ABSOLUTE DIFFERENCE BETWEEN V(I) AND W(I), I = 1, 2, ..., N,
C     IS GREATER THAN   ABSTOL  .
C
C     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ABSTOL
      INTEGER
     +   N,NFAIL
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   V(*),W(*)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ABSTOL
C        THE ABSOLUTE TOLERANCE USED IN THE COMPARISON.
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFAIL
C        THE TOTAL NUMBER OF FAILURES.
C     DOUBLE PRECISION V(N), W(N)
C        THE VALUES BEING COMPARED.
C
      NFAIL = 0
C
      DO 10 I = 1, N
         IF (ABS(V(I) - W(I)) .GT. ABSTOL) NFAIL = NFAIL + 1
   10 CONTINUE
C
      RETURN
C
      END
*ACCDIG
      SUBROUTINE ACCDIG(AX, X, AD, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     RETURNS NUMBER OF ACCURATE DIGITS, AD, IN AX AN APPROXIMATION TO X
C
C     WRITTEN BY DAVID HOGBEN, SEL, NBS.   10/29/69.
C
C     THIS ROUTINE WAS ADAPTED FROM THE OMNITAB ROUTINE ACCDIG
C     BY - -
C
C     JANET R. DONALDSON
C     STATISTICAL ENGINEERING DIVISION
C     NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AD(*),AX(*),X(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ADMAX,DIFF,FPLRS
      INTEGER
     +   I
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,LOG10,MAX,MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AD(N)
C        THE NUMBER OF ACCURATE DIGITS.
C     DOUBLE PRECISION ADMAX
C        THE NUMBER OF DIGITS CARRIED IN A FLOATING POINT COMPUTATION.
C     DOUBLE PRECISION AX(N)
C        THE APPROXIMATION TO THE SOLUTION.
C     DOUBLE PRECISION DIFF
C        *
C     DOUBLE PRECISION FPLRS
C        THE FLOATING POINT LARGEST RELATIVE SPACING.
C     INTEGER I
C        AN INDEX.
C     INTEGER N
C        THE NUMBER OF ELEMENTS BEING COMPARED.
C     DOUBLE PRECISION X(N)
C        THE SOLUTION.
C
C
      FPLRS = D1MACH(4)
C
      ADMAX = -LOG10(FPLRS)
C
      DO 20 I=1,N
         DIFF = AX(I) - X(I)
         IF (DIFF.NE.0.0D0) GO TO 10
         AD(I) = ADMAX
         GO TO 20
   10    AD(I) = 0.0D0
         IF (ABS(X(I)).GT.0.0D0) AD(I) = LOG10(ABS(X(I)))
         IF (ABS(DIFF).GT.0.0D0) AD(I) = -LOG10(ABS(DIFF)) + AD(I)
         AD(I) = MIN(ADMAX,AD(I))
         AD(I) = MAX(-ADMAX,AD(I))
   20 CONTINUE
      RETURN
      END
*ACF
      SUBROUTINE ACF (Y, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
C     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
C     (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN,YSD
      INTEGER
     +   IAR,IPRT,LACOV,LAGMAX,LAIC,LDSMIN,LDSTAK,LYFFT,NFAC,NFFT,
     +   NPRT
      LOGICAL
     +   DIFFER,ISFFT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),AIC(101),FTEST(2,100),PHI(100),PRHO(100),RHO(100),
     +   SDRHO(100),WORK(100)
      INTEGER
     +   IOD(1),ND(1),NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACFER,ACFMN,ACFOUT,IPRINT,SETLAG
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (ACOV(2),RHO(1))
      EQUIVALENCE (WORK(1),SDRHO(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(101)
C        THE AUTOCOVARIANCE FUNCTION ESTIMATE VECTOR.
C     DOUBLE PRECISION AIC(101)
C        THE ARRAY CONTAINING AKIAKES CRITERIA FOR EACH ORDER.
C     DOUBLE PRECISION CHIA, CHIAP
C        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
C        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
C        ARE STORED.
C     LOGICAL DIFFER
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
C     DOUBLE PRECISION FTEST(2, 100)
C        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IOD(1)
C        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     LOGICAL ISFFT
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAIC
C        THE LENGTH OF THE VECTOR AIC.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER ND(1)
C        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
C     INTEGER NDUM(1)
C        A DUMMY ARRAY.
C     INTEGER NFAC
C        THE NUMBER OF DIFFERENCE FACTORS
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C     INTEGER NPRT
C        THE VARIABLE CONTROLING THE PRINTED OUTPUT.
C     DOUBLE PRECISION OSPVAR
C        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED ORDER (IAR).
C     DOUBLE PRECISION PHI(100)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
C        ORDER.
C     DOUBLE PRECISION PRHO(100)
C        THE ARRAY CONTAINING THE PARTIAL ACF ESTIMATES.
C     DOUBLE PRECISION RHO(100)
C        THE ARRAY CONTAINING THE ACF ESTIMATES.
C     DOUBLE PRECISION SDRHO(100)
C        THE ARRAY CONTAINING THE STANDARD ERRORS OF THE ACF ESTIMATES.
C     DOUBLE PRECISION WORK(100)
C        A VECTOR USED IN THE COMPUTATIONS OF THE PARTIAL
C        AUTOCORRELATION COEFFICIENTS.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YMEAN, YSD
C        THE MEAN AND STANDARD DEVIATION OF THE OBSERVED TIME SERIES
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5), NMSUB(6)
     + /     'A',       'C',       'F',       ' ',       ' ',      ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      LAGMAX = 1
      LACOV = 101
      LAIC = 101
      LDSMIN = 0
      LDSTAK = 0
      NPRT = 1
      DIFFER = .FALSE.
      NFAC = 1
      ND(1) = 0
      IOD(1) = 0
      ISFFT = .FALSE.
      LYFFT = N
      NFFT = N
C
      CALL ACFER(NMSUB, N, LAGMAX, LACOV, LDSTAK, LDSMIN,
     +  DIFFER, NFAC, ND, IOD, ISFFT, LYFFT, NFFT)
C
      IF (IERR.EQ.0) THEN
C
C       SET NUMBER OF ACF TO BE COMPUTED
C
        CALL SETLAG (N, LAGMAX)
C
C       CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
C
        CALL ACFMN (Y, N, LAGMAX, RHO, SDRHO, YMEAN, PRHO, AIC, FTEST,
     +     PHI, IAR, OSPVAR, ACOV, LACOV, LAIC, CHIA, CHIAP, WORK, NPRT)
C
        YSD = SQRT(ACOV(1) * N / (N-1))
C
C       CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
C
        CALL ACFOUT (YMEAN, YSD, N, N, LAGMAX, RHO, SDRHO, PRHO, NDUM,
     +     AIC, LAIC, FTEST, IAR, PHI, OSPVAR, CHIA, CHIAP, LAGMAX,
     +     .FALSE., 0.0D0, .FALSE., .FALSE., 0, NDUM, NDUM, 0)
      END IF
C
      IF (IERR.NE.0) THEN
C
C     PRINT PROPER CALL SEQUENCE AND RETURN
C
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   22H       CALL ACF (Y, N))
      END
*ACFD
      SUBROUTINE ACFD (Y, N, LAGMAX, NFAC, ND, IOD, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
C     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
C     WITH DIFFERENCING.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LAGMAX,LDSTAK,N,NFAC
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
      INTEGER
     +   IOD(*),ND(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN,YSD
      INTEGER
     +   ACOV,AIC,FTEST,I,IAR,IFP,IPRT,LACOV,LDSMIN,LYFFT,NALL0,
     +   NFFT,NTIMES,NYD,NYF,PHI,PRHO,SDRHO,WORK,YF
      LOGICAL
     +   DIFFER,ISFFT,NEWPG
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACFER,ACFMN,ACFOUT,DIFSER,IPRINT,LDSCMP,DCOPY,STKCLR,
     +   STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN,SQRT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER ACOV
C        THE STARTING LOCATION IN DSTAK FOR
C        THE AUTOCOVARIANCE VECTOR.
C     INTEGER AIC
C        THE STARTING LOCATION IN DSTAK FOR
C        THE ARRAY CONTAINING THE AKAIKES CRITERION FOR EACH ORDER.
C     DOUBLE PRECISION CHIA, CHIAP
C        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
C        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
C        ARE STORED.
C     LOGICAL DIFFER
C        THE VARIABLE USED TO DESIGNATE WHETHER OR NOT THE SERIES
C        BEING ANALYZED WAS DIFFERENCED OR NOT.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER FTEST
C        THE STARTING LOCATION IN DSTAK FOR
C        THE ARRAY CONTAINING THE PARTIAL F RATIO AND PROBABILITIES
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C     INTEGER IFP
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE FLOATING
C        POINT VARIABLES ARE SINGLE (IFP=3) OR DOUBLE (IFP=4) PRECISION.
C     INTEGER IOD(NFAC)
C        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     LOGICAL ISFFT
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE REQUESTED.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LYFFT
C        A DUMMY VARIABLE
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
C     INTEGER ND(NFAC)
C        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE
C        FACTORS ARE TO BE APPLIED.
C     INTEGER NDUM(1)
C        A DUMMY DIMENSIONED VARIABLE.
C     LOGICAL NEWPG
C        THE VARIABLE USED TO DESIGNATE WHETHER OR NOT THE OUTPUT
C        IS TO BEGIN ON A NEW PAGE.
C     INTEGER NFAC
C        THE NUMBER OF DIFFERENCE FACTORS.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C     INTEGER NTIMES
C        THE NUMBER OF TIMES THE FIRST DIFFERENCE FACTOR HAS BEEN
C        APPLIED.
C     INTEGER NYD, NYF
C        THE NUMBER OF OBSERVATIONS AFTER THE DIFFERENCE FILTER IS
C        APPLIED.
C     DOUBLE PRECISION OSPVAR
C        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
C     INTEGER PHI
C        THE STARTING LOCATION IN DSTAK FOR
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
C        ORDER.
C     INTEGER PRHO
C        THE STARTING LOCATION IN THE WORK AREA FOR PRHO.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER SDRHO
C        THE STARTING LOCATION IN THE WORK AREA FOR SDRHO.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE WORK AREA FOR WORK.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
C     INTEGER YF
C        THE STARTING LOCATION IN DSTAK FOR
C        THE VECTOR CONTAINING THE DIFFERENCE FILTERED SERIES.
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YSD
C        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'A',       'C',       'F',       'D',       ' ',       ' '/
C
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      LACOV = LAGMAX+1
      DIFFER = .TRUE.
      ISFFT = .FALSE.
      LYFFT = 0
      NFFT = 0
C
      CALL LDSCMP(7, 0, 0, 0, 0, 0, 'D', 7*LAGMAX+2+N, LDSMIN)
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL ACFER(NMSUB, N, LAGMAX, LACOV, LDSTAK, LDSMIN,
     +  DIFFER, NFAC, ND, IOD, ISFFT, LYFFT, NFFT)
C
C     CHECK WHETHER AN ERROR HAS BEEN DETECTED
C
      IF (IERR.EQ.0) THEN
C
C       SET UP THE WORK AREA.
C
        CALL STKSET(LDSTAK, 4)
        NALL0 = STKST(1)
C
        IFP = 4
C
        ACOV = STKGET(LAGMAX+1, IFP)
        PRHO = STKGET(LAGMAX, IFP)
        AIC = STKGET(LAGMAX+1, IFP)
        FTEST = STKGET(2*LAGMAX, IFP)
        PHI = STKGET(LAGMAX, IFP)
        WORK = STKGET(LAGMAX, IFP)
        YF = STKGET(N, IFP)
        SDRHO = WORK
C
        IF (IERR.EQ.0) THEN
C
          NEWPG = .FALSE.
          NTIMES = 0
C
C         CHECK WHETHER THERE IS MORE THAN ONE DIFFERENCE FACTOR.
C
          IF (NFAC.LE.1) THEN
            CALL DCOPY(N, Y, 1, RSTAK(YF), 1)
          ELSE
C
C           CREATE NEW DATA BY APPLYING DIFFERENCE FACTORS BEYOND THE
C           FIRST.
C
            CALL DIFSER(Y, N, NFAC-1, ND(2), IOD(2), RSTAK(YF), NYF)
          END IF
          NYD = N
C
C         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
C
          CALL ACFMN (RSTAK(YF), NYD, MIN(LAGMAX, NYD-1),
     +       RSTAK(ACOV+1), RSTAK(SDRHO), YMEAN, RSTAK(PRHO),
     +       RSTAK(AIC), RSTAK(FTEST), RSTAK(PHI), IAR, OSPVAR,
     +       RSTAK(ACOV), LAGMAX+1, LAGMAX+1, CHIA, CHIAP, RSTAK(WORK),
     +       1)
C
          YSD = SQRT(RSTAK(ACOV) * N / (N-1))
C
C         CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
C
          CALL ACFOUT (YMEAN, YSD, NYF, NYF, MIN(LAGMAX, NYD-1),
     +       RSTAK(ACOV+1), RSTAK(SDRHO), RSTAK(PRHO), NDUM, RSTAK(AIC),
     +       LAGMAX+1, RSTAK(FTEST), IAR, RSTAK(PHI), OSPVAR, CHIA,
     +       CHIAP, LAGMAX, .FALSE., 0.0D0, DIFFER, NEWPG, NFAC, ND,
     +       IOD, NTIMES)
C
          NEWPG = .TRUE.
C
C         COMPUTE CORRELATION ANALYSIS FOR FIRST DIFFERENCE FACTOR
C         APPLIED 1 TO ND(1) TIMES
C
          IF ((NFAC.GE.1) .AND. (ND(1).GE.1)) THEN
            DO 50 I = 1, ND(1)
C
               CALL DIFSER(RSTAK(YF), NYD, NFAC-1, ND(2), IOD(2),
     +           RSTAK(YF), NYF)
C
C              CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
C
             CALL ACFMN (RSTAK(YF), NYD, MIN(LAGMAX, NYD-1),
     +          RSTAK(ACOV+1), RSTAK(SDRHO), YMEAN, RSTAK(PRHO),
     +          RSTAK(AIC), RSTAK(FTEST), RSTAK(PHI), IAR, OSPVAR,
     +          RSTAK(ACOV), LAGMAX+1, LAGMAX+1, CHIA, CHIAP,
     +          RSTAK(WORK), 1)
C
               YSD = SQRT(RSTAK(ACOV) * N / (N-1))
C
C           CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
C
             CALL ACFOUT (YMEAN, YSD, NYF, NYF, MIN(LAGMAX, NYD-1),
     +          RSTAK(ACOV+1), RSTAK(SDRHO), RSTAK(PRHO), NDUM,
     +          RSTAK(AIC), LAGMAX+1, RSTAK(FTEST), IAR, RSTAK(PHI),
     +          OSPVAR, CHIA, CHIAP, LAGMAX, .FALSE., 0.0D0, DIFFER,
     +          NEWPG, NFAC, ND, IOD, I)
C
   50       CONTINUE
          END IF
        END IF
C
        CALL STKCLR(NALL0)
      END IF
C
      IF (IERR.NE.0) THEN
C
C     PRINT PROPER CALL SEQUENCE AND RETURN
C
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL ACFD (Y, N, LAGMAX, NFAC, ND, IOD, LDSTAK)')
      END
*ACFDTL
      SUBROUTINE ACFDTL (NDF, ND, IOD, NTIMES)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRINTS TITLING FOR ACORRD.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   NDF,NTIMES
C
C  ARRAY ARGUMENTS
      INTEGER
     +   IOD(*),ND(*)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT,ISTOP
      CHARACTER
     +   ICOM*1,IPER*1,IPUNCT*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VARIABLE.
C     CHARACTER*1 ICOM
C        THE HOLLERITH VALUE -,- (COMMA)
C     INTEGER IOD(NDF)
C        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
C     CHARACTER*1 IPER
C        THE HOLLERITH VALUE -.- (PERIOD)
C     INTEGER IPRT
C        THE UNIT NUMBER OF THE DEVICE USED FOR PRINTED
C        OUTPUT.
C     CHARACTER*1 IPUNCT
C        THE HOLLERITH VALUE OF EITHER COMMA OR PERIOD.
C     INTEGER ISTOP
C        ONE LESS THAN THE NUMBER OF DIFFERENCE FACTORS.
C     INTEGER ND(NDF)
C        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE
C        FACTORS ARE TO BE APPLIED.
C     INTEGER NDF
C        THE NUMBER OF DIFFERENCE FACTORS.
C     INTEGER NTIMES
C        THE NUMBER OF TIMES THE DIFFERENCING FACTOR HAS BEEN APPLIED.
C
      DATA ICOM/','/, IPER/'.'/
C
      CALL IPRINT (IPRT)
C
      IF (NDF .LE. 1) GO TO 10
C
      ISTOP = NDF - 1
      IPUNCT = IPER
      IF (NTIMES .GE. 1) IPUNCT = ICOM
      WRITE(IPRT, 1000)
      IF (NDF .EQ. 2)  WRITE(IPRT, 1001) ND(2), IOD(2), IPER
      IF (NDF .GE. 3) WRITE(IPRT, 1001)
     +   (ND(I), IOD(I), ICOM, I = 1, ISTOP), ND(NDF), IOD(NDF), IPUNCT
      GO TO 20
C
   10 WRITE(IPRT, 1002)
C
   20 IF (NTIMES .EQ. 0) RETURN
C
      IF (NDF .GE. 2) WRITE(IPRT, 1003) NTIMES, IOD(1)
      IF (NDF .EQ. 1) WRITE(IPRT, 1004) NTIMES, IOD(1)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(//47H SERIES ANALYZED IS INPUT SERIES DIFFERENCED BY/)
 1001 FORMAT(3X, 3(I3, ' FACTOR(S) OF ORDER ', I3, A1, 1X)/)
 1002 FORMAT(//' SERIES ANALYZED IS ORIGINAL INPUT SERIES'/)
 1003 FORMAT(4X, 34H AND, IN ADDITION, DIFFERENCED BY , I3,
     +   18H FACTORS OF ORDER , I3, '.'//)
 1004 FORMAT(4X, 16H DIFFERENCED BY , I3, 18H FACTORS OF ORDER ,
     +   I3, '.'//)
      END
*ACFER
      SUBROUTINE ACFER(NMSUB, N, LAGMAX, LACOV, LDSTAK, LDSMIN,
     +  DIFFER, NFAC, ND, IOD, ISFFT, LYFFT, NFFT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE ERROR CHECKING ROUTINE FOR THE ACF FAMILY
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LACOV,LAGMAX,LDSMIN,LDSTAK,LYFFT,N,NFAC,NFFT
      LOGICAL
     +   DIFFER,ISFFT
C
C  ARRAY ARGUMENTS
      INTEGER
     +   IOD(*),ND(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I
      LOGICAL
     +   HEAD
C
C  LOCAL ARRAYS
      LOGICAL
     +   ERR(15)
      CHARACTER
     +   LLACOV(8)*1,LLAGMX(8)*1,LLDS(8)*1,LLGMX1(8)*1,
     +   LLYFFT(8)*1,LN(8)*1,LNFFT(8)*1,LNM1(8)*1,LONE(8)*1,
     +   LTHREE(8)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,ERDF
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL DIFFER
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
C     LOGICAL ERR(15)
C        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C     INTEGER IOD(NFAC)
C        THE ORDER OF EACH OF THE DIFFERENCE VACTORS
C     LOGICAL ISFFT
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE REQUESTED.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     CHARACTER*1 LLACOV(8), LLAGMX(8), LLDS(8), LLGMX1(8), LLYFFT(8),
C    *  LN(8), LNFFT(8), LNM1(8), LONE(8), LTHREE(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
C        CHECKED FOR ERRORS.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER ND(NFAC)
C        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE FACTORS
C        ARE TO BE APPLIED
C     INTEGER NFAC
C        THE NUMBER OF FACTORS.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C
C
C     SET UP NAME ARRAYS
C
      DATA
     + LLACOV(1), LLACOV(2), LLACOV(3), LLACOV(4), LLACOV(5),
     + LLACOV(6), LLACOV(7), LLACOV(8) /'L','A','C','O','V',' ',' ',' '/
      DATA
     + LLAGMX(1), LLAGMX(2), LLAGMX(3), LLAGMX(4), LLAGMX(5),
     + LLAGMX(6), LLAGMX(7), LLAGMX(8) /'L','A','G','M','A','X',' ',' '/
      DATA
     + LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     + LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA
     + LLGMX1(1), LLGMX1(2), LLGMX1(3), LLGMX1(4), LLGMX1(5),
     + LLGMX1(6), LLGMX1(7), LLGMX1(8) /'L','A','G','M','A','X','+','1'/
      DATA
     + LLYFFT(1), LLYFFT(2), LLYFFT(3), LLYFFT(4), LLYFFT(5),
     + LLYFFT(6), LLYFFT(7), LLYFFT(8) /'L','Y','F','F','T',' ',' ',' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5),
     + LN(6), LN(7), LN(8) /'N',' ',' ',' ',' ',' ',' ',' '/
      DATA
     + LNM1(1), LNM1(2), LNM1(3), LNM1(4), LNM1(5),
     + LNM1(6), LNM1(7), LNM1(8) /'(','N','-','1',')',' ',' ',' '/
      DATA
     + LNFFT(1), LNFFT(2), LNFFT(3), LNFFT(4), LNFFT(5),
     + LNFFT(6), LNFFT(7), LNFFT(8) /'N','F','F','T',' ',' ',' ',' '/
      DATA
     + LONE(1), LONE(2), LONE(3), LONE(4), LONE(5),
     + LONE(6), LONE(7), LONE(8) /'O','N','E',' ',' ',' ',' ',' '/
      DATA
     + LTHREE(1), LTHREE(2), LTHREE(3), LTHREE(4), LTHREE(5),
     + LTHREE(6), LTHREE(7), LTHREE(8) /'T','H','R','E','E',' ',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
      DO 10 I = 1, 15
        ERR(I) = .FALSE.
   10 CONTINUE
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 3, 2, HEAD, ERR(1), LTHREE)
C
      IF (.NOT.ERR(1)) THEN
C
        CALL EISII(NMSUB, LLAGMX, LAGMAX, 1, N-1, 1, HEAD, ERR(2), LONE,
     +    LNM1)
C
        IF (DIFFER) CALL ERDF(NMSUB, NFAC, ND, IOD, N, HEAD, ERR(3))
C
        IF (.NOT.ERR(2)) THEN
C
          CALL EISGE(NMSUB, LLACOV, LACOV, LAGMAX+1, 2, HEAD, ERR(4),
     +      LLGMX1)
C
          CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR(5), LLDS)
C
          IF (ISFFT)
     +      CALL EISGE(NMSUB, LLYFFT, LYFFT, NFFT, 2, HEAD, ERR(6),
     +      LNFFT)
        END IF
      END IF
C
      DO 20 I = 1, 15
        IF (ERR(I)) IERR = 1
   20 CONTINUE
C
      RETURN
C
      END
*ACFF
      SUBROUTINE ACFF (YFFT, N, LYFFT, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
C     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
C     USING AN FFT (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,LYFFT,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YFFT(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN,YSD
      INTEGER
     +   IAR,IFP,IPRT,LACOV,LAGMAX,LAIC,LDSMIN,NALL0,NFAC,NFFT,
     +   SDRHO,WORK
      LOGICAL
     +   DIFFER,ISFFT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),AIC(101),FTEST(2,100),PHI(100),PRHO(100),RHO(100),
     +   RSTAK(12)
      INTEGER
     +   IOD(1),ND(1),NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACFER,ACFMNF,ACFOUT,FFTLEN,IPRINT,LDSCMP,SETLAG,STKCLR,
     +   STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (ACOV(2),RHO(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(101)
C        THE AUTOCOVARIANCE VECTOR.
C     DOUBLE PRECISION AIC(101)
C       THE ARRAY CONTAINING AKAIKES CRITERIA FOR EACH ORDER.
C     DOUBLE PRECISION CHIA, CHIAP
C        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
C        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
C        ARE STORED.
C     LOGICAL DIFFER
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FTEST(2, 100)
C        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .NE. 0 ERRORS WERE DETECTED.
C     INTEGER IFP
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE FLOATING
C        POINT VARIABLES ARE SINGLE (IFP=3) OR DOUBLE (IFP=4) PRECISION.
C     INTEGER IOD(1)
C        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     LOGICAL ISFFT
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE REQUESTED.
C     INTEGER LAIC
C        THE LENGTH OF THE VECTOR AIC.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
C     INTEGER ND(1)
C        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
C     INTEGER NDUM(1)
C        A DUMMY ARRAY.
C     INTEGER NFAC
C        THE NUMBER OF DIFFERENCE FACTORS
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C     DOUBLE PRECISION OSPVAR
C        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED ORDER (IAR).
C     DOUBLE PRECISION PHI(100)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
C        ORDER.
C     DOUBLE PRECISION PRHO(100)
C        THE ARRAY CONTAINING THE PARITAL ACF ESTIMATES.
C     DOUBLE PRECISION RHO(100)
C        THE ARRAY CONTAINING THE ACF ESTIMATES.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER SDRHO
C        THE STARTING LOCATION IN DSTAK FOR
C        THE ARRAY CONTAINING THE STANDARD ERRORS OF THE ACF ESTIMATES.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE WORK AREA FOR WORK.
C     DOUBLE PRECISION YFFT(LYFFT)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YSD
C        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'A',       'C',       'F',       'F',       ' ',       ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      LACOV = 101
      LAIC = 101
      DIFFER = .FALSE.
      NFAC = 1
      ND(1) = 0
      IOD(1) = 0
      ISFFT = .TRUE.
C
      IF (N.GE.3) THEN
C
C     SET NUMBER OF ACF TO BE COMPUTED
C     AND LENGTH OF EXTENDED SERIES
C
         CALL SETLAG(N, LAGMAX)
         CALL FFTLEN(N+LAGMAX, 4, NFFT)
      END IF
C
      CALL LDSCMP(1, 0, 0, 0, 0, 0, 'D', NFFT, LDSMIN)
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL ACFER(NMSUB, N, LAGMAX, LACOV, LDSTAK, LDSMIN,
     +  DIFFER, NFAC, ND, IOD, ISFFT, LYFFT, NFFT)
C
C     CHECK WHETHER AN ERROR HAS BEEN DETECTED
C
      IF (IERR.EQ.0) THEN
C
C       SET UP THE WORK AREA.
C
        CALL STKSET (LDSTAK, 4)
        NALL0 = STKST(1)
C
        IFP = 4
C
        WORK = STKGET(NFFT, IFP)
        SDRHO = WORK
C
        IF (IERR.EQ.0) THEN
C
C         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
C
          CALL ACFMNF (YFFT, N, NFFT, LAGMAX, RHO, RSTAK(SDRHO), YMEAN,
     +       PRHO, AIC, FTEST, PHI, IAR, OSPVAR, ACOV, LACOV, LAIC,
     +       CHIA, CHIAP, LYFFT, RSTAK(WORK), NFFT, 1)
C
          YSD = SQRT (ACOV(1) * N / (N - 1))
C
C         CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
C
          CALL ACFOUT(YMEAN, YSD, N, N, LAGMAX, RHO, RSTAK(SDRHO), PRHO,
     +       NDUM, AIC, LAIC, FTEST, IAR, PHI, OSPVAR, CHIA, CHIAP,
     +       LAGMAX, .FALSE., 0.0D0, .FALSE., .FALSE., 0, NDUM, NDUM,
     +       0)
        END IF
C
        CALL STKCLR(NALL0)
      END IF
C
      IF (IERR.NE.0) THEN
C
C     PRINT PROPER CALL SEQUENCE AND RETURN
C
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL ACFF (YFFT, N, LYFFT, LDSTAK)')
      END
*ACFFS
      SUBROUTINE ACFFS (YFFT, N, LYFFT, LDSTAK, LAGMAX, LACOV, ACOV,
     +   IAR, PHI, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
C     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
C     USING A FFT WITH THE COMPUTED ACVF ESTIMATES RETURNED TO THE USERS
C     ROUTINE (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IAR,LACOV,LAGMAX,LDSTAK,LYFFT,N,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),PHI(*),YFFT(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN,YSD
      INTEGER
     +   AIC,FTEST,I,IFP,IPRT,LDSMIN,NALL0,NFAC,NFFT,PRHO,SDRHO,
     +   WORK
      LOGICAL
     +   DIFFER,ISFFT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   IOD(1),ND(1),NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACFER,ACFMNF,ACFOUT,FFTLEN,IPRINT,LDSCMP,STKCLR,STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV)
C        THE AUTOCOVARIANCE VECTOR.
C     INTEGER AIC
C        THE STARTING LOCATION IN DSTAK FOR
C        THE ARRAY CONTAINING THE AKAIKES CRITERION FOR EACH ORDER.
C     DOUBLE PRECISION CHIA, CHIAP
C        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
C        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
C        ARE STORED.
C     LOGICAL DIFFER
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER FTEST
C        THE STARTING LOCATION IN DSTAK FOR
C        THE ARRAY CONTAINING THE PARTIAL F RATIO AND PROBABILITIES
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C     INTEGER IFP
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE FLOATING
C        POINT VARIABLES ARE SINGLE (IFP=3) OR DOUBLE (IFP=4) PRECISION.
C     INTEGER IOD(1)
C        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     LOGICAL ISFFT
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE REQUESTED.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
C     INTEGER ND(1)
C        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
C     INTEGER NDUM(1)
C        A DUMMY DIMENSIONED VARIABLE.
C     INTEGER NFAC
C        THE NUMBER OF DIFFERENCE FACTORS
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO OUTPUT IS MADE.
C     DOUBLE PRECISION OSPVAR
C        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
C     DOUBLE PRECISION PHI(LAGMAX)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
C        ORDER.
C     INTEGER PRHO
C        THE STARTING LOCATION IN THE WORK AREA FOR PRHO.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER SDRHO
C        THE STARTING LOCATION IN THE WORK AREA FOR SDRHO.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE WORK AREA FOR WORK.
C     DOUBLE PRECISION YFFT(LYFFT)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YSD
C        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'A',       'C',       'F',       'F',       'S',       ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      DIFFER = .FALSE.
      NFAC = 1
      ND(1) = 0
      IOD(1) = 0
      ISFFT = .TRUE.
C
C     SET LENGTH OF EXTENDED SERIES
C
      NFFT = 0
      IF ((N.GE.3) .AND. (LAGMAX.GE.1)) CALL FFTLEN(N+LAGMAX, 4, NFFT)
C
      CALL LDSCMP(4, 0, 0, 0, 0, 0, 'D', (4*LAGMAX+1) + NFFT, LDSMIN)
C
      CALL ACFER(NMSUB, N, LAGMAX, LACOV, LDSTAK, LDSMIN,
     +  DIFFER, NFAC, ND, IOD, ISFFT, LYFFT, NFFT)
C
C     CHECK WHETHER AN ERROR HAS BEEN DETECTED
C
      IF (IERR.EQ.0) THEN
C
C       SET UP THE WORK AREA.
C
        CALL STKSET(LDSTAK, 4)
        NALL0 = STKST(1)
C
        IFP = 4
C
        WORK = STKGET(NFFT, IFP)
        PRHO = STKGET(LAGMAX, IFP)
        AIC = STKGET(LAGMAX+1, IFP)
        FTEST = STKGET(2*LAGMAX, IFP)
        SDRHO = WORK
C
        IF (IERR.EQ.0) THEN
C
C         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
C
          CALL ACFMNF (YFFT, N, NFFT, LAGMAX, ACOV(2), RSTAK(SDRHO),
     +       YMEAN, RSTAK(PRHO), RSTAK(AIC), RSTAK(FTEST), PHI,
     +       IAR, OSPVAR, ACOV, LACOV, LAGMAX+1, CHIA, CHIAP,
     +       LYFFT, RSTAK(WORK), NFFT, NPRT)
C
          YSD = SQRT (ACOV(1) * N / (N - 1))
C
C         CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
C
          IF ((NPRT.NE.0) .OR. (ACOV(1).EQ.0.0D0))
     +       CALL ACFOUT (YMEAN, YSD, N, N, LAGMAX, ACOV(2),
     +       RSTAK(SDRHO),
     +       RSTAK(PRHO), NDUM, RSTAK(AIC), LAGMAX+1, RSTAK(FTEST), IAR,
     +       PHI, OSPVAR, CHIA, CHIAP, LAGMAX, .FALSE., 0.0D0, .FALSE.,
     +       .FALSE., 0, NDUM, NDUM, 0)
C
          IF (NPRT.NE.0) THEN
            DO 50 I = 1, LAGMAX
               ACOV(I+1) = ACOV(I+1) * ACOV(1)
   50       CONTINUE
          END IF
C
        END IF
C
        CALL STKCLR(NALL0)
      END IF
C
      IF (IERR.NE.0) THEN
C
C     PRINT PROPER CALL SEQUENCE AND RETURN
C
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL ACFFS (YFFT, N, LYFFT, LDSTAK,'/
     +  '      +            LAGMAX, LACOV, ACOV, IAR, PHI, NPRT)')
      END
*ACFLST
      SUBROUTINE ACFLST (RHO, SDRHO, NLPPA, LAGMAX, IFMISS, CHIA,
     +   NDFCHI, CHIAP)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE ACTUALLY LISTS THE AUTOCORRELATIONS OR
C     PARTIAL AUTOCORRELATIONS AND OTHER PERTINENT INFORMATION.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CHIA,CHIAP
      INTEGER
     +   LAGMAX,NDFCHI
      LOGICAL
     +   IFMISS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RHO(*),SDRHO(*)
      INTEGER
     +   NLPPA(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,IMAX,IMIN,IPRT,LAG,NPERL
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CHIA, CHIAP
C        THE VARIABLES IN CHICH THE CHI SQUARE STATISTIC AND
C        PROBABILITY FOR THE AUTOCORRELATIONS ARE STORED.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     LOGICAL IFMISS
C        THE INDICATOR VARIABLE USED TO DETERMINE
C        WHETHER THE INPUT SERIES HAS MISSING DATA OR NOT.
C     INTEGER IMAX, IMIN
C        THE INDEX VALUES OF THE FIRST AND LAST OBSERVATION
C        TO BE PRINTED PER LINE
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT
C     INTEGER LAG
C        THE LAG VALUE OF THE AUTOCORRELATION OR PARTIAL
C        AUTOCORRELATION BEING PRINTED.
C     INTEGER LAGMAX
C        THE NUMBER OF AUTOCORRELATIONS OR PARTIAL AUTOCORRELATIONS
C        TO BE PRINTED.
C     INTEGER NDFCHI
C        THE DEGREES OF FREEDOM FOR THE CHI SQUARED STATISTIC.
C     INTEGER NLPPA(LAGMAX)
C        THE ARRAY IN WHICH THE NUMBER OF LAGGED PRODUCT PAIRS USED TO
C        COMPUTE EACH AUTOCORRELATION IS STORED
C     INTEGER NPERL
C        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
C     DOUBLE PRECISION RHO(LAGMAX)
C        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED.
C     DOUBLE PRECISION SDRHO(LAGMAX)
C        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
C        ARE STORED
C
C
      FPLM = D1MACH(2)
C
      CALL IPRINT(IPRT)
C
      NPERL = 12
      DO 30 I = 1, LAGMAX, NPERL
         IMIN = I
         IMAX = MIN(I + NPERL - 1, LAGMAX)
         WRITE(IPRT, 1000) (LAG, LAG = IMIN, IMAX)
         WRITE(IPRT, 1001) (RHO(LAG), LAG = IMIN, IMAX)
         WRITE(IPRT, 1002) (SDRHO(LAG), LAG = IMIN, IMAX)
         IF (IFMISS) WRITE(IPRT, 1003) (NLPPA(LAG), LAG = IMIN, IMAX)
   30 CONTINUE
C
      IF (SDRHO(LAGMAX) .EQ. FPLM) WRITE(IPRT, 1004) FPLM
C
      WRITE (IPRT, 1005) CHIA, NDFCHI, CHIAP
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/19H LAG               , 12(1X, I6))
 1001 FORMAT( 19H ACF               , 12(2X, F5.2))
 1002 FORMAT( 19H STANDARD ERROR    , 12(2X, F5.2))
 1003 FORMAT( 19H NO. OF OBS. USED  , 12(1X, I6))
 1004 FORMAT(///5X, F5.2, 38H INDICATES VALUE COULD NOT BE COMPUTED,
     +   ' DUE TO MISSING DATA.')
 1005 FORMAT(///33H THE CHI SQUARE TEST STATISTIC OF/
     +   40H THE NULL HYPOTHESIS OF WHITE NOISE    =, G21.4/
     +   40H DEGREES OF FREEDOM                    =, I17/
     +   40H OBSERVED SIGNIFICANCE LEVEL           =, F17.4)
      END
*ACFM
      SUBROUTINE ACFM (Y, YMISS, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
C     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
C     WITH MISSING VALUES (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMISS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN,YSD
      INTEGER
     +   IAR,IPRT,LACOV,LAGLST,LAGMAX,LAIC,LDSMIN,LDSTAK,LYFFT,
     +   NFAC,NFFT,NPRT
      LOGICAL
     +   DIFFER,ISFFT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),AIC(101),FTEST(2,100),PHI(100),PRHO(100),RHO(100),
     +   SDRHO(100),WORK(100)
      INTEGER
     +   IOD(1),ND(1),NDUM(1),NLPPA(101)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACFER,ACFMNM,ACFOUT,IPRINT,SETLAG
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (ACOV(2),RHO(1))
      EQUIVALENCE (WORK(1),SDRHO(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(101)
C        THE AUTOCOVARIANCE VECTOR.
C     DOUBLE PRECISION AIC(101)
C        THE ARRAY CONTAINING THE AKAIKES CRITERION FOR EACH ORDER.
C     DOUBLE PRECISION CHIA, CHIAP
C        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
C        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
C        ARE STORED.
C     LOGICAL DIFFER
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
C     DOUBLE PRECISION FTEST(2, 100)
C        THE ARRAY CONTAINING THE PARTIAL F RATIO AND PROBABILITIES
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IOD(1)
C        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     LOGICAL ISFFT
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGLST
C        THE LAST LAG BEFORE MISSING DATA CAUSED THE ACVF OF THE
C        SERIES NOT TO BE COMPUTED.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE REQUESTED.
C     INTEGER LAIC
C        THE LENGTH OF THE VECTOR AIC.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LYFFT
C        A DUMMY VARIABLE.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER ND(1)
C        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
C     INTEGER NDUM(1)
C        A DUMMY ARRAY.
C     INTEGER NFAC
C        THE NUMBER OF DIFFERENCE FACTORS
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO OUTPUT IS MADE.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     INTEGER NLPPA(101)
C        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
C        USED TO COMPUTE EACH ACVF ESTIMATE.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C     DOUBLE PRECISION OSPVAR
C        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
C     DOUBLE PRECISION PHI(100)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
C        ORDER.
C     DOUBLE PRECISION PRHO(100)
C        THE ARRAY CONTAINING THE PACF ESTIMATES.
C     DOUBLE PRECISION RHO(100)
C        THE ARRAY CONTAINING THE ACF ESTIMATES.
C     DOUBLE PRECISION SDRHO(100)
C        THE ARRAY CONTAINING THE STANDARD ERRORS OF THE ACF.
C     DOUBLE PRECISION WORK(100)
C        THE ARRAY CONTAINING WORK AREA FOR THE PACF COMPUTATIONS.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YMISS
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER
C        OR NOT AN OBSERVATION IN THE SERIES IS MISSING.
C        IF Y(I) .EQ. YMISS, THE VALUE IS ASSUMED MISSING.
C        IF Y(I) .NE. YMISS, THE VALUE IS ASSUMED NOT MISSING.
C     DOUBLE PRECISION YSD
C        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'A',       'C',       'F',       'M',       ' ',       ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      LAGMAX = 1
      LACOV = 101
      LAIC = 101
      NPRT = 1
      LDSMIN = 0
      LDSTAK = 0
      DIFFER = .FALSE.
      NFAC = 1
      ND(1) = 0
      IOD(1) = 0
      ISFFT = .FALSE.
      LYFFT = N
      NFFT = N
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL ACFER(NMSUB, N, LAGMAX, LACOV, LDSTAK, LDSMIN,
     +  DIFFER, NFAC, ND, IOD, ISFFT, LYFFT, NFFT)
C
C     CHECK WHETHER AN ERROR HAS BEEN DETECTED
C
      IF (IERR.EQ.0) THEN
C
C       SET LARGEST LAG TO BE USED.
C
        CALL SETLAG(N, LAGMAX)
C
C       CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
C
        CALL ACFMNM (Y, YMISS, N, LAGMAX, RHO, SDRHO, NLPPA, YMEAN,
     +     PRHO, AIC, FTEST, PHI, IAR, OSPVAR, ACOV, LACOV, LAIC, CHIA,
     +     CHIAP, LAGLST, WORK, NPRT)
C
        YSD = ACOV(1)
        IF (LAGLST.GE.0) YSD = SQRT (ACOV(1) * N / (N - 1))
C
C       CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
C
        CALL ACFOUT (YMEAN, YSD, N, NLPPA(1), LAGMAX, RHO, SDRHO, PRHO,
     +     NLPPA, AIC, LAGMAX+1, FTEST, IAR, PHI, OSPVAR, CHIA, CHIAP,
     +     LAGLST, .TRUE., YMISS, .FALSE., .FALSE., 0, NDUM, NDUM, 0)
      END IF
C
      IF (IERR.NE.0) THEN
C
C     PRINT PROPER CALL SEQUENCE AND RETURN
C
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   30H       CALL ACFM (Y, YMISS, N))
      END
*ACFMN
      SUBROUTINE ACFMN(Y, N, LAGMAX, RHO, SDRHO, YMEAN, PRHO, AIC,
     +   FTEST, PHI, IAR, OSPVAR, ACOV, LACOV, LAIC, CHIA, CHIAP, WORK,
     +   NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN SUBROUTINE FOR COMPUTING AUTOCORRELATIONS AND
C     PARTIAL AUTOCORRELATIONS OF A TIME SERIES .
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN
      INTEGER
     +   IAR,LACOV,LAGMAX,LAIC,N,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),AIC(*),FTEST(2,*),PHI(*),PRHO(*),RHO(*),SDRHO(*),
     +   WORK(*),Y(*)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACFSD,ACVF,AOS,CHIRHO
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV)
C        THE AUTOCOVARIANCE FUNCTION ESTIMATE VECTOR.
C     DOUBLE PRECISION AIC(LAIC)
C        THE ARRAY CONTAINING AKAIAES CRITERION FOR EACH ORDER.
C     DOUBLE PRECISION CHIA, CHIAP
C        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
C        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
C        ARE STORED.
C     DOUBLE PRECISION FTEST(2, LAGMAX)
C        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAIC
C        THE LENGTH OF THE VECTOR AIC.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO OUTPUT IS MADE.
C     DOUBLE PRECISION OSPVAR
C        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED ORDER (IAR).
C     DOUBLE PRECISION PHI(LAGMAX)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
C        ORDER (IAR).
C     DOUBLE PRECISION PRHO(LAGMAX)
C        THE ARRAY IN WHICH THE PARTIAL AUTOCORRELATIONS ARE STORED
C     DOUBLE PRECISION RHO(LAGMAX)
C        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
C     DOUBLE PRECISION SDRHO(LAGMAX)
C        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
C     DOUBLE PRECISION WORK(LAGMAX)
C        AN ARRAY USED IN THE COMPUTATIONS OF THE PARTIAL
C        AUTOCORRELATIONS COEFFICIENTS.
C        ARE STORED
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED SERIES
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C
C     COMPUTE AUTOCOVARIANCESS AND STANDARD DEVIATION OF THE SERIES.
C
      CALL ACVF(Y, N, YMEAN, ACOV, LAGMAX, LACOV)
C
      IF (ACOV(1) .EQ. 0.0D0) RETURN
C
C     COMPUTE PARTIAL AUTOCORRELATIONS AND THE AUTOREGRESSIVE MODEL
C     ORDER SELECTION STATISTICS.
C
      CALL AOS (N, LAGMAX, ACOV, PRHO, IAR, OSPVAR, PHI, WORK,
     +   AIC, FTEST, LACOV, LAIC)
C
      IF (NPRT .EQ. 0) RETURN
C
C     COMPUTE AUTOCORRELATIONS
C
      DO 10 I = 1, LAGMAX
         RHO(I) = ACOV(I+1) / ACOV(1)
   10 CONTINUE
C
C     COMPUTE STANDARD ERROR OF AUTOCORRELATIONS.
C
      CALL ACFSD (RHO, SDRHO, LAGMAX, N)
C
C     COMPUTE CHI STATISTIC BASED ON AUTOCORRELATION VALUES
C
      CALL CHIRHO (RHO, N, LAGMAX, CHIA, CHIAP)
C
      RETURN
      END
*ACFMNF
      SUBROUTINE ACFMNF (YFFT, N, NFFT, LAGMAX, RHO, SDRHO, YMEAN,
     +   PRHO, AIC, FTEST, PHI, IAR, OSPVAR, ACOV, LACOV, LAIC,
     +   CHIA, CHIAP, LYFFT, WORK, LWORK, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN SUBROUTINE FOR COMPUTING AUTOCORRELATIONS AND
C     PARTIAL AUTOCORRELATIONS OF A TIME SERIES .
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN
      INTEGER
     +   IAR,LACOV,LAGMAX,LAIC,LWORK,LYFFT,N,NFFT,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),AIC(*),FTEST(2,*),PHI(*),PRHO(*),RHO(*),SDRHO(*),
     +   WORK(*),YFFT(*)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACFSD,ACVFF,AOS,CHIRHO
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV)
C        THE AUTOCOVARIANCE FUNCTION ESTIMATE VECTOR.
C     DOUBLE PRECISION AIC(LAIC)
C        THE AKAIKES INFORMATION CRITERION VECTOR.
C     DOUBLE PRECISION CHIA, CHIAP
C        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
C        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
C        ARE STORED.
C     DOUBLE PRECISION FTEST(2, LAGMAX)
C        THE ARRAY IN WHICH THE PARTIAL F RATIOS AND PROBABILITIES
C        ARE STORED.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAIC
C        THE LENGTH OF THE VECTOR AIC.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR WORK.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO OUTPUT IS MADE.
C     DOUBLE PRECISION OSPVAR
C        THE ONE STEP PREDICTION VARIANCE.
C     DOUBLE PRECISION PHI(LAGMAX)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
C        ORDER (IAR).
C     DOUBLE PRECISION PRHO(LAGMAX)
C        THE ARRAY IN WHICH THE PARTIAL AUTOCORRELATIONS ARE STORED
C     DOUBLE PRECISION RHO(LAGMAX)
C        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
C     DOUBLE PRECISION SDRHO(LAGMAX)
C        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
C        ARE STORED
C     DOUBLE PRECISION WORK(LWORK)
C        A WORK ARRAY.
C     DOUBLE PRECISION YFFT(LYFFT)
C        THE VECTOR CONTAINING THE OBSERVED SERIES
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C
C     COMPUTE AUTOCOVARIANCESS AND STANDARD DEVIATION OF THE SERIES.
C
      CALL ACVFF(YFFT, N, NFFT, YMEAN, ACOV, LAGMAX, LACOV, LYFFT, WORK,
     +   LWORK)
C
      IF (ACOV(1) .EQ. 0.0D0) RETURN
C
C     COMPUTE PARTIAL AUTOCORRELATIONS AND AUTOREGRESSIVE ORDER
C     SELECTION STATISTICS.
C
      CALL AOS (N, LAGMAX, ACOV, PRHO, IAR, OSPVAR, PHI, WORK,
     +   AIC, FTEST, LACOV, LAIC)
C
      IF (NPRT .EQ. 0) RETURN
C
C     COMPUTE AUTOCORRELATIONS
C
      DO 10 I = 1, LAGMAX
         RHO(I) = ACOV(I+1) / ACOV(1)
   10 CONTINUE
C
C     COMPUTE STANDARD ERROR OF AUTOCORRELATIONS.
C
      CALL ACFSD (RHO, SDRHO, LAGMAX, N)
C
C     COMPUTE CHI STATISTIC BASED ON AUTOCORRELATION VALUES
C
      CALL CHIRHO (RHO, N, LAGMAX, CHIA, CHIAP)
C
      RETURN
      END
*ACFMNM
      SUBROUTINE ACFMNM(Y, YMISS, N, LAGMAX, RHO, SDRHO, NLPPA, YMEAN,
     +   PRHO, AIC, FTEST, PHI, IAR, OSPVAR, ACOV, LACOV, LAIC, CHIA,
     +   CHIAP, LAGLST, WORK, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN SUBROUTINE FOR COMPUTING AUTOCORRELATIONS AND
C     PARTIAL AUTOCORRELATIONS OF A TIME SERIES WITH MISSING DATA.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN,YMISS
      INTEGER
     +   IAR,LACOV,LAGLST,LAGMAX,LAIC,N,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),AIC(*),FTEST(2,*),PHI(*),PRHO(*),RHO(*),SDRHO(*),
     +   WORK(*),Y(*)
      INTEGER
     +   NLPPA(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,NUSED
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACFSDM,ACVFM,AOS,CHIRHO
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV)
C        THE AUTOCOVARIANCE FUNCTION ESTIMATE VECTOR.
C     DOUBLE PRECISION AIC(LAIC)
C        THE ARRAY CONTAINING AKAIAES CRITERION FOR EACH ORDER.
C     DOUBLE PRECISION CHIA, CHIAP
C        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
C        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
C        ARE STORED.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     DOUBLE PRECISION FTEST(2, LAGMAX)
C        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGLST
C        THE LAST LAG BEFORE MISSING DATA CAUSED THE ACVF OF THE
C        SERIES NOT TO BE COMPUTED.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
C     INTEGER LAIC
C        THE LENGTH OF THE VECTOR AIC.
C     INTEGER NLPPA(LACOV)
C        THE ARRAY CONTAINING THE NUMBERS OF LAGGED PRODUCT PAIRS
C        USED TO COMPUTE THE ACVF AT EACH LAG.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO OUTPUT IS MADE.
C     INTEGER NUSED
C        THE NUMBER OF ACTIVE (NOT MISSING) OBSERVATIONS IN THE SERIES.
C     DOUBLE PRECISION OSPVAR
C        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED ORDER (IAR).
C     DOUBLE PRECISION PHI(LAGMAX)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
C        ORDER (IAR).
C     DOUBLE PRECISION PRHO(LAGMAX)
C        THE ARRAY IN WHICH THE PARTIAL AUTOCORRELATIONS ARE STORED
C     DOUBLE PRECISION RHO(LAGMAX)
C        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
C     DOUBLE PRECISION SDRHO(LAGMAX)
C        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
C        ARE STORED
C     DOUBLE PRECISION WORK(LAGMAX)
C        AN ARRAY USED IN THE COMPUTATIONS OF THE PARTIAL
C        AUTOCORRELATIONS COEFFICIENTS.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED SERIES
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YMISS
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER
C        OR NOT AN OBSERVATION IN THE SERIES IS MISSING.
C        IF Y(I) .EQ. YMISS, THE VALUE IS ASSUMED MISSING.
C        IF Y(I) .NE. YMISS, THE VALUE IS ASSUMED NOT MISSING.
C
C
      FPLM = D1MACH(2)
C
C     COMPUTE AUTOCOVARIANCES OF THE SERIES WITH MISSING DATA.
C
      CALL ACVFM(Y, YMISS, N, YMEAN, ACOV, LAGMAX, LAGLST, NLPPA, LACOV)
C
      IF (NLPPA(1) .EQ. 0 .OR. ACOV(1) .EQ. 0.0D0) RETURN
C
      IF (NPRT .EQ. 0) RETURN
C
C     COMPUTE PARTIAL AUTOCORRELATIONS AND THE AUTOREGRESSIVE MODEL
C     ORDER SELECTION STATISTICS IF THERE WERE NO MISSING DATA.
C
      IF (NLPPA(1) .EQ. N) CALL AOS (N, LAGMAX, ACOV, PRHO, IAR,
     +   OSPVAR, PHI, WORK, AIC, FTEST, LACOV, LAIC)
C
C     COMPUTE AUTOCORRELATIONS.
C
      DO 10 I = 1, LAGMAX
         IF (NLPPA(I+1) .GE. 1) RHO(I) = ACOV(I+1) / ACOV(1)
   10 CONTINUE
C
C     PRESET SDRHO VALUES FOR PRINTING ROUTINE
C
      DO 20 I = LAGLST, LAGMAX
         SDRHO(I) = FPLM
   20 CONTINUE
C
C     COMPUTE STANDARD ERROR OF AUTOCORRELATIONS.
C
      CALL ACFSDM (RHO, SDRHO, LAGLST, N, NLPPA(2))
C
      IF (LAGLST .EQ. 0) RETURN
C
C     COMPUTE CHI STATISTIC BASED ON AUTOCORRELATION VALUES
C
      NUSED = NLPPA(1)
C
      CALL CHIRHO (RHO, NUSED, LAGLST, CHIA, CHIAP)
C
      RETURN
      END
*ACFMS
      SUBROUTINE ACFMS (Y, YMISS, N, LAGMAX, LACOV, ACOV, AMISS, NLPPA,
     +   NPRT, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
C     CORRELATIONS OF A TIME SERIES WITH MISSING VALUES (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   AMISS,YMISS
      INTEGER
     +   LACOV,LAGMAX,LDSTAK,N,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),Y(*)
      INTEGER
     +   NLPPA(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CHIA,CHIAP,FPLM,OSPVAR,YMEAN,YSD
      INTEGER
     +   AIC,FTEST,I,IAR,IFP,IPRT,LAGLST,LDSMIN,LYFFT,NALL0,NFAC,
     +   NFFT,PHI,PRHO,SDRHO,WORK
      LOGICAL
     +   DIFFER,ISFFT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   IOD(1),ND(1),NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      INTEGER
     +   STKGET,STKST
      EXTERNAL D1MACH,STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACFER,ACFMNM,ACFOUT,IPRINT,LDSCMP,STKCLR,STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV)
C        THE AUTOCOVARIANCE VECTOR.
C     INTEGER AIC
C        THE STARTING LOCATION IN DSTAK FOR
C        THE ARRAY CONTAINING THE AKAIKES CRITERION FOR EACH ORDER.
C     DOUBLE PRECISION AMISS
C        THE MISSING VALUE CODE FOR THE RETURNED ACVF ESTIMATES
C        (VECTOR ACOV).
C     DOUBLE PRECISION CHIA, CHIAP
C        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
C        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
C        ARE STORED.
C     LOGICAL DIFFER
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER FTEST
C        THE STARTING LOCATION IN DSTAK FOR
C        THE ARRAY CONTAINING THE PARTIAL F RATIO AND PROBABILITIES
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C     INTEGER IFP
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE FLOATING
C        POINT VARIABLES ARE SINGLE (IFP=3) OR DOUBLE (IFP=4) PRECISION.
C     INTEGER IOD(1)
C        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     LOGICAL ISFFT
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGLST
C        THE LAST LAG BEFORE MISSING DATA CAUSED THE ACVF OF THE
C        SERIES NOT TO BE COMPUTED.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE REQUESTED.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
C     INTEGER ND(1)
C        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
C     INTEGER NDUM(1)
C        A DUMMY ARRAY.
C     INTEGER NFAC
C        THE NUMBER OF DIFFERENCE FACTORS
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     INTEGER NLPPA(LACOV)
C        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
C        USED TO COMPUTE EACH ACVF ESTIMATE.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO OUTPUT IS MADE.
C     DOUBLE PRECISION OSPVAR
C        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
C     INTEGER PHI
C        THE STARTING LOCATION IN DSTAK FOR THE
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
C        ORDER.
C     INTEGER PRHO
C        THE STARTING LOCATION IN THE WORK AREA FOR PRHO.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER SDRHO
C        THE STARTING LOCATION IN THE WORK AREA FOR SDRHO.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE WORK AREA FOR WORK.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YMISS
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER
C        OR NOT AN OBSERVATION IN THE SERIES IS MISSING.
C        IF Y(I) .EQ. YMISS, THE VALUE IS ASSUMED MISSING.
C        IF Y(I) .NE. YMISS, THE VALUE IS ASSUMED NOT MISSING.
C     DOUBLE PRECISION YSD
C        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'A',       'C',       'F',       'M',       'S',       ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      DIFFER = .FALSE.
      NFAC = 1
      ND(1) = 0
      IOD(1) = 0
      ISFFT = .FALSE.
      LYFFT = N
      NFFT = N
C
      IF (NPRT .EQ. 0) THEN
        LDSMIN = 0
      ELSE
        CALL LDSCMP(5, 0, 0, 0, 0, 0, 'D', 6*LAGMAX+1, LDSMIN)
      END IF
C
      CALL ACFER(NMSUB, N, LAGMAX, LACOV, LDSTAK, LDSMIN,
     +  DIFFER, NFAC, ND, IOD, ISFFT, LYFFT, NFFT)
C
C     CHECK WHETHER AN ERROR HAS BEEN DETECTED
C
      IF (IERR.EQ.0) THEN
C
C       SET UP THE WORK AREA.
C
        CALL STKSET(LDSTAK, 4)
        NALL0 = STKST(1)
C
        FPLM = D1MACH(2)
C
        AMISS = FPLM
C
        IF (NPRT.EQ.0) THEN
C
C         SPECIFY STARTING LOCATIONS IN THE STACK FOR DUMMY VARIABLES
C
          PRHO = 1
          AIC = 1
          FTEST = 1
          PHI = 1
          WORK = 1
          SDRHO = 1
        ELSE
C
          IFP = 4
C
          PRHO = STKGET(LAGMAX, IFP)
          AIC = STKGET(LAGMAX+1, IFP)
          FTEST = STKGET(2*LAGMAX, IFP)
          PHI = STKGET(LAGMAX, IFP)
          WORK = STKGET(LAGMAX, IFP)
          SDRHO = WORK
        END IF
C
        IF (IERR.EQ.0) THEN
C
C         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
C
          CALL ACFMNM (Y, YMISS, N, LAGMAX, ACOV(2), RSTAK(SDRHO),
     +       NLPPA, YMEAN, RSTAK(PRHO), RSTAK(AIC), RSTAK(FTEST),
     +       RSTAK(PHI), IAR, OSPVAR, ACOV, LACOV, LAGMAX+1, CHIA,
     +       CHIAP, LAGLST, RSTAK(WORK), NPRT)
C
          IF (LAGLST .GE. 0) THEN
            YSD = SQRT (ACOV(1) * N / (N - 1))
          ELSE
            YSD = ACOV(1)
          END IF
C
C           CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
C
          IF ((NPRT.NE.0) .OR. (ACOV(1).EQ.0.0D0))
     +      CALL ACFOUT (YMEAN, YSD, N, NLPPA(1), LAGMAX, ACOV(2),
     +         RSTAK(SDRHO), RSTAK(PRHO), NLPPA, RSTAK(AIC), LAGMAX+1,
     +         RSTAK(FTEST), IAR, RSTAK(PHI), OSPVAR, CHIA, CHIAP,
     +         LAGLST, .TRUE., YMISS, .FALSE., .FALSE., 0, NDUM, NDUM,
     +         0)
C
          IF (NPRT.NE.0) THEN
            DO 50 I = 1, LAGMAX
               ACOV(I+1) = ACOV(I+1) * ACOV(1)
   50       CONTINUE
          END IF
        END IF
C
        CALL STKCLR(NALL0)
      END IF
C
      IF (IERR.NE.0) THEN
C
C     PRINT PROPER CALL SEQUENCE AND RETURN
C
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL ACFMS (Y, YMISS, N,'/
     +  '      +            LAGMAX, LACOV, ACOV, AMISS, NLPPA, NPRT,',
     +  ' LDSTAK)')
      END
*ACFOUT
      SUBROUTINE ACFOUT (YMEAN, YSD, N, NUSED, LAGMAX, RHO, SDRHO,
     +   PRHO, NLPPA, AIC, LAIC, FTEST, IAR, PHI, OSPVAR, CHIA, CHIAP,
     +   NDFCHI, IFMISS, YMISS, DIFFER, NEWPG, NFAC, ND, IOD, NTIMES)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRINTS THE AUTOCORRELATIONS AND THEIR
C     STANDARD ERRORS, AS WELL AND THE PARTIAL AUTOCORRELATIONS
C     AND MISCELLANEOUS SUMMARY INFORMATION.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN,YMISS,YSD
      INTEGER
     +   IAR,LAGMAX,LAIC,N,NDFCHI,NFAC,NTIMES,NUSED
      LOGICAL
     +   DIFFER,IFMISS,NEWPG
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AIC(LAIC),FTEST(2,LAGMAX),PHI(LAGMAX),PRHO(LAGMAX),
     +   RHO(LAGMAX),SDRHO(LAGMAX)
      INTEGER
     +   IOD(*),ND(*),NLPPA(LAGMAX)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM,PMISS
      INTEGER
     +   IPRT,NMISS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      INTEGER
     +   ISYM(1)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACFDTL,ACFLST,AOSLST,IPRINT,VERSP,VPMN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AIC(LAIC)
C        THE ARRAY CONTAINING THE AKAIKES INFORMATION CRITERION.
C     DOUBLE PRECISION CHIA, CHIAP
C        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
C        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
C        ARE STORED.
C     LOGICAL DIFFER
C        THE VARIABLE USED TO DESIGNATE WHETHER OR NOT THE SERIES
C        ANALYZED WAS DIFFERENCED OR NOT.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     DOUBLE PRECISION FTEST(2, LAGMAX)
C        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     LOGICAL IFMISS
C        THE INDICATOR VARIABLE USED TO DETERMINE
C        WHETHER THE INPUT SERIES HAS MISSING DATA OR NOT.
C     INTEGER IOD(NFAC)
C        THE ORDER OF EACH OF THE DIFFERENCING FACTORS.
C     INTEGER IPRT
C        THE UNIT NUMBER OF THE DEVICE USED FOR PRINTED
C        OUTPUT.
C     INTEGER ISYM(1)
C        A DUMMY ARRAY.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE USED.
C     INTEGER LAIC
C        THE LENGTH OF THE VECTOR AIC.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER ND(NFAC)
C        THE ARRAY CONTANING THE NUMBER OF TIMES THE DIFFERENCING
C        FACTORS ARE TO BE APPLIED.
C     INTEGER NDFCHI
C        THE DEGREES OF FREEDOM FOR THE CHI SQUARED STATISTIC.
C     LOGICAL NEWPG
C        THE VARIABLE DESIGNATING WHETHER OR NOT THE OUTPUT IS TO
C        START ON A NEW PAGE.
C     INTEGER NFAC
C        THE NUMBER OF DIFFERENCE FACTORS.
C     INTEGER NLPPA(LAGMAX)
C        THE ARRAY OF NUMBERS OF LAGGED PRODUCT PAIRS USED TO
C        COMPUTE EACH ACF ESTIMATE.
C     INTEGER NMISS
C        THE NUMBER OF MISSING OBSERVATIONS.
C     INTEGER NTIMES
C        THE NUMBER OF TIMES THE FIRST DIFFERENCE FACTOR HAS BEEN
C        APPLIED.
C     INTEGER NUSED
C        THE ACTIVE NUMBER OF OBSERVATIONS.
C     DOUBLE PRECISION OSPVAR
C        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
C     DOUBLE PRECISION PHI(LAGMAX)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
C        ORDER.
C     DOUBLE PRECISION PMISS
C        THE PERCENT OF MISSING OBSERVATIONS.
C     DOUBLE PRECISION PRHO(LAGMAX)
C        THE ARRAY IN WHICH THE PARTIAL AUTOCORRELATIONS ARE STORED
C     DOUBLE PRECISION RHO(LAGMAX)
C        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
C     DOUBLE PRECISION SDRHO(LAGMAX)
C        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
C        ARE STORED
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED SERIES.
C     DOUBLE PRECISION YMISS, YMMISS(1)
C        THE MISSING VALUE CODE.
C     DOUBLE PRECISION YSD
C        THE STANDARD DEVIATION OF THE OBSERVED SERIES.
C
C
      FPLM = D1MACH(2)
C
      YMMISS(1) = FPLM
C
C     PRINT SUMMARY INFORMATION
C
      CALL IPRINT(IPRT)
C
      IF (NEWPG) WRITE(IPRT, 1004)
C
      CALL VERSP (.TRUE.)
      WRITE(IPRT, 1005)
      IF (DIFFER) CALL ACFDTL(NFAC, ND, IOD, NTIMES)
      WRITE(IPRT, 1000) YMEAN, YSD, N
      IF (.NOT. IFMISS) GO TO 10
      NMISS = N - NUSED
      PMISS = 100.0D0 * NMISS / N
      WRITE(IPRT, 1003) NMISS, PMISS
   10 WRITE(IPRT, 1006) LAGMAX
      IF (IFMISS) WRITE(IPRT, 1007) YMISS
C
      IF (YSD .GT. 0.0D0) GO TO 20
C
      WRITE (IPRT, 1010)
      RETURN
C
   20 CONTINUE
C
C     PRINT ACF INFORMATION
C
      WRITE(IPRT, 1008)
      WRITE(IPRT, 1001)
      CALL ACFLST (RHO, SDRHO, NLPPA, LAGMAX, IFMISS, CHIA, NDFCHI,
     +   CHIAP)
C
C     PLOT ACF INFORMATION
C
      WRITE(IPRT, 1004)
      CALL VERSP (.TRUE.)
      WRITE(IPRT, 1001)
      IF (DIFFER) CALL ACFDTL(NFAC, ND, IOD, NTIMES)
      CALL VPMN(RHO, YMMISS, LAGMAX, 1, LAGMAX, 1, 0, ISYM, 1, 0,
     +   -1.0D0, 1.0D0, 1.0D0, 1.0D0, IFMISS, 0, 0, 1)
C
C     CHECK WHETHER PACF HAVE BEEN COMPUTED
C
      IF (NUSED .LE. N-1) RETURN
C
C     PRINT PACF INFORMATION AND AUTOREGRESSIVE MODEL ORDER SELECTION
C     STATISTICS
C
      WRITE(IPRT, 1004)
      CALL VERSP (.TRUE.)
      WRITE(IPRT, 1002)
      WRITE (IPRT, 1009)
      IF (DIFFER) CALL ACFDTL(NFAC, ND, IOD, NTIMES)
      CALL AOSLST (PRHO, AIC, FTEST, LAGMAX, LAIC, IAR, PHI, OSPVAR,
     +   .TRUE., N)
C
C     PLOT PACF INFORMATION
C
      WRITE(IPRT, 1004)
      CALL VERSP (.TRUE.)
      WRITE(IPRT, 1002)
      IF (DIFFER) CALL ACFDTL(NFAC, ND, IOD, NTIMES)
      CALL VPMN(PRHO, YMMISS, NDFCHI, 1, NDFCHI, 1, 0, ISYM, 1, 0,
     +   -1.0D0, 1.0D0, 1.0D0, 1.0D0, IFMISS, 0, 0, 1)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/
     +   ' AVERAGE OF THE SERIES                 = ', G14.7/
     +   ' STANDARD DEVIATION OF THE SERIES      = ', G14.7/
     +   ' NUMBER OF TIME POINTS                 = ', I10)
 1001 FORMAT (40H AUTOCORRELATION FUNCTION ESTIMATE (ACF)/)
 1002 FORMAT (49H PARTIAL AUTOCORRELATION FUNCTION ESTIMATE (PACF)/)
 1003 FORMAT (
     +   ' NUMBER OF MISSING OBSERVATIONS        = ', I10/
     +   ' PERCENTAGE OF OBSERVATIONS MISSING    = ', F10.4)
 1004 FORMAT ('1')
 1005 FORMAT ( 25H AUTOCORRELATION ANALYSIS)
 1006 FORMAT(
     +   ' LARGEST LAG VALUE USED                = ', I10)
 1007 FORMAT(
     +   ' MISSING VALUE CODE                    = ', G14.7)
 1008 FORMAT(//)
 1009 FORMAT (46H AND AUTOREGRESSIVE ORDER SELECTION STATISTICS///)
 1010 FORMAT (///36H THE AUTOCORRELATIONS OF THIS SERIES,
     +   22H COULD NOT BE COMPUTED/
     +   50H BECAUSE THE LAG ZERO AUTOCOVARIANCE OF THE SERIES,
     +    9H IS ZERO.)
      END
*ACFS
      SUBROUTINE ACFS(Y, N, LAGMAX, LACOV, ACOV, IAR, PHI, NPRT, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
C     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
C     WITH THE COMPUTED ACVF ESTIMATES RETURNED TO THE USERS
C     ROUTINE (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IAR,LACOV,LAGMAX,LDSTAK,N,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),PHI(*),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN,YSD
      INTEGER
     +   AIC,FTEST,I,IFP,IPRT,LDSMIN,LYFFT,NALL0,NFAC,NFFT,PRHO,
     +   SDRHO,WORK
      LOGICAL
     +   DIFFER,ISFFT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   IOD(1),ND(1),NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACFER,ACFMN,ACFOUT,IPRINT,LDSCMP,STKCLR,STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV)
C        THE AUTOCOVARIANCE VECTOR.
C     INTEGER AIC
C        THE STARTING LOCATION IN DSTAK FOR
C        THE ARRAY CONTAINING THE AKAIKES CRITERION FOR EACH ORDER.
C     DOUBLE PRECISION CHIA, CHIAP
C        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
C        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
C        ARE STORED.
C     LOGICAL DIFFER
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER FTEST
C        THE STARTING LOCATION IN DSTAK FOR
C        THE ARRAY CONTAINING THE PARTIAL F RATIO AND PROBABILITIES
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C     INTEGER IFP
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE FLOATING
C        POINT VARIABLES ARE SINGLE (IFP=3) OR DOUBLE (IFP=4) PRECISION.
C     INTEGER IOD(1)
C        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     LOGICAL ISFFT
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE REQUESTED.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
C     INTEGER ND(1)
C        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
C     INTEGER NDUM(1)
C        A DUMMY DIMENSIONED VARIABLE.
C     INTEGER NFAC
C        THE NUMBER OF DIFFERENCE FACTORS
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO OUTPUT IS MADE.
C     DOUBLE PRECISION OSPVAR
C        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
C     DOUBLE PRECISION PHI(LAGMAX)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
C        ORDER.
C     INTEGER PRHO
C        THE STARTING LOCATION IN THE WORK AREA FOR PRHO.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER SDRHO
C        THE STARTING LOCATION IN THE WORK AREA FOR SDRHO.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE WORK AREA FOR WORK.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YSD
C        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'A',       'C',       'F',       'S',       ' ',       ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      DIFFER = .FALSE.
      NFAC = 1
      ND(1) = 0
      IOD(1) = 0
      ISFFT = .FALSE.
      LYFFT = N
      NFFT = N
C
C
      CALL LDSCMP(4, 0, 0, 0, 0, 0, 'D', 5*LAGMAX+1, LDSMIN)
C
      CALL ACFER(NMSUB, N, LAGMAX, LACOV, LDSTAK, LDSMIN,
     +  DIFFER, NFAC, ND, IOD, ISFFT, LYFFT, NFFT)
C
C     CHECK WHETHER AN ERROR HAS BEEN DETECTED
C
      IF (IERR.EQ.0) THEN
C
C       SET UP THE WORK AREA.
C
        CALL STKSET(LDSTAK, 4)
        NALL0 = STKST(1)
C
        IFP = 4
C
        PRHO = STKGET(LAGMAX, IFP)
        AIC = STKGET(LAGMAX+1, IFP)
        FTEST = STKGET(2*LAGMAX, IFP)
        WORK = STKGET(LAGMAX, IFP)
        SDRHO = WORK
C
        IF (IERR.EQ.0) THEN
C
C         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
C
          CALL ACFMN (Y, N, LAGMAX, ACOV(2), RSTAK(SDRHO),
     +       YMEAN, RSTAK(PRHO), RSTAK(AIC), RSTAK(FTEST), PHI,
     +       IAR, OSPVAR, ACOV, LACOV, LAGMAX+1, CHIA, CHIAP,
     +       RSTAK(WORK), NPRT)
C
          YSD = SQRT (ACOV(1) * N / (N - 1))
C
C         CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
C
          IF ((NPRT.NE.0) .OR.  (ACOV(1).EQ.0.0D0)) CALL ACFOUT
     +       (YMEAN, YSD, N, N, LAGMAX, ACOV(2), RSTAK(SDRHO),
     +       RSTAK(PRHO), NDUM, RSTAK(AIC), LAGMAX+1, RSTAK(FTEST),
     +       IAR, PHI, OSPVAR, CHIA, CHIAP, LAGMAX, .FALSE., 0.0D0,
     +       .FALSE., .FALSE., 0, NDUM, NDUM, 0)
C
          IF (NPRT.NE.0) THEN
            DO 50 I = 1, LAGMAX
               ACOV(I+1) = ACOV(I+1) * ACOV(1)
   50       CONTINUE
          END IF
C
        END IF
C
        CALL STKCLR(NALL0)
C
      END IF
C
      IF (IERR.NE.0) THEN
C
C     PRINT PROPER CALL SEQUENCE AND RETURN
C
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL ACFS (Y, N,'/
     + '      +           LAGMAX, LACOV, ACOV, IAR, PHI, NPRT, LDSTAK)')
      END
*ACFSD
      SUBROUTINE ACFSD (RHO, SDRHO, NC, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE STANDARD ERROR OF THE AUTOCORRELATIONS
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NC
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RHO(*),SDRHO(*)
C
C  LOCAL SCALARS
      INTEGER
     +   K,KLAST,LAG
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN,DBLE,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER K
C        AN INDEX VARIABLE.
C     INTEGER KLAST
C        THE LAST LAG VALUE TO BE USED.
C     INTEGER LAG
C        THE INDEX VARIABLE USED TO INDICATE THE AUTOCORRELATION
C        BEING EXAMINED.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NC
C        THE NUMBER OF AUTOCORRELATIONS COMPUTED
C     DOUBLE PRECISION RHO(NC)
C        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
C     DOUBLE PRECISION SDRHO(NC)
C        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
C        ARE STORED
C
      SDRHO(1) = SQRT(DBLE(N - 1)) / N
      IF (NC .EQ. 1) RETURN
      DO 20 LAG = 2, NC
         SDRHO(LAG) = 0.0D0
         KLAST = MIN(LAG-1, N-LAG)
         DO 10 K = 1, KLAST
            SDRHO(LAG) = SDRHO(LAG) + (N-LAG-K) * RHO(K) * RHO(K)
   10    CONTINUE
         SDRHO(LAG) = SQRT((N-LAG) + 2.0D0 * SDRHO(LAG)) / N
   20 CONTINUE
      RETURN
      END
*ACFSDM
      SUBROUTINE ACFSDM (RHO, SDRHO, NC, N, NLPPA)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE STANDARD ERROR OF THE AUTOCORRELATIONS
C     WHEN MISSING DATA ARE INVOLVED.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NC
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RHO(*),SDRHO(*)
      INTEGER
     +   NLPPA(*)
C
C  LOCAL SCALARS
      INTEGER
     +   K,KLAST,LAG
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN,DBLE,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER K
C        AN INDEX VARIABLE.
C     INTEGER KLAST
C        THE LAST LAG VALUE TO BE USED.
C     INTEGER LAG
C        THE INDEX VARIABLE USED TO INDICATE THE AUTOCORRELATION
C        BEING EXAMINED.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NC
C        THE NUMBER OF AUTOCORRELATIONS COMPUTED
C     INTEGER NLPPA(NC)
C        THE ARRAY IN WHICH THE NUMBER OF OBSERVATIONS USED TO
C        COMPUTE EACH AUTOCORRELATION AND PARTIAL AUTOCORRELATION
C        IS STORED
C     DOUBLE PRECISION RHO(NC)
C        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
C     DOUBLE PRECISION SDRHO(NC)
C        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
C        ARE STORED
C
      SDRHO(1) = SQRT(DBLE(NLPPA(1))) * (N-1) / (N * NLPPA(1))
      IF (NC .EQ. 1) RETURN
      DO 20 LAG = 2, NC
         SDRHO(LAG) = 0.0D0
         KLAST = MIN(LAG-1, N-LAG)
         DO 10 K = 1, KLAST
            SDRHO(LAG) = SDRHO(LAG) + (N-LAG-K) * RHO(K) * RHO(K)
   10    CONTINUE
         SDRHO(LAG) = SQRT((N-LAG) + 2.0D0 * SDRHO(LAG)) *
     +      (N-LAG) / (N*NLPPA(LAG))
   20 CONTINUE
      RETURN
      END
*ACVF
      SUBROUTINE ACVF (Y, N, YMEAN, ACOV, LAGMAX, LACOV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE AUTOCOVARIANCE FUNCTION OF A SERIES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMEAN
      INTEGER
     +   LACOV,LAGMAX,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),Y(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DOTXY,DOTYY
      INTEGER
     +   LAG,NDOTXY,NDOTYY
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN,DOTC
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV)
C        THE ARRAY IN WHICH THE AUTOCOVARIANCES ARE STORED
C     DOUBLE PRECISION DOTXY, DOTYY
C        THE DOT PRODUCT BETWEEN VECTORS (Y(I) - YMEAN)) AND
C        (Y(LAG) - YMEAN)), AND (Y(I) - YMEAN)) AND (Y(I) - YMEAN)),
C        RESPECTIVELY.
C     INTEGER LACOV
C        THE ACTUAL DIMENSION OF ACOV.
C     INTEGER LAG, LAGMAX
C        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
C        AUTOCOVARIANCE BEING COMPUTED AND THE MAXIMUM LAG TO BE USED,
C        RESPECTIVELY.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES
C     INTEGER NDOTXY, NDOTYY
C        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY AND
C        DOTYY, RESPECTIVELY.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED SERIES
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C
C     COMPUTE ARITHMETIC MEAN
C
      CALL AMEAN(Y, N, YMEAN)
C
C     COMPUTE THE VARIANCE OF THE SERIES Y
C
      CALL DOTC (Y, YMEAN, N, Y, YMEAN, N, DOTYY, NDOTYY)
      ACOV(1) = DOTYY / NDOTYY
C
C     COMPUTE AUTOCOVARIANCES.
C
      DO 10 LAG = 1, LAGMAX
         CALL DOTC (Y, YMEAN, N, Y(LAG+1), YMEAN, N - LAG,
     +       DOTXY, NDOTXY)
         ACOV(LAG + 1) = DOTXY / N
   10 CONTINUE
C
      RETURN
      END
*ACVFF
      SUBROUTINE ACVFF (YFFT, N, NFFT, YMEAN, ACOV, LAGMAX, LACOV,
     +   LYFFT, WORK, LWORK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE ACVF OF A SERIES USING TWO
C     PASSES OF A FFT.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMEAN
      INTEGER
     +   LACOV,LAGMAX,LWORK,LYFFT,N,NFFT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),WORK(*),YFFT(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FAC
      INTEGER
     +   I,ISN,N1,NF,NFFT2
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN,FFT,FFTCT,REALTR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV)
C        THE ARRAY IN WHICH THE AUTOCOVARIANCES ARE STORED
C     DOUBLE PRECISION FAC
C        A FACTOR USED IN THE COMPUTATIONS.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER ISN
C        AN INDICATOR VARIABLE USED BY THE FFT ROUTINES.
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG TO BE USED.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR WORK.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES
C     INTEGER NF
C        THE NUMBER OF FOURIER FREQUENCIES.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     INTEGER NFFT2
C        THE EFFECTIVE NUMBER OF OBSERVATIONS FOR THE FFT TRANSFORM.
C     INTEGER N1
C        THE VALUE N + 1.
C     DOUBLE PRECISION WORK(LWORK)
C        THE WORK AREA FOR THE COMPUTATIONS.
C     DOUBLE PRECISION YFFT(LYFFT)
C        THE VECTOR CONTAINING THE OBSERVED SERIES
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C
C     COMPUTE ARITHMETIC MEAN
C
      CALL AMEAN(YFFT, N, YMEAN)
C
C     SUBTRACT THE MEAN FROM THE SERIES
C
      DO 10 I = 1, N
         YFFT(I) = YFFT(I) - YMEAN
   10 CONTINUE
C
C     APPEND ZEROS
C
      N1 = N + 1
C
      DO 20 I = N1, NFFT
         YFFT(I) = 0.0D0
   20 CONTINUE
C
C     COMPUTE AUTOCOVARIANCES.
C
      ISN = 2
      NFFT2 = (NFFT - 2)/ 2
C
      CALL FFT(YFFT(1), YFFT(2), NFFT2, NFFT2, NFFT2, ISN)
      CALL REALTR (YFFT(1), YFFT(2), NFFT2, ISN)
C
      NF = NFFT2 + 1
C
      DO 30 I = 1, NF
         WORK(I) = YFFT(2*I-1)*YFFT(2*I-1) + YFFT(2*I)*YFFT(2*I)
   30 CONTINUE
C
      CALL FFTCT (WORK, NFFT2, LWORK)
C
      FAC = 1.0D0 / (4 * (NFFT - 2) * N)
C
      ACOV(1) = WORK(1) * FAC
C
      DO 40 I = 1, LAGMAX
         ACOV(I+1) = WORK(I+1) * FAC
   40 CONTINUE
C
      RETURN
      END
*ACVFM
      SUBROUTINE ACVFM (Y, YMISS, N, YMEAN, ACOV, LAGMAX,
     +   LAGLST, NLPPA, LACOV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE AUTOCOVARIANCES WHEN MISSING DATA ARE
C     INVOLVED.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMEAN,YMISS
      INTEGER
     +   LACOV,LAGLST,LAGMAX,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),Y(*)
      INTEGER
     +   NLPPA(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DOTXY,DOTYY,FPLM
      INTEGER
     +   LAG,NDOTXY,NDOTYY,NUSED
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      INTEGER
     +   LSTLAG
      EXTERNAL D1MACH,LSTLAG
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMEANM,DOTCM
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV)
C        THE ARRAY IN WHICH THE AUTOCOVARIANCES ARE STORED
C     DOUBLE PRECISION DOTXY, DOTYY
C        THE DOT PRODUCT BETWEEN VECTORS (Y(I) - YMEAN)) AND
C        (Y(LAG) - YMEAN)), AND (Y(I) - YMEAN)) AND (Y(I) - YMEAN)),
C        RESPECTIVELY.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAG, LAGLST, LAGMAX
C        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
C        AUTOCORRELATION BEING COMPUTED, THE NUMBER OF AUTOCORRELATIONS
C        COMPUTED BEFORE A MISSING AUTOCORRELATION, AND THE NUMBER OF
C        AUTOCORRELATIONS DESIRED, RESPECTIVELY.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
C     INTEGER NDOTXY, NDOTYY
C        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY AND
C        DOTYY, RESPECTIVELY.
C     INTEGER NLPPA(LACOV)
C        THE ARRAY CONTAINING THE NUMBERS OF LAGGED PRODUCT PAIRS
C        USED TO COMPUTE THE ACVF AT EACH LAG.
C     INTEGER NUSED
C        THE NUMBER OF ACTIVE OBSERVATIONS IN THE SERIES.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED SERIES
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YMISS
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
C        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
C        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
C
C
      FPLM = D1MACH(2)
C
C     COMPUTE ARITHMETIC MEAN, WITH MISSING VALUES TAKEN INTO ACCOUNT
C
      CALL AMEANM (Y, YMISS, N, NUSED, YMEAN)
C
C     COMPUTE THE VARIANCE OF THE SERIES Y
C
      CALL DOTCM (Y, YMEAN, YMISS, N, Y, YMEAN, YMISS, N,
     +   DOTYY, NDOTYY)
      NLPPA(1) = NDOTYY
      IF (NLPPA(1).EQ.0) THEN
         LAGLST = 0
      ELSE
         ACOV(1) = DOTYY / NDOTYY
C
C     COMPUTE AUTOCORRELATIONS, WITH MISSING VALUES TAKEN INTO ACCOUNT
C
         DO 10 LAG = 1, LAGMAX
            CALL DOTCM (Y, YMEAN, YMISS, N, Y(LAG+1), YMEAN,
     +         YMISS, N - LAG, DOTXY, NDOTXY)
            NLPPA(LAG + 1) = NDOTXY
            ACOV(LAG + 1) = FPLM
            IF (NLPPA(LAG + 1) .LE. 0) GO TO 10
            ACOV(LAG + 1) = DOTXY * (N-LAG) / (NLPPA(LAG + 1) * N)
   10    CONTINUE
C
C     FIND THE LAST AUTOCORRELATION TO BE COMPUTED BEFORE
C     ONE COULD NOT BE COMPUTED DUE TO MISSING DATA
C
         LAGLST = LSTLAG(NLPPA, LAGMAX, LACOV)
      END IF
      RETURN
      END
*ADJLMT
      SUBROUTINE ADJLMT(YMN, YMX)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CORRECTS THE PLOT LIMITS WHEN ALL
C     OBSERVATIONS ARE IDENTICALLY EQUAL.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMN,YMX
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION YMN, YMX
C        THE Y-AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
C
      IF (YMN .LT. YMX) RETURN
C
C     CORRECT FOR ALL OBSERVATIONS IDENTICALLY EQUAL
C
      YMN = YMN - ABS(YMN/2.0D0)
      YMX = YMX + ABS(YMX/2.0D0)
      IF (YMN .LT. YMX) RETURN
      YMN = -0.5D0
      YMX = 0.5D0
C
      RETURN
      END
*AIME
      SUBROUTINE AIME (Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR ARIMA ESTIMATION
C     (CONTROL CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N,NFAC,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),Y(*)
      INTEGER
     +   MSPEC(4,*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IPRT,IVAPRX,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,MIT,
     +   NPARE,NPRT
      LOGICAL
     +   SAVE
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SCALE(1),SDPV(1),SDRES(1),STP(1),VCV(1,1)
      INTEGER
     +   IFIXED(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMEDRV,IPRINT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(1)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C        IF IFIXED(1).LT.0, THEN IFIXED(I)=DEFAULT,I=1,...,NPAR, AND THE
C                           DIMENSION OF IFIXED WILL BE ASSUMED TO BE 1.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE FOR
C        IVAPRX LE 0, VCV = THE DEFAULT OPTION
C        IVAPRX EQ 1, VCV = INVERSE(TRANSPOSE(J)*J)
C                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2, VCV = INVERSE(H)
C                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
C                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4, VCV = INVERSE(TRANSPOSE(J)*J)
C                     USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5, VCV = INVERSE(H)
C                     USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
C                     USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7, VCV = THE DEFAULT OPTION
C        WITH J REPRESENTING THE JACOBIAN AND H THE HESSIAN.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF MATRIX VCV.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE DIMENSION OF VECTOR IFIXED.
C     INTEGER LPV
C        THE DIMENSION OF VECTOR PV.
C     INTEGER LSCALE
C        THE DIMENSION OF VECTOR SCALE.
C     INTEGER LSDPV
C        THE DIMENSION OF VECTOR SDPV.
C     INTEGER LSDRES
C        THE DIMENSION OF VECTOR SDRES.
C     INTEGER LSTP
C        THE DIMENSION OF VECTOR STP.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     INTEGER MSPEC(4,NFAC)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PV(1)
C        THE PREDICTED VALUE OF THE FIT, UNUSED WHEN SAVE = FALSE.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(1)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C        IF SCALE(1).LE.0, THEN SCALE(I)=DEFAULT,I=1,...,NPAR, AND THE
C                          DIMENSION OF SCALE WILL BE ASSUMED TO BE 1.
C     DOUBLE PRECISION SDPV(1)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES, UNUSED
C        WHEN SAVE = FALSE.
C     DOUBLE PRECISION SDRES(1)
C        THE STANDARDIZED RESIDUALS, UNUSED WHEN SAVE = FALSE.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(1)
C        THE STEP SIZE ARRAY.
C        IF STP(1).LE.0, THEN STP(I)=DEFAULT,I=1,...,NPAR, AND THE
C                        DIMENSION OF STP WILL BE ASSUMED TO BE 1.
C     DOUBLE PRECISION VCV(1,1)
C        THE VARIANCE-COVARIANCE MATRIX, UNUSED WHEN SAVE = FALSE.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'A','I','M','E',' ',' '/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      SAVE = .FALSE.
C
      LIFIXD = 1
      IFIXED(1) = -1
      LSTP = 1
      STP(1) = 0.0D0
      MIT = -1
      STOPSS = -1.0D0
      STOPP = -1.0D0
      LSCALE = 1
      SCALE(1) = 0.0D0
      DELTA = -1.0D0
      IVAPRX = -1
      NPRT = -1
      LPV = 1
      LSDPV = 1
      LSDRES = 1
      IVCV = 1
C
      CALL AMEDRV(Y, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, SAVE, NPARE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
C
 1000 FORMAT (/' THE CORRECT FORM OF THE CALL STATEMENT IS'//
     +  '       CALL AIME (Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK)')
      END
*AIMEC
      SUBROUTINE AIMEC(Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR ARIMA ESTIMATION
C     (CONTROL CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,STOPP,STOPSS
      INTEGER
     +   IVAPRX,LDSTAK,MIT,N,NFAC,NPAR,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),SCALE(*),STP(*),Y(*)
      INTEGER
     +   IFIXED(1),MSPEC(4,*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,NPARE
      LOGICAL
     +   SAVE
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SDPV(1),SDRES(1),VCV(1,1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMEDRV,IPRINT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(1)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C        IF IFIXED(1).LT.0, THEN IFIXED(I)=DEFAULT,I=1,...,NPAR, AND THE
C                           DIMENSION OF IFIXED WILL BE ASSUMED TO BE 1.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE FOR
C        IVAPRX LE 0, VCV = THE DEFAULT OPTION
C        IVAPRX EQ 1, VCV = INVERSE(TRANSPOSE(J)*J)
C                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2, VCV = INVERSE(H)
C                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
C                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4, VCV = INVERSE(TRANSPOSE(J)*J)
C                     USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5, VCV = INVERSE(H)
C                     USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
C                     USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7, VCV = THE DEFAULT OPTION
C        WITH J REPRESENTING THE JACOBIAN AND H THE HESSIAN.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF MATRIX VCV.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE DIMENSION OF VECTOR IFIXED.
C     INTEGER LPV
C        THE DIMENSION OF VECTOR PV.
C     INTEGER LSCALE
C        THE DIMENSION OF VECTOR SCALE.
C     INTEGER LSDPV
C        THE DIMENSION OF VECTOR SDPV.
C     INTEGER LSDRES
C        THE DIMENSION OF VECTOR SDRES.
C     INTEGER LSTP
C        THE DIMENSION OF VECTOR STP.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     INTEGER MSPEC(4,NFAC)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PV(1)
C        THE PREDICTED VALUE OF THE FIT, UNUSED WHEN SAVE = FALSE.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(NPAR)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C        IF SCALE(1).LE.0, THEN SCALE(I)=DEFAULT,I=1,...,NPAR, AND THE
C                          DIMENSION OF SCALE WILL BE ASSUMED TO BE 1.
C     DOUBLE PRECISION SDPV(1)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES, UNUSED
C        WHEN SAVE = FALSE.
C     DOUBLE PRECISION SDRES(1)
C        THE STANDARDIZED RESIDUALS, UNUSED WHEN SAVE = FALSE.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(1)
C        THE STEP SIZE ARRAY.
C        IF STP(1).LE.0, THEN STP(I)=DEFAULT,I=1,...,NPAR, AND THE
C                        DIMENSION OF STP WILL BE ASSUMED TO BE 1.
C     DOUBLE PRECISION VCV(1,1)
C        THE VARIANCE-COVARIANCE MATRIX, UNUSED WHEN SAVE = FALSE.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'A','I','M','E','C',' '/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      SAVE = .FALSE.
C
      LIFIXD = NPAR
      IF (IFIXED(1).LE.-1) LIFIXD = 1
      LPV = 1
      LSCALE = NPAR
      IF (SCALE(1).LE.0.0D0) LSCALE = 1
      LSTP = NPAR
      IF (STP(1).LE.0.0D0) LSTP = 1
      LSDPV = 1
      LSDRES = 1
      IVCV = 1
C
      CALL AMEDRV(Y, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, SAVE, NPARE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/' THE CORRECT FORM OF THE CALL STATEMENT IS'//
     +  '       CALL AIMEC (Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK,'/
     +  '      +            IFIXED, STP, MIT, STOPSS, STOPP, SCALE,'/
     +  '      +            DELTA, IVAPRX, NPRT)')
      END
*AIMES
      SUBROUTINE AIMES(Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR ARIMA ESTIMATION
C     (LONG CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IVAPRX,IVCV,LDSTAK,MIT,N,NFAC,NPAR,NPARE,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),STP(*),VCV(*),
     +   Y(*)
      INTEGER
     +   IFIXED(1),MSPEC(4,*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP
      LOGICAL
     +   SAVE
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMEDRV,IPRINT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(1)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C        IF IFIXED(1).LT.0, THEN IFIXED(I)=DEFAULT,I=1,...,NPAR, AND THE
C                           DIMENSION OF IFIXED WILL BE ASSUMED TO BE 1.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE FOR
C        IVAPRX LE 0, VCV = THE DEFAULT OPTION
C        IVAPRX EQ 1, VCV = INVERSE(TRANSPOSE(J)*J)
C                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2, VCV = INVERSE(H)
C                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
C                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4, VCV = INVERSE(TRANSPOSE(J)*J)
C                     USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5, VCV = INVERSE(H)
C                     USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
C                     USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7, VCV = THE DEFAULT OPTION
C        WITH J REPRESENTING THE JACOBIAN AND H THE HESSIAN.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF MATRIX VCV.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE DIMENSION OF VECTOR IFIXED.
C     INTEGER LPV
C        THE DIMENSION OF VECTOR PV.
C     INTEGER LSCALE
C        THE DIMENSION OF VECTOR SCALE.
C     INTEGER LSDPV
C        THE DIMENSION OF VECTOR SDPV.
C     INTEGER LSDRES
C        THE DIMENSION OF VECTOR SDRES.
C     INTEGER LSTP
C        THE DIMENSION OF VECTOR STP.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     INTEGER MSPEC(4,NFAC)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUE OF THE FIT.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(NPAR)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C        IF SCALE(1).LE.0, THEN SCALE(I)=DEFAULT,I=1,...,NPAR, AND THE
C                          DIMENSION OF SCALE WILL BE ASSUMED TO BE 1.
C     DOUBLE PRECISION SDPV(N)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(N)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(NPAR)
C        THE STEP SIZE ARRAY.
C        IF STP(1).LE.0, THEN STP(I)=DEFAULT,I=1,...,NPAR, AND THE
C                        DIMENSION OF STP WILL BE ASSUMED TO BE 1.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE VARIANCE-COVARIANCE MATRIX.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'A','I','M','E','S',' '/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      SAVE = .TRUE.
C
      LIFIXD = NPAR
      IF (IFIXED(1).LE.-1) LIFIXD = 1
      LSCALE = NPAR
      IF (SCALE(1).LE.0.0D0) LSCALE = 1
      LSTP = NPAR
      IF (STP(1).LE.0.0D0) LSTP = 1
C
      CALL AMEDRV(Y, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, SAVE, NPARE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/' THE CORRECT FORM OF THE CALL STATEMENT IS'//
     +  '       CALL AIMES (Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK,'/
     +  '      +            IFIXED, STP, MIT, STOPSS, STOPP, SCALE,'/
     +  '      +            DELTA, IVAPRX, NPRT,'/
     +  '      +            NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)')
      END
*AIMF
      SUBROUTINE AIMF (Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR ARIMA ESTIMATION
C     (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N,NFAC,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),Y(*)
      INTEGER
     +   MSPEC(4,*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IFCST,IPRT,NFCST,NFCSTO,NPRT
      LOGICAL
     +   SAVE
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FCST(1,1),FCSTSD(1)
      INTEGER
     +   IFCSTO(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMFCNT,IPRINT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FCST(1,1)
C        THE STORAGE ARRAY FOR THE FORECASTS.
C     DOUBLE PRECISION FCSTSD(1)
C        THE STORAGE ARRAY FOR THE STANDARD DEVIATIONS OF THE FORECASTS.
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFCST
C        THE FIRST DIMENSION OF THE ARRAY FCST.
C     INTEGER IFCSTO(1)
C        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER MSPEC(4,NFAC)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NFCST
C        THE NUMBER OF FORECASTS.
C     INTEGER NFCSTO
C        THE NUMBER OF THE ORIGINS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'A','I','M','F',' ',' '/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      SAVE = .FALSE.
C
      NFCST = N/10 + 1
      NFCSTO = 1
      IFCSTO(1) = N
      NPRT = -1
      IFCST = 1
C
      CALL AMFCNT(Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK, NFCST, NFCSTO,
     +   IFCSTO, NPRT, FCST, IFCST, FCSTSD, NMSUB, SAVE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/' THE CORRECT FORM OF THE CALL STATEMENT IS'//
     +     '       CALL AIMF (Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK)')
      END
*AIMFS
      SUBROUTINE AIMFS(Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK,
     +   NFCST, NFCSTO, IFCSTO, NPRT, FCST, IFCST, FCSTSD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR ARIMA ESTIMATION
C     (CONTROL CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IFCST,LDSTAK,N,NFAC,NFCST,NFCSTO,NPAR,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FCST(*),FCSTSD(*),PAR(*),Y(*)
      INTEGER
     +   IFCSTO(*),MSPEC(4,*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,NFCSTU
      LOGICAL
     +   SAVE
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMFCNT,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FCST(IFCST,NFCSTO)
C        THE STORAGE ARRAY FOR THE FORECASTS.
C     DOUBLE PRECISION FCSTSD(NFCST)
C        THE STORAGE ARRAY FOR THE STANDARD DEVIATIONS OF THE FORECASTS.
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFCST
C        THE FIRST DIMENSION OF THE ARRAY FCST.
C     INTEGER IFCSTO(NFCSTO)
C        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER MSPEC(4,NFAC)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NFCST
C        THE NUMBER OF FORECASTS.
C     INTEGER NFCSTO
C        THE NUMBER OF THE ORIGINS.
C     INTEGER NFCSTU
C        THE NUMBER OF FORCASTES ACTUALLY USED.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'A','I','M','F','S',' '/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      SAVE = .TRUE.
C
      IF ((NFCST.GE.1) .AND. (NFCST.LE.N)) THEN
         NFCSTU = NFCST
      ELSE
         NFCSTU = (N/10)+1
      END IF
C
      CALL AMFCNT(Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK, NFCSTU,
     +   MAX(1,NFCSTO), IFCSTO, NPRT, FCST, IFCST, FCSTSD, NMSUB, SAVE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/' THE CORRECT FORM OF THE CALL STATEMENT IS'//
     +  '       CALL AIMFS (Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK,'/
     +  '      +            NFCST, NFCSTO, IFCSTO, NPRT, FCST, IFCST,',
     +  ' FCSTSD)')
      END
*AIMX1
      SUBROUTINE AIMX1(MXN, MXPAR, MXFC, MXFCO, MXFAC,
     +   MOD, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV,
     +   NFCST, NFCSTO, IFCSTO, FCST, IFCST, FCSTSD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     SET THE STARTING PARAMETER VALUES FOR AIMX
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IFCST,IVAPRX,IVCV,MIT,MOD,MXFAC,MXFC,MXFCO,MXN,MXPAR,N,
     +   NFAC,NFCST,NFCSTO,NPAR,NPARE,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FCST(MXFC,*),FCSTSD(*),PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),
     +   SDRES(*),STP(*),VCV(MXPAR,*)
      INTEGER
     +   IFCSTO(*),IFIXED(*),MSPEC(4,*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   SQMEPS
      INTEGER
     +   I,J
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   RMDCON
      EXTERNAL RMDCON
C
C  EXTERNAL SUBROUTINES
      EXTERNAL SETRV
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     DOUBLE PRECISION FCST(MXFC,MXFCO)
C        THE FORECASTS.
C     DOUBLE PRECISION FCSTSD(MXFC)
C        THE STANDARD DEVIATION OF THE FORECASTS.
C     INTEGER I
C        *
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFCST
C        *
C     INTEGER IFCSTO(MXFCO)
C        THE FORECAST ORIGINS.
C     INTEGER IFIXED(MXPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IVAPRX
C        *
C     INTEGER IVCV
C        THE ACTUAL FIRST DIMENSION OF VCV.
C     INTEGER J
C        *
C     INTEGER MIT
C        *
C     INTEGER MOD
C        AN INDICATOR VALUE USED TO DESIGNATE THE MODEL FOR WHICH
C        THE PARAMETERS ARE TO BE SET.
C     INTEGER MSPEC(4,MXFAC)
C        THE VALUES OF P, D, Q AND S FOR EACH FACTOR.
C     INTEGER MXFAC
C        THE MAXIMUM NUMBER OF FACTORS ALLOWED.
C     INTEGER MXFC
C        THE MAXIMUM NUMBER OF FORECASTS ALLOWED.
C     INTEGER MXFCO
C        THE MAXIMUM NUMBER OF FORECASTS ORIGINS ALLOWED.
C     INTEGER MXN
C        THE MAXIMUM NUMBER OF OBSERVATIONS ALLOWED.
C     INTEGER MXPAR
C        THE MAXIMUM NUMBER OF PARAMETERS ALLOWED.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NFCST, NFCSTO
C        THE NUMBER OF FORECASTS AND FORCAST ORIGINS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C        TO BE PROVIDED.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
C     INTEGER NPRT
C        *
C     DOUBLE PRECISION PAR(MXPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION PV(MXN)
C        THE PREDICTED VALUES.
C     DOUBLE PRECISION RES(MXN)
C        THE RESIDUALS.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     DOUBLE PRECISION SCALE(MXPAR)
C        THE SCALE VALUES.
C     DOUBLE PRECISION SDPV(MXN)
C        THE STANDARD DEVIATION OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(MXN)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION SQMEPS, STOPP, STOPSS
C        *
C     DOUBLE PRECISION STP(MXPAR)
C        THE STEP VALUES.
C     DOUBLE PRECISION VCV(MXPAR,MXPAR)
C        THE VARIANCE COVARIANCE MATRIX.
C
      GO TO (10, 20, 30, 40, 50, 60), MOD
C
   10 CONTINUE
      N = 144
      NFAC = 2
      MSPEC(1,1) = 0
      MSPEC(2,1) = 1
      MSPEC(3,1) = 1
      MSPEC(4,1) = 1
      MSPEC(1,2) = 0
      MSPEC(2,2) = 1
      MSPEC(3,2) = 1
      MSPEC(4,2) = 12
      NPAR = 3
      PAR(1) = 0.0D0
      PAR(2) = 0.4D0
      PAR(3) = 0.6D0
      IFIXED(1) = 1
      IFIXED(2) = 0
      IFIXED(3) = 0
C
      GO TO 70
C
C
   20 PAR(1) = 1.0D0
      PAR(2) = 2.0D0
      PAR(3) = 3.0D0
C
      GO TO 70
C
C
   30 PAR(1) = 6.0D0
      PAR(2) = 5.0D0
      PAR(3) = 4.0D0
      PAR(4) = 3.0D0
      PAR(5) = 2.0D0
C
      GO TO 70
C
C
   40 CALL SETRV(PAR, NPAR, 0.0D0)
C
      GO TO 70
C
C
   50 CALL SETRV(PAR, NPAR, 0.5D0)
C
      GO TO 70
C
C
   60 PAR(1) = 100.0D0
      PAR(2) = 15.0D0
C
   70 CONTINUE
C
      SQMEPS = SQRT(RMDCON(3))
C
      MIT = 25
      DO 80 I=1,10
         STP(I) = SQMEPS
         SCALE(I) = 1.0D0
   80 CONTINUE
      STOPSS = 10.0D-7
      STOPP = 10.0D-7
      DELTA = 0.5D0
      NPRT = 11111
      IVAPRX = 3
      IVCV = MXPAR
C
      NFCST = 36
      NFCSTO = 2
      IFCSTO(1) = 103
      IFCSTO(2) = N
      IFCST = MXFC
C
      DO 85 I=1,MXN
         RES(I) = -1.0D0
         PV(I) = -1.0D0
         SDPV(I) = -1.0D0
         SDRES(I) = -1.0D0
   85 CONTINUE
C
      DO 100 I=1,MXPAR
         DO 90 J=1,MXPAR
            VCV(I,J) = -1.0D0
   90    CONTINUE
  100 CONTINUE
C
      DO 110 I = 1, MXFC
        FCSTSD(I) = -1.0D0
        DO 105 J = 1, MXFCO
          FCST(I,J) = -1.0D0
  105   CONTINUE
  110 CONTINUE
C
      NPARE = -1
      RSD = -1.0D0
C
      IERR = -1
C
      RETURN
C
      END
*AMDRV
      SUBROUTINE AMDRV (MDLTS3, DRV, DONE, IFIXD, PAR, NPAR, XM, N, M,
     +   IXM, NRESTS, RESTS, D, WEIGHT, WT, LWT, STPT, LSTPT, SCL, LSCL)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE NUMERICAL APPROXIMATIONS TO THE
C     DERIVATIVE MATRIX (JACOBIAN).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LSCL,LSTPT,LWT,M,N,NPAR,NRESTS
      LOGICAL
     +   DONE,WEIGHT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(NRESTS,*),PAR(*),RESTS(*),SCL(*),STPT(*),WT(*),XM(IXM,*)
      INTEGER
     +   IFIXD(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDLTS3
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   PJ,STPJ
      INTEGER
     +   I,J,JPK
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,SIGN
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION D(NRESTS,NPAR)
C        THE FIRST DERIVATIVE OF THE MODEL (JACOBIAN).
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     LOGICAL DONE
C        THE VARIABLE USED TO INDICATE WHETHER THIS IS THE FINAL
C        COMPUTATION OF THE JACOBIAN OR NOT.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IXM
C        THE FIRST DIMENSION OF MATRIX XM.
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER JPK
C        AN INDEX VARIABLE.
C     INTEGER LSCL
C        THE DIMENSION OF VECTOR SCL.
C     INTEGER LSTPT
C        THE DIMENSION OF VECTOR STPT.
C     INTEGER LWT
C        THE DIMENSION OF VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDLTS3
C        THE STARPAC FORMAT SUBROUTINE FOR COMPUTING THE ARIMA MODEL
C        RESIDUALS.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NRESTS
C        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PJ
C        A TEMPORARY LOCATION FOR STORAGE OF THE JTH PARAMETER.
C     DOUBLE PRECISION RESTS(NRESTS)
C        THE RESIDUALS FROM THE ARIMA MODEL.
C     DOUBLE PRECISION SCL(LSCL)
C        THE SCALE VALUES.
C     DOUBLE PRECISION STPT(LSTPT)
C        THE STEP SIZE ARRAY.
C     DOUBLE PRECISION STPJ
C        THE JTH STEP SIZE.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE INDEPENDENT VARIABLE.
C
C     COMPUTE FINITE-DIFFERENCE JACOBIAN OF THE OPTIMIZED PARAMETERS
C
      JPK = 0
C
      DO 20 J=1,NPAR
C
         IF (IFIXD(J).NE.0) GO TO 20
C
         JPK = JPK + 1
C
         PJ = PAR(J)
         IF (SCL(JPK).NE.0.0D0) THEN
            STPJ = STPT(J)*SIGN(1.0D0,PAR(J))*MAX(ABS(PAR(J)),1.0D0/
     +             ABS(SCL(JPK)))
         ELSE
            IF (PAR(J).NE.0.0D0) THEN
               STPJ = STPT(J)*SIGN(1.0D0,PAR(J))*ABS(PAR(J))
            ELSE
               STPJ = STPT(J)
            END IF
         END IF
C
         STPJ = STPJ + PAR(J)
         STPJ = STPJ - PAR(J)
C
         PAR(J) = PJ + STPJ
         CALL MDLTS3(PAR, NPAR, XM, N, M, IXM, D(1,J))
C
         DO 10 I=1,NRESTS
            D(I,JPK) = (-RESTS(I)+D(I,J))/STPJ
   10    CONTINUE
C
         PAR(J) = PJ
C
   20 CONTINUE
C
      RETURN
C
      END
*AMEAN
      SUBROUTINE AMEAN(Y, N, YMEAN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE ARITHMETIC MEAN OF A SERIES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMEAN
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   SUMY
      INTEGER
     +   I
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES
C     DOUBLE PRECISION SUMY
C        THE VARIABLE USED TO SUM THE Y VALUES.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED SERIES
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C
      SUMY = 0.0D0
      DO 10 I = 1, N
         SUMY = SUMY + Y(I)
   10 CONTINUE
      YMEAN = SUMY / N
      RETURN
      END
*AMEANM
      SUBROUTINE AMEANM (Y, YMISS, N, NUSED, YMEAN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE ARITHMETIC MEAN OF A SERIES WHEN MISSING
C     DATA ARE INVOLVED.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMEAN,YMISS
      INTEGER
     +   N,NUSED
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   SUMY
      INTEGER
     +   I
C
C  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NUSED
C        THE NUMBER OF ACTIVE NUMBER OF OBSERVATIONS.
C     DOUBLE PRECISION SUMY
C        THE VARIABLE USED TO SUM THE NON-MISSING Y VALUES.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED SERIES
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YMISS
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
C        NOT AN OBSERVATION IS MISSING.  IF Y(I) = YMISS,
C        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
C
      NUSED = 0
      SUMY = 0.0D0
      DO 10 I = 1, N
         IF (MVCHK(Y(I), YMISS)) GO TO 10
         SUMY = SUMY + Y(I)
         NUSED = NUSED + 1
   10 CONTINUE
      IF (NUSED.GE.1) THEN
         YMEAN = SUMY / NUSED
      ELSE
         YMEAN = SUMY
      END IF
      RETURN
      END
*AMECNT
      SUBROUTINE AMECNT(Y, WT, LWT, XM, N, M, IXM, MDL, NLDRV, APRXDV,
     +   DRV, PAR, NPAR, RES, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS,
     +   STOPP, SCALE, LSCALE, DELTA, IVAPRX, RSD, PV, LPV, SDPV,
     +   LSDPV, SDRES, LSDRES, VCV, IVCV, WEIGHT, SAVE, NNZW, NPARE,
     +   NLHDR, PAGE, WIDE, IPTOUT, NDIGIT, HLFRPT, NRESTS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE CONTROLLING SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IVAPRX,IVCV,IXM,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,LWT,M,
     +   MIT,N,NDIGIT,NNZW,NPAR,NPARE,NRESTS
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,SAVE,WEIGHT,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),STP(*),
     +   VCV(IVCV,*),WT(*),XM(IXM,*),Y(*)
      INTEGER
     +   IFIXED(*),IPTOUT(5)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL,NLDRV,NLHDR
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   D,IFIXD,IFP,IIWORK,IRWORK,IWORK,LVCVL,NALL0,PARE,PVI,
     +   RESTS,RWORK,SDPVI,SDRESI,VCVL
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMEMN,CPYASF,CPYVII,DCOPY,SETIV,STKCLR
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL APRXDV
C        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
C        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
C        (FALSE).
C     INTEGER D
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE ARRAY IN WHICH THE NUMERICAL DERIVATIVES WITH RESPECT TO
C        EACH PARAMETER ARE STORED.
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL HLFRPT
C        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
C        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
C        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXD
C        THE STARTING LOCATION IN ISTAK OF
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IFIXED(LIFIXD)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF IFIXED(I).EQ
C        THEN PAR(I) WILL BE HELD FIXED.
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IIWORK
C        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
C     INTEGER IPTOUT(5)
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
C     INTEGER IRWORK
C        THE DIMENSION OF THE DOUBLE PRECISION WORK VECTOR RWORK.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IWORK
C        THE STARTING LOCATION IN ISTAK OF
C        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LIFIXD
C        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LSTP
C        THE ACTUAL LENGTH OF THE VECTOR STP.
C     INTEGER LVCVL
C        THE LENGTH OF THE VECTOR CONTAINING
C        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NALL0
C        NUMBER OF ALLOCATIONS ON ENTRY.
C     INTEGER NDIGIT
C        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
C     EXTERNAL NLDRV
C        THE NAME OF THE ROUTINE WHICH CALCULATES THE DERIVATIVES.
C     EXTERNAL NLHDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     INTEGER NRESTS
C        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     INTEGER PARE
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE CURRENT ESTIMATES OF THE PARAMETERS, BUT ONLY
C        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
C     DOUBLE PRECISION PV(LPV)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     INTEGER PVI
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE PREDICTED VALUES.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     INTEGER RESTS
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE RESIDUALS FROM THE ARIMA MODEL.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER RWORK
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE DOUBLE PRECISION WORK VECTOR USED BY THE NL2 SUBROUTINES.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(LSCALE)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(LSDPV)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     INTEGER SDPVI
C        THE STARTING LOCATION IN RWORK OF
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(LSDRES)
C        THE STANDARDIZED RESIDUALS.
C     INTEGER SDRESI
C        THE STARTING LOCATION IN RWORK OF THE
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(LSTP)
C        THE STEP SIZE ARRAY.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE VARIANCE-COVARIANCE MATRIX.
C     INTEGER VCVL
C        THE STARTING LOCATION IN RWORK OF
C        THE VARIANCE-COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     SET VARIOUS PROGRAM VALUES
C
      NALL0 = STKST(1)
C
      IFP = 4
C
      IERR = 0
C
C     SUBDIVIDE WORK AREA FOR LEAST SQUARES ANALYSIS
C
      IIWORK = NPARE + 60
      IRWORK = 94 + 2*NRESTS + NPARE*(3*NPARE+33)/2
C
      IFIXD = STKGET(NPAR,2)
      IWORK = STKGET(IIWORK,2)
C
      D = STKGET(NRESTS*NPAR,IFP)
      PARE = STKGET(NPARE,IFP)
      RESTS = STKGET(NRESTS,IFP)
      PVI = RESTS
      RWORK = STKGET(IRWORK,IFP)
C
      IF (IERR.EQ.1) RETURN
C
C     SET VALUES FOR IFIXD
C
      IF (IFIXED(1).GE.0) CALL CPYVII(NPAR, IFIXED, 1, ISTAK(IFIXD), 1)
      IF (IFIXED(1).LT.0) CALL SETIV(ISTAK(IFIXD), NPAR, 0)
C
      CALL AMEMN(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, NRESTS,
     +   APRXDV, ISTAK(IFIXD), PAR, RSTAK(PARE), NPAR, RES, PAGE,
     +   WIDE, HLFRPT, STP, LSTP, MIT, STOPSS, STOPP, SCALE, LSCALE,
     +   DELTA, IVAPRX, IPTOUT, NDIGIT, RSD, RSTAK(RESTS), SDPVI,
     +   SDRESI, VCVL, LVCVL, RSTAK(D), ISTAK(IWORK), IIWORK,
     +   RSTAK(RWORK), IRWORK, NLHDR, NPARE, RSTAK(PVI))
C
      IF (.NOT.SAVE) GO TO 10
C
      SDPVI = RWORK + SDPVI - 1
      SDRESI = RWORK + SDRESI - 1
      VCVL = RWORK + VCVL - 1
C
      CALL DCOPY(N, RSTAK(PVI), 1, PV, 1)
      CALL DCOPY(N, RSTAK(SDPVI), 1, SDPV, 1)
      CALL DCOPY(N, RSTAK(SDRESI), 1, SDRES, 1)
      CALL CPYASF(NPARE, RSTAK(VCVL), LVCVL, VCV, IVCV)
C
   10 CALL STKCLR(NALL0)
C
      RETURN
C
      END
*AMEDRV
      SUBROUTINE AMEDRV(Y, N, MSPEC, NFAC, PAR, NPAR,
     +   RES, LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP,
     +   SCALE, LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV,
     +   SDRES, LSDRES, VCV, IVCV, NMSUB, SAVE, NPARE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE CONTROLLING SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IVAPRX,IVCV,LDSTAK,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,
     +   MIT,N,NFAC,NPAR,NPARE,NPRT
      LOGICAL
     +   SAVE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),STP(*),VCV(*),
     +   Y(*)
      INTEGER
     +   IFIXED(*),MSPEC(4,*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR,IFLAG,MBO,MBOL,MSPECT,NFACT,NPARAR,NPARDF,NPARMA,
     +   NRESTS,PARAR,PARDF,PARMA,T,TEMP
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   EXMPT
      INTEGER
     +   IFP,IS,ISUBHD,IXM,LDSMIN,LWT,M,NALL0,NDIGIT,NETA,NNZW,STPT
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,PRTFXD,WEIGHT,WIDE
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12),WT(1)
      INTEGER
     +   IPTOUT(5),ISTAK(12)
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   ICNTI,STKGET,STKST
      EXTERNAL ICNTI,STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMECNT,AMEER,AMEHDR,AMESTP,BACKOP,CPYVII,
     +   DCOEF,DRV,LDSCMP,MDLTS1,MDLTS3,NLDRVN,PRTCNT,DCOPY,
     +   STKCLR,STKSET,STPAMO
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
      COMMON /MDLTSC/MSPECT,NFACT,PARDF,NPARDF,PARAR,NPARAR,PARMA,
     +   NPARMA,MBO,MBOL,T,TEMP,NRESTS,IFLAG
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     EXTERNAL AMEHDR
C        THE ROUTINE USED TO PRINT THE HEADING
C     LOGICAL APRXDV
C        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
C        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION EXMPT
C        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
C        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
C        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
C     LOGICAL HLFRPT
C        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
C        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
C        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(LIFIXD)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IFLAG
C        ...
C     INTEGER IFP
C        AN INDICATOR FOR THE PRECISION OF THE STACK ALLOCATION TYPE,
C        WHERE IFP=3 INDICATES SINGLE AND IFP=4 INDICATES DOUBLE.
C     INTEGER IPTOUT(5)
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
C     INTEGER IS
C        A VALUE USED TO DETERMINE THE AMOUNT OF WORK SPACE NEEDED
C        BASED ON WHETHER STEP SIZES ARE INPUT OR ARE TO BE CALCULATED.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE FOR
C        IVAPRX LE 0, VCV = THE DEFAULT OPTION
C        IVAPRX EQ 1, VCV = INVERSE(TRANSPOSE(J)*J)
C                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2, VCV = INVERSE(H)
C                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
C                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4, VCV = INVERSE(TRANSPOSE(J)*J)
C                     USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5, VCV = INVERSE(H)
C                     USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
C                     USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7, VCV = THE DEFAULT OPTION
C        WITH J REPRESENTING THE JACOBIAN AND H THE HESSIAN.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF MATRIX XM.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE DIMENSION OF VECTOR IFIXED.
C     INTEGER LPV
C        THE DIMENSION OF VECTOR PV.
C     INTEGER LSCALE
C        THE DIMENSION OF VECTOR SCALE.
C     INTEGER LSDPV
C        THE DIMENSION OF VECTOR SDPV.
C     INTEGER LSDRES
C        THE DIMENSION OF VECTOR SDRES.
C     INTEGER LSTP
C        THE DIMENSION OF VECTOR STP.
C     INTEGER LWT
C        THE DIMENSION OF VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MBO
C        THE MAXIMUM BACK ORDER OPERATOR.
C     INTEGER MBOL
C        THE MAXIMUM BACK ORDER ON THE LEFT
C     EXTERNAL MDLTS1
C        THE STARPAC FORMAT SUBROUTINE FOR COMPUTING THE ARIMA MODEL
C        PREDICTED VALUES.
C     EXTERNAL MDLTS3
C        THE STARPAC FORMAT SUBROUTINE FOR COMPUTING THE ARIMA MODEL
C        RESIDUALS.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     INTEGER MSPEC(4,NFAC)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER MSPECT
C        THE STARTING LOCATION IN THE WORK SPACE FOR
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NALL0
C        NUMBER OF STACK ALLOCATIONS OUTSTANDING.
C     INTEGER NDIGIT
C        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
C     INTEGER NETA
C        THE NUMBER OF ACCURATE DIGITS IN THE MODEL RESULTS.
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NFACT
C        THE NUMBER OF FACTORS IN THE MODEL
C     EXTERNAL NLDRVN
C        THE NAME OF THE ROUTINE WHICH CALCULATES THE DERIVATIVES.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARAR
C        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
C     INTEGER NPARDF
C        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
C     INTEGER NPARMA
C        THE LENGTH OF THE VECTOR PARMA
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     INTEGER NRESTS
C        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     INTEGER PARAR
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        THE AUTOREGRESSIVE PARAMETERS
C     INTEGER PARDF
C        THE STARTING LOCATION IN THE WORK SPACE FOR
C        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
C     INTEGER PARMA
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        THE MOVING AVERAGE PARAMETERS
C     LOGICAL PRTFXD
C        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
C        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
C        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PV(LPV)
C        THE PREDICTED VALUE OF THE FIT.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(LSDPV)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(LSDRES)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(LSTP)
C        THE STEP SIZE ARRAY.
C     EXTERNAL STPAMO
C        THE ROUTINE USED TO PRINT THE OUTPUT FROM THE STEP SIZE SELECTI
C        ROUTINES.
C     INTEGER STPT
C        THE STARTING LOCATION IN /CSTAK/ OF VECTOR STPT CONTAINING
C        THE STEP SIZE ARRAY.
C     INTEGER T
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        A TEMPORARY WORK VECTOR.
C     INTEGER TEMP
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        A TEMPORARY WORK VECTOR
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE VARIANCE-COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(1)
C        THE USER SUPPLIED WEIGHTS, UNUSED WHEN WEIGHT = FALSE.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C     SET VARIOUS PROGRAM VALUES
C
      WEIGHT = .FALSE.
      WT(1) = 1.0D0
      LWT = 1
C
      HLFRPT = .FALSE.
      APRXDV = .TRUE.
      PRTFXD = .TRUE.
      EXMPT = -1.0D0
      NETA = 0
C
      WIDE = .TRUE.
      PAGE = .FALSE.
C
      NDIGIT = 5
C
C     COMPUTE BACK OPERATORS
C
      CALL BACKOP(MSPEC, NFAC, NPARDF, MBOL, MBO, NPARMA, NPARAR)
      NNZW = N - NPARDF
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      NPARE = NPAR
      IF ((IFIXED(1).GE.0) .AND. (NPAR.GE.1)) NPARE =
     +   ICNTI(IFIXED,NPAR,0)
      IS = 0
      IF (STP(1).LE.0.0D0) IS = 1
C
      CALL LDSCMP(25, 0, MAX(IS*2*(N+NPAR),60+NPAR+NPARE) + 4*NFAC,
     +   0, 0, 0, 'D', 5*MBO +
     +   MAX(IS*(10*N+6*MBO+606),
     +        94+4*(N+MBO+101)+NPARE*(3*NPARE+35)/2),
     +   LDSMIN)
C
      CALL AMEER(NMSUB, N, NPAR, NPARE, LDSTAK,
     +   LDSMIN, STP, LSTP, SCALE, LSCALE, IVCV, SAVE, MSPEC, NFAC)
C
      IF (IERR.NE.0) RETURN
C
      CALL STKSET(LDSTAK, 4)
C
C     SET PRINT CONTROL VALUES
C
      CALL PRTCNT(NPRT, NDIGIT, IPTOUT)
C
C     SUBDIVIDE WORKSPACE FOR STEP SIZES
C
      NALL0 = STKST(1)
C
      IFP = 4
C
      STPT = STKGET(NPAR,IFP)
C
      PARDF = STKGET(MBO, IFP)
      PARAR = STKGET(MBO, IFP)
      PARMA = STKGET(MBO, IFP)
      T = STKGET(2*MBO, IFP)
C
      TEMP = T + MBO
C
      NFACT = NFAC
      MSPECT = STKGET(4*NFAC, 2)
C
C     SET UP FOR MODEL
C
      APRXDV = .TRUE.
      M = 1
      IXM = N
      NRESTS = MBO + 101 + N
C
      CALL CPYVII(NFAC, MSPEC(1,1), 4, ISTAK(MSPECT), 1)
      CALL CPYVII(NFAC, MSPEC(2,1), 4, ISTAK(MSPECT+NFAC), 1)
      CALL CPYVII(NFAC, MSPEC(3,1), 4, ISTAK(MSPECT+2*NFAC), 1)
      CALL CPYVII(NFAC, MSPEC(4,1), 4, ISTAK(MSPECT+3*NFAC), 1)
      CALL DCOEF (NFAC, ISTAK(MSPECT+NFAC), ISTAK(MSPECT+3*NFAC),
     +  NPARDF, RSTAK(PARDF), MBO, RSTAK(T))
C
C     COPY SUPPLIED STEP SIZES TO WORK SPACE
C
      CALL DCOPY(LSTP, STP, 1, RSTAK(STPT), 1)
C
      IF (IERR.NE.0) GO TO 10
C
C     SELECT STEP SIZES, IF DESIRED
C
      ISUBHD = 1
      IF (STP(1).LE.0.0D0) CALL AMESTP(Y, N, M, IXM, MDLTS3, PAR, NPAR,
     +  RSTAK(STPT), EXMPT, NETA, SCALE, LSCALE, IPTOUT(1), AMEHDR,
     +  PAGE, WIDE, ISUBHD, HLFRPT, PRTFXD, IFIXED, LIFIXD, STPAMO,
     +  NRESTS-N)
C
      CALL AMECNT(Y, WT, LWT, Y, N, M, IXM, MDLTS1, NLDRVN, APRXDV, DRV,
     +  PAR, NPAR, RES, IFIXED, LIFIXD, RSTAK(STPT), NPAR, MIT,
     +  STOPSS, STOPP, SCALE, LSCALE, DELTA, IVAPRX, RSD, PV, LPV,
     +  SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV, WEIGHT, SAVE, NNZW,
     +  NPARE, AMEHDR, PAGE, WIDE, IPTOUT, NDIGIT, HLFRPT, NRESTS)
C
   10 CONTINUE
C
      CALL STKCLR(NALL0)
C
      RETURN
C
      END
*AMEER
      SUBROUTINE AMEER(NMSUB, N, NPAR, NPARE, LDSTAK, LDSMIN,
     +  STP, LSTP, SCALE, LSCALE, IVCV, SAVE, MSPEC, NFAC)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE ERROR CHECKING ROUTINE FOR NONLINEAR LEAST SQUARES
C     ESTIMATION ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IVCV,LDSMIN,LDSTAK,LSCALE,LSTP,N,NFAC,NPAR,NPARE
      LOGICAL
     +   SAVE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   SCALE(*),STP(*)
      INTEGER
     +   MSPEC(4,*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I,NP,NV
      LOGICAL
     +   HEAD
C
C  LOCAL ARRAYS
      LOGICAL
     +   ERROR(20)
      CHARACTER
     +   LIVCV(8)*1,LLDS(8)*1,LMSPEC(8)*1,LN(8)*1,LNFAC(8)*1,
     +   LNPAR(8)*1,LNPARE(8)*1,LONE(8)*1,LSCL(8)*1,LSTEP(8)*1,
     +   LZERO(8)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EIAGE,EISEQ,EISGE,ERVGT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR(20)
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        THE VARIABLE USED TO INDICATE WHETHER A HEADING IS TO BE
C        PRINTED DURING A GIVEN CALL TO THE ITERATION REPORT (TRUE)
C        OR NOT (FALSE).
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF MATRIX VCV.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     CHARACTER*1 LIVCV(8), LLDS(8), LMSPEC(8), LN(8), LNFAC(8),
C    *   LNPAR(8), LNPARE(8), LONE(8), LSCL(8), LSTEP(8), LZERO(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
C        CHECKED FOR ERRORS.
C     INTEGER LSCALE
C        THE DIMENSION OF VECTOR SCALE.
C     INTEGER LSTP
C        THE DIMENSION OF VECTOR STP.
C     INTEGER MSPEC(4,*)
C        INTEGER MSPEC(4,NFAC)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
C     INTEGER NP
C        THE NUMBER OF PARAMETERS SPECIFIED BY MSPEC.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
C     INTEGER NV
C        *
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION STP(LSTP)
C        THE STEP SIZE ARRAY.
C
C     SET UP NAME ARRAYS
C
      DATA LIVCV(1), LIVCV(2), LIVCV(3), LIVCV(4), LIVCV(5),
     +   LIVCV(6), LIVCV(7), LIVCV(8) /'I','V','C','V',' ',' ',' ',' '/
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +   LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA LMSPEC(1), LMSPEC(2), LMSPEC(3), LMSPEC(4), LMSPEC(5),
     +   LMSPEC(6), LMSPEC(7), LMSPEC(8)
     +  /'M','S','P','C',' ',' ',' ',' '/
      DATA LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8) /'N',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LNFAC(1), LNFAC(2), LNFAC(3), LNFAC(4), LNFAC(5),
     +   LNFAC(6), LNFAC(7), LNFAC(8) /'N','F','A','C',' ',' ',' ',' '/
      DATA LNPAR(1), LNPAR(2), LNPAR(3), LNPAR(4), LNPAR(5),
     +   LNPAR(6), LNPAR(7), LNPAR(8) /'N','P','A','R',' ',' ',' ',
     +   ' '/
      DATA LNPARE(1), LNPARE(2), LNPARE(3), LNPARE(4), LNPARE(5),
     +   LNPARE(6), LNPARE(7), LNPARE(8) /'N','P','A','R','E',' ',' ',
     +   ' '/
      DATA LONE(1), LONE(2), LONE(3), LONE(4), LONE(5),
     +   LONE(6), LONE(7), LONE(8) /'1',' ',' ',' ',' ',' ',' ',' '/
      DATA LSCL(1), LSCL(2), LSCL(3), LSCL(4), LSCL(5),
     +   LSCL(6), LSCL(7), LSCL(8) /'S','C','A','L','E',' ',' ',
     +   ' '/
      DATA LSTEP(1), LSTEP(2), LSTEP(3), LSTEP(4), LSTEP(5),
     +   LSTEP(6), LSTEP(7), LSTEP(8) /'S','T','P',' ',' ',' ',' ',' '/
      DATA LZERO(1), LZERO(2), LZERO(3), LZERO(4), LZERO(5),
     +   LZERO(6), LZERO(7), LZERO(8) /'Z','E','R','O',' ',' ',' ',' '/
C
C     ERROR CHECKING
C
      DO 10 I=1,20
         ERROR(I) = .FALSE.
   10 CONTINUE
C
      IERR = 0
      HEAD = .TRUE.
C
      CALL EISGE(NMSUB, LN, N, 1, 2, HEAD, ERROR(1), LONE)
C
      CALL EISGE(NMSUB, LNFAC, NFAC, 1, 2, HEAD, ERROR(2), LONE)
C
      IF (.NOT. ERROR(2))
     +  CALL EIAGE(NMSUB, LMSPEC, MSPEC, 4, NFAC, 4, 0, 0, HEAD, 1, NV,
     +  ERROR(3), LMSPEC)
C
      IF ((.NOT. ERROR(2)) .AND. (.NOT. ERROR(3))) THEN
        NP = 1
         DO 20 I = 1, NFAC
          NP = NP + MSPEC(1,I) + MSPEC(3,I)
   20   CONTINUE
        CALL EISEQ(NMSUB, LNPAR, NPAR, NP, 1, HEAD, ERROR(4), LNPAR)
C
        IF (.NOT.ERROR(4)) THEN
          CALL EISGE(NMSUB, LNPARE, NPARE, 1, 2, HEAD, ERROR(5), LONE)
          CALL ERVGT(NMSUB, LSTEP, STP, LSTP, 0.0D0, 0, HEAD, 6, NV,
     +      ERROR(8), LZERO)
          CALL ERVGT(NMSUB, LSCL, SCALE, LSCALE, 0.0D0, 0, HEAD, 6, NV,
     +      ERROR(12), LZERO)
          IF (SAVE .AND. (.NOT.ERROR(5)))
     +      CALL EISGE(NMSUB, LIVCV, IVCV, NPARE, 3, HEAD, ERROR(15),
     +      LNPARE)
        END IF
      END IF
C
      IF ((.NOT.ERROR(1)) .AND. (.NOT.ERROR(2)) .AND. (.NOT.ERROR(3))
     +   .AND. (.NOT.ERROR(4)) .AND. (.NOT.ERROR(5)))
     +   CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR(6),
     +   LLDS)
C
      DO 30 I=1,20
         IF (ERROR(I)) GO TO 40
   30 CONTINUE
      RETURN
C
   40 CONTINUE
      IERR = 1
      RETURN
C
      END
*AMEFIN
      SUBROUTINE AMEFIN(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, IFIXD,
     +   PAR, NPAR, NPARE, RES, PAGE, WIDE, IPTOUT, NDIGIT, RSSHLF, RSD,
     +   PVT, SDPVT, SDREST, RD, VCVL, LVCVL, D, AMEHDR, IVCVPT, ISKULL,
     +   NRESTS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPLETES THE ANALYSIS FOR THE NONLINEAR
C     LEAST SQUARES ESTIMATION ROUTINES ONCE THE ESTIMATES
C     HAVE BEEN FOUND.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD,RSSHLF
      INTEGER
     +   IVCVPT,IXM,LVCVL,LWT,M,N,NDIGIT,NNZW,NPAR,NPARE,NRESTS
      LOGICAL
     +   PAGE,WEIGHT,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,*),PAR(*),PVT(*),RD(*),RES(*),SDPVT(*),SDREST(*),VCVL(*),
     +   WT(*),XM(IXM,*),Y(*)
      INTEGER
     +   IFIXD(*),IPTOUT(*),ISKULL(10)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL AMEHDR
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   COND,RSS,YSS
      INTEGER
     +   I,IDF
      LOGICAL
     +   EXACT,PRTFSM
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMEOUT,NLCMP
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION COND
C        THE CONDITION NUMBER OF D.
C     DOUBLE PRECISION D(N,NPAR)
C        THE FIRST DERIVATIVE OF THE MODEL (JACOBIAN).
C     LOGICAL EXACT
C        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
C        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
C     EXTERNAL AMEHDR
C        THE ROUTINE USED TO PRINT THE HEADING
C     INTEGER IDF
C        THE DEGREES OF FREEDOM IN THE FIT.
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IPTOUT(NDIGIT)
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
C     INTEGER ISKULL(10)
C        AN ERROR MESSAGE INDICATOR VARIABLE.
C     INTEGER IVCVPT
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
C        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
C        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(HESSIAN)
C        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                       *INVERSE(HESSIAN)
C     INTEGER IXM
C        THE FIRST DIMENSION OF MATRIX XM.
C     INTEGER LVCVL
C        THE DIMENSION OF VECTOR VCVL.
C     INTEGER LWT
C        THE DIMENSION OF VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NDIGIT
C        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
C     INTEGER NRESTS
C        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     LOGICAL PRTFSM
C        THE VARIABLE USED TO INDICATE WHETHER ANY OF THE SUMMARY
C        INFORMATION IS TO BE PRINTED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PVT(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
C     DOUBLE PRECISION RD(N)
C        THE DIAGONAL ELEMENTS OF THE R MATRIX OF THE Q - R
C        FACTORIZATION OF D.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     DOUBLE PRECISION RSS
C        THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION RSSHLF
C        HALF THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION SDPVT(N)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDREST(N)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION VCVL(LVCVL)
C        THE LOWER HALF OF THE VARIANCE-COVARIANCE MATRIX, STORED
C        ROW WISE.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C     DOUBLE PRECISION YSS
C        THE SUM OF THE SQUARES ABOUT THE MEAN Y VALUE.
C
C     MODIFY VCV TO REFLECT PROPER DEGREES OF FREEDOM
C
      DO 10 I=1,LVCVL
         VCVL(I) = (NRESTS-NPAR)*VCVL(I)/(N-NPAR)
   10 CONTINUE
C
C     COMPUTE RETURNED AND/OR PRINTED VALUES.
C
      CALL NLCMP (Y, WEIGHT, WT, LWT, N, NPAR, NPARE, RES,
     +   D, RD, COND, VCVL, LVCVL, NNZW, IDF, RSSHLF, RSS, RSD, YSS,
     +   EXACT, PVT, SDPVT, SDREST, ISKULL)
C
      PRTFSM = ((IPTOUT(3).NE.0) .OR. (IPTOUT(4).NE.0) .OR.
     +   (IPTOUT(5).NE.0) .OR. (IERR.NE.0))
C
C     PRINT SUMMARY INFORMATION IF DESIRED OR IF AN ERROR FLAG
C     HAS BEEN SET.
C
      IF (PRTFSM) CALL AMEOUT(Y, N,
     +   IFIXD, PAR, NPAR, NPARE, RES, IPTOUT, NDIGIT, PAGE, IDF, COND,
     +   RSS, RSD, YSS, EXACT, PVT, SDPVT, SDREST, VCVL, LVCVL, IVCVPT,
     +   ISKULL, AMEHDR, WIDE)
      RETURN
C
      END
*AMEHDR
      SUBROUTINE AMEHDR(PAGE, WIDE, ISUBHD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS THE PAGE HEADINGS FOR THE NONLINEAR
C     LEAST SQUARES ESTIMATION ROUTINES FOR ARIMA MODELS THAT USE
C     NUMERICAL APPROXIMATIONS TO THE DERIVATIVES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  AUGUST 1, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISUBHD
      LOGICAL
     +   PAGE,WIDE
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VERSP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C
      CALL IPRINT(IPRT)
      IF (PAGE) WRITE (IPRT, 1020)
      CALL VERSP(WIDE)
      IF (PAGE) WRITE (IPRT,1000)
      IF (.NOT.PAGE) WRITE (IPRT,1010)
      PAGE = .TRUE.
C
      IF (ISUBHD.EQ.0) RETURN
C
      GO TO (10), ISUBHD
C
   10 WRITE (IPRT, 1030)
C
      RETURN
C
C     FORMAT STATEMENTS FOR PAGE HEADINGS
C
 1000 FORMAT ('+NONLINEAR LEAST SQUARES ESTIMATION',
     +   ' FOR THE PARAMETERS OF AN ARIMA MODEL, CONTINUED')
 1010 FORMAT ('+', 77(1H*)/
     +   1X, 37H*  NONLINEAR LEAST SQUARES ESTIMATION,
     +   40H FOR THE PARAMETERS OF AN ARIMA MODEL  */
     +   2H *, 16X, 45H             USING BACKFORECASTS             ,
     +   14X, 1H*/1X, 77(1H*))
 1020 FORMAT ('1')
 1030 FORMAT (//30H SUMMARY OF INITIAL CONDITIONS/ 1X, 30('-'))
      END
*AMEISM
      SUBROUTINE AMEISM (AMEHDR, PAGE, WIDE, HLFRPT, NPAR, M, N, NNZW,
     +   WEIGHT, IFIXD, PAR, SCALE, LSCALE, IWORK, LIWORK, RWORK,
     +   LRWORK, RES, APRXDV, STPT, LSTPT, NPARE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS AN INITIAL SUMMARY OF THE STARTING
C     ESTIMATES AND THE CONTROL PARAMETERS FOR THE NONLINEAR
C     LEAST SQUARES SUBROUTINES FOR ARIMA MODELING.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LIWORK,LRWORK,LSCALE,LSTPT,M,N,NNZW,NPAR,NPARE
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,WEIGHT,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),RWORK(*),SCALE(*),STPT(*)
      INTEGER
     +   IFIXD(*),IWORK(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL AMEHDR
C
C  SCALARS IN COMMON
      INTEGER
     +   IFLAG,MBO,MBOL,MSPECT,NFACT,NPARAR,NPARDF,NPARMA,NRESTS,
     +   PARAR,PARDF,PARMA,T,TEMP
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD,RSS
      INTEGER
     +   IAMHD,IPRT,ISUBHD,LMAX0,MXFCAL,MXITER,RFCTOL,XCTOL
C
C  LOCAL ARRAYS
      INTEGER
     +   ISTAK(12)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   DNRM2
      EXTERNAL DNRM2
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMLST,IPRINT,MODSUM
C
C  INTRINSIC FUNCTIONS
      INTRINSIC DBLE,SQRT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /MDLTSC/MSPECT,NFACT,PARDF,NPARDF,PARAR,NPARAR,PARMA,
     +   NPARMA,MBO,MBOL,T,TEMP,NRESTS,IFLAG
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     EXTERNAL AMEHDR
C        THE ROUTINE USED TO PRINT THE HEADING
C     LOGICAL APRXDV
C        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
C        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL HLFRPT
C        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
C        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
C        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
C     INTEGER IAMHD
C        THE INDICATOR VALUE USED TO DESIGNATE THE TYPE OF LIST
C        TO BE GENERATED
C        IF IAMHD=1, THE LIST IS FOR THE INITIAL SUMMARY OF THE
C                    ESTIMATION ROUTINES.
C        IF IAMHD=2, THE LIST IS FOR THE INITIAL REPORT OF THE
C                    FORECASTING ROUTINES.
C        IF IAMHD=3, THE LIST IS FOR THE FINAL REPORT OF THE
C                    ESTIMATION ROUTINES.
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     INTEGER IWORK(LIWORK)
C        WORK SPACE USED BY THE NL2 SUBROUTINES.
C     INTEGER LIWORK
C        THE DIMENSION OF VECTOR IWORK.
C     INTEGER LMAX0
C        THE LOCATION IN RWORK OF THE VALUE INDICATING THE
C        MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     INTEGER LRWORK
C        THE DIMENSION OF VECTOR RWORK.
C     INTEGER LSCALE
C        THE DIMENSION OF VECTOR SCALE.
C     INTEGER LSTPT
C        THE DIMENSION OF VECTOR STPT.
C     INTEGER M
C        A DUMMY VARIABLE.
C     INTEGER MBO
C        THE MAXIMUM BACK ORDER OPERATOR.
C     INTEGER MBOL
C        THE MAXIMUM BACK ORDER ON THE LEFT
C     INTEGER MSPECT
C        THE STARTING LOCATION IN THE WORK SPACE FOR
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER MXFCAL
C        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
C        MAXIMUM NUMBER OF FUNCTION CALLS ALLOWED, EXCLUDING
C        CALLS NECESSARY TO COMPUTE THE DERIVATIVES AND VARIANCE
C        COVARIANCE MATRIX.
C     INTEGER MXITER
C        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
C        MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFACT
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARAR
C        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
C     INTEGER NPARDF
C        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
C     INTEGER NPARMA
C        THE LENGTH OF THE VECTOR PARMA
C     INTEGER NRESTS
C        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     INTEGER PARAR
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        THE AUTOREGRESSIVE PARAMETERS
C     INTEGER PARDF
C        THE STARTING LOCATION IN THE WORK SPACE FOR
C        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
C     INTEGER PARMA
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        THE MOVING AVERAGE PARAMETERS
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     INTEGER RFCTOL
C        THE LOCATION IN RWORK OF THE RELATIVE FUNCTION CONVERGENCE
C        TOLERANCE.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     DOUBLE PRECISION RSS
C        THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION RWORK(LRWORK)
C        WORK SPACE USED BY THE NL2 SUBROUTINES.
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION STPT(LSTPT)
C        THE STEP SIZE ARRAY.
C     INTEGER T
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        A TEMPORARY WORK VECTOR.
C     INTEGER TEMP
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        A TEMPORARY WORK VECTOR
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     INTEGER XCTOL
C        THE LOCATION IN RWORK OF THE PARAMETER CONVERGENCE TOLERANCE.
C
C     IWORK SUBSCRIPT VALUES
C
      DATA MXFCAL/17/, MXITER/18/
C
C     RWORK SUBSCRIPT VALUES
C
      DATA LMAX0/35/, RFCTOL/32/, XCTOL/33/
C
      CALL IPRINT(IPRT)
C
      ISUBHD = 1
      CALL AMEHDR(PAGE, WIDE, ISUBHD)
C
      CALL MODSUM(NFACT, ISTAK(MSPECT))
      IAMHD = 1
      CALL AMLST (IAMHD, PAR, NPAR, NFACT, ISTAK(MSPECT), N, PAR, NPAR,
     +  SCALE, LSCALE, STPT, LSTPT, IFIXD, RSS, RSD, NPARDF, NPARE, 0)
C
      IF (WEIGHT) WRITE (IPRT, 1170) NNZW
      WRITE(IPRT, 1070) IWORK(MXITER)
      WRITE(IPRT, 1090) IWORK(MXFCAL)
      WRITE(IPRT, 1080)
      WRITE(IPRT, 1100) RWORK(RFCTOL)
      WRITE(IPRT, 1110) RWORK(XCTOL)
      WRITE(IPRT, 1120) RWORK(LMAX0)
      RSD = DNRM2(NRESTS, RES, 1)
      RSS = RSD * RSD
      IF (N-NPARDF-NPARE.GE.1)
     +     RSD = RSD / SQRT(DBLE(N-NPARDF-NPARE))
      WRITE (IPRT, 1200) RSS
      WRITE (IPRT, 1210) RSD
      WRITE (IPRT, 1220) N, NPARDF, NPARE, NNZW-NPARE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1070 FORMAT (/37H MAXIMUM NUMBER OF ITERATIONS ALLOWED, 32X, 5H(MIT),
     +   1X, I5)
 1080 FORMAT(/44H CONVERGENCE CRITERION FOR TEST BASED ON THE/)
 1090 FORMAT(/' MAXIMUM NUMBER OF MODEL SUBROUTINE CALLS',
     +   8H ALLOWED, 26X, I5)
 1100 FORMAT (5X, 39H FORECASTED RELATIVE CHANGE IN RESIDUAL,
     +   15H SUM OF SQUARES, 7X, 8H(STOPSS), 1X, G11.4)
 1110 FORMAT(5X, 49H MAXIMUM SCALED RELATIVE CHANGE IN THE PARAMETERS,
     +   13X, 7H(STOPP), 1X, G11.4)
 1120 FORMAT(//' MAXIMUM CHANGE ALLOWED IN THE PARAMETERS',
     +   23H AT THE FIRST ITERATION, 3X, 7H(DELTA), 1X, G11.4)
 1170 FORMAT (/' NUMBER OF NON ZERO WEIGHTED OBSERVATIONS', 27X,
     +   6H(NNZW), 1X, I5)
 1200 FORMAT (/44H RESIDUAL SUM OF SQUARES FOR INPUT PARAMETER,
     +   7H VALUES, 24X, G11.4, '  (BACKFORECASTS INCLUDED)')
 1210 FORMAT (/48H RESIDUAL STANDARD DEVIATION FOR INPUT PARAMETER,
     +   7H VALUES, 14X, 5H(RSD), 1X, G11.4)
 1220 FORMAT (/ 19H BASED ON DEGREES O,
     +   9HF FREEDOM, 1X, I4, 3H - , I3, 3H - , I3, 3H = , I4)
      END
*AMEMN
      SUBROUTINE AMEMN(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, NRESTS,
     +   APRXDV, IFIXD, PAR, PARE, NPAR, RES, PAGE, WIDE,
     +   HLFRPT, STP, LSTP, MIT, STOPSS, STOPP, SCALE, LSCALE, DELTA,
     +   IVAPRX, IPTOUT, NDIGIT, RSD, RESTS, SDPVI, SDRESI, VCVL, LVCVL,
     +   D, IWORK, IIWORK, RWORK, IRWORK, NLHDR, NPARE, PVT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE CONTROLING SUBROUTINE FOR PERFORMING NONLINEAR
C     LEAST SQUARES REGRESSION USING THE NL2 SOFTWARE PACKAGE
C     (IMPLEMENTING THE METHOD OF DENNIS, GAY AND WELSCH).
C     THIS SUBROUTINE WAS ADAPTED FROM SUBROUTINE NL2SOL.
C
C     REFERENCES
C
C     DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1979), AN ADAPTIVE
C             NONLINEAR LEAST-SQUARES ALGORITHM, (BEING REVISED).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IIWORK,IRWORK,IVAPRX,IXM,LSCALE,LSTP,LVCVL,LWT,M,MIT,N,
     +   NDIGIT,NNZW,NPAR,NPARE,NRESTS,SDPVI,SDRESI,VCVL
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,WEIGHT,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(NRESTS,*),PAR(*),PARE(*),PVT(*),RES(*),RESTS(*),RWORK(*),
     +   SCALE(*),STP(*),WT(*),XM(IXM,*),Y(*)
      INTEGER
     +   IFIXD(*),IPTOUT(*),IWORK(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL NLHDR
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   CNVCOD,COVMAT,I,ICNVCD,IVCVPT,QTR,RD,RDI,RSAVE,RSSHLF,S,
     +   SCL
      LOGICAL
     +   CMPDRV,DONE,HEAD,NEWITR,PRTSMY
C
C  LOCAL ARRAYS
      INTEGER
     +   ISKULL(10)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMDRV,AMEFIN,AMEISM,DRV,MDLTS3,NL2ITR,NLERR,NLINIT,
     +   NLITRP,NLSUPK,REPCK,DCOPY
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL APRXDV
C        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
C        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL CMPDRV
C        THE VARIABLE USED TO INDICATE WHETHER DERIVATIVES MUST BE
C        COMPUTED (TRUE) OR NOT (FALSE).
C     INTEGER CNVCOD
C        A VALUE USED TO CONTROL THE PRINTING OF ITERATION REPORTS.
C     INTEGER COVMAT
C        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
C        OF THE BEGINNING OF THE VCV MATRIX.
C     DOUBLE PRECISION D(NRESTS,NPAR)
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     LOGICAL DONE
C        THE VARIABLE USED TO INDICATE WHETHER THIS IS THE FINAL
C        COMPUTATION OF THE JACOBIAN OR NOT.
C     LOGICAL HEAD
C        THE VARIABLE USED TO INDICATE WHETHER A HEADING IS TO BE
C        PRINTED DURING A GIVEN CALL TO THE ITERATION REPORT (TRUE)
C        OR NOT (FALSE).
C     LOGICAL HLFRPT
C        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
C        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
C        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER ICNVCD
C        THE LOCATION IN IWORK OF
C        THE CONVERGENCE CONDITION.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IIWORK
C        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
C     INTEGER IPTOUT(NDIGIT)
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
C     INTEGER IRWORK
C        THE DIMENSION OF THE DOUBLE PRECISION WORK VECTOR RWORK.
C     INTEGER ISKULL(10)
C        AN ERROR MESSAGE INDICATOR VARIABLE.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCVPT
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
C        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
C        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(HESSIAN)
C        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                       *INVERSE(HESSIAN)
C     INTEGER IWORK(IIWORK)
C        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSTP
C        THE ACTUAL LENGTH OF THE VECTOR STP.
C     INTEGER LVCVL
C        THE LENGTH OF THE VECTOR CONTAINING
C        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDLTS3
C        THE STARPAC FORMAT SUBROUTINE FOR COMPUTING THE ARIMA MODEL
C        RESIDUALS.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NDIGIT
C        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
C     LOGICAL NEWITR
C        A FLAG USED TO INDICATE WHETHER A NEW ITERATION HAS BEEN
C        COMPLETED (TRUE) OR NOT (FALSE).
C     EXTERNAL NLHDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
C     INTEGER NRESTS
C        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PARE(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS, BUT ONLY
C        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
C     LOGICAL PRTSMY
C        THE VARIABLE USED TO INDICATE WHETHER THE SUMMARY
C        INFORMATION IS TO BE PRINTED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PVT(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER QTR
C        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
C        THE ARRAY Q TRANSPOSE R.
C     INTEGER RD
C        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK OF
C        THE DIAGONAL ELEMENTS OF THE R MATRIX OF THE Q - R
C        FACTORIZATION OF D.
C     INTEGER RDI
C        THE LOCATION IN RWORK OF THE DIAGONAL ELEMENTS OF THE R
C        MATRIX OF THE Q - R FACTORIZATION OF D.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RESTS(NRESTS)
C        THE RESIDUALS FROM THE ARIMA MODEL.
C     INTEGER RSAVE
C        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
C        THE ARRAY RSAVE.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     INTEGER RSSHLF
C        THE LOCATION IN RWORK OF
C        HALF THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION RWORK(IRWORK)
C        THE DOUBLE PRECISION WORK VECTOR USED BY THE NL2 SUBROUTINES.
C     INTEGER S
C        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
C        THE ARRAY OF SECOND ORDER TERMS OF THE HESSIAN.
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     INTEGER SCL
C        THE INDEX IN RWORK OF THE 1ST VALUE OF THE USER SUPPLIED SCALE
C        VALUE.
C     INTEGER SDPVI
C        THE STARTING LOCATION IN RWORK OF
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     INTEGER SDRESI
C        THE STARTING LOCATION IN RWORK OF THE
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C        PREDICTED DECREASE IN THE RESIDUAL STANDARD DEVIATION (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FORTHE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(LSTP)
C        THE DUMMY STEP SIZE ARRAY.
C     INTEGER VCVL
C        THE STARTING LOCATION IN RWORK OF THE LOWER HALF OF THE
C        VCV MATRIX, STORED ROW WISE.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     IWORK SUBSCRIPT VALUES
C
      DATA CNVCOD /34/, ICNVCD /1/, COVMAT /26/, QTR /49/, RD /51/,
     +   RSAVE /52/, S/53/
      DATA RSSHLF /10/
C
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C
C     INITIALIZE CONTROL PARAMETERS
C
      CALL NLINIT (NRESTS, IFIXD, PAR, NPAR, PARE, NPARE, MIT, STOPSS,
     +   STOPP, SCALE, LSCALE, DELTA, IVAPRX, APRXDV, IVCVPT, IWORK,
     +   IIWORK, RWORK, IRWORK, SCL)
C
      CMPDRV = .TRUE.
      DONE = .FALSE.
      HEAD = .TRUE.
      NEWITR = .FALSE.
      PRTSMY = (IPTOUT(1).NE.0)
C
C     COMPUTE RESIDUALS
C
   10 CALL MDLTS3(PAR, NPAR, XM, N, M, IXM, RESTS)
C
C     PRINT INITIAL SUMMARY
C
      IF (.NOT.PRTSMY) GO TO 30
      CALL AMEISM(NLHDR, PAGE, WIDE, HLFRPT, NPAR, M, N, NNZW, WEIGHT,
     +   IFIXD, PAR, SCALE, LSCALE, IWORK, IIWORK, RWORK, IRWORK, RESTS,
     +   APRXDV, STP, LSTP, NPARE)
      PRTSMY = .FALSE.
C
   30 CONTINUE
C
      IF (.NOT.CMPDRV) GO TO 50
C
      CMPDRV = .FALSE.
C
   40 CONTINUE
C
C     PRINT ITERATION REPORT IF DESIRED
C
      IF ((IPTOUT(2).NE.0) .AND. NEWITR) CALL NLITRP(NLHDR, HEAD, PAGE,
     +   WIDE, IPTOUT(2), NPAR, NNZW, IWORK, IIWORK, RWORK, IRWORK,
     +   IFIXD, PARE, NPARE)
C
C  ***  COMPUTE JACOBIAN  ***
C
      IF (DONE) CALL MDLTS3(PAR, NPAR, XM, N, M, IXM, RESTS)
C
      CALL AMDRV(MDLTS3, DRV, DONE, IFIXD, PAR, NPAR, XM, N, M, IXM,
     +  NRESTS, RESTS, D, WEIGHT, WT, LWT, STP, LSTP, RWORK(SCL), NPARE)
C
      IF (DONE) GO TO 70
C
C     COMPUTE NEXT ITERATION
C
   50 CALL NL2ITR(RWORK(SCL), IWORK, D, NRESTS, NRESTS, NPARE, RESTS,
     +   RWORK, PARE)
C
C     UNPACK PARAMETERS
C
      CALL NLSUPK(PARE, NPARE, PAR, IFIXD, NPAR)
C
      NEWITR = (IWORK(CNVCOD).EQ.0)
      IF (IWORK(1)-2) 10, 40, 60
C
   60 DONE = .TRUE.
      GO TO 40
   70 CONTINUE
C
C     SET ERROR FLAGS, IF NECESSARY
C
      CALL NLERR(IWORK(ICNVCD), ISKULL)
C
C     FINISH COMPUTATIONS AND PRINT ANY DESIRED RESULTS
C
      CALL DCOPY(N, RESTS(NRESTS-N+1), 1, RES(1), 1)
      DO 75 I = 1, N
         PVT(I) = Y(I) - RES(I)
   75 CONTINUE
      SDPVI = IWORK(RSAVE)
      SDRESI = IWORK(QTR)
      VCVL = IWORK(COVMAT)
      IF (VCVL.GE.1) GO TO 80
C
      VCVL = IWORK(S)
      IF (IERR.NE.0) GO TO 80
      ISKULL(1) = 1
      ISKULL(7) = 1
      IERR = 7
C
   80 CONTINUE
C
      LVCVL = NPARE*(NPARE+1)/2
C
      RDI = IWORK(RD)
C
C     REPCK IS CALLED TO AVOID MODIFICATION OF NLS CODE.  FUTURE
C     REVISIONS OF NLS CODE SHOULD INCLUDE MODIFICATIONS NECESSARY
C     TO ELIMINATE NEED TO REPACK D FOR ARIMA CODE.
C
      CALL REPCK(D, NRESTS, NPAR, N)
      CALL AMEFIN(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, IFIXD, PAR,
     +   NPAR, NPARE, RES, PAGE, WIDE, IPTOUT, NDIGIT, RWORK(RSSHLF),
     +   RSD, PVT, RWORK(SDPVI), RWORK(SDRESI), RWORK(RDI),
     +   RWORK(VCVL), LVCVL, D, NLHDR, IVCVPT, ISKULL, NRESTS)
C
      RETURN
C
      END
*AMEOUT
      SUBROUTINE AMEOUT(Y, N, IFIXD,
     +   PAR, NPAR, NPARE, RES, IPTOUT, NDIGIT, PAGE, IDF, COND, RSS,
     +   RSD, YSS, EXACT, PVT, SDPVT, SDREST, VCVL, LVCVL, IVCVPT,
     +   ISKULL, AMEHDR, WIDE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS THE FINAL SUMMARY OUTPUT FROM THE
C     ARIMA ESTIMATION SUBROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   COND,RSD,RSS,YSS
      INTEGER
     +   IDF,IVCVPT,LVCVL,N,NDIGIT,NPAR,NPARE
      LOGICAL
     +   EXACT,PAGE,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PVT(*),RES(*),SDPVT(*),SDREST(*),VCVL(*),Y(*)
      INTEGER
     +   IFIXD(*),IPTOUT(*),ISKULL(10)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL AMEHDR
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR,IFLAG,MBO,MBOL,MSPECT,NFACT,NPARAR,NPARDF,NPARMA,
     +   NRESTS,PARAR,PARDF,PARMA,T,TEMP
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,IAMHD,IPRT,ISUBHD
C
C  LOCAL ARRAYS
      INTEGER
     +   ISTAK(12)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMEPT1,AMEPT2,AMLST,IPRINT,MODSUM,NLSKL,VCVOTF
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
      COMMON /MDLTSC/MSPECT,NFACT,PARDF,NPARDF,PARAR,NPARAR,PARMA,
     +   NPARMA,MBO,MBOL,T,TEMP,NRESTS,IFLAG
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION COND
C        THE CONDITION NUMBER OF D.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL EXACT
C        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
C        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     EXTERNAL AMEHDR
C        THE ROUTINE USED TO PRINT THE HEADING
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IAMHD
C        THE INDICATOR VALUE USED TO DESIGNATE THE TYPE OF LIST
C        TO BE GENERATED
C        IF IAMHD=1, THE LIST IS FOR THE INITIAL SUMMARY OF THE
C                    ESTIMATION ROUTINES.
C        IF IAMHD=2, THE LIST IS FOR THE INITIAL REPORT OF THE
C                    FORECASTING ROUTINES.
C        IF IAMHD=3, THE LIST IS FOR THE FINAL REPORT OF THE
C                    ESTIMATION ROUTINES.
C     INTEGER IDF
C        THE DEGREES OF FREEDOM IN THE FIT.
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IPTOUT(NDIGIT)
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
C     INTEGER ISKULL(10)
C        AN ERROR MESSAGE INDICATOR VARIABLE.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     INTEGER IVCVPT
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
C        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
C        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(HESSIAN)
C        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                       *INVERSE(HESSIAN)
C     INTEGER LVCVL
C        THE DIMENSION OF VECTOR VCVL.
C     INTEGER MBO
C        THE MAXIMUM BACK ORDER OPERATOR.
C     INTEGER MBOL
C        THE MAXIMUM BACK ORDER ON THE LEFT
C     INTEGER MSPECT
C        THE STARTING LOCATION IN THE WORK SPACE FOR
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NDIGIT
C        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
C     INTEGER NFACT
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARAR
C        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
C     INTEGER NPARDF
C        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
C     INTEGER NPARMA
C        THE LENGTH OF THE VECTOR PARMA
C     INTEGER NRESTS
C        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     INTEGER PARAR
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        THE AUTOREGRESSIVE PARAMETERS
C     INTEGER PARDF
C        THE STARTING LOCATION IN THE WORK SPACE FOR
C        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
C     INTEGER PARMA
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        THE MOVING AVERAGE PARAMETERS
C     DOUBLE PRECISION PVT(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     DOUBLE PRECISION RSS
C        THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION SDPVT(N)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDREST(N)
C        THE STANDARDIZED RESIDUALS.
C     INTEGER T
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        A TEMPORARY WORK VECTOR.
C     INTEGER TEMP
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        A TEMPORARY WORK VECTOR
C     DOUBLE PRECISION VCVL(LVCVL)
C        THE LOWER HALF OF THE VARIANCE-COVARIANCE MATRIX, STORED
C        ROW WISE.
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C     DOUBLE PRECISION YSS
C        THE SUM OF THE SQUARES ABOUT THE MEAN Y VALUE.
C
C
      FPLM = D1MACH(2)
C
      CALL IPRINT(IPRT)
C
      IF ((IERR.GE.1) .AND. (IERR.NE.4)) GO TO 60
C
C     TEST FOR EXACT FIT
C
      IF ((IDF.LE.0) .OR. EXACT) GO TO 70
C
C     PRINT ERROR HEADING IF NECESSARY
C
      IF (IERR.EQ.4) CALL NLSKL(ISKULL, PAGE, WIDE, AMEHDR)
C
C     PRINT PRIMARY REPORT
C
      IF ((IERR.EQ.0) .AND. (IPTOUT(3).EQ.0)) GO TO 10
      ISUBHD = 0
      CALL AMEHDR(PAGE, WIDE, ISUBHD)
      CALL AMEPT1(N, Y, PVT, SDPVT, RES, SDREST, IPTOUT, NDIGIT)
C
C     PRINT STANDARDIZED RESIDUAL PLOTS
C
   10 IF (IPTOUT(4).EQ.0) GO TO 20
      ISUBHD = 0
      CALL AMEHDR(PAGE, WIDE, ISUBHD)
C
      CALL AMEPT2 (RES, SDREST, N, RSS)
C
C     PRINT THE COVARIANCE AND CORRELATION MATRIX
C
   20 IF ((IERR.EQ.0) .AND. (IPTOUT(5).EQ.0)) RETURN
      ISUBHD = 0
      CALL AMEHDR(PAGE, WIDE, ISUBHD)
      CALL MODSUM(NFACT, ISTAK(MSPECT))
C
      IF ((IERR.EQ.0) .AND. (IPTOUT(5).LE.1)) GO TO 30
C
      CALL VCVOTF(NPARE, VCVL, LVCVL, .TRUE., NPAR, IFIXD, IVCVPT)
C
C     PRINT ANALYSIS SUMMARY
C
   30 WRITE (IPRT,1000)
      IAMHD = 3
      CALL AMLST(IAMHD, PAR, NPAR, NFACT, ISTAK(MSPECT), N, VCVL, LVCVL,
     +   PAR, NPAR, PAR, NPAR, IFIXD, RSS, RSD, NPARDF, NPARE, IDF)
      WRITE (IPRT,1050) COND
C
      IF (RSS.GT.YSS) WRITE (IPRT,1060)
C
      RETURN
C
C     PRINT OUT ERROR HEADING
C
   60 CALL NLSKL(ISKULL, PAGE, WIDE, AMEHDR)
C
      IF (IERR.LE.2) RETURN
C
C     PRINT SECONDARY REPORT
C
   70 CONTINUE
      ISUBHD = 0
      CALL AMEHDR(PAGE, WIDE, ISUBHD)
      CALL MODSUM(NFACT, ISTAK(MSPECT))
      IF (IERR.NE.0) WRITE (IPRT,1080)
      WRITE (IPRT,1000)
      IAMHD = 2
      CALL AMLST(IAMHD, PAR, NPAR, NFACT, ISTAK(MSPECT), N, VCVL, LVCVL,
     +   PAR, NPAR, PAR, NPAR, IFIXD, RSS, RSD, NPARDF, NPARE, IDF)
      IF (IERR.NE.3) WRITE (IPRT,1050) COND
C
      IF ((IERR.EQ.0) .AND. (.NOT.EXACT) .AND. (IDF.LE.0)) WRITE
     +   (IPRT,1070)
      IF ((IERR.EQ.0) .AND. EXACT) WRITE (IPRT,1090)
C
      IF (IERR.NE.0) GO TO 100
C
      DO 90 I=1,N
         SDREST(I) = 0.0D0
         SDPVT(I) = 0.0D0
   90 CONTINUE
C
      RETURN
C
  100 CONTINUE
C
      DO 110 I=1,N
         SDREST(I) = FPLM
         SDPVT(I) = FPLM
  110 CONTINUE
C
C     PRINT OUT ERROR EXIT STATISTICS
C
      CALL AMEPT1(N, Y, PVT, SDPVT, RES, SDREST, IPTOUT, NDIGIT)
C
C     WIPE OUT SDREST VECTOR
C
      DO 120 I=1,N
         SDREST(I) = FPLM
  120 CONTINUE
C
C     WIPE OUT VCV MATRIX
C
      DO 140 I=1,LVCVL
         VCVL(I) = FPLM
  140 CONTINUE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (///33H ESTIMATES FROM LEAST SQUARES FIT/1X, 33('-'))
 1050 FORMAT (/29H APPROXIMATE CONDITION NUMBER, 10X, G15.7)
 1060 FORMAT (//52H THE RESIDUAL SUM OF SQUARES AFTER THE LEAST SQUARES,
     +   20H FIT IS GREATER THAN/35H THE SUM OF SQUARES ABOUT THE MEAN ,
     +   19HY OBSERVATION.  THE, 14H MODEL IS LESS/17H REPRESENTATIVE O,
     +   39HF THE DATA THAN A SIMPLE AVERAGE.  DATA, 15H AND MODEL SHOU,
     +   2HLD/48H BE CHECKED TO BE SURE THAT THEY ARE COMPATABLE.)
 1070 FORMAT (/49H THE DEGREES OF FREEDOM FOR THIS PROBLEM IS ZERO.,
     +   54H  STATISTICAL ANALYSIS OF THE RESULTS IS NOT POSSIBLE.)
 1080 FORMAT (//40H THE FOLLOWING SUMMARY SHOULD BE USED TO, 8H ANALYZE,
     +   30H THE ABOVE MENTIONED PROBLEMS.)
 1090 FORMAT (/50H THE LEAST SQUARES FIT OF THE DATA TO THE MODEL IS,
     +   35H EXACT TO WITHIN MACHINE PRECISION./20H STATISTICAL ANALYSI,
     +   33HS OF THE RESULTS IS NOT POSSIBLE.)
      END
*AMEPT1
      SUBROUTINE AMEPT1(N, Y, PVT, SDPVT, RES, SDREST, IPTOUT, NDIGIT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBOUTINE PRINTS THE DATA SUMMARY FOR THE NONLINEAR
C     LEAST SQUARES SUBROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NDIGIT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PVT(*),RES(*),SDPVT(*),SDREST(*),Y(*)
      INTEGER
     +   IPTOUT(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,IPRT,NMAX
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,OBSSM2
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IPTOUT(NDIGIT)
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NDIGIT
C        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
C     INTEGER NMAX
C        THE MAXIMUM NUMBER OF ROWS TO BE PRINTED.
C     DOUBLE PRECISION PVT(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION SDPVT(N)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDREST(N)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
      FPLM = D1MACH(2)
C
      CALL IPRINT(IPRT)
C
      WRITE (IPRT,1100)
      WRITE (IPRT,1000)
      WRITE (IPRT, 1110)
C
      NMAX = N
      IF ((MAX(IPTOUT(3),1).EQ.1) .AND. (N.GE.45))
     +  NMAX = MIN(N,40)
C
C     PRINT OBSERVATION SUMMARY
C
      CALL OBSSM2(N, Y, PVT, SDPVT, RES, SDREST, 1, NMAX)
C
      IF (NMAX.GE.N) GO TO 200
C
      DO 195 I = 1, 3
         WRITE (IPRT, 1150)
  195 CONTINUE
C
C     PRINT LAST LINE OF OUTPUT
C
      CALL OBSSM2(N, Y, PVT, SDPVT, RES, SDREST, N, N)
C
  200 CONTINUE
C
      IF ((IERR.EQ.4)) WRITE (IPRT, 1080)
      IF ((IERR.GT.0) .AND. (IERR.NE.4)) WRITE (IPRT, 1090)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/ 5X, 16X, '  -----PREDICTED  ----STD DEV OF', 16X,
     +   '  ---STD'/
     +   2X, 3HROW, '  --------SERIES  ---------VALUE',
     +   '  ----PRED VALUE  ------RESIDUAL  ---RES')
 1080 FORMAT (// 37H *  NC  -  VALUE NOT COMPUTED BECAUSE,
     +   48H THE STANDARD DEVIATION OF THE RESIDUAL IS ZERO.)
 1090 FORMAT (// 29H *  NC  -  VALUE NOT COMPUTED,
     +   54H BECAUSE CONVERGENCE PROBLEMS PREVENTED THE COVARIANCE,
     +   28H MATRIX FROM BEING COMPUTED.)
 1100 FORMAT (//' RESULTS FROM LEAST SQUARES FIT'/ 1X, 31('-'))
 1110 FORMAT (' ')
 1150 FORMAT (4X, '.', 4(15X, '.'), 7X, '.')
      END
*AMEPT2
      SUBROUTINE AMEPT2 (RES, SDREST, N, RSS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE, ADAPTED FROM OMNITAB II, PRINTS
C     THE FOUR STANDARDIZED RESIDUAL PLOTS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RES(*),SDREST(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   AN,DOT,FAC1,FAC2,FPLM,GAMMA,PI,RATIO,ROWDIV,ROWMAX,ROWMID,
     +   ROWMIN,XDIV,XMAX,XMIN,YLABEL,YMAX,YMIN
      INTEGER
     +   I,I1,I2,IMID,IPLOT,IPRB,IPRT,IROW,IX,K,L,NCOL,NCOLP1,
     +   NCOLPL,NCOLT2,NDOT,NROW
      CHARACTER
     +   IBLANK*1,IMINUS*1,IPLUS*1,ISTAR*1
C
C  LOCAL ARRAYS
      CHARACTER
     +   LINE(113)*1
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      LOGICAL
     +   MVCHK
      EXTERNAL D1MACH,MVCHK
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DOTC,GETPI,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC INT,MAX,MIN,MOD
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AN
C        THE NUMBER OF OBSERVATIONS, USED IN COMPUTING
C        THE NORMAL PROBABILITY PLOT.
C     DOUBLE PRECISION DOT
C        THE DOT PRODUCT USED TO COMPUTE THE CORRELATION COEFFICIENT.
C     DOUBLE PRECISION FAC1, FAC2
C        FACTORS USED IN COMPUTING THE NORMAL PROBABILITY PLOT.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     DOUBLE PRECISION GAMMA
C        A VALUE USED IN COMPUTING THE NORMAL PROBABILITY PLOT.
C     INTEGER I
C        AN INDEX VARIABLE.
C     CHARACTER*1 IBLANK
C        THE VALUE OF THE CHARACTER -BLANK-.
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IMID
C        THE MIDPOINT OF THE AUTOCORRELATION PLOT.
C     CHARACTER*1 IMINUS
C        THE CHARACTER MINUS.
C     INTEGER IPLOT
C        AN INDICATOR VARIABLE DESIGNATING WHETHER THE FIRST OR
C        SECOND SET OF TWO PLOTS ARE BEING PRINTED.
C     CHARACTER*1 IPLUS
C        THE CHARACTER PLUS.
C     INTEGER IPRB
C        THE LOCATION IN THE PLOT STRING OF THE SYMBOL FOR THE
C        PROBABILITY PLOT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IROW
C        THE ROW OF THE VARIABLES BEING PLOTTED.
C     CHARACTER*1 ISTAR
C        THE CHARACTER STAR.
C     INTEGER IX
C        THE LOCATION IN THE PLOT STRING OF THE SYMBOL FOR THE PLOTS
C        VERSUS THE INDEPENDENT VARIABLE.
C     INTEGER I1, I2
C        INDEX VALUES.
C     INTEGER K
C        AN INDEX VARIABLE.
C     INTEGER L
C        AN INDEX VARIABLE.
C     CHARACTER*1 LINE(113)
C        THE SYMBOLS (BLANKS AND CHARACTERS) FOR A GIVEN LINE
C        OF THE PLOT.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NCOL, NCOLPL, NCOLP1, NCOLT2
C        THE NUMBER OF COLUMNS IN THE PLOT, NCOL+L, NCOL+1,
C        AND NCOL * 2.
C     INTEGER NDOT
C        THE NUMBER OF POINTS MAKING UP DOT.
C     INTEGER NROW
C        THE NUMBER OF COLUMNS IN THE PLOT.
C     DOUBLE PRECISION PI
C        THE VALUE OF PI.
C     DOUBLE PRECISION RATIO
C        A VALUE USED TO PRODUCE THE NORMAL PROBABILITY PLOT.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION ROWDIV
C        THE VALUE OF A DIVISION ALONG THE -ROW- AXIS.
C     DOUBLE PRECISION ROWMAX
C        THE LARGEST ROW VALUE.
C     DOUBLE PRECISION ROWMID
C        THE MIDPOINT OF THE RANGE OF THE ROWS PLOTTED.
C     DOUBLE PRECISION ROWMIN
C        THE SMALLEST ROW VALUE PLOTTED.
C     DOUBLE PRECISION RSS
C        THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION SDREST(N)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION XDIV
C        THE VALUE OF A DIVISION ALONG THE X AXIS.
C     DOUBLE PRECISION XMAX
C        THE LARGEST VALUE ALONG THE X AXIS.
C     DOUBLE PRECISION XMIN
C        THE SMALLEST VALUE ALONG THE X AXIS.
C     DOUBLE PRECISION YLABEL
C        THE LABEL TO BE PRINTED ALONG THE Y AXIS.
C     DOUBLE PRECISION YMAX
C        THE LARGEST VALUE ALONG THE Y AXIS
C     DOUBLE PRECISION YMIN
C        THE SMALLEST VALUE ALONG THE Y AXIS.
C
      DATA IPLUS/'+'/, IMINUS/'-'/, ISTAR/'*'/, IBLANK/' '/
C
      CALL IPRINT(IPRT)
C
      FPLM = D1MACH(2)
C
C     CHECK FOR INSUFFICIENT POINTS TO PLOT
C
      IF (IERR.NE.4) GO TO 20
      DO 10 I = 1, N
         IF (SDREST(I).NE.FPLM) GO TO 20
   10 CONTINUE
      WRITE (IPRT, 1090)
      RETURN
C
   20 CONTINUE
C
C     INITIALIZE VALUES FOR PROBABILITY PLOT
C
      CALL GETPI(PI)
      GAMMA = PI/8.0D0
      AN = N
      FAC1 = 1.0D0 / (AN - 2.0D0*GAMMA + 1.0D0)
      FAC2 = 10.0D0
C
C     INITIALIZE THE PLOT SIZE (IN PLOT UNITS)
C
      NROW = 26
C
C     BEGIN COMPUTATIONS FOR FIRST SET OF PLOTS
C
      IPLOT = 1
      NCOL = 111
C
C     SET X AXIS LIMITS FOR STANDARDIZED RESIDUAL VS ROW PLOT,
C
      ROWMIN = 1
      ROWMAX = N
C
      ROWMID = (ROWMAX+ROWMIN)/2.0D0
      ROWDIV = (ROWMAX-ROWMIN)/(NCOL-1)
C
C     PRINT TITLES FOR FIRST PLOTS
C
      WRITE (IPRT,1000)
      GO TO 90
C
C     BEGIN COMPUTATIONS FOR SECOND SET OF PLOTS
C
   40 IPLOT = 2
      NCOL = 51
C
C     SET AXIS LIMITS FOR THE STANDARDIZED RESIDUALS VS
C     STANDARDIZED RESIDUALS LAGGED BY ONE AND FOR PROBABILITY PLOT
C
      XMIN = -3.75D0
      XMAX = 3.75D0
      XDIV = (XMAX-XMIN)/(NCOL-1)
C
C     PRINT TITLES FOR SECOND PLOTS
C
      WRITE (IPRT,1050)
C
C     WRITE FIRST LINE OF PLOTS
C
   90 CONTINUE
C
C     PRINT PLOTS, ONE LINE AT A TIME
C
      NCOLP1 = NCOL + 1
      NCOLT2 = 2*NCOL
      YLABEL = 3.75D0
      YMAX = FPLM
      YMIN = 4.05D0
      DO 160 K=1,NROW
         YMIN = YMIN - 0.3D0
         IF (-3.70D0.GE.YMIN) YMIN = -FPLM
         DO 100 L=1,NCOL
            NCOLPL = L + NCOL
            LINE(L) = IBLANK
            IF (IPLOT.EQ.2) LINE(NCOLPL) = IBLANK
            IF ((K.NE.1) .AND. (K.NE.NROW)) GO TO 100
               LINE(L) = IMINUS
               IF (IPLOT.EQ.2) LINE(NCOLPL) = IMINUS
               IF ((MOD(L,10).NE.1) .AND. (L.NE.1+NCOL/2)) GO TO 100
                  LINE(L) = IPLUS
                  IF (IPLOT.EQ.2) LINE(NCOLPL) = IPLUS
  100    CONTINUE
         DO 130 I=1,N
            IF (.NOT.MVCHK(SDREST(I),FPLM)) THEN
               IF ((SDREST(I).GT.YMIN) .AND. (SDREST(I).LE.YMAX)) THEN
                  IF (IPLOT.EQ.1) THEN
                      IROW = INT(((I-ROWMIN)/ROWDIV)+1.5D0)
                      LINE(IROW) = ISTAR
                   ELSE
                      RATIO = (AN-GAMMA) * FAC1
                      IPRB = INT(4.91D0*(RATIO**0.14D0-
     +                          (1.0D0-RATIO)**0.14D0)*FAC2) + 77
                      IF (IPRB.LE.NCOL) IPRB = NCOL+1
                      IF (IPRB.GE.103) IPRB = 102
                      LINE(IPRB) = ISTAR
                      AN = AN - 1.0D0
                      IF ((AN.LT.2.0D0) .AND. (N.LE.10)) THEN
                         GAMMA = 1.0D0/3.0D0
                      END IF
                   END IF
                END IF
             END IF
  130    CONTINUE
C
C     SET PLOT LINE FOR CORRELATION PLOT OF SECOND SET OF PLOTS
C
         IF (IPLOT.EQ.2) THEN
            IMID = (NCOL-1)/2
            IF (K.LE.N-1) THEN
               DOT = 0.0D0
               CALL DOTC(RES, 0.0D0, N, RES(K+1), 0.0D0,
     +                   N-K, DOT, NDOT)
               IX = INT(IMID*DOT/RSS) + IMID + 1
               I1 = MIN(IX,IMID+1)
               I2 = MAX(IX,IMID+1)
               DO 135 IX=I1,I2
                  LINE(IX) = ISTAR
  135          CONTINUE
            END IF
         END IF
         IF (MOD(K,5).EQ.1) THEN
            IF (IPLOT.EQ.1) THEN
               WRITE (IPRT,2020) YLABEL, (LINE(L),L=1,NCOL)
            ELSE
               WRITE (IPRT,1020) K, (LINE(L),L=1,NCOL), YLABEL,
     +                           (LINE(L),L=NCOLP1,NCOLT2)
            END IF
            YLABEL = YLABEL - 1.5D0
         ELSE
            IF (IPLOT.EQ.1) THEN
               WRITE (IPRT,2030) (LINE(L),L=1,111)
            ELSE
               WRITE (IPRT,1030) (LINE(L),L=1,102)
            END IF
         END IF
         YMAX = YMIN
  160 CONTINUE
C
C     PRINT BOTTOM LINE OF GRAPHS
C
      IF (IPLOT.EQ.1) THEN
C
C     PRINT X AXIS LABELS FOR FIRST SET OF PLOTS
C
         WRITE (IPRT,1040) ROWMIN, ROWMID, ROWMAX
         GO TO 40
C
C     PRINT X AXIS LABELS FOR SECOND SET OF PLOTS
C
      ELSE
         WRITE (IPRT,1070)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/51X, 23H STD RES VS ROW NUMBER )
 1020 FORMAT (1X, I5, '+', 51A1, '+', 2X, F5.2, '+', 51A1, '+')
 1030 FORMAT (6X, '-', 51A1, '-', 7X, '-', 51A1, '-')
 1040 FORMAT (1X, F8.1, 47X, F8.1, 47X, F8.1)
 1050 FORMAT (/13X, 'AUTOCORRELATION FUNCTION OF RESIDUALS',
     +   23X, 36H NORMAL PROBABILITY PLOT OF STD RES )
 1070 FORMAT (4X, 5H-1.00, 22X, 3H0.0, 21X, 4H1.00, 5X, 4H-2.5, 23X,
     +   3H0.0, 22X, 3H2.5)
 1090 FORMAT (// 1X, 13(1H*)/ 1X, 13H*  WARNING  */ 1X, 13(1H*)//
     +   54H THE STANDARDIZED RESIDUAL PLOTS HAVE BEEN SUPPRESSED.,
     +   45H  NONE OF THE STANDARDIZED RESIDUALS COULD BE,
     +   10H COMPUTED,/
     +   50H BECAUSE FOR EACH OBSERVATION EITHER THE WEIGHT OR,
     +   48H THE STANDARD DEVIATION OF THE RESIDUAL IS ZERO.)
 2020 FORMAT (1X, F5.2, '+', 111A1, '+')
 2030 FORMAT (6X, '-', 111A1, '-')
      END
*AMESTP
      SUBROUTINE AMESTP(XM, N, M, IXM, MDL, PAR, NPAR, STP,
     +   EXMPT, NETA, SCALE, LSCALE, NPRT, HDR, PAGE, WIDE, ISUBHD,
     +   HLFRPT, PRTFXD, IFIXED, LIFIXD, STPOUT, PVPAD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CONTROLS THE STEP SIZE SELECTION PROCESS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   EXMPT
      INTEGER
     +   ISUBHD,IXM,LIFIXD,LSCALE,M,N,NETA,NPAR,NPRT,PVPAD
      LOGICAL
     +   HLFRPT,PAGE,PRTFXD,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),SCALE(*),STP(*),XM(IXM,*)
      INTEGER
     +   IFIXED(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL HDR,MDL,STPOUT
C
C  SCALARS IN COMMON
      DOUBLE PRECISION
     +   Q
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ETA,EXM,FPLRS,SCL,TAU
      INTEGER
     +   CD,FD,FDLAST,FDSAVE,IFAILJ,IFIXD,IFP,ITEMP,J,MXFAIL,NALL0,
     +   NDD,NDGT1,NEXMPT,NFAIL,NFAILJ,PARTMP,PV,PVMCD,PVNEW,PVPCD,
     +   PVSTP,PVTEMP
      LOGICAL
     +   HEAD
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      INTEGER
     +   STKGET,STKST
      EXTERNAL D1MACH,STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CPYVII,ETAMDL,SETIV,STKCLR,STPMN
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,INT,LOG10,MAX,MIN
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
      COMMON /NOTOPT/Q
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER CD
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE CENTRAL DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION ETA
C        THE RELATIVE NOISE IN THE MODEL.
C     DOUBLE PRECISION EXM
C        THE PROPORTION OF OBSERVATIONS ACTUALLY USED FOR WHICH THE
C        COMPUTED NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE
C        EXEMPTED FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
C     DOUBLE PRECISION EXMPT
C        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
C        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
C        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
C     INTEGER FD
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
C     INTEGER FDLAST
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
C        FOR THE LAST STEP SIZE TRIED.
C     INTEGER FDSAVE
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
C        FOR THE BEST STEP SIZE TRIED SO FAR.
C     DOUBLE PRECISION FPLRS
C        THE FLOATING POINT LARGEST RELATIVE SPACING.
C     EXTERNAL HDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     LOGICAL HLFRPT
C        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
C        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
C        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFAILJ
C        THE STARTING LOCATION IN ISTAK FOR
C        THE ARRAY OF INDICATOR VARIABLES DESIGNATING WHETHER
C        THE SETP SIZE SELECTED WAS SATISFACOTRY FOR A GIVEN
C        OBSERVATION AND THE JTH PARAMETER.
C     INTEGER IFIXD
C        THE STARTING LOCATION IN /CSTAK/ OF VECTOR IFIXD CONTAINING
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IFIXED(LIFIXD)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IFP
C        AN INDICATOR FOR THE PRECISION OF THE STACK ALLOCATION TYPE,
C        WHERE IFP=3 INDICATES SINGLE AND IFP=4 INDICATES DOUBLE.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     INTEGER ITEMP
C        THE STARTING LOCATION IN ISTAK FOR
C        A TEMPORARY STORAGE VECTOR.
C     INTEGER IXM
C        THE FIRST DIMENSION OF MATRIX XM.
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER LIFIXD
C        THE DIMENSION OF VECTOR IFIXED.
C     INTEGER LSCALE
C        THE DIMENSION OF VECTOR SCALE.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER MXFAIL
C        THE MAXIMUM NUMBER OF FAILURES FOR ANY PARAMETER.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NALL0
C        NUMBER OF STACK ALLOCATIONS OUTSTANDING.
C     INTEGER NDD
C        THE NUMBER OF DECIMAL DIGITS CARRIED FOR A SINGLE
C        PRECISION DOUBLE PRECISION NUMBER.
C     INTEGER NDGT1
C        THE NUMBER OF RELIABLE DIGITS IN THE MODEL USED, EITHER
C        SET TO THE USER SUPPLIED VALUE OF NETA, OR COMPUTED
C        BY ETAMDL.
C     INTEGER NETA
C        THE NUMBER OF ACCURATE DIGITS IN THE MODEL RESULTS.
C     INTEGER NEXMPT
C        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
C        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
C        SIZE STILL BE CONSIDERED OK.
C     INTEGER NFAIL
C        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP SIZE
C        FOR THE PARAMETER DOES NOT MEET THE CRITERIA.
C     INTEGER NFAILJ
C        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP SIZE
C        FOR THE JTH PARAMETER DOES NOT MEET THE CRITERIA.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     INTEGER PARTMP
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE MODIFIED MODEL PARAMETERS
C     LOGICAL PRTFXD
C        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
C        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
C        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
C     INTEGER PV
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     INTEGER PVMCD
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     INTEGER PVNEW
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPNEW.
C     INTEGER PVPAD
C       ADDITIONAL WORKSPACE NEEDED IN PV FOR THE EVALUATION OF THE
C       MODEL.
C     INTEGER PVPCD
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCD.
C     INTEGER PVSTP
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STP(J).
C     INTEGER PVTEMP
C        THE STARTING LOCATION IN THE WORK AREA OF
C        A TEMPORY STORAGE LOCATION FOR PREDICTED VALUES BEGINS.
C     DOUBLE PRECISION Q
C        A DUMMY VARIABLE WHICH IS USED, ALONG WITH COMMON NOTOPT (NO
C        OPTIMIZATION), TO COMPUTE THE STEP SIZE.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SCL
C        THE ACTUAL TYPICAL SIZE USED.
C     DOUBLE PRECISION STP(NPAR)
C        THE SELECTED STEP SIZES.
C     EXTERNAL STPOUT
C        THE ROUTINE FOR PRINTING THE OUTPUT.
C     DOUBLE PRECISION TAU
C        THE AGREEMENT TOLERANCE.
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION XM(IXM,M)
C        THE INDEPENDENT VARIABLE.
C
C
      NALL0 = STKST(1)
C
      FPLRS = D1MACH(4)
      IFP = 4
C
C     SET PRINT CONTROLS
C
      HEAD = .TRUE.
C
C     SUBDIVIDE WORK AREA
C
      IFIXD = STKGET(NPAR, 2)
      ITEMP = STKGET(N, 2)
      IFAILJ = STKGET(N, 2)
      NFAIL = STKGET(NPAR, 2)
C
      CD = STKGET(N, IFP)
      FD = STKGET(N, IFP)
      FDLAST = STKGET(N, IFP)
      FDSAVE = STKGET(N, IFP)
      PV = STKGET(N+PVPAD, IFP)
      PVMCD = STKGET(N+PVPAD, IFP)
      PVNEW = STKGET(N+PVPAD, IFP)
      PVPCD = STKGET(N+PVPAD, IFP)
      PVSTP = STKGET(N+PVPAD, IFP)
      PVTEMP = STKGET(N+PVPAD, IFP)
C
      IF (IERR .EQ. 1) RETURN
C
      PARTMP = CD
C
C     SET UP IFIXD
C
      IF (IFIXED(1).LT.0) CALL SETIV(ISTAK(IFIXD), NPAR, 0)
      IF (IFIXED(1).GE.0) CALL CPYVII(NPAR, IFIXED, 1, ISTAK(IFIXD), 1)
C
C     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
C
      NDD = INT(-LOG10(FPLRS))
C
      IF ((NETA .GE. 2) .AND. (NETA .LE. NDD)) THEN
            ETA = 10.0D0 ** (-NETA)
            NDGT1 = NETA
      ELSE
            CALL ETAMDL(MDL, PAR, NPAR, XM, N, M, IXM, ETA, NDGT1,
     +         RSTAK(PARTMP), RSTAK(PVTEMP), 0)
      END IF
C
      TAU = MIN(ETA**0.25D0, 0.01D0)
C
      EXM = EXMPT
      IF ((EXM.LT.0.0D0) .OR. (EXM.GT.1.0D0)) EXM = 0.10D0
      NEXMPT = INT(EXM * N)
      IF (EXM .NE. 0.0D0) NEXMPT = MAX(NEXMPT, 1)
C
C     COMPUTE PREDICTED VALUES OF THE MODEL USING THE INPUT PARAMETER
C     ESTIMATES
C
      CALL MDL(PAR, NPAR, XM, N, M, IXM, RSTAK(PV))
C
      MXFAIL = 0
      NFAILJ = NFAIL
C
      DO 120 J = 1, NPAR
C
         IF (SCALE(1) .LE. 0.0D0) THEN
            IF (PAR(J) .EQ. 0.0D0) THEN
               SCL = 1.0D0
            ELSE
               SCL = ABS(PAR(J))
            END IF
         ELSE
            SCL = SCALE(J)
         END IF
C
         CALL STPMN(J, XM, N, M, IXM, MDL, PAR, NPAR, NEXMPT,
     +      ETA, TAU, SCL, STP(J), ISTAK(NFAILJ), ISTAK(IFAILJ),
     +      RSTAK(CD), ISTAK(ITEMP), RSTAK(FD), RSTAK(FDLAST),
     +      RSTAK(FDSAVE), RSTAK(PV), RSTAK(PVMCD), RSTAK(PVNEW),
     +      RSTAK(PVPCD), RSTAK(PVSTP), RSTAK(PVTEMP))
C
C     COMPUTE THE MAXIMUM NUMBER OF FAILURES FOR ANY PARAMETER
C
         MXFAIL = MAX(ISTAK(NFAILJ), MXFAIL)
C
C     PRINT RESULTS IF THEY ARE DESIRED
C
         IF ((NPRT.NE.0) .OR. (MXFAIL.GT.NEXMPT))
     +      CALL STPOUT(HEAD, N, EXM, NEXMPT, NDGT1, J, PAR, NPAR,
     +         STP, ISTAK(NFAIL), ISTAK(IFAILJ), SCALE,  LSCALE, HDR,
     +         PAGE, WIDE, ISUBHD, NPRT, PRTFXD, ISTAK(IFIXD))
C
         NFAILJ = NFAILJ + 1
C
  120 CONTINUE
C
      HLFRPT = .FALSE.
      IF ((NPRT.NE.0) .OR. (MXFAIL.GT.NEXMPT)) HLFRPT = .TRUE.
C
      IF (MXFAIL.GT.NEXMPT) IERR = 2
C
      CALL STKCLR(NALL0)
C
      RETURN
C
      END
*AMFCNT
      SUBROUTINE AMFCNT(Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK,
     +   NFCST, NFCSTO, IFCSTO, NPRT, FCST, IFCST, FCSTSD, NMSUB, SAVE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE CONTROLLING SUBROUTINE FOR FORECASTING USING
C     ARIMA MODELS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IFCST,LDSTAK,N,NFAC,NFCST,NFCSTO,NPAR,NPRT
      LOGICAL
     +   SAVE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FCST(*),FCSTSD(*),PAR(*),Y(*)
      INTEGER
     +   IFCSTO(*),MSPEC(4,*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR,IFLAG,MBO,MBOL,MSPECT,NFACT,NPARAR,NPARDF,NPARMA,
     +   NRESTS,PARAR,PARDF,PARMA,T,TEMP
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   F,FSD,IFP,IS,LDSMIN,NALL0,PV
      LOGICAL
     +   PAGE,WIDE
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMFER,AMFMN,BACKOP,CPYVII,LDSCMP,STKCLR,STKSET
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
      COMMON /MDLTSC/MSPECT,NFACT,PARDF,NPARDF,PARAR,NPARAR,PARMA,
     +   NPARMA,MBO,MBOL,T,TEMP,NRESTS,IFLAG
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER F
C        THE STARTING LOCATION IN THE WORK VECTOR FOR
C        THE FORECASTS.
C     DOUBLE PRECISION FCST(IFCST,NFCSTO)
C        THE STORAGE ARRAY FOR THE FORECASTS.
C     DOUBLE PRECISION FCSTSD(NFCST)
C        THE STORAGE ARRAY FOR THE STANDARD DEVIATIONS OF THE FORECASTS.
C     INTEGER FSD
C        THE STARTING LOCATION IN THE WORK VECTOR FOR
C        THE STANDARD DEVIATIONS OF THE FORECASTS.
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFCST
C        THE FIRST DIMENSION OF THE ARRAY FCST.
C     INTEGER IFCSTO(NFCSTO)
C        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
C     INTEGER IFP
C        AN INDICATOR FOR THE PRECISION OF THE STACK ALLOCATION TYPE,
C        WHERE IFP=3 INDICATES SINGLE AND IFP=4 INDICATES DOUBLE.
C     INTEGER IS
C        A VALUE USED TO DETERMINE THE AMOUNT OF WORK SPACE NEEDED
C        BASED ON WHETHER STEP SIZES ARE INPUT OR ARE TO BE CALCULATED.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER MBO
C        THE MAXIMUM BACK ORDER OPERATOR.
C     INTEGER MBOL
C        THE MAXIMUM BACK ORDER ON THE LEFT
C     INTEGER MSPEC(4,NFAC)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER MSPECT
C        THE STARTING LOCATION IN THE WORK SPACE FOR
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NALL0
C        NUMBER OF STACK ALLOCATIONS OUTSTANDING.
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NFACT
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NFCST
C        THE NUMBER OF FORECASTS.
C     INTEGER NFCSTO
C        THE NUMBER OF THE ORIGINS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARAR
C        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
C     INTEGER NPARDF
C        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
C     INTEGER NPARMA
C        THE LENGTH OF THE VECTOR PARMA
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     INTEGER PARAR
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        THE AUTOREGRESSIVE PARAMETERS
C     INTEGER PARDF
C        THE STARTING LOCATION IN THE WORK SPACE FOR
C        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
C     INTEGER PARMA
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        THE MOVING AVERAGE PARAMETERS
C     INTEGER PV
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        THE PREDICTED VALUES
C     INTEGER NRESTS
C        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     INTEGER T
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        A TEMPORARY WORK VECTOR.
C     INTEGER TEMP
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        A TEMPORARY WORK VECTOR
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C     SET VARIOUS PROGRAM VALUES
C
      WIDE = .TRUE.
      PAGE = .FALSE.
C
C     COMPUTE BACK OPERATORS
C
      CALL BACKOP(MSPEC, NFAC, NPARDF, MBOL, MBO, NPARMA, NPARAR)
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      IS = 0
C
      CALL LDSCMP(8, 0, 4*NFAC,
     +   0, 0, 0, 'D', 5*MBO + 2*NFCST + N + MBO + 101, LDSMIN)
C
      CALL AMFER(NMSUB, N, NPAR, LDSTAK, LDSMIN, SAVE, MSPEC, NFAC,
     +   IFCST, NFCST)
C
      IF (IERR.EQ.0) THEN
C
        CALL STKSET(LDSTAK, 4)
C
C       SUBDIVIDE WORKSPACE FOR STEP SIZES
C
        NALL0 = STKST(1)
C
        IFP = 4
C
        PARDF = STKGET(MBO, IFP)
        PARAR = STKGET(MBO, IFP)
        PARMA = STKGET(MBO, IFP)
        T = STKGET(2*MBO, IFP)
C
        TEMP = T + MBO
C
        NFACT = NFAC
        MSPECT = STKGET(4*NFAC, 2)
        F = STKGET(NFCST, IFP)
        FSD = STKGET(NFCST, IFP)
C
C       SET UP FOR MODEL
C
        NRESTS = MBO + 101 + N
        PV = STKGET(NRESTS, IFP)
C
        CALL CPYVII(NFAC, MSPEC(1,1), 4, ISTAK(MSPECT), 1)
        CALL CPYVII(NFAC, MSPEC(2,1), 4, ISTAK(MSPECT+NFAC), 1)
        CALL CPYVII(NFAC, MSPEC(3,1), 4, ISTAK(MSPECT+2*NFAC), 1)
        CALL CPYVII(NFAC, MSPEC(4,1), 4, ISTAK(MSPECT+3*NFAC), 1)
C
C       CALL MAIN ROUTINE FOR COMPUTING AND PRINTING FORECASTS
C
        CALL AMFMN (PAR, RSTAK(PV), Y, NPAR, N, NFAC, ISTAK(MSPECT),
     +    RSTAK(PARDF), NPARDF, RSTAK(T), RSTAK(TEMP), RSTAK(PARAR),
     +    RSTAK(PARMA), MBO, MBOL, N-NRESTS+1, N, NPRT, SAVE,
     +    NFCST, NFCSTO, IFCSTO, FCST, IFCST, FCSTSD, RSTAK(F),
     +    RSTAK(FSD), NPARAR, NPARMA)
      END IF
C
      CALL STKCLR(NALL0)
C
      RETURN
C
      END
*AMFER
      SUBROUTINE AMFER(NMSUB, N, NPAR, LDSTAK, LDSMIN,
     +  SAVE, MSPEC, NFAC, IFCST, NFCST)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE ERROR CHECKING ROUTINE FOR NONLINEAR LEAST SQUARES
C     ESTIMATION ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IFCST,LDSMIN,LDSTAK,N,NFAC,NFCST,NPAR
      LOGICAL
     +   SAVE
C
C  ARRAY ARGUMENTS
      INTEGER
     +   MSPEC(4,*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I,NP,NV
      LOGICAL
     +   HEAD
C
C  LOCAL ARRAYS
      LOGICAL
     +   ERROR(20)
      CHARACTER
     +   LIFCST(8)*1,LLDS(8)*1,LMSPEC(8)*1,LN(8)*1,LNFAC(8)*1,
     +   LNFCST(8)*1,LNPAR(8)*1,LONE(8)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EIAGE,EISEQ,EISGE
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR(20)
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        THE VARIABLE USED TO INDICATE WHETHER A HEADING IS TO BE
C        PRINTED DURING A GIVEN CALL TO THE ITERATION REPORT (TRUE)
C        OR NOT (FALSE).
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     CHARACTER*1 LIFCST(8), LLDS(8), LMSPEC(8), LN(8), LNFAC(8),
C    *  LNPAR(8), LNFCST(8), LONE(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
C        CHECKED FOR ERRORS.
C     INTEGER MSPEC(4,NFAC)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NFCST
C        THE NUMBER OF FORECASTS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NV
C        *
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C
C     SET UP NAME ARRAYS
C
      DATA LIFCST(1), LIFCST(2), LIFCST(3), LIFCST(4), LIFCST(5),
     +   LIFCST(6), LIFCST(7), LIFCST(8)
     +  /'I','F','C','S','T',' ',' ',' '/
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +   LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA LMSPEC(1), LMSPEC(2), LMSPEC(3), LMSPEC(4), LMSPEC(5),
     +   LMSPEC(6), LMSPEC(7), LMSPEC(8)
     +  /'M','S','P','C',' ',' ',' ',' '/
      DATA LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8) /'N',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LNFAC(1), LNFAC(2), LNFAC(3), LNFAC(4), LNFAC(5),
     +   LNFAC(6), LNFAC(7), LNFAC(8) /'N','F','A','C',' ',' ',' ',' '/
      DATA LNFCST(1), LNFCST(2), LNFCST(3), LNFCST(4), LNFCST(5),
     +   LNFCST(6), LNFCST(7), LNFCST(8)
     +  /'N','F','C','S','T',' ',' ',' '/
      DATA LNPAR(1), LNPAR(2), LNPAR(3), LNPAR(4), LNPAR(5),
     +   LNPAR(6), LNPAR(7), LNPAR(8) /'N','P','A','R',' ',' ',' ',
     +   ' '/
      DATA LONE(1), LONE(2), LONE(3), LONE(4), LONE(5),
     +   LONE(6), LONE(7), LONE(8) /'1',' ',' ',' ',' ',' ',' ',' '/
C
C     ERROR CHECKING
C
      DO 10 I=1,20
         ERROR(I) = .FALSE.
   10 CONTINUE
C
      IERR = 0
      HEAD = .TRUE.
C
      CALL EISGE(NMSUB, LN, N, 1, 2, HEAD, ERROR(1), LONE)
C
      CALL EISGE(NMSUB, LNFAC, NFAC, 1, 2, HEAD, ERROR(2), LONE)
C
      IF (.NOT. ERROR(2))
     +  CALL EIAGE(NMSUB, LMSPEC, MSPEC, 4, NFAC, 4, 0, 0, HEAD, 1, NV,
     +  ERROR(3), LMSPEC)
C
      IF ((.NOT. ERROR(2)) .AND. (.NOT. ERROR(3))) THEN
        NP = 1
         DO 15 I = 1, NFAC
           NP = NP + MSPEC(1,I) + MSPEC(3,I)
   15   CONTINUE
        CALL EISEQ(NMSUB, LNPAR, NPAR, NP, 1, HEAD, ERROR(4), LNPAR)
      END IF
C
      IF ((.NOT.ERROR(1)) .AND. (.NOT.ERROR(2)) .AND. (.NOT.ERROR(3))
     +   .AND. (.NOT.ERROR(4)) .AND. (.NOT.ERROR(5)))
     +   CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR(6),
     +   LLDS)
C
      IF (SAVE)
     +   CALL EISGE(NMSUB, LIFCST, IFCST, NFCST, 3, HEAD, ERROR(15),
     +   LNFCST)
C
      DO 20 I=1,20
         IF (ERROR(I)) GO TO 30
   20 CONTINUE
      RETURN
C
   30 CONTINUE
      IERR = 1
      RETURN
C
      END
*AMFHDR
      SUBROUTINE AMFHDR(PAGE, WIDE, ISUBHD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS THE PAGE HEADINGS FOR THE NONLINEAR
C     LEAST SQUARES ESTIMATION ROUTINES FOR ARIMA MODELS THAT USE
C     NUMERICAL APPROXIMATIONS TO THE DERIVATIVES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  AUGUST 1, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISUBHD
      LOGICAL
     +   PAGE,WIDE
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VERSP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C
      CALL IPRINT(IPRT)
      IF (PAGE) WRITE (IPRT, 1020)
      CALL VERSP(WIDE)
      IF (PAGE) WRITE (IPRT,1000)
      IF (.NOT.PAGE) WRITE (IPRT,1010)
      PAGE = .TRUE.
C
      IF (ISUBHD.EQ.0) RETURN
C
      GO TO (10), ISUBHD
C
   10 WRITE (IPRT, 1030)
C
      RETURN
C
C     FORMAT STATEMENTS FOR PAGE HEADINGS
C
 1000 FORMAT ('+ARIMA FORECASTING, CONTINUED')
 1010 FORMAT ('+', 23(1H*)/ ' *  ARIMA FORECASTING  *', /1X, 23(1H*))
 1020 FORMAT ('1')
 1030 FORMAT (//' MODEL SUMMARY'/' -------------')
      END
*AMFMN
      SUBROUTINE AMFMN (PAR, PV, Y, NPAR, N, NFAC, MSPECT,
     +  PARDF, NPARDF, T, TEMP, PARAR, PARMA, MBO, MBOL, N1, N2, NPRT,
     +  SAVE, NFCST, NFCSTO, IFCSTO, FCST, IFCST, FCSTSD, F,
     +  FSD, NPARAR, NPARMA)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN ROUTINE FOR COMPUTING AND PRINTING THE ARIMA
C     FORECASTS
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IFCST,MBO,MBOL,N,N1,N2,NFAC,NFCST,NFCSTO,NPAR,NPARAR,
     +   NPARDF,NPARMA,NPRT
      LOGICAL
     +   SAVE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   F(*),FCST(IFCST,*),FCSTSD(*),FSD(*),PAR(*),PARAR(*),PARDF(*),
     +   PARMA(*),PV(N1:N2),T(*),TEMP(*),Y(*)
      INTEGER
     +   IFCSTO(*),MSPECT(NFAC,4)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CONST,PMU,RSD,RSS,T975,WSUM,WSUMT
      INTEGER
     +   I,I1,IDF,IF,IFC,IFLAG,IFO,IFOMIN,IPRT,J,K,NT
      LOGICAL
     +   PAGE
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   PPFT,DDOT
      EXTERNAL PPFT,DDOT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMFHDR,AMFOUT,AMLST,DCOEF,IPRINT,MDLTS2,MODSUM,MULTBP
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CONST
C        THE CONSTANT TERM IN THE MODEL, MODELING EITHER THE SERIES
C        MEAN OR A DETERMINISTIC TREND.
C     DOUBLE PRECISION F(NFCST)
C        THE FORECASTS.
C     DOUBLE PRECISION FCST(IFCST,NFCSTO)
C        THE STORAGE ARRAY FOR THE FORECASTS.
C     DOUBLE PRECISION FCSTSD(NFCST)
C        THE STORAGE ARRAY FOR THE STANDARD DEVIATIONS OF THE FORECASTS.
C     DOUBLE PRECISION FSD(NFCST)
C        THE STANDARD DEVIATIONS OF THE FORECASTS.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IF
C        AN INDEX VARIABLE.
C     INTEGER IFCST
C        THE FIRST DIMENSION OF THE ARRAY FCST.
C     INTEGER IFCSTO(NFCSTO)
C        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
C     INTEGER IFLAG
C        AN INDICATOR VARIABLE DESIGNATING WHETHER THE BACK FORECASTS
C        WERE ESSENTIALLY ZERO (IFLAG=0) OR NOT (IFLAG=1).
C     INTEGER IFO
C        THE INDEX OF THE ORIGIN BEING USED.
C     INTEGER IFOMIN
C        THE SMALLEST ORIGIN USED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER I1
C        AN INDEX VALUE.
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER K
C        AN INDEX VARIABLE.
C     INTEGER MBO
C        THE MAXIMUM BACK ORDER OPERATOR.
C     INTEGER MBOL
C        THE MAXIMUM BACK ORDER ON THE LEFT
C     INTEGER MSPECT(NFAC,4)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NFCST
C        THE NUMBER OF FORECASTS.
C     INTEGER NFCSTO
C        THE NUMBER OF THE ORIGINS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARAR
C        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
C     INTEGER NPARDF
C        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
C     INTEGER NPARMA
C        THE LENGTH OF THE VECTOR PARMA
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     INTEGER NT
C        THE NUMBER OF PARAMETERS IN T, WHERE NT = MBOL
C     INTEGER N1
C        THE LOWER BOUND FOR PV.
C     INTEGER N2
C        THE UPPER BOUND FOR PV.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PARAR(MBO)
C        THE AUTOREGRESSIVE PARAMETERS
C     DOUBLE PRECISION PARDF(NPARDF)
C        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS.
C     DOUBLE PRECISION PARMA(MBO)
C        THE MOVING AVERAGE PARAMETERS
C     DOUBLE PRECISION PMU
C        THE VALUE OF MU, I.E., THE TREND OR MEAN.
C     DOUBLE PRECISION PV(N1:N2)
C        THE PREDICTED VALUE OF THE FIT.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     DOUBLE PRECISION RSS
C        THE RESIDUAL SUM OF SQUARES.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION T(2*MBO)
C        A TEMPORARY WORK VECTOR.
C     DOUBLE PRECISION TEMP(MBO)
C        A TEMPORARY WORK VECTOR
C     DOUBLE PRECISION T975
C        THE VALUE OF THE 97.5 PERCENT POINT FUNCTION FOR THE
C        T DISTRIBUTION.
C     DOUBLE PRECISION WSUM
C        THE SUM OF THE WEIGHTS SQUARED, USED TO COMPUTE THE
C        STANDARD DEVIATION OF THE FORECAST.
C     DOUBLE PRECISION WSUMT
C        A TEMPORARY STORAGE LOCATION FOR WSUM.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
      CALL IPRINT (IPRT)
C
C     COMPUTE DIFFERENCING PARAMETERS
C
      CALL DCOEF (NFAC, MSPECT(1,2), MSPECT(1,4), NPARDF, PARDF, MBO, T)
C
C     COMPUTE RESIDUALS, GIVEN VALUES OF PARAMETERS
C
      CALL MDLTS2 (PAR, PV, Y, NPAR, N, NFAC, MSPECT, PMU,
     +  PARDF, NPARDF, T, TEMP, PARAR, PARMA, MBO, N1, N2, IFLAG)
      IDF = N - NPARDF - NPAR
      RSS = DDOT(N, PV(1), 1, PV(1), 1)
      RSD = SQRT(RSS / IDF)
C
C     PRINT INITIAL SUMMARY
C
      PAGE = .FALSE.
      IF (NPRT.EQ.0) GO TO 10
      CALL AMFHDR(PAGE, .TRUE., 2)
      CALL MODSUM(NFAC, MSPECT)
      CALL AMLST(2, PAR, NPAR, NFAC, MSPECT, N, PAR, NPAR, PAR,
     +  NPAR, PAR, NPAR, PAR, RSS, RSD, NPARDF, NPAR, IDF)
      PAGE = .TRUE.
C
   10 CONTINUE
C
C     COMBINE PARDF AND PARAR INTO T
C
      NT = NPARAR + NPARDF
      CALL MULTBP(PARAR, NPARAR, PARDF, NPARDF, T, NT, MBO)
C
C     COMPUTE CONSTANT
C
      CONST = 0.0D0
      IF (PMU.NE.0.0D0) THEN
        IF (NPARAR.GE.1) THEN
          DO 20 J = 1, NPARAR
            CONST = CONST - PARAR(J)
   20     CONTINUE
        END IF
        CONST = (1.0D0 + CONST) * PMU
      END IF
C
C     FIND LOWEST ORIGIN
C
      IFOMIN = IFCSTO(1)
      DO 30 IFO = 1, NFCSTO
        IFOMIN = MIN(IFOMIN, IFCSTO(IFO))
   30 CONTINUE
C
C     SET TEMP TO BACKFORECAST OF Y IF NECESSARY
C
      IF ((MBOL.GE.1) .AND. (IFOMIN.LT.MBOL)) THEN
        I1 = IFOMIN-MBOL+1
        DO 60 I = 0, I1, -1
          K = 1-I
          TEMP(K) = CONST
          DO 40 J = 1, MBOL
            IF (I+J.LE.N) THEN
              IF (I+J.GE.1) THEN
                TEMP(K) = TEMP(K) + T(J)*Y(I+J)
              ELSE
                TEMP(K) = TEMP(K) + T(J)*TEMP(MBOL-I-J)
              END IF
            END IF
   40     CONTINUE
          IF (NPARMA.GE.1) THEN
            DO 50 J =1, NPARMA
              IF (I+J.LE.N) TEMP(K) = TEMP(K) - PARMA(J)*PV(I+J)
   50       CONTINUE
          END IF
   60   CONTINUE
      END IF
C
C      COMPUTE WEIGHTS FOR COMPUTING STANDARD DEVIATIONS OF THE FORECAST
C
      DO 65 J = 1, NFCST
        FSD(J) = 0.0D0
        IF (MBOL.GE.1) THEN
          DO 64 I = 1, MBOL
            IF (J-I.GE.1) THEN
              FSD(J) = FSD(J) + T(I)*FSD(J-I)
            ELSE
              IF (J-I.EQ.0) FSD(J) = FSD(J) + T(I)
            END IF
   64     CONTINUE
        END IF
        IF (J.LE.NPARMA) FSD(J) = FSD(J) - PARMA(J)
   65 CONTINUE
C
C     COMPUTE STANDARD DEVIATIONS OF FORECASTS
C
      WSUM = 1.0D0
      DO 66 I = 1, NFCST
        WSUMT =WSUM
        WSUM = WSUM + FSD(I)*FSD(I)
        FSD(I) = SQRT(WSUMT)*RSD
   66 CONTINUE
C
C     SET PERCENT POINT VALUE FOR 95 PERCENT CONFIDENCE LIMITS
C
      T975 = PPFT(0.975D0, N-NPAR)
C
C     COMPUTE FORECASTS FOR EACH ORIGIN
C
      DO 100 IFO = 1, NFCSTO
        IFC = IFCSTO(IFO)
        IF ((IFC.LT.1) .OR. (IFC.GT.N)) IFC = N
        DO 90 IF = 1, NFCST
          F(IF) = CONST
          IF (MBOL.GE.1) THEN
            DO 70 J = 1, MBOL
              K = IF + IFC-J
              IF (K.LE.0) THEN
                F(IF) = F(IF) + T(J)*TEMP(1-K)
              ELSE
                IF (K.LE.IFC) THEN
                  F(IF) = F(IF) + T(J)*Y(K)
                ELSE
                  F(IF) = F(IF) + T(J)*F(IF-J)
                END IF
              END IF
   70       CONTINUE
          END IF
          IF (NPARMA.GE.1) THEN
            DO 80 J = 1, NPARMA
              K = IF + IFC - J
              IF (K.LE.IFC) F(IF) = F(IF) - PARMA(J)*PV(K)
   80       CONTINUE
          END IF
          IF (SAVE) FCST(IF,IFO) = F(IF)
   90   CONTINUE
C
C     PRINT RESULTS FROM THIS ORIGIN
C
        IF (NPRT.NE.0)
     +    CALL AMFOUT(F, FSD, N, NFCST, IFCSTO, IFO, NFCSTO, Y, T975,
     +    PAGE)
C
  100 CONTINUE
C
      RETURN
C
      END
*AMFOUT
      SUBROUTINE AMFOUT(F, FSD, N, NFCST, IFCSTO, IFO, NFCSTO, Y,
     +  T975, PAGE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRODUCES ARIMA FORECASTING OUTPUT
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   T975
      INTEGER
     +   IFO,N,NFCST,NFCSTO
      LOGICAL
     +   PAGE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   F(*),FSD(*),Y(*)
      INTEGER
     +   IFCSTO(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FL,FU,SCALE,YMN,YMX
      INTEGER
     +   I,IEND,IF,ILIM,INTER,IPF,IPFL,IPFU,IPRT,IPY,IY,J
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YLIM(4)
      CHARACTER
     +   LINE(53)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMFHDR,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC INT,MAX,MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION F(NFCST)
C        THE FORECASTS.
C     DOUBLE PRECISION FL
C        THE LOWER 95 PERCENT CONFIDENCE LIMIT FOR THE FORECAST
C     DOUBLE PRECISION FSD(NFCST)
C        THE STANDARD DEVIATIONS OF THE FORECASTS.
C     DOUBLE PRECISION FU
C        THE UPPER 95 PERCENT CONFIDENCE LIMIT FOR THE FORECAST
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IEND
C        THE LAST LOCATION IN THE PLOT STRING.
C     INTEGER IF
C        AN INDEX VARIABLE.
C     INTEGER IFCSTO(NFCSTO)
C        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
C     INTEGER IFO
C        THE INDEX OF THE ORIGIN BEING USED.
C     INTEGER ILIM
C        THE NUMBER OF LOCATIONS IN YLIM.
C     INTEGER INTER
C        THE NUMBER OF PLOT INTERVALS.
C     INTEGER IPF
C        THE LOCATION IN THE PLOT STRING OF THE FORECAST.
C     INTEGER IPFL
C        THE LOCATION IN THE PLOT STRING OF THE FORECAST LOWER
C        CONFIDENCE LIMIT.
C     INTEGER IPFU
C        THE LOCATION IN THE PLOT STRING OF THE FORECAST UPPER
C        CONFIDENCE LIMIT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IPY
C        THE LOCATION IN THE PLOT STRING OF THE OBSERVED VALUE.
C     INTEGER IY
C        AN INDEX VARIABLE.
C     INTEGER J
C        AN INDEX VARIABLE.
C     CHARACTER*1 LINE(53)
C        THE ARRAY OF SYMBOLS TO BE PLOTTED.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFCST
C        THE NUMBER OF FORECASTS.
C     INTEGER NFCSTO
C        THE NUMBER OF THE ORIGINS.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION SCALE
C        THE PLOT SCALE.
C     DOUBLE PRECISION T975
C        THE VALUE OF THE 97.5 PERCENT POINT FUNCTION FOR THE
C        T DISTRIBUTION.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C     DOUBLE PRECISION YLIM(4)
C        THE VALUES OF THE AXIS LABELS.
C     DOUBLE PRECISION YMN
C        THE MINIMUM VALUE TO BE PLOTTED.
C     DOUBLE PRECISION YMX
C        THE MAXIMUM VALUE TO BE PLOTTED.
C
C     SET VARIABLES FOR PLOTS
C
      CALL IPRINT(IPRT)
      INTER = 50
      IEND = INTER + 1
      ILIM = 4
C
C     COMPUTE SCALE FOR PLOT
C
      YMN = F(NFCST)-T975*FSD(NFCST)
      YMX = F(NFCST)+T975*FSD(NFCST)
      IY = IFCSTO(IFO)
      DO 10 I = 1, NFCST
        YMN = MIN(YMN, F(I)-T975*FSD(I))
        YMX = MAX(YMX, F(I)+T975*FSD(I))
        IF ((IY.GE.1) .AND. (IY.LE.N)) THEN
          YMN = MIN(YMN, Y(IY))
          YMX = MAX(YMX, Y(IY))
          IY = IY + 1
        END IF
   10 CONTINUE
      IF (IFCSTO(IFO).GE.2) THEN
        DO 20 IY = MAX(IFCSTO(IFO)-4, 1), IFCSTO(IFO)-1
          YMN = MIN(YMN, Y(IY))
          YMX = MAX(YMX, Y(IY))
   20   CONTINUE
      END IF
C
      SCALE = (YMX-YMN) / INTER
C
C     PRINT PLOT HEADINGS
C
      DO 30 I = 1, ILIM
        YLIM(I) = YMN + SCALE*I*10.0D0
   30 CONTINUE
C
      CALL AMFHDR(PAGE, .TRUE., 0)
      WRITE (IPRT, 1030) IFO
      WRITE (IPRT, 1000) YMN, YLIM(2), YLIM(4),
     +  YLIM(1), YLIM(4), YMX
C
C     BEGIN PLOTTING
C
      DO 80 I=MAX(IFCSTO(IFO)-4,1), IFCSTO(IFO)+NFCST
         IF (I.NE.IFCSTO(IFO)) THEN
           DO 40 J = 1, IEND
             LINE(J) = ' '
   40      CONTINUE
         ELSE
           DO 50 J = 1, IEND
             LINE(J) = '.'
   50      CONTINUE
         END IF
         IF (I.LE.IFCSTO(IFO)) THEN
           IPY = INT(((Y(I)-YMN) / SCALE) + 1.5D0)
           LINE(IPY) = '*'
           WRITE (IPRT, 1020) I, (LINE(J),J=1,IEND), I, Y(I)
         ELSE
           IF = I-IFCSTO(IFO)
           FL = F(IF) - T975*FSD(IF)
           FU = F(IF) + T975*FSD(IF)
           IF (I.LE.N) THEN
             IPFL = INT(((FL-YMN) / SCALE) + 1.5D0)
             IPFU = INT(((FU-YMN) / SCALE) + 1.5D0)
             DO 60 J = IPFL, IPFU
               LINE(J) = '-'
   60        CONTINUE
             LINE(IPFL) = '('
             LINE(IPFU) = ')'
             IPY = INT(((Y(I)-YMN) / SCALE) + 1.5D0)
             LINE(IPY) = '*'
             IPF = INT(((F(IF)-YMN) / SCALE) + 1.5D0)
             IF (IPF.NE.IPY) THEN
               LINE(IPF) = 'X'
             ELSE
               LINE(IPF) = '2'
             END IF
             WRITE (IPRT, 1010) I, (LINE(J),J=1,IEND), I,
     +         F(IF), FL, FU, Y(I)
           ELSE
             IPFL = INT(((FL-YMN) / SCALE) + 1.5D0)
             IPFU = INT(((FU-YMN) / SCALE) + 1.5D0)
             DO 70 J = IPFL, IPFU
               LINE(J) = '-'
   70        CONTINUE
             LINE(IPFL) = '('
             LINE(IPFU) = ')'
             IPF = INT(((F(IF)-YMN) / SCALE) + 1.5D0)
             LINE(IPF) = 'X'
             WRITE (IPRT, 1010) I, (LINE(J),J=1,IEND), I,
     +         F(IF), FL, FU
           END IF
         END IF
   80 CONTINUE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (//
     +  82X, ' --------------------95  PERCENT'/
     +  1X, 3(G15.8, 5X), 21X,
     +  ' --------------CONFIDENCE LIMITS',
     +  ' ---------ACTUAL'/
     +  11X, 2(G15.8, 5X), G15.8,
     +  ' ------FORECASTS ----------LOWER',
     +  ' ----------UPPER -------IF KNOWN'/
     +  9X, 5('I---------'), 'I', 6X,
     +  ' ------------[X] ------------[(]',
     +  ' ------------[)] ------------[*]')
 1010 FORMAT (2X, I5, 1X, 'I', 51A1, 'I', I5, 4(1X, G15.8))
 1020 FORMAT (2X, I5, 1X, 'I', 51A1, 'I', I5, 49X, G15.8)
 1030 FORMAT (//' FORECASTS FOR ORIGIN ', I2)
C
      END
*AMLST
      SUBROUTINE AMLST (IAMHD, PAR, NPAR, NFAC, MSPECT, N, VCVL,
     +   LVCVL, SCALE, LSCALE, STPT, LSTPT, IFIXD, RSS, RSD, NPARDF,
     +   NPARE, IDF)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRINTS THE PARAMETER SUMMARY OUTPUT FROM THE
C     ARIMA FORECASTING SUBROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 4, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD,RSS
      INTEGER
     +   IAMHD,IDF,LSCALE,LSTPT,LVCVL,N,NFAC,NPAR,NPARDF,NPARE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),SCALE(*),STPT(*),VCVL(*)
      INTEGER
     +   IFIXD(*),MSPECT(NFAC,4)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM,T975
      INTEGER
     +   IPARMN,IPARMX,IPRT,LBLTYP
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   PPFT,D1MACH
      EXTERNAL PPFT,D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMLST1,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER IAMHD
C        THE INDICATOR VALUE USED TO DESIGNATE THE TYPE OF LIST
C        TO BE GENERATED
C        IF IAMHD=1, THE LIST IS FOR THE INITIAL SUMMARY OF THE
C                    ESTIMATION ROUTINES.
C        IF IAMHD=2, THE LIST IS FOR THE INITIAL REPORT OF THE
C                    FORECASTING ROUTINES.
C        IF IAMHD=3, THE LIST IS FOR THE FINAL REPORT OF THE
C                    ESTIMATION ROUTINES.
C     INTEGER IDF
C        THE DEGREES OF FREEDOM IN THE FIT.
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IPARMN
C        THE SMALLEST PARAMETER INDEX INCLUDED IN THIS TERM.
C     INTEGER IPARMX
C        THE LARGEST PARAMETER INDEX INCLUDED IN THIS TERM.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER LSCALE
C        THE DIMENSION OF VECTOR SCALE.
C     INTEGER LSTPT
C        THE DIMENSION OF VECTOR STPT.
C     INTEGER LVCVL
C        THE DIMENSION OF VECTOR VCVL.
C     INTEGER MSPECT(NFAC,4)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPARDF
C        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     DOUBLE PRECISION RSS
C        THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION STPT(LSTPT)
C        THE STEP SIZE ARRAY.
C     DOUBLE PRECISION T975
C        THE VALUE OF THE 97.5 PERCENT POINT FUNCTION FOR THE
C        T DISTRIBUTION.
C     DOUBLE PRECISION VCVL(LVCVL)
C        THE LOWER HALF OF THE VARIANCE-COVARIANCE MATRIX, STORED
C        ROW WISE.
C
      FPLM = D1MACH(2)
C
      CALL IPRINT(IPRT)
C
C     PRINT HEADING FOR INFORMATION ABOUT PARAMETERS
C
      WRITE(IPRT, 1001)
C
      IF (IAMHD .EQ. 1) WRITE(IPRT, 1004)
      IF (IAMHD .EQ. 2) WRITE(IPRT, 1005)
      IF (IAMHD .EQ. 3) WRITE(IPRT, 1006)
      WRITE(IPRT, 1001)
C
C     PRINT MODEL SUMMARY INFORMATION
C
      IPARMN = 1
      IPARMX = 0
      T975 = PPFT(0.95D0, N-NPAR)
C
C     PRINT AUTOREGRESSIVE TERMS
C
      LBLTYP = 1
      CALL AMLST1 (IAMHD, PAR, NPAR, MSPECT, NFAC, VCVL, LVCVL,
     +  SCALE, LSCALE, STPT, LSTPT, IPARMN, IPARMX, LBLTYP, T975, IFIXD)
C
C     PRINT MEAN OR TREND TERM
C
      LBLTYP = 2
      CALL AMLST1 (IAMHD, PAR, NPAR, MSPECT, 1, VCVL, LVCVL,
     +  SCALE, LSCALE, STPT, LSTPT, IPARMN, IPARMX, LBLTYP, T975, IFIXD)
C
C     PRINT MOVING AVERAGE TERMS
C
      LBLTYP = 3
      CALL AMLST1 (IAMHD, PAR, NPAR, MSPECT, NFAC, VCVL, LVCVL,
     +  SCALE, LSCALE, STPT, LSTPT, IPARMN, IPARMX, LBLTYP, T975, IFIXD)
C
      WRITE (IPRT, 1160) N
      IF (IAMHD.GE.2)
     +   WRITE (IPRT, 1040) RSS, RSD, N, NPARDF, NPARE, IDF
      RETURN
C
C     FORMAT STATEMENTS
C
 1001 FORMAT(1X)
 1004 FORMAT (//73X, '  --STEP SIZE FOR'/
     +  39X, '  ------PARAMETER', 17X, '  --APPROXIMATING'/
     +  ' -----------------PARAMETER DESCRIPTION  STARTING VALUES',
     +  '  ----------SCALE  -----DERIVATIVE'/
     +  ' INDEX  ---------TYPE  --ORDER  --FIXED  ----------(PAR)',
     +  '  --------(SCALE)  ----------(STP)')
 1005 FORMAT(30X, '  ------PARAMETER'/
     +  ' --------PARAMETER DESCRIPTION  ------ESTIMATES'/
     +  ' INDEX  ---------TYPE  --ORDER  ----------(PAR)')
 1006 FORMAT(
     +  39X, '  ------PARAMETER  -----STD DEV OF', 17X,
     +  '  ---------------------APPROXIMATE'/
     +  ' -----------------PARAMETER DESCRIPTION  ------ESTIMATES',
     +  '  ------PARAMETER  ----------RATIO',
     +  '  ----95 PERCENT CONFIDENCE LIMITS'/
     +  ' INDEX  ---------TYPE  --ORDER  --FIXED  ----------(PAR)',
     +  '  ------ESTIMATES',
     +  '  PAR/(SD OF PAR)  ----------LOWER  ----------UPPER')
 1040 FORMAT (//' RESIDUAL SUM OF SQUARES       ', 8X, G15.7,
     +  '  (BACKFORECASTS INCLUDED)'//6H RESID,
     +   25HUAL STANDARD DEVIATION   , 8X, G15.7/19H BASED ON DEGREES O,
     +   9HF FREEDOM, 1X, I4, 3H - , I3, 3H - , I3, 3H = , I4)
 1160 FORMAT (//23H NUMBER OF OBSERVATIONS, 48X, 3H(N), 1X, I5)
      END
*AMLST1
      SUBROUTINE AMLST1 (IAMHD, PAR, NPAR, MSPECT, NFAC, VCVL, LVCVL,
     +  SCALE, LSCALE, STPT, LSTPT, IPARMN, IPARMX, LBLTYP, T975, IFIXD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRINTS THE PARAMETERS FOR THE ARIMA ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   T975
      INTEGER
     +   IAMHD,IPARMN,IPARMX,LBLTYP,LSCALE,LSTPT,LVCVL,NFAC,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),SCALE(*),STPT(*),VCVL(*)
      INTEGER
     +   IFIXD(*),MSPECT(NFAC,4)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM,PLL,PUL,RATIO,SDPAR
      INTEGER
     +   IPRT,J,K,L,LL,LPAR,ORDER
C
C  LOCAL ARRAYS
      CHARACTER
     +   FIXED(3)*1
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL FIXPRT,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     CHARACTER*1 FIXED(3)
C        THE CHARACTERS USED TO LABEL THE PARAMETERS FIXED OR NOT.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER IAMHD
C        THE INDICATOR VALUE USED TO DESIGNATE THE TYPE OF LIST
C        TO BE GENERATED
C        IF IAMHD=1, THE LIST IS FOR THE INITIAL SUMMARY OF THE
C                    ESTIMATION ROUTINES.
C        IF IAMHD=2, THE LIST IS FOR THE INITIAL REPORT OF THE
C                    FORECASTING ROUTINES.
C        IF IAMHD=3, THE LIST IS FOR THE FINAL REPORT OF THE
C                    ESTIMATION ROUTINES.
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IPARMN
C        THE SMALLEST PARAMETER INDEX INCLUDED IN THIS TERM.
C     INTEGER IPARMX
C        THE LARGEST PARAMETER INDEX INCLUDED IN THIS TERM.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER LVCVL
C        THE DIMENSION OF VECTOR VCVL.
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER L
C        AN INDEX VARIABLE.
C     INTEGER LBLTYP
C        THE TYPE OF LABLE TO BE PRINTED, WHERE
C        1 INDICATES THE TERM IS AUTOREGRESSIVE AND
C        2 INDICATES THE TERM IS MOVING AVERAGE
C     INTEGER LL
C        AN INDEX VARIABLE.
C     INTEGER LPAR
C        AN INDEX VARIABLE.
C     INTEGER LSCALE
C        THE DIMENSION OF VECTOR SCALE.
C     INTEGER LSTPT
C        THE DIMENSION OF VECTOR STPT.
C     INTEGER MSPECT(NFAC,4)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER ORDER
C        THE ORDER OF B FOR THE PARAMETER BEING PRINTED
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PLL
C        THE LOWER CONFIDENCE LIMIT FOR A GIVEN PARAMETER.
C     DOUBLE PRECISION PUL
C        THE UPPER CONFIDENCE LIMIT FOR A GIVEN PARAMETER.
C     DOUBLE PRECISION RATIO
C        THE RATIO OF A GIVEN PARAMETER VALUE TO ITS STANDARD ERROR.
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPAR
C        THE STANDARD DEVIATION OF A GIVEN PARAMETER VALUE.
C     DOUBLE PRECISION STPT(LSTPT)
C        THE STEP SIZE ARRAY.
C     DOUBLE PRECISION T975
C        THE VALUE OF THE 97.5 PERCENT POINT FUNCTION FOR THE
C        T DISTRIBUTION.
C     DOUBLE PRECISION VCVL(LVCVL)
C        THE LOWER HALF OF THE VARIANCE-COVARIANCE MATRIX, STORED
C        ROW WISE.
C
C
      FPLM = D1MACH(2)
C
      CALL IPRINT(IPRT)
C
C     PRINT NEXT SET OF TERMS
C
      LPAR = 0
      DO 1 J=1,IPARMX
         IF (IFIXD(J).EQ.0) LPAR = LPAR + 1
    1 CONTINUE

      DO 40 J=1,NFAC
        IF ((MSPECT(J,LBLTYP).EQ.0) .AND. (LBLTYP.NE.2)) GO TO 40
        IF (LBLTYP.NE.2) IPARMX = IPARMX + MSPECT(J,LBLTYP)
        IF (LBLTYP.EQ.2) IPARMX = IPARMX + 1
        ORDER = 0
        DO 30 L = IPARMN, IPARMX
          ORDER = ORDER + MSPECT(J,4)
          IF (IAMHD.EQ.2) GO TO 25
          CALL FIXPRT(IFIXD(L), FIXED)
          IF (LBLTYP.EQ.1) WRITE(IPRT, 1000) L, J, ORDER,
     +      (FIXED(K),K=1,3), PAR(L)
          IF (LBLTYP.EQ.2) WRITE(IPRT, 1004) L,
     +      (FIXED(K),K=1,3), PAR(L)
          IF (LBLTYP.EQ.3) WRITE(IPRT, 1005) L, J, ORDER,
     +      (FIXED(K),K=1,3), PAR(L)
            IF (IAMHD.EQ.3) GO TO 10
C
            IF (IFIXD(L).EQ.0) GO TO 5
            WRITE (IPRT, 1007)
            GO TO 10
C
    5       CONTINUE
            IF (SCALE(1).LE.0.0D0) WRITE (IPRT, 1001) STPT(L)
            IF (SCALE(1).GT.0.0D0) WRITE (IPRT, 1002) SCALE(L), STPT(L)
   10     CONTINUE
          IF (IAMHD .EQ. 1) GO TO 30
C
          IF (IFIXD(L).EQ.0) GO TO 20
          WRITE(IPRT, 1006)
          GO TO 30
C
   20     CONTINUE
          LPAR = LPAR + 1
          RATIO = FPLM
          LL = LPAR*(LPAR-1)/2 + LPAR
          IF (VCVL(LL).GT.0.0D0) RATIO = PAR(L)/SQRT(VCVL(LL))
          SDPAR = SQRT(VCVL(LL))
          PLL = PAR(L) - T975*SDPAR
          PUL = PAR(L) + T975*SDPAR
          WRITE(IPRT, 1003) SDPAR, RATIO, PLL, PUL
          GO TO 30
   25     CONTINUE
          IF (LBLTYP.EQ.1) WRITE(IPRT, 1010) L, J, ORDER, PAR(L)
          IF (LBLTYP.EQ.2) WRITE(IPRT, 1014) L, PAR(L)
          IF (LBLTYP.EQ.3) WRITE(IPRT, 1015) L, J, ORDER, PAR(L)
   30   CONTINUE
        IPARMN = IPARMX + 1
   40 CONTINUE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(1X, I5, 2X, 'AR (FACTOR', I2, ')',4X,I5,6X,3A1,E17.8)
 1001 FORMAT ('+', 65X, 7HDEFAULT, E17.8)
 1002 FORMAT ('+', 55X, 2E17.8)
 1003 FORMAT ('+', 55X, 4(2X, E15.8))
 1004 FORMAT(1X, I5, 13X, 'MU', 4X, '  ---' ,6X,3A1,E17.8)
 1005 FORMAT(1X, I5, 2X, 'MA (FACTOR', I2, ')',4X,I5,6X,3A1,E17.8)
 1006 FORMAT('+', 55X, 4(14X, '---'))
 1007 FORMAT('+', 69X, '---', 14X, '---')
 1010 FORMAT(1X, I5, 2X, 'AR (FACTOR', I2, ')',4X,I5,E17.8)
 1014 FORMAT(1X, I5, 13X, 'MU', 4X, '  ---' ,E17.8)
 1015 FORMAT(1X, I5, 2X, 'MA (FACTOR', I2, ')',4X,I5,E17.8)
      END
*AOS
      SUBROUTINE AOS (N, LAGMAX, ACOV, PRHO, IAR, OSPVAR, PHI, WORK,
     +   AIC, FTEST, LACOV, LAIC)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES AUTOREGRESSIVE MODEL ORDER SELECTION
C     STATISTICS. IT PERFORMS STEPWISE FITTING OF AUTOREGRESSIVE
C     COEFFICIENTS BY DURBINS METHOD USING AKAIKES AIC CRITERION
C     FOR SELECTING ORDER.   THE ROUTINE IS MODELED AFTER
C     SUBROUTINE UFPE WRITTEN BY DICK JONES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   OSPVAR
      INTEGER
     +   IAR,LACOV,LAGMAX,LAIC,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(LACOV),AIC(LAIC),FTEST(2,LAGMAX),PHI(LAGMAX),
     +   PRHO(LAGMAX),WORK(LAGMAX)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ACOV0,AICMIN,FPLM,RSS,RSSMIN,SQPACF
      INTEGER
     +   I,J
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFF,D1MACH
      EXTERNAL CDFF,D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ARCOEF
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG,DBLE
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV), ACOV0
C        THE AUTOCOVARIANCES FOR LAGS ZERO TO LAGMAX, AND THE
C        AUTOCOVARIANCE AT LAG ZERO.
C     DOUBLE PRECISION AIC(LAIC), AICMIN
C        THE ARRAY CONTANING AKIAKES CRITERIA FOR EACH ORDER, WHERE
C        AIC(I+1) IS THE CRITERIA FOR ORDER I-1, AND THE MINIMUM
C        CRITERIA COMPUTED.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     DOUBLE PRECISION FTEST(2, LAGMAX)
C        THE ARRAY IN WHICH THE F PERCENTAGE POINT AND PROBABILITY ARE
C        STORED.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAIC
C        THE LENGTH OF THE VECTOR AIC.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     DOUBLE PRECISION OSPVAR
C        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
C     DOUBLE PRECISION PHI(LAGMAX)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
C        SELECTED ORDER.
C     DOUBLE PRECISION PRHO(LAGMAX)
C        THE ARRAY CONTAINING THE PARTIAL AUTOCORRELATION
C        COEFFICIENTS.
C     DOUBLE PRECISION RSS, RSSMIN
C        THE ONE STEP PREDICTION RESIDUAL SUM OF SQUARES AND THE
C        MINIMUM ONE STEP PREDICTION RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION SQPACF
C        THE SQUARED VALUE OF THE PARTIAL AUTOCORRELATION FUNCTION AT
C        LAG I.
C     DOUBLE PRECISION WORK(LAGMAX)
C        A DOUBLE PRECISION WORK AREA.
C
      FPLM = D1MACH(2)
C
      RSS = ACOV(1) * N
      RSSMIN = RSS
      AIC(1) = N * LOG(RSS * (N+1) / (N-1))
      AICMIN = AIC(1)
      IAR = 0
C
C  START STEPWISE PROCEDURE
C
      WORK(1) = ACOV(2) / ACOV(1)
      PRHO(1) = WORK(1)
      RSS = RSS * (1.0D0 - WORK(1)*WORK(1))
      AIC(2) = N * LOG(RSS * (N+2) / (N-2))
C
      SQPACF = WORK(1) * WORK(1)
      FTEST(1, 1) = FPLM
      FTEST(2, 1) = 0.0D0
      IF (SQPACF .GE. 1.0D0) GO TO 5
C
      FTEST(1,1) = (N-2) * SQPACF / (1.0D0 - SQPACF)
C
      FTEST(2,1) = 1.0D0 - CDFF(FTEST(1,1), 1.0D0, DBLE(N-2))
C
    5 CONTINUE
C
      IF (AIC(2).GE.AICMIN) GO TO 10
      AICMIN = AIC(2)
      RSSMIN = RSS
      IAR = 1
      PHI(1) = WORK(1)
C
   10 IF (LAGMAX.LE.1) GO TO 40
C
      ACOV0 = ACOV(1)
C
      DO 30 I=2,LAGMAX
         CALL ARCOEF (ACOV(2), WORK, RSS, I, LAGMAX, ACOV0)
         PRHO(I) = WORK(I)
         AIC(I+1) = FPLM
         FTEST(1,I) = FPLM
         FTEST(2,I) = FPLM
         IF (I.EQ.N-1) GO TO 15
C
         AIC(I+1) = N * LOG(RSS * (N+I+1) / (N-I-1))
C
         SQPACF = WORK(I) * WORK(I)
         IF (SQPACF .GE. 1.0D0) GO TO 15
C
         FTEST(1,I) = (N-I-1) * SQPACF / (1.0D0 - SQPACF)
C
         FTEST(2,I) = 1.0D0 - CDFF(FTEST(1,I), 1.0D0, DBLE(N-I-1))
C
   15    CONTINUE
C
C     IF THIS AIC IS A MINIMUM AND ITS LAG DOES NOT EXCEED N/2,
C     SAVE THE COEFFICIENTS.
C
         IF ((AIC(I+1).GE.AICMIN) .OR. (I.GT.N/2)) GO TO 30
         AICMIN = AIC(I+1)
         RSSMIN = RSS
         IAR = I
         DO 20 J=1,I
            PHI(J) = WORK(J)
   20    CONTINUE
   30 CONTINUE
C
C   NORMALIZE AIC
C
   40 CONTINUE
      AIC(1) = AIC(1) - AICMIN
      DO 50 I=1,LAGMAX
         AIC(I+1) = AIC(I+1) - AICMIN
   50 CONTINUE
C
      OSPVAR = RSSMIN / (N-IAR-1)
C
      RETURN
      END
*AOSLST
      SUBROUTINE AOSLST (PRHO, AIC, FTEST, LAGMAX, LAIC, IAR, PHI,
     +   OSPVAR, IFPRHO, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE LISTS THE AUTOREGRESSIVE MODEL ORDER SELECTION
C     STATISTICS.
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   OSPVAR
      INTEGER
     +   IAR,LAGMAX,LAIC,N
      LOGICAL
     +   IFPRHO
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AIC(*),FTEST(2,*),PHI(*),PRHO(*)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IMAX,IMIN,IPRT,LAG,M,NPERL
      CHARACTER
     +   FMT*160
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AIC(LAIC)
C        THE ARRAY CONTAINING THE AKAIKES INFORMATION CRITERION.
C     CHARACTER*160 FMT
C        THE FORMAT USED.
C     DOUBLE PRECISION FTEST(2, LAGMAX)
C        THE ARRAY CONTIANING THE PARTIAL F RATIO AND ITS PROBABILITY
C        OF BEING EXCEEDED.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE MODEL SELECTED.
C     LOGICAL IFPRHO
C        THE LOGICAL VARIABLE USED TO INDICATE IF THE PARTIAL
C        AUTOCORRELATIONS ARE BEING PRINTED.  IF -IFPRHO- IS
C        .FALSE. THE AUTOCORRELATIONA AND THEIR STANDARD ERRORS
C        ARE PRINTED,  IF .TRUE., THE PARTIALS.
C     INTEGER IMAX, IMIN
C        THE INDEX VALUES OF THE FIRST AND LAST OBSERVATION
C        TO BE PRINTED PER LINE
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT
C     INTEGER LAG
C        THE LAG VALUE OF THE AUTOREGRESSIVE ORDER SELECTION STATISTIC
C        BEING PRINTED.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG AT WHICH THE AUTOREGRESSIVE ORDER SELECTION
C        STATISTICS WERE COMPUTED.
C     INTEGER LAIC
C        THE LENGTH OF THE VECTOR AIC.
C     INTEGER M
C        AN INDEX VARIABLE.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES.
C     INTEGER NPERL
C        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
C     DOUBLE PRECISION OSPVAR
C        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED.
C     DOUBLE PRECISION PHI(LAGMAX)
C        THE AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED ORDER.
C     DOUBLE PRECISION PRHO(LAGMAX)
C        THE ARRAY CONTAINING THE PARTIAL AUTOCORRELATION
C        COEFFICIENTS.
C
      CALL IPRINT(IPRT)
C
      NPERL = 12
      DO 30 I = 1, LAGMAX, NPERL
         IMIN = I
         IMAX = MIN(I + NPERL - 1, LAGMAX)
         WRITE(IPRT, 1000) (LAG, LAG = IMIN, IMAX)
         IF (IFPRHO) WRITE (IPRT, 1001) (PRHO(LAG), LAG = IMIN, IMAX)
C
         IF ((IMAX.EQ.LAGMAX) .AND. (LAGMAX.EQ.(N-1))) THEN
            IF (IMAX-IMIN.GE.1) THEN
               WRITE(FMT, 1002) IMAX-IMIN
            ELSE
               WRITE(FMT, 1003)
            END IF
            WRITE(IPRT, FMT) ' AIC               ',
     +                       (AIC(LAG+1), LAG = IMIN, IMAX-1)
            WRITE(IPRT, FMT) ' F RATIO           ',
     +                       (FTEST(1, LAG), LAG = IMIN, IMAX-1)
            WRITE(IPRT, FMT) ' F PROBABILITY     ',
     +                       (FTEST(2, LAG), LAG = IMIN, IMAX-1)
         ELSE
            WRITE(FMT, 1004) NPERL
            WRITE(IPRT, FMT) ' AIC               ',
     +                       (AIC(LAG+1), LAG = IMIN, IMAX)
            WRITE(IPRT, FMT) ' F RATIO           ',
     +                       (FTEST(1, LAG), LAG = IMIN, IMAX)
            WRITE(IPRT, FMT) ' F PROBABILITY     ',
     +                       (FTEST(2, LAG), LAG = IMIN, IMAX)
         END IF
   30 CONTINUE
C
      IF (LAGMAX.EQ.N-1) WRITE(IPRT, 1009)
C
C     PRINT INFORMATION ON ORDER SELECTED
C
      WRITE (IPRT, 1005) IAR, OSPVAR
C
      IF (IAR .EQ. 0) RETURN
C
      WRITE(IPRT, 1008)
C
      DO 40 I = 1, IAR, NPERL
         IMIN = I
         IMAX = MIN(I + NPERL - 1, IAR)
         WRITE (IPRT, 1006) (M, M = IMIN, IMAX)
         WRITE (IPRT, 1007) (PHI(M), M = IMIN, IMAX)
   40 CONTINUE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/19H LAG               , 12(1X, I6))
 1001 FORMAT( 19H PACF              , 12(2X, F5.2))
 1002 FORMAT('(A19,',I2,'(1X, F6.2), 7H ******)')
 1003 FORMAT('(A19, 7H ******)')
 1004 FORMAT('(A19,',I2,'(1X, F6.2))')
 1005 FORMAT (//
     +   49H ORDER AUTOREGRESSIVE PROCESS SELECTED =         , I6/
     +   51H ONE STEP PREDICTION VARIANCE OF PROCESS SELECTED =, G15.8/)
 1006 FORMAT (/19H COEFFICIENT NUMBER, 12(1X, I6))
 1007 FORMAT ( 19H COEFFICIENT VALUE , 12(1X, F6.4))
 1008 FORMAT (45H YULE-WALKER ESTIMATES OF THE COEFFICIENTS OF,
     +   36H THE AUTOREGRESSIVE PROCESS SELECTED)
 1009 FORMAT (/'****** THIS VALUE CANNOT BE COMPUTED',
     +         ' BECAUSE LAG = N-1'//)
C
      END
*AOV1
      SUBROUTINE AOV1(Y, TAG, N, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE -
C     1. CALLS OTHER ROUTINES TO CHECK THE INPUT PARAMETERS
C     2. SETS UP THE NEEDED STORAGE LOCATIONS, AND
C     3. CALLS AOV1MN TO COMPUTE A COMPREHENSIVE SET OF RESULTS FOR A
C     ONEWAY ANALYSIS OF VARIANCE WITH AUTOMATIC PRINTOUT.
C
C     WRITTEN BY -
C       LINDA MITCHELL
C       STATISTICAL ENGINEERING DIVISION
C       NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C                       BASED ON EARLIER VERSION BY J. R. DONALDSON
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   TAG(*),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   B10,DTMEAN,DTSD,DTSIZE,GPMAX,GPMIN,IFP,INDEX,INT,IPRT,
     +   ITEMP,NALL0,NG,NPRT,NZTAGS,RANKS,SRANK,TVAL
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET
      EXTERNAL STKGET
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AOV1ER,AOV1HD,AOV1MN,IPRINT,STKCLR
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER B10
C        STARTING LOCATION IN THE STACK AREA FOR B10
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER DTMEAN
C        THE STARTING LOCATION IN THE STACK AREA FOR THE MEANS
C        OF EACH GROUP
C     INTEGER DTSD
C        THE STARTING LOCATION IN THE STACK AREA OF THE
C        STANDARD DEVIATIONS
C     INTEGER DTSIZE
C        THE STARTING LOCATION IN THE STACK AREA OF THE SIZE OF THE
C        DIFFERENT GROUPS
C     INTEGER GPMAX
C        THE STARTING LOCATION IN THE STACK AREA OF MAXIMUM
C        OBSERVATION
C     INTEGER GPMIN
C        THE STARTING LOCATION IN THE STACK AREA OF THE MINUMUM
C        OBSERVATION
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG INDICATING WHETHER THERE
C        ARE ANY ERRORS, IF = 0 THEN NO ERRORS
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER INDEX
C        THE STARTING LOCATION IN THE STACK ARRAY OF THE INDEX FOR
C        THE SORTED TAGS
C     INTEGER INT
C        FRAMEWORK CODE VALUE FOR INTEGER NUMBERS
C     INTEGER IPRT
C        THE OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ITEMP
C        STARTING LOCATION IN THE STACK FOR THE
C        TEMPORARY STORAGE ARRAY
C     INTEGER LDSTAK
C        SIZE OF THE STACK AREA ALLOCATED IN THE USERS MAIN PROGRAM
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS TO BE ANALYZED
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT THIS
C        ROUTINE WAS CALLED.
C     INTEGER NG
C        THE NUMBER OF GROUPS WITH DIFFERENT POSITIVE TAG VALUES
C     CHARACTER*1 NMSUB(6)
C        SUBROUTINE NAME
C     INTEGER NPRT
C        THE VARIABLE CONTROLLING AUTOMATIC PRINTOUT
C        IF =0, PRINTOUT IS SUPRESSED
C        OTHERWISE PRINTOUT IS PROVIDED
C     INTEGER NZTAGS
C        THE NUMBER OF OBSERVATIONS WITH POSITIVE NON-ZERO WIEGHTS
C     INTEGER RANKS
C        THE STARTING LOCATION IN WORK AREA FOR THE RANKS OF Y
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER SRANK
C        THE STARTING LOCATION IN STACK FOR THE SUM OF RANKS
C     DOUBLE PRECISION TAG(N)
C        THE VECTOR OF TAG VALUES
C     INTEGER TVAL
C        THE STARTING LOCATION IN THE STACK FOR THE VECTOR OF
C        THE DIFFERENT POSITIVE TAG VALUES, FOR AOV1
C     DOUBLE PRECISION Y(N)
C        THE VECTOR OF OBSERVATIONS
C
      DATA   NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +     /      'A',      'O',      'V',      '1',      ' ',      ' '/
C
      CALL IPRINT(IPRT)
C
C     SET UP FRAMEWORK VARIABLES FOR NUMBER TYPES
C
      INT = 2
      IFP = 4
C
C     CHECK FOR ERRORS IN PARAMETERS, INITIALIZE STACK, AND SET NALL0.
C
      CALL AOV1ER(Y, TAG, N, N, NZTAGS, NG, LDSTAK, NMSUB, INDEX, 1,
     +   NALL0)
C
      IF (IERR.EQ.0) GO TO 20
C
C     PRINT CORRECT FORM OF CALL STATEMENT AND RETURN TO CALLER
C
      IERR = 1
      WRITE (IPRT,1000)
      RETURN
C
C     PRINT HEADING
C
   20 CALL AOV1HD(IPRT)
C
C     SET UP ADDITIONAL WORK VECTORS FOR AOV1MN AS CALLED FROM AOV1
C
      TVAL = STKGET(NG,IFP)
      DTSIZE = STKGET(NG,IFP)
      DTMEAN = STKGET(NG,IFP)
      DTSD = STKGET(NG,IFP)
      SRANK = STKGET(NG,IFP)
      GPMIN = STKGET(NG,IFP)
      GPMAX = STKGET(NG,IFP)
      B10 = STKGET(NG,IFP)
      RANKS = STKGET(NZTAGS,IFP)
      ITEMP = STKGET(NZTAGS,INT)
C
      NPRT = 1
C
      CALL AOV1MN(Y, TAG, N, RSTAK(TVAL), RSTAK(DTSIZE), RSTAK(DTMEAN),
     +   RSTAK(DTSD), NPRT, ISTAK(INDEX), RSTAK(SRANK), RSTAK(GPMIN),
     +   RSTAK(GPMAX), RSTAK(B10), RSTAK(RANKS),
     +   ISTAK(ITEMP), NG, NZTAGS)
C
C     RELEASE THE STACK AREA
C
      CALL STKCLR(NALL0)
C
      RETURN
C
C     FORMAT STATEMENT
C
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL AOV1 (Y, TAG, N, LDSTAK)')
      END
*AOV1ER
      SUBROUTINE AOV1ER(Y, TAG, N, IGSTAT, NZTAGS, NG, LDSTAK, NMSUB,
     +   INDEX, ISAOV1, NALL0)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE DOES PRELIMINARY CHECKING FOR ERRORS IN THE INPUT
C     PARAMETERS OF THE ONEWAY FAMILY.
C
C     WRITTEN BY -
C        LINDA L. MITCHELL AND JANET R. DONALDSON
C        STATISTICAL ENGINEERING DIVISION
C        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IGSTAT,INDEX,ISAOV1,LDSTAK,N,NALL0,NG,NZTAGS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   TAG(*),Y(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT,J,LDSMIN,NV
      LOGICAL
     +   ERROR,HEAD
C
C  LOCAL ARRAYS
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   LIGSTA(8)*1,LLDS(8)*1,LN(8)*1,LNG(8)*1,LTAG(8)*1,
     +   LTWO(8)*1,LZERO(8)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,ERVGT,GENI,IPRINT,LDSCMP,SRTIRR,SRTRRI,
     +   STKCLR,STKSET
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL ERROR
C        SET TRUE IF THE ERROR CHECKING ROUTINE FOUND ANY ERRORS
C     LOGICAL HEAD
C        INDICATES WHETHER HEADING NEEDS TO BE PRINTED
C        TRUE - YES, NEEDS TO BE PRINTED
C        FALSE - NO, HAS BEEN PRINTED
C     INTEGER I
C        *
C     INTEGER IERR
C        IF IERR .NE. 0, THEN ERRORS WHERE FOUND IN THE PARAMETERS
C     INTEGER IGSTAT
C        *
C     INTEGER INDEX
C        THE STARTING LOCATION IN THE STACH AREA OF THE INDEX FOR
C        THE SORTED TAGS.
C     INTEGER IPRT
C        THE OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISAOV1
C        AN INDICATOR VARIABLE USED FOR THE COMPUTATION OF WORK
C        SPACE.  IF ISAOV1 = 0, THE CALLING ROUTINE IS AOV1S.  IF
C        ISAOV1 = 1, THE CALLING ROUTINE IS AOV1.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER J
C        *
C     INTEGER LDSMIN
C        THE MINIMUM SIZE ALLOWED FOR THE STACK
C     INTEGER LDSTAK
C        SIZE OF STACK ALLOCATED IN THE USERS MAIN PROGRAM
C     CHARACTER*1 LIGSTA(8), LLDS(8), LN(8), LNG(8), LTAG(8),
C    *   LTWO(8), LZERO(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE VARIABLE(S) CHECKED
C        ERRORS
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS
C     INTEGER NALL0
C        OUTPUT PARAMETER.  NUMBER OF STACK ALLOCATIONS AFTER
C        STACK IS INITIALIZED.
C     INTEGER NG
C        *
C     CHARACTER*1 NMSUB(6)
C        NAME OF THE CALLING SUBROUTINE
C     INTEGER NV
C        THE NUMBER OF VALUES LESS THAN OR EQUAL TO ZERO.
C     INTEGER NZTAGS
C        THE NUMBER OF POSITIVE NON-ZERO TAGS, TO BE DETERMINED BY
C        THIS ROUTINE
C     DOUBLE PRECISION TAG(N)
C        THE VECTOR OF TAGS.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR OF OBSERVATIONS.
C
      DATA  LIGSTA(1),LIGSTA(2),LIGSTA(3),LIGSTA(4),LIGSTA(5),LIGSTA(6),
     +      LIGSTA(7),LIGSTA(8)
     +     / 'I', 'G', 'S', 'T', 'A', 'T', ' ', ' '/
      DATA   LLDS(1),  LLDS(2),  LLDS(3),  LLDS(4),  LLDS(5),  LLDS(6),
     +       LLDS(7),  LLDS(8)
     +     / 'L', 'D', 'S', 'T', 'A', 'K', ' ', ' '/
      DATA     LN(1),    LN(2),    LN(3),    LN(4),    LN(5),    LN(6),
     +         LN(7),    LN(8)
     +     / 'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA    LNG(1),   LNG(2),   LNG(3),   LNG(4),   LNG(5),   LNG(6),
     +        LNG(7),   LNG(8)
     +     / 'N', 'G', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA   LTAG(1),  LTAG(2),  LTAG(3),  LTAG(4),  LTAG(5),  LTAG(6),
     +       LTAG(7),  LTAG(8)
     +     / 'T', 'A', 'G', ' ', ' ', ' ', ' ', ' '/
      DATA   LTWO(1),  LTWO(2),  LTWO(3),  LTWO(4),  LTWO(5),  LTWO(6),
     +       LTWO(7),  LTWO(8)
     +     / 'T', 'W', 'O', ' ', ' ', ' ', ' ', ' '/
      DATA  LZERO(1), LZERO(2), LZERO(3), LZERO(4), LZERO(5), LZERO(6),
     +      LZERO(7), LZERO(8)
     +     / 'Z', 'E', 'R', 'O', ' ', ' ', ' ', ' '/
C
C     COMMENCE BODY OF ROUTINE
C
      IERR = 0
      HEAD = .TRUE.
C
C     SET UP OUTPUT UNIT
      CALL IPRINT(IPRT)
C
C     BEGIN ERROR CHECKING.
C
C     NUMBER OF OBSERVATIONS LESS THAN 2
C
      CALL EISGE(NMSUB, LN, N, 2, 2, HEAD, ERROR, LTWO)
      IF (ERROR) GO TO 50
C
C     NUMBER OF NON-ZERO TAGS LESS THAN 2
C
      CALL ERVGT(NMSUB, LTAG, TAG, N, 0.0D0, (N-2), HEAD, 7, NV, ERROR,
     +   LZERO)
      IF (ERROR) GO TO 50
C
      NZTAGS = N - NV
C
C     STACK MUST BE LARGE ENOUGH FOR A VECTOR OF LENGTH N TO CONTINUE
C
      CALL LDSCMP(1, 0, N, 0, 0, 0, 'D', 0, LDSMIN)
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR, LLDS)
      IF (ERROR) WRITE(IPRT, 1000)
      IF (ERROR) GO TO 50
C
C     INITIALIZE STACK AND NALL0
C
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
C
      INDEX = STKGET(N,2)
C
C     SORT TAG VECTOR CARRYING ALONG INDEX TO ORIGINAL ORDER AND THE
C     VECTOR OF OBSERVATIONS
C
      CALL GENI(ISTAK(INDEX), N, 1, 1)
      CALL SRTIRR(ISTAK(INDEX), Y, N, TAG)
C
C     COUNT THE NUMBER OF DIFFERENT TAG VALUES
C
      J = N - NZTAGS + 2
      NG = 1
      DO 10 I=J,N
         IF (TAG(I).GT.TAG(I-1)) NG = NG + 1
   10 CONTINUE
C
C     LESS THAN 2 DIFFERENT TAG GROUPS
C
      CALL EISII(NMSUB, LNG, NG, 2, NZTAGS-1, 3, HEAD, ERROR,
     +  LTWO, LN)
      IF (ERROR) GO TO 40
C
C     CHECK THAT DIMENSION OF STATISTICS MATRIX IS SUFFICIENT
C
      CALL EISGE(NMSUB, LIGSTA, IGSTAT, NG, 3, HEAD, ERROR, LNG)
      IF (ERROR) GO TO 40
C
C     COMPUTE AND CHECK FOR SUFFICIENT STACK
C
      CALL LDSCMP(11, 0, N+NZTAGS, 0, 0, 0,
     +            'D', ISAOV1*4*NG+4*NG+NZTAGS, LDSMIN)
C
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR, LLDS)
      IF (.NOT.ERROR) RETURN
C
   40 CONTINUE
C
C     REORDER DATA
C
      CALL SRTRRI(TAG, Y, N, ISTAK(INDEX))
C
C     CLEAR STACK, IN CASE WHERE ERROR FOLLOWS ALLOCATION OF STACK.
C
      CALL STKCLR (NALL0)
C
   50 CONTINUE
      IERR = 1
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/' NOTE.  THE VALUE OF LDSTAK MENTIONED ABOVE IS THE',
     +  ' MINIMUM NECESSARY'/
     +  ' TO CONTINUE CHECKING FOR ERRORS AND',
     +  ' TO CALCULATE THE CORRECT VALUE'/
     +  ' OF LDSTAK.  THE CORRECT',
     +  ' VALUE WILL BE LARGER.  CONSULT THE DOCUMENTATION'/
     +  ' FOR THE FORMULAS USED TO CALCULATE LDSTAK.')
      END
*AOV1HD
      SUBROUTINE AOV1HD(IPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     A SUBROUTINE TO PRINT OUT THE HEADING FOR THE ONEWAY ANOVA
C     FAMILY, AND IS THE ONLY SOURCE FOR HEADINGS IN THAT FAMILY
C
C     AUTHOR -
C        JOHN E. KOONTZ
C        STATISTICAL ENGINEERING DIVISION
C        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL VERSP
C
C  VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IPRT
C        THE OUTPUT LOGICAL UNIT NUMBER
C
      CALL VERSP(.TRUE.)
      WRITE (IPRT,1000)
      RETURN
 1000 FORMAT(///48X, 20HANALYSIS OF VARIANCE//)
      END
*AOV1MN
      SUBROUTINE AOV1MN(Y, TAG, N, TVALUE, TSIZE, TMEAN, TSD, NPRT,
     +   INDEX, SRANK, GPMIN, GPMAX, B10, RANKS, ITEMP, NG, NZW)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE COMPUTES A COMPREHENSIVE SET OF RESULTS FOR
C     ANALYSIS OF A ONE-WAY CLASSIFICATION WITH OPTIONAL PRINTED OUTPUT.
C     TAG VALUES CAN BE ANY VALUE WHERE ALL MEASUREMENTS WITH TAG
C     VALUES LESS THAN OR EQUAL TO ZERO ARE EXCLUDED FROM ANALYSIS.
C
C     ORIGINALLY WRITTEN FOR OMNITAB BY -
C       DAVID HOGBEN, STATISTICAL ENGINEERING DIVISION, NBS (10/25/69)
C
C     ADAPTED  BY -
C       JANET R. DONALDSON
C       STATISTICAL ENGINEERING DIVISION
C       NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NG,NPRT,NZW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   B10(*),GPMAX(*),GPMIN(*),RANKS(*),SRANK(*),TAG(*),TMEAN(*),
     +   TSD(*),TSIZE(*),TVALUE(*),Y(*)
      INTEGER
     +   INDEX(*),ITEMP(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   AF,BF,BFRAT,BFSIG,BMS,BSS,C,CC,CFKW,DF,DFRAT,DFSIG,DMS,DSS,F,
     +   F1KW,F2KW,FMLC,FMUC,FNZW,FPLM,FSTAT,G1,GM,GR,HSTAT,IBAR,K0,
     +   MF,MKW,Q,RESSQ,RMLC,RMUC,RX,SBMS,SC,SFRAT,SFSIG,SIGKW,SLBF,
     +   SLCC,SMAX,SMIN,SMS,SNC,SOS,SQB,SQMS,SQOM,SQT,SSF,SSS,STMS,
     +   SUM,SWMS,T1,T2,T3,TIES,TMS,TSS,U1,U2,UMLC,UMUC,V1,V2,VKW,VLS,
     +   WMS,WSS,YBMAX,YBMIN,YMAX,YMIN
      INTEGER
     +   I,IPRT,ISZ,J,K,KK,KKK,L,M,M28,M3,M5,NN,NNE1,NZPNTR
      CHARACTER
     +   BLANK*1,HIGH*1,ISD*1,LOW*1,MEAN*1
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   STATS(15)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFF,PPFF,PPFT,D1MACH
      EXTERNAL CDFF,PPFF,PPFT,D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GENI,IPRINT,RANKO,SRTIR,SRTRI,SRTRRI
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,ANINT,INT,LOG,MAX,MIN,NINT,DBLE,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AF
C        A FOR F
C     DOUBLE PRECISION BF
C        BARTLETT F
C     DOUBLE PRECISION BFRAT
C        BETWEEN GROUPS F RATIO
C     DOUBLE PRECISION BFSIG
C        BETWEEN GROUPS SIGNIFICANCE LEVEL
C     CHARACTER*1 BLANK
C        HOLLERITH BLANK
C     DOUBLE PRECISION BMS
C        BETWEEN MS
C     DOUBLE PRECISION BSS
C        BETWEEN SS
C     DOUBLE PRECISION B10(NG)
C        *
C     DOUBLE PRECISION C
C        INTERMEDIATE RESULT STORAGE
C     DOUBLE PRECISION CC
C        COCHRANS C
C     DOUBLE PRECISION CFKW
C        CORRECTION FACTOR FOR KRUSKAL-WALLIS
C     DOUBLE PRECISION DF
C        D.F.
C     DOUBLE PRECISION DFRAT
C        DEVIATIONS ABOUT LINE F RATIO
C     DOUBLE PRECISION DFSIG
C        DEVIATIONS ABOUT LINE F SIGNIFICANCE LEVEL
C     DOUBLE PRECISION DMS
C        DEVIATIONS ABOUT LINE MS
C     DOUBLE PRECISION DSS
C        DEVIATIONS ABOUT LINE SS
C     DOUBLE PRECISION F
C        BETWEEN MEANS F-TEST
C     DOUBLE PRECISION FMLC
C        FIXED MODEL LOWER CONFIDENCE LIMIT FOR MEAN
C     DOUBLE PRECISION FMUC
C        FIXED MODEL UPPER CONFIDENCE LIMIT FOR MEAN
C     DOUBLE PRECISION FNZW
C        *
C     DOUBLE PRECISION FPLM
C        LARGEST SINGLE PRECISION MAGNITUDE OF MACHINE
C     DOUBLE PRECISION FSTAT
C        F STATISTIC ASSOCIATED WITH KRUSKAL-WALLIS H STATISTIC
C     DOUBLE PRECISION F1KW
C        F1 D.F. FOR KRUSKAL-WALLIS F
C     DOUBLE PRECISION F2KW
C        F2 D.F. FOR KRUSKAL-WALLIS F
C     DOUBLE PRECISION GM
C        GRAND MEAN, MEAN OF ALL OBSERVATIONS WITH POSITIVE
C        NON-ZERO TAGS
C     DOUBLE PRECISION GPMAX(NG)
C        THE VECTOR OF MAXIMUM OBSERVATIONS FOR EACH GROUP
C     DOUBLE PRECISION GPMIN(NG)
C        THE VECTOR OF MINIMUM OBSERVATIONS FOR EACH GROUP
C     DOUBLE PRECISION GR
C        NZW-NG
C     DOUBLE PRECISION G1
C        NG-1
C     CHARACTER*1 HIGH
C        HOLLERITH + (PLUS)
C     DOUBLE PRECISION HSTAT
C        KRUSKAL-WALLIS H STATISTIC, SEE BROWNLEE(1965), PAGE 256
C     INTEGER I
C        INDEX VARIABLE
C     DOUBLE PRECISION IBAR
C        I BAR, ((SUM OF I)/NZW), WHERE I=1,NZW
C     INTEGER INDEX(N)
C        PERMUTATION VECTOR FOR Y AND LATER FOR TMEAN
C     INTEGER IPRT
C        THE OUTPUT LOGICAL UNIT NUMBER
C     CHARACTER*1 ISD
C        CAN CONTAIN FOLLOWING CHARACTERS FOR PRINTING
C        +, -,  (BLANK)
C     INTEGER ISZ
C        INTEGER SIZE OF GROUP
C     INTEGER ITEMP(NZW)
C        TEMPORARY INDEX VECTOR USED IN COMPUTING RANKS
C     INTEGER J
C        AN INDEX VARIABLE
C     INTEGER K
C        INDEX VARIABLE
C     INTEGER KK
C        POINTER TO THE LARGEST OF THE GROUP MEANS
C     INTEGER KKK
C        POINTER TO THE SMALLEST OF THE GROUP MEANS
C     DOUBLE PRECISION K0
C        = NZW - (SNC/NZW)/ G1
C     INTEGER L
C        INDEX VARIABLE
C     CHARACTER*1 LOW
C        HOLLERITH - (MINUS)
C     INTEGER M
C        INDEX VARIABLE
C     CHARACTER*1 MEAN
C        CAN CONTAIN FOLLOWING CHARACTERS FOR PRINTING
C        +, -,  (BLANK)
C     DOUBLE PRECISION MF
C        M FOR F
C     DOUBLE PRECISION MKW
C        M FOR KRUSKAL-WALLIS MEAN
C     INTEGER M28
C        USED IN CREATING BACKWARD LOOP
C     INTEGER M3
C        NG - 2
C     INTEGER M5
C        NZW - 1
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS
C     INTEGER NG
C        THE NUMBER OF GROUPS OF DIFFERENT POSITIVE TAG VALUES
C     INTEGER NN
C        AID IN PRINTING VALUES
C     INTEGER NNE1
C        NUMBER OF GROUPS WITH SIZE NOT EQUAL TO ONE
C     INTEGER NPRT
C        THE VARAIBLE CONTROLLING AUTOMATIC PRINTOUT
C        IF NPRT = 0, PRINTOUT SUPPRESSED
C           OTHERWISE PRINTOUT PROVIDED
C     INTEGER NZPNTR
C        A POINTER TO THE FIRST NON-ZERO TAG IN THE SORTED TAG VECTOR
C     INTEGER NZW
C        THE NUMBER OF OBSERVATIONS WITH POSITIVE, NON-ZERO, TAG VALUES
C     DOUBLE PRECISION Q
C        SIGNIFICANCE LEVEL FROM F-DISTRIBUTION
C     DOUBLE PRECISION RANKS(NZW)
C        THE RANKS OF THE OBSERVATIONS WITH POSITIVE TAG VALUES
C     DOUBLE PRECISION RESSQ
C        RESIDUALS SQUARED
C     DOUBLE PRECISION RMLC
C        RANDOM MODEL LOWER CONFIDENCE LIMIT FOR MEAN
C     DOUBLE PRECISION RMUC
C        RANDOM MODEL UPPER CONFIDENCE LIMIT FOR MEAN
C     DOUBLE PRECISION RX
C        USED IN CALCULATING MANDEL APPROXIMATION
C     DOUBLE PRECISION SBMS
C        SQRT BETWEEN MS
C     DOUBLE PRECISION SC
C        SUM OF N(I) CUBED, WHERE N(I) IS THE SIZE OF GROUP I
C     DOUBLE PRECISION SFRAT
C        SLOPE F RATIO
C     DOUBLE PRECISION SFSIG
C        SLOPE F SIGNIFICANCE LEVEL
C     DOUBLE PRECISION SIGKW
C        SIGNIFICANCE LEVEL FOR KRUSKAL-WALLIS F (OR H)
C     DOUBLE PRECISION SLBF
C        SIGNIFICANCE LEVEL FOR BARLETT F
C     DOUBLE PRECISION SLCC
C        SIGNIFICANCE LEVEL FOR COCHRANS C
C     DOUBLE PRECISION SMAX
C        MAXIMUM OF S(I), WHERE S(I) IS THE STD. DEV. OF GROUP I
C     DOUBLE PRECISION SMIN
C        MINIMUM OF S(I)
C     DOUBLE PRECISION SMS
C        SLOPE MS
C     DOUBLE PRECISION SNC
C        SUM OF N(I) SQUARED
C     DOUBLE PRECISION SOS
C        SUM OF S(I) SQUARED
C     DOUBLE PRECISION SQB
C        SQRT BETWEEN MS / NZW
C     DOUBLE PRECISION SQMS
C        SQRT WITHIN MS / NZW
C     DOUBLE PRECISION SQOM
C        OMEGA HAT SQUARED
C     DOUBLE PRECISION SQT
C        SQRT TOTAL MS / NZW
C     DOUBLE PRECISION SRANK(NG)
C        THE SUM OF THE RANKS FOR THE OBSERVATIONS IN EACH GROUP
C     DOUBLE PRECISION SSF
C        S * SQRT(NG-1) * F
C     DOUBLE PRECISION SSS
C        SLOPE SS
C     DOUBLE PRECISION STATS(15)
C        VECTOR OF STATISTICS
C     DOUBLE PRECISION STMS
C        SQRT TOTAL MS
C     DOUBLE PRECISION SUM
C        INTERMIDIATE VALUE
C     DOUBLE PRECISION SWMS
C        SQRT WITHIN MS
C     DOUBLE PRECISION TAG(N)
C        VECTOR OF CLASSIFICATION VALUES - VALUES LESS THAN OR EQUAL
C        TO ZERO ARE IGNORED FOR ANALYSIS.  ON ENTERING TAG IS
C        SORTED SMALLEST TO LARGEST
C     DOUBLE PRECISION TIES
C        *
C     DOUBLE PRECISION TMEAN(NG)
C        THE MEAN OF EACH OF THE GROUPS
C     DOUBLE PRECISION TMS
C        TOTAL MS
C     DOUBLE PRECISION TSD(NG)
C        THE STANDARD DEVIATIONS OF EACH OF THE GROUPS (NOT THE
C        STANDARD DEVIATIONS OF THE MEANS)
C     DOUBLE PRECISION TSIZE(NG)
C        THE SIZE OF EACH OF THE DIFFERENT GROUPS
C     DOUBLE PRECISION TSS
C        TOTAL SS
C     DOUBLE PRECISION TVALUE(NG)
C        THE DIFFERENT POSITIVE (NON-ZERO) TAG VALUES ANALYZED, ORDERED
C        FROM SMALLEST TO LARGEST
C     DOUBLE PRECISION T1
C        T(.05,NG-1)
C     DOUBLE PRECISION T2
C        T(.05,NG-1)
C     DOUBLE PRECISION T3
C        T(.05,NZW-1)
C     DOUBLE PRECISION UMLC
C        UNGROUPED MODEL LOWER CONFIDENCE LIMIT FOR MEAN
C     DOUBLE PRECISION UMUC
C        UNGROUPED MODEL UPPER CONFIDENCE LIMIT FOR MEAN
C     DOUBLE PRECISION U1, U2
C        USED IN CALCULATING MANDEL APPROXIMATION
C     DOUBLE PRECISION VKW
C        U FOR KRUSKAL-WALLIS F
C     DOUBLE PRECISION VLS
C        LARGEST VARIANCE / SMALLEST VARIANCE
C     DOUBLE PRECISION V1, V2
C        USED IN CALCULATING MANDEL APPROXIMATION
C     DOUBLE PRECISION WMS
C        WITHIN MS
C     DOUBLE PRECISION WSS
C        WITHIN SS
C     DOUBLE PRECISION Y(N)
C        OBSERVATIONS TO BE ANALYZED, SORTED BY TAGS
C        Y(NZPNTR) IS THE FIRST ELEMENT WITH A NON-ZERO TAG
C     DOUBLE PRECISION YBMAX
C        MAXIMUM YBAR(I), WHERE YBAR(I) IS THE MEAN OF GROUP I
C     DOUBLE PRECISION YBMIN
C        MINIMUN YBAR(I)
C     DOUBLE PRECISION YMAX
C        MAXIMUM OBSERVATION
C     DOUBLE PRECISION YMIN
C        MINIMUM OBSERVATION
C
C     MACHINE DEPENDENT VARIABLE - FPLM
C
      DATA BLANK /' '/
      DATA LOW /'-'/
      DATA HIGH /'+'/
C
      CALL IPRINT(IPRT)
      FPLM = D1MACH(2)
      NZPNTR = N - NZW + 1
      FNZW = NZW
C
C     ZERO WORK VECTORS
C
      DO 10 I=1,NG
         TVALUE(I) = 0.0D0
         TSIZE(I) = 0.0D0
         TMEAN(I) = 0.0D0
         TSD(I) = 0.0D0
         SRANK(I) = 0.0D0
         GPMIN(I) = 0.0D0
         GPMAX(I) = 0.0D0
         B10(I) = 0.0D0
   10 CONTINUE
C
      DO 20 I=1,15
         STATS(I) = 0.0D0
   20 CONTINUE
C
      CC = 0.0D0
      F = 0.0D0
      DMS = 0.0D0
      BSS = 0.0D0
      WSS = 0.0D0
      HSTAT = 0.0D0
      MF = 0.0D0
      SC = 0.0D0
      SMAX = 0.0D0
      NNE1 = 0
      SNC = 0.0D0
      SOS = 0.0D0
      SSS = 0.0D0
      SUM = 0.0D0
      TIES = 0.0D0
      TSS = 0.0D0
      SMIN = 0.0D0
      SFRAT = 0.0D0
C
C     BEGIN COMPUTATIONS
C
C     COMPUTE RANKS
C
      CALL RANKO(NZW, Y(NZPNTR), ITEMP, RANKS, TIES)
C
C     INITIALIZE FIRST ELEMENT BEFORE ENTERING LOOP
C
      TVALUE(1) = TAG(NZPNTR)
      SRANK(1) = RANKS(1)
      GPMIN(1) = Y(NZPNTR)
      GPMAX(1) = Y(NZPNTR)
      YMIN = GPMIN(1)
      YMAX = GPMAX(1)
      GM = Y(NZPNTR)
      IBAR = 1.0D0
      TMEAN(1) = Y(NZPNTR)
      TSIZE(1) = 1.0D0
C
C     DETERMINE MEANS AND MAXS, DO SUMMATION PRIOR TO
C     DETERIMING MEANS
C     HERE J IS THE GROUP NUMBER
C
      J = 1
      L = NZPNTR + 1
      DO 50 I=L,N
         IF (TAG(I).EQ.TAG(I-1)) GO TO 40
C
C        NEW TAG GROUP
         J = J + 1
         TVALUE(J) = TAG(I)
         GPMIN(J) = Y(I)
         GPMAX(J) = Y(I)
   40    TSIZE(J) = TSIZE(J) + 1.0D0
         TMEAN(J) = TMEAN(J) + Y(I)
         GM = GM + Y(I)
C
C     UNNECESSARY COMPUTATIONS IF PRINTED OUTPUT IS SUPRESSED
C
         IF (NPRT.EQ.0) GO TO 50
         K = I + 1 - NZPNTR
         SRANK(J) = SRANK(J) + RANKS(K)
         GPMIN(J) = MIN(GPMIN(J),Y(I))
         GPMAX(J) = MAX(GPMAX(J),Y(I))
         YMIN = MIN(YMIN,GPMIN(J))
         YMAX = MAX(YMAX,GPMAX(J))
         IBAR = IBAR + J
   50 CONTINUE
C
C     CALCULATE MEANS
C
      GM = GM/FNZW
      IBAR = IBAR/FNZW
      K = NZPNTR-1
      I = NZPNTR
      DO 70 J=1,NG
         IF (TSIZE(J).GE.2.0D0) THEN
            TMEAN(J) = TMEAN(J)/TSIZE(J)
         ELSE
            TMEAN(J) = TMEAN(J)
         END IF
         K = K + INT(TSIZE(J))
C
C     L GIVES INDEX TO Y VALUE WITHIN GROUP J
C
         DO 60 L=I,K
            RESSQ = (Y(L)-TMEAN(J))*(Y(L)-TMEAN(J))
            TSD(J) = TSD(J) + RESSQ
            IF (NPRT.EQ.0) GO TO 60
            BSS = BSS + (TMEAN(J)-GM)*(TMEAN(J)-GM)
            WSS = WSS + RESSQ
            TSS = TSS + (Y(L)-GM)*(Y(L)-GM)
   60    CONTINUE
         I = K + 1
   70 CONTINUE
C
C     NOW DONE WITH TAG VECTOR, RETURN VECTOR TO INPUT ORDER
C     INDEX IS FREED FOR USE IN OTHER PLACES
C
      CALL SRTRRI(TAG, Y, N, INDEX)
C
C     CHECK FOR PRINTED OUTPUT
C
      IF (NPRT.NE.0) GO TO 90
C
C     COMPUTE STANDARD DEVIATIONS WITHIN EACH GROUP
C
      DO 80 J=1,NG
         TSD(J) = SQRT(TSD(J))
         IF (TSIZE(J).LE.1.0D0) GO TO 80
         TSD(J) = TSD(J)/SQRT(TSIZE(J)-1.0D0)
   80 CONTINUE
C
C     COMPUTATIONS COMPLETE FOR STORED OUTPUT - RETURN IF PRINTED
C     OUTPUT IS SUPRESSED
C
      RETURN
   90 YBMIN = TMEAN(1)
      YBMAX = TMEAN(1)
      SMIN = FPLM
C     HERE I IS THE GROUP NUMBER
      DO 120 I=1,NG
         IF (TSD(I).GT.0.0D0) THEN
            B10(I) = TSIZE(I)*(TSIZE(I)-1.0D0)/TSD(I)
            STATS(1) = STATS(1) + B10(I)*TMEAN(I)
            STATS(2) = STATS(2) + B10(I)
            IF (TSIZE(I).GT.1.0D0) THEN
               TSD(I) = SQRT(TSD(I)/(TSIZE(I)-1.0D0))
            END IF
            MF = MF + (TSIZE(I)-1.0D0)*LOG(TSD(I)*TSD(I))
         END IF
         IF (NINT(TSIZE(I)).GE.2) THEN
            NNE1 = NNE1 + 1
            SMAX = MAX(SMAX,TSD(I))
            SMIN = MIN(SMIN,TSD(I))
            STATS(3) = STATS(3) + 1.0D0/(TSIZE(I)-1.0D0)
         END IF
         SSS = SSS + TSIZE(I)*(I-IBAR)*(TMEAN(I)-GM)
         STATS(4) = STATS(4) + TSIZE(I)*(I-IBAR)*(I-IBAR)
C
C        LOOK FOR SMALLEST AND LARGEST MEANS (YBAR)
C
         YBMIN = MIN(YBMIN,TMEAN(I))
         YBMAX = MAX(YBMAX,TMEAN(I))
C
         HSTAT = HSTAT + SRANK(I)*SRANK(I)/TSIZE(I)
         SUM = SUM + 1.0D0/TSIZE(I)
         STATS(5) = STATS(5) + (TMEAN(I)-GM)*(TMEAN(I)-GM)
         SOS = SOS + TSD(I)*TSD(I)
         SNC = SNC + TSIZE(I)*TSIZE(I)
         SC = SC + TSIZE(I)*TSIZE(I)*TSIZE(I)
  120 CONTINUE
      IF (STATS(2).NE.0.0D0) STATS(1) = STATS(1)/STATS(2)
      IF (STATS(4).NE.0.0D0) SSS = SSS*SSS/STATS(4)
      DSS = BSS - SSS
C
C     DEGREES OF FREEDOM FOR ANOVA
C
      G1 = NG-1
      M3 = NG - 2
      GR = NZW-NG
      M5 = NZW - 1
C
C     MEAN SQUARES
C
      BMS = BSS/G1
      SMS = SSS
      IF (NG.GE.3) DMS = DSS/M3
      WMS = WSS/GR
      TMS = TSS/M5
      IF (WMS.EQ.BMS) THEN
         BFRAT = 1.0D0
         BFSIG = 1.0D0
      ELSE IF (WMS.EQ.0.0D0) THEN
         BFRAT = FPLM
         BFSIG = 0.0D0
      ELSE
         BFRAT = BMS/WMS
         BFSIG = 1.0D0 - CDFF(BFRAT,G1,GR)
      END IF
      IF (WMS.EQ.DMS) THEN
         DFRAT = 1.0D0
         DFSIG = 1.0D0
      ELSE IF (WMS.EQ.0.0D0) THEN
         DFRAT = FPLM
         DFSIG = 0.0D0
      ELSE
         DFRAT = DMS/WMS
         DFSIG = 1.0D0 - CDFF(DFRAT,DBLE(M3),DBLE(NZW-2))
      END IF
      IF (SMS.EQ.DSS+WSS) THEN
         SFRAT = 1.0D0
         SFSIG = 1.0D0
      ELSE IF (DSS+WSS.EQ.0.0D0) THEN
         SFRAT = FPLM
         SFSIG = 0.0D0
      ELSE
         SFRAT = SMS/((DSS+WSS)/(FNZW-2.0D0))
         SFSIG = 1.0D0 - CDFF(SFRAT,1.0D0,GR)
      END IF
C
C     COMPUTE FOR KRUSKAL-WALLIS TEST
C     FOR FORMULAE WITH CLEARER FORM AND NAMES SEE
C     KRAFT AND VAN EEDEN  A NON PARAMETRIC INTRODUCTION TO STATISTICS,
C     PP. 238 - 240
C
      STATS(6) = NZW*(NZW+1)
      HSTAT = (12.0D0*HSTAT/STATS(6)) - (3.0D0*(NZW+1))
      IF (TIES.EQ.NZW*NZW*NZW-NZW) THEN
         CFKW = 0.0D0
         HSTAT = 0.0D0
         MKW = 0.0D0
      ELSE
         CFKW = 1.0D0 - TIES/(NZW*NZW*NZW-NZW)
         HSTAT = HSTAT/CFKW
         MKW = ((NZW*NZW*NZW-SC)/STATS(6))/CFKW
      END IF
      VKW = 2.0D0*G1 -
     +   (0.4D0*(3*NG*M3+NZW*(2*NG*(NG-3)+1)))/STATS(6)
     +   - 6.0D0*SUM/5.0D0
      IF (MKW-HSTAT.GT.0.0D0 .AND.
     +    MKW.NE.0.0D0 .AND. VKW.NE.0.0D0) THEN
         F1KW = (G1*(G1*(MKW-G1)-VKW))/(0.5D0*VKW*MKW)
         F2KW = (MKW-G1)*F1KW/G1
         FSTAT = (HSTAT*(MKW-G1))/(G1*(MKW-HSTAT))
         SIGKW = 1.0D0 - CDFF(FSTAT,ANINT(F1KW),ANINT(F2KW))
      ELSE
         SIGKW = 0.0D0
      END IF
C
C     COMPUTE TOTAL STATISTICS
C
      SWMS = SQRT(WMS)
      SBMS = SQRT(STATS(5)/G1)
      STMS = SQRT(TMS)
      SQMS = SWMS/(SQRT(FNZW))
      SQB = SBMS/(SQRT(DBLE(NG)))
      SQT = STMS/(SQRT(FNZW))
      T1 = PPFT(0.975D0,INT(GR))
      T2 = PPFT(0.975D0,INT(G1))
      T3 = PPFT(0.975D0,M5)
      FMLC = GM - SQMS*T1
      RMLC = GM - SQB*T2
      UMLC = GM - SQT*T3
      FMUC = GM + SQMS*T1
      RMUC = GM + SQB*T2
      UMUC = GM + SQT*T3
C
      SSF = SWMS*SQRT(G1*PPFF(0.95D0,INT(G1),INT(GR)))
C
C     TESTS FOR HOMOGENEITY OF VARIANCES
C
      IF (SMAX*SMAX.EQ.SOS) THEN
         CC = 1.0D0
      ELSE IF (SOS.NE.0.0D0) THEN
         CC = SMAX*SMAX/SOS
      END IF
      STATS(7) = ANINT(FNZW/NG)
      IF ((NNE1.GE.2) .AND. (CC.NE.1.0D0)) THEN
         SLCC = 1.0D0 -
     +          CDFF((NNE1-1)*CC/(1.0D0-CC),STATS(7),
     +          STATS(7)*(NNE1-1))
      ELSE
         SLCC = 1.0D0
      END IF
      SLCC = (NNE1-1)*SLCC
      IF (SLCC.GT.1.0D0) SLCC = 1.0D0
C
      IF (SMIN.EQ.SMAX) THEN
         VLS = 1.0D0
      ELSE
         IF (SMIN.EQ.0.0D0) THEN
            VLS = FPLM
         ELSE
            VLS = (SMAX/SMIN)*(SMAX/SMIN)
         END IF
      END IF
      IF (WMS.GT.0.0D0) MF = GR*LOG(WMS) - MF
      AF = (STATS(3)-(1.0D0/GR))/(3.0D0*G1)
      SLBF = 1.0D0
      IF ((AF.NE.1.0D0) .AND. (NNE1.GE.2)) THEN
         DF = (NNE1+1)/(AF*AF)
         BF = (DF*MF)/((NNE1-1)*(DF/(1.0D0-AF+(2.0D0/DF))-MF))
         IF (BF.LT.0.0D0) BF = 0.0D0
         SLBF = 1.0D0 - CDFF(BF,DBLE(NNE1-1),ANINT(DF))
      ELSE
         BF = FPLM
      END IF
      K0 = (FNZW-(SNC/FNZW))/G1
      SQOM = (BMS-WMS)/K0
C
C     COMPUTATIONS ARE NOW COMPLETE ************************************
C
C     PRINT ANOVA
C
      NN = N - NZW
      WRITE (IPRT,1000) NN
      NN = NG - 1
      WRITE (IPRT,1010) NN, BSS, BMS, BFRAT, BFSIG
      IF (NG.LT.3) GO TO 180
      IF (BFSIG.GE..10) GO TO 180
      NN = 1
      WRITE (IPRT,1020) NN, SSS, SMS, SFRAT, SFSIG
      WRITE (IPRT,1030) M3, DSS, DMS, DFRAT, DFSIG
  180 NN = NZW - NG
      WRITE (IPRT,1040) NN, WSS, WMS
      WRITE (IPRT,1050) M5, TSS
C
C     PRINT KRUSKAL-WALLIS TEST
C
      WRITE (IPRT,1060) HSTAT, SIGKW
C
C     PRINT ESTIMATES
C
      WRITE (IPRT,1070)
      DO 200 I=1,NG
         MEAN = BLANK
         IF (TMEAN(I).LE.YBMIN) MEAN = LOW
         IF (TMEAN(I).GE.YBMAX) MEAN = HIGH
         ISD = BLANK
         IF (TSD(I).LE.SMIN) ISD = LOW
         IF (TSD(I).GE.SMAX) ISD = HIGH
         ISZ = INT(TSIZE(I))
         IF (ISZ.LE.1) THEN
            WRITE (IPRT,1090) TVALUE(I), ISZ, TMEAN(I), MEAN, GPMIN(I),
     +         GPMAX(I), SRANK(I)
         ELSE
            STATS(9) = TSD(I)/SQRT(TSIZE(I))
            STATS(10) = PPFT(0.975D0,ISZ-1)
            STATS(8) = TMEAN(I) - STATS(9)*STATS(10)
            STATS(11) = TMEAN(I) + STATS(9)*STATS(10)
            WRITE (IPRT,1080) TVALUE(I), ISZ, TMEAN(I), MEAN, TSD(I),
     +                        ISD, STATS(9), GPMIN(I), GPMAX(I),
     +                        SRANK(I), STATS(8), STATS(11)
         END IF
  200 CONTINUE
      WRITE (IPRT,1100) NZW, GM, YMIN, YMAX, SWMS, SQMS, FMLC, FMUC,
     +   SBMS, SQB, RMLC, RMUC, STMS, SQT, UMLC, UMUC
      IF (BFSIG.LT.0.10) THEN
C
C     SORT YBAR FOR MULTIPLE COMPARISIONS OF MEANS
C
         CALL GENI(INDEX, NG, 1, 1)
         CALL SRTIR(INDEX, NG, TMEAN)
C
C     COMPUTE AND PRINT FOR MULTIPLE COMPARISIONS
C
         IF (NZW-NG.LT.4) GO TO 270
         WRITE (IPRT,1110)
C
C     NEWMAN-KEULS-HARTLEY
C
         WRITE (IPRT,1120)
         RX = -.283917D0 + 2.63532D0*(GR-1.00123D0)**(-.95862D0)
         U1 = -.314115D0 + 2.38301D0*(GR-1.03428D0)**(-.864005D0)
         U2 = 3.65961D0*U1**2 - 1.00891D0*U1 - 0.166346D0
         J = 1
         M28 = 0
  210    I = NG
  220    IF (I.LE.M28) GO TO 260
         IF (I.EQ.J) GO TO 230
         STATS(14) = ABS(TMEAN(I)-TMEAN(J))
C
C     MANDEL APPROXMATION TO PERCENT POINT OF STUDENTIZED RANGE
C
         STATS(12) = I-J+1
         C = 2.3849867D0 -
     +       2.9051857D0*(STATS(12)-0.57583164D0)**(-.069648109D0)
         V1 = 1.30153D0 -
     +        1.95073D0*(STATS(12)+.394915D0)**(-.139783D0)
         V2 = 4.72863D0*V1**2 + 0.404271D0*V1 - 0.135104D0
         STATS(13) = 6.15075D0 + 4.441409D0*RX +
     +               6.7514569D0*C + 7.4671282D0*U1*V1 -
     +               0.157537D0*U2*V2
         KK = INDEX(I)
         KKK = INDEX(J)
         STATS(13) = STATS(13)*
     +            SQRT(0.5D0*((1.0D0/TSIZE(KK))+(1.0D0/TSIZE(KKK))))*
     +            SWMS
         IF (STATS(14).LE.STATS(13)) GO TO 230
         I = I - 1
         GO TO 220
  230    IF (J.EQ.1) GO TO 250
         IF (J.GT.M28) GO TO 240
         WRITE (IPRT,1150)
         GO TO 250
  240    WRITE (IPRT,1160)
  250    WRITE (IPRT,1140) (TMEAN(M),M=J,I)
         IF (I.GE.NG) GO TO 270
         M28 = I
  260    J = J + 1
         GO TO 210
C
C     SCHEFFE METHOD
C
  270    WRITE (IPRT,1130)
         J = 1
         M28 = 0
  280    I = NG
  290    IF (I.LE.M28) GO TO 330
         IF (I.EQ.J) GO TO 300
         KK = INDEX(I)
         KKK = INDEX(J)
         STATS(14) = ABS(TMEAN(I)-TMEAN(J))
         STATS(13) = SSF*SQRT((1.0D0/TSIZE(KK))+(1./TSIZE(KKK)))
         IF (STATS(14)-STATS(13).LE.0.0D0) GO TO 300
         I = I - 1
         GO TO 290
  300    IF (J.EQ.1) GO TO 320
         IF (J.GT.M28) GO TO 310
         WRITE (IPRT,1150)
         GO TO 320
  310    WRITE (IPRT,1160)
  320    WRITE (IPRT,1140) (TMEAN(M),M=J,I)
         IF (I.GE.NG) GO TO 340
         M28 = I
  330    J = J + 1
         GO TO 280
C
C     RETURN TAG MEANS TO ORIGINAL ORDER
C
  340    CALL SRTRI(TMEAN, NG, INDEX)
      END IF
C
      IF (NNE1.LE.1) RETURN
      WRITE (IPRT,1170) CC, SLCC, BF, SLBF, VLS
      IF (SLCC.GT.0.1D0 .AND. SLBF.GT.0.1D0) GO TO 390
      DO 360 I=1,NG
         F = F + B10(I)*(TMEAN(I)-STATS(1))*(TMEAN(I)-STATS(1))
         IF (STATS(2).EQ.0.0D0 .OR. TSIZE(I).LE.1.0D0) GO TO 360
         STATS(15) = STATS(15) +
     +               (1.0D0-B10(I)*B10(I)/STATS(2)/STATS(2))/
     +               (TSIZE(I)-1.0D0)
  360 CONTINUE
      IF (STATS(15).EQ.0.0D0) GO TO 370
      STATS(15) = (NG*NG-1.0D0)/(3.0D0*STATS(15))
      IF (NG.LE.1) GO TO 370
      F = (F/G1)/(1.0D0+(2.0D0*M3/(3.0D0*STATS(15))))
      GO TO 380
  370 F = 0.0D0
  380 Q = 1.0D0 - CDFF(F,G1,ANINT(STATS(15)))
      WRITE (IPRT,1180) F, Q
  390 WRITE (IPRT,1190) SQOM
      RETURN
C
C     AUTOMATIC PRINTOUT IS FINISHED
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(54H *GROUP NUMBERS HAVE BEEN ASSIGNED ACCORDING TO TAG VA,
     +   59HLUES GIVEN, WHERE THE SMALLEST TAG GREATER THAN ZERO HAS BE,
     +   14HEN ASSIGNED  */41H *GROUP NUMBER 1, THE NEXT SMALLEST, GROU,
     +   59HP NUMBER 2, ETC.  TAGS LESS THAN OR EQUAL TO ZERO HAVE NOT ,
     +   27HBEEN INCLUDED IN ANALYSIS.*/28H *NUMBER OF VALUES EXCLUDED ,
     +   17HFROM ANALYSIS IS , I4, 77X, 1H*//17X, 6HSOURCE, 14X, 4HD.F.,
     +   4X, 14HSUM OF SQUARES, 5X, 12HMEAN SQUARES, 9X, 7HF RATIO, 4X,
     +   7HF PROB./)
 1010 FORMAT(17X, 14HBETWEEN GROUPS, 5X, I4, 1P2E18.6, 4X, 0PE11.3,
     +   F10.3)
 1020 FORMAT(20X, 5HSLOPE, 14X, I4, 1P2E18.6, 3X, 0PE11.3, F10.3)
 1030 FORMAT(20X, 16HDEVS. ABOUT LINE, 3X, I4, 1P2E18.6, 3X, 0PE11.3,
     +   F10.3)
 1040 FORMAT(17X, 13HWITHIN GROUPS, 6X, I4, 1P2E18.6)
 1050 FORMAT(17X, 5HTOTAL, 14X, I4, 1PE18.6//)
 1060 FORMAT(11X, 49HKRUSKAL-WALLIS RANK TEST FOR DIFFERENCE BETWEEN G,
     +   16HROUP MEANS * H =, E11.3, 10H, F PROB =, F6.3, 10H (APPROX.)
     +   /)
 1070 FORMAT(55X, 9HESTIMATES/96X, 6HSUM OF/5X, 5H TAG , 10X, 3HNO.,
     +   6X, 4HMEAN, 7X, 11HWITHIN S.D., 2X, 12HS.D. OF MEAN, 5X,
     +   7HMINIMUM, 7X, 7HMAXIMUM, 6X, 5HRANKS, 3X, 16H95PCT CONF INT F,
     +   7HOR MEAN/)
 1080 FORMAT(1X, 1PE14.6, I8, E14.5, A1, E13.5, A1, E13.5, 2E14.5,
     +   0PF9.1, 1PE13.5, 3H TO, E12.5)
 1090 FORMAT(1X, 1PE14.6, I8, E14.5, A1, 3X, 23H ESTIMATE NOT AVAILABLE,
     +   ' ', 2E14.5, 0PF9.1, 3X, 25H********** TO ********** )
 1100 FORMAT(/11X, 5HTOTAL, I7, 1PE14.5, 28X, 2E14.5//
     +   17X, 20HFIXED EFFECTS MODEL , 2E14.5, 37X, E13.5, 3H TO, E12.5/
     +   17X, 7HRANDOM ,
     +   13HEFFECTS MODEL, 2E14.5, 37X, E13.5, 3H TO, E12.5/17X,
     +   14HUNGROUPED DATA, 6X, 2E14.5, 37X, E13.5, 3H TO, E12.5/)
 1110 FORMAT(1X, 50HPAIRWISE MULTIPLE COMPARISON OF MEANS.  THE MEANS ,
     +   59HARE PUT IN INCREASING ORDER IN GROUPS SEPARATED BY *****.  ,
     +   11HA MEAN IS  /44H ADJUDGED NON-SIGNIFICANTLY DIFFERENT FROM A,
     +   59HNY MEAN IN THE SAME GROUP AND SIGNIFICANTLY DIFFERENT AT TH,
     +   17HE .05 LEVEL FROM /38H ANY MEAN IN ANOTHER GROUP.  ***** ***,
     +   59H** INDICATES ADJACENT GROUPS HAVE NO COMMON MEAN.          ,
     +   23H                       )
 1120 FORMAT(/3X, 49HNEWMAN-KEULS TECHNIQUE, HARTLEY MODIFICATION. (AP,
     +   40HPROXIMATE IF GROUP NUMBERS ARE UNEQUAL.))
 1130 FORMAT(/3X, 18HSCHEFFE TECHNIQUE.)
 1140 FORMAT(3X, 9(1PE12.5, ','))
 1150 FORMAT(6X, 5H*****)
 1160 FORMAT(3X, 11H***** *****)
 1170 FORMAT(/36H TESTS FOR HOMOGENEITY OF VARIANCES./7X, 9HCOCHRANS ,
     +   35HC = MAX. VARIANCE/SUM(VARIANCES) = , F7.4, 6H, P = , F6.3,
     +   10H (APPROX.)/7X, 17HBARTLETT-BOX F = , F9.3, 6H, P = ,
     +   F6.3/7X, 38HMAXIMUM VARIANCE / MINIMUM VARIANCE = , F14.4)
 1180 FORMAT(7X, 50HAPPROX BETWEEN MEANS F-TEST IN PRESENCE OF HETEROG,
     +   20HENEOUS VARIANCE. F =, F8.3, 5H, P =, F6.3)
 1190 FORMAT(/35H MODEL II - COMPONENTS OF VARIANCE./7X, 10HESTIMATE O,
     +   20HF BETWEEN COMPONENT , 1PE14.6)
      END
*AOV1S
      SUBROUTINE AOV1S(Y, TAG, N, LDSTAK, NPRT, GSTAT, IGSTAT, NG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE -
C     1. CALLS OTHER ROUTINES TO CHECK THE INPUT PARAMETERS
C     2. SETS UP NEEDED STORAGE LOCATIONS AND
C     3. CALLS AOV1MN TO COMPUTE A COMPREHENSIVE SET OF RESULTS FOR A
C         ONEWAY ANALYSIS OF VARIANCE WITH OPTIONAL OUTPUT.
C
C     WRITTEN BY -
C       LINDA MITCHELL
C       STATISTICAL ENGINEERING DIVISION
C       NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C                       BASED ON EARLIER VERSION BY J. R. DONALDSON
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IGSTAT,LDSTAK,N,NG,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   GSTAT(*),TAG(*),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   B10,GPMAX,GPMIN,IFP,INDEX,INT,IPRT,ITEMP,NALL0,NZTAGS,
     +   RANKS,SRANK
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET
      EXTERNAL STKGET
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AOV1ER,AOV1HD,AOV1MN,IPRINT,STKCLR
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER B10
C        STARTING LOCATION IN THE STACK AREA FOR B10
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER GPMAX
C        THE STARTING LOCATION IN THE STACK AREA OF MAXIMUM
C        OBSERVATION
C     INTEGER GPMIN
C        THE STARTING LOCATION IN THE STACK AREA OF THE MINUMUM
C        OBSERVATION
C     DOUBLE PRECISION GSTAT(IGSTAT,4)
C        THE GROUP STATISTICS.  COLUMNS CORRESPOND TO THE TAG
C        VALUE, SAMPLE SIZE, GROUP MEAN, AND GROUP STANDARD DEVIATION.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG INDICATING WHETHER THERE
C        ARE ANY ERRORS, IF = 0 THEN NO ERRORS
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IGSTAT
C        THE FIRST DIMENSION OF GSTAT.
C     INTEGER INDEX
C        THE STARTING LOCATION IN THE STACK ARRAY OF THE INDEX FOR
C        THE SORTED TAGS
C     INTEGER INT
C        FRAMEWORK CODE VALUE FOR INTEGER NUMBERS
C     INTEGER IPRT
C        THE OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ITEMP
C        STARTING LOCATION IN THE STACK FOR THE
C        TEMPORARY STORAGE ARRAY
C     INTEGER LDSTAK
C         SIZE OF THE STACK AREA ALLOCATED IN THE USERS MAIN PROGRAM
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS TO BE ANALYZED
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT THIS
C        ROUTINE WAS CALLED.
C     INTEGER NG
C        THE COMPUTED NUMBER OF GROUPS WITH
C        DIFFERENT POSITIVE TAG VALUES
C     CHARACTER*1 NMSUB(6)
C        SUBROUTINE NAME
C     INTEGER NPRT
C        THE VARIABLE CONTROLLING AUTOMATIC PRINTOUT
C        IF =0, PRINTOUT IS SUPRESSED
C        OTHERWISE PRINTOUT IS PROVIDED
C     INTEGER NZTAGS
C        THE NUMBER OF OBSERVATIONS WITH POSITIVE NON-ZERO WIEGHTS
C     INTEGER RANKS
C        THE STARTING LOCATION IN STACK AREA FOR THE RANKS OF Y
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER SRANK
C        THE STARTING LOCATION IN STACK FOR THE SUM OF RANKS
C     DOUBLE PRECISION TAG(N)
C        THE VECTOR OF TAG VALUES
C     DOUBLE PRECISION Y(N)
C        THE VECTOR OF OBSERVATIONS
C
      DATA   NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +     /      'A',      'O',      'V',      '1',      'S',      ' '/
C
C     SET UP FRAMEWORK VARIABLES FOR NUMBER TYPES
C
      INT = 2
      IFP = 4
C
      CALL IPRINT(IPRT)
C
C     CHECK FOR ERRORS IN PARAMETERS, INITIALIZE STACK, AND SET
C     NALL0.
C
      CALL AOV1ER(Y, TAG, N, IGSTAT, NZTAGS, NG, LDSTAK, NMSUB, INDEX,
     +   0, NALL0)
C
      IF (IERR.EQ.0) GO TO 20
C
C     PRINT CORRECT FORM OF CALL STATEMENT AND RETURN TO CALLER
C
      IERR = 1
      WRITE (IPRT,1000)
      RETURN
C
C     PRINT HEADING IF DESIRED
C
   20 IF (NPRT.EQ.0) GO TO 30
      CALL AOV1HD(IPRT)
C
C     SET UP ADDITIONAL WORK VECTORS FOR AOV1MN AS CALLED FROM AOV1S
C
   30 SRANK = STKGET(NG,IFP)
      GPMIN = STKGET(NG,IFP)
      GPMAX = STKGET(NG,IFP)
      B10 = STKGET(NG,IFP)
      RANKS = STKGET(NZTAGS,IFP)
      ITEMP = STKGET(NZTAGS,INT)
C
      CALL AOV1MN(Y, TAG, N,
     +            GSTAT(1), GSTAT(IGSTAT+1),
     +            GSTAT(2*IGSTAT+1), GSTAT(3*IGSTAT+1),
     +            NPRT, ISTAK(INDEX), RSTAK(SRANK), RSTAK(GPMIN),
     +            RSTAK(GPMAX), RSTAK(B10), RSTAK(RANKS),
     +            ISTAK(ITEMP), NG, NZTAGS)
C
C     RELEASE THE STACK AREA
C
      CALL STKCLR(NALL0)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL AOV1S (Y, TAG, N, LDSTAK, NPRT, GSTAT, IGSTAT, NG)')
      END
*AOV1XP
      SUBROUTINE AOV1XP(GSTAT, IGSTAT, NG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     PRINT STORAGE FOR ONEWAY FAMILY EXERCISER
C     AND CLEAR STORAGE VECTORS
C
C     WRITTEN BY -
C        LINDA MITCHELL
C        STATISTICAL ENGINEERING DIVISION
C        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IGSTAT,NG
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   GSTAT(IGSTAT,4)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT,J
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,SETRA
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION GSTAT(IGSTAT,4)
C        THE GROUP STATISTICS.  COLUMNS CORRESPOND TO THE TAG
C        VALUE, SAMPLE SIZE, GROUP MEAN, AND GROUP STANDARD DEVIATION.
C     INTEGER I
C        AN INDEX VALUE
C     INTEGER IGSTAT
C        THE FIRST DIMENSION OF GSTAT.
C     INTEGER IPRT
C        THE OUTPUT LOGICAL UNIT NUMBER
C     INTEGER J, NG
C        *
C
C     COMMENCE BODY OF ROUTINE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      WRITE (IPRT,1010) ((GSTAT(I,J),J=1,4),I=1,NG)
      CALL SETRA(GSTAT, IGSTAT, 4, NG, 0.0D0)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(//21H STORAGE FROM AOV1   //6X, 8HTAGVALUE,
     +   11X, 10H GROUPSIZE, 11X, 10H GROUPMEAN, 13X, 8H GROUPSD/)
 1010 FORMAT(4(1X, G20.14))
      END
*ARCOEF
      SUBROUTINE ARCOEF (ACOV, PHI, RSS, LAG, LAGMAX, ACOV0)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE USES DURBINS RECURSIVE METHOD TO COMPUTE
C     THE AUTOREGRESSIVE COEFFICIENTS OF AN ORDER LAG PROCESS,
C     GIVEN ON INPUT THE COEFFICIENTS OF AN ORDER (LAG-1) PROCESS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ACOV0,RSS
      INTEGER
     +   LAG,LAGMAX
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),PHI(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   SUM1,SUM2,T
      INTEGER
     +   J,L1,L2,LJ
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LAGMAX)
C        THE ARRAY OF ACVF ESTIMATES FOR LAGS ONE TO LAGMAX.
C     DOUBLE PRECISION ACOV0
C        THE ACVF FOR LAG ZERO.
C     INTEGER J, LAG
C        INDEX VARIABLES.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE USED.
C     INTEGER LJ, L2
C        INDEX VARIABLES.
C     DOUBLE PRECISION PHI(LAGMAX)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR AN AR
C        PROCESS OF ORDER LAG.
C     DOUBLE PRECISION RSS
C        THE ONE STEP PREDICTION RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION SUM1, SUM2
C        VARIABLES USED IN THE COMPUTATIONS OF THE AUTOREGRESSIVE
C        COEFFICIENTS.
C     DOUBLE PRECISION T
C        A TEMPORARY STORAGE LOCATION.
C
      L1 = LAG - 1
      SUM1 = 0.0D0
      SUM2 = 0.0D0
      DO 10 J = 1, L1
         LJ = LAG - J
         SUM1 = SUM1 + PHI(J) * ACOV(LJ)
         SUM2 = SUM2 + PHI(J) * ACOV(J)
   10 CONTINUE
      PHI(LAG) = (ACOV(LAG) - SUM1) / (ACOV0 - SUM2)
      L2 = LAG / 2
      DO 20 J = 1, L2
         LJ = LAG - J
         T = PHI(J) - PHI(LAG) * PHI(LJ)
         PHI(LJ) = PHI(LJ) - PHI(LAG) * PHI(J)
         PHI(J) = T
   20 CONTINUE
C
      RSS = RSS * (1.0D0 - PHI(LAG)*PHI(LAG))
C
      RETURN
      END
*ARFLT
      SUBROUTINE ARFLT (Y, N, IAR, PHI, YF, NYF)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PERFORMS THE AUTOREGRESSIVE FILTERING
C     OPERATION DEFINED BY PHI, RETURNING THE FILTERED SERIES
C     IN YF.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IAR,N,NYF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PHI(*),Y(*),YF(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   YMEAN
      INTEGER
     +   I,IPRT
      LOGICAL
     +   ERR01,HEAD
C
C  LOCAL ARRAYS
      CHARACTER
     +   LN(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN,EISGE,FLTAR,IPRINT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IAR
C        THE NUMBER OF FILTER COEFFICIENTS.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     CHARACTER*1 LN(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
C        CHECKED FOR ERRORS.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NYF
C        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
C     DOUBLE PRECISION PHI(IAR)
C        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YF(N)
C        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE INPUT SERIES Y.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'A',       'R',       'F',       'L',       'T',       ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 3, 1, HEAD, ERR01, LN)
C
C
      IF (.NOT. ERR01) GO TO 10
C
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   10 CONTINUE
C
C     COMPUTE ARITHMETIC MEAN
C
      CALL AMEAN(Y, N, YMEAN)
C
      DO 20 I = 1, N
         YF(I) = Y(I) - YMEAN
   20 CONTINUE
C
      CALL FLTAR (YF, N, IAR, PHI, YF, NYF)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   43H       CALL ARFLT (Y, N, IAR, PHI, YF, NYF))
      END
*AXPBY
      SUBROUTINE AXPBY(N,SA,SX,INCX,SB,SY,INCY,SZ,INCZ)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE IS ADAPTED FROM BLAS SUBROUTINE DAXPY.
C
C     OVERWRITE DOUBLE PRECISION SZ WITH DOUBLE PRECISION SA*SX + SB*SY.
C     FOR I = 0 TO N-1, REPLACE  SZ(LZ+I*INCZ) WITH SA*SX(LX+I*INCX) +
C     SY(LY+I*INCY), WHERE LX = 1 IF INCX .GE. 0, ELSE LX = (-INCX)*N,
C     AND LY AND LZ ARE DEFINED IN A SIMILAR WAY USING INCY AND INCZ,
C     RESPECTIVELY.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SA,SB
      INTEGER
     +   INCX,INCY,INCZ,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   SX(*),SY(*),SZ(*)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IX,IY,IZ,M,MP1,NS
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MOD
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION SX(N), SY(N), SZ(N)
C
      IF(N.LE.0) RETURN
      IF ((INCX .EQ. 1) .AND. (INCY .EQ. 1) .AND. (INCZ .EQ. 1))
     +   GO TO 20
      IF ((INCX .GE. 2) .AND. (INCX .EQ. INCY) .AND. (INCX .EQ. INCZ))
     +   GO TO 60
C
C        CODE FOR NONEQUAL OR NONPOSITIVE INCREMENTS.
C
      IX = 1
      IY = 1
      IZ = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      IF(INCZ.LT.0)IZ = (-N+1)*INCZ + 1
      DO 10 I = 1,N
        SZ(IZ) = SA*SX(IX) + SB*SY(IY)
        IX = IX + INCX
        IY = IY + INCY
        IZ = IZ + INCZ
   10 CONTINUE
      RETURN
C
C        CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C        CLEAN-UP LOOP SO REMAINING VECTOR LENGTH IS A MULTIPLE OF 4.
C
   20 M = MOD(N,4)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        SZ(I) = SA*SX(I) + SB*SY(I)
   30 CONTINUE
      IF( N .LT. 4 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,4
        SZ(I) = SA*SX(I) + SB*SY(I)
        SZ(I+1) = SA*SX(I+1) + SB*SY(I+1)
        SZ(I+2) = SA*SX(I+2) + SB*SY(I+2)
        SZ(I+3) = SA*SX(I+3) + SB*SY(I+3)
   50 CONTINUE
      RETURN
C
C        CODE FOR EQUAL, POSITIVE, NONUNIT INCREMENTS.
C
   60 CONTINUE
      NS = N*INCX
      DO 70 I=1,NS,INCX
        SZ(I) = SA*SX(I) + SB*SY(I)
   70 CONTINUE
      RETURN
      END
*BACKOP
      SUBROUTINE BACKOP (MSPEC, NFAC, NPARDF, MBOL, MBO, NPARMA, NPARAR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     COMPUTE NUMBER OF BACK ORDER TERMS FOR ARIMA MODEL
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 4, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   MBO,MBOL,NFAC,NPARAR,NPARDF,NPARMA
C
C  ARRAY ARGUMENTS
      INTEGER
     +   MSPEC(4,*)
C
C  LOCAL SCALARS
      INTEGER
     +   J
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER MBO
C        THE MAXIMUM BACK ORDER OPERATOR.
C     INTEGER MBOL
C        THE MAXIMUM BACK ORDER ON THE LEFT
C     INTEGER MSPEC(4,NFAC)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NPARAR
C        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
C     INTEGER NPARDF
C        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
C     INTEGER NPARMA
C        THE LENGTH OF THE VECTOR PARMA
C
C     COMPUTE DEGREE OF BACK OPERATOR RESULTING FROM THE NDF
C     DIFFERENCING FACTORS (= ND DOT IOD).
C
      NPARAR = 0
      NPARDF = 0
      NPARMA = 0
      IF (NFAC .EQ. 0) GO TO 20
      DO 10 J = 1, NFAC
         NPARAR = NPARAR + MSPEC(1,J)*MSPEC(4,J)
         NPARDF = NPARDF + MSPEC(2,J)*MSPEC(4,J)
         NPARMA = NPARMA + MSPEC(3,J)*MSPEC(4,J)
   10 CONTINUE
C
   20 CONTINUE
C
      MBOL = NPARDF + NPARAR
      MBO = MAX(MBOL,NPARMA)
C
      RETURN
C
      END
*BFS
      SUBROUTINE BFS(Y1, Y2, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
C     BIVARIATE SPECTRUM ANALYSIS (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y1(*),Y2(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS1,YMISS2
      INTEGER
     +   ICCOV,ICSPC2,INDEX1,INDEX2,INLPPC,IPHAS,IPRT,JCCOV,JNLPPC,
     +   LAGMAX,LAGMX1,LDSMIN,LDSTAK,LPCV,LW,LY,M,NF,NPRT,NW
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCOV(101,2,2),CEVEN(101),CODD(101),CSPC2(101,4),FREQ(101),
     +   PHAS(101,4),SPCF1(101),SPCF2(101),W(101),XAXIS(404),
     +   YAXIS(404)
      INTEGER
     +   ISYM(404),LAGS(4),NLPPC(1,1,1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,IPRINT,PARZEN,SETLAG
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION CCOV(101,2,2)
C        THE COVARIANCES.
C     DOUBLE PRECISION CEVEN(101)
C        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CODD(101)
C        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CSPC2(101,4)
C        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(101)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER ICSPC2
C        THE FIRST DIMENSION OF THE ARRAY CSPC2.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER INDEX1, INDEX2
C        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
C     INTEGER INLPPC
C        THE FIRST DIMENSION OF THE ARRAY NLPPC.
C     INTEGER IPHAS
C        THE FIRST DIMENSION OF THE ARRAY PHAS.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISYM(404)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER JCCOV
C        THE SECOND DIMENSION OF THE ARRAY CCOV.
C     INTEGER JNLPPC
C        THE SECOND DIMENSION OF THE ARRAY NLPPC.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGMX1
C        LAGMAX+1.
C     INTEGER LAGS(4)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LW
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LY
C        THE LENGTH OF THE VECTORS Y1 AND Y2.
C     INTEGER M
C        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
C        COMPUTED
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPC(1,1,1)
C        A DUMMY ARRAY.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT.
C        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        IF NPRT = 0 THE PLOT IS SUPPRESSED.
C        IF NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION PHAS(101,4)
C        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION SPCF1(101), SPCF2(101)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     DOUBLE PRECISION W(101)
C        THE WINDOWS.
C     DOUBLE PRECISION XAXIS(404)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YAXIS(404)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YMISS1, YMISS2
C        DUMMY VARIABLES.
C     DOUBLE PRECISION Y1(N)
C        THE FIRST TIME SERIES.
C     DOUBLE PRECISION Y2(N)
C        THE SECOND TIME SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S',' ',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(4) = .FALSE.
C
      ICCOV = 101
      JCCOV = 2
      M = 2
      INDEX1 = 1
      INDEX2 = 2
C
      ICSPC2 = 101
      IPHAS = 101
C
      LDSTAK = 0
      LDSMIN = 0
C
      NF = 101
      YMISS1 = 1.0D0
      YMISS2 = 1.0D0
      INLPPC = 1
      JNLPPC = 1
      LW = 101
      LY = N
      LPCV = 404
C
C     SET MAXIMUM LAG VALUE (LAGMAX)
C     SET NUMBER OF LAG WINDOW TRUCCATION POINTS (NW)
C
      CALL SETLAG(N, LAGMAX)
      NW = 4
C
C     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
C
      CALL BFSDRV(Y1, Y2, YMISS1, YMISS2, CCOV, NLPPC, SPCF1, SPCF2,
     +   NF, FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS, LAGMX1, W, LW,
     +   DELTA, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS, CODD,
     +   CEVEN, W, LW, NMSUB, LDSMIN, LDSTAK, OPTION, N, INLPPC,
     +   JNLPPC, LY)
C
      IF (IERR.EQ.0) RETURN
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL BFS (Y1, Y2, N)')
      END
*BFSDRV
      SUBROUTINE BFSDRV(Y1, Y2, YMISS1, YMISS2, CCOV, NLPPC, SPCF1,
     +   SPCF2, NF, FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS, LAGMX1,
     +   WORK, LWORK, DELTA, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT,
     +   WINDOW, ICCOV, JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2,
     +   IPHAS, CODD, CEVEN, W, LW, NMSUB, LDSMIN, LDSTAK, OPTION,
     +   NFFT, INLPPC, JNLPPC, LY)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE CONTROLING ROUTINE FOR TIME SERIES FOURIER
C     SPECTRUM ANALYSIS .
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS1,YMISS2
      INTEGER
     +   ICCOV,ICSPC2,INDEX1,INDEX2,INLPPC,IPHAS,JCCOV,JNLPPC,
     +   LAGMAX,LAGMX1,LDSMIN,LDSTAK,LPCV,LW,LWORK,LY,M,N,NF,NFFT,
     +   NPRT,NW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(*),CEVEN(*),CODD(*),CSPC2(*),FREQ(*),PHAS(*),SPCF1(*),
     +   SPCF2(*),W(*),WORK(*),XAXIS(*),Y1(*),Y2(*),YAXIS(*)
      INTEGER
     +   ISYM(*),LAGS(*),NLPPC(*)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL WINDOW
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   BW,DF,FMN,FMX,XPLTMN,XPLTMX,YMEAN1,YMEAN2,YPLTMN,YPLTMX
      INTEGER
     +   I,ILOG,ISPCER,J,K,LAG,LAGLST,NFUSED,NPTS,NWUSED
      LOGICAL
     +   NEWPG,UNIVAR
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   LSTLAG
      EXTERNAL LSTLAG
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACVF,ACVFF,ACVFM,BFSER,BFSLAG,BFSMN,CCVF,CCVFF,CCVFM,
     +   DFBW,DFBWM,SETFRQ,UFSEST,UFSOUT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC INT,MAX,MIN
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C  STATEMENT FUNCTIONS
      INTEGER
     +   I3C,I3N
C
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION BW
C        THE BANDWIDTH.
C     DOUBLE PRECISION CCOV(ICCOV,JCCOV,M)
C        THE COVARIANCES.
C     DOUBLE PRECISION CEVEN(LAGMX1)
C        THE SUMS OF THE COVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CODD(LAGMX1)
C        THE DIFFERENCES OF THE COVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CSPC2(ICSPC2,NW)
C        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DF
C        THE EFFECTIVE DEGREES OF FREEDOM.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FMN, FMX
C        *
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER INDEX1, INDEX2
C        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
C     INTEGER INLPPC
C        THE FIRST DIMENSION OF THE ARRAY NLPPC.
C     INTEGER IPHAS
C        THE FIRST DIMENSION OF THE ARRAY PHAS.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER ILOG
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        ILOG = 0 THE PLOT IS LINEAR/LINEAR, IF
C        ILOG = 1 THE PLOT IS LOG/LINEAR, IF
C     INTEGER ISPCER
C        AN ERROR FLAG USED FOR THE SPECTRUM PLOTS.
C     INTEGER ISYM(LPCV)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER I3C
C        STATEMENT FUNCTION FOR FINDING LOCATIONS WITHIN CCOV.
C     INTEGER I3N
C        STATEMENT FUNCTION FOR FINDING LOCATIONS WITHIN NLPPC.
C     INTEGER JCCOV
C        THE SECOND DIMENSION OF CCOV
C     INTEGER JNLPPC
C        THE SECOND DIMENSION OF NLPPC
C     INTEGER LAG
C        THE LAG WINDWO TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
C     INTEGER LAGLST
C        THE LAST LAG BEFORE MISSING DATA CAUSED AN ACVF
C        TO BE UNABLE TO BE COMPUTED.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGMX1
C        THE VALUE LAGMAX+1.
C     INTEGER LAGS(NW)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LY
C        THE LENGTH OF THE VECTORS Y1 AND Y2.
C     INTEGER M
C        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE COMPUTED
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     LOGICAL NEWPG
C        THE LOGICAL VARIABLE USED TO DETERMINE IF OUTPUT
C        WILL BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     INTEGER NFUSED
C        THE NUMBER OF FREQUENCIES ACTUALLY USED.
C     INTEGER NLPPC(INLPPC,JNLPPC,M)
C         THE ARRAY CONTAINING THE NUMBER OF LAG PRODUCT PAIRS.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT.
C        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        IF NPRT = 0 THE PLOT IS SUPPRESSED.
C        IF NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NPTS
C        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
C     INTEGER NW
C        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     INTEGER NWUSED
C        THE NUMBER OF DIFFERENT BANDWIDTHS ACTUALLY USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     DOUBLE PRECISION PHAS(IPHAS,NW)
C        THE PHASE COMPONENT OF THE BIVARIATE SPECTRUM.
C     DOUBLE PRECISION SPCF1(NF), SPCF2(NF)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     LOGICAL UNIVAR
C        THE LOGICAL VARIABLE USED TO DETERMINE IF THE OUTPUT
C        IS FOR UNIVARIATE (TRUE) OR BIVARIATE (FALSE) SPECTRA.
C     DOUBLE PRECISION W(LW)
C        THE VECTOR OF WINDOWS.
C     EXTERNAL WINDOW
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION WORK(LWORK)
C        THE VECTOR OF WORK SPACE.
C     DOUBLE PRECISION XAXIS(LPCV)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION XPLTMN, XPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
C     DOUBLE PRECISION YAXIS(LPCV)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YMEAN1, YMEAN2
C        THE MEAN OF THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YMISS1, YMISS2
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
C        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
C        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
C     DOUBLE PRECISION YPLTMN, YPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
C     DOUBLE PRECISION Y1(N), Y2(N)
C         THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C
C
C  STATEMENT FUNCTION DEFINITIONS
C
      I3C(I,J,K) = I + (J-1)*ICCOV + (K-1)*JCCOV*ICCOV
      I3N(I,J,K) = I + (J-1)*INLPPC + (K-1)*JNLPPC*INLPPC
C
      NFUSED = NF
      IF (OPTION(4)) THEN
        FMN = MAX(FMIN, 0.0D0)
        FMX = MIN(FMAX, 0.5D0)
        IF (FMN.GE.FMX) THEN
          FMN = 0.0D0
          FMX = 0.5D0
        END IF
      ELSE
C
C       SET VARIOUS VALUES FOR SHORT FORMS OF CALL STATEMENT
C
        NPRT = -1
        FMN = 0.0D0
        FMX = 0.5D0
        LAGMX1 = LAGMAX + 1
      END IF
C
C     CHECK FOR ERRORS
C
      CALL BFSER(NMSUB, N, LAGMAX, ICCOV, JCCOV, INLPPC, JNLPPC, M,
     +           INDEX1, INDEX2, ICSPC2, IPHAS, NF, NW, LAGS,
     +           LDSTAK, LDSMIN, LY, NFFT, OPTION)
C
      IF (IERR.EQ.1) RETURN
C
C     SET VARIOUS PROGRAM PARAMETERS.
C
      ALPHA = 0.95D0
      DELTA = 1.0D0
C
C     COMPUTE COVARIANCES
C
      LAGLST = LAGMAX
      IF (OPTION(1)) THEN
        CALL ACVFF(Y1, N, NFFT, YMEAN1,
     +             CCOV(I3C(1,INDEX1,INDEX1)),
     +             LAGMAX, ICCOV, N, WORK, NFFT)
        CALL ACVFF(Y2, N, NFFT, YMEAN2,
     +             CCOV(I3C(1,INDEX2,INDEX2)),
     +             LAGMAX, ICCOV, N, WORK, NFFT)
        CALL CCVFF(Y1, Y2, N, NFFT, LAGMAX,
     +             CCOV(I3C(1,INDEX1,INDEX2)),
     +             CCOV(I3C(1,INDEX2,INDEX1)), ICCOV, N, WORK, LWORK)
C
      ELSE
        IF (OPTION(3)) THEN
          IF (OPTION(2)) LAGLST = LSTLAG(NLPPC,LAGMAX,INLPPC)
        ELSE
          IF (OPTION(2)) THEN
            CALL ACVFM(Y1, YMISS1, N, YMEAN1,
     +                 CCOV(I3C(1,INDEX1,INDEX1)),
     +                 LAGMAX, LAGLST, NLPPC, ICCOV)
            CALL ACVFM(Y2, YMISS2, N, YMEAN2,
     +                 CCOV(I3C(1,INDEX2,INDEX2)),
     +                 LAGMAX, LAGLST, NLPPC, ICCOV)
            CALL CCVFM(Y1, YMISS1, Y2, YMISS2, N, LAGMAX, YMEAN1,
     +                 YMEAN2, CCOV(I3C(1,INDEX1,INDEX2)),
     +                 CCOV(I3C(1,INDEX2,INDEX1)), ICCOV,
     +                 NLPPC(I3N(1,INDEX1,INDEX2)),
     +                 NLPPC(I3N(1,INDEX2,INDEX1)))
C
          ELSE
            CALL ACVF(Y1, N, YMEAN1, CCOV(I3C(1,INDEX1,INDEX1)), LAGMAX,
     +                ICCOV)
            CALL ACVF(Y2, N, YMEAN2, CCOV(I3C(1,INDEX2,INDEX2)), LAGMAX,
     +                ICCOV)
            CALL CCVF(Y1, Y2, N, LAGMAX, YMEAN1, YMEAN2,
     +                CCOV(I3C(1,INDEX1,INDEX2)),
     +                CCOV(I3C(1,INDEX2,INDEX1)), ICCOV)
          END IF
        END IF
      END IF
C
      IF (LAGLST.LE.0) THEN
C
C     AN ERROR HAS BEEN DETECTED
C
         IERR = 2
         RETURN
      END IF
C
C     COMPUTE THE VECTOR OF LAG WINDOW TRUNCATION POINTS, ORDERED
C     SMALLEST TO LARGEST.
C
      NWUSED = NW
      IF (.NOT.OPTION(4)) CALL BFSLAG(CCOV, LAGLST, LAGS, N, NW, NWUSED,
     +                                ICCOV, JCCOV, INDEX1, INDEX2)
C
C     BEGIN COMPUTING FOURIER SPECTRUM FOR SERIES
C
      UNIVAR = .FALSE.
C
      ILOG = 0
C
      XPLTMN = FMN
      XPLTMX = FMX
C
      YPLTMN = 0.0D0
      YPLTMX = 1.0D0
C
C     SET FREQUENCIES FOR THE SPECTRUM.
C
      CALL SETFRQ(FREQ, NF, 1, FMN, FMX, DELTA)
C
C     COMPUTE AND PLOT SPECTRUM VALUES.
C
      NEWPG = .FALSE.
C
C     COMPUTE THE EVEN AND ODD CCVF ESTIMATES
C
      CEVEN(1) = CCOV(I3C(1,INDEX1,INDEX2))
      CODD(1) = 0.0D0
      DO 30 I=1,LAGLST
         CEVEN(I+1) = 0.5D0*
     +                (CCOV(I3C(I+1,INDEX1,INDEX2))+
     +                 CCOV(I3C(I+1,INDEX2,INDEX1)))
         CODD(I+1) = 0.5D0*
     +               (CCOV(I3C(I+1,INDEX1,INDEX2))-
     +                CCOV(I3C(I+1,INDEX2,INDEX1)))
   30 CONTINUE
C
      DO 60 I=1,NWUSED
         LAG = LAGS(I)
         IF (LAG.GT.LAGLST) THEN
            ISPCER = 2
            DF = 0.0D0
         ELSE
C
            ISPCER = 0
C
C     COMPUTE THE WINDOW, AND EFFECTIVE DEGREES OF FREEDOM AND
C     BANDWIDTH BASED ON THE WINDOW
C
            CALL WINDOW(LAG, W, LW)
            IF (OPTION(2)) THEN
               CALL DFBWM(N, LAG, W, LW, NLPPC(I3N(1,INDEX1,INDEX2)),
     +                    NLPPC(I3N(1,INDEX2,INDEX1)), INLPPC, DF, BW)
            ELSE
               CALL DFBW(N, LAG, W, LW, DF, BW)
            END IF
C
C     COMPUTE THE SPECTRUM FOR EACH INDIVIDUAL SERIES
C
            CALL UFSEST(CCOV(I3C(1,INDEX1,INDEX1)), W, LAG, SPCF1,
     +                  NFUSED, ICCOV, LAGMAX, NF, FREQ, DELTA)
C
            CALL UFSEST(CCOV(I3C(1,INDEX2,INDEX2)), W, LAG, SPCF2,
     +                  NFUSED, ICCOV, LAGMAX, NF, FREQ, DELTA)
C
            CALL BFSMN(SPCF1, SPCF2, CEVEN, CODD, W, LW, LAG, DF, NPRT,
     +                 NF, CSPC2(1+(I-1)*ICSPC2), PHAS(1+(I-1)*IPHAS),
     +                 FREQ, NPTS, XAXIS,
     +                 YAXIS, ISYM, LPCV, ALPHA, LAGMX1, DELTA)
C
            IF (NPRT.EQ.0) GO TO 60
C
         END IF
         CALL UFSOUT(XAXIS, YAXIS, ISYM, NPTS, BW, INT(DF+0.5D0), LAG,
     +               LAGMAX, NEWPG, ISPCER, NFUSED+5, XPLTMN, XPLTMX,
     +               YPLTMN, YPLTMX, ILOG, PHAS(1+(I-1)*IPHAS), FREQ,
     +               NF, UNIVAR, NMSUB)
C
         NEWPG = .TRUE.
C
   60 CONTINUE
C
      RETURN
C
      END
*BFSER
      SUBROUTINE BFSER(NMSUB, N, LAGMAX, ICCOV, JCCOV, INLPPC, JNLPPC,
     +   M, INDEX1, INDEX2, ICSPC2, IPHAS, NF, NW, LAGS,
     +   LDSTAK, LDSMIN, LYFFT, NFFT, OPTION)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE ERROR CHECKING ROUTINE FOR THE TIME SERIES
C     FOURIER UNIVARIATE SPECTRUM ANALYSIS ROUTINES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,ICSPC2,INDEX1,INDEX2,INLPPC,IPHAS,JCCOV,JNLPPC,
     +   LAGMAX,LDSMIN,LDSTAK,LYFFT,M,N,NF,NFFT,NW
C
C  ARRAY ARGUMENTS
      INTEGER
     +   LAGS(*)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I,NV
      LOGICAL
     +   HEAD
C
C  LOCAL ARRAYS
      LOGICAL
     +   ERROR(30)
      CHARACTER
     +   L1(8)*1,LICCOV(8)*1,LICSPC(8)*1,LINDX1(8)*1,LINDX2(8)*1,
     +   LINLPP(8)*1,LIPHAS(8)*1,LJCCOV(8)*1,LJNLPP(8)*1,
     +   LLAGMX(8)*1,LLAGS(8)*1,LLDS(8)*1,LLGMX1(8)*1,
     +   LLYFFT(8)*1,LM(8)*1,LN(8)*1,LNF(8)*1,LNM1(8)*1,LNW(8)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,EISLE,EIVII
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR(30)
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX VALUE.
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER ICSPC2
C        THE FIRST DIMENSION OF THE ARRAY CSPC2.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF ERR01, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER INDEX1, INDEX2
C        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
C     INTEGER INLPPC
C        THE FIRST DIMENSION OF THE ARRAY NLPPC.
C     INTEGER IPHAS
C        THE FIRST DIMENSION OF THE ARRAY PHAS.
C     INTEGER JCCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER JNLPPC
C        THE FIRST DIMENSION OF THE ARRAY NLPPC.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGS(NW)
C        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     CHARACTER*1 LICCOV(8), LICSPC(8), LINDX1(8),
C    *   LINDX2(8), LINLPP(8), LIPHAS(8), LJCCOV(8), LJNLPP(8),
C    *   LLAGMX(8), LLAGS(8), LLDS(8), LLGMX1(8), LLYFFT(8), LM(8),
C    *   LN(8), LNF(8), LNM1(8), LNW(8), L1(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE ARGUMENT(S)
C        CHECKED FOR ERRORS.
C     INTEGER LYFFT
C        THE LENGTH OF VECTOR YFFT.
C     INTEGER M
C        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
C        COMPUTED
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THE USER CALLED SUBROUTINE.
C     INTEGER NV
C        THE NUMBER OF VIOLATIONS FOUND WHEN CHECKING VECTOR LAGS.
C     INTEGER NW
C        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C
C     SET UP NAME ARRAYS
C
      DATA LICCOV(1), LICCOV(2), LICCOV(3), LICCOV(4), LICCOV(5),
     +   LICCOV(6), LICCOV(7), LICCOV(8) /'I','C','C','O','V',' ',' ',
     +   ' '/
      DATA LICSPC(1), LICSPC(2), LICSPC(3), LICSPC(4), LICSPC(5),
     +   LICSPC(6), LICSPC(7), LICSPC(8) /'I','C','S','P','C','2',' ',
     +   ' '/
      DATA LINDX1(1), LINDX1(2), LINDX1(3), LINDX1(4), LINDX1(5),
     +   LINDX1(6), LINDX1(7), LINDX1(8) /'I','N','D','E','X','1',' ',
     +   ' '/
      DATA LINDX2(1), LINDX2(2), LINDX2(3), LINDX2(4), LINDX2(5),
     +   LINDX2(6), LINDX2(7), LINDX2(8) /'I','N','D','E','X','2',' ',
     +   ' '/
      DATA LIPHAS(1), LIPHAS(2), LIPHAS(3), LIPHAS(4), LIPHAS(5),
     +   LIPHAS(6), LIPHAS(7), LIPHAS(8) /'I','P','H','A','S',' ',' ',
     +   ' '/
      DATA LINLPP(1), LINLPP(2), LINLPP(3), LINLPP(4), LINLPP(5),
     +   LINLPP(6), LINLPP(7), LINLPP(8) /'I','N','L','P','P','C',' ',
     +   ' '/
      DATA LJCCOV(1), LJCCOV(2), LJCCOV(3), LJCCOV(4), LJCCOV(5),
     +   LJCCOV(6), LJCCOV(7), LJCCOV(8) /'J','C','C','O','V',' ',' ',
     +   ' '/
      DATA LJNLPP(1), LJNLPP(2), LJNLPP(3), LJNLPP(4), LJNLPP(5),
     +   LJNLPP(6), LJNLPP(7), LJNLPP(8) /'J','N','L','P','P','C',' ',
     +   ' '/
      DATA LLAGMX(1), LLAGMX(2), LLAGMX(3), LLAGMX(4), LLAGMX(5),
     +   LLAGMX(6), LLAGMX(7), LLAGMX(8) /'L','A','G','M','A','X',' ',
     +   ' '/
      DATA LLAGS(1), LLAGS(2), LLAGS(3), LLAGS(4), LLAGS(5), LLAGS(6),
     +   LLAGS(7), LLAGS(8) /'L','A','G','S',' ',' ',' ',' '/
      DATA LLGMX1(1), LLGMX1(2), LLGMX1(3), LLGMX1(4), LLGMX1(5),
     +   LLGMX1(6), LLGMX1(7), LLGMX1(8) /'L','A','G','M','A','X','+',
     +   '1'/
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +   LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8) /'N',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LM(1), LM(2), LM(3), LM(4), LM(5), LM(6), LM(7), LM(8) /'M',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LNF(1), LNF(2), LNF(3), LNF(4), LNF(5), LNF(6), LNF(7),
     +   LNF(8) /'N','F',' ',' ',' ',' ',' ',' '/
      DATA LNM1(1), LNM1(2), LNM1(3), LNM1(4), LNM1(5), LNM1(6),
     +   LNM1(7), LNM1(8) /'N','-','1',' ',' ',' ',' ',' '/
      DATA LNW(1), LNW(2), LNW(3), LNW(4), LNW(5), LNW(6), LNW(7),
     +   LNW(8) /'N','W',' ',' ',' ',' ',' ',' '/
      DATA LLYFFT(1), LLYFFT(2), LLYFFT(3), LLYFFT(4), LLYFFT(5),
     +   LLYFFT(6), LLYFFT(7), LLYFFT(8) /'L','Y','F','F','T',' ',' ',
     +   ' '/
      DATA L1(1), L1(2), L1(3), L1(4), L1(5), L1(6), L1(7), L1(8) /'1',
     +   ' ',' ',' ',' ',' ',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
      DO 10 I=1,30
         ERROR(I) = .FALSE.
   10 CONTINUE
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERROR(1), LN)
C
      IF ((.NOT.OPTION(3))) GO TO 20
C
      CALL EISII(NMSUB, LLAGMX, LAGMAX, 1, N-1, 1, HEAD, ERROR(2), L1,
     +   LNM1)
C
      CALL EISGE(NMSUB, LM, M, 2, 1, HEAD, ERROR(3), LM)
C
      CALL EISGE(NMSUB, LICCOV, ICCOV, LAGMAX+1, 3, HEAD, ERROR(4),
     +   LLGMX1)
C
      CALL EISGE(NMSUB, LJCCOV, JCCOV, M, 4, HEAD, ERROR(5), LM)
C
      IF (OPTION(2)) THEN
        CALL EISGE(NMSUB, LINLPP, INLPPC, LAGMAX+1, 3, HEAD, ERROR(6),
     +     LLGMX1)
C
        CALL EISGE(NMSUB, LJNLPP, JNLPPC, M, 4, HEAD, ERROR(7), LM)
      END IF
C
      CALL EISLE(NMSUB, LINDX1, INDEX1, M, 2, HEAD, ERROR(8), LM)
C
      CALL EISLE(NMSUB, LINDX2, INDEX2, M, 2, HEAD, ERROR(9), LM)
C
   20 CALL EISGE(NMSUB, LLYFFT, LYFFT, NFFT, 9, HEAD, ERROR(10), LLYFFT)
C
      IF (OPTION(1) .AND. (.NOT.OPTION(4))) CALL EISGE(NMSUB, LLDS,
     +   LDSTAK, LDSMIN, 9, HEAD, ERROR(15), LLDS)
C
      IF (OPTION(4)) GO TO 40
C
      DO 30 I=1,15
         IF (ERROR(I)) GO TO 70
   30 CONTINUE
C
      RETURN
C
   40 CONTINUE
C
      CALL EISGE(NMSUB, LNF, NF, 1, 1, HEAD, ERROR(16), LNF)
C
      CALL EISGE(NMSUB, LNW, NW, 1, 1, HEAD, ERROR(18), LNW)
C
      IF (ERROR(18)) GO TO 50
      IF (OPTION(3)) THEN
         CALL EIVII(NMSUB, LLAGS, LAGS, NW, 1, LAGMAX, 0,
     +      HEAD, 4, NV, ERROR(19), L1, LLAGMX)
      ELSE
         CALL EIVII(NMSUB, LLAGS, LAGS, NW, 1, N-1, 0,
     +      HEAD, 4, NV, ERROR(19), L1, LNM1)
      END IF
C
   50 CONTINUE
C
      CALL EISGE(NMSUB, LICSPC, ICSPC2, NF, 3, HEAD, ERROR(24), LNF)
C
      CALL EISGE(NMSUB, LIPHAS, IPHAS, NF, 3, HEAD, ERROR(25), LNF)
C
      IF (ERROR(2) .OR. ERROR(16) .OR. ERROR(18) .OR. ERROR(19)) GO TO
     +   70
C
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR(30), LLDS)
C
      DO 60 I=1,30
         IF (ERROR(I)) GO TO 70
   60 CONTINUE
C
      RETURN
C
   70 CONTINUE
      IERR = 1
      RETURN
C
      END
*BFSF
      SUBROUTINE BFSF(YFFT1, YFFT2, N, LYFFT, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
C     BIVARIATE SPECTRUM ANALYSIS (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,LYFFT,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YFFT1(*),YFFT2(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS1,YMISS2
      INTEGER
     +   ICCOV,ICSPC2,IFP,INDEX1,INDEX2,INLPPC,IPHAS,IPRT,JCCOV,
     +   JNLPPC,LAGMAX,LAGMX1,LDSMIN,LPCV,LW,LWORK,M,NALL0,NF,NFFT,
     +   NPRT,NW,WORK
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCOV(101,2,2),CEVEN(101),CODD(101),CSPC2(101,4),FREQ(101),
     +   PHAS(101,4),RSTAK(12),SPCF1(101),SPCF2(101),W(101),
     +   XAXIS(404),YAXIS(404)
      INTEGER
     +   ISYM(404),LAGS(4),NLPPC(1,1,1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,IPRINT,LDSCMP,PARZEN,SETESL,SETLAG,STKSET
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION CCOV(101,2,2)
C        THE COVARIANCES.
C     DOUBLE PRECISION CEVEN(101)
C        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CODD(101)
C        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CSPC2(101,4)
C        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(101)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER ICSPC2
C        THE FIRST DIMENSION OF THE ARRAY CSPC2.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION
C     INTEGER INDEX1, INDEX2
C        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
C     INTEGER INLPPC
C        THE FIRST DIMENSION OF THE ARRAY NLPPC.
C     INTEGER IPHAS
C        THE FIRST DIMENSION OF THE ARRAY PHAS.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISYM(404)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER JCCOV
C        THE SECOND DIMENSION OF THE ARRAY CCOV.
C     INTEGER JNLPPC
C        THE SECOND DIMENSION OF THE ARRAY NLPPC.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGMX1
C        LAGMAX+1.
C     INTEGER LAGS(4)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LW
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR WORK.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTORS Y1 AND YFFT1 AND YFFT2
C     INTEGER M
C        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
C        COMPUTED
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NALL0
C        THE NUMBER OF STACK ALLOCATIONS ON ENTRY
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     INTEGER NLPPC(1,1,1)
C        A DUMMY ARRAY.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT.
C        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        IF NPRT = 0 THE PLOT IS SUPPRESSED.
C        IF NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION PHAS(101,4)
C        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION SPCF1(101), SPCF2(101)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     DOUBLE PRECISION W(101)
C        THE WINDOWS.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE WORK VECTOR
C     DOUBLE PRECISION XAXIS(404)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YAXIS(404)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YMISS1, YMISS2
C        DUMMY VARIABLES.
C     DOUBLE PRECISION YFFT1(LYFFT)
C        THE FIRST TIME SERIES.
C     DOUBLE PRECISION YFFT2(LYFFT)
C        THE SECOND TIME SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','F',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(1) = .TRUE.
      OPTION(2) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(4) = .FALSE.
C
      ICCOV = 101
      JCCOV = 2
      M = 2
      INDEX1 = 1
      INDEX2 = 2
C
      ICSPC2 = 101
      IPHAS = 101
C
      LDSMIN = 0
C
      NF = 101
      YMISS1 = 1.0D0
      YMISS2 = 1.0D0
      INLPPC = 1
      JNLPPC = 1
      LW = 101
      LPCV = 404
C
C     SET MAXIMUM LAG VALUE (LAGMAX)
C     SET NUMBER OF LAG WINDOW TRUCCATION POINTS (NW)
C     SET EXTENDED SERIES LENGTH (NFFT)
C
      CALL SETLAG(N, LAGMAX)
      NW = 4
      CALL SETESL(N+LAGMAX, 4, NFFT)
C
C     COMPUTE MINIMUM ALLOWABLE STACK LENGTH (LDSMIN)
C
      CALL LDSCMP(1, 0, 0, 0, 0, 0, 'D', NFFT, LDSMIN)
C
C     SET SIZE OF WORK AREA
C     SET NUMBER OF OUTSTANDING ALLOCATIONS (NALL0)
C     SET THE STACK ALLOCATION TYPE (IFP)
C
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
C
      IFP = 4
C
C     SET THE STARTING LOCATIONS INTHE WORK AREA FOR VARIOUS ARRAYS
C
      IF ((LDSMIN.LE.LDSTAK) .AND. (LDSMIN.GE.7)) THEN
         WORK = STKGET(NFFT,IFP)
         LWORK = NFFT
      ELSE
         WORK = 1
         LWORK = 1
      END IF
C
C     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
C
      CALL BFSDRV(YFFT1, YFFT2, YMISS1, YMISS2, CCOV, NLPPC, SPCF1,
     +            SPCF2, NF, FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS,
     +            LAGMX1, RSTAK(WORK), LWORK, DELTA, ISYM, XAXIS,
     +            YAXIS, LPCV, ALPHA, NPRT, PARZEN, ICCOV, JCCOV, M,
     +            INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS, CODD,
     +            CEVEN, W, LW, NMSUB, LDSMIN, LDSTAK, OPTION, NFFT,
     +            INLPPC, JNLPPC, LYFFT)
C
      IF (IERR.EQ.0) RETURN
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL BFSF (YFFT1, YFFT2, N, LYFFT, LDSTAK)')
      END
*BFSFS
      SUBROUTINE BFSFS(YFFT1, YFFT2, N, LYFFT, LDSTAK, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
C     BIVARIATE SPECTRUM ANALYSIS (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   ICSPC2,IPHAS,LDSTAK,LYFFT,N,NF,NPRT,NW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CSPC2(*),FREQ(*),PHAS(*),YFFT1(*),YFFT2(*)
      INTEGER
     +   LAGS(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,YMISS1,YMISS2
      INTEGER
     +   CCOV,CCOV11,CCOV12,CCOV21,CCOV22,CEVEN,CODD,I,ICCOV,IFP,
     +   INDEX1,INDEX2,INLPPC,IO,IPRT,ISYM,JCCOV,JNLPPC,LAGMAX,
     +   LAGMX1,LDSMIN,LPCV,LW,LWORK,M,NALL0,NFFT,SPCF1,SPCF2,W,
     +   WORK,XAXIS,YAXIS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12),NLPPC(1,1,1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,IPRINT,LDSCMP,PARZEN,SETESL,STKCLR,STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     INTEGER CCOV, CCOV11, CCOV12, CCOV21, CCOV22
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE COVARIANCES.
C     INTEGER CEVEN
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
C     INTEGER CODD
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CSPC2(ICSPC2,NW)
C        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER I
C        AN INDEX VALUE.
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER ICSPC2
C        THE FIRST DIMENSION OF THE ARRAY CSPC2.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER INDEX1, INDEX2
C        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
C        BASED ON PRINTED OUTPUT REQUESTED.
C     INTEGER IPHAS
C        THE FIRST DIMENSION OF THE ARRAY PHAS.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISYM
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER JCCOV
C        THE SECOND DIMENSION OF THE ARRAY CCOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGMX1
C        LAGMAX+1.
C     INTEGER LAGS(NW)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LW
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR WORK.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTORS Y1 AND Y2.
C     INTEGER M
C        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
C        COMPUTED
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NALL0
C        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     INTEGER NLPPC(1,1,1)
C        A DUMMY ARRAY.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT.
C        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        IF NPRT = 0 THE PLOT IS SUPPRESSED.
C        IF NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION PHAS(IPHAS,NW)
C        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER SPCF1, SPCF2
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     INTEGER W
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE WINDOWS.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE WORK AREA FOR THE VECTOR WORK.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YMISS1, YMISS2
C        DUMMY VARIABLES.
C     DOUBLE PRECISION YFFT1(LYFFT)
C        THE FIRST TIME SERIES.
C     DOUBLE PRECISION YFFT2(LYFFT)
C        THE SECOND TIME SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','F','S',' '/
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(4) = .TRUE.
C
C     SET MAXIMUM LAG VALUE TO BE USED.
C
      IF (NW.GE.1) THEN
         LAGMAX = LAGS(1)
         DO 10 I=2,NW
            LAGMAX = MAX(LAGMAX,LAGS(I))
   10    CONTINUE
      ELSE
         LAGMAX = N - 1
      END IF
      LAGMX1 = LAGMAX + 1
      CALL SETESL(N+LAGMAX, 4, NFFT)
C
      ICCOV = LAGMAX + 1
      JCCOV = 2
      INLPPC = 1
      JNLPPC = 1
      M = 2
      INDEX1 = 1
      INDEX2 = 2
C
C     COMPUTE THE MINIMUM ALLOWABLE STACK AREA
C
      IF (NPRT.EQ.0) THEN
         IO = 0
      ELSE
         IO = 1
      END IF
C
      CALL LDSCMP(9, 0, IO*4*NF, 0, 0, 0, 'D',
     +            6*LAGMAX+6+NFFT+IO*8*NF, LDSMIN)
C
      YMISS1 = 1.0D0
      YMISS2 = 1.0D0
      LPCV = 4*NF
      LW = NFFT
C
C     SET SIZE OF WORK AREA.
C     SET THE NUMBER OF OUTSTANDING STACK ALLOCATIONS (NALL0)
C     SET THE STACK ALLOCATION TYPE (IFP)
C
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
C
      IFP = 4
C
C     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS
C
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         CCOV = 1
         CEVEN = 1
         CODD = 1
         SPCF1 = 1
         SPCF2 = 1
         W = 1
C
         CCOV11 = 1
         CCOV21 = 1
         CCOV12 = 1
         CCOV22 = 1
C
         ISYM = 1
         XAXIS = 1
         YAXIS = 1
      ELSE
         CCOV = STKGET(4*LAGMX1,IFP)
         CEVEN = STKGET(LAGMX1,IFP)
         CODD = STKGET(LAGMX1,IFP)
         SPCF1 = STKGET(NF,IFP)
         SPCF2 = STKGET(NF,IFP)
         W = STKGET(LW,IFP)
C
         CCOV11 = CCOV
         CCOV21 = CCOV + LAGMX1
         CCOV12 = CCOV21 + LAGMX1
         CCOV22 = CCOV12 + LAGMX1
C
         IF (NPRT.EQ.0) THEN
            ISYM = W
            XAXIS = W
            YAXIS = W
         ELSE
            ISYM = STKGET(LPCV,2)
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
         END IF
      END IF
C
      WORK = W
      LWORK = LW
C
C     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
C
      CALL BFSDRV(YFFT1, YFFT2, YMISS1, YMISS2, RSTAK(CCOV), NLPPC,
     +   RSTAK(SPCF1), RSTAK(SPCF2), NF, FMIN, FMAX, FREQ, N, NW,
     +   LAGMAX, LAGS, LAGMX1, RSTAK(WORK), LWORK, DELTA, ISTAK(ISYM),
     +   RSTAK(XAXIS), RSTAK(YAXIS), LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS,
     +   RSTAK(CODD), RSTAK(CEVEN), RSTAK(W), LW, NMSUB, LDSMIN,
     +   LDSTAK, OPTION, NFFT, INLPPC, JNLPPC, LYFFT)
C
      CALL STKCLR(NALL0)
C
C     CHECK FOR ERRORS
C
      IF (IERR.EQ.0) RETURN
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL BFSFS (YFFT1, YFFT2, N, LYFFT, LDSTAK,'/
     +   '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +   '      +            CSPC2, ICSPC2, PHAS, IPHAS, FREQ)')
      END
*BFSLAG
      SUBROUTINE BFSLAG(CCOV, LAGMAX, LAGS, N, NW, NWUSED, ICCOV,
     +   JCCOV, INDEX1, INDEX2)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE LAG WINDOW TRUNCATION POINTS FOR
C     FOURIER BIVARIATE SPECTRUM ANALYSIS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,INDEX1,INDEX2,JCCOV,LAGMAX,N,NW,NWUSED
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(ICCOV,JCCOV,*)
      INTEGER
     +   LAGS(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   COVMX,COVMXI,FAC11,FAC12,FAC21,FAC22,P95LIM
      INTEGER
     +   I,J,K,LAG,NWM1
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,DBLE,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCOV(ICCOV,JCCOV,*)
C        THE COVARIANCES.
C     DOUBLE PRECISION COVMX
C        THE MAXIMUM COVARIANCE VALUE.
C     DOUBLE PRECISION COVMXI
C        THE MAXIMUM COVARIANCE VALUE FOR THE ITH LAG.
C     DOUBLE PRECISION FAC11, FAC12, FAC21, FAC22
C        FACTORS USED TO COMPUTE THE CORRELATION COEFFICIENTS.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER INDEX1, INDEX2
C        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
C     INTEGER J
C        AN INDEX VALUE.
C     INTEGER JCCOV
C        THE SECOND DIMENSION OF THE ARRAY CCOV.
C     INTEGER K
C        AN INDEX VALUE.
C     INTEGER LAG, LAGMAX
C        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
C        BIVARIATE COVARIANCE BEING COMPUTED AND THE MAXIMUM LAG
C        TO BE USED, RESPECTIVELY.
C     INTEGER LAGS(NW)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NW
C        THE NUMBER OF DIFFERENT BANDWIDTHS REQUESTED.
C     INTEGER NWM1, NWUSED
C        THE NUMBER OF DIFFERENT BANDWIDTHS MINUS 1, AND THE
C        ACTUAL NUMBER OF BANDWIDTHS ACTUALLY USED.
C     DOUBLE PRECISION P95LIM
C        THE 95 PERCENT CONFIDENT LIMIT FOR WHITE NOISE.
C
      LAGS(NW) = LAGMAX
      IF (LAGS(NW).LE.32) GO TO 30
C
C     COMPUTE 95 PERCENT CONFIDENCE LIMITS ON BIVARIATECOVARIANCES,
C     ASSUMING WHITE NOISE.
C
      P95LIM = 1.96D0/SQRT(DBLE(N))
C
      FAC11 = CCOV(1,INDEX1,INDEX1)
      FAC12 = SQRT(CCOV(1,INDEX1,INDEX1)*CCOV(1,INDEX2,INDEX2))
      FAC21 = FAC12
      FAC22 = CCOV(1,INDEX2,INDEX2)
C
C     CHECK FOR FIRST CVF EXCEEDING 95 PERCENT LIMIT ON WHITE NOISE
C
      DO 10 I=1,LAGMAX
         LAG = LAGMAX + 1 - I
         COVMXI = MAX(ABS(CCOV(LAG,INDEX1,INDEX1)*FAC11),ABS(CCOV(LAG,
     +      INDEX1,INDEX2)*FAC12),ABS(CCOV(LAG,INDEX2,INDEX1)*FAC21),
     +      ABS(CCOV(LAG,INDEX2,INDEX2)*FAC22))
         IF (COVMXI.GE.P95LIM) GO TO 30
         LAGS(NW) = LAGS(NW) - 1
   10 CONTINUE
C
C     IF NO ACVF EXCEEDS WHITE NOISE LIMITS, CHECK FOR LARGEST ACVF.
C
      LAGS(NW) = 1
      COVMX = ABS(CCOV(2,1,1)*FAC11)
      DO 20 LAG=1,LAGMAX
         COVMXI = MAX(ABS(CCOV(LAG,INDEX1,INDEX1)*FAC11),ABS(CCOV(LAG,
     +      INDEX1,INDEX2)*FAC12),ABS(CCOV(LAG,INDEX2,INDEX1)*FAC21),
     +      ABS(CCOV(LAG,INDEX2,INDEX2)*FAC22))
         IF (COVMXI.LE.COVMX) GO TO 20
         LAGS(NW) = LAG
         COVMX = COVMXI
   20 CONTINUE
C
C     COMPUTE LAG WINDOW TRUNCATION POINTS
C
   30 LAGS(NW) = LAGS(NW)*3.0D0/2.0D0
      IF (LAGS(NW).LT.32) LAGS(NW) = 32
      IF (LAGS(NW).GT.LAGMAX) LAGS(NW) = LAGMAX
      NWUSED = NW
      IF (NW.EQ.1) RETURN
      NWM1 = NW - 1
      DO 40 I=1,NWM1
         K = NW - I
         LAGS(K) = LAGS(K+1)/2
   40 CONTINUE
C
C     CHECK WHETHER ALL NW LAG WINDOW TRUNCATION POINTS CAN BE USED.
C
      NWUSED = NW
      IF (LAGS(1).GE.4) RETURN
C
C     RECONSTURCT -LAGS- VECTOR IF NOT ALL TRUNCATION POINTS ARE
C     TO BE USED
C
      DO 50 I=2,NW
         NWUSED = NWUSED - 1
         IF (LAGS(I).GE.4) GO TO 60
   50 CONTINUE
C
   60 DO 70 I=1,NWUSED
         J = NW - NWUSED + I
         LAGS(I) = LAGS(J)
   70 CONTINUE
C
      RETURN
      END
*BFSM
      SUBROUTINE BFSM(Y1, YMISS1, Y2, YMISS2, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
C     FOURIER SPECTRUM ANALYSIS OF SERIES WITH MISSING OBSERVATIONS
C     (SHORT CALL)
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMISS1,YMISS2
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y1(*),Y2(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN
      INTEGER
     +   ICCOV,ICSPC2,INDEX1,INDEX2,INLPPC,IPHAS,IPRT,JCCOV,JNLPPC,
     +   LAGMAX,LAGMX1,LDSMIN,LDSTAK,LPCV,LW,LY,M,NF,NPRT,NW
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCOV(101,2,2),CEVEN(101),CODD(101),CSPC2(101,4),FREQ(101),
     +   PHAS(101,4),SPCF1(101),SPCF2(101),W(101),XAXIS(404),
     +   YAXIS(404)
      INTEGER
     +   ISYM(404),LAGS(4),NLPPC(101,2,2)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,ECVF,IPRINT,PARZEN,SETLAG
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION CCOV(101,2,2)
C        THE COVARIANCES.
C     DOUBLE PRECISION CEVEN(101)
C        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CODD(101)
C        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CSPC2(101,4)
C        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(101)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER ICSPC2
C        THE FIRST DIMENSION OF THE ARRAY CSPC2.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER INDEX1, INDEX2
C        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
C     INTEGER INLPPC
C        THE FIRST DIMENSION OF THE ARRAY NLPPC.
C     INTEGER IPHAS
C        THE FIRST DIMENSION OF THE ARRAY PHAS.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISYM(404)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER JCCOV
C        THE SECOND DIMENSION OF THE ARRAY CCOV.
C     INTEGER JNLPPC
C        THE SECOND DIMENSION OF THE ARRAY NLPPC.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGMX1
C        LAGMAX+1.
C     INTEGER LAGS(4)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LW
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LY
C        THE LENGTH OF THE VECTORS Y1 AND Y2.
C     INTEGER M
C        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
C        COMPUTED
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPC(101,2,2)
C        THE NUMBER OF OBSERVATIONS IN EACH COVARIANCE ESTIMATE
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT.
C        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        IF NPRT = 0 THE PLOT IS SUPPRESSED.
C        IF NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION PHAS(101,4)
C        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION SPCF1(101), SPCF2(101)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     DOUBLE PRECISION W(101)
C        THE WINDOWS.
C     DOUBLE PRECISION XAXIS(404)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YAXIS(404)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YMISS1, YMISS2
C        THE MISSING VALUE CODES
C     DOUBLE PRECISION Y1(N)
C        THE FIRST TIME SERIES.
C     DOUBLE PRECISION Y2(N)
C        THE SECOND TIME SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','M',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(1) = .FALSE.
      OPTION(2) = .TRUE.
      OPTION(3) = .FALSE.
      OPTION(4) = .FALSE.
C
      ICCOV = 101
      JCCOV = 2
      M = 2
      INDEX1 = 1
      INDEX2 = 2
C
      ICSPC2 = 101
      IPHAS = 101
C
      LDSTAK = 0
      LDSMIN = 0
C
      NF = 101
      INLPPC = 101
      JNLPPC = 2
      LW = 101
      LY = N
      LPCV = 404
C
C     SET MAXIMUM LAG VALUE (LAGMAX)
C     SET NUMBER OF LAG WINDOW TRUCCATION POINTS (NW)
C
      CALL SETLAG(N, LAGMAX)
      NW = 4
C
C     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
C
      CALL BFSDRV(Y1, Y2, YMISS1, YMISS2, CCOV, NLPPC, SPCF1, SPCF2,
     +   NF, FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS, LAGMX1, W, LW,
     +   DELTA, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS, CODD,
     +   CEVEN, W, LW, NMSUB, LDSMIN, LDSTAK, OPTION, N, INLPPC,
     +   JNLPPC, LY)
C
      IF (IERR.NE.0) THEN
        IF (IERR.EQ.2) CALL ECVF(NMSUB)
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL BFSM (Y1, YMISS1, Y2, YMISS2, N)')
      END
*BFSMN
      SUBROUTINE BFSMN(SPCF1, SPCF2, CEVEN, CODD, W, LW, LAG, DF, NPRT,
     +   NF, CSPC2, PHAS, FREQ, NPTS, XAXIS, YAXIS, ISYM, LPCV, ALPHA,
     +   LAGMX1, DELTA)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE SQUARED COHERENCY AND PHASE COMPONENTS
C     OF A BIVARIATE SPECTRUM.
C
C     REFERENCE - JENKINS AND WATTS
C                 SPECTRAL ANALYSIS AND ITS APPLICATIONS
C
C     WRITTEN BY - STEPHEN M. KEEFER AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALPHA,DELTA,DF
      INTEGER
     +   LAG,LAGMX1,LPCV,LW,NF,NPRT,NPTS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CEVEN(*),CODD(*),CSPC2(*),FREQ(*),PHAS(*),SPCF1(*),SPCF2(*),
     +   W(*),XAXIS(*),YAXIS(*)
      INTEGER
     +   ISYM(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ARG,BARL,BARQ,BARY,C,CI,FAC,FPLM,FPLRS,FPSPM,G,PI,PIT2,SN,V0,
     +   V1,V2,Z0,Z1,Z2
      INTEGER
     +   I,K
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   PPFNML,D1MACH
      EXTERNAL PPFNML,D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ATAN2,COS,LOG,SIGN,SIN,SQRT,TANH
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION ARG
C        AN ARGUMENT USED IN THE SPECTRUM COMPUTATIONS.
C     DOUBLE PRECISION BARL
C        THE SMOOTHED COSPECTRAL ESTIMATES.
C     DOUBLE PRECISION BARQ
C        THE SMOOTHED QUADRATURE SPECTRAL ESTIMATES.
C     DOUBLE PRECISION BARY
C        A TRANSFORMATION OF THE SQUARED COHERENCY COMPONENT.
C     DOUBLE PRECISION C
C        AN ARGUMENT USED IN THE SPECTRUM COMPUTATIONS.
C     DOUBLE PRECISION CEVEN(LAGMX1)
C        THE SUMS OF THE COVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CI
C        THE CONFIDENCE INTERVAL FOR THE SQUARED COHERENCY COMPONENT.
C     DOUBLE PRECISION CODD(LAGMX1)
C        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CSPC2(NF)
C        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DF
C        THE EFFECTIVE DEGREES OF FREEDOM.
C     DOUBLE PRECISION FAC
C        THE CONVERSION FACTOR FROM RADIANS TO DEGREES.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     DOUBLE PRECISION FPLRS
C        THE FLOATING POINT LARGEST RELATIVE SPACING.
C     DOUBLE PRECISION FPSPM
C        THE FLOATING POINT SMALLEST POSITIVE MAGNITUDE.
C     DOUBLE PRECISION FREQ(NF)
C        THE FREQUENCIES AT WHICH THE SPECTRUM IS COMPUTED.
C     DOUBLE PRECISION G
C        AN ARGUMENT USED IN THE COMPUTATION OF THE ALPHA PERCENT
C        SIGNIFICANCE LEVEL.
C     INTEGER I
C        AN INDEX VALUE.
C     INTEGER ISYM(LPCV)
C        THE VECTOR CONTAINING THE CODES FOR THE PLOT SYMBOLS.
C     INTEGER K
C         AN INDEX VALUE.
C     INTEGER LAG
C        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
C     INTEGER LAGMX1
C        THE VALUE LAGMAX+1.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LW
C         THE LENGTH OF VECTOR W.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT.
C        IF NPRT = 0 THE PLOT IS SUPPRESSED.
C        IF NPRT = 2 THE PLOT IS PROVIDED.
C     INTEGER NPTS
C        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
C     DOUBLE PRECISION PHAS(NF)
C        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION PI, PIT2
C        THE VALUE OF PI AND PI*2.
C     DOUBLE PRECISION SN
C        AN ARGUMENT USED IN THE COMPUTATION OF THE SPECTRUM.
C     DOUBLE PRECISION SPCF1(NF), SPCF2(NF)
C        THE UNIVARIATE SPECTRUM FOR EACH SERIES.
C     DOUBLE PRECISION V0, V1, V2
C        ARGUMENTS USED IN THE COMPUTATION OF THE SPECTRUM.
C     DOUBLE PRECISION W(LW)
C        THE WINDOW.
C     DOUBLE PRECISION XAXIS(LPCV)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YAXIS(LPCV)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION Z0, Z1, Z2
C        ARGUMENTS USED IN THE COMPUTATION OF THE SPECTRUM.
C
C
      CALL GETPI(PI)
      PIT2 = PI*2.0D0
C
      FPSPM = D1MACH(1)
      FPLM = D1MACH(2)
      FPLRS = D1MACH(4)
C
      FAC = 180.0D0/PI
C
C
C     COMPUTE SMOOTHED CO-SPECTRAL ESTIMATE
C
      DO 40 I=1,NF
C
C           COMPUTE SMOOTHED CO- AND QUADRATURE SPECTRA USING
C           THE ALGORITHM SHOWN ON PAGE 420 OF JENKINS AND WATTS
C
         IF (FREQ(I).EQ.0.0D0) THEN
            C = 1.0D0
            SN = 0.0D0
         ELSE IF (FREQ(I).EQ.0.25D0) THEN
            C = 0.0D0
            SN = 1.0D0
         ELSE IF (FREQ(I).EQ.0.5D0) THEN
            C = -1.0D0
            SN = 0.0
         ELSE
            ARG = PIT2*FREQ(I)
            C = COS(ARG)
            SN = SIN(ARG)
         END IF
         V0 = 0.0D0
         V1 = 0.0D0
         Z0 = 0.0D0
         Z1 = 0.0D0
         DO 10 K=LAG-1,1,-1
            V2 = 2.0D0*C*V1 - V0 + W(K+1)*CEVEN(K+1)
            Z2 = 2.0D0*C*Z1 - Z0 + W(K+1)*CODD(K+1)
            V0 = V1
            V1 = V2
            Z0 = Z1
            Z1 = Z2
   10    CONTINUE
         BARL = DELTA*(CEVEN(1)+2.0D0*(V1*C-V0))
         BARQ = 2.0D0*DELTA*Z1*SN
C
C     COMPUTE THE SMOOTHED SQUARED COHERENCY SPECTRA
C
         IF (SPCF1(I)*SPCF2(I).GT.0.0D0) THEN
            CSPC2(I) = (BARL*BARL+BARQ*BARQ)
            CSPC2(I) = CSPC2(I)/(SPCF1(I)*SPCF2(I))
         ELSE
            CSPC2(I) = FPLM
         END IF
C
C     COMPUTE PHASE (IN RADIANS)
C
         IF ((BARQ.NE.0.0D0) .OR. (BARL.NE.0.0D0)) THEN
            PHAS(I) = ATAN2(-BARQ,BARL)
         ELSE
            IF (I.EQ.1) THEN
               PHAS(I) = 0.0D0
            ELSE
               PHAS(I) = SIGN(PI,PHAS(I-1))
            END IF
         END IF
   40 CONTINUE
C
      IF (NPRT.EQ.0) RETURN
C
C     COMPUTE SMOOTHED SQUARED COHERENCY PLOT VECTORS
C
      CI = PPFNML(ALPHA)*SQRT(1.0D0/DF)
      G = 2.0D0/DF
      G = 1.0D0 - (1.0D0-ALPHA)**(G/(1.0D0-G))
      NPTS = 0
      DO 60 I=1,NF
         NPTS = NPTS + 1
C
C     COMPUTE 95 PER CENT SIGNIFICANCE LEVEL
C
         YAXIS(NPTS) = G
         XAXIS(NPTS) = FREQ(I)
         ISYM(NPTS) = 4
         IF (SPCF1(I)*SPCF2(I).LE.0.0D0) GO TO 60
C
C     COMPUTE COHERENCE SPECTRAL ESTIMATE
C
         IF (CSPC2(I).GT.1.0D0) GO TO 60
         NPTS = NPTS + 1
         YAXIS(NPTS) = CSPC2(I)
         XAXIS(NPTS) = FREQ(I)
         ISYM(NPTS) = 1
         IF (CSPC2(I).LT.G) GO TO 60
C
C     COMPUTE CONFIDENCE INTERVAL
C
         BARY = SQRT(CSPC2(I))
         BARY = 0.5D0*(LOG((1.0D0+BARY)/(1.0D0-BARY)))
         NPTS = NPTS + 1
         YAXIS(NPTS) = (TANH(BARY+CI))*(TANH(BARY+CI))
         XAXIS(NPTS) = FREQ(I)
         ISYM(NPTS) = 2
         NPTS = NPTS + 1
         YAXIS(NPTS) = (TANH(BARY-CI))*(TANH(BARY-CI))
         XAXIS(NPTS) = FREQ(I)
         ISYM(NPTS) = 2
   60 CONTINUE
C
      RETURN
C
      END
*BFSMS
      SUBROUTINE BFSMS (Y1, YMISS1, Y2, YMISS2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
C     FOURIER SPECTRUM ANALYSIS OF SERIES WITH MISSING OBSERVATIONS
C     (LONG CALL)
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN,YMISS1,YMISS2
      INTEGER
     +   ICSPC2,IPHAS,LDSTAK,N,NF,NPRT,NW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CSPC2(*),FREQ(*),PHAS(*),Y1(*),Y2(*)
      INTEGER
     +   LAGS(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA
      INTEGER
     +   CCOV,CEVEN,CODD,I,ICCOV,IFP,INDEX1,INDEX2,INLPPC,IO,IPRT,
     +   ISYM,JCCOV,JNLPPC,LAGMAX,LAGMX1,LDSMIN,LPCV,LW,LWORK,LY,M,
     +   NALL0,NLPPC,SPCF1,SPCF2,W,WORK,XAXIS,YAXIS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,ECVF,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     INTEGER CCOV
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE COVARIANCES.
C     INTEGER CEVEN
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
C     INTEGER CODD
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CSPC2(ICSPC2,NW)
C        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER I
C        AN INDEX VALUE.
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER ICSPC2
C        THE FIRST DIMENSION OF THE ARRAY CSPC2.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER INDEX1, INDEX2
C        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
C        BASED ON PRINTED OUTPUT REQUESTED.
C     INTEGER IPHAS
C        THE FIRST DIMENSION OF THE ARRAY PHAS.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISYM
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER JCCOV
C        THE SECOND DIMENSION OF THE ARRAY CCOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGMX1
C        LAGMAX+1.
C     INTEGER LAGS(NW)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LW
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR WORK.
C     INTEGER LY
C        THE LENGTH OF THE VECTORS Y1 AND Y2.
C     INTEGER M
C        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
C        COMPUTED
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NALL0
C        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPC
C        THE STARTING LOCATION IN THE WORK AREA FOR NLPPC
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT.
C        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        IF NPRT = 0 THE PLOT IS SUPPRESSED.
C        IF NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION PHAS(IPHAS,NW)
C        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER SPCF1, SPCF2
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     INTEGER W
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE WINDOWS.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE WORK AREA FOR THE VECTOR WORK.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YMISS1, YMISS2
C        DUMMY VARIABLES.
C     DOUBLE PRECISION Y1(N)
C        THE FIRST TIME SERIES.
C     DOUBLE PRECISION Y2(N)
C        THE SECOND TIME SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','M','S',' '/
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(1) = .FALSE.
      OPTION(2) = .TRUE.
      OPTION(3) = .FALSE.
      OPTION(4) = .TRUE.
C
C     SET MAXIMUM LAG VALUE TO BE USED (LAGMAX).
C
      LAGMAX = N - 1
      IF (NW.LE.0) GO TO 20
      LAGMAX = LAGS(1)
      DO 10 I=1,NW
         LAGMAX = MAX(LAGMAX,LAGS(I))
   10 CONTINUE
   20 CONTINUE
      LAGMX1 = LAGMAX + 1
C
      ICCOV = LAGMAX + 1
      JCCOV = 2
      INLPPC = LAGMAX + 1
      JNLPPC = 2
      M = 2
      INDEX1 = 1
      INDEX2 = 2
C
C     COMPUTE THE MINIMUM ALLOWABLE STACK AREA (LDSMIN)
C
      IO = 1
      IF (NPRT.EQ.0) IO = 0
C
      CALL LDSCMP(10, 0, 4*LAGMAX + 4 + IO*4*NF, 0, 0, 0, 'D',
     +  7*LAGMAX+7+2*NF+IO*8*NF, LDSMIN)
C
      LY = N
      LPCV = 4*NF
      LW = LAGMX1
C
C     SET SIZE OF WORK AREA.
C     SET THE NUMBER OF OUTSTANDING STACK ALLOCATIONS (NALL0).
C     SET THE STACK ALLOCATION TYPE (IFP)
C
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
C
      IFP = 4
C
C     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS
C
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         CCOV = 1
         NLPPC = 1
         CEVEN = 1
         CODD = 1
         SPCF1 = 1
         SPCF2 = 1
         W = 1
C
         ISYM = 1
         XAXIS = 1
         YAXIS = 1
      ELSE
         CCOV = STKGET(4*LAGMX1,IFP)
         NLPPC = STKGET(4*LAGMX1,2)
         CEVEN = STKGET(LAGMX1,IFP)
         CODD = STKGET(LAGMX1,IFP)
         SPCF1 = STKGET(NF,IFP)
         SPCF2 = STKGET(NF,IFP)
         W = STKGET(LW,IFP)
         IF (NPRT.EQ.0) THEN
            ISYM = W
            XAXIS = W
            YAXIS = W
         ELSE
            ISYM = STKGET(LPCV,2)
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
         END IF
      END IF
C
      WORK = W
      LWORK = LW
C
C     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
C
      CALL BFSDRV(Y1, Y2, YMISS1, YMISS2, RSTAK(CCOV), ISTAK(NLPPC),
     +   RSTAK(SPCF1), RSTAK(SPCF2), NF, FMIN, FMAX, FREQ, N, NW,
     +   LAGMAX, LAGS, LAGMX1, RSTAK(WORK), LWORK, DELTA, ISTAK(ISYM),
     +   RSTAK(XAXIS), RSTAK(YAXIS), LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS,
     +   RSTAK(CODD), RSTAK(CEVEN), RSTAK(W), LW, NMSUB, LDSMIN,
     +   LDSTAK, OPTION, N, INLPPC, JNLPPC, LY)
C
      CALL STKCLR(NALL0)
C
C     CHECK FOR ERRORS
C
      IF (IERR.NE.0) THEN
        IF (IERR.EQ.2) CALL ECVF(NMSUB)
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL BFSMS (Y1, YMISS1, Y2, YMISS2, N,'/
     +  '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +  '      +            CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)')
      END
*BFSMV
      SUBROUTINE BFSMV(CCOV, NLPPC, INDEX1, INDEX2, N, LAGMAX, ICCOV,
     +  JCCOV, INLPPC, JNLPPC)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
C     FOURIER SPECTRUM ANALYSIS OF SERIES WITH MISSING OBSERVATIONS
C     AND COVARIANCES INPUT RATHER THAN ORIGINAL SERIES
C     (SHORT CALL)
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,INDEX1,INDEX2,INLPPC,JCCOV,JNLPPC,LAGMAX,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(*)
      INTEGER
     +   NLPPC(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS1,YMISS2
      INTEGER
     +   ICSPC2,IPHAS,IPRT,LAGMX1,LAGMXU,LDSMIN,LDSTAK,LPCV,LW,LY,
     +   M,NF,NPRT,NW
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CEVEN(101),CODD(101),CSPC2(101,4),FREQ(101),PHAS(101,4),
     +   SPCF1(101),SPCF2(101),W(101),XAXIS(404),Y1(1),Y2(1),
     +   YAXIS(404)
      INTEGER
     +   ISYM(404),LAGS(4)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,ECVF,IPRINT,PARZEN,SETLAG
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION CCOV(ICCOV,JCCOV,*)
C        THE COVARIANCES.
C     DOUBLE PRECISION CEVEN(101)
C        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CODD(101)
C        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CSPC2(101,4)
C        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(101)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER ICSPC2
C        THE FIRST DIMENSION OF THE ARRAY CSPC2.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER INDEX1, INDEX2
C        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
C     INTEGER INLPPC
C        THE FIRST DIMENSION OF THE ARRAY NLPPC.
C     INTEGER IPHAS
C        THE FIRST DIMENSION OF THE ARRAY PHAS.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISYM(404)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER JCCOV
C        THE SECOND DIMENSION OF THE ARRAY CCOV.
C     INTEGER JNLPPC
C        THE SECOND DIMENSION OF THE ARRAY NLPPC.
C     INTEGER LAGMAX, LAGMXU
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGMX1
C        LAGMAX+1.
C     INTEGER LAGS(4)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LW
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LY
C        THE LENGTH OF THE VECTORS Y1 AND Y2.
C     INTEGER M
C        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
C        COMPUTED
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPC(INLPPC,JNLPPC,*)
C        THE NUMBER OF OBSERVATIONS IN EACH COVARIANCE ESTIMATE
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT.
C        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        IF NPRT = 0 THE PLOT IS SUPPRESSED.
C        IF NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION PHAS(101,4)
C        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION SPCF1(101), SPCF2(101)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     DOUBLE PRECISION W(101)
C        THE WINDOWS.
C     DOUBLE PRECISION XAXIS(404)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YAXIS(404)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YMISS1, YMISS2
C        THE MISSING VALUE CODES
C     DOUBLE PRECISION Y1(1)
C        THE FIRST TIME SERIES.
C     DOUBLE PRECISION Y2(1)
C        THE SECOND TIME SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','M','V',' '/
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(1) = .FALSE.
      OPTION(2) = .TRUE.
      OPTION(3) = .TRUE.
      OPTION(4) = .FALSE.
C
      M = 2
C
      ICSPC2 = 101
      IPHAS = 101
C
      LDSTAK = 0
      LDSMIN = 0
C
      NF = 101
      LW = 101
      LY = N
      LPCV = 404
C
C     SET MAXIMUM LAG VALUE USED (LAGMXU)
C     SET NUMBER OF LAG WINDOW TRUCCATION POINTS (NW)
C
      CALL SETLAG(N, LAGMXU)
      LAGMXU = MIN(LAGMXU,LAGMAX)
      NW = 4
C
C     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
C
      CALL BFSDRV(Y1, Y2, YMISS1, YMISS2, CCOV, NLPPC, SPCF1, SPCF2,
     +   NF, FMIN, FMAX, FREQ, N, NW, LAGMXU, LAGS, LAGMX1, W, LW,
     +   DELTA, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS, CODD,
     +   CEVEN, W, LW, NMSUB, LDSMIN, LDSTAK, OPTION, N, INLPPC,
     +   JNLPPC, LY)
C
      IF (IERR.NE.0) THEN
        IF (IERR.EQ.2) CALL ECVF(NMSUB)
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL BFSMV (CCOV, NLPPC, INDEX1, INDEX2, N, LAGMAX,'/
     +   '      +            ICCOV, JCCOV, INLPPC, JNLPPC)')
      END
*BFSMVS
      SUBROUTINE BFSMVS(CCOV, NLPPC, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   INLPPC, JNLPPC, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
C     FOURIER SPECTRUM ANALYSIS OF SERIES WITH MISSING OBSERVATIONS
C     WITH USER INPUT OF THE COVARIANCES RATHER THAN THE SERIES
C     (LONG CALL)
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   ICCOV,ICSPC2,INDEX1,INDEX2,INLPPC,IPHAS,JCCOV,JNLPPC,
     +   LDSTAK,N,NF,NPRT,NW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(*),CSPC2(*),FREQ(*),PHAS(*)
      INTEGER
     +   LAGS(*),NLPPC(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,YMISS1,YMISS2
      INTEGER
     +   CEVEN,CODD,I,IFP,IO,IPRT,ISYM,LAGMAX,LAGMX1,LDSMIN,LPCV,
     +   LW,LWORK,LY,M,NALL0,SPCF1,SPCF2,W,WORK,XAXIS,YAXIS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12),Y1(1),Y2(1)
      INTEGER
     +   ISTAK(12)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,ECVF,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION CCOV(ICCOV,JCCOV,*)
C        THE COVARIANCES.
C     INTEGER CEVEN
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
C     INTEGER CODD
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CSPC2(ICSPC2,NW)
C        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER I
C        AN INDEX VALUE.
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER ICSPC2
C        THE FIRST DIMENSION OF THE ARRAY CSPC2.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER INDEX1, INDEX2
C        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
C        BASED ON PRINTED OUTPUT REQUESTED.
C     INTEGER IPHAS
C        THE FIRST DIMENSION OF THE ARRAY PHAS.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISYM
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER JCCOV
C        THE SECOND DIMENSION OF THE ARRAY CCOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGMX1
C        LAGMAX+1.
C     INTEGER LAGS(NW)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LW
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR WORK.
C     INTEGER LY
C        THE LENGTH OF THE VECTORS Y1 AND Y2.
C     INTEGER M
C        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
C        COMPUTED
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NALL0
C        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPC(INLPPC,JNLPPC,*)
C        THE NUMBER OF OBSERVATIONS IN EACH COVARIANCE ESTIMATE
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT.
C        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        IF NPRT = 0 THE PLOT IS SUPPRESSED.
C        IF NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION PHAS(IPHAS,NW)
C        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER SPCF1, SPCF2
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     INTEGER W
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE WINDOWS.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE WORK AREA FOR THE VECTOR WORK.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YMISS1, YMISS2
C        DUMMY VARIABLES.
C     DOUBLE PRECISION Y1(1)
C        THE FIRST TIME SERIES.
C     DOUBLE PRECISION Y2(1)
C        THE SECOND TIME SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','M','V','S'/
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(1) = .FALSE.
      OPTION(2) = .TRUE.
      OPTION(3) = .TRUE.
      OPTION(4) = .TRUE.
C
C     SET MAXIMUM LAG VALUE TO BE USED (LAGMAX).
C
      LAGMAX = N - 1
      IF (NW.LE.0) GO TO 20
      LAGMAX = LAGS(1)
      DO 10 I=1,NW
         LAGMAX = MAX(LAGMAX,LAGS(I))
   10 CONTINUE
   20 CONTINUE
      LAGMX1 = LAGMAX + 1
C
      M = 2
C
C     COMPUTE THE MINIMUM ALLOWABLE STACK AREA (LDSMIN)
C
      IO = 1
      IF (NPRT.EQ.0) IO = 0
C
      CALL LDSCMP(8, 0, IO*4*NF, 0, 0, 0, 'D',
     +  7*LAGMAX+7+2*NF+IO*8*NF, LDSMIN)
C
      LY = N
      LPCV = 4*NF
      LW = LAGMAX + 1
C
C     SET SIZE OF WORK AREA.
C     SET THE NUMBER OF OUTSTANDING STACK ALLOCATIONS (NALL0).
C     SET THE STACK ALLOCATION TYPE (IFP)
C
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
C
      IFP = 4
C
C     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS
C
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         CEVEN = 1
         CODD = 1
         SPCF1 = 1
         SPCF2 = 1
         W = 1
C
         ISYM = 1
         XAXIS = 1
         YAXIS = 1
      ELSE
         CEVEN = STKGET(LAGMX1,IFP)
         CODD = STKGET(LAGMX1,IFP)
         SPCF1 = STKGET(NF,IFP)
         SPCF2 = STKGET(NF,IFP)
         W = STKGET(LW,IFP)
         IF (NPRT.EQ.0) THEN
            ISYM = W
            XAXIS = W
            YAXIS = W
         ELSE
            ISYM = STKGET(LPCV,2)
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
         END IF
      END IF
C
      WORK = W
      LWORK = LW
C
C     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
C
      CALL BFSDRV(Y1, Y2, YMISS1, YMISS2, CCOV, NLPPC,
     +   RSTAK(SPCF1), RSTAK(SPCF2), NF, FMIN, FMAX, FREQ, N, NW,
     +   LAGMAX, LAGS, LAGMX1, RSTAK(WORK), LWORK, DELTA, ISTAK(ISYM),
     +   RSTAK(XAXIS), RSTAK(YAXIS), LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS,
     +   RSTAK(CODD), RSTAK(CEVEN), RSTAK(W), LW, NMSUB, LDSMIN,
     +   LDSTAK, OPTION, N, INLPPC, JNLPPC, LY)
C
      CALL STKCLR(NALL0)
C
C     CHECK FOR ERRORS
C
      IF (IERR.NE.0) THEN
        IF (IERR.EQ.2) CALL ECVF(NMSUB)
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL BFSMVS(CCOV, NLPPC, INDEX1, INDEX2, N,'/
     +   '      +            ICCOV, JCCOV, INLPPC, JNLPPC,'/
     +   '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +   '      +            CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)')
      END
*BFSS
      SUBROUTINE BFSS(Y1, Y2, N, NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2,
     +   ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
C     BIVARIATE SPECTRUM ANALYSIS (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   ICSPC2,IPHAS,LDSTAK,N,NF,NPRT,NW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CSPC2(*),FREQ(*),PHAS(*),Y1(*),Y2(*)
      INTEGER
     +   LAGS(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,YMISS1,YMISS2
      INTEGER
     +   CCOV,CCOV11,CCOV12,CCOV21,CCOV22,CEVEN,CODD,I,ICCOV,IFP,
     +   INDEX1,INDEX2,INLPPC,IO,IPRT,ISYM,JCCOV,JNLPPC,LAGMAX,
     +   LAGMX1,LDSMIN,LPCV,LW,LWORK,LY,M,NALL0,SPCF1,SPCF2,W,WORK,
     +   XAXIS,YAXIS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12),NLPPC(1,1,1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     INTEGER CCOV, CCOV11, CCOV12, CCOV21, CCOV22
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE COVARIANCES.
C     INTEGER CEVEN
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
C     INTEGER CODD
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CSPC2(ICSPC2,NW)
C        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER I
C        AN INDEX VALUE.
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER ICSPC2
C        THE FIRST DIMENSION OF THE ARRAY CSPC2.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER INDEX1, INDEX2
C        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
C        BASED ON PRINTED OUTPUT REQUESTED.
C     INTEGER IPHAS
C        THE FIRST DIMENSION OF THE ARRAY PHAS.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISYM
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER JCCOV
C        THE SECOND DIMENSION OF THE ARRAY CCOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGMX1
C        LAGMAX+1.
C     INTEGER LAGS(NW)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LW
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR WORK.
C     INTEGER LY
C        THE LENGTH OF THE VECTORS Y1 AND Y2.
C     INTEGER M
C        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
C        COMPUTED
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NALL0
C        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPC(1,1,1)
C        A DUMMY ARRAY.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT.
C        IF NPRT = 0 THE PLOT IS SUPPRESSED.
C        IF NPRT = 1 THE PLOT IS PROVIDED.
C     INTEGER NW
C        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION PHAS(IPHAS,NW)
C        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER SPCF1, SPCF2
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     INTEGER W
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE WINDOWS.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE WORK AREA FOR THE VECTOR WORK.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YMISS1, YMISS2
C        DUMMY VARIABLES.
C     DOUBLE PRECISION Y1(N)
C        THE FIRST TIME SERIES.
C     DOUBLE PRECISION Y2(N)
C        THE SECOND TIME SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','S',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(4) = .TRUE.
C
C     SET MAXIMUM LAG VALUE TO BE USED (LAGMAX).
C
      IF (NW.GE.1) THEN
         LAGMAX = LAGS(1)
         DO 10 I=1,NW
            LAGMAX = MAX(LAGMAX,LAGS(I))
   10    CONTINUE
      ELSE
         LAGMAX = N - 1
      END IF
      LAGMX1 = LAGMAX + 1
C
      ICCOV = LAGMAX + 1
      JCCOV = 2
      INLPPC = 1
      JNLPPC = 1
      M = 2
      INDEX1 = 1
      INDEX2 = 2
C
C     COMPUTE THE MINIMUM ALLOWABLE STACK AREA (LDSMIN)
C
      IO = 1
      IF (NPRT.EQ.0) IO = 0
C
      CALL LDSCMP(9, 0, IO*4*NF, 0, 0, 0, 'D',
     +            7*LAGMAX+7+IO*8*NF, LDSMIN)
C
      LY = N
      YMISS1 = 1.0D0
      YMISS2 = 1.0D0
      LPCV = 4*NF
      LW = LAGMAX + 1
C
C     SET SIZE OF WORK AREA.
C     SET THE NUMBER OF OUTSTANDING STACK ALLOCATIONS (NALL0).
C     SET THE STACK ALLOCATION TYPE (IFP)
C
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
C
      IFP = 4
C
C     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS
C
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         CCOV = 1
         CEVEN = 1
         CODD = 1
         SPCF1 = 1
         SPCF2 = 1
         W = 1
C
         CCOV11 = 1
         CCOV21 = 1
         CCOV12 = 1
         CCOV22 = 1
C
         ISYM = 1
         XAXIS = 1
         YAXIS = 1
      ELSE
         CCOV = STKGET(4*LAGMX1,IFP)
         CEVEN = STKGET(LAGMX1,IFP)
         CODD = STKGET(LAGMX1,IFP)
         SPCF1 = STKGET(NF,IFP)
         SPCF2 = STKGET(NF,IFP)
         W = STKGET(LW,IFP)
C
         CCOV11 = CCOV
         CCOV21 = CCOV + LAGMX1
         CCOV12 = CCOV21 + LAGMX1
         CCOV22 = CCOV12 + LAGMX1
C
         IF (NPRT.EQ.0) THEN
            ISYM = W
            XAXIS = W
            YAXIS = W
         ELSE
            ISYM = STKGET(LPCV,2)
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
        END IF
      END IF
C
      WORK = W
      LWORK = LW
C
C     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
C
      CALL BFSDRV(Y1, Y2, YMISS1, YMISS2, RSTAK(CCOV), NLPPC,
     +   RSTAK(SPCF1), RSTAK(SPCF2), NF, FMIN, FMAX, FREQ, N, NW,
     +   LAGMAX, LAGS, LAGMX1, RSTAK(WORK), LWORK, DELTA, ISTAK(ISYM),
     +   RSTAK(XAXIS), RSTAK(YAXIS), LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS,
     +   RSTAK(CODD), RSTAK(CEVEN), RSTAK(W), LW, NMSUB, LDSMIN,
     +   LDSTAK, OPTION, N, INLPPC, JNLPPC, LY)
C
      CALL STKCLR(NALL0)
C
C     CHECK FOR ERRORS
C
      IF (IERR.EQ.0) RETURN
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL BFSS (Y1, Y2, N,'/
     +   '      +           NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +   '      +           CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)')
      END
*BFSV
      SUBROUTINE BFSV(CCOV, INDEX1, INDEX2, N, LAGMAX, ICCOV, JCCOV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
C     FOURIER SPECTRUM ANALYSIS OF SERIES WITH
C     COVARIANCES INPUT RATHER THAN ORIGINAL SERIES
C     (SHORT CALL)
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,INDEX1,INDEX2,JCCOV,LAGMAX,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS1,YMISS2
      INTEGER
     +   ICSPC2,INLPPC,IPHAS,IPRT,JNLPPC,LAGMX1,LAGMXU,LDSMIN,
     +   LDSTAK,LPCV,LW,LY,M,NF,NPRT,NW
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CEVEN(101),CODD(101),CSPC2(101,4),FREQ(101),PHAS(101,4),
     +   SPCF1(101),SPCF2(101),W(101),XAXIS(404),Y1(1),Y2(1),
     +   YAXIS(404)
      INTEGER
     +   ISYM(404),LAGS(4),NLPPC(1,1,1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,IPRINT,PARZEN,SETLAG
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION CCOV(ICCOV,JCCOV,*)
C        THE COVARIANCES.
C     DOUBLE PRECISION CEVEN(101)
C        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CODD(101)
C        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CSPC2(101,4)
C        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(101)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER ICSPC2
C        THE FIRST DIMENSION OF THE ARRAY CSPC2.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER INDEX1, INDEX2
C        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
C     INTEGER INLPPC
C        THE FIRST DIMENSION OF THE ARRAY NLPPC.
C     INTEGER IPHAS
C        THE FIRST DIMENSION OF THE ARRAY PHAS.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISYM(404)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER JCCOV
C        THE SECOND DIMENSION OF THE ARRAY CCOV.
C     INTEGER JNLPPC
C        THE SECOND DIMENSION OF THE ARRAY NLPPC.
C     INTEGER LAGMAX, LAGMXU
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGMX1
C        LAGMAX+1.
C     INTEGER LAGS(4)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LW
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LY
C        THE LENGTH OF THE VECTORS Y1 AND Y2.
C     INTEGER M
C        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
C        COMPUTED
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPC(1,1,1)
C        A DUMMY ARRAY.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT.
C        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        IF NPRT = 0 THE PLOT IS SUPPRESSED.
C        IF NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION PHAS(101,4)
C        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION SPCF1(101), SPCF2(101)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     DOUBLE PRECISION W(101)
C        THE WINDOWS.
C     DOUBLE PRECISION XAXIS(404)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YAXIS(404)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YMISS1, YMISS2
C        THE MISSING VALUE CODES
C     DOUBLE PRECISION Y1(1)
C        THE FIRST TIME SERIES.
C     DOUBLE PRECISION Y2(1)
C        THE SECOND TIME SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','V',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .TRUE.
      OPTION(4) = .FALSE.
C
      M = 2
C
      INLPPC = 1
      JNLPPC = 1
      ICSPC2 = 101
      IPHAS = 101
C
      LDSTAK = 0
      LDSMIN = 0
C
      NF = 101
      LW = 101
      LY = N
      LPCV = 404
C
C     SET MAXIMUM LAG VALUE USED (LAGMXU)
C     SET NUMBER OF LAG WINDOW TRUCCATION POINTS (NW)
C
      CALL SETLAG(N, LAGMXU)
      LAGMXU = MIN(LAGMXU,LAGMAX)
      NW = 4
C
C     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
C
      CALL BFSDRV(Y1, Y2, YMISS1, YMISS2, CCOV, NLPPC, SPCF1, SPCF2,
     +   NF, FMIN, FMAX, FREQ, N, NW, LAGMXU, LAGS, LAGMX1, W, LW,
     +   DELTA, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS, CODD,
     +   CEVEN, W, LW, NMSUB, LDSMIN, LDSTAK, OPTION, N, INLPPC,
     +   JNLPPC, LY)
C
      IF (IERR.EQ.0) RETURN
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL BFSV(CCOV, INDEX1, INDEX2, N, LAGMAX, ICCOV,',
     +  ' JCCOV)')
      END
*BFSVS
      SUBROUTINE BFSVS(CCOV, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS,
     +   FREQ, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
C     FOURIER SPECTRUM ANALYSIS OF SERIES WITH
C     USER INPUT OF THE COVARIANCES RATHER THAN THE SERIES
C     (LONG CALL)
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   ICCOV,ICSPC2,INDEX1,INDEX2,IPHAS,JCCOV,LDSTAK,N,NF,NPRT,NW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(*),CSPC2(*),FREQ(*),PHAS(*)
      INTEGER
     +   LAGS(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,YMISS1,YMISS2
      INTEGER
     +   CEVEN,CODD,I,IFP,INLPPC,IO,IPRT,ISYM,JNLPPC,LAGMAX,LAGMX1,
     +   LDSMIN,LPCV,LW,LWORK,LY,M,NALL0,SPCF1,SPCF2,W,WORK,XAXIS,
     +   YAXIS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12),Y1(1),Y2(1)
      INTEGER
     +   ISTAK(12),NLPPC(1,1,1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION CCOV(ICCOV,JCCOV,*)
C        THE COVARIANCES.
C     INTEGER CEVEN
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
C     INTEGER CODD
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
C     DOUBLE PRECISION CSPC2(ICSPC2,NW)
C        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER I
C        AN INDEX VALUE.
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER ICSPC2
C        THE FIRST DIMENSION OF THE ARRAY CSPC2.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER INDEX1, INDEX2
C        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
C        BASED ON PRINTED OUTPUT REQUESTED.
C     INTEGER IPHAS
C        THE FIRST DIMENSION OF THE ARRAY PHAS.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISYM
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER JCCOV
C        THE SECOND DIMENSION OF THE ARRAY CCOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGMX1
C        LAGMAX+1.
C     INTEGER LAGS(NW)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LW
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR WORK.
C     INTEGER LY
C        THE LENGTH OF THE VECTORS Y1 AND Y2.
C     INTEGER M
C        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
C        COMPUTED
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NALL0
C        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPC(1,1,1)
C        THE NUMBER OF OBSERVATIONS IN EACH COVARIANCE ESTIMATE
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT.
C        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        IF NPRT = 0 THE PLOT IS SUPPRESSED.
C        IF NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION PHAS(IPHAS,NW)
C        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER SPCF1, SPCF2
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     INTEGER W
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE WINDOWS.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE WORK AREA FOR THE VECTOR WORK.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YMISS1, YMISS2
C        DUMMY VARIABLES.
C     DOUBLE PRECISION Y1(1)
C        THE FIRST TIME SERIES.
C     DOUBLE PRECISION Y2(1)
C        THE SECOND TIME SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','V','S',' '/
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .TRUE.
      OPTION(4) = .TRUE.
C
C     SET MAXIMUM LAG VALUE TO BE USED (LAGMAX).
C
      LAGMAX = N - 1
      IF (NW.LE.0) GO TO 20
      LAGMAX = LAGS(1)
      DO 10 I=1,NW
         LAGMAX = MAX(LAGMAX,LAGS(I))
   10 CONTINUE
   20 CONTINUE
      LAGMX1 = LAGMAX + 1
C
      M = 2
C
C     COMPUTE THE MINIMUM ALLOWABLE STACK AREA (LDSMIN)
C
      IO = 1
      IF (NPRT.EQ.0) IO = 0
C
      CALL LDSCMP(8, 0, IO*4*NF, 0, 0, 0, 'D',
     +  3*LAGMAX+3+2*NF+IO*8*NF, LDSMIN)
C
      INLPPC = 1
      JNLPPC = 1
      LY = N
      LPCV = 4*NF
      LW = LAGMAX + 1
C
C     SET SIZE OF WORK AREA.
C     SET THE NUMBER OF OUTSTANDING STACK ALLOCATIONS (NALL0).
C     SET THE STACK ALLOCATION TYPE (IFP)
C
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
C
      IFP = 4
C
C     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS
C
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         CEVEN = 1
         CODD = 1
         SPCF1 = 1
         SPCF2 = 1
         W = 1
         ISYM = W
         XAXIS = W
         YAXIS = W
      ELSE
         CEVEN = STKGET(LAGMX1,IFP)
         CODD = STKGET(LAGMX1,IFP)
         SPCF1 = STKGET(NF,IFP)
         SPCF2 = STKGET(NF,IFP)
         W = STKGET(LW,IFP)
         IF (NPRT.EQ.0) THEN
            ISYM = W
            XAXIS = W
            YAXIS = W
         ELSE
            ISYM = STKGET(LPCV,2)
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
         END IF
      END IF
C
      WORK = W
      LWORK = LW
C
C     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
C
      CALL BFSDRV(Y1, Y2, YMISS1, YMISS2, CCOV, NLPPC,
     +   RSTAK(SPCF1), RSTAK(SPCF2), NF, FMIN, FMAX, FREQ, N, NW,
     +   LAGMAX, LAGS, LAGMX1, RSTAK(WORK), LWORK, DELTA, ISTAK(ISYM),
     +   RSTAK(XAXIS), RSTAK(YAXIS), LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS,
     +   RSTAK(CODD), RSTAK(CEVEN), RSTAK(W), LW, NMSUB, LDSMIN,
     +   LDSTAK, OPTION, N, INLPPC, JNLPPC, LY)
C
      CALL STKCLR(NALL0)
C
C     CHECK FOR ERRORS
C
      IF (IERR.EQ.0) RETURN
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL BFSVS(CCOV, INDEX1, INDEX2, N, ICCOV, JCCOV,'/
     + '      +           NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     + '      +           CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)')
      END
*CCF
      SUBROUTINE CCF (Y1, Y2, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
C     CORRELATIONS OF TWO TIME SERIES (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y1(*),Y2(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   Y1MEAN,Y1SD,Y2MEAN,Y2SD
      INTEGER
     +   ICCOV,INLPPC,IPRT,IYM,IYMFFT,JCCOV,JNLPPC,LAGMAX,LDSMIN,
     +   LDSTAK,LYFFT,M,NFFT
      LOGICAL
     +   ISFFT,ISLONG
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCOV(101,2,2),RHOC(201),SDRHOC(201)
      INTEGER
     +   NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACVF,CCFER,CCFMN,CCFOUT,IPRINT,SETLAG
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCOV(101, 2, 2)
C        THE CCVF MATRIX.
C     INTEGER ICCOV
C        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER INLPPC
C        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
C        IN THE USERS PROGRAM.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     LOGICAL ISFFT
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
C     LOGICAL ISLONG
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
C     INTEGER IYM
C        THE ACTUAL FIRST DIMENSION OF THE MATRIX YM AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER IYMFFT
C        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER JCCOV
C        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER JNLPPC
C        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
C        IN THE USERS PROGRAM.
C     INTEGER LAGMAX
C        THE NUMBER OF AUTOCORRELATIONS DESIRED.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER M
C        THE NUMBER OF SERIES BEING COMPARED, IE THE
C        NUMBER OF COLUMNS OF DATA IN YM.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NDUM(1)
C        A DUMMY DIMENSIONED VARIABLE.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C     DOUBLE PRECISION RHOC(201)
C        THE ARRAY CONTAINING THE CCF.
C     DOUBLE PRECISION SDRHOC(201)
C        THE ARRAY CONTAINING THE SD OF THE CCF.
C     DOUBLE PRECISION Y1(N), Y1MEAN, Y1SD
C        THE FIRST SERIES, AND ITS MEAN AND STANDARD DEVIATION.
C     DOUBLE PRECISION Y2(N), Y2MEAN, Y2SD
C        THE SECOND SERIES, AND ITS MEAN AND STANDARD DEVIATION.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'C',       'C',       'F',       ' ',       ' ',       ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      ICCOV = 101
      INLPPC = 1
      IYM = N
      JCCOV = 2
      JNLPPC = 1
      LDSMIN = 0
      LDSTAK = 0
      LAGMAX = 1
      LYFFT = N + LAGMAX
      IYMFFT = LYFFT
      M = 2
      NFFT = N
      ISFFT = .FALSE.
      ISLONG = .FALSE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL CCFER(NMSUB, N, LAGMAX, LDSTAK, LDSMIN, ICCOV, JCCOV,
     +  INLPPC, JNLPPC, M, LYFFT, NFFT, IYM, IYMFFT, ISFFT, ISLONG)
C
C     CHECK WHETHER AN ERROR HAS BEEN DETECTED
C
      IF (IERR.EQ.0) THEN
C
C       SET THE MAXIMUM LAG VALUE TO BE USED.
C
        CALL SETLAG (N, LAGMAX)
C
C       COMPUTE THE SERIES ACVF AND SD
C
        CALL ACVF (Y1, N, Y1MEAN, CCOV(1,1,1), LAGMAX, 101)
        Y1SD = SQRT(CCOV(1,1,1) * N / (N-1))
C
        CALL ACVF (Y2, N, Y2MEAN, CCOV(1,2,2), LAGMAX, 101)
        Y2SD = SQRT(CCOV(1,2,2) * N / (N-1))
C
C       CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
C
        IF (CCOV(1,1,1)*CCOV(1,2,2) .NE. 0.0D0)
     +    CALL CCFMN (Y1, Y2, N, LAGMAX, 2*LAGMAX+1, CCOV(1,1,1),
     +     CCOV(1,2,2), CCOV(1,1,2), CCOV(1,2,1), 101, Y1MEAN, Y2MEAN,
     +     RHOC, SDRHOC, 1)
C
C       CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
C
        CALL CCFOUT (1, Y1MEAN, Y1SD, N, N, 2, Y2MEAN, Y2SD, N,
     +     N, LAGMAX, 2*LAGMAX+1, RHOC, SDRHOC, .FALSE., NDUM, NDUM, 1,
     +     0.0D0, 0.0D0, .FALSE.)
      END IF
C
      IF (IERR.NE.0) THEN
C
C     PRINT PROPER CALL SEQUENCE AND RETURN
C
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   27H       CALL CCF (Y1, Y2, N))
      END
*CCFER
      SUBROUTINE CCFER(NMSUB, N, LAGMAX, LDSTAK, LDSMIN, ICCOV, JCCOV,
     +  INLPPC, JNLPPC, M, LYFFT, NFFT, IYM, IYMFFT, ISFFT, ISLONG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE ERROR CHECKING ROUTINE FOR THE CCF FAMILY
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,INLPPC,IYM,IYMFFT,JCCOV,JNLPPC,LAGMAX,LDSMIN,LDSTAK,
     +   LYFFT,M,N,NFFT
      LOGICAL
     +   ISFFT,ISLONG
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I
      LOGICAL
     +   HEAD
C
C  LOCAL ARRAYS
      LOGICAL
     +   ERR(15)
      CHARACTER
     +   LICCOV(8)*1,LINLPP(8)*1,LIYM(8)*1,LIYMFF(8)*1,
     +   LJCCOV(8)*1,LJNLPP(8)*1,LLAGMX(8)*1,LLDS(8)*1,
     +   LLGMX1(8)*1,LLYFFT(8)*1,LM(8)*1,LN(8)*1,LNFFT(8)*1,
     +   LNM1(8)*1,LONE(8)*1,LTHREE(8)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR(15)
C        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C     INTEGER INLPPC
C        THE FIRST DIMENSION OF THE ARRAY NLPPC.
C     LOGICAL ISFFT
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
C     LOGICAL ISLONG
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
C     INTEGER IYM, IYMFFT
C        THE FIRST DIMENSION OF THE ARRAYS YM AND YMFFT, RESPECTIVELY.
C     INTEGER JCCOV, JNLPPC
C        THE SECOND DIMENSIONS OF THE ARRAYS CCOV AND NLPPC,
C        RESPECTIVELY.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE REQUESTED.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     CHARACTER*1 LICCOV(8), LINLPP(8), LIYM(8), LIYMFF(8), LJCCOV(8),
C    *  LJNLPP(8), LLAGMX(8), LLDS(8), LLGMX1(8), LLYFFT(8),
C    *  LM(8), LN(8), LNFFT(8), LNM1(8), LONE(8), LTHREE(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
C        CHECKED FOR ERRORS.
C     INTEGER M
C        THE NUMBER OF SERIES BEING ANALYZED
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C
C     SET UP NAME ARRAYS
C
      DATA
     + LICCOV(1), LICCOV(2), LICCOV(3), LICCOV(4), LICCOV(5),
     + LICCOV(6), LICCOV(7), LICCOV(8) /'I','C','C','O','V',' ',' ',' '/
      DATA
     + LINLPP(1), LINLPP(2), LINLPP(3), LINLPP(4), LINLPP(5),
     + LINLPP(6), LINLPP(7), LINLPP(8) /'I','N','L','P','P','C',' ',' '/
      DATA
     + LIYM(1), LIYM(2), LIYM(3), LIYM(4), LIYM(5),
     + LIYM(6), LIYM(7), LIYM(8) /'I','Y','M',' ',' ',' ',' ',' '/
      DATA
     + LIYMFF(1), LIYMFF(2), LIYMFF(3), LIYMFF(4), LIYMFF(5),
     + LIYMFF(6), LIYMFF(7), LIYMFF(8) /'I','Y','M','F','F','T',' ',' '/
      DATA
     + LJCCOV(1), LJCCOV(2), LJCCOV(3), LJCCOV(4), LJCCOV(5),
     + LJCCOV(6), LJCCOV(7), LJCCOV(8) /'J','C','C','O','V',' ',' ',' '/
      DATA
     + LJNLPP(1), LJNLPP(2), LJNLPP(3), LJNLPP(4), LJNLPP(5),
     + LJNLPP(6), LJNLPP(7), LJNLPP(8) /'J','N','L','P','P','C',' ',' '/
      DATA
     + LLAGMX(1), LLAGMX(2), LLAGMX(3), LLAGMX(4), LLAGMX(5),
     + LLAGMX(6), LLAGMX(7), LLAGMX(8) /'L','A','G','M','A','X',' ',' '/
      DATA
     + LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     + LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA
     + LLGMX1(1), LLGMX1(2), LLGMX1(3), LLGMX1(4), LLGMX1(5),
     + LLGMX1(6), LLGMX1(7), LLGMX1(8) /'L','A','G','M','A','X','+','1'/
      DATA
     + LLYFFT(1), LLYFFT(2), LLYFFT(3), LLYFFT(4), LLYFFT(5),
     + LLYFFT(6), LLYFFT(7), LLYFFT(8) /'L','Y','F','F','T',' ',' ',' '/
      DATA
     + LM(1), LM(2), LM(3), LM(4), LM(5),
     + LM(6), LM(7), LM(8) /'M',' ',' ',' ',' ',' ',' ',' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5),
     + LN(6), LN(7), LN(8) /'N',' ',' ',' ',' ',' ',' ',' '/
      DATA
     + LNM1(1), LNM1(2), LNM1(3), LNM1(4), LNM1(5),
     + LNM1(6), LNM1(7), LNM1(8) /'(','N','-','1',')',' ',' ',' '/
      DATA
     + LNFFT(1), LNFFT(2), LNFFT(3), LNFFT(4), LNFFT(5),
     + LNFFT(6), LNFFT(7), LNFFT(8) /'N','F','F','T',' ',' ',' ',' '/
      DATA
     + LONE(1), LONE(2), LONE(3), LONE(4), LONE(5),
     + LONE(6), LONE(7), LONE(8) /'O','N','E',' ',' ',' ',' ',' '/
      DATA
     + LTHREE(1), LTHREE(2), LTHREE(3), LTHREE(4), LTHREE(5),
     + LTHREE(6), LTHREE(7), LTHREE(8) /'T','H','R','E','E',' ',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
      DO 10 I = 1, 15
        ERR(I) = .FALSE.
   10 CONTINUE
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 3, 2, HEAD, ERR(1), LTHREE)
C
      CALL EISGE(NMSUB, LM, M, 1, 2, HEAD, ERR(2), LONE)
C
      IF (.NOT.ERR(1)) THEN
C
        CALL EISII(NMSUB, LLAGMX, LAGMAX, 1, N-1, 1, HEAD, ERR(3), LONE,
     +    LNM1)
C
        IF (ISFFT) THEN
          IF (ISLONG) THEN
            CALL EISGE(NMSUB, LIYMFF, IYMFFT, NFFT, 3, HEAD, ERR(4),
     +        LNFFT)
          ELSE
            CALL EISGE(NMSUB, LLYFFT, LYFFT, NFFT, 3, HEAD, ERR(4),
     +        LNFFT)
          END IF
        ELSE
          CALL EISGE(NMSUB, LIYM, IYM, N, 3, HEAD, ERR(4), LN)
        END IF
C
        IF (.NOT.ERR(3)) THEN
C
          IF (ISLONG) THEN
            CALL EISGE(NMSUB, LICCOV, ICCOV, LAGMAX+1, 3, HEAD, ERR(5),
     +        LLGMX1)
            CALL EISGE(NMSUB, LJCCOV, JCCOV, M, 3, HEAD, ERR(6),
     +        LLGMX1)
            CALL EISGE(NMSUB, LINLPP, INLPPC, LAGMAX+1, 3, HEAD, ERR(7),
     +        LLGMX1)
            CALL EISGE(NMSUB, LJNLPP, JNLPPC, M, 3, HEAD, ERR(8),
     +        LLGMX1)
          END IF
C
          CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR(9), LLDS)
C
        END IF
      END IF
C
      DO 20 I = 1, 15
        IF (ERR(I)) IERR = 1
   20 CONTINUE
C
      RETURN
C
      END
*CCFF
      SUBROUTINE CCFF (YFFT1, YFFT2, N, LYFFT, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
C     CORRELATIONS OF TWO TIME SERIES USING THE SINGLETON FFT
C     (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,LYFFT,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YFFT1(*),YFFT2(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   Y1MEAN,Y1SD,Y2MEAN,Y2SD
      INTEGER
     +   ICCOV,IFP,INLPPC,IPRT,IYM,IYMFFT,JCCOV,JNLPPC,LAGMAX,
     +   LDSMIN,M,NALL0,NFFT,WORK
      LOGICAL
     +   ISFFT,ISLONG
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCOV(101,2,2),RHOC(201),RSTAK(12),SDRHOC(201),STAK(12)
      INTEGER
     +   NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACVFF,CCFER,CCFMNF,CCFOUT,FFTLEN,IPRINT,LDSCMP,SETLAG,
     +   STKCLR,STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),STAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCOV(101, 2, 2)
C        THE CCVF MATRIX.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ICCOV
C        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER INLPPC
C        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
C        IN THE USERS PROGRAM.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     LOGICAL ISFFT
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
C     LOGICAL ISLONG
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
C     INTEGER IYMFFT
C        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER JCCOV
C        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER JNLPPC
C        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
C        IN THE USERS PROGRAM.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE REQUESTED.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LYFFT
C        THE NUMBER OF LOCATIONS IN THE ARRAY YFFT1 AND YFFT2.
C     INTEGER M
C        THE NUMBER OF SERIES BEING COMPARED, IE THE
C        NUMBER OF COLUMNS OF DATA IN YM.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
C     INTEGER NDUM(1)
C        A DUMMY ARRAY.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C     DOUBLE PRECISION RHOC(201)
C        THE ARRAY CONTAINING THE CCF.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION SDRHOC(201)
C        THE ARRAY CONTAINING THE SD OF THE CCF.
C     DOUBLE PRECISION STAK(12)
C        THE USED VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER WORK
C        THE STARTING LOCATION IN DSTAK FOR
C        THE WORK ARRAY NEEDED BY THE FFT.
C     DOUBLE PRECISION YFFT1(N), Y1MEAN, Y1SD
C        THE FIRST SERIES, AND ITS MEAN AND STANDARD DEVIATION.
C     DOUBLE PRECISION YFFT2(N), Y2MEAN, Y2SD
C        THE SECOND SERIES, AND ITS MEAN AND STANDARD DEVIATION.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'C',       'C',       'F',       'F',       ' ',       ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      ICCOV = 101
      INLPPC = 1
      IYM = N
      JCCOV = 2
      JNLPPC = 1
      LAGMAX = 1
      IYMFFT = LYFFT
      M = 2
      NFFT = N
      ISFFT = .TRUE.
      ISLONG = .FALSE.
C
      IF (N.GE.3) THEN
C
C     SET LARGEST LAG VALUE TO BE USED
C
        CALL SETLAG(N, LAGMAX)
C
C     SET LENGTH OF THE EXTENDED SERIES
C
        CALL FFTLEN(N+LAGMAX, 4, NFFT)
      END IF
C
      CALL LDSCMP(1, 0, 0, 0, 0, 0, 'D', NFFT, LDSMIN)
C
      CALL CCFER(NMSUB, N, LAGMAX, LDSTAK, LDSMIN, ICCOV, JCCOV,
     +  INLPPC, JNLPPC, M, LYFFT, NFFT, IYM, IYMFFT, ISFFT, ISLONG)
C
C     CHECK WHETHER AN ERROR HAS BEEN DETECTED
C
      IF (IERR.EQ.0) THEN
C
C       SET UP THE WORK AREA.
C
        CALL STKSET (LDSTAK, 4)
        NALL0 = STKST(1)
C
        IFP = 4
C
        WORK = STKGET(NFFT, IFP)
C
        IF (IERR.EQ.0) THEN
C
C         COMPUTE THE SERIES ACVF AND SD
C
          CALL ACVFF (YFFT1, N, NFFT, Y1MEAN, CCOV(1,1,1), LAGMAX, 101,
     +       LYFFT, STAK(WORK), NFFT)
          Y1SD = SQRT(CCOV(1,1,1) * N / (N-1))
C
          CALL ACVFF (YFFT2, N, NFFT, Y2MEAN, CCOV(1,2,2), LAGMAX, 101,
     +       LYFFT, STAK(WORK), NFFT)
          Y2SD = SQRT(CCOV(1,2,2) * N / (N-1))
C
C         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
C
          IF (CCOV(1,1,1)*CCOV(1,2,2) .NE. 0.0D0)
     +       CALL CCFMNF (YFFT1, YFFT2, N, NFFT, LAGMAX, 2*LAGMAX+1,
     +       CCOV(1,1,1), CCOV(1,2,2), CCOV(1,1,2), CCOV(1,2,1), 101,
     +       RHOC, SDRHOC, 1, LYFFT, STAK(WORK), NFFT)
C
C         CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
C
          CALL CCFOUT (1, Y1MEAN, Y1SD, N, N, 2, Y2MEAN, Y2SD, N,
     +       N, LAGMAX, 2*LAGMAX+1, RHOC, SDRHOC, .FALSE., NDUM, NDUM,
     +       1, 0.0D0, 0.0D0, .FALSE.)
        END IF
C
        CALL STKCLR(NALL0)
      END IF
C
      IF (IERR.NE.0) THEN
C
C     PRINT PROPER CALL SEQUENCE AND RETURN
C
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL CCFF (YFFT1, YFFT2, N, LYFFT, LDSTAK)')
      END
*CCFFS
      SUBROUTINE CCFFS (YMFFT, N, M, IYMFFT, LAGMAX,
     +   CCOV, ICCOV, JCCOV, NPRT, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
C     CORRELATIONS AND COVARIANCES OF A MULTIVARIATE SERIES USING THE
C     SINGLETON FFT (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,IYMFFT,JCCOV,LAGMAX,LDSTAK,M,N,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(*),YMFFT(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IFP,INLPPC,IO,IPRT,IYM,J,JNLPPC,K,LDSMIN,LYFFT,NALL0,
     +   NFFT,RHOC,SDRHOC,WORK,YMEAN,YMEANJ,YMEANK,YSD,YSDJ,YSDK
      LOGICAL
     +   ISFFT,ISLONG,NEWPG
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACVFF,CCFER,CCFMNF,CCFOUT,FFTLEN,IPRINT,LDSCMP,STKCLR,
     +   STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  STATEMENT FUNCTIONS
      INTEGER
     +   I2,I3
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCOV(ICCOV, JCCOV, M)
C        THE CROSS COVARIANCE MATRIX.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ICCOV
C        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER INLPPC
C        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
C        IN THE USERS PROGRAM.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
C        BASED ON WHETHER PRINTED OUTPUT IS DESIRED.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     LOGICAL ISFFT
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
C     LOGICAL ISLONG
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
C     INTEGER IYM
C        THE ACTUAL FIRST DIMENSION OF THE MATRIX YM AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER IYMFFT
C        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER I2
C        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN YMFFT
C     INTEGER I3
C        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN CCOV
C     INTEGER J
C        THE INDEX OF -SERIES 1- IN THE ARRAY YMFFT.
C     INTEGER JCCOV
C        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER JNLPPC
C        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
C        IN THE USERS PROGRAM.
C     INTEGER K
C        THE INDEX OF -SERIES 2- IN THE ARRAY YMFFT.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE REQUESTED.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LYFFT
C        THE NUMBER OF LOCATIONS IN EACH COLUMN OF YMFFT ALLOWED FOR
C        THE EXTENDED SERIES.
C     INTEGER M
C        THE NUMBER OF SERIES BEING COMPARED, IE THE
C        NUMBER OF COLUMNS OF DATA IN YMFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
C     INTEGER NDUM(1)
C        A DUMMY DMENSIONED ARRAY.
C     LOGICAL NEWPG
C        AN INDICATOR VARIABLE USED TO DETERMINE WHEN A NEW PAGE
C        IS APPROPRIATE FOR THE OUTPUT.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPEDIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO OUTPUT IS GIVEN.
C     INTEGER RHOC
C        THE STARTING LOCATION IN STAK/DSTAK OF THE ARRAY RHOC.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER SDRHOC
C        THE STARTING LOCATION IN THE WORK AREA FOR SDRHOC.
C     INTEGER WORK
C        THE STARGING LOCATION IN DSTAK OF
C        THE WORK VECTOR NEEDED BY THE FFT.
C     INTEGER YMEAN, YMEANJ, YMEANK
C        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
C        MEANS OF EACH OF THE SERIES, AND THE LOCATION IN
C        THE ARRAY FOR THE MEAN OF THE JTH AND KTH SERIES,
C        RESPECTIVELY.
C     DOUBLE PRECISION YMFFT(IYMFFT, M)
C        THE MATRIX CONTAINING THE OBSERVED TIME SERIES
C     INTEGER YSD, YSDJ, YSDK
C        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
C        STANDARD DEVIATIONS OF EACH OF THE SERIES, AND THE
C        LOCATION IN THE ARRAY FOR THE STANDARD DEVIATION OF
C        THE JTH AND KTH SERIES, RESPECTIVELY.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'C',       'C',       'F',       'F',       'S',       ' '/
C
      I2(I,J) = I + (J-1)*IYMFFT
      I3(I,J,K) = I + (J-1)*ICCOV + (K-1)*JCCOV*ICCOV
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      INLPPC = ICCOV
      IYM = IYMFFT
      JNLPPC = JCCOV
      LYFFT = IYMFFT
      M = 2
      ISFFT = .TRUE.
      ISLONG = .TRUE.
C
      IO = 1
      IF (NPRT .EQ. 0) IO = 0
C
C     SET LENGTH OF EXTENDED SERIES
C
      IF ((N.GE.3) .AND. (LAGMAX.GE.1)) THEN
         CALL FFTLEN (N+LAGMAX, 4, NFFT)
      ELSE
         NFFT = N
      END IF
C
      CALL LDSCMP(3+2*IO, 0, 0, 0, 0, 0, 'D',
     +            2*M+NFFT+IO*(4*LAGMAX+2), LDSMIN)
C
      CALL CCFER(NMSUB, N, LAGMAX, LDSTAK, LDSMIN, ICCOV, JCCOV,
     +  INLPPC, JNLPPC, M, LYFFT, NFFT, IYM, IYMFFT, ISFFT, ISLONG)
C
C     CHECK WHETHER AN ERROR HAS BEEN DETECTED
C
      IF (IERR.EQ.0) THEN
C
C       SET UP THE WORK AREA.
C
        CALL STKSET (LDSTAK, 4)
        NALL0 = STKST(1)
C
        IFP = 4
C
        YMEAN = STKGET(M, IFP)
        YSD = STKGET(M, IFP)
        IF (NPRT.EQ.0) THEN
          RHOC = YSD
          SDRHOC = YSD
        ELSE
          RHOC = STKGET(2*LAGMAX+1, IFP)
          SDRHOC = STKGET(2*LAGMAX+1, IFP)
        END IF
        WORK = STKGET(NFFT, IFP)
C
        IF (IERR.EQ.0) THEN
C
C         BEGIN LOOP FOR COMPUTATIONS
C
          NEWPG = .FALSE.
C
          DO 40 K = 1, M
C
             YMEANK = YMEAN + K - 1
             YSDK = YSD + K - 1
C
             CALL ACVFF (YMFFT(I2(1,K)), N, NFFT, RSTAK(YMEANK),
     +                   CCOV(I3(1,K,K)), LAGMAX, ICCOV, LYFFT,
     +                   RSTAK(WORK), NFFT)
             RSTAK(YSDK) = SQRT(CCOV(I3(1,K,K)) * N / (N - 1))
C
             IF ((K-1).LE.0) GO TO 40
C
             DO 30 J = 1, (K-1)
C
                YMEANJ = YMEAN + J - 1
                YSDJ = YSD + J - 1
C
                CALL CCFMNF(YMFFT(I2(1,J)), YMFFT(I2(1,K)),
     +                      N, NFFT, LAGMAX, 2*LAGMAX+1,
     +                      CCOV(I3(1,J,J)), CCOV(I3(1,K,K)),
     +                      CCOV(I3(1,J,K)), CCOV(I3(1,K,J)),
     +                      ICCOV, RSTAK(RHOC), RSTAK(SDRHOC), NPRT,
     +                      LYFFT, RSTAK(WORK), NFFT)
C
                IF (NPRT .EQ. 0) GO TO 30
C
C         CALL ROUTINE TO PRINT OUT CORRELATIONS
C
                CALL CCFOUT (J, RSTAK(YMEANJ), RSTAK(YSDJ), N, N, K,
     +             RSTAK(YMEANK), RSTAK(YSDK), N, N, LAGMAX, 2*LAGMAX+1,
     +             RSTAK(RHOC), RSTAK(SDRHOC), .FALSE., NDUM, NDUM, 1,
     +             0.0D0, 0.0D0, NEWPG)
C
                NEWPG = .TRUE.
C
   30        CONTINUE
   40     CONTINUE
        END IF
C
        CALL STKCLR(NALL0)
      END IF
C
      IF (IERR.NE.0) THEN
C
C     PRINT PROPER CALL SEQUENCE AND RETURN
C
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL CCFFS (YMFFT, N, M, IYMFFT,'/
     + '      +            LAGMAX, CCOV, ICCOV, JCCOV, NPRT, LDSTAK)')
      END
*CCFLST
      SUBROUTINE CCFLST (RHOC, SDRHOC, NLPP12, NLPP21, LAGMAX, LCCOV,
     +   NCC, IFMISS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE ACTUALLY LISTS THE CROSS CORRELATIONS AND THEIR
C     STANDARD ERRORS, AND MISCELLANEOUS SUMMARY INFORMATION.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LAGMAX,LCCOV,NCC
      LOGICAL
     +   IFMISS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RHOC(*),SDRHOC(*)
      INTEGER
     +   NLPP12(*),NLPP21(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,I1,IMAX,IMIN,IPRT,K,K0,K1,LAGN,NPERL
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RLST(12),SDRLST(12)
      INTEGER
     +   LAG(12),NLPLST(12)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN,MOD
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     LOGICAL IFMISS
C        THE INDICATOR VARIABLE USED TO DETERMINE
C        WHETHER THE INPUT SERIES HAS MISSING DATA OR NOT.
C     INTEGER IMAX, IMIN
C        THE INDEX VALUES OF THE FIRST AND LAST OBSERVATION
C        TO BE PRINTED PER LINE
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT
C     INTEGER I1
C        AN INDEX VARIABLE.
C     INTEGER K, K0, K1
C        INDEX VARIABLES.
C     INTEGER LAG(12)
C        THE LAG VALUE OF THE CORRELATION BEING PRINTED.
C     INTEGER LAGMAX
C        THE LARGEST LAG VALUE TO BE USED.
C     INTEGER LAGN
C        THE NUMBER OF LAG VALUES TO BE PRINTED PER LINE.
C     INTEGER LCCOV
C        THE NUMBER OF LOCATIONS ALLOWED FOR STORING THE NLPPC.
C     INTEGER NCC
C        THE NUMBER OF CROSS CORRELATIONS COMPUTED (FROM -LAGMAX
C        TO +LAGMAX).
C     INTEGER NLPLST(12)
C        THE ARRAY WHICH CONTAINS THE VALUES OF NLPPC TO BE PRINTED
C        ON EACH LINE, ORDERED PROPERLY.
C     INTEGER NLPP12(LCCOV), NLPP21(LCCOV)
C        THE NUMBER OF LAGGED PRODUCT PAIRS USED TO COMPUTE EACH
C        CCVF AT EACH LAG.
C     INTEGER NPERL
C        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
C     DOUBLE PRECISION RHOC(NCC)
C        THE ARRAY IN WHICH THE AUTOCORRELATIONS OR PARTIAL
C        AUTOCORRELATIONS WILL BE PASSED TO THIS ROUTINE.
C     DOUBLE PRECISION RLST(12)
C        THE ARRAY WHICH CONTAINS THE VALUES OF RHO TO BE PRINTED
C        ON EACH LINE, ORDERED PROPERLY.
C     DOUBLE PRECISION SDRHOC(NCC)
C        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
C        ARE STORED
C     DOUBLE PRECISION SDRLST(12)
C        THE ARRAY WHICH CONTAINS THE VALUES OF SDRHO TO BE PRINTED
C        ON EACH LINE, ORDERED PROPERLY.
C
C
      CALL IPRINT(IPRT)
      NPERL = 12
C
      K0 = LAGMAX + 1
C
      LAGN = MOD(LAGMAX, NPERL)
      IF (LAGN .EQ. 0) LAGN = NPERL
      I1 = LAGN + 1
C
      DO 20 I = I1, K0, NPERL
         DO 10 K = 1, LAGN
            LAG(K) = I - K0 - K
            K1 = I - K
            RLST(K) = RHOC(K1)
            SDRLST(K) = SDRHOC(K1)
            IF (.NOT. IFMISS) GO TO 10
            K1 = K0 - K1
            NLPLST(K) = NLPP21(K1+1)
   10    CONTINUE
         WRITE(IPRT, 1000) (LAG(K), K = 1, LAGN)
         WRITE(IPRT, 1001) (RLST(K), K = 1, LAGN)
         WRITE(IPRT, 1002) (SDRLST(K), K = 1, LAGN)
         IF (IFMISS) WRITE(IPRT, 1003) (NLPLST(K), K = 1, LAGN)
         LAGN = NPERL
   20 CONTINUE
C
      LAG(1) = 0
      WRITE(IPRT, 1000) LAG(1)
      WRITE(IPRT, 1001) RHOC(K0)
      WRITE(IPRT, 1002) SDRHOC(K0)
      IF (IFMISS) WRITE(IPRT, 1003) NLPP12(1)
C
      DO 40 I = 1, LAGMAX, NPERL
         IMIN = I + K0
         IMAX = MIN(IMIN + NPERL - 1, 2*LAGMAX+1)
         LAGN = IMAX - IMIN + 1
         DO 30 K = 1, LAGN
            LAG(K) = I - 1 + K
   30    CONTINUE
         WRITE(IPRT, 1000) (LAG(K), K = 1, LAGN)
         WRITE(IPRT, 1001) (RHOC(K), K = IMIN, IMAX)
         WRITE(IPRT, 1002) (SDRHOC(K), K = IMIN, IMAX)
         IF (.NOT. IFMISS) GO TO 40
         IMIN = I
         IMAX = MIN(I + NPERL - 1, LAGMAX)
         WRITE (IPRT,1003) (NLPP12(K+1), K=IMIN,IMAX)
   40 CONTINUE
C
      FPLM = D1MACH(2)
C
      IF (SDRHOC(1).EQ.FPLM .OR. SDRHOC(2*LAGMAX+1).EQ.FPLM)
     +   WRITE(IPRT, 1004) FPLM
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/19H LAG               , 12(1X, I6))
 1001 FORMAT( 19H CCF               , 12(2X, F5.2))
 1002 FORMAT( 19H STANDARD ERROR    , 12(2X, F5.2))
 1003 FORMAT( 19H NO. OF OBS. USED  , 12(1X, I6))
 1004 FORMAT(///5X, F5.2, 38H INDICATES VALUE COULD NOT BE COMPUTED,
     +   21H DUE TO MISSING DATA.)
      END
*CCFM
      SUBROUTINE CCFM (Y1, Y1MISS, Y2, Y2MISS, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
C     CORRELATIONS OF TWO TIME SERIES WITH MISSING OBSERVATIONS
C     (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   Y1MISS,Y2MISS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y1(*),Y2(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   Y1MEAN,Y1SD,Y2MEAN,Y2SD
      INTEGER
     +   ICCOV,INLPPC,IPRT,IYM,IYMFFT,JCCOV,JNLPPC,LAGMAX,LDSMIN,
     +   LDSTAK,LGLST1,LGLST2,LYFFT,M,NFFT,NUSED1,NUSED2
      LOGICAL
     +   ISFFT,ISLONG
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCOV(101,2,2),RHOC(201),SDRHOC(201)
      INTEGER
     +   NLPPC(101,2,2)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACVFM,CCFER,CCFMNM,CCFOUT,IPRINT,SETLAG
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN,SQRT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCOV(101, 2, 2)
C        THE ARRAY USED FOR THE CCVF ESTIMATES.
C     INTEGER ICCOV
C        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER INLPPC
C        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
C        IN THE USERS PROGRAM.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     LOGICAL ISFFT
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
C     LOGICAL ISLONG
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
C     INTEGER IYM
C        THE ACTUAL FIRST DIMENSION OF THE MATRIX YM AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER IYMFFT
C        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER JCCOV
C        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER JNLPPC
C        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
C        IN THE USERS PROGRAM.
C     INTEGER LAGMAX
C        THE NUMBER OF AUTOCORRELATIONS DESIRED.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LGLST1, LGLST2
C        THE LAG VALUE OF THE LAST ACVF WHICH COULD BE COMPUTED
C        FOR SERIES 1 AND 2, RESPECTIVELY, BEFORE MISSING DATA
C        CAUSED A MISSING ACVF.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER M
C        THE NUMBER OF SERIES BEING COMPARED, IE THE
C        NUMBER OF COLUMNS OF DATA IN YM.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     INTEGER NLPPC(101, 2, 2)
C        THE NUMBER OF LAGGED PRODUCT PAIRS USED TO COMPUTE THE CCVF.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C     INTEGER NUSED1, NUSED2
C        THE NUMBER OF ACTIVE (NON MISSING) OBSERVATIONS IN SERIES
C        1 AND 2, RESPECTIVELY.
C     DOUBLE PRECISION RHOC(201)
C        THE CCF ESTIMATES.
C     DOUBLE PRECISION SDRHOC(201)
C        THE ARRAY CONTAINING THE SD OF THE CCFM.
C     DOUBLE PRECISION Y1(N), Y1MEAN, Y1MISS, Y1SD
C        THE FIRST SERIES, AND ITS MEAN, MISSING VALUE CODE AND
C        STANDARD DEVIATION.
C     DOUBLE PRECISION Y2(N), Y2MEAN, Y2MISS, Y2SD
C        THE SECOND SERIES, AND ITS MEAN, MISSING VALUE CODE AND
C        STANDARD DEVIATION.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'C',       'C',       'F',       'M',       ' ',       ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      ICCOV = 101
      INLPPC = 101
      IYM = N
      JCCOV = 2
      JNLPPC = 2
      LDSMIN = 0
      LDSTAK = 0
      LAGMAX = 1
      LYFFT = N + LAGMAX
      IYMFFT = LYFFT
      M = 2
      NFFT = N
      ISFFT = .FALSE.
      ISLONG = .FALSE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL CCFER(NMSUB, N, LAGMAX, LDSTAK, LDSMIN, ICCOV, JCCOV,
     +  INLPPC, JNLPPC, M, LYFFT, NFFT, IYM, IYMFFT, ISFFT, ISLONG)
C
C     CHECK WHETHER AN ERROR HAS BEEN DETECTED
C
      IF (IERR.EQ.0) THEN
C
C       SET THE MAXIMUM LAG VALUE TO BE USED.
C
        CALL SETLAG (N, LAGMAX)
C
C       COMPUTE THE SERIES ACVF AND SD
C
        CALL ACVFM (Y1, Y1MISS, N, Y1MEAN, CCOV(1,1,1), LAGMAX, LGLST1,
     +     NLPPC(1,1,1), 101)
C
        NUSED1 = NLPPC(1,1,1)
        Y1SD = SQRT(CCOV(1,1,1) * N / (NUSED1-1))
C
        CALL ACVFM (Y2, Y2MISS, N, Y2MEAN, CCOV(1,2,2), LAGMAX, LGLST2,
     +     NLPPC(1,2,2), 101)
C
        NUSED2 = NLPPC(1,2,2)
        Y2SD = SQRT(CCOV(1,2,2) * N / (NUSED2-1))
C
C       CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
C
        IF (CCOV(1,1,1)*CCOV(1,2,2) .NE. 0.0D0)
     +    CALL CCFMNM (Y1, Y1MISS, Y2, Y2MISS, N, LAGMAX, 201,
     +    CCOV(1,1,1),
     +    CCOV(1,2,2), CCOV(1,1,2), CCOV(1,2,1), 101, NLPPC(1,1,1),
     +    NLPPC(1,2,2), NLPPC(1,1,2), NLPPC(1,2,1), 101, Y1MEAN, Y2MEAN,
     +    RHOC, SDRHOC, 1, MIN(LGLST1, LGLST2))
C
C       CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
C
        CALL CCFOUT (1, Y1MEAN, Y1SD, N, NUSED1, 2, Y2MEAN, Y2SD, N,
     +     NUSED2, LAGMAX, 201, RHOC, SDRHOC, .TRUE., NLPPC(1,1,2),
     +     NLPPC(1,2,1), 101, Y1MISS, Y2MISS, .FALSE.)
      END IF
C
      IF (IERR.NE.0) THEN
C
C     PRINT PROPER CALL SEQUENCE AND RETURN
C
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   44H       CALL CCFM (Y1, YMISS1, Y2, YMISS2, N))
      END
*CCFMN
      SUBROUTINE CCFMN (Y1, Y2, N, LAGMAX, NCC, CCOV11, CCOV22, CCOV12,
     +   CCOV21, LCCOV, Y1MEAN, Y2MEAN, RHOC, SDRHOC, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN SUBROUTINE FOR COMPUTING CROSS CORRELATIONS AND
C     THEIR STANDARD ERRORS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   Y1MEAN,Y2MEAN
      INTEGER
     +   LAGMAX,LCCOV,N,NCC,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV11(LCCOV),CCOV12(LCCOV),CCOV21(LCCOV),CCOV22(LCCOV),
     +   RHOC(NCC),SDRHOC(NCC),Y1(N),Y2(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FAC
      INTEGER
     +   I,I0,IM,IP
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CCFSD,CCVF
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCOV11(LCCOV)
C        THE ARRAY IN WHICH THE AUTOCOVARIANCE FUNCTION ESTIMATES
C        FOR THE FIRST SERIES IS STORED.
C     DOUBLE PRECISION CCOV12(LCCOV), CCOV21(LCCOV)
C        THE ARRAYS IN WHICH THE CROSS COVARIANCE FUNCTION
C        ESTIMATES FOR THE FIRST SERIES LAGGED BEHIND THE SECOND
C        AND VISA VERSA, ARE STORED.
C     DOUBLE PRECISION CCOV22(LCCOV)
C        THE ARRAY IN WHICH THE AUTOCOVARIANCE FUNCTION ESTIMATES
C        FOR THE SECOND SERIES IS STORED.
C     DOUBLE PRECISION FAC
C        THE INVERSE OF THE SQUARE ROOT OF THE PRODUCT OF THE
C        AUTOCOVARIANCES AT LAG ZERO.
C     INTEGER I
C        THE INDEXING VARIABLE FOR THE LAG VALUE.
C     INTEGER  IM, IP, I0
C        THE LOCATIONS IN THE CCF RELATED ARRAYS
C        OF THE LAG -I, I, AND 0, RESPECTIVELY.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE AT WHICH THE CCVF IS TO BE COMPUTED.
C     INTEGER LCCOV
C        THE DIMENSION OF THE COVARIANCE RELATED ARRAYS.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
C     INTEGER NCC
C        THE NUMBER OF CCF COMPUTED.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO CONTROL COMPUTATIONS NEEDED
C        ONLY FOR PRINTED OUTPUT.
C     DOUBLE PRECISION RHOC(NCC)
C        THE ARRAY IN WHICH THE CROSS CORRELATIONS ARE STORED
C     DOUBLE PRECISION SDRHOC(NCC)
C        THE ARRAY CONTAINING THE STD. ERRORS OF THE CROSS CORRELATIONS.
C        ARE STORED
C     DOUBLE PRECISION Y1(N), Y1MEAN
C        THE FIRST SERIES, AND ITS MEAN.
C     DOUBLE PRECISION Y2(N), Y2MEAN
C        THE SECOND SERIES, AND ITS MEAN.
C
C     COMPUTE THE CROSS CORRELATIONS.
C
      CALL CCVF(Y1, Y2, N, LAGMAX, Y1MEAN, Y2MEAN, CCOV12, CCOV21,
     +   LCCOV)
C
      IF (NPRT .EQ. 0 .OR. CCOV11(1)*CCOV22(1) .EQ. 0.0D0) RETURN
C
      FAC = 1.0D0 / SQRT(CCOV11(1) * CCOV22(1))
C
      I0 = LAGMAX + 1
      RHOC(I0) = CCOV12(1) * FAC
      DO 10 I = 1, LAGMAX
         IP = I0 + I
         RHOC(IP) = CCOV12(I+1) * FAC
C
         IM = I0 - I
         RHOC(IM) = CCOV21(I+1) * FAC
   10 CONTINUE
C
C     COMPUTE STANDARD ERROR OF THE CROSSCORRELATIONS.
C
      CALL CCFSD (CCOV11, CCOV22, SDRHOC, LAGMAX, NCC, N, LCCOV)
C
      RETURN
      END
*CCFMNF
      SUBROUTINE CCFMNF (Y1, Y2, N, NFFT, LAGMAX, NCC, CCOV11, CCOV22,
     +   CCOV12, CCOV21, LCCOV, RHOC, SDRHOC, NPRT, LYFFT, WORK, LWORK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN SUBROUTINE FOR COMPUTING CROSS CORRELATIONS AND
C     THEIR STANDARD ERRORS OF A TIME SERIES USING A FFT.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LAGMAX,LCCOV,LWORK,LYFFT,N,NCC,NFFT,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV11(LCCOV),CCOV12(LCCOV),CCOV21(LCCOV),CCOV22(LCCOV),
     +   RHOC(NCC),SDRHOC(NCC),WORK(LWORK),Y1(LYFFT),Y2(LYFFT)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FAC
      INTEGER
     +   I,I0,IM,IP
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CCFSD,CCVFF
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCOV11(LCCOV)
C        THE ARRAY IN WHICH THE AUTOCOVARIANCE FUNCTION ESTIMATES
C        FOR THE FIRST SERIES IS STORED.
C     DOUBLE PRECISION CCOV12(LCCOV), CCOV21(LCCOV)
C        THE ARRAYS IN WHICH THE CROSS COVARIANCE FUNCTION
C        ESTIMATES FOR THE FIRST SERIES LAGGED BEHIND THE SECOND
C        AND VISA VERSA, ARE STORED.
C     DOUBLE PRECISION CCOV22(LCCOV)
C        THE ARRAY IN WHICH THE AUTOCOVARIANCE FUNCTION ESTIMATES
C        FOR THE SECOND SERIES IS STORED.
C     DOUBLE PRECISION FAC
C        THE INVERSE OF THE SQUARE ROOT OF THE PRODUCT OF THE
C        AUTOCOVARIANCES AT LAG ZERO.
C     INTEGER I
C        THE INDEXING VARIABLE FOR THE LAG VALUE.
C     INTEGER  IM, IP, I0
C        THE LOCATIONS IN THE CCF RELATED ARRAYS
C        OF THE LAG -I, I, AND 0, RESPECTIVELY.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LCCOV
C        THE DIMENSION OF THE COVARANCE ARRAYS.
C     INTEGER LWORK
C        THE DIMENSION OF THE WORK ARRAY.
C     INTEGER LYFFT
C        THE DIMENSION OF THE DATA ARRAYS.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
C     INTEGER NCC
C        THE NUMBER OF CROSS CORRELATIONS COMPUTED.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO CONTROL COMPUTATIONS NEEDED
C        ONLY FOR PRINTED OUTPUT.
C     DOUBLE PRECISION RHOC(NCC)
C        THE ARRAY IN WHICH THE CROSS CORRELATIONS ARE STORED
C     DOUBLE PRECISION SDRHOC(NCC)
C        THE ARRAY CONTAINING THE STD. ERRORS OF THE CROSS CORRELATIONS.
C        ARE STORED.
C     DOUBLE PRECISION WORK(LWORK)
C        THE WORK ARRAY.
C     DOUBLE PRECISION Y1(LYFFT), Y2(LYFFT)
C        THE VECTORS CONTAINING THE OBSERVED SERIES
C
C     COMPUTE THE CROSS CORRELATIONS.
C
      CALL CCVFF (Y1, Y2, N, NFFT, LAGMAX, CCOV12, CCOV21, LCCOV, LYFFT,
     +   WORK, LWORK)
C
      IF (NPRT .EQ. 0 .OR. CCOV11(1)*CCOV22(1) .EQ. 0.0D0) RETURN
C
      FAC = 1.0D0 / SQRT(CCOV11(1) * CCOV22(1))
C
      I0 = LAGMAX + 1
      RHOC(I0) = CCOV12(1) * FAC
      DO 10 I = 1, LAGMAX
         IP = I0 + I
         RHOC(IP) = CCOV12(I+1) * FAC
C
         IM = I0 - I
         RHOC(IM) = CCOV21(I+1) * FAC
   10 CONTINUE
C
C     COMPUTE STANDARD ERROR OF THE CROSSCORRELATIONS.
C
      CALL CCFSD (CCOV11, CCOV22, SDRHOC, LAGMAX, NCC, N, LCCOV)
C
      RETURN
      END
*CCFMNM
      SUBROUTINE CCFMNM (Y1, Y1MISS, Y2, Y2MISS, N, LAGMAX, NCC,
     +   CCOV11, CCOV22, CCOV12, CCOV21, ICCOV, NLPP11, NLPP22,
     +   NLPP12, NLPP21, INLPPC, Y1MEAN, Y2MEAN, RHOC, SDRHOC, NPRT,
     +   LAGLST)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN SUBROUTINE FOR COMPUTING CROSS CORRELATIONS AND
C     THEIR STANDARD ERRORS WHEN MISSING DATA ARE INVOLVED.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   Y1MEAN,Y1MISS,Y2MEAN,Y2MISS
      INTEGER
     +   ICCOV,INLPPC,LAGLST,LAGMAX,N,NCC,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV11(ICCOV),CCOV12(ICCOV),CCOV21(ICCOV),CCOV22(ICCOV),
     +   RHOC(NCC),SDRHOC(NCC),Y1(N),Y2(N)
      INTEGER
     +   NLPP11(INLPPC),NLPP12(INLPPC),NLPP21(INLPPC),
     +   NLPP22(INLPPC)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FAC,FPLM
      INTEGER
     +   I,I0,IM,IP
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CCFSDM,CCVFM
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCOV11(ICCOV), CCOV12(ICCOV)
C     DOUBLE PRECISION CCOV21(ICCOV), CCOV22(ICCOV)
C        THE ARRAY CONTAINING THE AUTOCOVARIANCE AND CROSS COVARIANCE
C        ESTIMATES FOR SERIES 1 AND 2.
C     DOUBLE PRECISION FAC
C        THE INVERSE OF THE SQUARE ROOT OF THE PRODUCT OF THE
C        AUTOCOVARIANCES AT LAG ZERO.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER I
C        THE INDEXING VARIABLE FOR THE LAG.
C     INTEGER ICCOV
C        THE DIMENSION OF THE COVARIANCE VECTORS.
C     INTEGER IM
C        THE LOCATIONS IN THE VARIOUS CCF RELATED ARRAYS OF LAG -I.
C     INTEGER INLPPC
C        THE DIMENSION OF THE LAGGED PRODUCT PAIR COUNT VECTORS.
C     INTEGER IP
C        THE LOCATION IF THE VARIOUS CCF RELATED ARRAYS OF LAG I.
C     INTEGER I0
C        THE LOCATION IF THE VARIOUS CCF RELATED ARRAYS OF LAG 0.
C     INTEGER LAGLST
C        THE LAST LAG BEFORE MISSING DATA CAUSED THE ACVF OF EITHER
C        SERIES 1 OR 2 NOT TO BE COMPUTED.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
C     INTEGER NCC
C        THE NUMBER OF CROSS CORRELATIONS TO BE COMPUTED.
C     INTEGER NLPP11(INLPPC), NLPP12(INLPPC), NLPP21(INLPPC),
C    +        NLPP22(INLPPC)
C        THE NUMBERS OF LAGGED PRODUCT PAIRS USED TO COMPUTE
C        THE AUTOCOVARIANCE AND CROSS COVARIANCE ESTIMATES.
C     INTEGER NPRT
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT.
C     DOUBLE PRECISION RHOC(NCC)
C        THE ARRAY IN WHICH THE AUTO AND CROSS CORRELATIONS ARE STORED
C     DOUBLE PRECISION SDRHOC(NCC)
C        THE ARRAY CONTAINING THE STD. ERRORS OF THE CROSS CORRELATIONS.
C        ARE STORED
C     DOUBLE PRECISION Y1(N), Y1MEAN, Y1MISS
C        THE FIRST SERIES, AND ITS MEAN, AND MISSING VALUE CODE.
C     DOUBLE PRECISION Y2(N), Y2MEAN, Y2MISS
C        THE SECOND SERIES, AND ITS MEAN, AND MISSING VALUE CODE.
C
      FPLM = D1MACH(2)
C
C     COMPUTE AUTOCORRELATIONS AND STANDARD DEVIATION OF THE SERIES.
C
      CALL CCVFM(Y1, Y1MISS, Y2, Y2MISS, N, LAGMAX, Y1MEAN, Y2MEAN,
     +   CCOV12, CCOV21, ICCOV, NLPP12, NLPP21)
C
      IF (NPRT .EQ. 0 .OR. NLPP11(1) .EQ. 0) RETURN
      IF (CCOV11(1) *CCOV22(1) .EQ. 0.0D0) RETURN
C
      FAC = 1.0D0 / SQRT(CCOV11(1) * CCOV22(1))
C
      I0 = LAGMAX + 1
      RHOC(I0) = FPLM
      IF (NLPP12(1).GE.1) RHOC(I0) = CCOV12(1) * FAC
C
      DO 10 I = 1, LAGMAX
         IP = I0 + I
         RHOC(IP) = FPLM
         IF (NLPP12(I+1).GE.1) RHOC(IP) = CCOV12(I+1) * FAC
C
         IM = I0 - I
         RHOC(IM) = FPLM
         IF (NLPP21(I+1).GE.1) RHOC(IM) = CCOV21(I+1) * FAC
   10 CONTINUE
C
C     COMPUTE STANDARD ERROR OF AUTOCORRELATIONS.
C
      CALL CCFSDM (CCOV11, CCOV22, SDRHOC, LAGMAX, NCC, LAGLST, N,
     +   NLPP12, NLPP21, ICCOV, INLPPC)
C
      RETURN
      END
*CCFMS
      SUBROUTINE CCFMS (YM, YMMISS, N, M, IYM, LAGMAX, CCOV,
     +   CMISS, ICCOV, JCCOV, NLPPC, INLPPC, JNLPPC, NPRT, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
C     CORRELATIONS AND COVARIANCES OF A MULTIVARIATE SERIES (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CMISS
      INTEGER
     +   ICCOV,INLPPC,IYM,JCCOV,JNLPPC,LAGMAX,LDSTAK,M,N,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(*),YM(*),YMMISS(*)
      INTEGER
     +   NLPPC(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,IFP,IO,IPRT,IYMFFT,J,K,LDSMIN,LGLST,LGLSTJ,LGLSTK,LYFFT,
     +   NALL0,NFFT,RHOC,SDRHOC,YMEAN,YMEANJ,YMEANK,YSD,YSDJ,YSDK
      LOGICAL
     +   ISFFT,ISLONG,NEWPG
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      INTEGER
     +   STKGET,STKST
      EXTERNAL D1MACH,STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACVFM,CCFER,CCFMNM,CCFOUT,IPRINT,LDSCMP,STKCLR,STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN,SQRT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  STATEMENT FUNCTIONS
      INTEGER
     +   I2,I3C,I3N
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCOV(ICCOV, JCCOV, M)
C        THE CROSS COVARIANCE MATRIX.
C     DOUBLE PRECISION CMISS
C        THE MISSING VALUE CODE FOR THE CCVF ESTIMATES.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER ICCOV
C        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER INLPPC
C        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
C        IN THE USERS PROGRAM.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
C        BASED ON WHETHER PRINTED OUTPUT IS DESIRED.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     LOGICAL ISFFT
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
C     LOGICAL ISLONG
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IYM
C        THE ACTUAL FIRST DIMENSION OF THE MATRIX YM AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER IYMFFT
C        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER I2
C        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN YM
C     INTEGER I3C
C        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN CCOV
C     INTEGER I3N
C        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN NLPPC
C     INTEGER J
C        THE INDEX OF -SERIES 1- IN THE ARRAY YM.
C     INTEGER JCCOV
C        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER JNLPPC
C        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
C        IN THE USERS PROGRAM.
C     INTEGER K
C        THE INDEX OF -SERIES 2- IN THE ARRAY YM.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE REQUESTED.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LGLST, LGLSTJ, LGLSTK
C        THE STARTING LOCATION IN ISTAK FOR THE ARRAY LGLST,
C        AND THE LOCATIONS IN LGLST IN EHICH THE NUMBER OF THE
C        LAG OF THE LAST ACVF WHICH COULD BE COMPUTED FOR SERIES
C        J AND K, RESPECTIVELY, BEFORE A MISSNG ACVF (DUE TO MISSING
C        DATA).
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER M
C        THE NUMBER OF SERIES BEING COMPARED, IE THE
C        NUMBER OF COLUMNS OF DATA IN YM.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
C     LOGICAL NEWPG
C        AN INDICATOR VARIABLE USED TO DETERMINE WHEN A NEW PAGE
C        IS APPROPRIATE FOR THE OUTPUT.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     INTEGER NLPPC(INLPPC, JNLPPC, M)
C        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
C        USED TO COMPUTE EACH ACVF ESTIMATE.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPEDIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO OUTPUT IS GIVEN.
C     INTEGER RHOC
C        THE STARTING LOCATION IN DSTAK OF THE ARRAY RHOC.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER SDRHOC
C        THE STARTING LOCATION IN THE WORK AREA FOR SDRHOC.
C     DOUBLE PRECISION YM(IYM, M)
C        THE MATRIX CONTAINING THE OBSERVED TIME SERIES
C     INTEGER YMEAN, YMEANJ, YMEANK
C        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
C        MEANS OF EACH OF THE SERIES, AND THE LOCATION IN
C        THE ARRAY FOR THE MEAN OF THE JTH AND KTH SERIES,
C        RESPECTIVELY.
C     DOUBLE PRECISION YMMISS(M)
C        THE MISSING VALUE CODES FOR EACH OF THE SERIES IN YM.
C     INTEGER YSD, YSDJ, YSDK
C        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
C        STANDARD DEVIATIONS OF EACH OF THE SERIES, AND THE
C        LOCATION IN THE ARRAY FOR THE STANDARD DEVIATION OF
C        THE JTH AND KTH SERIES, RESPECTIVELY.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'C',       'C',       'F',       'M',       'S',       ' '/
C
      I2(I,J) = I + (J-1)*IYM
      I3C(I,J,K) = I + (J-1)*ICCOV + (K-1)*JCCOV*ICCOV
      I3N(I,J,K) = I + (J-1)*INLPPC + (K-1)*JNLPPC*INLPPC
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      LYFFT = N + LAGMAX
      IYMFFT = LYFFT
      NFFT = N
      ISFFT = .FALSE.
      ISLONG = .TRUE.
C
      IO = 1
      IF (NPRT .EQ. 0) IO = 0
C
      CALL LDSCMP(3+2*IO, 0, M, 0, 0, 0, 'D',
     +            2*M+IO*(4*LAGMAX+2), LDSMIN)
C
      CALL CCFER(NMSUB, N, LAGMAX, LDSTAK, LDSMIN, ICCOV, JCCOV,
     +  INLPPC, JNLPPC, M, LYFFT, NFFT, IYM, IYMFFT, ISFFT, ISLONG)
C
C     CHECK WHETHER AN ERROR HAS BEEN DETECTED
C
      IF (IERR.EQ.0) THEN
C
        FPLM = D1MACH(2)
C
C       SET UP THE WORK AREA.
C
        CALL STKSET (LDSTAK, 4)
        NALL0 = STKST(1)

        IFP = 4
C
        YMEAN = STKGET(M, IFP)
        YSD = STKGET(M, IFP)
        LGLST = STKGET(M, 2)
        IF (NPRT.EQ.0) THEN
          RHOC = YSD
          SDRHOC = YSD
        ELSE
          RHOC = STKGET(2*LAGMAX+1, IFP)
          SDRHOC = STKGET(2*LAGMAX+1, IFP)
        END IF
C
        IF (IERR.EQ.0) THEN
C
C         BEGIN LOOP FOR COMPUTATIONS
C
          NEWPG = .FALSE.
C
          DO 40 K = 1, M
C
             YMEANK = YMEAN + K - 1
             YSDK = YSD + K - 1
             LGLSTK = LGLST + K - 1
C
             CALL ACVFM (YM(I2(1,K)), YMMISS(K), N, RSTAK(YMEANK),
     +                   CCOV(I3C(1,K,K)), LAGMAX, ISTAK(LGLSTK),
     +                   NLPPC(I3N(1,K,K)), LAGMAX+1)
             RSTAK(YSDK) = SQRT(CCOV(I3C(1,K,K)) * N / (N - 1))
C
             IF ((K-1).LE.0) GO TO 40
C
             DO 30 J = 1, (K-1)
C
                YMEANJ = YMEAN + J - 1
                YSDJ = YSD + J - 1
                LGLSTJ = LGLST + J - 1
C
                CALL CCFMNM (YM(I2(1,J)), YMMISS(J),
     +                       YM(I2(1,K)), YMMISS(K),
     +                       N,  LAGMAX, 2*LAGMAX+1,
     +                       CCOV(I3C(1,J,J)), CCOV(I3C(1,K,K)),
     +                       CCOV(I3C(1,J,K)), CCOV(I3C(1,K,J)), ICCOV,
     +                       NLPPC(I3N(1,J,J)), NLPPC(I3N(1,K,K)),
     +                       NLPPC(I3N(1,J,K)), NLPPC(I3N(1,K,J)),
     +                       INLPPC,
     +                       RSTAK(YMEANJ), RSTAK(YMEANK), RSTAK(RHOC),
     +                       RSTAK(SDRHOC),
     +                       NPRT, MIN(ISTAK(LGLSTJ), ISTAK(LGLSTK)))
C
                IF (NPRT .EQ. 0) GO TO 30
C
C         CALL ROUTINE TO PRINT OUT CORRELATIONS
C
                CALL CCFOUT (J, RSTAK(YMEANJ), RSTAK(YSDJ), N,
     +                       NLPPC(I3N(1,J,J)), K, RSTAK(YMEANK),
     +                       RSTAK(YSDK), N, NLPPC(I3N(1,K,K)), LAGMAX,
     +                       2*LAGMAX+1, RSTAK(RHOC), RSTAK(SDRHOC),
     +                       .TRUE., NLPPC(I3N(1,J,K)),
     +                       NLPPC(I3N(1,K,J)),
     +                       INLPPC, YMMISS(J), YMMISS(K), NEWPG)
C
                NEWPG = .TRUE.
C
   30        CONTINUE
   40     CONTINUE
C
          CMISS = FPLM
        END IF
C
        CALL STKCLR(NALL0)
      END IF
C
      IF (IERR.NE.0) THEN
C
C     PRINT PROPER CALL SEQUENCE AND RETURN
C
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL CCFMS (YM, YMMISS, N, M, IYM,'/
     +  '      +            LAGMAX, CCOV, CMISS, ICCOV, JCCOV,'/
     +  '      +            NLPPC, INLPPC, JNLPPC, NPRT, LDSTAK)')
      END
*CCFOUT
      SUBROUTINE CCFOUT (J, YMEANJ, YSDJ, NJ, NUSEDJ, K, YMEANK, YSDK,
     +   NK, NUSEDK, LAGMAX, NCC, RHOC, SDRHOC, IFMISS, NLPP12,
     +   NLPP21, LCCOV, YMISSJ, YMISSK, NEWPG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRINTS THE CROSS CORRELATIONS AND THEIR
C     STANDARD ERRORS, AND MISCELLANEOUS SUMMARY INFORMATION.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMEANJ,YMEANK,YMISSJ,YMISSK,YSDJ,YSDK
      INTEGER
     +   J,K,LAGMAX,LCCOV,NCC,NJ,NK,NUSEDJ,NUSEDK
      LOGICAL
     +   IFMISS,NEWPG
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RHOC(*),SDRHOC(*)
      INTEGER
     +   NLPP12(*),NLPP21(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM,PMISSJ,PMISSK
      INTEGER
     +   IPRT,NMISSJ,NMISSK
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      INTEGER
     +   ISYM(1)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CCFLST,IPRINT,VERSP,VPMN
C
C  INTRINSIC FUNCTIONS
      INTRINSIC DBLE
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     LOGICAL IFMISS
C        THE INDICATOR VARIABLE USED TO DETERMINE
C        WHETHER THE INPUT SERIES HAS MISSING DATA OR NOT.
C     INTEGER IPRT
C        THE UNIT NUMBER OF THE DEVICE USED FOR PRINTED
C        OUTPUT.
C     INTEGER ISYM(1)
C        A DUMMY ARRAY.
C     INTEGER J, K
C        THE SUBSCRIPT VALUES OF THE TWO SERIES BEING COMPARED.
C     INTEGER LAGMAX
C        THE LARGEST LAG VALUE TO BE USED.
C     INTEGER LCCOV
C        THE NUMBER OF LOCATIONS ALLOWED FOR STORING THE NLPPC.
C     INTEGER NCC
C        THE NUMBER OF CROSS CORRELATIONS COMPUTED (FROM -LAGMAX
C        TO +LAGMAX).
C     LOGICAL NEWPG
C        AN INDICATOR VARIABLE USED TO DETERMINE IF THE OUTPUT SHOULD
C        START ON A NEW PAGE.
C     INTEGER NJ, NK
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NLPP12(LCCOV), NLPP21(LCCOV)
C        THE NUMBER OF LAGGED PRODUCT PAIRS USED TO COMPUTE EACH
C        CCVF AT EACH LAG.
C     INTEGER NMISSJ, NMISSK
C        THE NUMBER OF MISSING VALUES IN EACH SERIES.
C     INTEGER NUSEDJ, NUSEDK
C        THE ACTIVE NUMBER OF OBSERVATIONS IN EACH SERIES.
C     DOUBLE PRECISION PMISSJ, PMISSK
C        THE PERCENT OF MISSING OBSERVATIONS.
C     DOUBLE PRECISION RHOC(NCC)
C        THE ARRAY IN WHICH THE CROSS CORRELATIONS ARE STORED
C     DOUBLE PRECISION SDRHOC(NCC)
C        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
C        ARE STORED
C     DOUBLE PRECISION YMEANJ, YMEANK
C        THE MEAN OF EACH OF THE SERIES.
C     DOUBLE PRECISION YMISSJ, YMISSK
C        THE MISSING VALUE CODE FOR EACH SERIES.
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE CROSS CORRELATIONS.
C     DOUBLE PRECISION YSDJ, YSDK
C        THE STANDARD DEVIAION OF EACH SERIES.
C
      FPLM = D1MACH(2)
C
      YMMISS(1) = FPLM
C
C     PRINT SUMMARY INFORMATION
C
      CALL IPRINT(IPRT)
C
      IF (NEWPG) WRITE (IPRT, 1004)
      CALL VERSP (.TRUE.)
      WRITE(IPRT, 1005)
C
      WRITE(IPRT, 1000) J, K, YMEANJ, YMEANK, YSDJ, YSDK, NJ, NK
      IF (.NOT. IFMISS) GO TO 10
      NMISSJ = NJ - NUSEDJ
      PMISSJ = 100.0D0 * NMISSJ / NJ
      NMISSK = NK - NUSEDK
      PMISSK = 100.0D0 * NMISSK / NK
      WRITE(IPRT, 1003) NMISSJ, NMISSK, PMISSJ, PMISSK
C
   10 WRITE(IPRT, 1006) LAGMAX
      IF (IFMISS) WRITE(IPRT, 1007) YMISSJ, YMISSK
C
      IF (YSDJ .GT. 0.0D0 .AND. YSDK .GT. 0.0D0) GO TO 20
      WRITE (IPRT, 1008) J, K
      RETURN
C
C     PRINT CCF INFORMATION
C
   20 CONTINUE
      WRITE(IPRT, 1002)
      WRITE (IPRT, 1001) J, K
      CALL CCFLST (RHOC, SDRHOC, NLPP12, NLPP21, LAGMAX, LCCOV, NCC,
     +   IFMISS)
C
C     PLOT CCF INFORMATION
C
      WRITE(IPRT, 1004)
      CALL VERSP (.TRUE.)
      WRITE (IPRT, 1001) J, K
      CALL VPMN(RHOC, YMMISS, 2*LAGMAX+1, 1, 2*LAGMAX+1, 1, 0,
     +   ISYM, 1, 0, -1.0D0, 1.0D0, DBLE(-LAGMAX), 1.0D0, IFMISS,
     +   0, 0, 1)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/ 42X, 7HSERIES , I2, 5X, 7HSERIES , I2//
     +   41H AVERAGE OF THE SERIES                 = , 2G14.7/
     +   41H STANDARD DEVIATION OF THE SERIES      = , 2G14.7/
     +   41H NUMBER OF TIME POINTS                 = , 2(I10, 4X))
 1001 FORMAT (42H CROSS CORRELATION FUNCTION ESTIMATE (CCF)//
     +   22H CCF CORRELATES SERIES , I2, 22H AT TIME T WITH SERIES , I2,
     +   15H AT TIME T + K./
     +   5X, 55H(IF PEAK CORRELATION OCCURES AT POSITIVE (NEGATIVE) LAG/
     +   8X, 36HTHEN SERIES 1 LEADS (LAGS) SERIES 2))
 1002 FORMAT(//)
 1003 FORMAT (
     +   41H NUMBER OF MISSING OBSERVATIONS        = , 2(I10, 4X)/
     +   41H PERCENTAGE OF OBSERVATIONS MISSING    = , 2(F10.4, 4X))
 1004 FORMAT ('1')
 1005 FORMAT ( 27H CROSS CORRELATION ANALYSIS)
 1006 FORMAT(/
     +   41H LARGEST LAG VALUE TO BE USED          = , I10)
 1007 FORMAT(
     +   41H MISSING VALUE CODE                    = , 2G14.7)
 1008 FORMAT (//35H CROSS CORRELATIONS BETWEEN SERIES , I2, 5H AND ,
     +   I2, 22H COULD NOT BE COMPUTED/
     +   54H BECAUSE THE LAG ZERO AUTOCOVARIANCE OF ONE OR BOTH OF/
     +   20H THE SERIES IS ZERO.)
      END
*CCFS
      SUBROUTINE CCFS (YM, N, M, IYM, LAGMAX, CCOV, ICCOV, JCCOV,
     +   NPRT, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
C     CORRELATIONS AND COVARIANCES OF A MULTIVARIATE SERIES (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,IYM,JCCOV,LAGMAX,LDSTAK,M,N,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(*),YM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IFP,INLPPC,IO,IPRT,IYMFFT,J,JNLPPC,K,LDSMIN,LYFFT,NALL0,
     +   NFFT,RHOC,SDRHOC,YMEAN,YMEANJ,YMEANK,YSD,YSDJ,YSDK
      LOGICAL
     +   ISFFT,ISLONG,NEWPG
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACVF,CCFER,CCFMN,CCFOUT,IPRINT,LDSCMP,STKCLR,STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  STATEMENT FUNCTIONS
      INTEGER
     +   I2,I3
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCOV(ICCOV, JCCOV, M)
C        THE CROSS COVARIANCE MATRIX.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ICCOV
C        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER INLPPC
C        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
C        IN THE USERS PROGRAM.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
C        BASED ON WHETHER PRINTED OUTPUT IS DESIRED.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     LOGICAL ISFFT
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
C     LOGICAL ISLONG
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
C     INTEGER IYM
C        THE ACTUAL FIRST DIMENSION OF THE MATRIX YM AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER IYMFFT
C        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER I2
C        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN YM
C     INTEGER I3
C        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN CCOV
C     INTEGER J
C        THE INDEX OF -SERIES 1- IN THE ARRAY YM.
C     INTEGER JCCOV
C        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
C        SPECIFIED IN THE USERS PROGRAM.
C     INTEGER JNLPPC
C        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
C        IN THE USERS PROGRAM.
C     INTEGER K
C        THE INDEX OF -SERIES 2- IN THE ARRAY YM.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE REQUESTED.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER M
C        THE NUMBER OF SERIES BEING COMPARED, IE THE
C        NUMBER OF COLUMNS OF DATA IN YM.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
C     INTEGER NDUM(1)
C        A DUMMY DIMENSIONED VARIABLE.
C     LOGICAL NEWPG
C        AN INDICATOR VARIABLE USED TO DETERMINE WHEN A NEW PAGE
C        IS APPROPRIATE FOR THE OUTPUT.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPEDIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO OUTPUT IS GIVEN.
C     INTEGER RHOC
C        THE STARTING LOCATION IN DSTAK OF THE ARRAY RHOC.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER SDRHOC
C        THE STARTING LOCATION IN THE WORK AREA FOR SDRHOC.
C     DOUBLE PRECISION YM(IYM, M)
C        THE MATRIX CONTAINING THE OBSERVED TIME SERIES
C     INTEGER YMEAN, YMEANJ, YMEANK
C        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
C        MEANS OF EACH OF THE SERIES, AND THE LOCATION IN
C        THE ARRAY FOR THE MEAN OF THE JTH AND KTH SERIES,
C        RESPECTIVELY.
C     INTEGER YSD, YSDJ, YSDK
C        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
C        STANDARD DEVIATIONS OF EACH OF THE SERIES, AND THE
C        LOCATION IN THE ARRAY FOR THE STANDARD DEVIATION OF
C        THE JTH AND KTH SERIES, RESPECTIVELY.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'C',       'C',       'F',       'S',       ' ',       ' '/
C
      I2(I,J) = I + (J-1)*IYM
      I3(I,J,K) = I + (J-1)*ICCOV + (K-1)*JCCOV*ICCOV
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      INLPPC = ICCOV
      JNLPPC = JCCOV
      LYFFT = N + LAGMAX
      IYMFFT = IYM
      NFFT = N
      ISFFT = .FALSE.
      ISLONG = .TRUE.
C
      IO = 1
      IF (NPRT .EQ. 0) IO = 0
C
      CALL LDSCMP(2+2*IO, 0, 0, 0, 0, 0, 'D',
     +            2*M+IO*(4*LAGMAX+2), LDSMIN)
C
      CALL CCFER(NMSUB, N, LAGMAX, LDSTAK, LDSMIN, ICCOV, JCCOV,
     +  INLPPC, JNLPPC, M, LYFFT, NFFT, IYM, IYMFFT, ISFFT, ISLONG)
C
C     CHECK WHETHER AN ERROR HAS BEEN DETECTED
C
      IF (IERR.EQ.0) THEN
C
C       SET UP THE WORK AREA.
C
        CALL STKSET (LDSTAK, 4)
        NALL0 = STKST(1)
C
        IFP = 4
C
        YMEAN = STKGET(M, IFP)
        YSD = STKGET(M, IFP)
        IF (NPRT.EQ.0) THEN
          RHOC = YSD
          SDRHOC = YSD
        ELSE
          RHOC = STKGET(2*LAGMAX+1, IFP)
          SDRHOC = STKGET(2*LAGMAX+1, IFP)
        END IF
C
        IF (IERR.EQ.0) THEN
C
C         BEGIN LOOP FOR COMPUTATIONS
C
          NEWPG = .FALSE.
C
          DO 40 K = 1, M
C
             YMEANK = YMEAN + K - 1
             YSDK = YSD + K - 1
C
             CALL ACVF (YM(I2(1,K)), N, RSTAK(YMEANK),
     +                  CCOV(I3(1,K,K)), LAGMAX, ICCOV)
             RSTAK(YSDK) = SQRT(CCOV(I3(1,K,K)) * N / (N - 1))
C
             IF ((K-1).LE.0) GO TO 40
C
             DO 30 J = 1, (K-1)
C
                YMEANJ = YMEAN + J - 1
                YSDJ = YSD + J - 1
C
                CALL CCFMN (YM(I2(1,J)), YM(I2(1,K)),
     +                      N, LAGMAX, 2*LAGMAX+1,
     +                      CCOV(I3(1,J,J)), CCOV(I3(1,K,K)),
     +                      CCOV(I3(1,J,K)), CCOV(I3(1,K,J)),
     +                      ICCOV, RSTAK(YMEANJ), RSTAK(YMEANK),
     +                      RSTAK(RHOC), RSTAK(SDRHOC), NPRT)
C
                IF (NPRT .EQ. 0) GO TO 30
C
C         CALL ROUTINE TO PRINT OUT CORRELATIONS
C
                CALL CCFOUT (J, RSTAK(YMEANJ), RSTAK(YSDJ), N, N, K,
     +             RSTAK(YMEANK), RSTAK(YSDK), N, N, LAGMAX, 2*LAGMAX+1,
     +             RSTAK(RHOC), RSTAK(SDRHOC), .FALSE., NDUM, NDUM, 1,
     +             0.0D0, 0.0D0, NEWPG)
C
                NEWPG = .TRUE.
C
   30        CONTINUE
   40     CONTINUE
        END IF
C
        CALL STKCLR(NALL0)
      END IF
C
      IF (IERR.NE.0) THEN
C
C     PRINT PROPER CALL SEQUENCE AND RETURN
C
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL CCFS (YM, N, M, IYM,'/
     +   '      +           LAGMAX, CCOV, ICCOV, JCCOV, NPRT, LDSTAK)')
      END
*CCFSD
      SUBROUTINE CCFSD (CCOV11, CCOV22, SDRHOC, LAGMAX, NCC, N, ICCOV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN SUBROUTINE FOR COMPUTING THE STANDARD ERROR
C     OF THE CROSS CORRELATIONS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,LAGMAX,N,NCC
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV11(ICCOV),CCOV22(ICCOV),SDRHOC(NCC)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DIV,SUM
      INTEGER
     +   I,ILAST,K,K0,KM,KP
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCOV11(ICCOV), CCOV22(ICCOV)
C        THE ARRAYS IN WHICH THE AUTOCOVARIANCES ARE STORED
C     DOUBLE PRECISION DIV
C        THE SQUARE ROOT OF THE PRODUCT OF THE AUTOCOVARIANCE
C        FUNCTION VALUES AT LAG ZERO.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER ICCOV
C        THE DIMENSION OF THE ACVF ARRAYS.
C     INTEGER ILAST
C        THE LAST LAG AT WHICH THE STANDARD ERROR IS TO BE COMPUTED.
C     INTEGER K
C        AN INDEX VARIALBE.
C     INTEGER KM, KP, K0
C        THE LOCATIONS IN THE ARRAYS -RHOC- AND -SDRHOC-
C        OF THE LAG -K, K AND 0, RESPECTIVELY.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE USED.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
C     INTEGER NCC
C        THE NUMBER OF CCF COMPUTED.
C     DOUBLE PRECISION SDRHOC(NCC)
C        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE CROSS CORRELATION
C        ARE STORED
C     DOUBLE PRECISION SUM
C         A SUMMING VARIABLE.
C
      K0 = LAGMAX + 1
C
      DIV = CCOV11(1) * CCOV22(1)
C
      SUM = 0.0D0
      DO 10 I = 1, LAGMAX
         SUM = SUM + CCOV11(I+1) * CCOV22(I+1)
   10 CONTINUE
      SUM = SUM / DIV
      SDRHOC(K0) = SQRT(N + 2.0D0 * SUM) / N
C
      DO 30 K = 1, LAGMAX
         SUM = 0.0D0
         ILAST = MIN(LAGMAX, N-LAGMAX)
         DO 20 I = 1, ILAST
            SUM = SUM + (N-K-I)*CCOV11(I+1)*CCOV22(I+1)
   20    CONTINUE
         SUM = SUM / DIV
         KM = K0 - K
         SDRHOC(KM) = SQRT((N - K) + 2.0D0 * SUM) / N
C
         KP = K0 + K
         SDRHOC(KP) = SDRHOC(KM)
C
   30 CONTINUE
C
      RETURN
      END
*CCFSDM
      SUBROUTINE CCFSDM (CCOV11, CCOV22, SDRHOC, LAGMAX, NCC, LAGLST, N,
     +   NLPP12, NLPP21, ICCOV, INLPPC)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN SUBROUTINE FOR COMPUTING THE STANDARD ERROR
C     OF THE CROSS CORRELATIONS WHEN THERE ARE MISSING VALUES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,INLPPC,LAGLST,LAGMAX,N,NCC
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV11(ICCOV),CCOV22(ICCOV),SDRHOC(NCC)
      INTEGER
     +   NLPP12(INLPPC),NLPP21(INLPPC)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DIV,FPLM,SUM
      INTEGER
     +   I,ILAST,K,K0,KM,KP
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCOV11(ICCOV), CCOV22(ICCOV)
C        THE ARRAYS IN WHICH THE AUTOCOVARIANCES ARE STORED.
C     DOUBLE PRECISION DIV
C        THE SQUARE ROOT OF THE PRODUCT OF THE AUTOCOVARIANCE
C        FUNCTION VALUES AT LAG ZERO.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER I
C        INDEXING VARIABLES.
C     INTEGER ICCOV
C        THE DIMENSION OF THE COVARIANCE VECTORS.
C     INTEGER ILAST
C        THE LAST LAG AT WHICH THE STANDARD ERRORS ARE TO BE COMPUTED.
C     INTEGER INLPPC
C        THE DIMENSION OF THE LAGGED PRODUCT PAIR COUNT VECTORS.
C     INTEGER K
C        INDEXING VARIABLES.
C     INTEGER KM, KP, K0
C        THE LOCATIONS IN THE ARRAYS -RHOC- AND -SDRHOC-
C        OF THE LAG -K, K AND 0, RESPECTIVELY.
C     INTEGER LAGLST
C        THE LAST AUTOCORRELATION COMPUTED BEFORE A MISSING
C        AUTOCORRELATION WAS INCOUNTERED IN EITHER SERIES.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE USED.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
C     INTEGER NCC
C       THE NUMBER OF CROSS CORRELATIONS COMPUTED.
C     INTEGER NLPP12(INLPPC), NLPP21(INLPPC)
C        THE ARRAYS IN WHICH THE NUMBER OF OBSERVATIONS USED TO
C        COMPUTE EACH CROSS CORRELATION ARE STORED.
C     DOUBLE PRECISION SDRHOC(NCC)
C        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE CROSS CORRELATION
C        ARE STORED
C     DOUBLE PRECISION SUM
C         A SUMMING VARIABLE.
C
      FPLM = D1MACH(2)
C
      DIV = CCOV11(1) * CCOV22(1)
C
      K0 = LAGMAX + 1
C
      SUM = 0.0D0
      DO 10 I = 1, LAGLST
         SUM = SUM + CCOV11(I+1) * CCOV22(I+1)
   10 CONTINUE
      SUM = SUM / DIV
      SDRHOC(K0) = FPLM
      IF (NLPP12(1) .GE. 1) SDRHOC(K0) =
     +   SQRT(N + 2.0D0 * SUM) / NLPP12(1)
C
      DO 30 K = 1, LAGMAX
         SUM = 0.0D0
         ILAST = MIN(LAGLST, N-LAGLST)
         DO 20 I = 1, ILAST
            SUM = SUM + (N-K-I) * CCOV11(I+1) * CCOV22(I+1)
   20    CONTINUE
         SUM = SUM / DIV
         KM = K0 - K
         SDRHOC(KM) = FPLM
         IF (NLPP21(K+1) .GE. 1) SDRHOC(KM) =
     +      SQRT((N - K) + 2.0D0 * SUM) * (N - K)/ (N * NLPP21(K+1))
C
         KP = K0 + K
         SDRHOC(KP) = FPLM
         IF (NLPP12(K+1) .GE. 1) SDRHOC(KP) =
     +      SQRT((N - K) + 2.0D0 * SUM) * (N - K) / (N * NLPP12(K+1))
   30 CONTINUE
C
      RETURN
      END
*CCFXP
      SUBROUTINE CCFXP (STORE, LAGMAX, M, CCOV, ICCOV, JCCOV, MISS,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO LIST THE COMPUTED RESULTS FROM THE TIME SERIES
C     CROSS CORRELATION ROUTINES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CMISS
      INTEGER
     +   ICCOV,INLPPC,JCCOV,JNLPPC,LAGMAX,M
      LOGICAL
     +   MISS,STORE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(ICCOV,JCCOV,*)
      INTEGER
     +   NLPPC(INLPPC,JNLPPC,*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT,J,K,L,L1,LAG
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCF(16)
C
C  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCF(16)
C        AN ARRAY USED FOR PRINTING THE CCF.
C     DOUBLE PRECISION CCOV(ICCOV,JCCOV,M)
C        THE CROSS COVARIANCE ARRAY.
C     DOUBLE PRECISION CMISS
C        THE MISSING VALUE CODE FOR THE RETURNED CCVF ESTIMATES
C        (VECTOR CCOV).
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C     INTEGER INLPPC
C        THE FIRST DIMENSION OF THE ARRAY NLPPC.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER J
C        AN INDEXING VARIABLE.
C     INTEGER JCCOV, JNLPPC
C        THE SECOND DIMENSIONS OF THE ARRAYS CCOV AND NLPPC,
C        RESPECTIVELY.
C     INTEGER K
C        AN INDEXING VARIABLE.
C     INTEGER L1
C        AN INDEX VARIABLE.
C     INTEGER LAG
C        THE LAG VALUE AT WHICH THE DATA IS BEING PRINTED.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE REQUESTED.
C     INTEGER M
C        THE NUMBER OF SERIES IN THE MULTIVARIATE TIME SERIES YM.
C     LOGICAL MISS
C        THE VALUE INDICATING WHETHER THE ANALYSIS INCLUDED MISSING
C        DATA (TRUE) OR NOT (FALSE).
C     INTEGER NLPPC(INLPPC,JNLPPC,M)
C        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
C        USED TO COMPUTE EACH CCVF ESTIMATE.
C     LOGICAL STORE
C        THE VALUE INDICATING WHETHER THE RESULTS WERE RETURNED
C        TO THE USER (TRUE) OR NOT (FALSE).
C
      CALL IPRINT(IPRT)
C
C     PRINT IERR
C
      WRITE (IPRT, 1000) IERR
C
      IF (IERR.NE.0) RETURN
C
C     CHECK FOR STORED RESULTS
C
      IF (.NOT.STORE) RETURN
C
C     PRINT HEADING FOR CCVF
C
      WRITE (IPRT, 1010)
      WRITE (IPRT, 1040) ((J,K, K=1,M), J=1,M)
C
C     PRINT CROSS COVARIANCES
C
      LAG = 0
      WRITE (IPRT, 1060) LAG, ((CCOV(1,J,K), K=1,M), J=1,M)
      DO 10 LAG = 1, LAGMAX
         WRITE (IPRT, 1060) LAG, ((CCOV(LAG+1,J,K), K=1,M), J=1,M)
   10 CONTINUE
C
C     PRINT HEADING FOR CCF
C
      WRITE (IPRT, 1020)
      WRITE (IPRT, 1040) ((J,K, K=1,M), J=1,M)
C
C     PRINT CROSS CORRELATIONS
C
      LAG = 0
      I = 0
      DO 30 J = 1, M
         DO 20 K = 1, M
            I = I + 1
            CCF(I) = CCOV(1,J,K) / SQRT(CCOV(1,J,J)*CCOV(1,K,K))
   20    CONTINUE
   30 CONTINUE
      WRITE (IPRT, 1060) LAG, (CCF(L), L=1,I)
C
      DO 60 LAG = 1, LAGMAX
         I = 0
         DO 50 J = 1, M
            DO 40 K = 1, M
               I = I + 1
               IF (.NOT.MISS) GO TO 35
               CCF(I) = CMISS
               IF (MVCHK(CCOV(LAG+1,J,K),CMISS)) GO TO 40
   35          CCF(I) = CCOV(LAG+1,J,K) / SQRT(CCOV(1,J,J)*CCOV(1,K,K))
   40       CONTINUE
   50    CONTINUE
         WRITE (IPRT, 1060) LAG, (CCF(L1), L1=1,I)
   60 CONTINUE
C
C     CHECK FOR MISSING VALUES
C
      IF (.NOT.MISS) RETURN
C
C     PRINT HEADING FOR NUMBERS OF LAGGED PRODUCT PAIRS
C
      WRITE (IPRT, 1030)
      WRITE (IPRT, 1040) ((J,K, K=1,M), J=1,M)
C
C     PRINT NUMBERS OF LAGGED PRODUCT PAIRS FOR EACH CCVF
C
      LAG = 0
      WRITE (IPRT, 1070) LAG, ((NLPPC(1,J,K), K=1,M), J=1,M)
      DO 70 LAG = 1, LAGMAX
         WRITE (IPRT, 1070) LAG, ((NLPPC(LAG+1,J,K), K=1,M), J=1,M)
   70 CONTINUE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (//8H IERR = , I5)
 1010 FORMAT (// 6X, 6H  CCVF)
 1020 FORMAT (// 6X, 6H   CCF)
 1030 FORMAT (// 6X, 6H NLPPC)
 1040 FORMAT (1X, 3HLAG, 16(5X, I1, ',', I1))
 1060 FORMAT (1X, I3, 16F8.4)
 1070 FORMAT (1X, I3, 16I8)
      END
*CCVF
      SUBROUTINE CCVF(Y1, Y2, N, LAGMAX, Y1MEAN, Y2MEAN, CCOV12, CCOV21,
     +   ICCOV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE CROSS COVARIANCE FUNCTION
C     BETWEEN TWO SERIES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   Y1MEAN,Y2MEAN
      INTEGER
     +   ICCOV,LAGMAX,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV12(ICCOV),CCOV21(ICCOV),Y1(N),Y2(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DOTXY
      INTEGER
     +   LAG,NDOTXY
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DOTC
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCOV12(ICCOV), CCOV21(ICCOV)
C        THE ARRAYS IN WHICH THE CCVF FOR SERIES 1 LAGGED
C        BEHIND SERIES 2 AND VISA VERSA, RESPECTIVELY, ARE
C        STORED.
C     DOUBLE PRECISION DOTXY
C        VARIOUS CROSS PRUDUCTS BETWEEN SERIES Y1 AND Y2.
C     INTEGER ICCOV
C        THE ROW DIMENSION OF THE ARRAYS CCOV12 AND CCOV21.
C     INTEGER LAG
C        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
C        AUTOCORRELATION BEING COMPUTED.
C     INTEGER LAGMAX
C        THE MAXIMUM NUMBER OF LAGS TO BE USED.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
C     INTEGER NDOTXY
C        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY.
C     DOUBLE PRECISION Y1(N), Y1MEAN
C        THE FIRST SERIES, AND ITS MEAN.
C     DOUBLE PRECISION Y2(N), Y2MEAN
C        THE SECOND SERIES, AND ITS MEAN.
C
C     COMPUTE THE CROSS COVARIANCES
C
      CALL DOTC ( Y1, Y1MEAN, N, Y2, Y2MEAN, N, DOTXY, NDOTXY)
      CCOV12(1) = DOTXY / N
      CCOV21(1) = CCOV12(1)
C
      DO 10 LAG = 1, LAGMAX
C
         CALL DOTC (Y1, Y1MEAN, N, Y2(LAG + 1), Y2MEAN, N - LAG,
     +       DOTXY, NDOTXY)
         CCOV12(LAG+1) = DOTXY / N
C
         CALL DOTC (Y2, Y2MEAN, N, Y1(LAG + 1), Y1MEAN, N - LAG,
     +       DOTXY, NDOTXY)
         CCOV21(LAG+1) = DOTXY / N
C
   10 CONTINUE
C
      RETURN
      END
*CCVFF
      SUBROUTINE CCVFF (YFFT1, YFFT2, N, NFFT, LAGMAX, CCOV12, CCOV21,
     +   ICCOV, LYFFT, WORK, LWORK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE CROSS COVARIANCE FUNCTION
C     BETWEEN TWO SERIES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,LAGMAX,LWORK,LYFFT,N,NFFT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV12(ICCOV),CCOV21(ICCOV),WORK(LWORK),YFFT1(LYFFT),
     +   YFFT2(LYFFT)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FAC
      INTEGER
     +   I,ISN,J,LAG,NF,NF2,NFFT2
C
C  EXTERNAL SUBROUTINES
      EXTERNAL FFT,REALTR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCOV12(ICCOV), CCOV21(ICCOV)
C        THE ARRAYS IN WHICH THE CCVF FOR SERIES 1 LAGGED
C        BEHIND SERIES 2 AND VISA VERSA, RESPECTIVELY, ARE STORED.
C     DOUBLE PRECISION FAC
C        THE APPROPRIATE FACTOR USED TO SCALE THE CCVF.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER ICCOV
C        THE DIMENSION OF THE ARRAYS CCOV12 AND CCOV21.
C     INTEGER LAG, LAGMAX
C        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
C        CROSS CORRELATION BEING COMPUTED, AND THE MAXIMUM LAG
C        VALUE TO BE USED.
C     INTEGER LWORK
C        THE DIMENSION OF THE VECTOR WORK.
C     INTEGER LYFFT
C        THE ACTUAL LENGTH OF THE ARRAYS YFFT1 AND YFFT2.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
C     INTEGER NF
C        THE NUMBER OF FOURIER FREQUENCIES.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     INTEGER NFFT2
C        THE EFFECTIVE NUMBER OF OBSERVATIONS FOR THE FFT TRANSFORM.
C     INTEGER NF2
C        TWICE THE NUMBER OF FOURIER FREQUENCIES.
C     DOUBLE PRECISION WORK(LWORK)
C        THE WORK ARRAY NEEDED FOR THE COMPUTATIONS.
C     DOUBLE PRECISION YFFT1(LYFFT), YFFT2(LYFFT)
C        THE VECTORS CONTAINING THE OBSERVED SERIES ALREADY PROCESSED
C        BY ONE PASS OF A FFT.
C
      NFFT2 = (NFFT-2) / 2
      NF = NFFT2 + 1
      NF2 = NF * 2
C
C     COMPUTE THE CROSS COVARIANCES
C
      DO 10 I = 2, NF2, 2
         WORK(I-1) = YFFT1(I-1)*YFFT2(I-1) + YFFT1(I)*YFFT2(I)
         WORK(I) = YFFT1(I)*YFFT2(I-1) - YFFT1(I-1)*YFFT2(I)
   10 CONTINUE
C
      FAC = 1.0D0 / (4 * (NFFT-2) * N)
C
      ISN = -2
C
      CALL REALTR (WORK, WORK(2), NFFT2, ISN)
C
      CALL FFT (WORK, WORK(2), NFFT2, NFFT2, NFFT2, ISN)
C
      CCOV12(1) = WORK(1) * FAC
      CCOV21(1) = CCOV12(1)
C
      DO 20 LAG = 1, LAGMAX
         CCOV21(LAG+1) = WORK(LAG+1) * FAC
C
         J = NFFT - 1 - LAG
         CCOV12(LAG+1) = WORK(J) * FAC
   20 CONTINUE
C
      RETURN
      END
*CCVFM
      SUBROUTINE CCVFM(Y1, Y1MISS, Y2, Y2MISS, N, NC, Y1MEAN, Y2MEAN,
     +   CCOV12, CCOV21, ICCOV, NLPP12, NLPP21)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE CROSS COVARIANCE FUNCTION
C     BETWEEN TWO SERIES WHEN MISSING DATA ARE INVOLVED.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   Y1MEAN,Y1MISS,Y2MEAN,Y2MISS
      INTEGER
     +   ICCOV,N,NC
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV12(ICCOV),CCOV21(ICCOV),Y1(N),Y2(N)
      INTEGER
     +   NLPP12(ICCOV),NLPP21(ICCOV)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DOTXY,FPLM
      INTEGER
     +   LAG,NDOTXY
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DOTCM
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCOV12(ICCOV), CCOV21(ICCOV)
C        THE ARRAYS IN WHICH THE CCVF FOR SERIES 1 LAGGED
C        BEHIND SERIES 2 AND VISA VERSA, RESPECTIVELY, ARE
C        STORED.
C     DOUBLE PRECISION DOTXY
C        VARIOUS CROSS PRUDUCTS BETWEEN SERIES Y1 AND Y2.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER ICCOV
C        THE ROW DIMENSION OF THE ARRAYS CCOV12 AND CCOV21.
C     INTEGER LAG
C        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
C        AUTOCORRELATION BEING COMPUTED.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
C     INTEGER NC
C        THE NUMBER OF CROSS CORRELATIONS DESIRED.
C     INTEGER NLPP12(ICCOV), NLPP21(ICCOV)
C        THE NUMBER OF LAGGED PRODUCT PAIRS USED TO COMPUTE THE CCVF
C        FOR EACH PAIR OF SERIES AT EACH LAG.
C     INTEGER NDOTXY
C        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY.
C     DOUBLE PRECISION Y1(N), Y1MEAN, Y1MISS
C        THE FIRST SERIES, AND ITS MEAN, AND MISSING VALUE CODE.
C     DOUBLE PRECISION Y2(N), Y2MEAN, Y2MISS
C        THE SECOND SERIES, AND ITS MEAN, AND MISSING VALUE CODE.
C
      FPLM = D1MACH(2)
C
C     COMPUTE THE CROSS COVARIANCES
C
      CALL DOTCM (Y1, Y1MEAN, Y1MISS, N, Y2, Y2MEAN, Y2MISS, N, DOTXY,
     +   NDOTXY)
C
      NLPP12(1) = NDOTXY
      CCOV12(1) = FPLM
      IF (NDOTXY .GE. 1) CCOV12(1) = DOTXY / NDOTXY
C
      CCOV21(1) = CCOV12(1)
      NLPP21(1) = NDOTXY
C
      DO 10 LAG = 1, NC
C
         CALL DOTCM (Y1, Y1MEAN, Y1MISS, N, Y2(LAG+1), Y2MEAN, Y2MISS,
     +       N-LAG, DOTXY, NDOTXY)
C
         NLPP12(LAG+1) = NDOTXY
         CCOV12(LAG+1) = FPLM
         IF (NDOTXY .GE. 1)
     +      CCOV12(LAG+1) = DOTXY * (N-LAG) / (N*NDOTXY)
C
         CALL DOTCM (Y2, Y2MEAN, Y2MISS, N, Y1(LAG+1), Y1MEAN, Y1MISS,
     +      N-LAG, DOTXY, NDOTXY)
C
         NLPP21(LAG+1) = NDOTXY
         CCOV21(LAG+1) = FPLM
         IF (NDOTXY .GE. 1)
     +      CCOV21(LAG+1) = DOTXY * (N-LAG) / (N*NDOTXY)
C
   10 CONTINUE
C
      RETURN
      END
*CDFCHI
      DOUBLE PRECISION FUNCTION CDFCHI(CHISQR, DF)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE CHI SQUARE CUMULATIVE DISTRIBUTION
C     FUNCTION FROM THE INCOMPLETE GAMMA FUNCTION RATIO AS DISCUSSED IN
C     CHAPTER 17 OF DISTRIBUTIONS IN STATISTICS - CONTINUOUS UNIVARIATE
C     DISTRIBUTIONS - 1, BY JOHNSON AND KOTZ.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE - DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CHISQR,DF
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLPM
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   DGAMI,DGAMMA,D1MACH
      LOGICAL
     +   MVCHK
      EXTERNAL DGAMI,DGAMMA,D1MACH,MVCHK
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CHISQR
C        THE PERCENT POINT FROM THE CHI SQUARED DISTRIBUTION.
C     DOUBLE PRECISION DF
C        THE DEGREES OF FREEDOM.
C     DOUBLE PRECISION FPLPM
C        THE DOUBLE PRECISION FLOATING POINT LARGEST POSITIVE MAGNITUDE.
C
C     COMMENCE BODY OF ROUTINE
C
      FPLPM = D1MACH(2)
C
      CDFCHI = DGAMI(0.5D0*DF, 0.5D0*CHISQR)
      IF (MVCHK(CDFCHI,FPLPM)) THEN
         CDFCHI = 1.0D0
      ELSE
         CDFCHI = CDFCHI / DGAMMA(0.5D0*DF)
         IF (CDFCHI.LT.0.0D0) CDFCHI = 0.0D0
         IF (CDFCHI.GT.1.0D0) CDFCHI = 1.0D0
      END IF
C
      RETURN
      END
*CDFF
      DOUBLE PRECISION FUNCTION CDFF(F, DF1, DF2)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION FUNCTION FOR
C     THE F DISTRIBUTION.  THE APPROXIMATION USED DEPENDS ON THE
C     DEGREES OF FREEDOM IN THE NUMERATOR AND DENOMINATOR.
C     1.  IF BOTH DEGREES OF FREEDOM ARE SMALL (LESS THAN 4000),
C         THE CDF IS COMPUTED FROM THE INCOMPLETE BETA FUNCTION
C         USING EQUATION 5.45 OF STATISTICAL COMPUTING, BY KENNEDY AND
C         GENTLE.
C     2.  IF ONE OF THE DEGREES OF FREEDOM IS LARGE (GREATER THAN OR
C         EQUAL TO 4000) AND THE OTHER IS MODERATELY LARGE (GREATER THAN
C         OR EQUAL TO 100), THE CDF IS APPROXIMATED BY A NORMAL DISTRIB-
C         BUTION AS SHOWN IN EQUATION 20 ON PAGE 83 OF DISTRIBUTIONS IN
C         STATISTICS - CONTINUOUS UNIVARIATE DISTRIBUTIONS - 2, BY
C         JOHNSON AND KOTZ.
C     3.  IF ONE OF THE DEGREES OF FREEDOM IS SMALL (LESS THAN 100) AND
C         THE OTHER IS LARGE (EXCEEDING 4000), THE CDF IS APPROXIMATED
C         BY A CHI SQUARED DISTRIBUTION AS SHOWN IN THE THIRD EQUATION
C         ON PAGE 84 OF DISTRIBUTIONS IN STATISTICS - CONTINUOUS
C         UNIVARIATE DISTRIBUTIONS - 2, BY JOHNSON AND KOTZ.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE - DECEMBER 7, 1981
C                     THIS ROUTINE IS MODELED AFTER DATAPAC ROUTINE FCDF.
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DF1,DF2,F
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FTRANS
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   DBETAI,CDFCHI,CDFNML
      EXTERNAL DBETAI,CDFCHI,CDFNML
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DF1
C        THE DEGREES OF FREEDOM IN THE NUMERATOR.
C     DOUBLE PRECISION DF2
C        THE DEGREES OF FREEDOM IN THE DENOMINATOR.
C     DOUBLE PRECISION F
C        THE PERCENTAGE POINT FROM THE F DISTRIBUTION.
C     DOUBLE PRECISION FTRANS
C        TRANSFORMS OF THE F PERCENTAGE POINT, USED FOR THE VARIOUS
C        APPROXIMATING DISTRIBUTIONS.
C
C     COMMENCE BODY OF ROUTINE
C
      IF (F.GT.0.0D0) GO TO 5
      CDFF = 0.0D0
      RETURN
C
    5 CONTINUE
C
      IF ((DF1.GT.4000.0D0) .OR. (DF2.GT.4000.0D0)) GO TO 10
C
C     BOTH DEGREES OF FREEDOM ARE LESS THAN OR EQUAL TO 4000.  USE
C     THE INCOMPLETE BETA FUNCTION TO COMPUTE THE F CDF.
C
      FTRANS = DF2 / (DF2 + DF1 * F)
C
      CDFF = 1.0D0 - DBETAI(FTRANS, 0.5D0*DF2, 0.5D0*DF1)
      RETURN
C
   10 IF ((DF1.LE.100.0D0) .OR. (DF2.LE.100.0D0)) GO TO 20
C
C     BOTH DEGREES OF FREEDOM EXCEED 4000.  USE THE NORMAL APPROXIMATION
C     TO COMPUTE THE F CDF.
C
      FTRANS =
     +   (((1.0D0-(2.0D0/(9.0D0*DF2)))*
     +     (F**(1.0D0/3.0D0)))-(1.0D0-(2.0D0/(9.0D0*DF1)))) /
     +   SQRT(((F**(2.0D0/3.0D0))/(4.5D0*DF2))+(2.0D0/(9.0D0*DF1)))
C
      CDFF = CDFNML(FTRANS)
      RETURN
C
   20 IF (DF1.GT.100.0D0) GO TO 30
C
C     THE DEGREES OF FREEDOM IN THE DENOMINATOR EXCEEDS 4000 AND THE
C     DEGREES OF FREEDOM IN NUMERATOR IS LESS THAN OR EQUAL TO 100.
C     USE THE CHI SQUARE APPROXIMATION TO COMPUTE THE F CDF.
C
      FTRANS =
     +   (DF1 + (DF1/DF2)*(0.5D0*DF1-1.0D0))/
     +   ((1.0D0/F)+(DF1/DF2)*0.5D0)
C
      CDFF = CDFCHI(FTRANS, DF1)
C
      RETURN
C
   30 CONTINUE
C
C     THE DEGREES OF FREEDOM IN THE NUMERATOR EXCEEDS 4000 AND THE
C     DEGREES OF FREEDOM IN DENOMINATOR IS LESS THAN OR EQUAL TO 100.
C     USE THE CHI SQUARE APPROXIMATION TO COMPUTE THE F CDF.
C
      FTRANS =
     +   (DF2+(DF2/DF1)*(0.5D0*DF2-1.0D0))/(F+(DF2/DF1)*0.5D0)
C
      CDFF = 1.0D0 - CDFCHI(FTRANS, DF2)
C
      RETURN
C
      END
*CDFNML
      DOUBLE PRECISION FUNCTION CDFNML(X)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE NORMAL CUMULATIVE DISTRIBUTION
C     FUNCTION FROM THE ERROR FUNCTION AS DESCRIBED IN CHAPTER 13
C     OF DISTRIBUTIONS IN STATISTICS - CONTINUOUS UNIVARIATE
C     DISTRIBUTIONS - 1, BY JOHNSON AND KOTZ.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE - DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   X
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   DERF
      EXTERNAL DERF
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION X
C        THE PERCENT POINT FROM THE CHI SQUARED DISTRIBUTION.
C
C     COMMENCE BODY OF ROUTINE
C
      CDFNML = 0.5D0 * (1.0D0 + DERF(X/SQRT(2.0D0)))
C
      RETURN
      END
*CDFT
      DOUBLE PRECISION FUNCTION CDFT(X, IDF)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
C              FUNCTION VALUE FOR STUDENT"S T DISTRIBUTION
C              WITH INTEGER DEGREES OF FREEDOM PARAMETER = IDF.
C              THIS DISTRIBUTION IS DEFINED FOR ALL X.
C              THE PROBABILITY DENSITY FUNCTION IS GIVEN
C              IN THE REFERENCES BELOW.
C     INPUT  ARGUMENTS--X      = THE VALUE AT
C                                WHICH THE CUMULATIVE DISTRIBUTION
C                                FUNCTION IS TO BE EVALUATED.
C                                X SHOULD BE NON-NEGATIVE.
C                     --IDF     = THE INTEGER NUMBER OF DEGREES
C                                OF FREEDOM.
C                                IDF SHOULD BE POSITIVE.
C     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
C                                DISTRIBUTION FUNCTION VALUE.
C     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
C             FUNCTION VALUE CDF FOR THE STUDENT"S T DISTRIBUTION
C             WITH DEGREES OF FREEDOM PARAMETER = IDF.
C     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
C     RESTRICTIONS--IDF SHOULD BE A POSITIVE INTEGER VARIABLE.
C     OTHER DATAPAC   SUBROUTINES NEEDED--NORCDFC     LANGUAGE--ANSI FOR
C     REFERENCES--NATIONAL BUREAU OF STANDARDS APPLIED MATHMATICS
C                 SERIES 55, 1964, PAGE 948, FORMULAE 26.7.3 AND 26.7.4.
C               --JOHNSON AND KOTZ, CONTIIDFOUS UNIVARIATE
C                 DISTRIBUTIONS--2, 1970, PAGES 94-129.
C               --FEDERIGHI, EXTENDED TABLES OF THE
C                 PERCENTAGE POINTS OF STUDENT"S
C                 T-DISTRIBUTION, JOURNAL OF THE
C                 AMERICAN STATISTICAL ASSOCIATION,
C                 1959, PAGES 683-688.
C               --OWEN, HANDBOOK OF STATISTICAL TABLES,
C                 1962, PAGES 27-30.
C               --PEARSON AND HARTLEY, BIOMETRIKA TABLES
C                 FOR STATISTICIANS, VOLUME 1, 1954,
C                 PAGES 132-134.
C     WRITTEN BY--JAMES J. FILLIBEN
C                 STATISTICAL ENGINEERING LABORATORY (205.03)
C                 NATIONAL BUREAU OF STANDARDS
C                 WASHINGTON, D. C. 20234
C     ORIGINAL VERSION--JUNE      1972.
C     UPDATED         --MAY       1974.
C     UPDATED         --SEPTEMBER 1975.
C     UPDATED         --NOVEMBER  1975.
C     UPDATED         --OCTOBER   1976.
C
C---------------------------------------------------------------------
C
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   X
      INTEGER
     +   IDF
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   B11,B21,B22,B23,B24,B25,B31,B32,B33,B34,B35,B36,B37,C,CSQ,D1,
     +   D11,D3,D5,D7,D9,DCONST,DF,FPSPM,PI,SD,SUM,TERM,TERM1,TERM2,
     +   TERM3,Z
      INTEGER
     +   I,IDFCUT,IEVODD,IMAX,IMIN,IPRT
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFNML,D1MACH
      EXTERNAL CDFNML,D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GETPI,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,ATAN,EXP,LOG,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION B11, B21, B22, B23, B24, B25
C        CONSTANTS USED IN THE COMPUTATIONS.
C     DOUBLE PRECISION B31, B32, B33, B34, B35, B36, B37
C        CONSTANTS USED IN THE COMPUTATIONS.
C     DOUBLE PRECISION C
C        ...
C     DOUBLE PRECISION CSQ
C        ...
C     DOUBLE PRECISION DCONST
C        ...
C     DOUBLE PRECISION DF
C        THE DEGREES OF FREEDOM.
C     DOUBLE PRECISION D1, D11, D3, D5, D7, D9
C        CONSTANTS USED IN THE COMPUTATIONS.
C     DOUBLE PRECISION FPSPM
C        THE FLOATING POINT SMALLEST POSITIVE MAGNITUDE.
C     INTEGER I
C        AN INDEX.
C     INTEGER IDF
C        THE DEGREES OF FREEDOM.
C     INTEGER IDFCUT
C        ...
C     INTEGER IEVODD
C        ...
C     INTEGER IMAX
C        ...
C     INTEGER IMIN
C        ...
C     INTEGER IPRT
C        THE PRINT UNIT.
C     DOUBLE PRECISION PI
C        PI.
C     DOUBLE PRECISION SD
C        ...
C     DOUBLE PRECISION SUM
C        ...
C     DOUBLE PRECISION TERM, TERM1, TERM2, TERM3
C        ...
C     DOUBLE PRECISION X
C        THE T STATISTIC.
C     DOUBLE PRECISION Z
C        ...
C
      DATA IDFCUT /1000/
      DATA DCONST /0.3989422804D0/
      DATA B11 /0.25D0/
      DATA B21 /96.0D0/
C     DATA B21 /0.01041666666667D0/
      DATA B22, B23, B24, B25 /3.0D0,-7.0D0,-5.0D0,-3.0D0/
      DATA B31 /0.00260416666667D0/
      DATA B32, B33, B34, B35, B36, B37
     +    /1.0D0,-11.0D0,14.0D0,6.0D0,-3.0D0,-15.0D0/
C
C
      CALL GETPI(PI)
      CALL IPRINT(IPRT)
      FPSPM = D1MACH(1)
C
C     CHECK THE INPUT ARGUMENTS FOR ERRORS
C
      IF (IDF.LE.0) GO TO 10
      GO TO 20
   10 WRITE (IPRT, 1000)
      WRITE (IPRT, 1010) IDF
      CDFT = 0.0D0
      RETURN
   20 CONTINUE
C
C-----START POINT-----------------------------------------------------
C
      DF = IDF
C
C     IF IDF IS 3 THROUGH 9 AND X IS MORE THAN 3000
C     STANDARD DEVIATIONS BELOW THE MEAN,
C     SET CDFT = 0.0D0 AND RETURN.
C     IF IDF IS 10 OR LARGER AND X IS MORE THAN 150
C     STANDARD DEVIATIONS BELOW THE MEAN,
C     SET CDFT = 0.0D0 AND RETURN.
C     IF IDF IS 3 THROUGH 9 AND X IS MORE THAN 3000
C     STANDARD DEVIATIONS ABOVE THE MEAN,
C     SET CDFT = 1.0D0 AND RETURN.
C     IF IDF IS 10 OR LARGER AND X IS MORE THAN 150
C     STANDARD DEVIATIONS ABOVE THE MEAN,
C     SET CDFT = 1.0D0 AND RETURN.
C
      IF (IDF.LE.2) GO TO 50
      SD = SQRT(DF/(DF-2.0D0))
      Z = X/SD
      IF (IDF.LT.10 .AND. Z.LT.(-3000.0D0)) GO TO 30
      IF (IDF.GE.10 .AND. Z.LT.(-150.0D0)) GO TO 30
      IF (IDF.LT.10 .AND. Z.GT.3000.0D0) GO TO 40
      IF (IDF.GE.10 .AND. Z.GT.150.0D0) GO TO 40
      GO TO 50
   30 CDFT = 0.0D0
      RETURN
   40 CDFT = 1.0D0
      RETURN
   50 CONTINUE
C
C     DISTINGUISH BETWEEN THE SMALL AND MODERATE
C     DEGREES OF FREEDOM CASE VERSUS THE
C     LARGE DEGREES OF FREEDOM CASE
C
      IF (IDF.LT.IDFCUT) GO TO 60
      GO TO 120
C
C     TREAT THE SMALL AND MODERATE DEGREES OF FREEDOM CASE
C     METHOD UTILIZED--EXACT FINITE SUM
C     (SEE AMS 55, PAGE 948, FORMULAE 26.7.3 AND 26.7.4).
C
   60 CONTINUE
      CSQ = DF/(X*X+DF)
      C = SQRT(CSQ)
      IMAX = IDF - 2
      IEVODD = IDF - 2*(IDF/2)
      IF (IEVODD.NE.0) THEN
         IF (IDF.EQ.1) THEN
            SUM = 0.0D0
         ELSE
            SUM = C
         END IF
         TERM = C
         IMIN = 3
      ELSE
         SUM = 1.0D0
         TERM = 1.0D0
         IMIN = 2
      END IF
C
      DO 90 I=IMIN,IMAX,2
         IF (TERM.NE.0.0D0) THEN
            IF (LOG(TERM)+LOG((I-1.0D0)/I)+LOG(CSQ).GE.LOG(FPSPM)) THEN
               TERM = TERM*((I-1.0D0)/I)*CSQ
               SUM = SUM + TERM
            ELSE
               TERM = 0.0D0
            END IF
         END IF
   90 CONTINUE
C
      IF (SUM.EQ.0.0D0 .OR. X.EQ.0.0D0) THEN
         SUM = 0.0D0
      ELSE
         IF (LOG(SUM)+LOG(ABS(X))-0.5*LOG(X*X+DF) .LT. LOG(FPSPM)) THEN
            SUM = 0.0D0
         ELSE
            SUM = SUM*X/SQRT(X*X+DF)
         END IF
      END IF
      IF (IEVODD.EQ.0) GO TO 110
      SUM = (2.0D0/PI)*(ATAN(X/SQRT(DF))+SUM)
  110 CDFT = 0.5D0 + SUM/2.0D0
      RETURN
C
C     TREAT THE LARGE DEGREES OF FREEDOM CASE.
C     METHOD UTILIZED--TRUNCATED ASYMPTOTIC EXPANSION
C     (SEE JOHNSON AND KOTZ, VOLUME 2, PAGE 102, FORMULA 10?
C     SEE FEDERIGHI, PAGE 687).
C
  120 CONTINUE
      D1 = X
      D3 = X**3
      D5 = X**5
      D7 = X**7
      D9 = X**9
      D11 = X**11
      TERM1 = B11*(D3+D1)/DF
C     TERM2 = B21*(B22*D7+B23*D5+B24*D3+B25*D1)/(DF**2)
      TERM2 = (B22*D7+B23*D5+B24*D3+B25*D1)/(DF**2) / B21
      TERM3 = B31*(B32*D11+B33*D9+B34*D7+B35*D5+B36*D3+B37*D1)/(DF**3)
      CDFT = TERM1 + TERM2 + TERM3
      CDFT = CDFNML(X) - (DCONST*(EXP(-X*X/2.0D0)))*CDFT
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (' ', 49H***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO T,
     +   42HHE CDFT   SUBROUTINE IS NON-POSITIVE *****)
 1010 FORMAT (' ', 35H***** THE VALUE OF THE ARGUMENT IS , I8, 6H *****)
      END
*CENTER
      SUBROUTINE CENTER (Y, N, YC)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER ROUTINE FOR CENTERING THE OBSERVED SERIES Y,
C     RETURNING THE CENTERED SERIES IN YC.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*),YC(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,HEAD
C
C  LOCAL ARRAYS
      CHARACTER
     +   LN(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CNTR,EISGE,IPRINT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
C        ERROR MESSAGES (TRUE) OR NOT (FALSE).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IPRT
C        THE LOGICAL UNIT NUMBER USED FOR OUTPUT.
C     CHARACTER*1 LN(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
C        FOR ERRORS.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YC(N)
C        THE VECTOR IN WHICH THE CENTERED SERIES IS RETURNED.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'C',       'E',       'N',       'T',       'E',       'R'/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /'N',' ',' ',' ',' ',' ',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 2, 1, HEAD, ERR01, LN)
      IF (.NOT. ERR01) GO TO 5
C
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
    5 CONTINUE
C
      CALL CNTR (Y, N, YC)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   29H       CALL CENTER (Y, N, YC))
      END
*CHIRHO
      SUBROUTINE CHIRHO (RHO, N, NC, CHI, CHIP)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE CHI SQUARED STATISTIC AND ITS
C     PROBABILITY BASED IN A VECTOR OF AUTOCORRELATIONS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CHI,CHIP
      INTEGER
     +   N,NC
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RHO(*)
C
C  LOCAL SCALARS
      INTEGER
     +   LAG
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFCHI
      EXTERNAL CDFCHI
C
C  INTRINSIC FUNCTIONS
      INTRINSIC DBLE
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CHI, CHIP
C        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
C        CHI SQUARE STATISTIC PROBABILITY ARE STORED.
C     INTEGER LAG
C        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
C        AUTOCORRELATION BEING EXAMINED.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES.
C     INTEGER NC
C        THE NUMBER OF AUTOCORRELATIONS COMPUTED.
C     DOUBLE PRECISION RHO(NC)
C        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
C
      CHI = 0.0D0
      DO 10 LAG = 1, NC
         CHI = CHI + RHO(LAG) * RHO(LAG)
   10 CONTINUE
      CHI = CHI * N
      CHIP = 1.0D0 - CDFCHI(CHI, DBLE(NC))
      RETURN
      END
*CMPFD
      SUBROUTINE CMPFD(N,STP,PVSTP,PV,FD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES A FINITE DIFFERENCE DERIVATIVE,
C     ASSUMING THAT IF THE DIFFERENCE BETWEEN PVSTP(I) AND PV(I) IS
C     SMALL ENOUGH THE DERIVATIVE IS ZERO.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 30, 1987
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   STP
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FD(*),PV(*),PVSTP(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLRS
      INTEGER
     +   I
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VARIABLE.
C     DOUBLE PRECISION FD(N)
C        THE FINITE-DIFFERENCE DERIVATIVE.
C     DOUBLE PRECISION FPLRS
C        THE FLOATING POINT LARGEST RELATIVE SPACING.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUES AT THE CURRENT PARAMETER VALUE.
C     DOUBLE PRECISION PVSTP(N)
C        THE PREDICTED VALUES AT THE CURRENT PARAMETER VALUE PLUS STP.
C     DOUBLE PRECISION STP
C        THE STEP.
C
      FPLRS = D1MACH(4)
C
      DO 10 I=1,N
         FD(I) = PVSTP(I) - PV(I)
         IF (ABS(FD(I)).GE.5*FPLRS*MIN(ABS(PVSTP(I)),ABS(PV(I)))) THEN
            FD(I) = FD(I) / STP
         ELSE
            FD(I) = 0.0D0
         END IF
   10 CONTINUE
      RETURN
      END
*CNTR
      SUBROUTINE CNTR (Y, N, YC)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CENTERS THE INPUT SERIES Y ABOUT ITS MEAN,
C     RETURNING THE CENTERED SERIES IN YC.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*),YC(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   YMEAN
      INTEGER
     +   I
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE INPUT SERIES.
C     DOUBLE PRECISION Y(N)
C        THE INPUT ARRAY OF OBSERVATIONS TO BE CENTERED.
C     DOUBLE PRECISION YC(N)
C        THE OUTPUT ARRAY OF CENTERED OBSERVATIONS.
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE INPUT SERIES.
C
      CALL AMEAN (Y, N, YMEAN)
C
      DO 10 I = 1, N
         YC(I) = Y(I) - YMEAN
   10 CONTINUE
C
      RETURN
C
      END
*CORR
      SUBROUTINE CORR(YM, N, M, IYM, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR THE CORRELATION FAMILY.
C     IT IS THE SHORT CALL FORM.
C     THIS PROCEDURE CALLS CORER TO CHECK FOR ERRORS IN THE PARAMETER
C     LIST.  IF NO PROBLEMS IT THEN ALLOCATES SPACE IN CSTAK FOR THE
C     VECTORS NEEDED AND CALLS THE MAIN ROUTINE , CORRMN, TO
C     DO THE CORRELATION ANALYSIS.
C
C     WRITTEN BY -
C        LINDA L. MITCHELL
C        STATISTICAL ENGINEERING DIVISION
C        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IYM,LDSTAK,M,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   AVG,CILO,CIUP,ICOR,IFP,IPRT,IWRK,LIWRK,LWRK,NALL0,NPRT,PC,
     +   QF,QUAD,RANK,SC,SCINV,SD,SLPC,SLSC,SRCC,T,VCV,WRK
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CORRER,CORRMN,IPRINT,STKCLR,STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER AVG
C                  THE STARTING LOCATION IN THE WORK AREA FOR THE
C                  AVERAGES OF YM
C     INTEGER CILO
C                  OCCUPIES THE SAME SPACE AS SLPC AND IS THE LOWER
C                  CONFIDENCE INTERVAL
C     INTEGER CIUP
C                  OCCUPIES THE SAME SPACE AS SLSC AND IS THE UPPER
C                  CONFIDENCE INTERVAL
C     DOUBLE PRECISION DSTAK(12)
C                  THE DOUBLE PRECISION VERSION OF
C                  THE /CSTAK/ WORK AREA.
C     INTEGER ICOR
C                  DETERMINES WHICH SUBROUTINE CALLED CORRMN
C                  IF =1, THEN CALLED BY CORR
C                     =2, THEN CALLED BY CORRS
C     INTEGER IERR
C                  A FLAG RETURNED TO THE USER INDICATING
C                  WHETHER  ERRORS WERE DETECTED IN THE PARAMETER LIST
C                  IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C                  IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C                  AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3
C                  INDICATES SINGLE PRECISION AND IFP=4 INDICATES
C                  DOUBLE PRECISION.
C     INTEGER IPRT
C                  LOGICAL OUTPUT UNIT
C     INTEGER ISTAK(12)
C                  THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IWRK
C                  THE STARTING LOCATION IN THE WORK AREA FOR THE
C                  INTEGER WORK VECTOR.
C     INTEGER IYM
C                  THE ROW DIMENSION OF YM SPECIFIED IN THE USERS PROGRA
C     INTEGER LDSTAK
C                  SIZE OF WORK AREA ALLOCATED IN THE USERS PROGRAM
C     INTEGER LIWRK
C                  THE LENGTH OF THE INTEGER WORK VECTOR.
C     INTEGER LWRK
C                  THE LENGTH OF THE DOUBLE PRECISION WORK VECTOR.
C     INTEGER M
C                  THE NUMBER OF VARIABLES
C     INTEGER N
C                  THE NUMBER OF OBSERVATIONS
C     INTEGER NALL0
C                  THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE
C                  TIME THAT THIS ROUTINE WAS CALLED.
C     CHARACTER*1 NMSUB(6)
C                  THE SUBROUTINE NAME
C     INTEGER NPRT
C                  THE VARIABLE CONTROLLING THE AUTOMATIC PRINTOUT
C                       NPRT = 0, PRINTOUT IS SUPPRESSED
C                       OTHERWISE THE PRINTOUT IS PROVIDED.
C     INTEGER PC
C                  THE STARTING LOCATION IN THE WORK AREA
C                  OF THE PARTIAL CORRELATION COEFFICIENTS MATRIX
C     INTEGER QF
C                  THE STARTING LOCATION IN THE WORK AREA FOR THE
C                  QUADRATIC FIT
C     INTEGER QUAD
C                  THE STARTING LOCATION IN THE WORK AREA FOR THE
C                  DOUBLE PRECISION VERSION OF THE QUADRATIC FIT
C     INTEGER RANK
C                  THE STARTING LOCATION IN THE WORK AREA FOR THE
C                  MATRIX CONTAINING THE RANKS OF YM
C     DOUBLE PRECISION RSTAK(12)
C                  THE DOUBLE PRECISION VERSION OF THE
C                  /CSTAK/ WORK AREA.
C     INTEGER SC
C                  THE STARTING LOCATION IN THE WORK AREA
C                  OF THE SIMPLE CORRELATION COEFFICIENTS MATRIX
C     INTEGER SCINV
C                  THE STARTING LOCATION IN THE WORK AREA FOR THE
C                  INVERSE MATRIX OF SC
C     INTEGER SD
C                  THE STARTING LOCATION IN THE WORK AREA OF THE
C                  STANDARD DEVIATIONS OF YM
C     INTEGER SLPC
C                  THE STARTING LOCATION IN THE WORK AREA OF THE
C                  SIGNIFICANCE LEVELS OF PC
C     INTEGER SLSC
C                  THE STARTING LOCATION IN THE WORK AREA OF THE
C                  SIGNIFICANCE LEVELS OF SC
C     INTEGER SRCC
C                  THE STARTING LOCATION IN THE WORK AREA OF THE
C                  SPEARMAN RANK COEFFICIENTS
C     INTEGER T
C                  STARTING LOCATION IN THE WORK AREA
C                  FOR THE ARRAY T.
C     INTEGER VCV
C                  THE STARTING LOCATION IN THE WORK AREA OF THE
C                  VARIANCE COVARIANCE MATRIX.
C     INTEGER WRK
C                  THE STARTING LOCATION IN THE WORK AREA FOR
C                  WORK SPACE
C     DOUBLE PRECISION YM(IYM,M)
C                  THE MATRIX IN WHICH THE OBSERVATIONS ARE PASSED
C
C
C     SET UP NAME ARRAY
C
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'C',      'O',      'R',      'R',      ' ',      ' '/
C
C     SET UP FRAMEWORK VARIABLES FOR NUMBER TYPE
C
      IFP = 4
C
C     SET CALLER FLAG, THIS IS CORR
C
      ICOR = 1
C
C     PRINTOUT IS AUTOMATICALY PROVIDED
C
      NPRT = 1
C
C     CHECK FOR ERRORS IN PARAMETERS
C
      CALL CORRER(NMSUB, M, N, IYM, M, LDSTAK, ICOR, NPRT)
C
C     IF THERE IS AN ERROR RETURN TO THE CALLERS ROUTINE
C
      IF (IERR.EQ.0) GO TO 10
C
C     PRINT CORRECT FORM OF CALL STATEMENT AND RETURN TO CALLER
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     INITIALIZE THE STACK
C
   10 CALL STKSET (LDSTAK, 4)
      NALL0 = STKST(1)
C
C     ALLOCATE SPACE IN CSTAK FOR MATRICES.
C
      LIWRK = MAX(N,M)
      LWRK = LIWRK
C
      VCV = STKGET(M*M,IFP)
      IWRK = STKGET(LIWRK,2)
      WRK = STKGET(LWRK,IFP)
C
      T = STKGET(M,IFP)
      RANK = STKGET(N*M,IFP)
      SCINV = STKGET(M*M,IFP)
      SLSC = STKGET(M*M,IFP)
      SLPC = STKGET(M*M,IFP)
      SC = STKGET(M*M,IFP)
      PC = STKGET(M*M,IFP)
      QUAD = STKGET(3*N,IFP)
      QF = STKGET(M*M,IFP)
C
C     THE FOLLOWING VARIABLES HAVE BEEN INDIRECTLY EQUIVALENCED-
C
      CIUP = SLSC
      CILO = SLPC
      AVG = WRK
      SD = WRK
      SRCC = SCINV
C
C     CALL THE ROUTINE TO DO THE COMPUTATIONS
C
      CALL CORRMN(YM, N, M, IYM, RSTAK(AVG), RSTAK(SD), RSTAK(T),
     +   RSTAK(RANK), RSTAK(SC), RSTAK(PC), RSTAK(SCINV), ISTAK(IWRK),
     +   RSTAK(WRK), RSTAK(SLSC), RSTAK(SLPC), RSTAK(SRCC),
     +   RSTAK(QUAD), RSTAK(CIUP), RSTAK(CILO), RSTAK(QF),
     +   NPRT, RSTAK(VCV), M, LIWRK, LWRK)
C
C     RETURN AREA TO THE WORK ARRAY
C
      CALL STKCLR(NALL0)
C
      RETURN
C
C     FORMAT STATEMENT
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL CORR (YM, N, M, IYM, LDSTAK)')
      END
*CORRER
      SUBROUTINE CORRER(NMSUB, M, N, IYM, IVCV, LDSTAK, ICOR, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS FOR ERRORS IN THE INPUT
C     PARAMETERS.  IF ANY ARE FOUND A FLAG IS SET AND
C     COMPUTATION STOPS
C
C     WRITTEN BY -
C        LINDA L. MITCHELL
C        STATISTICAL ENGINEERING DIVISION
C        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ICOR,IVCV,IYM,LDSTAK,M,N,NPRT
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IP,IPRT,IS,LDSMIN
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,HEAD
C
C  LOCAL ARRAYS
      CHARACTER
     +   LIVCV(8)*1,LIYM(8)*1,LLDS(8)*1,LM(8)*1,LN(8)*1,
     +   LTHREE(8)*1,LTWO(8)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,IPRINT,LDSCMP
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
C                  VALUE(S) INDICATING WHETHER OR ERROR WAS DETECTED
C                  (TRUE) OR NOT (FALSE).
C     LOGICAL HEAD
C                  A FLAG INDICATING WHETHER THE HEADING SHOULD BE
C                  PRINTED (TRUE) OR NOT (FALSE).  IF A HEADING IS
C                  PRINTED, THE VALUE OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER ICOR
C                  DETERMINES WHICH SUBROUTINE CALLED CORRER
C                  IF =1, THEN CALLED BY CORR
C                     =2, THEN CALLED BY CORRS
C     INTEGER IERR
C                  A FLAG, THAT WHEN RETURNED BY THIS ROUTINE DESIGNATES
C                  WHETHER  ERRORS WERE DETECTED IN THE PARAMETER LIST
C                  IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C                  IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IP
C                  A TEMPORARY VARIABLE USED FOR COMPUTING LDSMIN.
C     INTEGER IPRT
C                  THE LOGICAL OUTPUT UNIT
C     INTEGER IS
C                  A TEMPORARY VARIABLE USED FOR COMPUTING LDSMIN.
C     INTEGER IVCV
C                  THE DIMENSION OF SC
C     INTEGER IYM
C                  ACTUAL ROW DIMENSION OF YM
C     INTEGER LDSMIN
C                  THE MINIMUM LENGTH ALLOWED FOR DSTAK
C     INTEGER LDSTAK
C                  THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK
C     CHARACTER*1 LIVCV(8), LIYM(8), LLDS(8), LM(8), LN(8), LTHREE(8),
C    *  LTWO(8)
C                  THE ARRAY(S) CONTAINING THE NAME(S) OF THE
C                  VARIABLE(S) CHECKED FOR ERRORS.
C     INTEGER M
C                  NUMBER OF VARIABLES
C     INTEGER N
C                  THE NUMBER OFOBSERVATIONS
C     CHARACTER*1 NMSUB(6)
C                  THE NAME OF THE CALLING SUBROUTINE.
C     INTEGER NPRT
C                  THE VARIABLE CONTROLLING THE PRINTED OUTPUT.
C                  IF NPRT=0, OUTPUT IS SUPPRESSED, OTHERWISE IT IS NOT
C
C
C     SET UP NAME ARRAYS
C
      DATA  LIVCV(1), LIVCV(2), LIVCV(3), LIVCV(4), LIVCV(5), LIVCV(6),
     +      LIVCV(7), LIVCV(8) / 'I', 'V', 'C', 'V', ' ', ' ', ' ', ' '/
      DATA   LIYM(1),  LIYM(2),  LIYM(3),  LIYM(4),  LIYM(5),  LIYM(6),
     +       LIYM(7),  LIYM(8) / 'I', 'Y', 'M', ' ', ' ', ' ', ' ', ' '/
      DATA   LLDS(1),  LLDS(2),  LLDS(3),  LLDS(4),  LLDS(5),  LLDS(6),
     +       LLDS(7),  LLDS(8) / 'L', 'D', 'S', 'T', 'A', 'K', ' ', ' '/
      DATA     LM(1),    LM(2),    LM(3),    LM(4),    LM(5),    LM(6),
     +         LM(7),    LM(8) / 'M', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA     LN(1),    LN(2),    LN(3),    LN(4),    LN(5),    LN(6),
     +         LN(7),    LN(8) / 'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA LTHREE(1),LTHREE(2),LTHREE(3),LTHREE(4),LTHREE(5),LTHREE(6),
     +     LTHREE(7),LTHREE(8) / 'T', 'H', 'R', 'E', 'E', ' ', ' ', ' '/
      DATA   LTWO(1),  LTWO(2),  LTWO(3),  LTWO(4),  LTWO(5),  LTWO(6),
     +       LTWO(7),  LTWO(8) / 'T', 'W', 'O', ' ', ' ', ' ', ' ', ' '/
C
      CALL IPRINT(IPRT)
C
      HEAD = .TRUE.
C
      IERR = 0
C
C     BEGIN ERROR CHECKING. THE COMMENTS STATE WHAT CONSTITUTES AN
C     ERROR. COMMENTS ENCLOSED BY STARS(**) INDICATE THE ERROR CONDITION
C
C     **NUMBER OF VARIABLES LESS THAN 2**
C
      CALL EISGE(NMSUB, LM, M, 2, 2, HEAD, ERR01, LTWO)
C
C     **NUMBER OF OBSERVATIONS LESS THAN 3**
C
      CALL EISGE(NMSUB, LN, N, 3, 2, HEAD, ERR02, LTHREE)
C
C     **OBSERVATION MATRIX DIMENSIONED LESS THAN N**
C
      ERR03 = .FALSE.
      IF (.NOT.ERR02) CALL EISGE(NMSUB, LIYM, IYM, N, 3, HEAD, ERR03,
     +   LN)
C
C     **SC MATRIX DIMENSIONED LESS THAN M**
C
      ERR04 = .FALSE.
      IF ((ICOR.EQ.2) .AND. (.NOT.ERR01)) CALL EISGE(NMSUB, LIVCV,
     +   IVCV, M, 3, HEAD, ERR04, LM)
C
      IF (ERR01 .OR. ERR02) GO TO 40
      IS = 0
      IF (ICOR.EQ.1) IS = 1
C
      IP = 1
      IF (NPRT.EQ.0) IP = 0
C
C
C     CHECK FOR ENOUGH COMMON FOR THIS PROBLEM
C
      CALL LDSCMP(12, 0, IP*MAX(N,M), 0, 0, 0, 'D',
     +   IS*M*M + IP*(MAX(N,M)+M+N*(M+3)+6*M*M), LDSMIN)
C
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR05, LLDS)
C
      IF (ERR01 .OR. ERR02 .OR. ERR03 .OR. ERR04 .OR. ERR05) GO TO 40
      RETURN
C
C     SET IERR TO INDICATE AN ERROR
C
   40 CONTINUE
      IERR = 1
      RETURN
      END
*CORRHD
      SUBROUTINE CORRHD(IPRT, M, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     A SUBROUTINE TO PRINT OUT THE HEADING FOR THE CORRELATION FAMILY.
C
C     AUTHOR -
C        JOHN E. KOONTZ
C        STATISTICAL ENGINEERING DIVISION
C        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IPRT,M,N
C
C  EXTERNAL SUBROUTINES
      EXTERNAL VERSP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IPRT
C        THE OUTPUT LOGICAL UNIT NUMBER
C     INTEGER M
C        THE NUMBER OF VARIABLES
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS FOR EACH VARIABLE
C
      CALL VERSP(.TRUE.)
      WRITE (IPRT,1000) M, N
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/25H CORRELATION ANALYSIS FOR, I3, 15H VARIABLES WITH,
     +   I5, 13H OBSERVATIONS/)
      END
*CORRMN
      SUBROUTINE CORRMN(YM, N, M, IYM, AVG, SD, T, RANK, SC, PC, SCINV,
     +   IWRK, WRK, SLSC, SLPC, SRCC, QUAD, CIUP, CILO, QF, NPRT,
     +   VCV, IVCV, LIWRK, LWRK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN ROUTINE FOR THE CORRELATION FAMILY, IT WAS
C     ADAPTED FROM THE OMNITAB ROUTINE CORREL. IT DOES A  CORRELATION
C     ANALYSIS OF A MULTIVARIATE RANDOM SAMPLE.
C     THE FOLLOWING TABLES ARE PRODUCED
C        SIMPLE CORRELATION COEFFICIENTS,
C        PARTIAL CORRELATION COEFFICIENTS,
C        AND THEIR SIGINIFICANCE LEVELS,
C        SPEARMAN RANK COEFFICIENTS,
C        QUADRATIC RELATIONSHIP,
C        95 AND 99 PERCENT CONFIDENCE INTERVALS.
C
C     THIS ROUTINE WAS ADAPTED FROM AN OMNITAB ROUTINE.
C
C     ADAPTED BY -
C        JANET R. DONALDSON AND LINDA L. MITCHELL
C        STATISTICAL ENGINEERING DIVISION
C        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IVCV,IYM,LIWRK,LWRK,M,N,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AVG(M),CILO(M,M),CIUP(M,M),PC(M,M),QF(M,M),QUAD(N,3),
     +   RANK(N,M),SC(M,M),SCINV(M,M),SD(M),SLPC(M,M),SLSC(M,M),
     +   SRCC(M,M),T(M),VCV(IVCV,M),WRK(LWRK),YM(IYM,M)
      INTEGER
     +   IWRK(LIWRK)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   B,F,FN3,FPLM,HL1,HL2,SQSUM,SUM,Z,ZZ
      INTEGER
     +   I,IER,IPRT,J,K,K1,K2,NSUM
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   C(3),D(3),RR(3,3),XX(3)
      INTEGER
     +   INERT(3)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFF,D1MACH
      EXTERNAL CDFF,D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN,CORRHD,DOTC,IPRINT,MATPRT,MGS,RANKO,DSIDI,DSIFA,
     +   VCVOUT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,INT,LOG,MAX,MIN,DBLE,SIGN,SQRT,TANH
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AVG(M)
C                  CONTAINS THE COLUMN AVERAGES OF YM
C     DOUBLE PRECISION B
C                  = (N-1) * N * (N+1) / 6
C     DOUBLE PRECISION C(3)
C                  *
C     DOUBLE PRECISION CILO(M,M)
C                  LOWER CONFIDENCE INTERVAL FOR SC
C     DOUBLE PRECISION CIUP(M,M)
C                  UPPER CONFIDENCE INTERVAL FOR SC
C     DOUBLE PRECISION D(3)
C                  A DUMMY ARRAY.
C     DOUBLE PRECISION F
C                  SQUARE ROOT OF FN3
C     DOUBLE PRECISION FN3
C                  DOUBLE PRECISION REPRESENTATION OF (N-3).
C     DOUBLE PRECISION FPLM
C                  THE FLOATING POINT LARGEST MAGNITUDE
C     DOUBLE PRECISION HL1
C                  *
C     DOUBLE PRECISION HL2
C                  *
C     INTEGER I
C                  AN INDEX VARIABLE
C     INTEGER IER
C                  ERROR FLAG FOR SUBROUTINES CALLED FROM THIS ROUTINE
C     INTEGER IERR
C                  WHEN RETURNED BY THIS ROUTINE, DESGINATES WHETHER ANY
C                  ERRORS WERE DETECTED DURING COMPUTATIONS
C                     IF IERR .EQ. 0, NO ERRORS
C                             .EQ. 1, ERRORS WERE DETECTED
C     INTEGER INERT(3)
C                  THE INERTIA OF THE SIMPLE CORRELATION MATRIX.
C     INTEGER IPRT
C                  THE LOGICAL OUTPUT NUMBER
C     INTEGER IVCV
C                  THE ROW DIMENSION OF VCV SPECIFIED IN THE USERS PROGR
C     INTEGER IWRK(LIWRK)
C                  A WORK VECTOR FOR THE INVERSION ROUTINE
C     INTEGER IYM
C                  THE ROW DIMENSION OF YM SPECIFIED IN THE USERS PROGRA
C     INTEGER J
C                  AN INDEX VARIABLE
C     INTEGER K
C                  AN INDEX VARIABLE
C     INTEGER K1
C                  *
C     INTEGER K2
C                  *
C     INTEGER LIWRK
C                  THE LENGTH OF THE INTEGER WORK VECTOR.
C     INTEGER LWRK
C                  THE LENGTH OF THE DOUBLE PRECISION WORK VECTOR.
C     INTEGER M
C                  THE NUMBER OF VARIABLES (THE COLUMN DIMENSION OF YM)
C     INTEGER N
C                  THE NUMBER OF OBSERVATIONS
C     INTEGER NPRT
C                  THE VARIABLE CONTROLLING THE AUTOMATIC PRINTOUT
C                  NPRT =0, PRINTOUT IS SUPPRESSED
C                  OTHERWISE PRINTOUT IS PROVIDED
C     INTEGER NSUM
C                  THE NUMBER OF OBSERVATIONS IN THE DOT PRODUCT
C     DOUBLE PRECISION PC(M,M)
C                  PARTIAL CORRELATION COEFFICIENTS MATRIX
C     DOUBLE PRECISION QF(M,M)
C                  QUADRATIC FIX MATRIX
C     DOUBLE PRECISION QUAD(N,3)
C                  DOUBLE VERSION OF QF MATRIX
C     DOUBLE PRECISION RANK(N,M)
C                  THE MATRIX CONTAING THE RANKS OF YM
C     DOUBLE PRECISION RR(3,3)
C                  *
C     DOUBLE PRECISION SC(M,M)
C                  SIMPLE CORRELATION COEFFICIENTS MATRIX
C     DOUBLE PRECISION SCINV(M,M)
C                  THE INVERSE MATRIX OF SC
C     DOUBLE PRECISION SD(M)
C                  STANDARD DEVIATION OF THE COMLUMNS OF YM
C     DOUBLE PRECISION SLPC(M,M)
C                  SIGNIFICANCE LEVELS OF PC
C     DOUBLE PRECISION SLSC(M,M)
C                  SIGNIFICANCE LEVELS OF SC
C     DOUBLE PRECISION SQSUM
C                  THE SUM OF SQUARES OF THE ITH COLUMN OF YM
C     DOUBLE PRECISION SRCC(M,M)
C                  SPEARMAN RANK CORRELATION COEFFICIENTS
C     DOUBLE PRECISION SUM
C                  USED IN CALCULATING THE STATISTICS OF YM
C     DOUBLE PRECISION T(M)
C                  USED IN DETERMINING SRCC
C     DOUBLE PRECISION VCV(IVCV,M)
C                  THE VARIANCE COVARIANCE MATRIX.
C     DOUBLE PRECISION WRK(LWRK)
C                  WORK STORAGE
C     DOUBLE PRECISION XX(3)
C                  *
C     DOUBLE PRECISION YM(IYM,M)
C                  THE MATRIX WHOSE COLUMNS EACH CONTAIN ONE OF M SETS
C                  OF N OBSERVATIONS. EACH COLUMN REPRESENTS A DIFFERENT
C                  VARIABLE
C     DOUBLE PRECISION Z
C                  USED IN COMPUTING CONFIDENCE INTERVALS
C     DOUBLE PRECISION ZZ
C                  USED IN DETERMINING CORRELATION COEFFICIENTS
C
      IERR = 0
C
      FPLM = D1MACH(2)
      CALL IPRINT(IPRT)
C
      DO 10 J=1,M
         CALL AMEAN(YM(1,J), N, AVG(J))
   10 CONTINUE
C
C     COMPUTE VARIANCE-COVARIANCE MATRIX
C
      DO 30 J=1,M
         DO 20 I=J,M
            CALL DOTC(YM(1,J), AVG(J), N, YM(1,I), AVG(I), N, SUM, NSUM)
            VCV(J,I) = SUM/(NSUM-1)
            VCV(I,J) = VCV(J,I)
   20    CONTINUE
   30 CONTINUE
C
      IF (NPRT.EQ.0) RETURN
C
C     PRINT VARIANCE-COVARIANCE MATRIX AND SIMPLE CORRELATION
C     COEFFICIENTS
C
      CALL CORRHD(IPRT, M, N)
      CALL VCVOUT(M, VCV, IVCV, .FALSE.)
C
C     COMPUTE STANDARD DEVIATIONS
C
      DO 40 I=1,M
         IF (VCV(I,I).LE.0.0D0) GO TO 90
         SD(I) = SQRT(VCV(I,I))
   40 CONTINUE
C
C     COMPUTE SIMPLE CORRELATION COEFFICIENTS
C
      DO 60 J=1,M
         DO 50 I=J,M
            SC(I,J) = 1.0D0
            SCINV(J,I) = 1.0D0
            IF (I.EQ.J) GO TO 50
            SC(I,J) = VCV(I,J)/SD(I)/SD(J)
            SC(J,I) = SC(I,J)
            SCINV(J,I) = SC(I,J)
   50    CONTINUE
   60 CONTINUE
C
      IF ((M.LE.2) .OR. (N.LE.M)) GO TO 190
C
C     CALCULATE PARTIAL CORRELATION COEFFICIENTS.
C
      CALL DSIFA(SCINV, M, M, IWRK, IER)
      IF (IER.EQ.0) GO TO 100
   90 WRITE (IPRT,1000)
      IERR = 1
      RETURN
  100 CONTINUE
      CALL DSIDI(SCINV, M, M, IWRK, D, INERT, WRK, 1)
      DO 130 J=1,M
         DO 120 I=J,M
            PC(I,J) = 1.0D0
            IF (I.EQ.J) GO TO 120
            ZZ = SCINV(I,I)*SCINV(J,J)
            PC(I,J) = FPLM
            IF (ZZ.LE.0.0D0) GO TO 110
            PC(I,J) = -SCINV(J,I)/SQRT(ZZ)
            IF (ABS(PC(I,J)).GT.1.0D0) PC(I,J) = SIGN(1.0D0,PC(I,J))
  110       PC(J,I) = PC(I,J)
  120    CONTINUE
C
  130 CONTINUE
C
C     COMPUTE SIGNIFICANCE LEVELS OF PARTIAL CORRELATION COEFFICIENTS.
C     NOTE, LOWER TRIANGULAR MATRIX STORED IN SQUARE MATRIX.
C
      DO 180 I=1,M
         DO 170 J=1,I
            IF (PC(I,J).NE.0.0D0) GO TO 140
            SLPC(I,J) = 1.0D0
            GO TO 170
  140       IF (ABS(PC(I,J)).LT.1.0D0) GO TO 150
            SLPC(I,J) = 0.0D0
            GO TO 170
  150       F = PC(I,J)*PC(I,J)
            IF (1.0D0-F.NE.0.0D0) GO TO 160
            SLPC(I,J) = FPLM
            GO TO 170
  160       F = (N-M)*F/(1.0D0-F)
            SLPC(I,J) = 1.0D0 - CDFF(F,1.0D0,DBLE(N-M))
  170    CONTINUE
  180 CONTINUE
C
C     COMPUTE SIGNIFICANCE LEVELS OF SIMPLE CORRELATION COEFFICIENTS
C     NOTE, ONLY LOWER TRIANGULAR STORED IN SQUARE MATRIX.
C
  190 DO 250 I=1,M
         DO 240 J=1,I
            IF (I.NE.J) GO TO 200
            SLSC(I,J) = 0.0D0
            GO TO 240
  200       IF (SC(I,J).NE.0.0D0) GO TO 210
            SLSC(I,J) = 1.0D0
            GO TO 240
  210       IF (ABS(SC(I,J)).LT.1.0D0) GO TO 220
            SLSC(I,J) = 0.0D0
            GO TO 240
  220       F = SC(I,J)*SC(I,J)
            IF (F.NE.1.0D0) GO TO 230
            SLSC(I,J) = FPLM
            GO TO 240
  230       F = (N-2)*F/(1.0D0-F)
            SLSC(I,J) = 1.0D0 - CDFF(F,1.0D0,DBLE(N-2))
  240    CONTINUE
  250 CONTINUE
C
C     PRINT SIGNIFICANCE LEVELS OF SIMPLE CORRELATION COEFFICIENTS,
C     PARTIAL CORRELATION COEFFICIENTS AND SIGNIFICANCE LEVELS
C
      WRITE (IPRT,1020)
      CALL MATPRT(SLSC, SLSC, M, IPRT, 0, 1, M)
      IF ((M.GT.2) .AND. (N.GT.M)) GO TO 260
      WRITE (IPRT,1010)
      GO TO 270
  260 I = M - 2
      WRITE (IPRT,1030) I
      CALL MATPRT(PC, PC, M, IPRT, 0, 1, M)
      WRITE (IPRT,1040)
      CALL MATPRT(SLPC, SLPC, M, IPRT, 0, 1, M)
  270 CONTINUE
C
C     DETERMINE THE RANKS OF THE OBSERVATIONS.
C
      DO 280 I=1,M
         CALL RANKO(N, YM(1,I), IWRK, RANK(1,I), T(I))
         T(I) = T(I) / 12.0D0
  280 CONTINUE
C
C     COMPUTE SPEARMAN RANK CORRELATION COEFFICIENTS.
C     NOTE, LOWER TRIANGULAR MATRIX, STORED IN SQUARE MATRIX.
C
      B = (N-1)*N*(N+1)/6
      DO 330 I=1,M
         DO 320 J=1,I
            SRCC(I,J) = 1.0D0
            IF (I.EQ.J) GO TO 320
            K1 = 2.0D0*T(I) + 0.4D0
            K2 = 2.0D0*T(J) + 0.4D0
            SRCC(I,J) = FPLM
            IF ((INT(B)-K1.LE.0) .OR. (INT(B)-K2.LE.0)) GO TO 320
            SUM = 0.0D0
            DO 310 K=1,N
               ZZ = RANK(K,I) - RANK(K,J)
               SUM = SUM + ZZ*ZZ
  310       CONTINUE
            ZZ = (B - 2.0D0*T(I))*(B - 2.0D0*T(J))
            IF (ZZ.GT.0.0D0) SRCC(I,J) = (B-SUM-T(I)-T(J))/SQRT(ZZ)
  320    CONTINUE
  330 CONTINUE
C
C     PRINT SPEARMAN RANK CORRELATIONS COEFFICIENTS
C
      WRITE (IPRT,1050)
      CALL MATPRT(SRCC, SRCC, M, IPRT, 0, 1, M)
C
      IF (N.GT.3) GO TO 340
      WRITE (IPRT,1060)
      RETURN
C
C     COMPUTE THE SIGNIFICANCE LEVELS OF THE QUADRATIC FIT OVER THE
C     LINEAR FIT.
C
C     THESE CALCULATIONS MAY PRODUCE VARIABLE RESULTS IN VARYING
C     MACHINE/COMPILATION ENVIRONMENTS, IN CASES IN WHICH THE
C     YM MATRIX IS NEAR SINGULAR (ESSENTIALLY SINGULAR BUT THE
C     SINGULARITY IS UNDETECTED BY THE CODE).  THE OBSERVED SYMPTOMS
C     ARE ALTERNATION BETWEEN QF VALUES OF 0.0D0 (FIRST F = LINE
C     PRODUCES ZERO) AND 1.0D0 (FIRST F = LINE PRODUCES APPROX.
C     ZERO, AND NUMERATOR IN SECOND F = LINE IS NONZERO).
C
  340 FN3 = N-3
      DO 410 J=1,M
         DO 400 I=1,M
            IF (I.NE.J) GO TO 350
            QF(I,J) = 1.0D0
            GO TO 400
  350       SQSUM = 0.0D0
            DO 360 K=1,N
              QUAD(K,1) = 1.0D0
               QUAD(K,2) = YM(K,J)
               QUAD(K,3) = YM(K,J)*YM(K,J)
               SQSUM = SQSUM + YM(K,I)*YM(K,I)
               WRK(K) = YM(K,I)
  360       CONTINUE
            CALL MGS(QUAD, WRK, N, 3, XX, C, D, RR, 3, N, IER)
            IF (IER.EQ.0) GO TO 370
            WRITE (IPRT,1090)
            GO TO 420
  370       DO 380 K=1,3
               C(K) = C(K)*SQRT(D(K))
  380       CONTINUE
            F = (SQSUM-C(1)*C(1)-C(2)*C(2)-C(3)*C(3))
            QF(I,J) = 0.0D0
            IF (F.EQ.0.0D0) GO TO 400
            F = (C(3)*C(3)*FN3)/F
            QF(I,J) = 1.0D0
            IF (F.GT.0.0D0) QF(I,J) = 1.0D0 - CDFF(F,1.0D0,FN3)
  400    CONTINUE
  410 CONTINUE
C
C     PRINT THE QUADRATIC FIT MATRIX
C
      J = 2
      K = 1
      I = N - 3
      WRITE (IPRT,1070) I, QF(J,K), J, K
      CALL MATPRT(QF, QF, M, IPRT, 1, 1, M)
C
C     COMPUTE CONFIDENCE LIMITS FOR SIMPLE CORRELATION COEFFICIENTS
C
  420 F = SQRT(FN3)
      HL1 = 2.5758293D0/F
      HL2 = 1.9599640D0/F
      DO 520 J=1,M
         DO 510 I=1,M
            IF (I.NE.J) GO TO 430
            CIUP(I,J) = 99.0D0
            CILO(I,J) = 95.0D0
            GO TO 510
  430       IF (I.LT.J) GO TO 470
C
C           COMPUTE 95 PERCENT INTERVALS.
C
            IF (SC(I,J).GE.1.0D0) GO TO 440
            IF (SC(I,J).GT.-1.0D0) GO TO 450
            Z = -1.0D0
            GO TO 460
  440       Z = 1.0D0
            GO TO 460
  450       Z = 0.5D0*LOG((1.0D0+SC(I,J))/(1.0D0-SC(I,J)))
  460       CIUP(I,J) = MIN(TANH(Z+HL2),1.0D0)
            CILO(I,J) = MAX(TANH(Z-HL2),-1.0D0)
            GO TO 510
C
C           COMPUTE 99 PERCENT INTERVALS.
C
  470       IF (SC(J,I).GE.1.0D0) GO TO 480
            IF (SC(J,I).GT.-1.0D0) GO TO 490
            Z = -1.0D0
            GO TO 500
  480       Z = 1.0D0
            GO TO 500
  490       Z = 0.5D0*LOG((1.0D0+SC(J,I))/(1.0D0-SC(J,I)))
  500       CIUP(I,J) = MIN(TANH(Z+HL1),1.0D0)
            CILO(I,J) = MAX(TANH(Z-HL1),-1.0D0)
  510    CONTINUE
  520 CONTINUE
C
C     PRINT CONFIDENCE LIMITS
C
      WRITE (IPRT,1080)
      CALL MATPRT(CIUP, CILO, M, IPRT, 1, 2, M)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/ 46H COMPUTATION STOPPED DUE TO SINGULAR OR ILL-CO,
     +   28HNDITIONED COVARIANCE MATRIX.)
 1010 FORMAT (//42H THE PARTIAL CORRELATION COEFFICIENTS (AND, 6H SIGNI,
     +   50HFICANCE LEVELS) ARE NOT PRINTED OR DEFINED BECAUSE/6H EITHE,
     +   52HR THE NUMBER OF VECTORS BEING COMPARED IS TWO OR THE,
     +   59H NUMBER OF MEASUREMENTS IS LESS THAN OR EQUAL TO THE NUMBER/
     +   27H OF VECTORS BEING COMPARED.)
 1020 FORMAT (// 44H SIGNIFICANCE LEVELS OF SIMPLE CORRELATION C,
     +   32HOEFFICIENTS (ASSUMING NORMALITY))
 1030 FORMAT (// 38H PARTIAL CORRELATION COEFFICIENTS WITH, I3,
     +   26H REMAINING VARIABLES FIXED)
 1040 FORMAT (// 44H SIGNIFICANCE LEVELS OF PARTIAL CORRELATION ,
     +   33HCOEFFICIENTS (ASSUMING NORMALITY))
 1050 FORMAT (// 44H SPEARMAN RANK CORRELATION COEFFICIENTS (ADJ,
     +   15HUSTED FOR TIES))
 1060 FORMAT (// 44H NONLINEARITY TEST AND APPROXIMATION OF CONF,
     +   39HIDENCE INTERVALS NOT DEFINED FOR N = 3.)
 1070 FORMAT (// 45H SIGNIFICANCE LEVEL OF QUADRATIC FIT OVER LIN,
     +   35HEAR FIT BASED ON F RATIO WITH 1 AND, I5, 15H DEGREES OF FRE,
     +   4HEDOM/14H (FOR EXAMPLE,, F7.4, 19H IS THE SIGNIFICANC,
     +   41HE LEVEL OF THE QUADRATIC TERM WHEN COLUMN, I3, 9H IS FITTE,
     +   11HD TO COLUMN, I3, ')')
 1080 FORMAT (// 44H CONFIDENCE INTERVALS FOR SIMPLE CORRELATION,
     +   43H COEFFICIENTS (USING FISHER TRANSFORMATION)/' 95 PER C',
     +   59HENT LIMITS BELOW DIAGONAL, 99 PER CENT LIMITS ABOVE DIAGONA,
     +   'L')
 1090 FORMAT (/ 46H SIGNIFICANCE LEVELS OF QUADRATIC FIT OVER LIN,
     +   30HEAR FIT HAVE NOT BEEN COMPUTED/' DUE TO SINGULARITY IN',
     +   32H DESIGN MATRIX. CHECK YOUR DATA.)
      END
*CORRS
      SUBROUTINE CORRS(YM, N, M, IYM, LDSTAK, NPRT, VCV, IVCV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR THE CORRELATION FAMILY.
C     IT IS THE LONG CALL FORM.
C     THIS ROUTINE CALLS CORRER TO CHECK FOR ERRORS IN THE PARAMETERS.
C     IF THERE ARE NO PROBLEMS IT THEN ALLOCATES SPACE IN CSTAK
C     FOR THE VECTORS NEEDED AND CALLS THE MAIN ROUTINE, CORRMN, TO DO
C     THE CORRELATION ANALYSIS.
C
C     WRITTEN BY -
C        LINDA L. MITCHELL
C        STATISTICAL ENGINEERING DIVISION
C        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IVCV,IYM,LDSTAK,M,N,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VCV(*),YM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   AVG,CILO,CIUP,ICOR,IFP,IPRT,IWRK,LIWRK,LWRK,NALL0,PC,QF,
     +   QUAD,RANK,SC,SCINV,SD,SLPC,SLSC,SRCC,T,WRK
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CORRER,CORRMN,IPRINT,STKCLR,STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER AVG
C                  THE STARTING LOCATION IN THE WORK AREA OF THE
C                  AVERAGES OF YM
C     INTEGER CILO
C                  OCCUPIES THE SAME SPACE AS SLPC AND IS THE LOWER
C                  CONFIDENCE INTERVAL
C     INTEGER CIUP
C                  OCCUPIES THE SAME SPACE AS SLSC AND IS THE UPPER
C                  CONFIDENCE INTERVAL
C     DOUBLE PRECISION DSTAK(12)
C                  THE DOUBLE PRECISION VERSION OF
C                  THE /CSTAK/ WORK AREA.
C     INTEGER ICOR
C                  DETERMINES WHICH SUBROUTINE CALLED CORRMN
C                  IF =1, THEN CALLED BY CORR
C                     =2, THEN CALLED BY CORRS
C     INTEGER IERR
C                  A FLAG RETURNED TO THE USER INDICATING
C                  WHETHER  ERRORS WERE DETECTED IN THE PARAMETER LIST
C                  IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C                  IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C                  AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3
C                  INDICATES SINGLE PRECISION AND IFP=4 INDICATES
C                  DOUBLE PRECISION.
C     INTEGER IPRT
C                  LOGICAL OUTPUT UNIT
C     INTEGER ISTAK(12)
C                  THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IVCV
C                  THE DIMENSION OF VCV ASSIGNED IN THE USERS PROGRAM.
C     INTEGER IWRK
C                  THE STARTING LOCATION IN THE WORK AREA FOR THE
C                  INTEGER WORK VECTOR.
C     INTEGER IYM
C                  ROW DIMENSION OF YM SPECIFIED IN THE USERS PROGRAM.
C     INTEGER LDSTAK
C                  SIZE OF WORK AREA ALLOCATED IN THE USERS PROGRAM
C     INTEGER LIWRK
C                  THE LENGTH OF THE INTEGER WORK VECTOR.
C     INTEGER LWRK
C                  THE LENGTH OF THE DOUBLE PRECISION WORK VECTOR.
C     INTEGER M
C                  THE NUMBER OF VARIABLES
C     INTEGER N
C                  THE NUMBER OF OBSERVATIONS
C     INTEGER NALL0
C                  THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE
C                  TIME THAT THIS ROUTINE WAS CALLED.
C     CHARACTER*1 NMSUB(6)
C                  THE SUBROUTINE NAME
C     INTEGER NPRT
C                  THE VARIABLE CONTROLLING THE AUTOMATIC PRINTOUT
C                  NPRT = 0 PRINTOUT IS SUPRESSED
C                  OTHERWISE THE PRINTOUT IS PROVIDED.
C     INTEGER PC
C                  THE STARTING LOCATION IN THE WORK AREA FOR THE
C                  THE PARTIAL CORRELATION COEFFICIENTS MATRIX
C     INTEGER QF
C                  THE STARTING LOCATION IN THE WORK AREA FOR THE
C                  QUADRATIC FIT MATRIX
C     INTEGER QUAD
C                  THE STARTING LOCATION IN THE WORK AREA FOR THE
C                  DOUBLE PRECISION  QUAD FIT
C     INTEGER RANK
C                  THE STARTING LOCATION IN THE WORK AREA FOR THE
C                  MATRIX CONTAINING THE RANKS OF YM
C     DOUBLE PRECISION RSTAK(12)
C                  THE DOUBLE PRECISION VERSION OF
C                  THE /CSTAK/ WORK AREA.
C     INTEGER SC
C                  THE STARTING LOCATION IN THE WORK AREA FOR THE
C                  THE SIMPLE CORRELATION COEFFICIENTS MATRIX
C     INTEGER SCINV
C                  THE STARTING LOCATION IN THE WORK AREA OF THE
C                  INVERSE MATRIX OF VCV
C     INTEGER SD
C                  THE STARTING LOCATION IN THE WORK AREA OF THE
C                  STANDARD DEVIATIONS VECTOR
C     INTEGER SLPC
C                  THE STARTING LOCATION IN THE WORK AREA OF THE
C                  SIGNIFICANCE LEVELS FOR PC
C     INTEGER SLSC
C                  THE STARTING LOCATION IN THE WORK AREA OF THE
C                  SIGNIFICANCE LEVELS FOR SC
C     INTEGER SRCC
C                  STARTING LOCATION IN THE WORK AREA FOR THE SPEAR-
C                  MAN RANK COEFFICIENTS
C     INTEGER T
C                  STARTING LOCATION IN THE WORK AREA
C                  FOR THE WORK VECTOR T
C     DOUBLE PRECISION VCV(IVCV,M)
C                  THE VARIANCE COVARIANCE MATRIX
C     INTEGER WRK
C                  THE STARTING LOCATION IN THE WORK AREA FOR
C                  WORK SPACE
C     DOUBLE PRECISION YM(IYM,M)
C                  THE OBSERVATION MATRIX
C
C
C     SET UP NAME ARRAY
C
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'C',      'O',      'R',      'R',      'S',      ' '/
C
C     SET UP FRAMEWORK VARIABLES FOR NUMBER TYPES
C
      IFP = 4
C
C     SET THE CALLER FLAG, THIS IS CORRS
C
      ICOR = 2
C
C     CHECK FOR ERRORS IN PARAMETERS
C
      CALL CORRER(NMSUB, M, N, IYM, IVCV, LDSTAK, ICOR, NPRT)
C
C     IF THERE IS AN ERROR RETURN TO THE CALLERS ROUTINE
C
      IF (IERR.EQ.0) GO TO 10
C
C     PRINT CORRECT FORM OF CALL STATEMENT AND RETURN TO CALLER
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     INITIALIZE THE STACK
C
   10 CALL STKSET (LDSTAK, 4)
      NALL0 = STKST(1)
C
C     ALLOCATE SPACE IN DSTAK FOR MATRICES
C
      LIWRK = MAX(N,M)
      LWRK = LIWRK
C
      WRK = STKGET(LWRK,IFP)
C
      IF (NPRT.EQ.0) THEN
         IWRK = WRK
         T = WRK
         RANK = WRK
         SC = WRK
         SCINV = WRK
         SLSC = WRK
         PC = WRK
         SLPC = WRK
         QUAD = WRK
         QF = WRK
      ELSE
         IWRK = STKGET(LIWRK,2)
         T = STKGET(M,IFP)
         RANK = STKGET(N*M,IFP)
         SC = STKGET(M*M,IFP)
         SCINV = STKGET(M*M,IFP)
         SLSC = STKGET(M*M,IFP)
         PC = STKGET(M*M,IFP)
         SLPC = STKGET(M*M,IFP)
         QUAD = STKGET(3*N,IFP)
         QF = STKGET(M*M,IFP)
      END IF
C
C     THE FOLLOWING VARIABLES HAVE BEEN INDIRECTLY EQUIVALENCED-
C
      CIUP = SLSC
      CILO = SLPC
      AVG = WRK
      SD = WRK
      SRCC = SCINV
C
      CALL CORRMN(YM, N, M, IYM, RSTAK(AVG), RSTAK(SD), RSTAK(T),
     +   RSTAK(RANK), RSTAK(SC), RSTAK(PC), RSTAK(SCINV), ISTAK(IWRK),
     +   RSTAK(WRK), RSTAK(SLSC), RSTAK(SLPC), RSTAK(SRCC),
     +   RSTAK(QUAD), RSTAK(CIUP), RSTAK(CILO), RSTAK(QF),
     +   NPRT, VCV, IVCV, LIWRK, LWRK)
C
C     RETURN AREA TO WORK
C
      CALL STKCLR(NALL0)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL CORRS (YM, N, M, IYM, LDSTAK, NPRT, VCV, IVCV)')
      END
*CORRXP
      SUBROUTINE CORRXP(M, VCV, IVCV, IPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     PRINT STORED OUTPUT RETURNED FROM CORRS
C
C     WRITTEN BY -
C        LINDA MITCHELL
C        STATISTICAL ENGINEERING DIVISION
C        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IPRT,IVCV,M
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VCV(*)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL MATPRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IPRT
C        THE LOGICAL OUTPUT NUMBER
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE MATRIX VCV
C     INTEGER M
C        THE NUMBER OF VARIABLES IN THE ANALYSIS
C     DOUBLE PRECISION VCV(IVCV,M)
C        ARRAYS TO BE PRINTED
C
      IF (IVCV.GE.M) THEN
         WRITE (IPRT,1000)
         WRITE (IPRT,1010)
         CALL MATPRT(VCV, VCV, M, IPRT, 1, 1, IVCV)
      END IF
C
C     FORMAT STATEMENTS
C
      RETURN
 1000 FORMAT (/ 20H STORAGE FROM CORRS.)
 1010 FORMAT (40H STORAGE FROM VARIANCE-COVARIANCE MATRIX)
      END
*CPYASF
      SUBROUTINE CPYASF (M, X, LX, Y, IY)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COPIES THE ELEMENTS OF SYMMETRIC MATRIX X,
C     STORED ROW WISE, TO MATRIX Y.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IY,LX,M
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),Y(IY,*)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IJ,J
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VALUE.
C     INTEGER IY
C        THE FIRST DIMENSION OF THE MATRIX Y.
C     INTEGER J
C        AN INDEX VALUE.
C     INTEGER LX
C        THE LENGTH OF SYMMETRIC MATRIX X, STORED ROW WISE.
C     INTEGER M
C        THE NUMBER OF COLUMNS OF DATA TO BE COPIED FROM MATRIX X.
C     DOUBLE PRECISION X(LX)
C        THE MATRIX TO BE COPIED FROM.
C     DOUBLE PRECISION Y(IY,M)
C        THE MATRIX TO BE COPIED TO.
C
      DO 20 I = 1, M
         DO 10 J = 1, I
            IJ = I*(I-1)/2 + J
            Y(I,J) = X(IJ)
            Y(J,I) = Y(I,J)
   10    CONTINUE
   20 CONTINUE
C
      RETURN
C
      END
*CPYMSS
      SUBROUTINE CPYMSS (N, M, X, IX, Y, IY)
C
C     LATEST REVISION  -  03/15/90  (JRD
C
C     THIS ROUTINE COPIES THE N BY M ELEMENTS OF MATRIX X TO
C     MATRIX Y.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IX,IY,M,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(IX,*),Y(IY,*)
C
C  LOCAL SCALARS
      INTEGER
     +   I,J
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VALUE.
C     INTEGER IX
C        THE FIRST DIMENSION OF THE MATRIX X.
C     INTEGER IY
C        THE FIRST DIMENSION OF THE MATRIX Y.
C     INTEGER J
C        AN INDEX VALUE.
C     INTEGER M
C        THE NUMBER OF COLUMNS OF DATA TO BE COPIED FROM MATRIX X.
C     INTEGER N
C        THE NUMBER OF ROWS OF DATA TO BE COPIED FROM MATRIX X.
C     DOUBLE PRECISION X(IX,M)
C        THE MATRIX TO BE COPIED FROM.
C     DOUBLE PRECISION Y(IY,M)
C        THE MATRIX TO BE COPIED TO.
C
C
      DO 20 J = 1, M
         DO 10 I = 1, N
            Y(I,J) = X(I,J)
   10    CONTINUE
   20 CONTINUE
C
      RETURN
C
      END
*CPYVII
      SUBROUTINE CPYVII(N,X,INCX,Y,INCY)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     COPY INTEGER X TO INTEGER Y.
C     FOR I = 0 TO N-1, COPY  X(LX+I*INCX) TO Y(LY+I*INCY),
C     WHERE LX = 1 IF INCX .GE. 0, ELSE LX = (-INCX)*N, AND LY IS
C     DEFINED IN A SIMILAR WAY USING INCY.
C
C     MODELED AFTER BLAS COPY ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   INCX,INCY,N
C
C  ARRAY ARGUMENTS
      INTEGER
     +   X(N),Y(N)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IX,IY,M,MP1,NS
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MOD
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VALUE.
C     INTEGER INCX
C        THE INCREMENT FOR THE MATRIX X.
C     INTEGER INCY
C        THE INCREMENT FOR THE MATRIX Y.
C     INTEGER N
C        THE NUMBER OF ROWS OF DATA TO BE COPIED FROM MATRIX X.
C     INTEGER X(N)
C        THE MATRIX TO BE COPIED FROM.
C     INTEGER Y(N)
C        THE MATRIX TO BE COPIED TO.
C
      IF(N.LE.0)RETURN
      IF(INCX.EQ.INCY) IF(INCX-1) 5,20,60
    5 CONTINUE
C
C        CODE FOR UNEQUAL OR NONPOSITIVE INCREMENTS.
C
      IX = 1
      IY = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        Y(IY) = X(IX)
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      RETURN
C
C        CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C        CLEAN-UP LOOP SO REMAINING VECTOR LENGTH IS A MULTIPLE OF 7.
C
   20 M = MOD(N,7)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        Y(I) = X(I)
   30 CONTINUE
      IF( N .LT. 7 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,7
        Y(I) = X(I)
        Y(I + 1) = X(I + 1)
        Y(I + 2) = X(I + 2)
        Y(I + 3) = X(I + 3)
        Y(I + 4) = X(I + 4)
        Y(I + 5) = X(I + 5)
        Y(I + 6) = X(I + 6)
   50 CONTINUE
      RETURN
C
C        CODE FOR EQUAL, POSITIVE, NONUNIT INCREMENTS.
C
   60 CONTINUE
      NS = N*INCX
          DO 70 I=1,NS,INCX
          Y(I) = X(I)
   70     CONTINUE
      RETURN
      END
*DCKCNT
      SUBROUTINE DCKCNT(XM, N, M, IXM, MDL, DRV, PAR, NPAR, NETA, NTAU,
     +   SCALE, LSCALE, NROW, NPRT, HDR, PAGE, WIDE, ISUBHD, HLFRPT,
     +   PRTFXD, IFIXED, LIFIXD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CONTROLS THE DERIVATIVE CHECKING PROCESS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISUBHD,IXM,LIFIXD,LSCALE,M,N,NETA,NPAR,NPRT,NROW,NTAU
      LOGICAL
     +   HLFRPT,PAGE,PRTFXD,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),SCALE(LSCALE),XM(IXM,M)
      INTEGER
     +   IFIXED(LIFIXD)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,HDR,MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   D,ETA,FPLRS,PV,SCL,TAU
      INTEGER
     +   DTEMP,IFIXD,IFP,INDXD,INDXPV,J,LMSG,MSG,NALL0,NDD,NDGT1,
     +   NDGT2,NROWU,PARTMP,PVTEMP
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      INTEGER
     +   STKGET,STKST
      EXTERNAL D1MACH,STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CPYVII,DCKMN,DCKOUT,ETAMDL,SETIV,SETROW,STKCLR
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG10
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION D
C        THE SCALAR IN WHICH ROW   NROWU   OF THE DERIVATIVE
C        MATRIX WITH RESPECT TO THE JTH UNKNOWN PARAMETER
C        IS STORED.
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER DTEMP
C        THE STARTING LOCATION IN THE WORK AREA IN WHICH
C        THE ARRAY IN WHICH THE ANALYTIC DERIVATIVES WITH
C        RESPECT TO EACH UNKNOWN PARAMETER ARE STORED.
C     DOUBLE PRECISION ETA
C        THE RELATIVE NOISE IN THE MODEL.
C     DOUBLE PRECISION FPLRS
C        THE FLOATING POINT LARGEST RELATIVE SPACING.
C     EXTERNAL HDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
C     LOGICAL HLFRPT
C        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
C        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
C        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFIXD
C        THE STARTING LOCATION IN ISTAK OF
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C     INTEGER IFIXED(LIFIXD)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER INDXD, INDXPV
C        THE INDEX IN THE WORK AREA OF
C        THE LOCATION OF THE VALUE OF THE
C        DERIVATIVE WITH RESPECT TO THE JTH PARAMETER AT ROW   NROWU
C        AND OF THE LOCATION OF THE PREDICTED VALUE FROM THE MODEL FOR R
C        ROW   NROWU   .
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED BY
C        ROUTINE HDR.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER LIFIXD
C        THE LENGTH OF THE VECTOR IFIXED.
C     INTEGER LMSG
C        THE LENGTH OF THE VECTOR MSG.
C     INTEGER LSCALE
C        THE LENGTH OF VECTOR SCALE.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER MSG
C        THE STARTING LOCATION IN THE WORK AREA OF
C        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS OF DATA.
C     INTEGER NALL0
C        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
C     INTEGER NDD
C        THE NUMBER OF DECIMAL DIGITS CARRIED FOR A SINGLE
C        PRECISION DOUBLE PRECISION NUMBER.
C     INTEGER NDGT1
C        THE NUMBER OF RELIABLE DIGITS IN THE MODEL USED, EITHER
C        SET TO THE USER SUPPLIED VALUE OF NETA, OR COMPUTED
C        BY ETAMDL.
C     INTEGER NDGT2
C        THE ACTUAL NUMBER OF DIGITS OF AGREEMENT USED, EITHER
C        SET TO THE USER SUPPLIED VALUE OF NTAU, OR COMPUTED
C        FROM NDGT1.
C     INTEGER NETA
C        THE USER SUPPLIED NUMBER OF RELIABLE DIGITS IN THE MODEL.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
C     INTEGER NROW, NROWU
C        THE USER-SUPPLIED NUMBER OF THE ROW OF THE INDEPENDENT
C        VARIABLE ARRAY AT WHICH THE DERIVATIVE IS TO BE CHECKED,
C        AND THE NUMBER OF THE ROW ACTUALLY USED.
C     INTEGER NTAU
C        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
C        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     INTEGER PARTMP
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE MODIFIED MODEL PARAMETERS
C     LOGICAL PRTFXD
C        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
C        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
C        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PV
C        THE SCALAR IN WHICH THE PREDICTED VALUE FROM THE MODEL FOR
C        ROW   NROW   IS STORED.
C     INTEGER PVTEMP
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
C     DOUBLE PRECISION SCL
C        THE ACTUAL TYPICAL SIZE USED.
C     DOUBLE PRECISION TAU
C        THE AGREEMENT TOLERANCE.
C     LOGICAL WIDE
C       THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
      NALL0 = STKST(1)
C
      FPLRS = D1MACH(4)
C
C     SELECT FIRST ROW OF INDEPENDENT VARIABLES WHICH CONTAINS NO ZEROS
C
      CALL SETROW(NROW, XM, N, M, IXM, NROWU)
C
C     SUBDIVIDE WORK AREA
C
      IFP = 4
C
      LMSG = NPAR + 1
C
      IFIXD = STKGET(NPAR,2)
      MSG = STKGET(LMSG,2)
      DTEMP = STKGET(N*NPAR,IFP)
      PARTMP = STKGET(NPAR,IFP)
      PVTEMP = STKGET(N,IFP)
C
      IF (IERR.EQ.1) RETURN
C
C     SET UP IFIXD
C
      IF (IFIXED(1).LT.0) CALL SETIV(ISTAK(IFIXD), NPAR, 0)
      IF (IFIXED(1).GE.0) CALL CPYVII(NPAR, IFIXED, 1, ISTAK(IFIXD), 1)
C
C     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
C
      NDD = -LOG10(FPLRS)
C
      IF ((NETA.LT.2) .OR. (NETA.GT.NDD)) THEN
         CALL ETAMDL(MDL, PAR, NPAR, XM, N, M, IXM, ETA, NDGT1,
     +      RSTAK(PARTMP), RSTAK(PVTEMP), NROWU)
      ELSE
         ETA = 10.0D0**(-NETA)
         NDGT1 = NETA
      END IF
C
      IF ((NTAU.LT.1) .OR. (NTAU.GT.(NDGT1-1)/2)) THEN
         NDGT2 = (NDGT1+3)/4
      ELSE
         NDGT2 = NTAU
      END IF
C
      TAU = 10.0D0**(-NDGT2)
C
      INDXPV = PVTEMP + NROWU - 1
C
C     COMPUTE PREDICTED VALUE OF MODEL USING CURRENT PARAMETER
C     ESTIMATES, AND COMPUTE USER-SUPPLIED DERIVATIVE VALUES
C
      CALL MDL(PAR, NPAR, XM, N, M, IXM, RSTAK(PVTEMP))
      PV = RSTAK(INDXPV)
      CALL DRV(PAR, NPAR, XM, N, M, IXM, RSTAK(DTEMP))
C
      ISTAK(MSG) = 0
C
      DO 30 J=1,NPAR
C
         IF (SCALE(1).GT.0.0D0) THEN
            SCL = SCALE(J)
         ELSE
            SCL = PAR(J)
         END IF
         IF (SCL.EQ.0.0D0) SCL = 1.0D0
C
C     CALL ROUTINE TO CHECK USER SUPPLIED NUMERICAL DERIVATIVES
C     WITH RESPECT TO THE JTH PARAMETER.
C
         INDXD = DTEMP - 1 + N*(J-1) + NROWU
C
         D = RSTAK(INDXD)
         CALL DCKMN(J, D, PAR, SCL, NPAR, ETA, TAU, MDL, XM, N, NROWU,
     +      M, IXM, PV, RSTAK(PVTEMP), ISTAK(MSG), LMSG)
C
   30 CONTINUE
C
      IF (ISTAK(MSG).GE.1) IERR = ISTAK(MSG) + 1
C
C     PRINT RESULTS IF THEY ARE DESIRED
C
      HLFRPT = .FALSE.
C
      IF ((NPRT.NE.0) .OR. (IERR.NE.0)) THEN
         HLFRPT = .TRUE.
         CALL DCKOUT(XM,IXM,N,M,NROWU,NDGT1,NDGT2,NPAR,ISTAK(MSG),
     +      LMSG,PAR,SCALE,LSCALE,HDR,PAGE,WIDE,ISUBHD,PRTFXD,
     +      ISTAK(IFIXD))
      END IF
C
      CALL STKCLR(NALL0)
C
      RETURN
C
      END
*DCKCRV
      SUBROUTINE DCKCRV(J, D, PAR, NPAR, ETA, TAU, MDL, XM, N,
     +   NROW, M, IXM, PV, PVTEMP, MSG, LMSG, FD, PARMX, PVPSTP, STP)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS WHETHER HIGH CURVATURE COULD BE THE CAUSE
C     OF THE DISAGREEMENT BETWEEN THE NUMERICAL AND ANALYTIC DERIVATIVES
C
C     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   D,ETA,FD,PARMX,PV,PVPSTP,STP,TAU
      INTEGER
     +   IXM,J,LMSG,M,N,NPAR,NROW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PVTEMP(N),XM(IXM,M)
      INTEGER
     +   MSG(LMSG)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CURVE,FPLRS,PVMCRV,PVPCRV,STPCRV,TEMP,THIRD
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DCKFPA
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,SIGN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CURVE
C        A MEASURE OF THE CURVATURE IN THE MODEL.
C     DOUBLE PRECISION D
C        THE SCALAR IN WHICH ROW   NROW   OF THE DERIVATIVE
C        MATRIX WITH RESPECT TO THE JTH UNKNOWN PARAMETER
C        IS STORED.
C     DOUBLE PRECISION ETA
C        THE RELATIVE NOISE IN THE MODEL.
C     DOUBLE PRECISION FD
C        THE FORWARD DIFFERENCE QUOTIENT DERIVATIVE WITH RESPECT TO THE
C        JTH PARAMETER.
C     DOUBLE PRECISION FPLRS
C        THE FLOATING POINT LARGEST RELATIVE SPACING.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER J
C        THE INDEX OF THE PARTIAL DERIVATIVE BEING EXAMINED.
C     INTEGER LMSG
C        THE LENGTH OF THE VECTOR MSG.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER MSG(LMSG)
C        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NROW
C        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
C        WHICH THE DERIVATIVE IS TO BE CHECKED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION PARMX
C        THE MAXIMUM OF THE CURRENT PARAMETER ESTIMATE.
C     DOUBLE PRECISION PV
C        THE SCALAR IN WHICH THE PREDICTED VALUE FROM THE MODEL FOR
C        ROW   NROW   IS STORED.
C     DOUBLE PRECISION PVMCRV
C        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
C        BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)-STPCRV.
C     DOUBLE PRECISION PVPCRV
C        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
C        BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCRV.
C     DOUBLE PRECISION PVPSTP
C        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
C        BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J) + STP.
C     DOUBLE PRECISION PVTEMP(N)
C        THE VECTOR OF PREDICTED VALUES FROM THE MODEL.
C     DOUBLE PRECISION STP
C        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FINITE DIFFERENC
C        DERIVATIVE
C     DOUBLE PRECISION STPCRV
C        THE STEP SIZE SELECTED TO CHECK FOR CURVATURE IN THE MODEL.
C     DOUBLE PRECISION TAU
C        THE AGREEMENT TOLERANCE.
C     DOUBLE PRECISION TEMP
C        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
C        PARAMETER IS STORED.
C     DOUBLE PRECISION THIRD
C        THE VALUE ONE THIRD.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
      FPLRS = D1MACH(4)
C
      THIRD = 1.0D0/3.0D0
C
      STPCRV = (ETA**THIRD*PARMX*SIGN(1.0D0,PAR(J))+PAR(J)) - PAR(J)
C
      TEMP = PAR(J)
      PAR(J) = TEMP + STPCRV
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVTEMP)
C
      PVPCRV = PVTEMP(NROW)
C
      PAR(J) = TEMP - STPCRV
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVTEMP)
      PAR(J) = TEMP
C
      PVMCRV = PVTEMP(NROW)
C
C     ESTIMATE CURVATURE BY SECOND DERIVATIVE OF MODEL WITH RESPECT TO
C     PAR(J)
C
      CURVE = ((PVPCRV+PVMCRV)-2*PV) / (STPCRV*STPCRV)
      CURVE = CURVE + (ETA ** THIRD) * (ABS(PVPCRV) +
     +   ABS(PVMCRV) + 2.0D0 * ABS(PV)) / (PARMX * PARMX)
C
C     COMPARE NUMERICAL AND ANALYTICAL DERIVATIVES USING A FUDGE
C     FACTOR OF 10.0D0.
C
      IF (ABS(CURVE*STP)*5.0D0.LT.ABS(FD-D)) THEN
C
C     CURVATURE CANNOT ACCOUNT FOR DISCREPANCY.
C     CHECK IF FINITE PRECISION ARITHMETIC COULD BE THE CULPRIT.
C
         CALL DCKFPA(J,D,PAR,NPAR,ETA,TAU,MDL,XM,N,NROW,
     +      M,IXM,PV,PVTEMP,MSG,LMSG,FD,PARMX,STP,PVPSTP,CURVE)
C
      ELSE
C
C     HIGH CURVATURE COULD BE THE PROBLEM.  TRY A SMALLER STEP SIZE.
C     COMPUTE SMALLER STEPSIZE
C
         STP = (2.0D0*TAU*ABS(D)*SIGN(1.0D0,PAR(J))/ABS(CURVE)+PAR(J))
     +          - PAR(J)
C
         IF (ABS(STP).LE.FPLRS*ABS(PAR(J))) THEN
C
C     NEW STEP SIZE IS TOO SMALL TO USE.
C
            IF (MSG(1).EQ.0) MSG(1) = 1
            MSG(J+1) = 1
         ELSE
C
C     TRY NEW STEP SIZE
C
            TEMP = PAR(J)
            PAR(J) = TEMP + STP
            CALL MDL(PAR, NPAR, XM, N, M, IXM, PVTEMP)
            PAR(J) = TEMP
            PVPSTP = PVTEMP(NROW)
C
C     COMPUTE THE NEW NUMERICAL DERIVATIVE
C
            FD = (PVPSTP-PV)/STP
C
C     CHECK WHETHER THE NEW NUMERICAL DERIVATIVE IS NOT OK
C
            IF (ABS(FD-D).GT.2.0D0*TAU*ABS(D)) THEN
C
C     NUMERICAL DERIVATIVE COMPUTED USING NEW STEP SIZE DOES
C     NOT AGREE WITH ANALYTIC DERIVATIVE.
C
C     CHECK IF THE PROBLEM COULD BE THE FORWARD DIFFERENCE QUOTIENT
C     DERIVATIVE.
C     (FUDGE FACTOR IS 2)
C
               IF (ABS(STP*(FD-D)).GE.2.0D0*ETA*ABS(PV+PVPSTP)) THEN
C
C     FINITE PRECISION COULD NOT BE THE CULPRIT
C
                  MSG(1) = 2
                  MSG(J+1) = 2
               ELSE
C
C     FINITE PRECISION MAY BE THE CULPRIT
C
                  IF (MSG(1).EQ.0) MSG(1) = 1
                  MSG(J+1) = 1
               END IF
            END IF
         END IF
      END IF
      RETURN
C
      END
*DCKDRV
      SUBROUTINE DCKDRV (NMSUB, LDSTAK, XM, N, M, IXM, MDL,
     +   DRV, PAR, NPAR, NETA, NTAU, SCALE, LSCALE, NROW, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE IS THE DRIVER FOR THE DERIVATIVE CHECKING ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,LSCALE,M,N,NETA,NPAR,NPRT,NROW,NTAU
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),SCALE(*),XM(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   ISUBHD,LIFIXD
      LOGICAL
     +   HLFRPT,PAGE,PRTFXD,WIDE
C
C  LOCAL ARRAYS
      INTEGER
     +   IFIXED(1)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DCKCNT,DCKER,DCKHDR,STKSET
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     EXTERNAL DCKHDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL HLFRPT
C        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
C        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
C        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFIXED(1)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE LENGTH OF THE VECTOR IFIXED.
C     INTEGER LSCALE
C        THE LENGTH OF VECTOR SCALE.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS OF DATA.
C     INTEGER NETA
C        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
C     INTEGER NROW
C        THE USER-SUPPLIED NUMBER OF THE ROW OF THE INDEPENDENT
C        VARIABLE ARRAY AT WHICH THE DERIVATIVE IS TO BE CHECKED.
C     INTEGER NTAU
C        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
C        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     LOGICAL PRTFXD
C        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
C        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
C        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION XM(IXM,M)
C        THE INDEPENDENT VARIABLE ARRAY
C
C
C     CHECK FOR ERRORS IN INPUT PARAMETERS
C
      CALL DCKER(NMSUB, N, M, IXM, NPAR, LDSTAK, SCALE, LSCALE)
C
      IF (IERR.NE.0) RETURN
C
      PAGE = .FALSE.
      WIDE = .TRUE.
      ISUBHD = 0
C
      PRTFXD = .FALSE.
      IFIXED(1) = -1
      LIFIXD = 1
C
      CALL STKSET(LDSTAK, 4)
C
C     PASS CONTROL OF DERIVATIVE CHECKING TO DCKCNT
C
      CALL DCKCNT (XM, N, M, IXM, MDL, DRV, PAR, NPAR, NETA,
     +   NTAU, SCALE, LSCALE, NROW, NPRT, DCKHDR, PAGE, WIDE, ISUBHD,
     +   HLFRPT, PRTFXD, IFIXED, LIFIXD)
C
      RETURN
C
      END
*DCKER
      SUBROUTINE DCKER(NMSUB, N, M, IXM, NPAR, LDSTAK, SCALE, LSCALE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE ERROR CHECKING ROUTINE FOR DERIVATIVE CHECKING
C     ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,LSCALE,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   SCALE(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I,LDSMIN,NV
      LOGICAL
     +   HEAD
C
C  LOCAL ARRAYS
      LOGICAL
     +   ERROR(10)
      CHARACTER
     +   LIXM(8)*1,LLDS(8)*1,LM(8)*1,LN(8)*1,LNPAR(8)*1,
     +   LSCL(8)*1,LZERO(8)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISLE,ERVGT,LDSCMP
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR(10)
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX VALUE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     CHARACTER*1 LIXM(8), LLDS(8), LM(8), LN(8), LNPAR(8), LSCL(8),
C    *   LZERO(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
C        CHECKED FOR ERRORS.
C     INTEGER LSCALE
C        THE LENGTH OF VECTOR SCALE.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NV
C        THE NUMBER OF VIOLATIONS FOUND BY THE SCALE CHECKING ROUTINE.
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
C
C     SET UP NAME ARRAYS
C
      DATA LIXM(1), LIXM(2), LIXM(3), LIXM(4), LIXM(5), LIXM(6),
     +   LIXM(7), LIXM(8) /'I','X','M',' ',' ',' ',' ',' '/
      DATA LM(1), LM(2), LM(3), LM(4), LM(5), LM(6), LM(7), LM(8) /'M',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     +   LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',
     +   ' '/
      DATA LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8) /'N',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LNPAR(1), LNPAR(2), LNPAR(3), LNPAR(4), LNPAR(5),
     +   LNPAR(6), LNPAR(7), LNPAR(8) /'N','P',' ',' ',' ',' ',' ',
     +   ' '/
      DATA LSCL(1), LSCL(2), LSCL(3), LSCL(4), LSCL(5),
     +   LSCL(6), LSCL(7), LSCL(8) /'S','C','A','L','E',' ',' ',
     +   ' '/
      DATA LZERO(1), LZERO(2), LZERO(3), LZERO(4), LZERO(5),
     +   LZERO(6), LZERO(7), LZERO(8) /'Z','E','R','O',' ',' ',' ',' '/
C
C     ERROR CHECKING
C
      DO 10 I=1,10
         ERROR(I) = .FALSE.
   10 CONTINUE
C
      IERR = 0
      HEAD = .TRUE.
C
      CALL EISGE(NMSUB, LN, N, 1, 1, HEAD, ERROR(1), LN)
C
      CALL EISGE(NMSUB, LM, M, 1, 1, HEAD, ERROR(2), LM)
C
      CALL EISGE(NMSUB, LIXM, IXM, N, 3, HEAD, ERROR(3), LN)
C
      CALL EISLE(NMSUB, LNPAR, NPAR, N, 2, HEAD, ERROR(4), LN)
C
      CALL LDSCMP(5, 0, 2*NPAR+1, 0, 0, 0, 'D',
     +            N*NPAR + NPAR + N, LDSMIN)
C
      IF ((.NOT.ERROR(1)) .AND. (.NOT.ERROR(4)))
     +   CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR(5),
     +   LLDS)
C
      CALL ERVGT(NMSUB, LSCL, SCALE, LSCALE, 0.0D0, 0, HEAD, 6, NV,
     +   ERROR(9), LZERO)
C
      DO 20 I=1,10
         IF (ERROR(I)) GO TO 30
   20 CONTINUE
      RETURN
C
   30 CONTINUE
      IERR = 1
      RETURN
C
      END
*DCKFPA
      SUBROUTINE DCKFPA(J, D, PAR, NPAR, ETA, TAU, MDL, XM, N,
     +   NROW, M, IXM, PV, PVTEMP, MSG, LMSG, FD, PARMX, STP, PVPSTP,
     +   CURVE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     CHECK WHETHER FINITE PRECISION ARITHMETIC COULD POSSIBLY BE THE
C     PROBLEM
C
C     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CURVE,D,ETA,FD,PARMX,PV,PVPSTP,STP,TAU
      INTEGER
     +   IXM,J,LMSG,M,N,NPAR,NROW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PVTEMP(N),XM(IXM,M)
      INTEGER
     +   MSG(LMSG)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   TEMP
      LOGICAL
     +   LARGE
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,SIGN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CURVE
C        A MEASURE OF THE CURVATURE IN THE MODEL.
C     DOUBLE PRECISION D
C        THE SCALAR IN WHICH ROW   NROW   OF THE DERIVATIVE
C        MATRIX WITH RESPECT TO THE JTH UNKNOWN PARAMETER
C        IS STORED.
C     DOUBLE PRECISION ETA
C        THE RELATIVE NOISE IN THE MODEL
C     DOUBLE PRECISION FD
C        THE FORWARD DIFFERENCE QUOTIENT DERIVATIVE WITH RESPECT TO THE
C        JTH PARAMETER
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER J
C        THE INDEX OF THE PARTIAL DERIVATIVE BEING EXAMINED.
C     LOGICAL LARGE
C        AN INDICATOR VALUE INDICATING WHETHER THE RECOMMENDED
C        INCREASE IN THE STEP SIZE WOULD BE GREATER THAN PARMX.
C     INTEGER LMSG
C        THE LENGTH OF THE VECTOR MSG.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER MSG(LMSG)
C        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NROW
C        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
C        WHICH THE DERIVATIVE IS TO BE CHECKED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION PARMX
C        THE MAXIMUM OF THE CURRENT PARAMETER ESTIMATE AND THE
C        TYPICAL VALUE OF THAT PARAMETER
C     DOUBLE PRECISION PV
C        THE SCALAR IN WHICH THE PREDICTED VALUE FROM THE MODEL FOR
C        ROW   NROW   IS STORED.
C     DOUBLE PRECISION PVPSTP
C        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
C        BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J) + STP.
C     DOUBLE PRECISION PVTEMP(N)
C        THE VECTOR OF PREDICTED VALUES FROM THE MODEL.
C     DOUBLE PRECISION STP
C        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FINITE DIFFERENC
C        DERIVATIVE
C     DOUBLE PRECISION TAU
C        THE AGREEMENT TOLERANCE.
C     DOUBLE PRECISION TEMP
C        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
C        PARAMETER IS STORED.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
C     CHECK WHETHER FINITE PRECISION COULD BE THE PROBLEM
C
      IF (ABS(STP*(FD-D)) .GE.
     +   10.0D0*ETA*(ABS(PV)+ABS(PVPSTP))) THEN
C
C     DISCREPANCY BETWEEN NUMERICAL AND ANALYTICAL DERIVATIVES CANNOT
C     BE ACCOUNTED FOR BY FINITE PRECISION ARITHMETIC
C
         MSG(1) = 2
         MSG(J+1) = 2
         RETURN
C
      END IF
C
C     FINITE PRECISION ARITHMETIC COULD BE THE PROBLEM.
C
C     TRY A LARGER STEP SIZE
C
      STP = (ETA*(ABS(PV)+ABS(PVPSTP))*SIGN(1.0D0,PAR(J))/
     +   (TAU*ABS(D))+PAR(J)) - PAR(J)
C
      LARGE = .FALSE.
C
      IF (ABS(STP).GT.PARMX) THEN
         STP = PARMX*SIGN(1.0D0,PAR(J))
         LARGE = .TRUE.
      END IF
C
C     CALCULATE NUMERICAL DERIVATIVE USNG NEW, LARGER, STEPSIZE
C
      TEMP = PAR(J)
      PAR(J) = PAR(J) + STP
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVTEMP)
      PAR(J) = TEMP
C
      PVPSTP = PVTEMP(NROW)
C
      FD = (PVPSTP-PV)/STP
C
C     CHECK FOR AGREEMENT
C
      IF ((ABS(FD-D)).LE.2.0D0*TAU*ABS(D)) THEN
C
C     FORWARD DIFFERENCE QUOTIENT AND ANALYTIC DERIVATIVES AGREE FOR
C     THIS STEP SIZE
C
         RETURN
      END IF
C
C     FORWARD DIFFERENCE QUOTIENT AND ANALYTIC DERIVATIVES STILL
C     DISAGREE
C
C     CHECK IF CURVATURE IS THE PROBLEM
C
      IF (ABS(CURVE*STP) .LT. ABS(FD-D) .AND. (.NOT. LARGE)) THEN
C
C        CURVATURE COULDNT BE THE CULPRIT
C
             MSG(1) = 2
             MSG(J+1) = 2
             RETURN
      ELSE
C
C        CURVATURE MAY BE THE CULPRIT
C
             IF (MSG(1).EQ.0) MSG(1) = 1
             IF (LARGE) MSG(J+1) = 6
             IF (.NOT. LARGE) MSG(J+1) = 1
             RETURN
      END IF
C
      END
*DCKHDR
      SUBROUTINE DCKHDR(PAGE, WIDE, ISUBHD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS THE PAGE HEADINGS FOR THE
C     DERIVATIVE CHECKING ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISUBHD
      LOGICAL
     +   PAGE,WIDE
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VERSP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C       THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        FULL WIDTH (TRUE) OR NOT (FALSE).
C
      CALL IPRINT(IPRT)
      IF (PAGE) WRITE (IPRT, 1020)
      CALL VERSP(WIDE)
      IF (PAGE) WRITE (IPRT,1000)
      IF (.NOT.PAGE) WRITE (IPRT,1010)
      PAGE = .TRUE.
C
      IF (ISUBHD.EQ.0) RETURN
C
      GO TO (10), ISUBHD
C
   10 WRITE (IPRT, 1030)
C
      RETURN
C
C     FORMAT STATEMENTS FOR PAGE HEADINGS
C
 1000 FORMAT (21H+DERIVATIVE CHECKING,,
     +   10H CONTINUED)
 1010 FORMAT ('+', 23(1H*)/ 24H * DERIVATIVE CHECKING */ 1X, 23(1H*))
 1020 FORMAT ('1')
 1030 FORMAT (//30H SUMMARY OF INITIAL CONDITIONS/ 1X, 30('-'))
      END
*DCKLS
      SUBROUTINE DCKLS(XM, N, M, IXM, MDL, DRV, PAR, NPAR, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR CHECKING USER SUPPLIED
C     ANALYTIC DERIVATIVES AGAINST NUMERICAL DERIVATIVES
C     FOR THE NONLINEAR LEAST SQUARES ROUTINES (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),XM(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,LSCALE,NETA,NPRT,NROW,NTAU
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   SCALE(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DCKDRV,IPRINT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LSCALE
C        THE LENGTH OF VECTOR SCALE.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS OF DATA.
C     INTEGER NETA
C        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
C     INTEGER NROW
C        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
C        WHICH THE DERIVATIVE IS TO BE CHECKED.
C     INTEGER NTAU
C        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
C        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION SCALE(1)
C        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE INDEPENDENT VARIABLE MATRIX.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'D','C','K','L','S',' '/
C
C     SET DEFAULT VALUES
C
      NETA = 0
      NTAU = 0
      SCALE(1) = 0.0D0
      LSCALE = 1
      NPRT = 1
      NROW = 0
C
C     PASS CONTROL OF DERIVATIVE CHECKING TO DCKDRV
C
      CALL DCKDRV(NMSUB, LDSTAK, XM, N, M, IXM, MDL, DRV, PAR, NPAR,
     +   NETA, NTAU, SCALE, LSCALE, NROW, NPRT)
C
      IF (IERR.NE.1) RETURN
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL DCKLS (XM, N, M, IXM, NLSMDL, NLSDRV,'/
     +   '      +            PAR, NPAR, LDSTAK)')
      END
*DCKLSC
      SUBROUTINE DCKLSC(XM, N, M, IXM, MDL, DRV, PAR, NPAR, LDSTAK,
     +   NETA, NTAU, SCALE, NROW, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR CHECKING USER SUPPLIED
C     ANALYTIC DERIVATIVES AGAINST NUMERICAL DERIVATIVES
C     FOR THE NONLINEAR LEAST SQUARES ROUTINES (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,M,N,NETA,NPAR,NPRT,NROW,NTAU
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),SCALE(*),XM(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,LSCALE
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DCKDRV,IPRINT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LSCALE
C        THE LENGTH OF VECTOR SCALE.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS OF DATA.
C     INTEGER NETA
C        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
C     INTEGER NROW
C        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
C        WHICH THE DERIVATIVE IS TO BE CHECKED.
C     INTEGER NTAU
C        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
C        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION SCALE(NPAR)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE INDEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'D','C','K','L','S','C'/
C
      LSCALE = NPAR
C
C     PASS CONTROL OF DERIVATIVE CHECKING TO DCKDRV
C
      CALL DCKDRV(NMSUB, LDSTAK, XM, N, M, IXM, MDL, DRV, PAR, NPAR,
     +   NETA, NTAU, SCALE, LSCALE, NROW, NPRT)
C
      IF (IERR.NE.1) RETURN
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL DCKLSC (XM, N, M, IXM, NLSMDL, NLSDRV,'/
     +   '      +             PAR, NPAR, LDSTAK,'/
     +   '      +             NETA, NTAU, SCALE, NROW, NPRT)')
      END
*DCKLS1
      SUBROUTINE DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE,
     +   NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     SET UP PROBLEM SPECIFICATION FOR TESTING THE USER CALLABLE
C     ROUTINES IN THE (LEAST SQUARES) STEP SIZE SELECTION FAMILY.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NETA,NPAR,NPRT,NROW,NTAU
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(10),SCALE(10)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NETA
C        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     INTEGER NROW
C        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
C        WHICH THE DERIVATIVE IS TO BE CHECKED.
C     INTEGER NTAU
C        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
C        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
C     DOUBLE PRECISION PAR(10)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION SCALE(10)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
C
C
      PAR(1) = 1.0D0
      PAR(2) = 3.125D0
      PAR(3) = 1.0D0
      PAR(4) = 2.0D0
C
      N = 101
      M = 1
      IXM = 200
      NPAR = 4
      DO 10 I=1,10
         SCALE(I) = 1.0D0
   10 CONTINUE
      SCALE(2) = 0.01D0
      NETA = 0
      NTAU = 0
      NROW = 1
      NPRT = 1
C
      RETURN
C
      END
*DCKMN
      SUBROUTINE DCKMN(J, D, PAR, SCALE, NPAR, ETA, TAU, MDL, XM,
     +   N, NROW, M, IXM, PV, PVTEMP, MSG, LMSG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN SUBROUTINE FOR CHECKING USER SUPPLIED
C     ANALYTIC DERIVATIVES AGAINST NUMERICAL DERIVATIVES
C
C     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   D,ETA,PV,SCALE,TAU
      INTEGER
     +   IXM,J,LMSG,M,N,NPAR,NROW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PVTEMP(N),XM(IXM,M)
      INTEGER
     +   MSG(LMSG)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FD,PARMX,PVPSTP,STP,TEMP
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DCKCRV,DCKZRO
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,SIGN,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION D
C        THE SCALAR IN WHICH ROW   NROW   OF THE DERIVATIVE
C        MATRIX WITH RESPECT TO THE JTH UNKNOWN PARAMETER
C        IS STORED.
C     DOUBLE PRECISION ETA
C        THE RELATIVE NOISE IN THE MODEL
C     DOUBLE PRECISION FD
C        THE FORWARD DIFFERENCE QUOTIENT DERIVATIVE WITH RESPECT TO THE
C        JTH PARAMETER
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER J
C        THE INDEX OF THE PARTIAL DERIVATIVE BEING EXAMINED.
C     INTEGER LMSG
C        THE LENGTH OF THE VECTOR MSG.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER MSG(LMSG)
C        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NROW
C        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
C        WHICH THE DERIVATIVE IS TO BE CHECKED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION PARMX
C        THE MAXIMUM OF THE CURRENT PARAMETER ESTIMATE AND THE
C        TYPICAL VALUE OF THAT PARAMETER
C     DOUBLE PRECISION PV
C        THE SCALAR IN WHICH THE PREDICTED VALUE FROM THE MODEL FOR
C        ROW   NROW   IS STORED.
C     DOUBLE PRECISION PVPSTP
C        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
C        BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J) + STP.
C     DOUBLE PRECISION PVTEMP(N)
C        THE VECTOR OF PREDICTED VALUE FROM THE MODEL.
C     DOUBLE PRECISION SCALE
C        THE TYPICAL SIZE OF THE JTH PARAMETER.
C     DOUBLE PRECISION STP
C        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FINITE DIFFERENC
C        DERIVATIVE
C     DOUBLE PRECISION TAU
C        THE AGREEMENT TOLERANCE.
C     DOUBLE PRECISION TEMP
C        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
C        PARAMETER IS STORED.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
C     CALCULATE THE JTH PARTIAL DERIVATIVE USING FORWARD DIFFERENCE
C     QUOTIENTS AND DECIDE IF IT AGREES WITH USER SUPPLIED VALUES
C
      MSG(J+1) = 0
C
      PARMX = MAX(ABS(PAR(J)),ABS(SCALE))
      IF (PARMX .EQ. 0.0D0) PARMX = 1.0D0
C
C     COMPUTE INITIAL STEP SIZE
C
      STP = (SQRT(ETA)*PARMX*SIGN(1.0D0,PAR(J))+PAR(J)) - PAR(J)
C
C     COMPUTE PREDICTED VALUES
C
      TEMP = PAR(J)
      PAR(J) = PAR(J) + STP
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVTEMP)
      PAR(J) = TEMP
C
      PVPSTP = PVTEMP(NROW)
C
      FD = (PVPSTP-PV)/STP
C
C     CHECK FOR DISAGREEMENT
C
      IF (ABS(FD-D) .GT. TAU*ABS(D)) GO TO 10
C
C     NUMERICAL AND ANALYTIC DERIVATIVES AGREE
C
C     CHECK IF ANALYTIC DERIVATIVE IS IDENTICALLY ZERO, INDICATING
C     THE POSSIBILITY THAT THE DERIVATIVE SHOULD BE RECHECKED AT
C     ANOTHER POINT.
C
      IF (D.NE.0.0D0) RETURN
C
C     JTH ANALYTIC AND NUMERICAL DERIVATIVES BOTH ARE ZERO.
C
      IF (MSG(1).EQ.0) MSG(1) = 1
      MSG(J+1) = 3
      RETURN
C
   10 CONTINUE
C
C     NUMERICAL AND ANALYTIC DERIVATIVES DISAGREE
C
C     CHECK WHY
C
      IF (D.EQ.0.0D0) THEN
         CALL DCKZRO(J, PAR, NPAR, MDL, XM, N,
     +      NROW, M, IXM, PV, PVTEMP, MSG, LMSG, FD, PARMX, PVPSTP,
     +      STP)
      ELSE
         CALL DCKCRV(J, D, PAR, NPAR, ETA, TAU, MDL, XM,
     +      N, NROW, M, IXM, PV, PVTEMP, MSG, LMSG, FD, PARMX,
     +      PVPSTP, STP)
      END IF
C
      RETURN
      END
*DCKOUT
      SUBROUTINE DCKOUT(XM, IXM, N, M, NROW, NETA, NTAU, NPAR, MSG,
     +   LMSG, PAR, SCALE, LSCALE, HDR, PAGE, WIDE, ISUBHD, PRTFXD,
     +   IFIXD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRINTS THE RESULTS OF THE DERIVATIVE CHECKING
C     SUBROUTINE
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISUBHD,IXM,LMSG,LSCALE,M,N,NETA,NPAR,NROW,NTAU
      LOGICAL
     +   PAGE,PRTFXD,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),SCALE(LSCALE),XM(IXM,M)
      INTEGER
     +   IFIXD(NPAR),MSG(LMSG)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL HDR
C
C  LOCAL SCALARS
      INTEGER
     +   I,IMAX,IMIN,INDEX,IPRT,J,K,NPERL
      CHARACTER
     +   BLANK*1
C
C  LOCAL ARRAYS
      LOGICAL
     +   FTNOTE(6)
      CHARACTER
     +   FIXED(3)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL FIXPRT,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     CHARACTER*1 BLANK
C        THE CHARACTER BLANK.
C     CHARACTER*1 FIXED(3)
C        THE CHARACTERS USED TO LABEL THE PARAMETERS FIXED OR NOT.
C     LOGICAL FTNOTE(6)
C        THE ARRAY WHICH CONTROLS PRINTING OF FOOTNOTES.
C     EXTERNAL HDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXD(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXD(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C     INTEGER IMAX, IMIN
C        THE LARGEST AND SMALLEST INDEX VALUE TO BE PRINTED ON EACH
C        LINE.
C     INTEGER INDEX
C        THE INDEX VALUE TO BE PRINTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED BY
C        ROUTINE HDR.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER K
C        AN INDEX VARIABLE.
C     INTEGER LMSG
C        THE LENGTH OF THE VECTOR MSG.
C     INTEGER LSCALE
C        THE LENGTH OF VECTOR SCALE.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MSG(LMSG)
C        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
C     INTEGER NETA
C        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPERL
C        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
C     INTEGER NROW
C        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
C        WHICH THE DERIVATIVE IS TO BE CHECKED.
C     INTEGER NTAU
C        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
C        APPROXIMATED DERIVATIVES AND THE USER-SUPPLIED DERIVATIVES.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     LOGICAL PRTFXD
C        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
C        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
C        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
C     LOGICAL WIDE
C       THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION XM(IXM,M)
C        THE INDEPENDENT VARIABLE.
C
      DATA BLANK /' '/
C
      CALL IPRINT(IPRT)
C
C     INITIALIZE ARRAY FIXED
C
      DO 10 K=1,3
         FIXED(K) = BLANK
   10 CONTINUE
C
      CALL HDR(PAGE, WIDE, ISUBHD)
C
C     SET UP FOR FOOTNOTES
C
      DO 20 I=1,6
         FTNOTE(I) = .FALSE.
   20 CONTINUE
C
      IF (MSG(1).LE.0) GO TO 40
C
      DO 30 I=1,NPAR
         IF ((MSG(I+1).EQ.0) .OR. (MSG(I+1).EQ.2)) GO TO 30
         K = MSG(I+1) - 2
         IF (K.EQ.-1) K = 5
         FTNOTE(1) = .TRUE.
         FTNOTE(K+1) = .TRUE.
   30 CONTINUE
C
C     PRINT REPORT
C
   40 CONTINUE
C
      WRITE (IPRT,1000)
      IF (FTNOTE(1)) WRITE (IPRT,1040)
      IF (PRTFXD) WRITE (IPRT,1160)
      IF (.NOT.PRTFXD) WRITE (IPRT,1170)
C
      IF (SCALE(1).LE.0.0D0) GO TO 60
C
      DO 50 I=1,NPAR
         IF (PRTFXD) CALL FIXPRT(IFIXD(I), FIXED)
         K = MSG(I+1) - 2
         IF (K.EQ.-1) K = 5
         IF (K.EQ.-2) WRITE (IPRT,1010) I, (FIXED(J),J=1,3), PAR(I),
     +      SCALE(I)
         IF (K.EQ.0) WRITE (IPRT,1020) I, (FIXED(J),J=1,3), PAR(I),
     +      SCALE(I)
         IF (K.GE.1) WRITE (IPRT,1030) I, (FIXED(J),J=1,3), PAR(I),
     +      SCALE(I), K
   50 CONTINUE
      GO TO 80
C
   60 CONTINUE
C
      DO 70 I=1,NPAR
         IF (PRTFXD) CALL FIXPRT(IFIXD(I), FIXED)
         K = MSG(I+1) - 2
         IF (K.EQ.-1) K = 5
         IF (K.EQ.-2) WRITE (IPRT,1180) I, (FIXED(J),J=1,3), PAR(I)
         IF (K.EQ.0) WRITE (IPRT,1190) I, (FIXED(J),J=1,3), PAR(I)
         IF (K.GE.1) WRITE (IPRT,1200) I, (FIXED(J),J=1,3), PAR(I), K
   70 CONTINUE
C
   80 CONTINUE
C
C     PRINT FOOTNOTES
C
      IF (.NOT.FTNOTE(1)) GO TO 90
C
      WRITE (IPRT,1060)
      IF (FTNOTE(2)) WRITE (IPRT,1070)
      IF (FTNOTE(3)) WRITE (IPRT,1080)
      IF (FTNOTE(4)) WRITE (IPRT,1090)
      IF (FTNOTE(5)) WRITE (IPRT,1100)
      IF (FTNOTE(6)) WRITE (IPRT,1050)
C
   90 CONTINUE
C
      WRITE (IPRT,1110) NETA
      WRITE (IPRT,1120) NTAU
C
C     PRINT OUT ROW OF INDEPENDENT VARIABLE WHICH WAS CHECKED.
C
      WRITE (IPRT,1130) NROW
      NPERL = 7
C
      DO 100 I=1,M,NPERL
         IMIN = I
         IMAX = MIN(I+NPERL-1,M)
         WRITE (IPRT,1140) (INDEX,INDEX=IMIN,IMAX)
         WRITE (IPRT,1150) (XM(NROW,INDEX),INDEX=IMIN,IMAX)
  100 CONTINUE
      WRITE (IPRT,1210) N
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (//)
 1010 FORMAT (1X, I3, 5X, 3A1, 2G17.8, 10X, 2HOK)
 1020 FORMAT (1X, I3, 5X, 3A1, 2G17.8, 7X, 9HINCORRECT)
 1030 FORMAT (1X, I3, 5X, 3A1, 2G17.8, 5X, 14HQUESTIONABLE (, I1, ')')
 1040 FORMAT (62X, 1H*)
 1050 FORMAT (/48H  (5) USER-SUPPLIED AND APPROXIMATED DERIVATIVES,
     +   14H DISAGREE, BUT/5X, 37H APPROXIMATED DERIVATIVE IS QUESTIONA,
     +   11HBLE BECAUSE, 6H RATIO/5X, 30H OF RELATIVE CURVATURE TO RELA,
     +   17HTIVE SLOPE IS TOO, 6H HIGH.)
 1060 FORMAT (/53H * NUMBERS IN PARENTHESES REFER TO THE FOLLOWING NOTE,
     +   2HS.)
 1070 FORMAT (/48H  (1) USER-SUPPLIED AND APPROXIMATED DERIVATIVES,
     +   11H AGREE, BUT/5X, 40H BOTH ARE ZERO.  RECHECK AT ANOTHER ROW.)
 1080 FORMAT (/48H  (2) USER-SUPPLIED AND APPROXIMATED DERIVATIVES,
     +   15H MAY AGREE, BUT/5X, 36H USER-SUPPLIED DERIVATIVE IS IDENTIC,
     +   9HALLY ZERO, 17H AND APPROXIMATED/5X, 21H DERIVATIVE IS ONLY A,
     +   18HPPROXIMATELY ZERO., 25H  RECHECK AT ANOTHER ROW.)
 1090 FORMAT (/48H  (3) USER-SUPPLIED AND APPROXIMATED DERIVATIVES,
     +   14H DISAGREE, BUT/5X, 37H USER-SUPPLIED DERIVATIVE IS IDENTICA,
     +   9HLLY ZERO., 12H  RECHECK AT/5X, 13H ANOTHER ROW.)
 1100 FORMAT (/48H  (4) USER-SUPPLIED AND APPROXIMATED DERIVATIVES,
     +   14H DISAGREE, BUT/5X, 37H APPROXIMATED DERIVATIVE IS QUESTIONA,
     +   11HBLE BECAUSE, 13H EITHER RATIO/5X, 22H OF RELATIVE CURVATURE,
     +   25H TO RELATIVE SLOPE IS TOO, 9H HIGH, OR/5X, 13H SCALE(K) IS ,
     +   6HWRONG.)
 1110 FORMAT (/43H NUMBER OF RELIABLE DIGITS IN MODEL RESULTS, 25X,
     +   6H(NETA), 1X, I5)
 1120 FORMAT (/40H NUMBER OF DIGITS IN DERIVATIVE CHECKING, 9H AGREEMEN,
     +   11HT TOLERANCE, 8X, 6H(NTAU), 1X, I5)
 1130 FORMAT (/45H ROW NUMBER AT WHICH DERIVATIVES WERE CHECKED, 23X,
     +   6H(NROW), 1X, I5/42H   -VALUES OF THE INDEPENDENT VARIABLES AT,
     +   9H THIS ROW)
 1140 FORMAT (10X, 5HINDEX, I5, 6I15)
 1150 FORMAT (10X, 5HVALUE, 7(1X, G14.7)/)
 1160 FORMAT (52X, 10HDERIVATIVE/7X, 24HPARAMETER STARTING VALUE, 6X,
     +   5HSCALE, 10X, 10HASSESSMENT/1X, 5HINDEX, 2X, 5HFIXED, 6X,
     +   5H(PAR), 12X, 7H(SCALE)/)
 1170 FORMAT (17X, 9HPARAMETER, 26X, 10HDERIVATIVE/15X, 12HSTARTING VAL,
     +   2HUE, 8X, 5HSCALE, 10X, 10HASSESSMENT/1X, 5HINDEX, 13X,
     +   5H(PAR), 12X, 7H(SCALE)/)
 1180 FORMAT (1X, I3, 5X, 3A1, G17.8, 7X, 7HDEFAULT, 13X, 2HOK)
 1190 FORMAT (1X, I3, 5X, 3A1, G17.8, 7X, 7HDEFAULT, 10X, 9HINCORRECT)
 1200 FORMAT (1X, I3, 5X, 3A1, G17.8, 7X, 7HDEFAULT, 8X, 11HQUESTIONABL,
     +   3HE (, I1, ')')
 1210 FORMAT (/23H NUMBER OF OBSERVATIONS, 48X, 3H(N), 1X, I5)
      END
*DCKZRO
      SUBROUTINE DCKZRO(J, PAR, NPAR, MDL, XM, N, NROW, M, IXM, PV,
     +   PVTEMP, MSG, LMSG, FD, PARMX, PVPSTP, STP)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE RECHECKS THE DERIVATIES IN THE CASE WHERE THE FINITE
C     DIFFERENCE DERIVATIVE DISAGREES WITH THE ANALYTIC DERIVATIVE AND T
C     ANALYTIC DERIVATIVE IS ZERO.
C
C     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FD,PARMX,PV,PVPSTP,STP
      INTEGER
     +   IXM,J,LMSG,M,N,NPAR,NROW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PVTEMP(N),XM(IXM,M)
      INTEGER
     +   MSG(LMSG)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CD,FPLRS,PVMSTP,TEMP,THIRD
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CD
C        THE CENTRAL DIFFERENCE QUOTIENT DERIVATIVE WITH
C        RESPECT TO THE JTH PARAMETER.
C     DOUBLE PRECISION FD
C        THE FORWARD DIFFERENCE QUOTIENT DERIVATIVE WITH RESPECT TO THE
C        JTH PARAMETER.
C     DOUBLE PRECISION FPLRS
C        THE FLOATING POINT LARGEST RELATIVE SPACING.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER J
C        THE INDEX OF THE PARTIAL DERIVATIVE BEING EXAMINED.
C     INTEGER LMSG
C        THE LENGTH OF THE VECTOR MSG.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER MSG(LMSG)
C        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NROW
C        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
C        WHICH THE DERIVATIVE IS TO BE CHECKED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION PARMX
C        THE MAXIMUM OF THE CURRENT PARAMETER ESTIMATE AND THE TYPICAL
C        VALUE OF THAT PARAMETER.
C     DOUBLE PRECISION PV
C        THE SCALAR IN WHICH THE PREDICTED VALUE FROM THE MODEL FOR
C        ROW   NROW   IS STORED.
C     DOUBLE PRECISION PVMSTP
C        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
C        BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J) - STP.
C     DOUBLE PRECISION PVPSTP
C        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
C        BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J) + STP.
C     DOUBLE PRECISION PVTEMP(N)
C        THE VECTOR OF PREDICTED VALUES FROM THE MODEL.
C     DOUBLE PRECISION STP
C        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FINITE DIFFERENC
C        DERIVATIVE
C     DOUBLE PRECISION TEMP
C        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
C        PARAMETER IS STORED.
C     DOUBLE PRECISION THIRD
C        THE VALUE 1/3.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
      FPLRS = D1MACH(4)
C
C     RECALCULATE NUMERICAL DERIVATIVE USING CENTRAL DIFFERENCE AND STEP
C     SIZE OF 2*STP
C
      TEMP = PAR(J)
      PAR(J) = PAR(J) - STP
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVTEMP)
      PAR(J) = TEMP
C
      PVMSTP = PVTEMP(NROW)
C
      CD = (PVPSTP-PVMSTP)/(2.0D0*STP)
C
C     CHECK FOR DISAGREEMENT
C
      IF (CD.NE.0.0D0) GO TO 10
C
C     NUMERICAL AND ANALYTIC DERIVATIVES NOW AGREE, BUT BOTH EQUAL ZERO,
C     INDICATING THAT DERIVATIVES SHOULD BE RECHECKED AT ANOTHER POINT.
C
      IF (MSG(1).EQ.0) MSG(1) = 1
      MSG(J+1) = 3
      RETURN
C
   10 CONTINUE
C
C     NUMERICAL AND ANALYTIC DERIVATIVE STILL DO NOT AGREE.
C
C     CHECK IF NUMERICAL DERIVATIVE IS CLOSE TO ZERO.
C
      THIRD = 1.0D0/3.0D0
      IF (MIN(ABS(CD), ABS(FD))*PARMX .GT. ABS(PV*FPLRS**THIRD))
     +   GO TO 20
C
C     NUMERICAL DERIVATIVE IS CLOSE TO ZERO
C
      IF (MSG(1).EQ.0) MSG(1) = 1
      MSG(J+1) = 4
      RETURN
C
   20 CONTINUE
C
C     NUMERICAL DERIVATIVE NOT CLOSE TO ZERO
C
      MSG(1) = 2
      MSG(J+1) = 5
      RETURN
C
      END
*DCOEF
      SUBROUTINE DCOEF (NDF, ND, IOD, NPARDF, PARDF, MBO, WORK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE EXPANDS THE DIFFERENCE FILTER SPECIFIED BY NDF,
C     IOD AND ND INTO PARDF.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DEVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   MBO,NDF,NPARDF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PARDF(*),WORK(*)
      INTEGER
     +   IOD(*),ND(*)
C
C  LOCAL SCALARS
      INTEGER
     +   K,KK,L,NTIMES,NWORK1,NWORK2
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   NCHOSE
      EXTERNAL NCHOSE
C
C  EXTERNAL SUBROUTINES
      EXTERNAL MULTBP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IOD(NDF)
C        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
C     INTEGER K
C        AN INDEX VARIABLE.
C     INTEGER KK
C        AN INDEX VARIABLE.
C     INTEGER L
C        AN INDEX VARIABLE.
C     INTEGER MBO
C        THE MAXIMUM BACK ORDER OPERATOR.
C     INTEGER ND(NDF)
C        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED.
C     INTEGER NDF
C        THE NUMBER OF DIFFERENCE FACTORS
C     INTEGER NPARDF
C        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
C     INTEGER NTIMES
C        THE NUMBER OF TIMES A GIVEN DIFFERENCE FACTOR IS TO BE APPLIED.
C     INTEGER NWORK1
C        THE NUMBER OF TERMS IN THE FIRST COLUMN OF WORK.
C     INTEGER NWORK2
C        THE NUMBER OF TERMS IN THE SECOND COLUMN OF WORK
C     DOUBLE PRECISION PARDF(MBO)
C        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS.
C     DOUBLE PRECISION WORK(MBO,2)
C        A WORK ARRAY NECESSARY TO EXPAND THE DIFFERENCE FILTER.
C
      NPARDF = 0
C
      DO 30 L = 1, NDF
         IF (ND(L).EQ.0) GO TO 30
         NTIMES = ND(L)
         NWORK1 = IOD(L) * ND(L)
         DO 10 K = 1, NWORK1
            WORK(K) = 0.0D0
   10    CONTINUE
         DO 20 K = 1, NTIMES
            KK = K * IOD(L)
            WORK(KK) = ((-1)**(K+1)) * NCHOSE(NTIMES, K)
   20    CONTINUE
         NWORK2 = NWORK1 + NPARDF
         CALL MULTBP (WORK(1), NWORK1, PARDF, NPARDF, WORK(MBO+1),
     +      NWORK2, MBO)
   30 CONTINUE
      RETURN
      END
*DEMDRV
      SUBROUTINE DEMDRV (Y, N, FD, FC, K, HLP, AMPL, PHASE, IPHASE,
     +   NDEM, NPRT, NMSUB)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE DRIVER ROUTINE TO DEMODULATE SERIES
C     Y AT FREQUENCY FD, TO APPLY A LOW PASS FILTER WITH CUTOFF
C     FREQUENCY FC, AND TO EXTRACT THE AMPLITUDE AND PHASE COMPONENTS
C     OF THE RESULTING FILTERED SERIES .
C
C     WRITTEN BY  -  PETER BLOOMFIELD
C                    FOURIER ANALYSIS OF TIME SERIES- AN
C                       INTRODUCTION
C                    JOHN WILEY AND SONS, NEW YORK, 1976
C                    PAGE 147
C     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
C                                STATISTICAL ENGINEERING DIVISION
C                                NATIONAL BUREAU OF STANDARDS
C                                BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC,FD
      INTEGER
     +   IPHASE,K,N,NDEM,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AMPL(N),HLP(K),PHASE(IPHASE,2),Y(N)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DEMODU,DEMORD,DEMOUT,FLTSL,LPFLT,POLAR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AMPL(N)
C        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
C     DOUBLE PRECISION FC
C        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
C     DOUBLE PRECISION FD
C        THE DEMODULATION FREQUENCY.
C     DOUBLE PRECISION HLP(K)
C        THE ARRAY IN WHICH THE LOW PASS FILTER COEFFICIENTS ARE
C        STORED.
C     INTEGER K
C        THE USER SUPPLIED NUMBER OF TERMS TO BE USED FOR THE LOW
C        PASS FILTER.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NDEM
C        THE NUMBER OF VALUES IN THE DEMODULATED SERIES, I.E., IN
C        THE AMPLITUDE AND PHASE ARRAYS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE CALLING SUBROUTINE.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF NPRT
C        IS ZERO, NO OUTPUT IS GIVEN, OTHERWISE OUTPUT IS PROVIDED.
C     DOUBLE PRECISION PHASE(IPHASE,2)
C        THE ARRAY CONTIANING THE PRIMARY AND SECONDARY PHASE ESTIMATES.
C     DOUBLE PRECISION Y(N)
C        THE INPUT ARRAY CONTAINING THE OBSERVED SERIES.
C
C
      CALL DEMODU (Y, N, FD, AMPL, PHASE)
      CALL LPFLT (FC, K, HLP)
      CALL FLTSL (AMPL, N, K, HLP, AMPL, NDEM)
      CALL FLTSL (PHASE, N, K, HLP, PHASE, NDEM)
C
      CALL POLAR (AMPL, PHASE, NDEM)
C
      IF (NPRT .EQ. 0) RETURN
C
      CALL DEMORD (PHASE, PHASE(1,2), NDEM, N)
      CALL DEMOUT (FD, FC, K, AMPL, PHASE, IPHASE, NDEM, NMSUB)
C
      RETURN
C
      END
*DEMOD
      SUBROUTINE DEMOD (Y, N, FD, FC, K, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE TO DEMODULATE SERIES
C     Y AT FREQUENCY FD, TO APPLY A LOW PASS FILTER WITH CUTOFF
C     FREQUENCY FC, AND TO EXTRACT THE AMPLITUDE AND PHASE COMPONENTS
C     OF THE RESULTING FILTERED SERIES (SHORT CALL).
C
C     WRITTEN BY  -  PETER BLOOMFIELD
C                    FOURIER ANALYSIS OF TIME SERIES- AN
C                       INTRODUCTION
C                    JOHN WILEY AND SONS, NEW YORK, 1976
C                    PAGE 147
C     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
C                                STATISTICAL ENGINEERING DIVISION
C                                NATIONAL BUREAU OF STANDARDS
C                                BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC,FD
      INTEGER
     +   K,LDSTAK,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   TEMP
      INTEGER
     +   AMPL,HLP,IFP,IPRT,LDSMIN,NALL0,NDEM,PHASE
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,ERR06,ERR07,HEAD
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      CHARACTER
     +   LFC(8)*1,LFD(8)*1,LK(8)*1,LKIN(8)*1,LLDS(8)*1,LN(8)*1,
     +   LNM1(8)*1,LONE(8)*1,NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DEMDRV,EISGE,EISII,ERIODD,ERSII,ERSLFS,IPRINT,LDSCMP,
     +   STKCLR,STKSET
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER AMPL
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05, ERR06, ERR07
C        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION FC
C        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
C     DOUBLE PRECISION FD
C        THE DEMODULATION FREQUENCY.
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER HLP
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE ARRAY IN WHICH THE LOW PASS FILTER COEFFICIENTS ARE
C        STORED.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     INTEGER K
C        THE USER SUPPLIED NUMBER OF TERMS TO BE USED FOR THE LOW
C        PASS FILTER.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     CHARACTER*1 LFC(8), LFD(8), LK(8), LKIN(8), LLDS(8), LN(8),
C    *  LNM1(8), LONE(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
C        CHECKED FOR ERRORS.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
C        WAS CALLED.
C     INTEGER NDEM
C        THE NUMBER OF VALUES IN THE DEMODULATED SERIES, I.E., IN
C        THE AMPLITUDE AND PHASE ARRAYS.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER PHASE
C        THE STARTING LOCATIONS IN RSTAK/DSTAK OF
C        THE ARRAY CONTAINING THE PRIMARY AND SECONDARY PHASE ESTIMATES.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION TEMP
C        A TEMPORARY VARIABLE USED FOR TYPE CONVERSION.
C     DOUBLE PRECISION Y(N)
C        THE INPUT ARRAY CONTAINING THE OBSERVED SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'D',       'E',       'M',       'O',       'D',       ' '/
      DATA
     +  LFC(1), LFC(2), LFC(3), LFC(4), LFC(5), LFC(6), LFC(7), LFC(8)
     + /  'F',   'C',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LFD(1), LFD(2), LFD(3), LFD(4), LFD(5), LFD(6), LFD(7), LFD(8)
     + /  'F',   'D',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LKIN(1), LKIN(2), LKIN(3), LKIN(4), LKIN(5), LKIN(6), LKIN(7),
     +  LKIN(8) /  '(',   '1',   '/',   'K',   ')',   ' ',   ' ',   ' '/
      DATA
     +  LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6), LLDS(7),
     +  LLDS(8) /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LNM1(1), LNM1(2), LNM1(3), LNM1(4), LNM1(5), LNM1(6), LNM1(7),
     +  LNM1(8) /  '(',   'N',   '-',   '1',   ')',   ' ',   ' ',   ' '/
      DATA
     +  LONE(1), LONE(2), LONE(3), LONE(4), LONE(5), LONE(6), LONE(7),
     +  LONE(8) /  'O',   'N',   'E',   ' ',   ' ',   ' ',   ' ',   ' '/
C
C     PERFORM ERROR CHECKING ON INPUT DATA.
C
      IERR = 0
      HEAD = .TRUE.
C
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
C
      CALL ERSII(NMSUB, LFD, FD,
     +           0.0D0, 0.5D0, 2, HEAD, ERR02, LFD, LFD)
C
      ERR03 = .TRUE.
      IF (.NOT. ERR01)
     +  CALL EISII(NMSUB, LK, K, 1, N-1, 1, HEAD, ERR03, LONE, LNM1)
C
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR04)
C
      ERR05 = .TRUE.
      IF ((.NOT. ERR02) .AND. (.NOT. ERR03) .AND. (.NOT. ERR04)) THEN
         TEMP = K
         CALL ERSII(NMSUB, LFC, FC, 1.0D0/TEMP, FD, 1, HEAD, ERR05,
     +              LKIN, LFD)
      END IF
C
      ERR06 = .TRUE.
      IF ((.NOT. ERR03) .AND. (.NOT. ERR04) .AND. (.NOT. ERR05))
     +   CALL ERSLFS(NMSUB, FC, K, HEAD, ERR06)
C
      IF (ERR01 .OR. ERR06) GO TO 10
C
      CALL LDSCMP(3, 0, 0, 0, 0, 0, 'D', K + 3*N, LDSMIN)
C
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR07, LLDS)
C
C
      IF (ERR02 .OR. ERR03 .OR. ERR04 .OR. ERR05 .OR. ERR07) GO TO 10
      GO TO 20
C
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   20 CONTINUE
      CALL STKSET (LDSTAK, 4)
      NALL0 = STKST(1)
C
      IFP = 4
C
      AMPL = STKGET(N, IFP)
      PHASE = STKGET(2*N, IFP)
      HLP = STKGET(K, IFP)
C
      IF (IERR .EQ. 1) GO TO 10
C
      CALL DEMDRV(Y, N, FD, FC, K, RSTAK(HLP), RSTAK(AMPL),
     +   RSTAK(PHASE), N, NDEM, 1, NMSUB)
C
      CALL STKCLR(NALL0)
C
      IF (IERR .EQ. 1) GO TO 10
C
      RETURN
C
C     FORMAT STATEMENT
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL DEMOD (Y, N, FD, FC, K, LDSTAK)')
C
      END
*DEMODS
      SUBROUTINE DEMODS (Y, N, FD, FC, K, AMPL, PHAS, NDEM, NPRT,
     +  LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE TO DEMODULATE SERIES
C     Y AT FREQUENCY FD, TO APPLY A LOW PASS FILTER WITH CUTOFF
C     FREQUENCY FC, AND TO EXTRACT THE AMPLITUDE AND PHASE COMPONENTS
C     OF THE RESULTING FILTERED SERIES (LONG CALL).
C
C     WRITTEN BY  -  PETER BLOOMFIELD
C                    FOURIER ANALYSIS OF TIME SERIES- AN
C                       INTRODUCTION
C                    JOHN WILEY AND SONS, NEW YORK, 1976
C                    PAGE 147
C     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
C                                STATISTICAL ENGINEERING DIVISION
C                                NATIONAL BUREAU OF STANDARDS
C                                BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC,FD
      INTEGER
     +   K,LDSTAK,N,NDEM,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AMPL(*),PHAS(*),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   TEMP
      INTEGER
     +   HLP,IO,IPRT,LDSMIN,NALL0,PHASE
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,ERR06,ERR07,HEAD
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      CHARACTER
     +   LFC(8)*1,LFD(8)*1,LK(8)*1,LKIN(8)*1,LLDS(8)*1,LN(8)*1,
     +   LNM1(8)*1,LONE(8)*1,NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DEMDRV,EISGE,EISII,ERIODD,ERSII,ERSLFS,IPRINT,LDSCMP,
     +   DCOPY,STKCLR,STKSET
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AMPL(N)
C        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05, ERR06, ERR07
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION FC
C        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
C     DOUBLE PRECISION FD
C        THE DEMODULATION FREQUENCY.
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER HLP
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE ARRAY IN WHICH THE LOW PASS FILTER COEFFICIENTS ARE
C        STORED.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
C        BASED ON PRINTED OUTPUT REQUESTED.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     INTEGER K
C        THE USER SUPPLIED NUMBER OF TERMS TO BE USED FOR THE LOW
C        PASS FILTER.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     CHARACTER*1 LFC(8), LFD(8), LK(8), LKIN(8), LLDS(8), LN(8),
C    *  LNM1(8), LONE(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
C        CHECKED FOR ERRORS.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
C        WAS CALLED.
C     INTEGER NDEM
C        THE NUMBER OF VALUES IN THE DEMODULATED SERIES, I.E., IN
C        THE AMPLITUDE AND PHASE ARRAYS.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF NPRT
C        IS ZERO, NO OUTPUT IS GIVEN, OTHERWISE OUTPUT IS PROVIDED.
C     DOUBLE PRECISION PHAS(N)
C        THE ARRAY IN WHICH THE PRIMARY PHASE ESTIMATES ARE RETURNED.
C     INTEGER PHASE
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE ARRAY CONTAINING THE PRIMARY AND SECONDARY PHASE ESTIMATES.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION TEMP
C        A TEMPORARY VARIABLE USED FOR TYPE CONVERSION.
C     DOUBLE PRECISION Y(N)
C        THE INPUT ARRAY CONTAINING THE OBSERVED SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'D',       'E',       'M',       'O',       'D',       'S'/
      DATA
     +  LFC(1), LFC(2), LFC(3), LFC(4), LFC(5), LFC(6), LFC(7), LFC(8)
     + /  'F',   'C',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LFD(1), LFD(2), LFD(3), LFD(4), LFD(5), LFD(6), LFD(7), LFD(8)
     + /  'F',   'D',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LKIN(1), LKIN(2), LKIN(3), LKIN(4), LKIN(5), LKIN(6), LKIN(7),
     +  LKIN(8) /  '(',   '1',   '/',   'K',   ')',   ' ',   ' ',   ' '/
      DATA
     +  LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6), LLDS(7),
     +  LLDS(8) /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LNM1(1), LNM1(2), LNM1(3), LNM1(4), LNM1(5), LNM1(6), LNM1(7),
     +  LNM1(8) /  '(',   'N',   '-',   '1',   ')',   ' ',   ' ',   ' '/
      DATA
     +  LONE(1), LONE(2), LONE(3), LONE(4), LONE(5), LONE(6), LONE(7),
     +  LONE(8) /  'O',   'N',   'E',   ' ',   ' ',   ' ',   ' ',   ' '/
C
C     PERFORM ERROR CHECKING ON INPUT DATA.
C
      IERR = 0
      HEAD = .TRUE.
C
      IF (NPRT.EQ.0) THEN
        IO = 0
      ELSE
        IO = 1
      END IF
C
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
C
      CALL ERSII(NMSUB, LFD, FD,
     +           0.0D0, 0.5D0, 2, HEAD, ERR02, LFD, LFD)
C
      ERR03 = .TRUE.
      IF (.NOT. ERR01)
     +  CALL EISII(NMSUB, LK, K, 1, N-1, 1, HEAD, ERR03, LONE, LNM1)
C
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR04)
C
      ERR05 = .TRUE.
      IF ((.NOT. ERR02) .AND. (.NOT. ERR03) .AND. (.NOT. ERR04)) THEN
         TEMP = K
         CALL ERSII(NMSUB, LFC, FC, 1.0D0/TEMP, FD, 1, HEAD, ERR05,
     +              LKIN, LFD)
      END IF
C
      ERR06 = .TRUE.
      IF ((.NOT. ERR03) .AND. (.NOT. ERR04) .AND. (.NOT. ERR05))
     +   CALL ERSLFS(NMSUB, FC, K, HEAD, ERR06)
C
      IF (ERR01 .OR. ERR06) GO TO 10
C
      CALL LDSCMP(2, 0, 0, 0, 0, 0, 'D', K + IO*2*N, LDSMIN)
C
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR07, LLDS)
C
C
      IF (ERR02 .OR. ERR03 .OR. ERR04 .OR. ERR05 .OR. ERR07) GO TO 10
      GO TO 20
C
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   20 CONTINUE
      CALL STKSET (LDSTAK, 4)
      NALL0 = STKST(1)
C
      HLP = STKGET(K, 4)
      IF (NPRT.EQ.0) THEN
         PHASE = 1
      ELSE
         PHASE = STKGET(2*N, 4)
      END IF
C
      IF (IERR .EQ. 1) GO TO 10
C
      IF (NPRT .NE. 0) THEN
C
         CALL DEMDRV(Y, N, FD, FC, K, RSTAK(HLP), AMPL,
     +      RSTAK(PHASE), N, NDEM, NPRT, NMSUB)
         CALL DCOPY(NDEM, RSTAK(PHASE), 1, PHAS, 1)
      ELSE
         CALL DEMDRV(Y, N, FD, FC, K, RSTAK(HLP), AMPL,
     +      PHAS, N, NDEM, NPRT, NMSUB)
      END IF
C
      CALL STKCLR(NALL0)
C
      IF (IERR .EQ. 1) GO TO 10
C
      RETURN
C
C     FORMAT STATEMENT
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL DEMODS (Y, N, FD, FC, K,'/
     +   '      +             AMPL, PHAS, NDEM, NPRT, LDSTAK)')
C
      END
*DEMODU
      SUBROUTINE DEMODU (Y, N, FD, AMPL, PHAS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE DEMODULATES THE SERIES Y AT FREQUENCY
C     FD.  THE REAL AND IMAGINARY PARTS OF THE DEMODULATED
C     SERIES ARE RETURNED IN AMPL AND PHAS, RESPECTIVELY.
C
C     WRITTEN BY  -  PETER BLOOMFIELD
C                    FOURIER ANALYSIS OF TIME SERIES- AN
C                       INTRODUCTION
C                    JOHN WILEY AND SONS, NEW YORK, 1976
C                    PAGE 148
C     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
C                                STATISTICAL ENGINEERING DEVISION
C                                NATIONAL BUREAU OF STANDARDS
C                                BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FD
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AMPL(N),PHAS(N),Y(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ARG,PI
      INTEGER
     +   I
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
C
C  INTRINSIC FUNCTIONS
      INTRINSIC COS,SIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AMPL(N)
C        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
C     DOUBLE PRECISION ARG
C        A VALUE USED IN COMPUTING THE DEMODULATED SERIES.
C     DOUBLE PRECISION FD
C        THE DEMODULATION FREQUENCY.
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES BEING DEMODULATED.
C     DOUBLE PRECISION PHAS(N)
C        THE ARRAYS CONTAINING THE PRIMARY PHASE ESTIMATES.
C     DOUBLE PRECISION PI
C        THE VALUE OF PI.
C     DOUBLE PRECISION Y(N)
C        THE INPUT ARRAY ARRAY CONTAINING THE OBSERVED SERIES.
C
      CALL GETPI(PI)
C
      DO 10 I = 1, N
         IF (FD.EQ.0.25D0) THEN
            AMPL(I) = 0.0D0
            PHAS(I) = -2.0D0*Y(I)
         ELSE IF (FD.EQ.0.5D0) THEN
            AMPL(I) = -2.0D0*Y(I)
            PHAS(I) = 0.0D0
         ELSE
            ARG = (I-1) * FD * 2.0D0 * PI
            AMPL(I) = Y(I)*COS(ARG)*2.0D0
            PHAS(I) = -Y(I)*SIN(ARG)*2.0D0
         END IF
   10 CONTINUE
      RETURN
      END
*DEMORD
      SUBROUTINE DEMORD (PHAS1, PHAS2, NDEM, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE SETS UP THE DATA FOR THE PHASE PLOTS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NDEM
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PHAS1(N),PHAS2(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   PI
      INTEGER
     +   I
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES BEING DEMODULATED.
C     INTEGER NDEM
C        THE NUMBER OF VALUES IN THE DEMODULATED SERIES, I.E., IN
C        THE AMPLITUDE AND PHASE ARRAYS.
C     DOUBLE PRECISION PHAS1(N), PHAS2(N)
C        THE ARRAYS CONTAINING THE PRIMARY AND SECONDARY PHASE
C        ESTIMATES, RESPECTIVELY.
C     DOUBLE PRECISION PI
C        THE VALUE OF PI.
C
      CALL GETPI(PI)
C
      DO 10 I = 1, NDEM
         PHAS2(I) = 0.0D0
         IF (PHAS1(I) .GT. 0.0D0) PHAS2(I) = PHAS1(I) - 2.0D0*PI
         IF (PHAS1(I) .LT. 0.0D0) PHAS2(I) = PHAS1(I) + 2.0D0*PI
   10 CONTINUE
C
      RETURN
      END
*DEMOUT
      SUBROUTINE DEMOUT(FD, FC, K, AMPL, PHASE, IPHASE, NDEM, NMSUB)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRODUCES THE OUTPUT FOR THE TIME SERIES
C     DEMODULATION ROUTINE.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DEVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC,FD
      INTEGER
     +   IPHASE,K,NDEM
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AMPL(NDEM),PHASE(IPHASE,2)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   PI,YMN,YMX
      INTEGER
     +   IPRT
      LOGICAL
     +   ERROR
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GETPI,IPRINT,VERSP,VPLMT,VPMN
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AMPL(NDEM)
C        THE ARRAY IN WHICH THE AMPLITUDES OF THE DEMODULATED SERIES
C        ARE STORED.
C     LOGICAL ERROR
C        AN ERROR FLAG
C     DOUBLE PRECISION FC, FD
C        THE CUTOFF FREQUENCY AND THE DEMODULATION FREQUENCY.
C     INTEGER IERR
C        THE ERROR FLAG
C     INTEGER IPHASE
C
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ISYM(1)
C        A DUMMY ARRAY.
C     INTEGER K
C        THE NUMBER OF TERMS IN THE LOW PASS FILTER USED TO SMOOTH
C        THE DEMODULATED SERIES.
C     INTEGER NDEM
C        THE NUMBER OF VALUES IN THE DEMODULATED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE CALLING SUBROUTINE
C     DOUBLE PRECISION PHASE(IPHASE,2)
C        THE ARRAY CONTAINING THE PRIMARY AND SECONDARY PHASE VALUES.
C     DOUBLE PRECISION PI
C        THE VALUE OF PI.
C     DOUBLE PRECISION YMN, YMX
C
C
      CALL IPRINT(IPRT)
C
      CALL VERSP(.TRUE.)
C
      CALL GETPI(PI)
C
      WRITE (IPRT, 1000) FD, FC, K
C
      WRITE (IPRT, 1001)
      CALL VPLMT(AMPL, AMPL, NDEM, 1, NDEM, 0.0D0, 0.0D0,
     +  YMN, YMX, ERROR, NMSUB, .FALSE., 1)
C
      IF (ERROR) THEN
        IERR = 1
        RETURN
      ELSE
        CALL VPMN(AMPL, AMPL, NDEM, 1, NDEM, 1, 0, ISYM, 1, 0,
     +   YMN, YMX, 1.0D0, 1.0D0, .FALSE., 0, 1, 0)
      END IF
C
      WRITE (IPRT, 1002)
      CALL VERSP(.TRUE.)
      WRITE (IPRT, 1003)
      CALL VPMN(PHASE, PHASE, NDEM, 2, IPHASE, 1, 2, ISYM, 1, 0,
     +   -2.0D0*PI, 2.0D0*PI, 1.0D0, 1.0D0, .FALSE., 0, 0, 0)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/25H TIME SERIES DEMODULATION//
     +   26H DEMODULATION FREQUENCY IS, F10.8/
     +   26H CUTOFF FREQUENCY IS      , F10.8/
     +   38H THE NUMBER OF TERMS IN THE FILTER IS , I5///)
 1001 FORMAT (49H PLOT OF AMPLITUDE OF SMOOTHED DEMODULATED SERIES)
 1002 FORMAT ('1')
 1003 FORMAT (45H PLOT OF PHASE OF SMOOTHED DEMODULATED SERIES)
      END
*DFBW
      SUBROUTINE DFBW (N, LAG, W, LW, DF, BW)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE COMPUTES AND STORES THE ASSOCIATED DEGREES OF
C     FREEDOM AND BANDWIDTH FOR A GIVEN LAG WINDOW.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   BW,DF
      INTEGER
     +   LAG,LW,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   W(LW)
C
C  LOCAL SCALARS
      INTEGER
     +   K
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION BW
C        THE BANDWIDTH.
C     DOUBLE PRECISION DF
C        THE EFFECTIVE DEGREES OF FREEDOM.
C     INTEGER K
C        AN INDEX VARIABLE
C     INTEGER LAG
C        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
C     INTEGER LW
C        THE LENGTH OF THE VECTOR W.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES.
C     DOUBLE PRECISION W(LW)
C        THE VECTOR OF LAG WINDOWS.
C
      BW = 0.0D0
      DO 10 K = 1, LAG
         BW = BW + W(K+1) * W(K+1) * (N-K)
   10 CONTINUE
C
      BW = 1.0D0 / (W(1)*W(1) + 2.0D0*BW/N)
      DF = 2.0D0 * BW * N
      RETURN
      END
*DFBWM
      SUBROUTINE DFBWM (N, LAG, W, LW, NLPPA1, NLPPA2, LNLPPA, DF, BW)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE COMPUTES AND STORES THE ASSOCIATED DEGREES OF
C     FREEDOM AND BANDWIDTH FOR A GIVEN LAG WINDOW WHEN MISSING DATA ARE
C     INVOLVED.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   BW,DF
      INTEGER
     +   LAG,LNLPPA,LW,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   W(LW)
      INTEGER
     +   NLPPA1(LNLPPA),NLPPA2(LNLPPA)
C
C  LOCAL SCALARS
      INTEGER
     +   K
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION BW
C        THE BANDWIDTH.
C     DOUBLE PRECISION DF
C        THE EFFECTIVE DEGREES OF FREEDOM.
C     INTEGER K
C        AN INDEX VARIABLE
C     INTEGER LNLPPA
C        THE LENGTH OF THE VECTOR NLPPA.
C     INTEGER LW
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LAG
C        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES.
C     INTEGER NLPPA1(LNLPPA), NLPPA2(LNLPPA)
C        THE NUMBER OF LAGGED PRODUCT PAIRS USED FOR EACH ACVF
C        ESTIMATE.
C     DOUBLE PRECISION W(LW)
C        THE VECTOR OF LAG WINDOWS.
C
      BW = (W(1)*N)**2/NLPPA1(1)
      DO 10 K = 1, LAG
         BW = BW + (W(K+1)*(N-K))**2 *
     +      (1.0D0/NLPPA1(K+1) + 1.0D0/NLPPA2(K+1))
   10 CONTINUE
C
C
      BW = N / BW
      DF = 2.0D0 * BW * N
      RETURN
      END
*DIF
      SUBROUTINE DIF (Y, N, YF, NYF)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PERFORMS A FIRST DIFFERENCE FILTERING OPERATION,
C     RETURNING THE FILTERED SERIES IN YF.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NYF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*),YF(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IAR,IPRT
      LOGICAL
     +   ERR01,HEAD
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PHI(1)
      CHARACTER
     +   LN(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,FLTAR,IPRINT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IAR
C        THE NUMBER OF FILTER COEFFICIENTS.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     CHARACTER*1 LN(8)
C        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES N.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NYF
C        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
C     DOUBLE PRECISION PHI(1)
C        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YF(N)
C        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'D',       'I',       'F',       ' ',       ' ',       ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 3, 1, HEAD, ERR01, LN)
C
C
      IF (.NOT. ERR01) GO TO 10
C
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   10 CONTINUE
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      IAR = 1
      PHI(1) = 1.0D0
C
      CALL FLTAR (Y, N, IAR, PHI, YF, NYF)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   31H       CALL DIF (Y, N, YF, NYF))
      END
*DIFC
      SUBROUTINE DIFC (Y, N, NFAC, ND, IOD, IAR, PHI, LPHI, YF, NYF,
     +   LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE EXPANDS THE DIFFERENCE FILTER SPECIFIED BY NFAC,
C     IOD AND ND INTO PHI AND PERFORMS THE DIFFERENCE FILTERING
C     OPERATION DEFINED BY PHI, RETURNING THE FILTERED SERIES
C     IN YF.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IAR,LDSTAK,LPHI,N,NFAC,NYF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PHI(*),Y(*),YF(*)
      INTEGER
     +   IOD(*),ND(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT,LDSMIN,NALL0,WORK
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,HEAD
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      CHARACTER
     +   LLDS(8)*1,LLPHI(8)*1,LN(8)*1,NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DCOEF,EISGE,ERDF,FLTAR,IPRINT,LDSCMP,STKCLR,STKSET
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL ERR01, ERR02, ERR03, ERR04
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IAR
C        THE NUMBER OF FILTER COEFFICIENTS.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IOD(NFAC)
C        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     CHARACTER*1 LLDS(8), LLPHI(8), LN(8)
C        THE ARRAYS CONTAINING THE NAMES OF VARIOUS VARIABLES
C     INTEGER LPHI
C        THE LENGTH OF THE ARRAY PHI.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING WORK AREA ALLOCATIONS.
C     INTEGER ND(NFAC)
C        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE
C        FACTORS ARE TO BE APPLIED.
C     INTEGER NFAC
C        THE NUMBER OF DIFFERENCE FACTORS.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NYF
C        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
C     DOUBLE PRECISION PHI(LPHI)
C        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER WORK
C        THE STARTING LOCATION FOR THE WORK VECTOR NECESSARY TO
C        EXPAND THE DIFFERENCE FILTER.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YF(N)
C        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'D',       'I',       'F',       'C',       ' ',       ' '/
      DATA
     +  LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +  LLDS(7), LLDS(8)
     + /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
      DATA
     +  LLPHI(1), LLPHI(2), LLPHI(3), LLPHI(4), LLPHI(5), LLPHI(6),
     +  LLPHI(7), LLPHI(8)
     + /  'L',   'P',   'H',   'I',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
      ERR01 = .FALSE.
      ERR02 = .FALSE.
      ERR03 = .FALSE.
      ERR04 = .FALSE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB,LN,N,3,1,HEAD,ERR01,LN)
C
      IAR = 0
C
      IF (NFAC.GE.1) THEN
C
         DO 10 I = 1, NFAC
            IAR = IAR + ND(I)*IOD(I)
   10    CONTINUE
C
         CALL ERDF(NMSUB,NFAC,ND,IOD,N,HEAD,ERR02)
C
         IF (.NOT.ERR02) THEN
            CALL EISGE(NMSUB,LLPHI,LPHI,IAR,9,HEAD,ERR03,LLPHI)
            CALL LDSCMP(1,0,0,0,0,0,'D',2*IAR,LDSMIN)
            CALL EISGE(NMSUB,LLDS,LDSTAK,LDSMIN,9,HEAD,ERR04,LLDS)
         END IF
      END IF
C
C
      IF (ERR01 .OR. ERR02 .OR. ERR03 .OR. ERR04) GO TO 20
      GO TO 30
C
   20 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   30 CONTINUE
C
      NYF = N
      DO 50 I = 1, NYF
         YF(I) = Y(I)
   50 CONTINUE
C
      IF (NFAC .LE. 0) RETURN
C
      CALL STKSET (LDSTAK, 4)
      NALL0 = STKST(1)
C
      DO 60 I = 1, LPHI
         PHI(I) = 0.0D0
   60 CONTINUE
C
      WORK = STKGET(2*IAR, 4)
C
      IF (IERR .EQ. 1) GO TO 20
C
      CALL DCOEF (NFAC,ND,IOD,IAR,PHI,LPHI,RSTAK(WORK))
C
      CALL STKCLR(NALL0)
C
      IF (IERR .EQ. 1) GO TO 20
C
      CALL FLTAR (YF,NYF,IAR,PHI,YF,NYF)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL DIFC (Y, N,'/
     +   '      +           NFAC, ND, IOD, IAR, PHI, LPHI,'/
     +   '      +           YF, NYF, LDSTAK)')
      END
*DIFM
      SUBROUTINE DIFM (Y, YMISS, N, YF, YFMISS, NYF)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PERFORMS A FIRST DIFFERENCE FILTERING OPERATION,
C     RETURNING THE FILTERED SERIES IN YF, FOR AN INPUT SERIES
C     CONTAINING MISSING VALUES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YFMISS,YMISS
      INTEGER
     +   N,NYF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*),YF(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IAR,IPRT
      LOGICAL
     +   ERR01,HEAD
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PHI(1)
      CHARACTER
     +   LN(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,FLTARM,IPRINT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IAR
C        THE NUMBER OF FILTER COEFFICIENTS.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     CHARACTER*1 LN(8)
C        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES N.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NYF
C        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
C     DOUBLE PRECISION PHI(1)
C        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YF(N)
C        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
C     DOUBLE PRECISION YFMISS
C        THE MISSING VALUE CODE USED IN THE FILTERED SERIES TO
C        INDICATE THE VALUE COULD NOT BE COMPUTED DUE TO MISSING DATA.
C     DOUBLE PRECISION YMISS
C        THE MISSING VALUE CODE USED IN THE INPUT SERIES TO INDICATE
C        AN OBSERVATION IS MISSING.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'D',       'I',       'F',       'M',       ' ',       ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 3, 1, HEAD, ERR01, LN)
C
      IF (.NOT. ERR01) GO TO 10
C
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   10 CONTINUE
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      IAR = 1
      PHI(1) = 1.0D0
C
      CALL FLTARM (Y, YMISS, N, IAR, PHI, YF, YFMISS, NYF)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   47H       CALL DIFM (Y, YMISS, N, YF, YFMISS, NYF))
      END
*DIFMC
      SUBROUTINE DIFMC (Y, YMISS, N, NFAC, ND, IOD, IAR, PHI, LPHI, YF,
     +   YFMISS, NYF, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE EXPANDS THE DIFFERENCE FILTER SPECIFIED BY NFAC,
C     IOD AND ND INTO PHI AND PERFORMS THE DIFFERENCE FILTERING
C     OPERATION DEFINED BY PHI ON A SERIES CONTAINING MISSING DATA,
C     RETURNING THE FILTERED SERIES IN YF.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YFMISS,YMISS
      INTEGER
     +   IAR,LDSTAK,LPHI,N,NFAC,NYF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PHI(*),Y(*),YF(*)
      INTEGER
     +   IOD(*),ND(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT,LDSMIN,NALL0,WORK
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,HEAD
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      CHARACTER
     +   LLDS(8)*1,LLPHI(8)*1,LN(8)*1,NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DCOEF,EISGE,ERDF,FLTARM,IPRINT,LDSCMP,STKCLR,STKSET
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL ERR01, ERR02, ERR03, ERR04
C        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IAR
C        THE NUMBER OF FILTER COEFFICIENTS.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IOD(NFAC)
C        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     CHARACTER*1 LLDS(8), LLPHI(8), LN(8)
C        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES LDSTAK, N
C        AND LPHI, RESPECTIVELY.
C     INTEGER LPHI
C        THE LENGTH OF THE VECTOR PHI.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
C     INTEGER ND(NFAC)
C        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE
C        FACTORS ARE TO BE APPLIED.
C     INTEGER NFAC
C        THE NUMBER OF DIFFERENCE FACTORS.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NYF
C        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
C     DOUBLE PRECISION PHI(LPHI)
C        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER WORK
C        THE STARTING LOCATION FOR THE WORK VECTOR NECESSARY TO
C        EXPAND THE DIFFERENCE FILTER.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YF(N)
C        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
C     DOUBLE PRECISION YFMISS
C        THE MISSING VALUE CODE USED IN THE FILTERED SERIES TO
C        INDICATE THE VALUE COULD NOT BE COMPUTED DUE TO MISSING DATA.
C     DOUBLE PRECISION YMISS
C        THE MISSING VALUE CODE USED IN THE INPUT SERIES TO INDICATE
C        AN OBSERVATION IS MISSING.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'D',       'I',       'F',       'M',       'C',       ' '/
      DATA
     +  LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +  LLDS(7), LLDS(8)
     + /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
      DATA
     +  LLPHI(1), LLPHI(2), LLPHI(3), LLPHI(4), LLPHI(5), LLPHI(6),
     +  LLPHI(7), LLPHI(8)
     + /  'L',   'P',   'H',   'I',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
      ERR01 = .FALSE.
      ERR02 = .FALSE.
      ERR03 = .FALSE.
      ERR04 = .FALSE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB,LN,N,3,1,HEAD,ERR01,LN)
C
      IAR = 0
C
      IF (NFAC.GE.1) THEN
C
         DO 10 I = 1, NFAC
            IAR = IAR + ND(I)*IOD(I)
   10    CONTINUE
C
         CALL ERDF(NMSUB,NFAC,ND,IOD,N,HEAD,ERR02)
C
         IF (.NOT.ERR02) THEN
            CALL EISGE(NMSUB,LLPHI,LPHI,IAR,9,HEAD,ERR03,LLPHI)
            CALL LDSCMP(1,0,0,0,0,0,'D',2*IAR,LDSMIN)
            CALL EISGE(NMSUB,LLDS,LDSTAK,LDSMIN,9,HEAD,ERR04,LLDS)
         END IF
      END IF
C
      IF (ERR01 .OR. ERR02 .OR. ERR03 .OR. ERR04) GO TO 20
      GO TO 30
C
   20 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   30 CONTINUE
C
      NYF = N
      DO 50 I = 1, NYF
         YF(I) = Y(I)
   50 CONTINUE
C
      YFMISS = YMISS
C
      IF (NFAC .LE. 0) RETURN
C
      CALL STKSET (LDSTAK, 4)
      NALL0 = STKST(1)
C
      DO 60 I = 1, LPHI
         PHI(I) = 0.0D0
   60 CONTINUE
C
      WORK = STKGET(2*IAR,4)
C
      IF (IERR .EQ. 1) GO TO 20
C
      CALL DCOEF (NFAC,ND,IOD,IAR,PHI,LPHI,RSTAK(WORK))
C
      CALL STKCLR(NALL0)
C
      IF (IERR .EQ. 1) GO TO 20
C
      CALL FLTARM (YF,YMISS,NYF,IAR,PHI,YF,YFMISS,NYF)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL DIFMC (Y, YMISS, N,'/
     +   '      +            NFAC, ND, IOD, IAR, PHI, LPHI,'/
     +   '      +            YF, YFMISS, NYF, LDSTAK)')
      END
*DIFSER
      SUBROUTINE DIFSER (Y, N, NDF, ND, IOD, YDIFF, NDIFF)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PERFORMS THE DIFFERENCING OPPERATION
C     DEFINED BY ND, IOD AND NDF ON THE SERIES Y, RESULTING IN
C     THE SERIES YDIFF.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVIAION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NDF,NDIFF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*),YDIFF(*)
      INTEGER
     +   IOD(*),ND(*)
C
C  LOCAL SCALARS
      INTEGER
     +   I,J,K,L,NTIMES
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IOD(NDF)
C        THE VECTOR CONTAINING THE ORDERS OF EACH DIFFERENCE FACTOR.
C     INTEGER J, K, L
C        INDEX VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER ND(NDF)
C        THE VECTOR CONTAINING THE NUMBER OF TIMES EACH DIFFERENCING
C        FACTOR IS APPLIED.
C     INTEGER NDF
C        THE NUMBER OF DIFFERENCE FACTORS.
C     INTEGER NDIFF
C        THE NUMBER OF OBSERVATIONS REMAINING IN THE DIFFERENCED SERIES.
C     INTEGER NTIMES
C        THE NUMBER OF TIMES A GIVEN DIFFERENCE FACTOR IS TO BE APPLIED.
C     DOUBLE PRECISION Y(N), YDIFF(N)
C        THE VECTOR CONTAINING THE SERIES OBSERVATIONS AND THE VECTOR
C        IN WHICH THE DIFFERENCED SERIES IS RETURNED.
C
      DO 10 I = 1, N
         YDIFF(I) = Y(I)
   10 CONTINUE
C
      NDIFF = N
C
      IF (NDF .EQ. 0) RETURN
C
      DO 40 I = 1, NDF
         NTIMES = ND(I)
         DO 30 L = 1, NTIMES
            NDIFF = NDIFF - IOD(I)
            DO 20 J = 1, NDIFF
               K = J + IOD(I)
               YDIFF(J) = YDIFF(K) - YDIFF(J)
   20       CONTINUE
   30    CONTINUE
   40 CONTINUE
      RETURN
      END
*DOTC
      SUBROUTINE DOTC (Y, YMEAN, NY, X, XMEAN, NX, DOTXY, NDOTXY)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE DOT PRODUCT OF TWO
C     SERIES, CENTERED ABOUT THEIR RESPECTIVE MEANS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DOTXY,XMEAN,YMEAN
      INTEGER
     +   NDOTXY,NX,NY
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(NX),Y(NY)
C
C  LOCAL SCALARS
      INTEGER
     +   I,M
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DOTXY
C        THE DOT PRODUCT OF THE SERIES (Y(I) - YMEAN) AND
C        (X(I) - XMEAN).
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER M
C        THE SMALLER OF THE NUMBER OF OBSERVATIONS IN X AND Y
C     INTEGER NDOTXY
C        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY
C     INTEGER NX, NY
C        THE NUMBER OF OBSERVATIONS IN SERIES X AND Y, RESPECTIVELY.
C     DOUBLE PRECISION X(NX)
C        THE VECTOR CONTAINING THE SECOND SERIES
C     DOUBLE PRECISION XMEAN
C        THE MEAN OF THE SECOND SERIES.
C     DOUBLE PRECISION Y(NY)
C        THE VECTOR CONTAINING THE FIRST SERIES
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE FIRST SERIES.
C
      NDOTXY = 0
      DOTXY = 0.0D0
      M = MIN(NY, NX)
      DO 10 I = 1, M
         DOTXY = DOTXY + (Y(I) - YMEAN) * (X(I) - XMEAN)
         NDOTXY = NDOTXY + 1
   10 CONTINUE
      RETURN
      END
*DOTCM
      SUBROUTINE DOTCM (Y, YMEAN, YMISS, NY, X, XMEAN, XMISS,
     +   NX, DOTXY, NDOTXY)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE DOT PRODUCT OF TWO
C     SERIES WITH MISSING DATA, CENTERED ABOUT THEIR RESPECTIVE MEANS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DOTXY,XMEAN,XMISS,YMEAN,YMISS
      INTEGER
     +   NDOTXY,NX,NY
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(NX),Y(NY)
C
C  LOCAL SCALARS
      INTEGER
     +   I,M
C
C  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DOTXY
C        THE DOT PRODUCT OF THE SERIES (Y(I) - YMEAN) AND
C        (X(I) - XMEAN).
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER M
C        THE SMALLER OF THE NUMBER OF OBSERVATIONS IN X AND Y
C     INTEGER NDOTXY
C        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY
C     INTEGER NX, NY
C        THE NUMBER OF OBSERVATIONS IN SERIES X AND Y, RESPECTIVELY.
C     DOUBLE PRECISION X(NX)
C        THE VECTOR CONTAINING THE SECOND SERIES
C     DOUBLE PRECISION XMEAN
C        THE MEAN OF THE SECOND SERIES.
C     DOUBLE PRECISION XMISS
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
C        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF X(I) = XMISS,
C        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
C     DOUBLE PRECISION Y(NY)
C        THE VECTOR CONTAINING THE FIRST SERIES
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE FIRST SERIES.
C     DOUBLE PRECISION YMISS
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
C        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
C        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
C
      NDOTXY = 0
      DOTXY = 0.0D0
      M = MIN(NY, NX)
      DO 10 I = 1, M
         IF (MVCHK(Y(I), YMISS) .OR. MVCHK(X(I), XMISS)) GO TO 10
         DOTXY = DOTXY + (Y(I) - YMEAN) * (X(I) - XMEAN)
         NDOTXY = NDOTXY + 1
   10 CONTINUE
      RETURN
      END
*DRV
      SUBROUTINE DRV(PAR, NPAR, XM, N, M, IXM, D)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     DUMMY DERIVATIVE FUNCTION FOR NLS FAMILY
C
C     WRITTEN BY  -  LINDA L. MITCHELL
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PAR(NPAR),XM(IXM,M)
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION D(N,NPAR)
C        THE FIRST DERIVATIVE WITH RESPECT TO THE ITH PARAMETER
C     INTEGER IXM
C        ACTUAL FIRST DIMENSION OF XM
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLESC
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS
C     DOUBLE PRECISION PAR(NPAR)
C        MODEL PARAMETERS
C     DOUBLE PRECISION XM(IXM,M)
C        MODEL INDEPENDENT VARIABLE
C
C
      RETURN
C
      END
*DRV1A
      SUBROUTINE DRV1A(COEF, NCOEF, XM, N, M, IXM, D)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     DERIVATIVE FUNCTION FOR NLS FAMILY EXERCISER SUBROUTINE MDL1
C     CODED CORRECTLY.
C
C     WRITTEN BY  -  LINDA L. MITCHELL
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NCOEF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   COEF(NCOEF),D(N,NCOEF),XM(IXM,M)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION COEF(NCOEF)
C        MODEL COEFFICIENTS
C     DOUBLE PRECISION D(N,NCOEF)
C        THE FIRST DERIVATIVE WITH RESPECT TO THE ITH COEFFICIENT
C     INTEGER I
C        ROW MARKER
C     INTEGER IXM
C        ACTUAL FIRST DIMENSION OF XM
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLESC
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS
C     INTEGER NCOEF
C        THE NUMBER OF COEFFICIENTS
C     DOUBLE PRECISION XM(IXM,M)
C        INDEPENDENT VARIABLES
C
C
      DO 10 I=1,N
         D(I,1) = XM(I,1)**COEF(2)
         D(I,2) = COEF(1)*(XM(I,1)**COEF(2))*LOG(XM(I,1))
   10 CONTINUE
C
      RETURN
C
      END
*DRV1B
      SUBROUTINE DRV1B(PAR, NPAR, XM, N, M, IXM, D)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     DERIVATIVE FUNCTION FOR NLS FAMILY EXERCISER SUBROUTINE MDL1
C     CODED INCORRECTLY.
C
C     WRITTEN BY  -  LINDA L. MITCHELL
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PAR(NPAR),XM(IXM,M)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION D(N,NPAR)
C        THE FIRST DERIVATIVE WITH RESPECT TO THE ITH COEFFICIENT
C     INTEGER I
C        ROW MARKER
C     INTEGER IXM
C        ACTUAL FIRST DIMENSION OF XM
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLESC
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS
C     INTEGER NPAR
C        THE NUMBER OF COEFFICIENTS
C     DOUBLE PRECISION PAR(NPAR)
C        MODEL COEFFICIENTS
C     DOUBLE PRECISION XM(IXM,M)
C        INDEPENDENT VARIABLES
C
C
      DO 10 I=1,N
         D(I,1) = XM(I,1)*PAR(2)
         D(I,2) = PAR(1)*(XM(I,1)**PAR(2))*LOG(XM(I,1))
   10 CONTINUE
C
      RETURN
C
      END
*DRV2
      SUBROUTINE DRV2(PAR, NPAR, XM, N, M, IXM, D)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     DERIVATIVE FUNCTION FOR NLS FAMILY EXERCISER SUBROUTINE MDL2.
C
C     WRITTEN BY  -  LINDA L. MITCHELL
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PAR(NPAR),XM(IXM,M)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION PAR(NPAR)
C        MODEL PARAMETERS
C     DOUBLE PRECISION D(N,NPAR)
C        THE FIRST DERIVATIVE WITH RESPECT TO THE ITH PARAMETER
C     INTEGER I
C        ROW MARKER
C     INTEGER IXM
C        ACTUAL FIRST DIMENSION OF XM
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLESC
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS
C     DOUBLE PRECISION XM(IXM,M)
C        MODEL INDEPENDENT VARIABLE
C
C
      DO 10 I=1,N
         D(I,1) = XM(I,1)
         D(I,2) = XM(I,2)
         D(I,3) = XM(I,3)**3
   10 CONTINUE
C
      RETURN
C
      END
*DRV3
      SUBROUTINE DRV3(PAR, NPAR, XM, N, M, IXM, D)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     DERIVATIVE FUNCTION FOR NLS FAMILY EXERCISER SUBROUTINE MDL3
C
C     WRITTEN BY  -  LINDA L. MITCHELL
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PAR(NPAR),XM(IXM,M)
C
C  LOCAL SCALARS
      INTEGER
     +   I,J
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION PAR(NPAR)
C        MODEL PARAMETERS
C     DOUBLE PRECISION D(N,NPAR)
C        THE FIRST DERIVATIVE WITH RESPECT TO THE ITH PARAMETER
C     INTEGER I
C        ROW MARKER
C     INTEGER IXM
C        ACTUAL FIRST DIMENSION OF XM
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLESC
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS
C     DOUBLE PRECISION XM(IXM,M)
C        INDEPENDENT VARIABLE
C
      DO 20 I=1,N
         DO 10 J=1,NPAR
            D(I,J) = XM(I,J)
   10    CONTINUE
   20 CONTINUE
C
      RETURN
C
      END
*DRV4A
      SUBROUTINE DRV4A (COEF, NCOEF, XM, N, M, IXM, D)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     DERIVATIVE FOR DERIVATIVE CHECKING ROUTINES (CORRECTLY CODED).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NCOEF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   COEF(NCOEF),D(N,NCOEF),XM(IXM,M)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C  INTRINSIC FUNCTIONS
      INTRINSIC EXP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION COEF(NCOEF)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        COEFFICIENTS ARE STORED.
C     DOUBLE PRECISION D(N,NCOEF)
C        THE MATRIX OF FIRST PARTIAL DERIVATIVES (JACOBIAN).
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS OF DATA.
C     INTEGER NCOEF
C        THE NUMBER OF UNKNOWN COEFFICIENTS IN THE MODEL.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
C
      DO 10 I = 1, N
         D(I,1) = 1.0D0
         D(I,2) = (COEF(3)*2.0D0*(XM(I,1)-COEF(2))/COEF(4)) *
     +      EXP(-((XM(I,1)-COEF(2))**2)/COEF(4))
         D(I,3) = EXP(-((XM(I,1)-COEF(2))**2)/COEF(4))
         D(I,4) = -COEF(3)*(-((XM(I,1)-COEF(2))**2) /
     +      (COEF(4)**2)) * EXP(-((XM(I,1)-COEF(2))**2)/COEF(4))
   10 CONTINUE
C
      RETURN
C
      END
*DRV4B
      SUBROUTINE DRV4B (COEF, NCOEF, XM, N, M, IXM, D)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     DERIVATIVE FOR DERIVATIVE CHECKING ROUTINES (INCORRECTLY CODED).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NCOEF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   COEF(NCOEF),D(N,NCOEF),XM(IXM,M)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C  INTRINSIC FUNCTIONS
      INTRINSIC EXP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION COEF(NCOEF)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        COEFFICIENTS ARE STORED.
C     DOUBLE PRECISION D(N,NCOEF)
C        THE MATRIX OF FIRST PARTIAL DERIVATIVES (JACOBIAN).
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS OF DATA.
C     INTEGER NCOEF
C        THE NUMBER OF UNKNOWN COEFFICIENTS IN THE MODEL.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
C
      DO 10 I = 1, N
         D(I,1) = 0.0D0
         D(I,2) = (COEF(3)*2.0D0*(XM(I,1)-COEF(2))/COEF(4)) *
     +      EXP(-((XM(I,1)-COEF(2))**2)/COEF(4))
         D(I,3) = 0.0D0
         D(I,4) = COEF(3)*(-((XM(I,1)-COEF(2))**2) /
     +      (COEF(4)**2)) * EXP(-((XM(I,1)-COEF(2))**2)/COEF(4))
   10 CONTINUE
C
      RETURN
C
      END
*ECVF
      SUBROUTINE ECVF(NMSUB)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRINTS AN ERROR MESSAGE WHEN THE LAG VALUE OF
C     THE LAST COVARIANCE COMPUTED BEFORE ONE WAS NOT COMPUTED
C     DUE TO MISSING DATA DOES NOT EXCEED ZERO.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 10, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMSUB(6)*1
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
      LOGICAL
     +   HEAD
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C
      CALL IPRINT(IPRT)
C
      HEAD = .TRUE.
C
      CALL EHDR(NMSUB, HEAD)
C
      WRITE(IPRT, 1010)
      RETURN
C
C     FORMAT STATEMENTS
C
 1010 FORMAT (/
     +   46H THE COVARIANCES AT LAGS ZERO AND/OR ONE COULD,
     +   16H NOT BE COMPUTED/
     +   49H BECAUSE OF MISSING DATA.  NO FURTHER ANALYSIS IS,
     +   10H POSSIBLE.)
C
      END
*EHDR
      SUBROUTINE EHDR(NMSUB, HEAD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRINTS THE HEADING FOR THE ERROR CHECKING ROUTINES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      LOGICAL
     +   HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMSUB(6)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VERSP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C
      IF (.NOT.HEAD) RETURN
C
      CALL IPRINT(IPRT)
C
      CALL VERSP(.FALSE.)
      WRITE(IPRT,1010)
      WRITE (IPRT, 1000) (NMSUB(I), I=1,6)
      HEAD = .FALSE.
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/31H ERROR CHECKING FOR SUBROUTINE , 6A1/ 1X, 37('-'))
 1010 FORMAT ('+', 18(1H*)/19H * ERROR MESSAGES */1X, 18(1H*))
C
      END
*EIAGE
      SUBROUTINE EIAGE (NMSUB, NMVAR, YM, N, M, IYM, YMMN, NVMX,
     +   HEAD, MSGTYP, NV, ERROR, NMMIN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS TO ENSURE THAT NO VALUES, OR ONLY A MAXIMUM
C     OF NVMX, ARE NOT GREATER THAN A SPECIFIED LOWER BOUND YMMN,
C     WITH NAME NMMIN.   THE CHECKING OPTION IS SPECIFIED
C     WITH MSGTYP.  IF AN ERROR IS FOUND, THE ERROR IS PRINTED AND
C     AN ERROR FLAG AND THE NUMBER OF VIOLATINS ARE RETURNED.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 10, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IYM,M,MSGTYP,N,NV,NVMX,YMMN
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      INTEGER
     +   YM(*)
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,J
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EIAGEP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IYM
C        THE FIRST DIMENSION OF THE ARRAY YM.
C     INTEGER J
C        AN INDEXING VARIABLE.
C     INTEGER M
C        THE NUMBER OF COLUMNS OF DATA IN YM.
C     INTEGER MSGTYP
C        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
C        IF (MSGTYP.GE.3) THE MESSAGE PRINTED WILL USE NMMIN
C        OTHERWISE IT WILL USE YMMN.
C        IF (MSGTYP = 1 OR 3) NO VIOLATIONS ARE ALLOWED.
C        IF (MSGTYP = 2 OR 4) THE NUMBER OF VIOLATIONS MUST
C                             BE LESS THAN   NVMX   .
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMMIN(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE PARAMETERS NAME.
C     INTEGER NV
C        THE NUMBER OF VIOLATIONS FOUND.
C     INTEGER NVMX
C        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
C     INTEGER YM(IYM,M)
C        THE ARRAY BEING TESTED.
C     INTEGER YMMN
C        THE MINIMUM ACCEPTABLE VALUE.
C
      ERROR = .FALSE.
C
      IF ((N.LE.0) .OR. (M.LE.0)) RETURN
C
C     CHECK FOR VIOLATIONS
C
      NV = 0
      DO 5 I = 1, N
         DO 1 J = 1, M
            IF (YM(I+(J-1)*IYM) .LT. YMMN) NV = NV + 1
    1    CONTINUE
    5 CONTINUE
C
      IF (NV .LE. NVMX) RETURN
C
C     VIOLATIONS FOUND
C
      ERROR = .TRUE.
C
      CALL EIAGEP (NMSUB, NMVAR, YMMN, NVMX, HEAD, MSGTYP, NV,
     +   NMMIN)
C
      RETURN
C
      END
*EIAGEP
      SUBROUTINE EIAGEP (NMSUB, NMVAR, YMMN, NVMX, HEAD, MSGTYP, NV,
     +   NMMIN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRINTS THE ERROR MESSAGES FOR ERAGT AND ERAGTM.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 10, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   MSGTYP,NV,NVMX,YMMN
      LOGICAL
     +   HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER MSGTYP
C        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
C        IF (MSGTYP.GE.3) THE MESSAGE PRINTED WILL USE NMMIN
C        OTHERWISE IT WILL USE YMMN.
C        IF (MSGTYP = 1 OR 3) NO VIOLATIONS ARE ALLOWED.
C        IF (MSGTYP = 2 OR 4) THE NUMBER OF VIOLATIONS MUST
C                             BE LESS THAN   NVMX   .
C     CHARACTER*1 NMMIN(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE PARAMETERS NAME.
C     INTEGER NV
C        THE NUMBER OF VIOLATIONS FOUND.
C     INTEGER NVMX
C        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
C     INTEGER YMMN
C        THE MINIMUM ACCEPTABLE VALUE.
C
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
C
      IF (MSGTYP.LE.2)
     +   WRITE (IPRT, 1000) (NMVAR(I),I=1,6), YMMN, NV
      IF (MSGTYP.GE.3)
     +   WRITE (IPRT, 1005) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8), NV
C
      GO TO (10, 20, 30, 40), MSGTYP
C
   10 WRITE(IPRT, 1010) (NMVAR(I),I=1,6), YMMN
      RETURN
C
   20 WRITE(IPRT, 1020) (NMVAR(I),I=1,6), YMMN, NVMX
      RETURN
C
   30 WRITE(IPRT, 1030) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8)
      RETURN
C
   40 WRITE(IPRT, 1040) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8), NVMX
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/
     +   31H THE NUMBER OF VALUES IN ARRAY , 6A1,
     +   ' LESS THAN ', I5, 4H IS , I6, '.')
 1005 FORMAT (/
     +   31H THE NUMBER OF VALUES IN ARRAY , 6A1,
     +   ' LESS THAN ', 8A1, 4H IS , I6, '.')
 1010 FORMAT(
     +   25H THE VALUES IN THE ARRAY , 6A1,
     +   ' MUST ALL BE GREATER THAN OR EQUAL TO ', I5, '.')
 1020 FORMAT(
     +   35H THE NUMBER OF VALUES IN THE ARRAY , 6A1,
     +   ' LESS THAN ', 8A1/
     +   19H MUST BE LESS THAN , I5, '.')
 1030 FORMAT(
     +   25H THE VALUES IN THE ARRAY , 6A1,
     +   ' MUST ALL BE GREATER THAN OR EQUAL TO ', I5, '.')
 1040 FORMAT(
     +   35H THE NUMBER OF VALUES IN THE ARRAY , 6A1,
     +   ' LESS THAN ', 8A1/
     +   19H MUST BE LESS THAN , I5, '.')
C
      END
*EISEQ
      SUBROUTINE EISEQ(NMSUB, NMVAR1, NVAL, NEQ, MSGTYP, HEAD, ERROR,
     +   NMVAR2)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS WHETHER THE VALUE   NVAL   IS
C     OQUAL TO   NEQ  AND PRINTS A DIAGNOSTIC IF IT IS NOT.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   MSGTYP,NEQ,NVAL
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMSUB(6)*1,NMVAR1(8)*1,NMVAR2(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER MSGTYP
C        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
C        PRINTED, WHERE IF ERROR IS TRUE AND
C        MSGTYP = 1 THE INPUT VALUE WAS NOT EQUAL TO THE NUMBER OF PARAM
C                   SPECIFIED BY MSPEC (ARIMA ESTIMATION AND FORECASTING
C     INTEGER NEQ
C        THE ACCEPTABLE VALUE FOR THE ARGUMENT BEING TESTED.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR1(8)
C        THE CHARACTERS OF THE NAME OF THE ARGUMENT BEING CHECKED.
C     CHARACTER*1 NMVAR2(8)
C        THE CHARACTERS OF THE NAME OF THE ARGUMENT BEING CHECKED
C        AGAINST.
C     INTEGER NVAL
C        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
C
      ERROR = .FALSE.
C
      IF (NVAL .EQ. NEQ) RETURN
C
      ERROR = .TRUE.
C
      CALL IPRINT (IPRT)
C
      CALL EHDR(NMSUB, HEAD)
C
      WRITE (IPRT, 1000) (NMVAR1(I), I=1,6), NVAL
C
C     PRINT MESSAGE FOR ARIMA ROUTINES
C
      WRITE (IPRT, 1010) (NMVAR1(I), I=1,6), NEQ
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/20H THE INPUT VALUE OF , 6A1, 4H IS , I5, '.')
 1010 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   ' MUST BE GREATER THAN OR EQUAL TO'/
     +   1X, I5, ' = ONE PLUS THE SUM OF MSPEC(1,J)+MSPEC(3,J) FOR',
     +   ' J = 1, ..., NFAC,'/
     +   6X, ' = ONE PLUS THE NUMBER OF AUTOREGRESSIVE PARAMETERS PLUS'/
     +   9X, ' THE NUMBER OF MOVING AVERAGE PARAMETERS.')
C
      END
*EISGE
      SUBROUTINE EISGE(NMSUB, NMVAR1, NVAL, NMIN, MSGTYP, HEAD, ERROR,
     +   NMVAR2)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS WHETHER THE VALUE   NVAL   IS GREATER THAN
C     OR EQUAL TO   NMIN   AND PRINTS A DIAGNOSTIC IF IT IS NOT.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   MSGTYP,NMIN,NVAL
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMSUB(6)*1,NMVAR1(8)*1,NMVAR2(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER MSGTYP
C        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
C        PRINTED, WHERE IF ERROR IS TRUE AND
C        MSGTYP = 1 THE INPUT VALUE WAS TOO SMALL BASED
C                   ON LIMITS IMPOSED BY STARPAC
C        MSGTYP = 2 THE INPUT VALUE WAS TOO SMALL BASED ON OTHER INPUT
C                   ARGUMENTS.
C        MSGTYP = 3 THE INPUT VALUE WAS TOO SMALL BASED ON OTHER INPUT
C                   ARGUMENTS, WHERE THE VALUE INDICATES THE FIRST
C                   DIMENSION OF A DIMENSIONED ARRAY
C                   N.B.  IT IS ASSUMED THAT THE DIMENSION NAME IS THE
C                         ARRAY NAME PRECEDED BY THE LETTER I.  IF THE
C                         ARRAY NAME IS 6 LETTERS, THE DIMENSION NAME
C                         SHOULD OMIT THE LAST LETTER.  THE DIMENSION
C                         NAME WILL BE PRINTED USING (NMVAR(I),I=1,6),
C                         AND THE ARRAY NAME USING (NMVAR(I),I=2,7).
C        MSGTYP = 4 THE INPUT VALUE WAS TOO SMALL BASED ON OTHER INPUT
C                   ARGUMENTS, WHERE THE VALUE INDICATES THE SECOND
C                   DIMENSION OF A DIMENSIONED ARRAY
C                   N.B.  IT IS ASSUMED THAT THE DIMENSION NAME IS THE
C                         ARRAY NAME PRECEDED BY THE LETTER J.  IF THE
C                         ARRAY NAME IS 6 LETTERS, THE DIMENSION NAME
C                         SHOULD OMIT THE LAST LETTER.  THE DIMENSION
C                         NAME WILL BE PRINTED USING (NMVAR(I),I=1,6),
C                         AND THE ARRAY NAME USING (NMVAR(I),I=2,7).
C        MSGTYP = 5 THE ARGUMENT BEING CHECKED IS LDSTAK.
C                   NO LONGER USED.
C        MSGTYP = 6 THE ARGUMENT INDICATES THE FIRST DIMENSION OF
C                   AN ARRAY BEING CHECKED AGAINST THE NUMBER OF
C                   UNFIXED PARAMETERS.
C        MSGTYP = 7 THE INPUT VALUE WAS TOO SMALL BASED ON OTHER INPUT
C                   ARGUMENTS, WHERE THE VALUE INDICATES THE
C                   DIMENSION OF A VECTOR.
C                   N.B.  IT IS ASSUMED THAT THE DIMENSION NAME IS THE
C                         ARRAY NAME PRECEDED BY THE LETTER L.  IF THE
C                         ARRAY NAME IS 6 LETTERS, THE DIMENSION NAME
C                         SHOULD OMIT THE LAST LETTER.  THE DIMENSION
C                         NAME WILL BE PRINTED USING (NMVAR(I),I=1,6),
C                         AND THE ARRAY NAME USING (NMVAR(I),I=2,7).
C        MSGTYP = 8 THE INPUT VALUE WAS TOO SMALL BASED ON OTHER INPUT
C                   ARGUMENTS, WHERE THE VALUE INDICATES THE
C                   DIMENSION OF THE VECTORS ACOV AND NLPPA.
C        MSGTYP = 9 THE INPUT VALUE WAS TOO SMALL BASED ON LIMITS
C                   IMPOSED BY STARPAC, WHERE THE VALUE INDICATES THE
C                   DIMENSION OF A VECTOR.
C                   N.B.  IT IS ASSUMED THAT THE DIMENSION NAME IS THE
C                         ARRAY NAME PRECEDED BY THE LETTER L.  IF THE
C                         ARRAY NAME IS 6 LETTERS, THE DIMENSION NAME
C                         SHOULD OMIT THE LAST LETTER.  THE DIMENSION
C                         NAME WILL BE PRINTED USING (NMVAR(I),I=1,6),
C                         AND THE ARRAY NAME USING (NMVAR(I),I=2,7).
C     INTEGER NMIN
C        THE MINIMUM ACCEPTABLE VALUE FOR THE ARGUMENT BEING TESTED.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR1(8)
C        THE CHARACTERS OF THE NAME OF THE ARGUMENT BEING CHECKED.
C     CHARACTER*1 NMVAR2(8)
C        THE CHARACTERS OF THE NAME OF THE ARGUMENT BEING CHECKED
C        AGAINST.
C     INTEGER NVAL
C        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
C
      ERROR = .FALSE.
C
      IF (NVAL .GE. NMIN) RETURN
C
      ERROR = .TRUE.
C
      CALL IPRINT (IPRT)
C
      CALL EHDR(NMSUB, HEAD)
C
      WRITE (IPRT, 1000) (NMVAR1(I), I=1,6), NVAL
C
      GO TO (20, 30, 40, 50, 60, 70, 80, 90, 100), MSGTYP
C
C     PRINT MESSAGE FOR VALUE TOO SMALL BASED ON LIMITS IMPOSED
C     BY STARPAC.
C
   20 WRITE (IPRT, 1010) (NMVAR1(I), I=1,6), NMIN
      RETURN
C
C     PRINT MESSAGE FOR VALUE TOO SMALL BASED ON OTHER INPUT
C     ARGUMENTS.
C
   30 WRITE (IPRT, 1020) (NMVAR1(I), I=1,6), (NMVAR2(I), I=1,8)
      RETURN
C
C     PRINT MESSAGE FOR VALUE TOO SMALL, WHERE VALUE INDICATED THE
C     FIRST DIMENSION OF A DIMENSIONED ARRAY.
C
   40 WRITE (IPRT, 1030) (NMVAR1(I), I=2,7), (NMVAR1(I), I=1,6),
     +   (NMVAR2(I), I=1,8)
      RETURN
C
C     PRINT MESSAGE FOR VALUE TOO SMALL, WHERE VALUE INDICATED THE
C     SECOND DIMENSION OF A DIMENSIONED ARRAY.
C
   50 WRITE (IPRT, 1040) (NMVAR1(I), I=2,7), (NMVAR1(I), I=1,6),
     +   (NMVAR2(I), I=1,8)
      RETURN
C
C     PRINT MESSAGE FOR VALUE TOO SMALL, WHEN ARGUMENT IS LDSTAK.
C
   60 WRITE(IPRT, 1050) NMIN
      RETURN
C
C     PRINT MESSAGE FOR VALUE TOO SMALL, WHERE VALUE INDICATED THE
C     FIRST DIMENSION OF A DIMENSIONED ARRAY CHECK AGAINST THE NUMBER OF
C     UNFIXED PARAMETERS.
C
   70 WRITE (IPRT, 1060) (NMVAR1(I), I=2,7), (NMVAR1(I), I=1,6)
      RETURN
C
C     PRINT MESSAGE FOR VALUE TOO SMALL, WHERE VALUE INDICATED THE
C     DIMENSION OF A VECTOR.
C
   80 WRITE (IPRT, 1070) (NMVAR1(I), I=2,7), (NMVAR1(I), I=1,6),
     +   (NMVAR2(I), I=1,8)
      RETURN
C
C     PRINT MESSAGE FOR VALUE TOO SMALL, WHERE VALUE INDICATED THE
C     DIMENSION OF THE VECTORS ACOV AND NLPPA.
C
   90 WRITE (IPRT, 1080) (NMVAR1(I), I=1,6), (NMVAR2(I), I=1,8)
      RETURN
C
C     PRINT MESSAGE FOR VALUE TOO SMALL, WHERE VALUE INDICATED THE
C     DIMENSION OF A VECTOR.
C
  100 WRITE (IPRT, 1090) (NMVAR1(I), I=2,7), (NMVAR1(I), I=1,6),
     +   NMIN
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/20H THE INPUT VALUE OF , 6A1, 4H IS , I5, '.')
 1010 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   34H MUST BE GREATER THAN OR EQUAL TO , I5, '.')
 1020 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   34H MUST BE GREATER THAN OR EQUAL TO , 8A1, '.')
 1030 FORMAT(
     +   24H THE FIRST DIMENSION OF , 6A1,
     +   30H, AS INDICATED BY THE ARGUMENT/
     +    1X, 6A1, 35H, MUST BE GREATER THAN OR EQUAL TO , 8A1, '.')
 1040 FORMAT(
     +   25H THE SECOND DIMENSION OF , 6A1,
     +   30H, AS INDICATED BY THE ARGUMENT/
     +    1X, 6A1, 35H, MUST BE GREATER THAN OR EQUAL TO , 8A1, '.')
 1050 FORMAT(
     +   55H THE DIMENSION OF THE DOUBLE PRECISION VECTOR DSTAK, AS,
     +   13H INDICATED BY/
     +   54H THE ARGUMENT LDSTAK, MUST BE GREATER THAN OR EQUAL TO,
     +   I5, '.')
 1060 FORMAT(
     +   24H THE FIRST DIMENSION OF , 6A1,
     +   30H, AS INDICATED BY THE ARGUMENT/
     +    1X, 6A1, 34H, MUST BE GREATER THAN OR EQUAL TO,
     +   34H THE NUMBER OF UNFIXED PARAMETERS.)
 1070 FORMAT(
     +   15H THE LENGTH OF , 6A1,
     +   30H, AS INDICATED BY THE ARGUMENT/
     +    1X, 6A1, 35H, MUST BE GREATER THAN OR EQUAL TO , 8A1, '.')
 1080 FORMAT(
     +   29H THE LENGTH OF ACOV AND NLPPA,
     +   30H, AS INDICATED BY THE ARGUMENT/
     +    1X, 6A1, 35H, MUST BE GREATER THAN OR EQUAL TO , 8A1, '.')
 1090 FORMAT(
     +   15H THE LENGTH OF , 6A1,
     +   30H, AS INDICATED BY THE ARGUMENT/
     +    1X, 6A1, 35H, MUST BE GREATER THAN OR EQUAL TO , I6, '.')
C
      END
*EISII
      SUBROUTINE EISII(NMSUB, NMVAR, IVAL, IVALMN, IVALMX, MSGTYP,
     +   HEAD, ERROR, NMMIN, NMMAX)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THE ROUTINE CHECKS WHETHER THE VALUE   IVAL   IS WITHIN THE
C     THE RANGE IVALMN (INCLUSIVE) TO IVALMX (INCLUSIVE), AND PRINTS A
C     DIAGNOSTIC IF IT IS NOT.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IVAL,IVALMN,IVALMX,MSGTYP
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMMAX(8)*1,NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAL
C        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
C     INTEGER IVALMN, IVALMX
C        THE MINIMUM AND MAXIMUM OF THE RANGE WITHIN WHICH THE
C        ARGUMENT MUST LIE.
C     INTEGER MSGTYP
C        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
C        PRINTED, WHERE IF ERROR IS .TRUE. AND
C        MSGTYP = 1 THE INPUT VALUE WAS OUTSIDE THE RANGE DETERMINED
C                   FROM OTHER INPUT ARGUMENTS
C        MSGTYP = 2 THE INPUT VALUE WAS OUTSIDE THE RANGE IMPOSED BY
C                   STARPAC
C     CHARACTER*1 NMMAX(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MAXIMUM.
C     CHARACTER*1 NMMIN(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE ARGUMENTS NAME.
C
      ERROR = .FALSE.
C
      IF (((IVALMN.LE.IVAL) .AND. (IVAL.LE.IVALMX)) .OR.
     +   (IVALMX.LT.IVALMN)) RETURN
C
      ERROR = .TRUE.
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
C
      IF (MSGTYP.LE.2) WRITE (IPRT, 1000) (NMVAR(I),I=1,6), IVAL
C
C     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE DETERMINED FROM
C     OTHER INPUT ARGUMENTS.
C
      IF (MSGTYP .EQ. 1)
     +   WRITE (IPRT, 1010) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8),
     +      (NMMAX(I),I=1,8)
C
C     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE IMPOSED BY STARPAC
C
      IF (MSGTYP .EQ. 2)
     +   WRITE (IPRT, 1020) (NMVAR(I),I=1,6), IVALMN, IVALMX
C
C     PRINT MESSAGE FOR AOV ROUTINES
C
      IF (MSGTYP .EQ. 3)
     +   WRITE (IPRT, 1030)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/20H THE INPUT VALUE OF , 6A1, 4H IS , I6, '.')
 1010 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   16H MUST BE BETWEEN, 1X, 8A1,
     +   5H AND , 8A1, 12H, INCLUSIVE.)
 1020 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   16H MUST BE BETWEEN, 1X, I6,
     +   5H AND , I6, 12H, INCLUSIVE.)
 1030 FORMAT(/' THE NUMBER OF DISTINCT GROUPS (NG) MUST BE BETWEEN'/
     +  ' TWO AND ONE LESS THAN THE NUMBER OF POSITIVE TAG VALUES.')
C
      END
*EISLE
      SUBROUTINE EISLE(NMSUB, NMVAR1, NVAL, NMAX, MSGTYP, HEAD, ERROR,
     +   NMVAR2)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS WHETHER THE VALUE   NVAL   IS LESS THAN
C     OR EQUAL TO   NMAX   AND PRINTS A DIAGNOSTIC IF IT IS NOT.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   MSGTYP,NMAX,NVAL
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMSUB(6)*1,NMVAR1(8)*1,NMVAR2(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER NMAX
C        THE MAXIMUM ACCEPTABLE VALUE FOR THE ARGUMENT BEING TESTED.
C     INTEGER MSGTYP
C        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
C        PRINTED, WHERE IF ERROR IS TRUE AND
C        MSGTYP = 1 THE INPUT VALUE WAS TOO LARGE BASED
C                   ON LIMITS IMPOSED BY STARPAC
C        MSGTYP = 2 THE INPUT VALUE WAS TOO LARGE BASED ON OTHER INPUT
C                   ARGUMENTS.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR1(8)
C        THE CHARACTERS OF THE NAME OF THE ARGUMENT BEING CHECKED.
C     CHARACTER*1 NMVAR2(8)
C        THE CHARACTERS OF THE NAME OF THE ARGUMENT BEING CHECKED
C        AGAINST.
C     INTEGER NVAL
C        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
C
      ERROR = .FALSE.
C
      IF (NVAL .LE. NMAX) RETURN
C
      ERROR = .TRUE.
C
      CALL IPRINT (IPRT)
C
      CALL EHDR(NMSUB, HEAD)
C
      WRITE (IPRT, 1000) (NMVAR1(I), I=1,6), NVAL
C
      GO TO (10, 20), MSGTYP
C
C     PRINT MESSAGE FOR VALUE TOO LARGE BASED ON LIMITS IMPOSED
C     BY STARPAC.
C
   10 WRITE (IPRT, 1010) (NMVAR1(I), I=1,6), NMAX
      RETURN
C
C     PRINT MESSAGE FOR VALUE TOO LARGE BASED ON OTHER INPUT
C     ARGUMENTS.
C
   20 WRITE (IPRT, 1020) (NMVAR1(I), I=1,6), (NMVAR2(I), I=1,8)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/20H THE INPUT VALUE OF , 6A1, 4H IS , I5, '.')
 1010 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   31H MUST BE LESS THAN OR EQUAL TO , I5, '.')
 1020 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   31H MUST BE LESS THAN OR EQUAL TO , 8A1, '.')
C
      END
*EISRNG
      SUBROUTINE EISRNG (NMSUB, ISEED, ISEEDU, HEAD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS WHETHER THE INPUT VARIABLE ISEED IS
C     WITHIN [0, 2**MDIG], AND, IF NONZERO, IS ODD.
C
C     IF ISEED IS WITHIN [0, 2**MDIG] THEN
C        ISEEDU = ISEED-MOD(ISEED,2)+1
C     ELSE
C        ISEEDU = MIN[ ABS(ISEED)-MOD(ABS(ISEED),2)+1, 2**(MDIG-1)-1]
C                 AND AN ERROR MESSAGE IS PRINTED.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    CENTER FOR COMPUTING AND APPLIED MATHEMATICS
C                    NATIONAL INSTITUTE OF STANDARDS AND TECHNOLOGY
C                    BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 17, 1990
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISEED,ISEEDU
      LOGICAL
     +   HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMSUB(6)*1
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,MDIG
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   I1MACH
      EXTERNAL I1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MIN,MOD
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ISEED
C        THE VALUE OF THE SEED BEING TESTED.
C     INTEGER ISEEDU
C        THE VALUE OF THE SEED ACTUALLY USED BY NRAND AND NRANDC.
C     INTEGER MDIG
C        A LOWER BOUND ON THE NUMBER OF BINARY DIGITS AVAILABLE
C        FOR REPRESENTING INTEGERS, INCLUDING THE SIGN BIT.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C
      MDIG = MIN(I1MACH(8)+1,32)
C
C     CHECK FOR VIOLATIONS
C
      IF ((ISEED.EQ.0) .OR.
     +    ((ISEED.GE.1) .AND.
     +     (ISEED.LE.2**(MDIG-1)-1) .AND.
     +     (MOD(ISEED,2).EQ.1))) THEN
C
C     SUPPLIED SEED WILL BE USED
C
         ISEEDU = ISEED
      ELSE
C
C     VIOLATIONS FOUND
C
         ISEEDU = MIN( ABS(ISEED)+MOD(ABS(ISEED),2)-1, 2**(MDIG-1)-1)
         CALL IPRINT(IPRT)
         CALL EHDR(NMSUB, HEAD)
         WRITE (IPRT, 1010) MDIG-1,ISEEDU
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1010 FORMAT(/
     +   ' THE VALUE OF ISEED MUST BE BETWEEN 0 AND 2**',I2,' - 1,'/
     +   ' INCLUSIVE, AND, IF ISEED IS NOT 0, ISEED MUST BE ODD.  THE'/
     +   ' SEED ACTUALLY USED BY THE RANDOM NUMBER GENERATOR HAS BEEN'/
     +   ' SET TO', I10,'.')
C
      END
*EIVEO
      SUBROUTINE EIVEO (NMSUB, NMVAR, IVEC, N, EVEN, HEAD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS WHETHER EACH OF THE VALUES IN THE INPUT
C     VECTOR IVEC ARE EVEN (OR ODD) AND PRINTS A
C     DIAGNOSTIC IF THEY ARE NOT.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N
      LOGICAL
     +   EVEN,HEAD
C
C  ARRAY ARGUMENTS
      INTEGER
     +   IVEC(*)
      CHARACTER
     +   NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MOD
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL EVEN
C        AN INDICATOR VARIABLE DESIGNATING WHETHER THE VALUES OF IVEC
C        SHOULD BE EVEN (TRUE) OR NOT (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVEC(N)
C        THE VECTOR BEING TESTED.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE PARAMETERS NAME.
C
C     CHECK FOR VIOLATIONS
C
      DO 10 I = 1, N
         IF ((EVEN .AND. (MOD(IVEC(I), 2) .EQ. 1)) .OR.
     +       ((.NOT.EVEN) .AND. (MOD(IVEC(I), 2) .EQ. 1))) GO TO 20
   10 CONTINUE
C
      RETURN
C
C     VIOLATIONS FOUND
C
   20 CONTINUE
C
      CALL IPRINT(IPRT)
C
      CALL EHDR(NMSUB, HEAD)
C
      IF (EVEN) GO TO 40
C
      WRITE (IPRT, 1010) (NMVAR(I), I = 1, 6)
      RETURN
C
   40 CONTINUE
      WRITE (IPRT, 1020) (NMVAR(I), I = 1, 6)
      RETURN
C
C     FORMAT STATEMENTS
C
 1010 FORMAT(/
     +   26H THE VALUES IN THE VECTOR , 6A1,
     +   27H MUST ALL BE ODD.  THE NEXT/
     +   53H LARGER INTEGER WILL BE USED IN PLACE OF EVEN VALUES.)
 1020 FORMAT(/
     +   26H THE VALUES IN THE VECTOR , 6A1,
     +   28H MUST ALL BE EVEN.  THE NEXT/
     +   52H LARGER INTEGER WILL BE USED IN PLACE OF ODD VALUES.)
C
      END
*EIVEQ
      SUBROUTINE EIVEQ (NMSUB, NMVAR1, IVEC, N, IVAL, NEQMN, HEAD, NEQ,
     +                  NNE, MSGTYP, ERROR, NMVAR2, NMVAR3)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS WHETHER THE NUMBER OF ELEMENTS OF IVEC EQUAL
C     TO IVAL IS AT LEAST NEQMN.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  AUGUST 3, 1987
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IVAL,MSGTYP,N,NEQ,NEQMN,NNE
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      INTEGER
     +   IVEC(*)
      CHARACTER
     +   NMSUB(6)*1,NMVAR1(8)*1,NMVAR2(8)*1,NMVAR3(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVEC(N)
C        THE VECTOR BEING CHECKED.
C     INTEGER MSGTYP
C        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
C        PRINTED, WHERE IF ERROR IS TRUE AND
C        MSGTYP = 1, THE INPUT VALUE WAS TOO SMALL BASED ON LIMITS
C                    IMPOSED BY STARPAC.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR1(8)
C        THE CHARACTERS OF THE NAME OF THE ARGUMENT BEING CHECKED.
C     CHARACTER*1 NMVAR2(8)
C        THE CHARACTERS OF THE NAME OF THE ARGUMENT BEING CHECKED
C        AGAINST.
C     CHARACTER*1 NMVAR3(8)
C        THE CHARACTERS OF THE NAME OF THE ARGUMENT THAT THE ELEMENTS
C        MUST BE EQUAL TO.
C     INTEGER NEQ
C        THE NUMBER OF ELEMENTS EQUAL TO IVAL.
C     INTEGER NEQMN
C        THE MINIMUM NUMBER OF ELEMENTS EQUAL TO IVAL WHICH IS OK.
C     INTEGER NNE
C        THE NUMBER OF ELEMENTS NOT EQUAL TO IVAL.
C
      ERROR = .FALSE.
C
      IF (N.LE.0) RETURN
C
C     CHECK FOR VALUES EQUAL TO IVAL
C
      NEQ = 0
      DO 10 I = 1, N
         IF (IVEC(I) .EQ. IVAL) NEQ = NEQ + 1
   10 CONTINUE
C
      NNE = N - NEQ
      IF (NEQ .GE. NEQMN) RETURN
C
C     INSUFFICIENT NUMBER OF ELEMENTS EQUAL TO IVAL.
C
      ERROR = .TRUE.
C
      CALL IPRINT(IPRT)
C
      CALL EHDR(NMSUB, HEAD)
C
      IF (MSGTYP.EQ.1) WRITE(IPRT, 1000)
     +   (NMVAR1(I),I=1,8), (NMVAR2(I),I=1,8), NEQ,
     +   (NMVAR2(I),I=1,8), (NMVAR3(I),I=1,8)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(
     +   ' THE NUMBER OF ELEMENTS IN ', 8A1,
     +   ' EQUAL TO ', 8A1, ' IS ', I6, '.'/
     +   ' THE NUMBER OF ELEMENTS EQUAL TO ', 8A1,
     +   ' MUST BE GREATER THAN OR EQUAL TO ', 8A1, '.')
C
      END
*EIVII
      SUBROUTINE EIVII (NMSUB, NMVAR, IVEC, N, IVECLB, IVECUB, NVMX,
     +   HEAD, MSGTYP, NV, ERROR, NMMIN, NMMAX)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS FOR VALUES IN THE INPUT VECTOR IVEC
C     WHICH ARE OUTSIDE THE (INCLUSIVE) LIMITS IVECLB TO IVECUB, PRINTS
C     AN ERROR MESSAGE IF THE NUMBER OF VIOLATIONS EXCEEDS THE LARGEST
C     NUMBER OF VIOLATIONS ALLOWED, AND RETURNS THE NUMBER OF
C     VIOLATIONS AND AN ERROR FLAG INDICATING THE RESULTS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 10, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IVECLB,IVECUB,MSGTYP,N,NV,NVMX
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      INTEGER
     +   IVEC(*)
      CHARACTER
     +   NMMAX(8)*1,NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MOD
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        THE VALUE RETURNED FROM THE ERROR CHECKING ROUTINES TO INDICATE
C        WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED (TRUE)
C        OR NOT (FALSE).
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVEC(N)
C        THE VECTOR BEING TESTED.
C     INTEGER IVECLB, IVECUB
C        THE (INCLUSIVE) RANGE THAT THE VECTOR IS BEING TESTED
C        AGAINST.
C     INTEGER MSGTYP
C        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
C        IF (MSGTYP.GE.4) THE MESSAGE PRINTED WILL USE NMMIN AND
C        NMMAX, OTHERWISE IT WILL USE IVECLB AND IVECUB.
C        IF (MSGTYP = 1 OR 4) NO VIOLATIONS ARE ALLOWED.
C        IF (MSGTYP = 2 OR 5) THE NUMBER OF VIOLATIONS MUST
C                             BE LESS THAN   NVMX   .
C        IF (MSGTYP = 3 OR 6) VIOLATIONS ARE COUNTED ONLY IF THE
C                             THE FIRST ELEMENT IS NOT IN VIOLATION.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMMAX(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MAXIMUM.
C     CHARACTER*1 NMMIN(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE ARGUMENTS NAME.
C     INTEGER NV
C        THE NUMBER OF VIOLATIONS FOUND.
C     INTEGER NVMX
C        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
C
      ERROR = .FALSE.
C
      IF (N.LE.0) RETURN
      IF (IVECUB.LT.IVECLB) RETURN
C
C     TEST WHETHER TESTING IS NECESSRY
C
      IF ((MOD(MSGTYP,3) .EQ. 0) .AND.
     +    ((IVEC(1) .LT. IVECLB) .OR. (IVEC(1) .GT. IVECUB))) RETURN
C
C     CHECK FOR VIOLATIONS
C
      NV = 0
      DO 5 I = 1, N
         IF ((IVEC(I).LT.IVECLB) .OR. (IVEC(I).GT.IVECUB)) NV = NV + 1
    5 CONTINUE
C
      IF (NV .LE. NVMX) RETURN
C
C     VIOLATIONS FOUND
C
      ERROR = .TRUE.
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
C
      IF (MSGTYP.LE.3)
     +   WRITE (IPRT, 1000) (NMVAR(I),I=1,6), IVECLB, IVECUB, NV
      IF (MSGTYP.GE.4)
     +   WRITE (IPRT, 1005) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8),
     +   (NMMAX(I),I=1,8), NV
C
      GO TO (10, 20, 30, 10, 20, 30), MSGTYP
C
   10 WRITE(IPRT, 1010) (NMVAR(I),I=1,6)
      RETURN
C
   20 WRITE(IPRT, 1020) (NMVAR(I),I=1,6), NVMX
      RETURN
C
   30 WRITE(IPRT, 1030) (NMVAR(I),I=1,6)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/
     +   32H THE NUMBER OF VALUES IN VECTOR , 6A1,
     +   19H OUTSIDE THE RANGE , I6, 3H TO/
     +   1X, I6, 16H, INCLUSIVE, IS , I6, '.')
 1005 FORMAT (/
     +   32H THE NUMBER OF VALUES IN VECTOR , 6A1,
     +   19H OUTSIDE THE RANGE , 8A1, 3H TO/
     +   1X, 8A1, 16H, INCLUSIVE, IS , I6, '.')
 1010 FORMAT(
     +   26H THE VALUES IN THE VECTOR , 6A1,
     +   31H MUST ALL BE WITHIN THIS RANGE.)
 1020 FORMAT(
     +   36H THE NUMBER OF VALUES IN THE VECTOR , 6A1,
     +   19H OUTSIDE THIS RANGE/
     +   19H MUST BE LESS THAN , I5, '.')
 1030 FORMAT(
     +   34H IF THE FIRST VALUE OF THE VECTOR , 6A1,
     +   21H IS WITHIN THIS RANGE/
     +   45H ALL OF THE VALUES MUST BE WITHIN THIS RANGE.)
C
      END
*ENFFT
      SUBROUTINE ENFFT(NMSUB, NFFT, NDIV, N, LYFFT, NFFT2, HEAD, ERROR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS WHETHER THE VALUE NFFT IS SUCH THAT NFFT-2 IS
C     DIVISIBLE BY NDIV AND HAS NO PRIME FACTORS GREATER THAN 23, AND
C     THE PRODUCT OF THE SQUARE FREE PRIME FACTORS OF NFFT - 2 DO NOT
C     EXCEED 209, I.E., THE VALUE OF NFFT MEETS THE REQUIREMENTS OF
C     THE EXTENDED LENGTH OF THE SERIES REQUIRED FOR ANY ROUTINE
C     USING THE SINGLETON FFT PROVIDING THE PROPER VALUE OF NDIV
C     IS CHOSEN.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LYFFT,N,NDIV,NFFT,NFFT2
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMSUB(6)*1
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,NFFT1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT,SETESL
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR CONTAINING THE SERIES TO BE EXTENDED.
C     INTEGER N
C        THE ACTUAL NUMBER OF OBSERVATIONS IN THE SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     INTEGER NFFT
C        THE USER SUPPLIED EXTENDED SERIES LENGTH.
C     INTEGER NFFT1
C        THE MAXIMUM OF NFFT AND N+2.
C     INTEGER NFFT2
C        THE SMALLEST EXTENDED SERIES LENGTH WHICH EQUALS OR
C        EXCEEDS NFFT AND WHICH MEETS THE REQUIREMENTS OF
C        SINGLETONS FFT CODE.
C
      ERROR = .FALSE.
      CALL IPRINT (IPRT)
C
      IF (NFFT .GE. N+2) GO TO 20
C
C     PRINT WARNING
C
      CALL EHDR(NMSUB, HEAD)
C
      WRITE (IPRT, 1050) N
C
   20 CONTINUE
      NFFT1 = MAX(NFFT, N+2)
      CALL SETESL(NFFT1-2, NDIV, NFFT2)
C
      IF (NFFT .EQ. NFFT2) RETURN
C
C     PRINT WARNING
C
      CALL EHDR(NMSUB, HEAD)
C
      WRITE (IPRT, 1020) NFFT, NFFT2
C
      IF (NFFT .GT. LYFFT) GO TO 40
C
      WRITE (IPRT, 1030) NFFT2
      RETURN
C
   40 CONTINUE
C
      ERROR = .TRUE.
C
      WRITE (IPRT, 1040) NFFT2, LYFFT
      RETURN
C
C     FORMAT STATEMENTS
C
 1020 FORMAT (/
     +   40H THE INPUT VALUE OF THE PARAMETER NFFT (, I5,
     +   15H) DOES NOT MEET/
     +   51H THE REQUIREMENTS OF SINGLETONS FFT CODE.  THE NEXT,
     +   13H LARGER VALUE/
     +   15H WHICH DOES IS , I5, '.')
 1030 FORMAT (/
     +   11H THE VALUE , I5, 37H WILL BE USED FOR THE EXTENDED SERIES,
     +    8H LENGTH.)
 1040 FORMAT (/
     +   20H HOWEVER, THE VALUE , I5, 27H EXCEEDS THE LENGTH LYFFT (,
     +   I5, 8H) OF THE/
     +   58H VECTOR YFFT, AND THEREFORE CANNOT BE USED AS THE EXTENDED/
     +   43H SERIES LENGTH WITHOUT REDIMENSIONING YFFT.)
 1050 FORMAT (/
     +   56H THE EXTENDED SERIES LENGTH (NFFT) MUST EQUAL OR EXCEED,/
     +   45H THE NUMBER OF OBSERVATIONS IN THE SERIES (N=, I5,
     +    9H) PLUS 2.)
C
      END
*ERAGT
      SUBROUTINE ERAGT (NMSUB, NMVAR, YM, N, M, IYM, YMMN, NVMX,
     +   HEAD, MSGTYP, NV, ERROR, NMMIN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS TO ENSURE THAT NO VALUES, OR ONLY A MAXIMUM
C     OF NVMX, ARE NOT GREATER THAN A SPECIFIED LOWER BOUND YMMN,
C     WITH NAME NMMIN.   THE CHECKING OPTION IS SPECIFIED
C     WITH MSGTYP.  IF AN ERROR IS FOUND, THE ERROR IS PRINTED AND
C     AN ERROR FLAG AND THE NUMBER OF VIOLATINS ARE RETURNED.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 10, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMMN
      INTEGER
     +   IYM,M,MSGTYP,N,NV,NVMX
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,J
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ERAGTP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IYM
C        THE FIRST DIMENSION OF THE ARRAY YM.
C     INTEGER J
C        AN INDEXING VARIABLE.
C     INTEGER M
C        THE NUMBER OF COLUMNS OF DATA IN YM.
C     INTEGER MSGTYP
C        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
C        IF (MSGTYP.GE.3) THE MESSAGE PRINTED WILL USE NMMIN
C        OTHERWISE IT WILL USE YMMN.
C        IF (MSGTYP = 1 OR 3) NO VIOLATIONS ARE ALLOWED.
C        IF (MSGTYP = 2 OR 4) THE NUMBER OF VIOLATIONS MUST
C                             BE LESS THAN   NVMX   .
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMMIN(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE PARAMETERS NAME.
C     INTEGER NV
C        THE NUMBER OF VIOLATIONS FOUND.
C     INTEGER NVMX
C        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
C     DOUBLE PRECISION YM(IYM,M)
C        THE ARRAY BEING TESTED.
C     DOUBLE PRECISION YMMN
C        THE MINIMUM ACCEPTABLE VALUE.
C
      ERROR = .FALSE.
C
      IF ((N.LE.0) .OR. (M.LE.0)) RETURN
C
C     CHECK FOR VIOLATIONS
C
      NV = 0
      DO 5 I = 1, N
         DO 1 J = 1, M
            IF (YM(I+(J-1)*IYM) .LE. YMMN) NV = NV + 1
    1    CONTINUE
    5 CONTINUE
C
      IF (NV .LE. NVMX) RETURN
C
C     VIOLATIONS FOUND
C
      ERROR = .TRUE.
C
      CALL ERAGTP (NMSUB, NMVAR, YMMN, NVMX, HEAD, MSGTYP, NV,
     +   NMMIN)
C
      RETURN
C
      END
*ERAGTM
      SUBROUTINE ERAGTM (NMSUB, NMVAR, YM, YMMISS, N, M, IYM, YMMN,
     +   NVMX, HEAD, MSGTYP, NV, ERROR, NMMIN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS TO ENSURE THAT NO VALUES, OR ONLY A MAXIMUM
C     OF NVMX, ARE NOT GREATER THAN A SPECIFIED LOWER BOUND YMMN,
C     WITH NAME NMMIN.   THE CHECKING OPTION IS SPECIFIED
C     WITH MSGTYP.  IF AN ERROR IS FOUND, THE ERROR IS PRINTED AND
C     AN ERROR FLAG AND THE NUMBER OF VIOLATINS ARE RETURNED.
C     ELEMENTS OF YM(*, I) EQUAL TO YMMISS(I) ARE EXEMPT FROM CHECKING.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 10, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMMN
      INTEGER
     +   IYM,M,MSGTYP,N,NV,NVMX
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(*)
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,J
C
C  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ERAGTP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IYM
C        THE FIRST DIMENSION OF THE ARRAY YM.
C     INTEGER J
C        AN INDEXING VARIABLE.
C     INTEGER M
C        THE NUMBER OF COLUMNS OF DATA IN YM.
C     INTEGER MSGTYP
C        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
C        IF (MSGTYP.GE.3) THE MESSAGE PRINTED WILL USE NMMIN
C        OTHERWISE IT WILL USE YMMN.
C        IF (MSGTYP = 1 OR 3) NO VIOLATIONS ARE ALLOWED.
C        IF (MSGTYP = 2 OR 4) THE NUMBER OF VIOLATIONS MUST
C                             BE LESS THAN   NVMX   .
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMMIN(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE PARAMETERS NAME.
C     INTEGER NV
C        THE NUMBER OF VIOLATIONS FOUND.
C     INTEGER NVMX
C        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
C     DOUBLE PRECISION YM(IYM,M)
C        THE ARRAY BEING TESTED.
C     DOUBLE PRECISION YMMISS(M)
C        MISSING VALUE CODES FOR EACH COLUMN OF YM
C     DOUBLE PRECISION YMMN
C        THE MINIMUM ACCEPTABLE VALUE.
C
      ERROR = .FALSE.
C
      IF ((N.LE.0) .OR. (M.LE.0)) RETURN
C
C     CHECK FOR VIOLATIONS
C
      NV = 0
      DO 5 I = 1, N
         DO 1 J = 1, M
            IF (MVCHK(YM(I+(J-1)*IYM), YMMISS(J))) GO TO 1
            IF (YM(I+(J-1)*IYM) .LE. YMMN) NV = NV + 1
    1    CONTINUE
    5 CONTINUE
C
      IF (NV .LE. NVMX) RETURN
C
C     VIOLATIONS FOUND
C
      ERROR = .TRUE.
      CALL ERAGTP (NMSUB, NMVAR, YMMN, NVMX, HEAD, MSGTYP, NV,
     +   NMMIN)
C
      RETURN
C
      END
*ERAGTP
      SUBROUTINE ERAGTP (NMSUB, NMVAR, YMMN, NVMX, HEAD, MSGTYP, NV,
     +   NMMIN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRINTS THE ERROR MESSAGES FOR ERAGT AND ERAGTM.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 10, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMMN
      INTEGER
     +   MSGTYP,NV,NVMX
      LOGICAL
     +   HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER MSGTYP
C        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
C        IF (MSGTYP.GE.3) THE MESSAGE PRINTED WILL USE NMMIN
C        OTHERWISE IT WILL USE YMMN.
C        IF (MSGTYP = 1 OR 3) NO VIOLATIONS ARE ALLOWED.
C        IF (MSGTYP = 2 OR 4) THE NUMBER OF VIOLATIONS MUST
C                             BE LESS THAN   NVMX   .
C     CHARACTER*1 NMMIN(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE PARAMETERS NAME.
C     INTEGER NV
C        THE NUMBER OF VIOLATIONS FOUND.
C     INTEGER NVMX
C        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
C     DOUBLE PRECISION YMMN
C        THE MINIMUM ACCEPTABLE VALUE.
C
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
C
      IF (MSGTYP.LE.2)
     +   WRITE (IPRT, 1000) (NMVAR(I),I=1,6), YMMN, NV
      IF (MSGTYP.GE.3)
     +   WRITE (IPRT, 1005) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8), NV
C
      GO TO (10, 20, 30, 40), MSGTYP
C
   10 WRITE(IPRT, 1010) (NMVAR(I),I=1,6), YMMN
      RETURN
C
   20 WRITE(IPRT, 1020) (NMVAR(I),I=1,6), YMMN, NVMX
      RETURN
C
   30 WRITE(IPRT, 1030) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8)
      RETURN
C
   40 WRITE(IPRT, 1040) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8), NVMX
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/
     +   31H THE NUMBER OF VALUES IN ARRAY , 6A1,
     +   23H LESS THAN OR EQUAL TO , 1PE14.7, 4H IS , I6, '.')
 1005 FORMAT (/
     +   31H THE NUMBER OF VALUES IN ARRAY , 6A1,
     +   23H LESS THAN OR EQUAL TO , 8A1, 4H IS , I6, '.')
 1010 FORMAT(
     +   25H THE VALUES IN THE ARRAY , 6A1,
     +   26H MUST ALL BE GREATER THAN , 1PE14.7, '.')
 1020 FORMAT(
     +   35H THE NUMBER OF VALUES IN THE ARRAY , 6A1,
     +   23H LESS THAN OR EQUAL TO , 8A1/
     +   19H MUST BE LESS THAN , I5, '.')
 1030 FORMAT(
     +   25H THE VALUES IN THE ARRAY , 6A1,
     +   26H MUST ALL BE GREATER THAN , 1PE14.7, '.')
 1040 FORMAT(
     +   35H THE NUMBER OF VALUES IN THE ARRAY , 6A1,
     +   23H LESS THAN OR EQUAL TO , 8A1/
     +   19H MUST BE LESS THAN , I5, '.')
C
      END
*ERDF
      SUBROUTINE ERDF(NMSUB, NDF, IOD, ND, N, HEAD, ERROR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PERFORMS ERROR CHECKING FOR THE INPUT
C     VALUES USED TO SPECIFY DIFFERENCING ON A TIME SERIES
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NDF
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      INTEGER
     +   IOD(*),ND(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IER,IPRT,MBOD
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IER
C        AN ERROR INDICATOR.
C     INTEGER IOD(NDF)
C        THE VECTOR CONTAINING THE ORDERS OF EACH DIFFERENCE FACTOR.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER MBOD
C        THE MAXIMUM BACKORDER DUE TO DIFFERENCING.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER ND(NDF)
C        THE VECTOR CONTAINING THE NUMBER OF TIMES EACH DIFFERENCE
C        FACTOR IS APPLIED.
C     INTEGER NDF
C        THE NUMBER OF DIFFERENCE FACTORS TO BE APPLIED TO THE SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINE NAME.
C
      ERROR = .FALSE.
C
      IF (NDF .GE. 0) GO TO 10
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
      WRITE (IPRT, 1001) NDF
      ERROR = .TRUE.
      RETURN
C
   10 IF (NDF .EQ. 0) RETURN
C
      IER = 0
      MBOD = 0
      DO 30 I = 1, NDF
         IF (IOD(I) .GE. 1 .AND. ND(I) .GE. 1) GO TO 20
         IER = 1
         GO TO 40
   20    MBOD = MBOD + IOD(I) * ND(I)
   30 CONTINUE
      IF (MBOD .LE. N - 1) RETURN
C
   40 CONTINUE
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
      IF (IER .EQ. 1)
     +   WRITE (IPRT, 1002) (I, ND(I), IOD(I), I = 1, NDF)
      IF (IER .EQ. 0 .AND. MBOD .GE. N) WRITE (IPRT, 1003) MBOD, N
      ERROR = .TRUE.
      RETURN
C
C     FORMAT STATEMENTS
C
 1001 FORMAT(/44H THE NUMBER OF DIFFERENCE FACTORS (NDF) MUST/
     +   54H BE GREATER THAN OR EQUAL TO ZERO.  THE INPUT VALUE OF/
     +   8H NDF IS , I6, '.')
 1002 FORMAT (/46H THE ORDER OF EACH DIFFERENCE FACTOR (IOD) AND/
     +   56H NUMBER OF TIMES IT IS APPLIED (ND) MUST BE GREATER THAN/
     +   52H EQUAL TO ONE.  THE INPUT VALUES OF THESE ARRAYS ARE/
     +   25H    DIF. FACT.   ND   IOD/
     +   (1X, I13, I5, I6))
 1003 FORMAT (/50H THE MAXIMUM BACKORDER DUE TO DIFFERENCING (MBOD),
     +  /54H THAT IS, THE SUM OF ND(I)*IOD(I), I = 1, 2, ..., NDF,/
     +   59H MUST BE LESS THAN OR EQUAL TO N-1.  THE COMPUTED VALUE FOR/
     +   9H MBOD IS , I6, 33H, WHILE THE INPUT VALUE FOR N IS , I6, '.')
      END
*ERIODD
      SUBROUTINE ERIODD(NMSUB, NMVAR, NVAL, MSGTYP, HEAD, ERROR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SETS ERROR TO TRUE IF THE VALUE   NVAL   IS NOT EVEN
C     OR ODD, AS SPECIFIED BY THE PARAMETER ODD.  IN ADDITION, IF THIS
C     IS THE FIRST ERROR FOUND FOR THE CALLING SUBROUTINE   NMSUB   , IE
C     IF   HEAD   IS TRUE, THEN A HEADING FOR THE CALLING SUBROUTINE
C     IS ALSO PRINTED OUT.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   MSGTYP,NVAL
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MOD
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER MSGTYP
C        A VARIABLE USED TO INDICATE THE TYPE OF MESSAGE TO BE
C        PRINTED, WHERE IF
C        MSGTYP = 1, THE INPUT VALUE SHOULD BE ODD AND
C        MSGTYP = 2, THE INPUT VALUE SHOULD BE EVEN.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THE CALLING SUBROUTINE.
C     CHARACTER*1 NMVAR(8)
C        THE ARRAY CONTAINING THE NAME OF THE VARIABLE BEING CHECKED.
C     INTEGER NVAL
C        THE VALUE OF THE VARIABLE BEING CHECKED.
C
      ERROR = .FALSE.
C
      IF (MSGTYP .EQ. 2) GO TO 10
C
C     CHECK FOR ODD
C
      IF (MOD(NVAL, 2) .EQ. 1) RETURN
C
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
      WRITE(IPRT, 1010) (NMVAR(I), I = 1, 6), (NMVAR(I), I = 1, 6), NVAL
      ERROR = .TRUE.
      RETURN
C
   10 CONTINUE
C
C     CHECK FOR EVEN
C
      IF (MOD(NVAL, 2) .EQ. 0) RETURN
C
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
      WRITE(IPRT, 1020) (NMVAR(I), I = 1, 6), (NMVAR(I), I = 1, 6), NVAL
      ERROR = .TRUE.
      RETURN
C
C     FORMAT STATEMENTS
C
 1010 FORMAT(/
     +   27H THE VALUE OF THE VARIABLE , 6A1,
     +   34H MUST BE ODD.  THE INPUT VALUE OF , 6A1/
     +    4H IS , I5, '.')
 1020 FORMAT(/
     +   27H THE VALUE OF THE VARIABLE , 6A1,
     +   35H MUST BE EVEN.  THE INPUT VALUE OF , 6A1/
     +    4H IS , I5, '.')
C
      END
*ERSEI
      SUBROUTINE ERSEI(NMSUB, NMVAR, VAL, VALMN, VALMX, MSGTYP, HEAD,
     +   ERROR, NMMIN, NMMAX)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THE ROUTINE CHECKS WHETHER THE VALUE   VAL   IS WITHIN THE
C     THE RANGE VALMN (EXCLUSIVE) TO VALMX (INCLUSIVE), AND PRINTS A
C     DIAGNOSTIC IF IT IS NOT.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 10, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VAL,VALMN,VALMX
      INTEGER
     +   MSGTYP
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMMAX(8)*1,NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER MSGTYP
C        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
C        PRINTED, WHERE IF ERROR IS .TRUE. AND
C        MSGTYP = 1 THE INPUT VALUE WAS OUTSIDE THE RANGE DETERMINED
C                   FROM OTHER INPUT ARGUMENTS
C        MSGTYP = 2 THE INPUT VALUE WAS OUTSIDE THE RANGE IMPOSED BY
C                   STARPAC
C     CHARACTER*1 NMMAX(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MAXIMUM.
C     CHARACTER*1 NMMIN(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE ARGUMENTS NAME.
C     DOUBLE PRECISION VAL
C        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
C     DOUBLE PRECISION VALMN, VALMX
C        THE MINIMUM AND MAXIMUM OF THE RANGE WITHIN WHICH THE
C        ARGUMENT MUST LIE.
C
      ERROR = .FALSE.
C
      IF (((VALMN.LT.VAL) .AND. (VAL.LE.VALMX)) .OR.
     +   (VALMX.LT.VALMN)) RETURN
C
      ERROR = .TRUE.
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
C
      WRITE (IPRT, 1000) (NMVAR(I),I=1,6), VAL
C
C     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE DETERMINED FROM
C     OTHER INPUT ARGUMENTS.
C
      IF (MSGTYP .EQ. 1)
     +   WRITE (IPRT, 1010) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8),
     +      (NMMAX(I),I=1,8)
C
C     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE IMPOSED BY STARPAC
C
      IF (MSGTYP .EQ. 2)
     +   WRITE (IPRT, 1020) (NMVAR(I),I=1,6), VALMN, VALMX
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/20H THE INPUT VALUE OF , 6A1, 4H IS , G15.8, '.')
 1010 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   17H MUST LIE BETWEEN, 1X, 8A1, 12H (EXCLUSIVE)/
     +   5H AND , 8A1, 13H (INCLUSIVE).)
 1020 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   17H MUST LIE BETWEEN, 1X, G15.8, 12H (EXCLUSIVE)/
     +   5H AND , G15.8, 13H (INCLUSIVE).)
C
      END
*ERSGE
      SUBROUTINE ERSGE(NMSUB, NMVAR, VAL, VALMN, MSGTYP, HEAD, ERROR,
     +   NMMIN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THE ROUTINE CHECKS WHETHER THE VALUE   VAL   IS GREATER THAN OR
C     EQUAL TO   VALMN   , AND PRINTS A DIAGNOSTIC IF IT IS NOT.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 10, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VAL,VALMN
      INTEGER
     +   MSGTYP
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER MSGTYP
C        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
C        PRINTED, WHERE IF ERROR IS .TRUE. AND
C        MSGTYP = 1 THE INPUT VALUE WAS TOO SMALL BASED
C                   ON LIMITS IMPOSED BY STARPAC
C        MSGTYP = 2 THE INPUT VALUE WAS TOO SMALL BASED ON
C                   LIMITS BASED ON OTHER INPUT ARGUMENTS.
C     CHARACTER*1 NMMIN(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE ARGUMENTS NAME.
C     DOUBLE PRECISION VAL
C        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
C     DOUBLE PRECISION VALMN
C        THE MINIMUM VALUE THE ARGUMENT CAN VALIDLY HAVE.
C
      ERROR = .FALSE.
C
      IF (VAL .GE. VALMN) RETURN
C
      ERROR = .TRUE.
      CALL IPRINT (IPRT)
      CALL EHDR(NMSUB, HEAD)
C
      WRITE (IPRT, 1000) (NMVAR(I),I=1,6), VAL
C
      GO TO (10, 20), MSGTYP
C
C     PRINT MESSAGE FOR VALUE TOO SMALL BASED ON LIMITS IMPOSED
C     BY STARPAC.
C
   10 WRITE (IPRT, 1010) (NMVAR(I),I=1,6), VALMN
      RETURN
C
   20 WRITE (IPRT, 1020) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/20H THE INPUT VALUE OF , 6A1, 4H IS , G15.8, '.')
 1010 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   34H MUST BE GREATER THAN OR EQUAL TO , G21.14, '.')
 1020 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   34H MUST BE GREATER THAN OR EQUAL TO , 8A1, '.')
C
      END
*ERSGT
      SUBROUTINE ERSGT(NMSUB, NMVAR, VAL, VALMN, MSGTYP, HEAD, ERROR,
     +   NMMIN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THE ROUTINE CHECKS WHETHER THE VALUE   VAL   IS GREATER THAN
C        VALMN   , AND PRINTS A DIAGNOSTIC IF IT IS NOT.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 10, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VAL,VALMN
      INTEGER
     +   MSGTYP
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER MSGTYP
C        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
C        PRINTED, WHERE IF ERROR IS .TRUE. AND
C        MSGTYP = 1 THE INPUT VALUE WAS TOO SMALL BASED
C                   ON LIMITS IMPOSED BY STARPAC
C        MSGTYP = 2 THE INPUT VALUE WAS TOO SMALL BASED ON
C                   LIMITS BASED ON OTHER INPUT ARGUMENTS.
C     CHARACTER*1 NMMIN(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE ARGUMENTS NAME.
C     DOUBLE PRECISION VAL
C        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
C     DOUBLE PRECISION VALMN
C        THE MINIMUM VALUE THE ARGUMENT CAN VALIDLY HAVE.
C
      ERROR = .FALSE.
C
      IF (VAL .GT. VALMN) RETURN
C
      ERROR = .TRUE.
      CALL IPRINT (IPRT)
      CALL EHDR(NMSUB, HEAD)
C
      WRITE (IPRT, 1000) (NMVAR(I),I=1,6), VAL
C
      GO TO (10, 20), MSGTYP
C
   10 WRITE (IPRT, 1010) (NMVAR(I),I=1,6), VALMN
      RETURN
C
   20 WRITE (IPRT, 1020) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/20H THE INPUT VALUE OF , 6A1, 4H IS , G15.8, '.')
 1010 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   22H MUST BE GREATER THAN , G21.14, '.')
 1020 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   22H MUST BE GREATER THAN , 8A1, '.')
C
      END
*ERSIE
      SUBROUTINE ERSIE(NMSUB, NMVAR, VAL, VALMN, VALMX, MSGTYP, HEAD,
     +   ERROR, NMMIN, NMMAX)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THE ROUTINE CHECKS WHETHER THE VALUE   VAL   IS WITHIN THE
C     THE RANGE VALMN (INCLUSIVE) TO VALMX (EXCLUSIVE), AND PRINTS A
C     DIAGNOSTIC IF IT IS NOT.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 10, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VAL,VALMN,VALMX
      INTEGER
     +   MSGTYP
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMMAX(8)*1,NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER MSGTYP
C        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
C        PRINTED, WHERE IF ERROR IS .TRUE. AND
C        MSGTYP = 1 THE INPUT VALUE WAS OUTSIDE THE RANGE DETERMINED
C                   FROM OTHER INPUT ARGUMENTS
C        MSGTYP = 2 THE INPUT VALUE WAS OUTSIDE THE RANGE IMPOSED BY
C                   STARPAC
C     CHARACTER*1 NMMAX(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MAXIMUM.
C     CHARACTER*1 NMMIN(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE ARGUMENTS NAME.
C     DOUBLE PRECISION VAL
C        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
C     DOUBLE PRECISION VALMN, VALMX
C        THE MINIMUM AND MAXIMUM OF THE RANGE WITHIN WHICH THE
C        ARGUMENT MUST LIE.
C
      ERROR = .FALSE.
C
      IF (((VALMN.LE.VAL) .AND. (VAL.LT.VALMX)) .OR.
     +   (VALMX.LT.VALMN)) RETURN
C
      ERROR = .TRUE.
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
C
      WRITE (IPRT, 1000) (NMVAR(I),I=1,6), VAL
C
C     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE DETERMINED FROM
C     OTHER INPUT ARGUMENTS.
C
      IF (MSGTYP .EQ. 1)
     +   WRITE (IPRT, 1010) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8),
     +      (NMMAX(I),I=1,8)
C
C     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE IMPOSED BY STARPAC
C
      IF (MSGTYP .EQ. 2)
     +   WRITE (IPRT, 1020) (NMVAR(I),I=1,6), VALMN, VALMX
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/20H THE INPUT VALUE OF , 6A1, 4H IS , G15.8, '.')
 1010 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   17H MUST LIE BETWEEN, 1X, 8A1, 12H (INCLUSIVE)/
     +   5H AND , 8A1, 13H (EXCLUSIVE).)
 1020 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   17H MUST LIE BETWEEN, 1X, G15.8, 12H (INCLUSIVE)/
     +   5H AND , G15.8, 13H (EXCLUSIVE).)
C
      END
*ERSII
      SUBROUTINE ERSII(NMSUB, NMVAR, VAL, VALMN, VALMX, MSGTYP, HEAD,
     +   ERROR, NMMIN, NMMAX)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THE ROUTINE CHECKS WHETHER THE VALUE   VAL   IS WITHIN THE
C     THE RANGE VALMN (INCLUSIVE) TO VALMX (INCLUSIVE), AND PRINTS A
C     DIAGNOSTIC IF IT IS NOT.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 10, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VAL,VALMN,VALMX
      INTEGER
     +   MSGTYP
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMMAX(8)*1,NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER MSGTYP
C        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
C        PRINTED, WHERE IF ERROR IS .TRUE. AND
C        MSGTYP = 1 THE INPUT VALUE WAS OUTSIDE THE RANGE DETERMINED
C                   FROM OTHER INPUT ARGUMENTS
C        MSGTYP = 2 THE INPUT VALUE WAS OUTSIDE THE RANGE IMPOSED BY
C                   STARPAC
C     CHARACTER*1 NMMAX(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MAXIMUM.
C     CHARACTER*1 NMMIN(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE ARGUMENTS NAME.
C     DOUBLE PRECISION VAL
C        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
C     DOUBLE PRECISION VALMN, VALMX
C        THE MINIMUM AND MAXIMUM OF THE RANGE WITHIN WHICH THE
C        ARGUMENT MUST LIE.
C
      ERROR = .FALSE.
C
      IF (((VALMN.LE.VAL) .AND. (VAL.LE.VALMX)) .OR.
     +   (VALMX.LT.VALMN)) RETURN
C
      ERROR = .TRUE.
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
C
      WRITE (IPRT, 1000) (NMVAR(I),I=1,6), VAL
C
C     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE DETERMINED FROM
C     OTHER INPUT ARGUMENTS.
C
      IF (MSGTYP .EQ. 1)
     +   WRITE (IPRT, 1010) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8),
     +      (NMMAX(I),I=1,8)
C
C     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE IMPOSED BY STARPAC
C
      IF (MSGTYP .EQ. 2)
     +   WRITE (IPRT, 1020) (NMVAR(I),I=1,6), VALMN, VALMX
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/20H THE INPUT VALUE OF , 6A1, 4H IS , G15.8, '.')
 1010 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   16H MUST BE BETWEEN, 1X, 8A1,
     +   5H AND , 8A1, 12H, INCLUSIVE.)
 1020 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   16H MUST BE BETWEEN, 1X, G15.8,
     +   5H AND , G15.8, 12H, INCLUSIVE.)
C
      END
*ERSLF
      SUBROUTINE ERSLF (NMSUB, NMVAR, K, H, HEAD, ERROR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PERFORMS ERROR CHECKING FOR THE INPUT
C     VALUES OF A SYMMETRIC LINEAR FILTER.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   K
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   H(*)
      CHARACTER
     +   NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IHM,IHP,IPRT,KHALF,KMID,NZERO
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION H(K)
C         THE VECTOR OF FILTER COEFFICIENTS.
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IHM, IHP
C        INDEX VARIABLES FOR SYMMETRIC LOCATIONS AROUND THE MIDPOINT
C        OF THE FILTER.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER K
C        THE NUMBER OF TERMS IN THE FILTER.
C     INTEGER KHALF
C        THE VALUE OF THE MIDPOINT OF K MINUS 1.
C     INTEGER KMID
C        THE MIDPOINT OF THE FILTER.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     CHARACTER*1 NMVAR(8)
C        THE ARRAY CONTAINING THE NAME OF THE FILTER COEFFICIENT
C        ARRAY.
C     INTEGER NZERO
C        THE NUMBER OF FILTER COEFFICIENTS EQUAL TO ZERO.
C
      ERROR = .FALSE.
C
      KMID = (K + 1) / 2
      KHALF = KMID - 1
      NZERO = 0
      DO 10 IHM = 1, KHALF
         IHP = K + 1 - IHM
         IF (H(IHM) .EQ. 0.0D0) NZERO = NZERO + 1
         IF (H(IHM)  .EQ.  H(IHP)) GO TO 10
C
         CALL IPRINT(IPRT)
         CALL EHDR(NMSUB, HEAD)
         WRITE (IPRT, 1010) (NMVAR(I), I = 1, 6), (H(I), I = 1, K)
         ERROR = .TRUE.
         RETURN
   10 CONTINUE
C
      IF (H(KMID) .EQ. 0.0D0) NZERO = NZERO + 1
C
      IF (NZERO .LT. KMID) RETURN
C
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
      WRITE (IPRT, 1020) (NMVAR(I), I = 1, 6)
      ERROR = .TRUE.
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1010 FORMAT(/
     +   18H THE INPUT FILTER , 6A1, 24H MUST BE SYMMETRIC.  THE,
     +   30H INPUT FILTER COEFFICIENTS ARE/
     +   5(1X, E15.5))
 1020 FORMAT(/
     +   32H ALL THE FILTER COEFFICIENTS IN , 6A1, 16H ARE IDENTICALLY,
     +   15H EQUAL TO ZERO,/
     +   42H THEREFORE NO FILTERING WILL BE PERFORMED.)
      END
*ERSLFS
      SUBROUTINE ERSLFS(NMSUB, FC, K, HEAD, ERROR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PERFORMS ERROR CHECKING FOR THE INPUT
C     VALUES USED TO SPECIFY SYMMETRIC LINEAR FILTERING OF A
C     TIME SERIES
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC
      INTEGER
     +   K
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMSUB(6)*1
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   TEMP
      INTEGER
     +   IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION FC
C        THE USER SUPPLIED CUTOFF FREQUENCY.
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER K
C        THE NUMBER OF TERMS IN THE FILTER.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THE CALLING SUBROUTINE.
C     DOUBLE PRECISION TEMP
C        A TEMPORARY VARIABLE USED FOR TYPE CONVERSION.
C
      ERROR = .FALSE.
      TEMP = K
C
      IF (FC - 1.0D0/TEMP .GE. 0.0D0) GO TO 10
C
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
      WRITE (IPRT, 1010) FC, K
      ERROR = .TRUE.
      RETURN
C
   10 CONTINUE
C
      IF (FC + 1.0D0/K .LT. 0.5D0) RETURN
C
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
      WRITE (IPRT, 1020) FC, K
      ERROR = .TRUE.
      RETURN
C
C     FORMAT STATEMENTS
C
 1010 FORMAT (/36H THE CUTOFF FREQUENCY, FC, MINUS ONE,
     +   41H OVER THE NUMBER OF FILTER TERMS, K, THAT/
     +   53H IS, FC - 1/K, MUST BE GREATER THAN OR EQUAL TO ZERO.,
     +   29H THE INPUT VALUES OF FC AND K/
     +   4H ARE, F8.5, 4H AND, I5, 15H, RESPECTIVELY.)
 1020 FORMAT (/35H THE CUTOFF FREQUENCY, FC, PLUS ONE,
     +   45H OVER THE NUMBER OF FILTER TERMS, K, THAT IS,/
     +   49H FC + 1/K, MUST BE GREATER THAN OR EQUAL TO ZERO.,
     +   29H THE INPUT VALUES OF FC AND K/
     +   4H ARE, F7.5, 4H AND, I5, 15H, RESPECTIVELY.)
C
      END
*ERVGT
      SUBROUTINE ERVGT (NMSUB, NMVAR, VEC, N, VECLB, NVMX,
     +   HEAD, MSGTYP, NV, ERROR, NMMIN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS TO ENSURE THAT NO VALUES, OR ONLY A MAXIMUM
C     OF NVMX, ARE NOT GREATER THAN A SPECIFIED LOWER BOUND VECLB,
C     WITH NAME NMMIN. THE ROUTINE ALTERNATIVELY CHECKS TO MAKE SURE
C     THAT NO VALUES ARE IN VIOLATION OF THIS LOWER BOUND IF THE FIRST
C     VALUE IN THE VECTOR IS NOT.  THE CHECKING OPTION IS SPECIFIED
C     WITH MSGTYP.  IF AN ERROR IS FOUND, THE ERROR IS PRINTED AND
C     AN ERROR FLAG AND THE NUMBER OF VIOLATINS ARE RETURNED.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VECLB
      INTEGER
     +   MSGTYP,N,NV,NVMX
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VEC(*)
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,NVMN
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ERVGTP
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MOD
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        THE VALUE RETURNED FROM THE ERROR CHECKING ROUTINES TO INDICATE
C        WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED (TRUE)
C        OR NOT (FALSE).
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER MSGTYP
C        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
C        IF (MSGTYP.GE.4) THE MESSAGE PRINTED WILL USE NMMIN
C        OTHERWISE IT WILL USE VECLB.
C        IF (MSGTYP = 1 OR 4) NO VIOLATIONS ARE ALLOWED.
C        IF (MSGTYP = 2 OR 5) THE NUMBER OF VIOLATIONS MUST
C                             BE LESS THAN   NVMX   .
C        IF (MSGTYP = 3 OR 6) VIOLATIONS ARE COUNTED ONLY IF THE
C                             THE FIRST ELEMENT IS NOT IN VIOLATION.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMMIN(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE ARGUMENTS NAME.
C     INTEGER NV
C        THE NUMBER OF VIOLATIONS FOUND.
C     INTEGER NVMN
C        THE SMALLEST NUMBER OF NON-VIOLATIONS ALLOWED.
C     INTEGER NVMX
C        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
C     DOUBLE PRECISION VEC(N)
C        THE VECTOR BEING TESTED.
C     DOUBLE PRECISION VECLB
C        THE VALUE THAT THE VECTOR IS BEING TESTED AGAINST.
C
      ERROR = .FALSE.
C
      IF (N .LE. 0) RETURN
C
C     TEST WHETHER TESTING IS NECESSRY
C
      IF ((MOD(MSGTYP,3) .EQ. 0) .AND. (VEC(1) .LE. VECLB)) RETURN
C
C     CHECK FOR VIOLATIONS
C
      NV = 0
      DO 5 I = 1, N
         IF ((VEC(I).LE.VECLB)) NV = NV + 1
    5 CONTINUE
C
      IF (NV .LE. NVMX) RETURN
C
C     VIOLATIONS FOUND
C
      ERROR = .TRUE.
      NVMN = N - NVMX
      CALL ERVGTP (NMSUB, NMVAR, VECLB, NVMN, NVMX, HEAD, MSGTYP, NV,
     +   NMMIN)
C
      RETURN
C
      END
*ERVGTM
      SUBROUTINE ERVGTM (NMSUB, NMVAR, VEC, VCMISS, N, VECLB, NVMX,
     +   HEAD, MSGTYP, NV, ERROR, NMMIN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS TO ENSURE THAT NO VALUES, OR ONLY A MAXIMUM
C     OF NVMX, ARE NOT GREATER THAN A SPECIFIED LOWER BOUND VECLB,
C     WITH NAME NMMIN. THE ROUTINE ALTERNATIVELY CHECKS TO MAKE SURE
C     THAT NO VALUES ARE IN VIOLATION OF THIS LOWER BOUND IF THE FIRST
C     VALUE IN THE VECTOR IS NOT.  THE CHECKING OPTION IS SPECIFIED
C     WITH MSGTYP.  IF AN ERROR IS FOUND, THE ERROR IS PRINTED AND
C     AN ERROR FLAG AND THE NUMBER OF VIOLATINS ARE RETURNED.
C     VALUES OF VEC EQUAL TO VCMISS ARE EXEMPTED FROM THE CHECKING.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 10, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VCMISS,VECLB
      INTEGER
     +   MSGTYP,N,NV,NVMX
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VEC(*)
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,NVMN
C
C  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ERVGTP
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MOD
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        THE VALUE RETURNED FROM THE ERROR CHECKING ROUTINES TO INDICATE
C        WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED (TRUE)
C        OR NOT (FALSE).
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER MSGTYP
C        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
C        IF (MSGTYP.GE.4) THE MESSAGE PRINTED WILL USE NMMIN
C        OTHERWISE IT WILL USE VECLB.
C        IF (MSGTYP = 1 OR 4) NO VIOLATIONS ARE ALLOWED.
C        IF (MSGTYP = 2 OR 5) THE NUMBER OF VIOLATIONS MUST
C                             BE LESS THAN   NVMX   .
C        IF (MSGTYP = 3 OR 6) VIOLATIONS ARE COUNTED ONLY IF THE
C                             THE FIRST ELEMENT IS NOT IN VIOLATION.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMMIN(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE ARGUMENTS NAME.
C     INTEGER NV
C        THE NUMBER OF VIOLATIONS FOUND.
C     INTEGER NVMN
C        THE SMALLEST NUMBER OF NON-VIOLATIONS ALLOWED.
C     INTEGER NVMX
C        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
C     DOUBLE PRECISION VCMISS
C        MISSING VALUE CODE IN VEC.
C     DOUBLE PRECISION VEC(N)
C        THE VECTOR BEING TESTED.
C     DOUBLE PRECISION VECLB
C        THE VALUE THAT THE VECTOR IS BEING TESTED AGAINST.
C
      ERROR = .FALSE.
C
      IF (N .LE. 0) RETURN
C
C     TEST WHETHER TESTING IS NECESSRY
C
      IF ((MOD(MSGTYP,3) .EQ. 0) .AND. (VEC(1) .LE. VECLB)) RETURN
C
C     CHECK FOR VIOLATIONS
C
      NV = 0
      DO 5 I = 1, N
         IF (MVCHK(VEC(I), VCMISS)) GO TO 5
         IF ((VEC(I).LE.VECLB)) NV = NV + 1
    5 CONTINUE
C
      IF (NV .LE. NVMX) RETURN
C
C     VIOLATIONS FOUND
C
      ERROR = .TRUE.
      NVMN = N - NVMX
      CALL ERVGTP (NMSUB, NMVAR, VECLB, NVMN, NVMX, HEAD, MSGTYP, NV,
     +   NMMIN)
C
      RETURN
C
      END
*ERVGTP
      SUBROUTINE ERVGTP (NMSUB, NMVAR, VECLB, NVMN, NVMX, HEAD, MSGTYP,
     +  NV, NMMIN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRINTS THE ERROR MESSAGES FOR ERVGT AND ERVGTM.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VECLB
      INTEGER
     +   MSGTYP,NV,NVMN,NVMX
      LOGICAL
     +   HEAD
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED (TRUE)
C        OR NOT (FALSE).
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER MSGTYP
C        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
C        IF (MSGTYP.GE.4) THE MESSAGE PRINTED WILL USE NMMIN
C        OTHERWISE IT WILL USE VECLB.
C        IF (MSGTYP = 1 OR 4) NO VIOLATIONS ARE ALLOWED.
C        IF (MSGTYP = 2 OR 5) THE NUMBER OF VIOLATIONS MUST
C                             BE LESS THAN   NVMX   .
C        IF (MSGTYP = 3 OR 6) VIOLATIONS ARE COUNTED ONLY IF THE
C                             THE FIRST ELEMENT IS NOT IN VIOLATION.
C     CHARACTER*1 NMMIN(8)
C        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE ARGUMENTS NAME.
C     INTEGER NV
C        THE NUMBER OF VIOLATIONS FOUND.
C     INTEGER NVMX
C        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
C     DOUBLE PRECISION VECLB
C        THE VALUE THAT THE VECTOR IS BEING TESTED AGAINST.
C
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
C
      IF (MSGTYP.LE.3) THEN
        WRITE (IPRT, 1000) (NMVAR(I),I=1,6), VECLB, NV
      ELSE
        IF (MSGTYP.GE.7) THEN
          WRITE (IPRT, 1001) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8), NV
        ELSE
          WRITE (IPRT, 1002) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8), NV
        END IF
      END IF
C
      GO TO (10, 20, 30, 40, 50, 60, 70), MSGTYP
C
   10 WRITE(IPRT, 1010) (NMVAR(I),I=1,6), VECLB
      RETURN
C
   20 WRITE(IPRT, 1020) (NMVAR(I),I=1,3), VECLB, NVMX
      RETURN
C
   30 WRITE(IPRT, 1030) (NMVAR(I),I=1,6), VECLB, VECLB
      RETURN
C
   40 WRITE(IPRT, 1040) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8)
      RETURN
C
   50 WRITE(IPRT, 1050) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8), NVMX
      RETURN
C
   60 WRITE(IPRT, 1060) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8),
     +   (NMMIN(I),I=1,8)
      RETURN
C
   70 WRITE(IPRT, 1070) NVMN, (NMVAR(I),I=1,6), (NMMIN(I),I=1,8)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/
     +   32H THE NUMBER OF VALUES IN VECTOR , 6A1,
     +   23H LESS THAN OR EQUAL TO , 1PE14.7, 4H IS , I6, '.')
 1001 FORMAT (/
     +   32H THE NUMBER OF VALUES IN VECTOR , 6A1,
     +  ' GREATER THAN ', 8A1, ' IS ', I2, '.')
 1002 FORMAT (/
     +   32H THE NUMBER OF VALUES IN VECTOR , 6A1,
     +   23H LESS THAN OR EQUAL TO , 8A1, 4H IS , I6, '.')
 1010 FORMAT(
     +   26H THE VALUES IN THE VECTOR , 6A1,
     +   26H MUST ALL BE GREATER THAN , 1PE14.7, '.')
 1020 FORMAT(
     +   36H THE NUMBER OF VALUES IN THE VECTOR , 6A1,
     +   23H LESS THAN OR EQUAL TO , 1PE14.7/
     +   19H MUST BE LESS THAN , I5, '.')
 1030 FORMAT(
     +   37H SINCE THE FIRST VALUE OF THE VECTOR , 6A1,
     +   17H IS GREATER THAN , 1PE14.7/
     +   40H ALL OF THE VALUES MUST BE GREATER THAN , 1PE14.7, '.')
 1040 FORMAT(
     +   26H THE VALUES IN THE VECTOR , 6A1,
     +   26H MUST ALL BE GREATER THAN , 8A1, '.')
 1050 FORMAT(
     +   36H THE NUMBER OF VALUES IN THE VECTOR , 6A1,
     +   23H LESS THAN OR EQUAL TO , 8A1/
     +   19H MUST BE LESS THAN , I5, '.')
 1060 FORMAT(
     +   37H SINCE THE FIRST VALUE OF THE VECTOR , 6A1,
     +   17H IS GREATER THAN , 8A1/
     +   40H ALL OF THE VALUES MUST BE GREATER THAN , 8A1, '.')
 1070 FORMAT(/' THERE MUST BE AT LEAST ', I2, ' VALUES IN VECTOR ', 6A1/
     +  ' GREATER THAN OR EQUAL TO ', 8A1, '.')
C
      END
*ERVII
      SUBROUTINE ERVII (NMSUB, NMVAR, Y, N, YLB, YUB, NVMX,
     +   HEAD, MSGTYP, NV, ERROR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS FOR VALUES IN THE INPUT VECTOR   Y
C     WHICH ARE OUTSIDE THE (INCLUSIVE) LIMITS YLB TO YUB, PRINTS
C     AN ERROR MESSAGE IF THE NUMBER OF VIOLATIONS EXCEEDS THE LARGEST
C     NUMBER OF VIOLATIONS ALLOWED, AND RETURNS THE NUMBER OF
C     VIOLATIONS AND AN ERROR FLAG INDICATING THE RESULTS.  THREE
C     MESSAGES ARE AVAILABLE, SPECIFIED BY    MSGTYP   .
C        IF (MSGTYP = 0) NO VIOLATIONS ARE ALLOWED.
C        IF (MSGTYP = 1) THE NUMBER OF VIOLATIONS MUST
C                        BE LESS THAN   NVMX   .
C        IF (MSGTYP = 2) VIOLATIONS ARE COUNTED ONLY IF THE
C                        THE FIRST ELEMENT IS NOT IN VIOLATION.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YLB,YUB
      INTEGER
     +   MSGTYP,N,NV,NVMX
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
      CHARACTER
     +   NMSUB(6)*1,NMVAR(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT,NNV,NNVMN
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        THE VALUE RETURNED FROM THE ERROR CHECKING ROUTINES TO INDICATE
C        WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED (TRUE)
C        OR NOT (FALSE).
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER MSGTYP
C        THE INDICATOR VARIABLE FOR THE TYPE OF MESSAGE.
C        IF (MSGTYP = 0) NO VIOLATIONS ARE ALLOWED.
C        IF (MSGTYP = 1) THE NUMBER OF VIOLATIONS MUST
C                        BE LESS THAN   NVMX   .
C        IF (MSGTYP = 2) VIOLATIONS ARE COUNTED ONLY IF THE
C                        THE FIRST ELEMENT IS NOT IN VIOLATION.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR(8)
C        THE CHARACTERS OF THE PARAMETERS NAME.
C     INTEGER NNV
C        THE NUMBER OF VALUES NOT IN VIOLATION.
C     INTEGER NNVMN
C        THE SMALLEST NUMBER OF VALUES NOT IN VIOLATION ALLOWED.
C     INTEGER NV
C        THE NUMBER OF VIOLATIONS FOUND.
C     INTEGER NVMX
C        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR BEING TESTED.
C     DOUBLE PRECISION YLB, YUB
C        THE (INCLUSIVE) RANGE THAT THE VECTOR IS BEING TESTED
C        AGAINST.
C
      ERROR = .FALSE.
C
      IF (N .LE. 0) RETURN
C
C     TEST WHETHER TESTING IS NECESSRY
C
      IF ((MSGTYP .EQ. 2) .AND.
     +    (Y(1) .LT. YLB) .OR. (Y(1) .GT. YUB)) RETURN
C
C     CHECK FOR VIOLATIONS
C
      NV = 0
      DO 10 I = 1, N
         IF ((Y(I).LT.YLB) .OR. (Y(I).GT.YUB)) NV = NV + 1
   10 CONTINUE
C
      IF (NV .LE. NVMX) RETURN
C
C     VIOLATIONS FOUND
C
      ERROR = .TRUE.
      CALL IPRINT(IPRT)
C
      CALL EHDR(NMSUB, HEAD)
C
      NNV = N - NV
      NNVMN = N - NVMX
C
      IF (MSGTYP .EQ. 0)
     +   WRITE(IPRT, 1010) (NMVAR(I), I = 1, 6), YLB, YUB, NV
      IF (MSGTYP .EQ. 1)
     +   WRITE(IPRT, 1020) (NMVAR(I), I = 1, 6), YLB, YUB,
     +   NNVMN, NNV
      IF (MSGTYP .EQ. 2)
     +   WRITE(IPRT, 1030) (NMVAR(I), I = 1, 6), YLB, YUB
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1010 FORMAT(/
     +   26H THE VALUES IN THE VECTOR , 6A1,
     +   26H MUST ALL BE IN THE RANGE , 1PE14.7, 3H TO/
     +   1X, 1PE14.7,
     +      52H, INCLUSIVE. THE NUMBER OF VALUES OUTSIDE THIS RANGE,
     +   4H IS , I5, '.')
 1020 FORMAT(/
     +   36H THE NUMBER OF VALUES IN THE VECTOR , 6A1,
     +   14H IN THE RANGE , 1PE14.7, 3H TO/
     +   1X, 1PE14.7, 34H, INCLUSIVE, MUST EQUAL OR EXCEED , I5, '.'/
     +   ' THE NUMBER OF VALUES IN THIS RANGE IS ', I5, '.')
 1030 FORMAT(/
     +   34H IF THE FIRST VALUE OF THE VECTOR , 6A1,
     +   16H IS IN THE RANGE, 1PE14.7, 3H TO/
     +   1X, 1PE14.7,
     +      52H INCLUSIVE, ALL OF THE VALUES MUST BE IN THIS RANGE.)
C
      END
*ERVWT
      SUBROUTINE ERVWT (NMSUB, NMVAR1, WT, N, NNZWMN, HEAD, NNZW,
     +   NZW, MSGTYP, ERROR, NMVAR2)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS USER SUPPLIED WEIGHTS TO ASSURE THERE
C     ARE NO NEGATIVE WEIGHTS, AND THAT THERE ARE SUFFICIENT POSITIVE
C     WEIGHTS FOR THE TASK.  IT RETURNS ERROR SET TO TRUE
C     IF NO ERRORS ARE FOUND, AND SET TO FALSE OTHERWISE, AND IN
C     ADDITION, RETURNS THE NUMBER OF NONZERO WEIGHTS AND THE NUMBER
C     OF ZERO WEIGHTS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   MSGTYP,N,NNZW,NNZWMN,NZW
      LOGICAL
     +   ERROR,HEAD
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   WT(*)
      CHARACTER
     +   NMSUB(6)*1,NMVAR1(8)*1,NMVAR2(8)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX ARGUMENT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER MSGTYP
C        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
C        PRINTED, WHERE IF ERROR IS TRUE AND
C        MSGTYP = 1, THE INPUT VALUE WAS TOO SMALL BASED ON LIMITS
C                    IMPOSED BY STARPAC.
C        MSGTYP = 2, THE INPUT VALUE WAS TOO SMALL BASED ON OTHER
C                    INPUT ARGUMENTS.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
C     CHARACTER*1 NMVAR1(8)
C        THE CHARACTERS OF THE NAME OF THE ARGUMENT BEING CHECKED.
C     CHARACTER*1 NMVAR2(8)
C        THE CHARACTERS OF THE NAME OF THE ARGUMENT BEING CHECKED
C        AGAINST.
C     INTEGER NNZW
C        THE NUMBER OF NONZERO WEIGHTS.
C     INTEGER NNZWMN
C        THE MINIMUM NUMBER OF NONZERO WEIGHTS WHICH IS ACCEPTABLE.
C     INTEGER NZW
C        THE NUMBER OF ZERO WEIGHTS.
C     DOUBLE PRECISION WT(N)
C        THE WEIGHT VECTOR.
C
      ERROR = .FALSE.
C
      IF (N.LE.0) RETURN
C
C     CHECK FOR NEGATIVE WEIGHTS AND COUNT NUMBER OF ZERO WEIGHTS.
C
      NZW = 0
      DO 10 I = 1, N
         IF (WT(I) .LT. 0.0D0) GO TO 20
         IF (WT(I) .EQ. 0.0D0) NZW = NZW + 1
   10 CONTINUE
C
      NNZW = N - NZW
      IF (NNZW .GE. NNZWMN) RETURN
C
C     INSUFFICIENT NUMBER OF POSITIVE WEIGHTS FOUND
C
      ERROR = .TRUE.
C
      CALL IPRINT(IPRT)
C
      CALL EHDR(NMSUB, HEAD)
C
      WRITE (IPRT, 1010) NNZW
      IF (MSGTYP.EQ.1) WRITE(IPRT, 1030) (NMVAR1(I), I=1,6), NNZWMN
      IF (MSGTYP.EQ.2) WRITE(IPRT,1040) (NMVAR1(I),I=1,6),
     +   (NMVAR2(I),I=1,8)
C
      RETURN
C
C     NEGATIVE WEIGHTS FOUND
C
   20 ERROR = .TRUE.
C
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
      WRITE(IPRT, 1020) (NMVAR1(I), I = 1, 6)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1010 FORMAT(/
     +   40H THE NUMBER OF NONZERO WEIGHTS FOUND IS , I6, '.')
 1020 FORMAT(/
     +   42H NEGATIVE VALUES WERE FOUND IN THE VECTOR , 6A1, '.'/
     +   51H ALL WEIGHTS MUST BE GREATER THAN OR EQUAL TO ZERO.)
 1030 FORMAT(
     +   34H THE NUMBER OF NONZERO WEIGHTS IN , 6A1,
     +   34H MUST BE GREATER THAN OR EQUAL TO , I6, '.')
 1040 FORMAT(
     +   34H THE NUMBER OF NONZERO WEIGHTS IN , 6A1,
     +   34H MUST BE GREATER THAN OR EQUAL TO , 8A1, '.')
C
      END
*ETAMDL
      SUBROUTINE ETAMDL(MDL, PAR, NPAR, XM, N, M, IXM, ETA, NETA,
     +   PARTMP, PV, NROWIN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO COMPUTE NOISE AND NUMBER OF GOOD DIGITS IN
C     RESULTS OF MODEL ROUTINE AT ROW <NROW>.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ETA
      INTEGER
     +   IXM,M,N,NETA,NPAR,NROWIN
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PARTMP(NPAR),PV(N),XM(IXM,M)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   A,B,FAC,FPLRS,J,RSSSM,RSSSMJ,SQRTMP
      INTEGER
     +   I,K,NROW
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSS(5)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL SETROW
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,LOG10,MAX,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION A, B
C        PARAMETERS OF THE FIT.
C     DOUBLE PRECISION ETA
C        THE NOISE IN THE MODEL RESULTS.
C     DOUBLE PRECISION FAC
C        A FACTOR USED IN THE COMPUTATIONS.
C     DOUBLE PRECISION FPLRS
C        THE FLOATING POINT LARGEST RELATIVE SPACING.
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IXM
C        ACTUAL FIRST DIMENSION OF XM
C     DOUBLE PRECISION J
C        THE VALUE FLOAT(I-3).
C     INTEGER K
C        AN INDEX VARIABLE.
C     INTEGER M
C        NUMBER OF VARIABLES
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        NUMBER OF OBSERVATIONS
C     INTEGER NETA
C        THE NUMBER OF ACCURATE DIGITS IN THE MODEL RESULTS.
C     INTEGER NPAR
C        NUMBER OF PARAMETERS
C     INTEGER NROW
C        THE ROW NUMBER ACTUALLY USED.
C     INTEGER NROWIN
C        THE INPUT NUMBER OF THE ROW BEING CHECKED.
C     DOUBLE PRECISION PAR(NPAR)
C        MODEL PARAMETERS
C     DOUBLE PRECISION PARTMP(NPAR)
C        MODIFIED MODEL PARAMETERS
C     DOUBLE PRECISION PV(N)
C        PREDICTED VALUES
C     DOUBLE PRECISION RSS(5)
C        THE RESIDUAL SUM OF SQUARES FOR EACH VALUE OF J.
C     DOUBLE PRECISION RSSSM
C        THE SUM OF THE RESIDUAL SUM OF SQUARES FOR EACH SET OF
C        PARAMETER VALUES.
C     DOUBLE PRECISION RSSSMJ
C        THE SUM OF THE RESIDUAL SUM OF SQUARES TIMES J FOR EACH
C        SET OF PARAMETER VALUES.
C     DOUBLE PRECISION SQRTMP
C        THE SQUARE ROOT OF MACHINE PRECISION (FPLRS).
C     DOUBLE PRECISION XM(IXM,M)
C        INDEPENDENT VARIABLES
C
      FPLRS = D1MACH(4)
C
C     SELECT FIRST ROW OF INDEPENDENT VARIABLES WHICH CONTAINS NO ZEROS
C
      CALL SETROW(NROWIN, XM, N, M, IXM, NROW)
C
      SQRTMP = SQRT(FPLRS)
      RSSSM = 0.0D0
      RSSSMJ = 0.0D0
      DO 20 I=1,5
         J = I-3
         DO 10 K=1,NPAR
            PARTMP(K) = PAR(K)*(1.0D0+J*SQRTMP)
   10    CONTINUE
         CALL MDL(PARTMP, NPAR, XM, N, M, IXM, PV)
C
         RSS(I) = PV(NROW)
C
         RSSSM = RSSSM + RSS(I)
         RSSSMJ = RSSSMJ + J*RSS(I)
   20 CONTINUE
      A = 0.2D00*RSSSM
      B = 0.1D00*RSSSMJ
      FAC = 1.0D0
      IF (RSS(3).NE.0.0D0) FAC = FAC/RSS(3)
      DO 30 I=1,5
         J = I-3
         RSS(I) = ABS((RSS(I)-(A+J*B))*FAC)
   30 CONTINUE
      ETA = MAX(RSS(1),RSS(2),RSS(3),RSS(4),RSS(5),FPLRS)
      NETA = -LOG10(ETA)
      ETA = 10.0D0**(-NETA)
      RETURN
      END
*EXTEND
      DOUBLE PRECISION FUNCTION EXTEND(X, I, N, SYM)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C      THIS FUNCTION RETURNS THE ITH TERM IN THE SERIES X,
C     EXTENDING IF NECESSARY WITH EVEN OR ODD SYMMETRY ACCORDING
C     TO THE SIGN OF SYM, WHICH SHOULD BE EITHER PLUS OR MINUS ONE.
C     (THE VALUE ZERO WILL RESULT IN THE EXTENDED VALUE BEING ZERO.)
C     THIS ROUTINE IS TAKEN FROM BLOOMFIELDS BOOK, PAGE 179.
C
C     WRITTEN BY  -  PETER BLOOMFIELD
C     CODED BY  -  JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SYM
      INTEGER
     +   I,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CON
      INTEGER
     +   J
C
      J = I
      CON = 1.0D0
   10 IF (J .GE. 1) GO TO 20
      J = 2-J
      CON = CON * SYM
   20 IF (J .LE. N) GO TO 30
      J = 2*N-J
      CON = CON * SYM
      GO TO 10
   30 EXTEND = X(J)*CON
C
      RETURN
C
      END
*FACTOR
      SUBROUTINE FACTOR(N, NPF, IPF, IPFEXP)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE FACTORS AN INPUT INTEGER   N   AND RETURNS
C     THE NUMBER OF PRIME FACTORS IN   NPF   , THE VALUE OF THE
C     PRIME FACTORS IN THE VECTOR   IPF   , AND THE EXPONENT
C     OF EACH OF THE PRIME FACTORS IN THE VECTOR   IPFEXP   .
C     THE ELEMENTS OF    IPF   ARE STORED IN INCREASING ORDER.
C     THE LENGTH OF THE VECTORS IS SUFFICIENT TO ACCOMODATE
C     THE PRIME FACTORS OF AN INTEGER UP TO 2 ** 128 (APPROXIMATELY
C     10 ** 40).
C
C     THIS ROUTINE IS ADAPTED FROM THE FACTORING ROUTINE GIVEN
C     IN ACM ALGORITHM 467 (CACM, 1973, VOL. 16, NO. 11, PAGE 692-694).
C
C     ADAPTED BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 23, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NPF
C
C  ARRAY ARGUMENTS
      INTEGER
     +   IPF(50),IPFEXP(50)
C
C  LOCAL SCALARS
      INTEGER
     +   IDIV,IFCUR,IQUOT,NPART
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IDIV, IFCUR
C        VARIOUS VARIABLES USED TO FACTOR    N   .
C     INTEGER IPF(50), IPFEXP(50)
C        THE VECTORS OF PRIME FACTORS OF   N   , AND THEIR EXPONENTS,
C        RESPECTIVELY.
C     INTEGER IQUOT
C        A VARIABLE USED TO FACTOR   N   .
C     INTEGER N
C        THE VALUE TO BE FACTORED.
C     INTEGER NPART
C        A VARIABLE USED TO FACTOR   N   .
C     INTEGER NPF
C        THE NUMBER OF FACTORS FOUND IN    N   .
C
C  DETERMINE THE FACTORS OF N
C
      NPF = 0
      IFCUR = 0
      NPART = N
      IDIV = 2
   10 IQUOT = NPART/IDIV
      IF (NPART.NE.IDIV*IQUOT) GO TO 40
      IF (IDIV.LE.IFCUR) GO TO 20
      NPF = NPF + 1
      IPF(NPF) = IDIV
      IFCUR = IDIV
      IPFEXP(NPF) = 1
      GO TO 30
   20 IPFEXP(NPF) = IPFEXP(NPF) + 1
   30 NPART = IQUOT
      GO TO 10
   40 IF (IQUOT.LE.IDIV) GO TO 60
      IF (IDIV.GE.3) GO TO 50
      IDIV = 3
      GO TO 10
   50 IDIV = IDIV + 2
      GO TO 10
   60 IF (NPART.LE.1) RETURN
      IF (NPART.LE.IFCUR) GO TO 70
      NPF = NPF + 1
      IPF(NPF) = NPART
      IPFEXP(NPF) = 1
      RETURN
   70 IPFEXP(NPF) = IPFEXP(NPF) + 1
C
      RETURN
      END
*FFT
      SUBROUTINE FFT(A, B, NTOT, N, NSPAN, ISN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C  MULTIVARIATE COMPLEX FOURIER TRANSFORM, COMPUTED IN PLACE
C    USING MIXED-RADIX FAST FOURIER TRANSFORM ALGORITHM.
C  BY R. C. SINGLETON, STANFORD RESEARCH INSTITUTE, OCT. 1968
C  ARRAYS A AND B ORIGINALLY HOLD THE DOUBLE PRECISION AND IMAGINARY
C    COMPONENTS OF THE DATA, AND RETURN THE DOUBLE PRECISION AND
C    IMAGINARY COMPONENTS OF THE RESULTING FOURIER COEFFICIENTS.
C  MULTIVARIATE DATA IS INDEXED ACCORDING TO THE FORTRAN
C    ARRAY ELEMENT SUCCESSOR FUNCTION, WITHOUT LIMIT
C    ON THE NUMBER OF IMPLIED MULTIPLE SUBSCRIPTS.
C    THE SUBROUTINE IS CALLED ONCE FOR EACH VARIATE.
C    THE CALLS FOR A MULTIVARIATE TRANSFORM MAY BE IN ANY ORDER.
C  NTOT IS THE TOTAL NUMBER OF COMPLEX DATA VALUES.
C  N IS THE DIMENSION OF THE CURRENT VARIABLE.
C  NSPAN/N IS THE SPACING OF CONSECUTIVE DATA VALUES
C    WHILE INDEXING THE CURRENT VARIABLE.
C  THE SIGN OF ISN DETERMINES THE SIGN OF THE COMPLEX
C    EXPONENTIAL, AND THE MAGNITUDE OF ISN IS NORMALLY ONE.
C  A TRI-VARIATE TRANSFORM WITH A(N1,N2,N3), B(N1,N2,N3)
C    IS COMPUTED BY
C      CALL FFT(A,B,N1*N2*N3,N1,N1,1)
C      CALL FFT(A,B,N1*N2*N3,N2,N1*N2,1)
C      CALL FFT(A,B,N1*N2*N3,N3,N1*N2*N3,1)
C  FOR A SINGLE-VARIATE TRANSFORM,
C    NTOT = N = NSPAN = (NUMBER OF COMPLEX DATA VALUES), F.G.
C      CALL FFT(A,B,N,N,N,1)
C  THE DATA MAY ALTERNATIVELY BE STORED IN A SINGLE COMPLEX
C    ARRAY A, THEN THE MAGNITUDE OF ISN CHANGED TO TWO TO
C    GIVE THE CORRECT INDEXING INCREMENT AND A(2) USED TO
C    PASS THE INITIAL ADDRESS FOR THE SEQUENCE OF IMAGINARY
C    VALUES, E.G.
C      CALL FFT(A,A(2),NTOT,N,NSPAN,2)
C  ARRAYS AT(MAXF), CK(MAXF), BT(MAXF), SK(MAXF), AND NP(MAXP)
C    ARE USED FOR TEMPORARY STORAGE.  IF THE AVAILABEL STORAGE
C    IS INSUFFICIENT, THE PROGRAM IS TERMINATED BY A STOP.
C    MAXF MUST BE .GE. THE MAXIMUM PRIME FACTOR OF N.
C    MAXP MUST BE .GT. THE NUMBER OF PRIME FACTORS OF N.
C
C     NB. THE ABOVE DESCRIPTION OF MAXP APPEARS TO BE INCORRECT.
C         MAXP SEEMS TO BE THE MAXIMUM SIZE OF THE SQUARE FREE
C         PORTION K OF N.
C
C    IN ADDITION, IF THE SQUARE-FREE PORTION K OF N HAS TWO OR
C    MORE PRIME FACTORS, THEN MAXP MUST BE .GE. K-1.
C     DIMENSION A(1), B(1)
C  ARRAY STORAGE IN NFAC FOR A MAXIMUM OF 11 FACTORS OF N.
C  IF N HAS MORE THAN ONE SQUARE-FREE FACTOR, THE PRODUCT OF THE
C    SQUARE-FREE FACTORS MUST BE .LE. 210
C     DIMENSION NFAC(11), NP(209)
C  ARRAY STORAGE FOR MAXIMUM PRIME FACTOR OF 23
C     DIMENSION AT(23), CK(23), BT(23), SK(23)
C
C
C  VARIABLE DECLARATIONS
C
C  PARAMETERS
      INTEGER
     +   MAXF1
      PARAMETER (MAXF1=23)
      INTEGER
     +   MAXP1
      PARAMETER (MAXP1=209)
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISN,N,NSPAN,NTOT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   A(*),B(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   AA,AJ,AJM,AJP,AK,AKM,AKP,BB,BJ,BJM,BJP,BK,BKM,BKP,C1,C2,C3,
     +   C72,CD,RAD,RADF,S1,S120,S2,S3,S72,SD
      INTEGER
     +   I,II,INC,IPRT,J,JC,JF,JJ,K,K1,K2,K3,K4,KK,KS,KSPAN,KSPNN,
     +   KT,M,MAXF,MAXP,NN,NT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AT(MAXF1),BT(MAXF1),CK(MAXF1),SK(MAXF1)
      INTEGER
     +   NFAC(11),NP(MAXP1)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ATAN,COS,MOD,SIN,SQRT
C
C  EQUIVALENCES
      EQUIVALENCE (I,II)
C
C  THE FOLLOWING TWO CONSTANTS SHOULD AGREE WITH THE ARRAY DIMENSIONS.
      MAXF = MAXF1
      MAXP = MAXP1
      IF (N.LT.2) RETURN
C
C  INITIALIZE VARIABLES
C
      C1 = 0
      C2 = 0
      C3 = 0
      S1 = 0
      S2 = 0
      S3 = 0
      K1 = 0
      K2 = 0
      K3 = 0
      K4 = 0
C
      INC = ISN
      RAD = 8.0D0*ATAN(1.0D0)
      S72 = RAD/5.0D0
      C72 = COS(S72)
      S72 = SIN(S72)
      S120 = SQRT(0.75D0)
      IF (ISN.GE.0) GO TO 10
      S72 = -S72
      S120 = -S120
      RAD = -RAD
      INC = -INC
   10 NT = INC*NTOT
      KS = INC*NSPAN
      KSPAN = KS
      NN = NT - INC
      JC = KS/N
      RADF = RAD*JC*0.5D0
      I = 0
      JF = 0
C  DETERMINE THE FACTORS OF N
      M = 0
      K = N
      GO TO 30
   20 M = M + 1
      NFAC(M) = 4
      K = K/16
   30 IF (K-(K/16)*16.EQ.0) GO TO 20
      J = 3
      JJ = 9
      GO TO 50
   40 M = M + 1
      NFAC(M) = J
      K = K/JJ
   50 IF (MOD(K,JJ).EQ.0) GO TO 40
      J = J + 2
      JJ = J**2
      IF (JJ.LE.K) GO TO 50
      IF (K.GT.4) GO TO 60
      KT = M
      NFAC(M+1) = K
      IF (K.NE.1) M = M + 1
      GO TO 100
   60 IF (K-(K/4)*4.NE.0) GO TO 70
      M = M + 1
      NFAC(M) = 2
      K = K/4
   70 KT = M
      J = 2
   80 IF (MOD(K,J).NE.0) GO TO 90
      M = M + 1
      NFAC(M) = J
      K = K/J
   90 J = ((J+1)/2)*2 + 1
      IF (J.LE.K) GO TO 80
  100 IF (KT.EQ.0) GO TO 120
      J = KT
  110 M = M + 1
      NFAC(M) = NFAC(J)
      J = J - 1
      IF (J.NE.0) GO TO 110
C  COMPUTE FOURIER TRANSFORM
  120 SD = RADF/KSPAN
      CD = 2.0D0*SIN(SD)**2
      SD = SIN(SD+SD)
      KK = 1
      I = I + 1
      IF (NFAC(I).NE.2) GO TO 170
C  TRANSFORM FOR FACTOR OF 2 (INCLUDING ROTATION FACTOR)
      KSPAN = KSPAN/2
      K1 = KSPAN + 2
  130 K2 = KK + KSPAN
      AK = A(K2)
      BK = B(K2)
      A(K2) = A(KK) - AK
      B(K2) = B(KK) - BK
      A(KK) = A(KK) + AK
      B(KK) = B(KK) + BK
      KK = K2 + KSPAN
      IF (KK.LE.NN) GO TO 130
      KK = KK - NN
      IF (KK.LE.JC) GO TO 130
      IF (KK.GT.KSPAN) GO TO 360
  140 C1 = 1.0D0 - CD
      S1 = SD
  150 K2 = KK + KSPAN
      AK = A(KK) - A(K2)
      BK = B(KK) - B(K2)
      A(KK) = A(KK) + A(K2)
      B(KK) = B(KK) + B(K2)
      A(K2) = C1*AK - S1*BK
      B(K2) = S1*AK + C1*BK
      KK = K2 + KSPAN
      IF (KK.LT.NT) GO TO 150
      K2 = KK - NT
      C1 = -C1
      KK = K1 - K2
      IF (KK.GT.K2) GO TO 150
      AK = C1 - (CD*C1+SD*S1)
      S1 = (SD*C1-CD*S1) + S1
C  THE FOLLOWING THREE STATEMENTS COMPENSATE FOR TRUNCATION ERROR
      C1 = 0.5D0/(AK**2+S1**2) + 0.5D0
      S1 = C1*S1
      C1 = C1*AK
      KK = KK + JC
      IF (KK.LT.K2) GO TO 150
      K1 = K1 + INC + INC
      KK = (K1-KSPAN)/2 + JC
      IF (KK.LE.JC+JC) GO TO 140
      GO TO 120
C  TRANSFORM FOR FACTOR OF 3 (OPTIONAL CODE)
  160 K1 = KK + KSPAN
      K2 = K1 + KSPAN
      AK = A(KK)
      BK = B(KK)
      AJ = A(K1) + A(K2)
      BJ = B(K1) + B(K2)
      A(KK) = AK + AJ
      B(KK) = BK + BJ
      AK = -0.5D0*AJ + AK
      BK = -0.5D0*BJ + BK
      AJ = (A(K1)-A(K2))*S120
      BJ = (B(K1)-B(K2))*S120
      A(K1) = AK - BJ
      B(K1) = BK + AJ
      A(K2) = AK + BJ
      B(K2) = BK - AJ
      KK = K2 + KSPAN
      IF (KK.LT.NN) GO TO 160
      KK = KK - NN
      IF (KK.LE.KSPAN) GO TO 160
      GO TO 320
C  TRANSFORM FOR FACTOR OF 4
  170 IF (NFAC(I).NE.4) GO TO 260
      KSPNN = KSPAN
      KSPAN = KSPAN/4
  180 C1 = 1.0D0
      S1 = 0
  190 K1 = KK + KSPAN
      K2 = K1 + KSPAN
      K3 = K2 + KSPAN
      AKP = A(KK) + A(K2)
      AKM = A(KK) - A(K2)
      AJP = A(K1) + A(K3)
      AJM = A(K1) - A(K3)
      A(KK) = AKP + AJP
      AJP = AKP - AJP
      BKP = B(KK) + B(K2)
      BKM = B(KK) - B(K2)
      BJP = B(K1) + B(K3)
      BJM = B(K1) - B(K3)
      B(KK) = BKP + BJP
      BJP = BKP - BJP
      IF (ISN.LT.0) GO TO 220
      AKP = AKM - BJM
      AKM = AKM + BJM
      BKP = BKM + AJM
      BKM = BKM - AJM
      IF (S1.EQ.0.0D0) GO TO 230
  200 A(K1) = AKP*C1 - BKP*S1
      B(K1) = AKP*S1 + BKP*C1
      A(K2) = AJP*C2 - BJP*S2
      B(K2) = AJP*S2 + BJP*C2
      A(K3) = AKM*C3 - BKM*S3
      B(K3) = AKM*S3 + BKM*C3
      KK = K3 + KSPAN
      IF (KK.LE.NT) GO TO 190
  210 C2 = C1 - (CD*C1+SD*S1)
      S1 = (SD*C1-CD*S1) + S1
      C1 = 0.5D0/(C2**2+S1**2) + 0.5D0
      S1 = C1*S1
      C1 = C1*C2
      C2 = C1**2 - S1**2
      S2 = 2.0D0*C1*S1
      C3 = C2*C1 - S2*S1
      S3 = C2*S1 + S2*C1
      KK = KK - NT + JC
      IF (KK.LE.KSPAN) GO TO 190
      KK = KK - KSPAN + INC
      IF (KK.LE.JC) GO TO 180
      IF (KSPAN.EQ.JC) GO TO 360
      GO TO 120
  220 AKP = AKM + BJM
      AKM = AKM - BJM
      BKP = BKM - AJM
      BKM = BKM + AJM
      IF (S1.NE.0.0D0) GO TO 200
  230 A(K1) = AKP
      B(K1) = BKP
      A(K2) = AJP
      B(K2) = BJP
      A(K3) = AKM
      B(K3) = BKM
      KK = K3 + KSPAN
      IF (KK.LE.NT) GO TO 190
      GO TO 210
C  TRANSFORM FOR FACTOR OF 5 (OPTIONAL CODE)
  240 C2 = C72**2 - S72**2
      S2 = 2.0D0*C72*S72
  250 K1 = KK + KSPAN
      K2 = K1 + KSPAN
      K3 = K2 + KSPAN
      K4 = K3 + KSPAN
      AKP = A(K1) + A(K4)
      AKM = A(K1) - A(K4)
      BKP = B(K1) + B(K4)
      BKM = B(K1) - B(K4)
      AJP = A(K2) + A(K3)
      AJM = A(K2) - A(K3)
      BJP = B(K2) + B(K3)
      BJM = B(K2) - B(K3)
      AA = A(KK)
      BB = B(KK)
      A(KK) = AA + AKP + AJP
      B(KK) = BB + BKP + BJP
      AK = AKP*C72 + AJP*C2 + AA
      BK = BKP*C72 + BJP*C2 + BB
      AJ = AKM*S72 + AJM*S2
      BJ = BKM*S72 + BJM*S2
      A(K1) = AK - BJ
      A(K4) = AK + BJ
      B(K1) = BK + AJ
      B(K4) = BK - AJ
      AK = AKP*C2 + AJP*C72 + AA
      BK = BKP*C2 + BJP*C72 + BB
      AJ = AKM*S2 - AJM*S72
      BJ = BKM*S2 - BJM*S72
      A(K2) = AK - BJ
      A(K3) = AK + BJ
      B(K2) = BK + AJ
      B(K3) = BK - AJ
      KK = K4 + KSPAN
      IF (KK.LT.NN) GO TO 250
      KK = KK - NN
      IF (KK.LE.KSPAN) GO TO 250
      GO TO 320
C  TRANSFORM FOR ODD FACTORS
  260 K = NFAC(I)
      KSPNN = KSPAN
      KSPAN = KSPAN/K
      IF (K.EQ.3) GO TO 160
      IF (K.EQ.5) GO TO 240
      IF (K.EQ.JF) GO TO 280
      JF = K
      S1 = RAD/K
      C1 = COS(S1)
      S1 = SIN(S1)
      IF (JF.GT.MAXF) GO TO 590
      CK(JF) = 1.0D0
      SK(JF) = 0.0D0
      J = 1
  270 CK(J) = CK(K)*C1 + SK(K)*S1
      SK(J) = CK(K)*S1 - SK(K)*C1
      K = K - 1
      CK(K) = CK(J)
      SK(K) = -SK(J)
      J = J + 1
      IF (J.LT.K) GO TO 270
  280 K1 = KK
      K2 = KK + KSPNN
      AA = A(KK)
      BB = B(KK)
      AK = AA
      BK = BB
      J = 1
      K1 = K1 + KSPAN
  290 K2 = K2 - KSPAN
      J = J + 1
      AT(J) = A(K1) + A(K2)
      AK = AT(J) + AK
      BT(J) = B(K1) + B(K2)
      BK = BT(J) + BK
      J = J + 1
      AT(J) = A(K1) - A(K2)
      BT(J) = B(K1) - B(K2)
      K1 = K1 + KSPAN
      IF (K1.LT.K2) GO TO 290
      A(KK) = AK
      B(KK) = BK
      K1 = KK
      K2 = KK + KSPNN
      J = 1
  300 K1 = K1 + KSPAN
      K2 = K2 - KSPAN
      JJ = J
      AK = AA
      BK = BB
      AJ = 0.0D0
      BJ = 0.0D0
      K = 1
  310 K = K + 1
      AK = AT(K)*CK(JJ) + AK
      BK = BT(K)*CK(JJ) + BK
      K = K + 1
      AJ = AT(K)*SK(JJ) + AJ
      BJ = BT(K)*SK(JJ) + BJ
      JJ = JJ + J
      IF (JJ.GT.JF) JJ = JJ - JF
      IF (K.LT.JF) GO TO 310
      K = JF - J
      A(K1) = AK - BJ
      B(K1) = BK + AJ
      A(K2) = AK + BJ
      B(K2) = BK - AJ
      J = J + 1
      IF (J.LT.K) GO TO 300
      KK = KK + KSPNN
      IF (KK.LE.NN) GO TO 280
      KK = KK - NN
      IF (KK.LE.KSPAN) GO TO 280
C  MULTIPLY BY ROTATION FACTOR (EXCEPT FOR FACTORS OF 2 AND 4)
  320 IF (I.EQ.M) GO TO 360
      KK = JC + 1
  330 C2 = 1.0D0 - CD
      S1 = SD
  340 C1 = C2
      S2 = S1
      KK = KK + KSPAN
  350 AK = A(KK)
      A(KK) = C2*AK - S2*B(KK)
      B(KK) = S2*AK + C2*B(KK)
      KK = KK + KSPNN
      IF (KK.LE.NT) GO TO 350
      AK = S1*S2
      S2 = S1*C2 + C1*S2
      C2 = C1*C2 - AK
      KK = KK - NT + KSPAN
      IF (KK.LE.KSPNN) GO TO 350
      C2 = C1 - (CD*C1+SD*S1)
      S1 = S1 + (SD*C1-CD*S1)
      C1 = 0.5D0/(C2**2+S1**2) + 0.5D0
      S1 = C1*S1
      C2 = C1*C2
      KK = KK - KSPNN + JC
      IF (KK.LE.KSPAN) GO TO 340
      KK = KK - KSPAN + JC + INC
      IF (KK.LE.JC+JC) GO TO 330
      GO TO 120
C  PERMUTE THE RESULTS TO NORMAL ORDER--- DONE IN TWO STAGES
C  PERMUTATION FOR SQUARE FACTORS OF N
  360 NP(1) = KS
      IF (KT.EQ.0) GO TO 450
      K = KT + KT + 1
      IF (M.LT.K) K = K - 1
      J = 1
      NP(K+1) = JC
  370 NP(J+1) = NP(J)/NFAC(J)
      NP(K) = NP(K+1)*NFAC(J)
      J = J + 1
      K = K - 1
      IF (J.LT.K) GO TO 370
      K3 = NP(K+1)
      KSPAN = NP(2)
      KK = JC + 1
      K2 = KSPAN + 1
      J = 1
      IF (N.NE.NTOT) GO TO 410
C  PERMUTATION FOR SINGLE-VARIATE TRANSFORM (OPTIONAL CODE)
  380 AK = A(KK)
      A(KK) = A(K2)
      A(K2) = AK
      BK = B(KK)
      B(KK) = B(K2)
      B(K2) = BK
      KK = KK + INC
      K2 = KSPAN + K2
      IF (K2.LT.KS) GO TO 380
  390 K2 = K2 - NP(J)
      J = J + 1
      K2 = NP(J+1) + K2
      IF (K2.GT.NP(J)) GO TO 390
      J = 1
  400 IF (KK.LT.K2) GO TO 380
      KK = KK + INC
      K2 = KSPAN + K2
      IF (K2.LT.KS) GO TO 400
      IF (KK.LT.KS) GO TO 390
      JC = K3
      GO TO 450
C  PERMUTATION FOR MULTIVARIATE TRANSFORM
  410 K = KK + JC
  420 AK = A(KK)
      A(KK) = A(K2)
      A(K2) = AK
      BK = B(KK)
      B(KK) = B(K2)
      B(K2) = BK
      KK = KK + INC
      K2 = K2 + INC
      IF (KK.LT.K) GO TO 420
      KK = KK + KS - JC
      K2 = K2 + KS - JC
      IF (KK.LT.NT) GO TO 410
      K2 = K2 - NT + KSPAN
      KK = KK - NT + JC
      IF (K2.LT.KS) GO TO 410
  430 K2 = K2 - NP(J)
      J = J + 1
      K2 = NP(J+1) + K2
      IF (K2.GT.NP(J)) GO TO 430
      J = 1
  440 IF (KK.LT.K2) GO TO 410
      KK = KK + JC
      K2 = KSPAN + K2
      IF (K2.LT.KS) GO TO 440
      IF (KK.LT.KS) GO TO 430
      JC = K3
  450 IF (2*KT+1.GE.M) RETURN
      KSPNN = NP(KT+1)
C  PERMUTATION FOR SQUARE-FREE FACTORS OF N
      J = M - KT
      NFAC(J+1) = 1
  460 NFAC(J) = NFAC(J)*NFAC(J+1)
      J = J - 1
      IF (J.NE.KT) GO TO 460
      KT = KT + 1
      NN = NFAC(KT) - 1
      IF (NN.GT.MAXP) GO TO 590
      JJ = 0
      J = 0
      GO TO 490
  470 JJ = JJ - K2
      K2 = KK
      K = K + 1
      KK = NFAC(K)
  480 JJ = KK + JJ
      IF (JJ.GE.K2) GO TO 470
      NP(J) = JJ
  490 K2 = NFAC(KT)
      K = KT + 1
      KK = NFAC(K)
      J = J + 1
      IF (J.LE.NN) GO TO 480
C  DETERMINE THE PERMUTATION CYCLES OF LENGTH GREATER THAN 1
      J = 0
      GO TO 510
  500 K = KK
      KK = NP(K)
      NP(K) = -KK
      IF (KK.NE.J) GO TO 500
      K3 = KK
  510 J = J + 1
      KK = NP(J)
      IF (KK.LT.0) GO TO 510
      IF (KK.NE.J) GO TO 500
      NP(J) = -J
      IF (J.NE.NN) GO TO 510
      MAXF = INC*MAXF
C  REORDER A AND B, FOLLOWING THE PERMUTATION CYCLES
      GO TO 580
  520 J = J - 1
      IF (NP(J).LT.0) GO TO 520
      JJ = JC
  530 KSPAN = JJ
      IF (JJ.GT.MAXF) KSPAN = MAXF
      JJ = JJ - KSPAN
      K = NP(J)
      KK = JC*K + II + JJ
      K1 = KK + KSPAN
      K2 = 0
  540 K2 = K2 + 1
      AT(K2) = A(K1)
      BT(K2) = B(K1)
      K1 = K1 - INC
      IF (K1.NE.KK) GO TO 540
  550 K1 = KK + KSPAN
      K2 = K1 - JC*(K+NP(K))
      K = -NP(K)
  560 A(K1) = A(K2)
      B(K1) = B(K2)
      K1 = K1 - INC
      K2 = K2 - INC
      IF (K1.NE.KK) GO TO 560
      KK = K2
      IF (K.NE.J) GO TO 550
      K1 = KK + KSPAN
      K2 = 0
  570 K2 = K2 + 1
      A(K1) = AT(K2)
      B(K1) = BT(K2)
      K1 = K1 - INC
      IF (K1.NE.KK) GO TO 570
      IF (JJ.NE.0) GO TO 530
      IF (J.NE.1) GO TO 520
  580 J = K3 + 1
      NT = NT - KSPNN
      II = NT - INC + 1
      IF (NT.GE.0) GO TO 520
      RETURN
C  ERROR FINISH, INSUFFICIENT ARRAY STORAGE
  590 ISN = 0
      CALL IPRINT(IPRT)
      WRITE(IPRT, 1000)
C
C     NB.  THE FOLLOWING STOP SHOULD BE CHANGED TO A RETURN WHEN
C          THE TIME SERIES ROUTINES ARE MODIFIED FOR STARPAC.
C
      STOP
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (' ', 17('*')/18H * ERROR MESSAGE */1X, 17('*')//
     +   45H ARRAY BOUNDS EXCEEDED WITHIN SUBROUTINE FFT./
     +   44H PLEASE BRING THIS ERROR TO THE ATTENTION OF/
     +   22H    JANET R. DONALDSON/
     +   16H    303-497-5114/
     +   16H    FTS 320-5114)
      END
*FFTCT
      SUBROUTINE FFTCT(X, N2, IX)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     COSINE TRANSFORM OF N=2*N2 SYMMETRIC DATA POINTS
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IX,N2
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(IX)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   A2,AA,AB,CD,CN,EX,PI,SAVE,SD,SN
      INTEGER
     +   I,ISN,J,K,M,M1,N1,NK
C
C  EXTERNAL SUBROUTINES
      EXTERNAL FFT,GETPI,REALTR
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AA, AB, A2
C     DOUBLE PRECISION CD, CN
C     DOUBLE PRECISION EX
C     INTEGER I, ISN
C     INTEGER IX
C        THE DIMENSION OF X.
C     INTEGER J
C     INTEGER K
C     INTEGER M, M1
C     INTEGER NK, N1
C     INTEGER N2
C        THE HALF LENGTH OF THE SYMMETRIC DATA ARRAY.  N2 MUST BE EVEN.
C     DOUBLE PRECISION PI
C        THE VALUE OF PI.
C     DOUBLE PRECISION SAVE, SD, SN
C     DOUBLE PRECISION X(IX)
C        THE N2+2 VECTOR WITH FIRST HALF OF SYMMETRIC DATA STORED IN
C        THE FIRST N2+1 LOCATIONS.  LOCATION N2+2 USED ONLY FOR
C        WORKSPACE.  THE COSINE TRANSFORM COEFFICIENTS ARE RETURNED
C        IN THE FIRST N2+1 LOCATIONS OF X.
C
      CALL GETPI(PI)
C
      A2 = 0.0D0
      N1 = N2 + 1
      DO 10 J=2,N2,2
         A2 = A2 + X(J)
   10 CONTINUE
      A2 = 2.0D0*A2
      M = N2/2
      M1 = M + 1
      EX = X(2)
      X(2) = 0.0D0
      IF (N1.LT.4) GO TO 30
      DO 20 I=4,N1,2
         SAVE = EX - X(I)
         EX = X(I)
         X(I) = SAVE
   20 CONTINUE
   30 X(N2+2) = 0.0D0
      ISN = -2
      CALL REALTR(X, X(2), M, ISN)
      CALL FFT(X, X(2), M, M, M, ISN)
      SD = PI / (2*N2)
      CD = 2.0D0*SIN(SD)**2
      SD = SIN(SD+SD)
      SN = 0.0D0
      CN = 1.0D0
      NK = N2 + 2
      DO 40 J=2,M1
         K = NK - J
         AA = X(J) + X(K)
         AB = (X(J)-X(K))*0.5D0
         EX = CN - (CD*CN+SD*SN)
         SN = (SD*CN-CD*SN) + SN
         CN = 0.5D0/(EX*EX+SN*SN) + 0.5D0
         SN = CN*SN
         CN = CN*EX
         EX = AB/SN
         X(J) = (AA+EX)*0.5D0
         X(K) = (AA-EX)*0.5D0
   40 CONTINUE
      EX = X(1)
      X(1) = EX + A2
      X(N2+1) = EX - A2
      X(N2+2) = 0.0D0
      RETURN
      END
*FFTLEN
      SUBROUTINE FFTLEN(N, NDIV, NFFT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE SMALLEST VALUE OF NFFT WHICH
C     EQUALS OR EXCEEDS N + 2, SUCH THAT NFFT - 2 IS DIVISIBLE BY
C     NDIV AND HAS NO PRIME FACTORS GREATER THAN 23, AND THE
C     PRODUCT OF THE NON SQUARE PRIME FACTORS OF NFFT - 2 DO NOT
C     EXCEED 209.  THE VALUE OF NFFT THUS MEET THE REQUIREMENTS OF
C     THE EXTENDED LENGTH OF THE SERIES REQUIRED FOR ANY ROUTINE
C     USING THE SINGLETON FFT PROVIDING THE PROPER VALUE OF NDIV
C     IS CHOSEN.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NDIV,NFFT
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,ERR02,HEAD
C
C  LOCAL ARRAYS
      CHARACTER
     +   LN(8)*1,LNDIV(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,IPRINT,SETESL
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01, ERR02
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     CHARACTER*1 LN(8), LNDIV(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
C        CHECKED FOR ERRORS.
C     INTEGER N
C        THE NUMBER UPON WHICH NFFT IS BASED.
C     INTEGER NDIV
C        A REQUIRED FACTOR OF NFFT - 2.
C     INTEGER NFFT
C        THE RETURNED VALUE WHICH MEETS THE ABOVE DESCRIPTION.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'F',       'F',       'T',       'L',       'E',       'N'/
      DATA
     +     LN(1),     LN(2),     LN(3),     LN(4),     LN(5),     LN(6)
     + /     'N',       ' ',       ' ',       ' ',       ' ',       ' '/
      DATA
     +     LN(7),     LN(8)
     + /     ' ',       ' '/
      DATA
     +  LNDIV(1),  LNDIV(2),  LNDIV(3),  LNDIV(4),  LNDIV(5),  LNDIV(6)
     + /     'N',       'D',       'I',       'V',       ' ',       ' '/
      DATA
     +  LNDIV(7),  LNDIV(8)
     + /     ' ',       ' '/
C
C     ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
      CALL EISGE(NMSUB, LN, N, 1, 1, HEAD, ERR01, LN)
C
      CALL EISGE(NMSUB, LNDIV, NDIV, 1, 1, HEAD, ERR02, LNDIV)
C
C
      IF ((.NOT. ERR01) .AND. (.NOT. ERR02)) GO TO 10
C
C     PRINT PROPER CALL SEQUENCE
C
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
C
      RETURN
C
   10 CONTINUE
C
      CALL SETESL(N, NDIV, NFFT)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   34H       CALL FFTLEN (N, NDIV, NFFT))
C
      END
*FFTR
      SUBROUTINE FFTR (YFFT, N, NFFT, IEXTND, NF, AB, LAB)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
C     THE FOURIER TRANSFORM OF A SERIES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IEXTND,LAB,N,NF,NFFT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AB(*),YFFT(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   YEXTND
      INTEGER
     +   I,IPRT,ISN,N1,NFFT1,NFFT2
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD
C
C  LOCAL ARRAYS
      CHARACTER
     +   LLAB(8)*1,LN(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN,EISGE,ENFFT,FFT,IPRINT,REALTR
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AB(LAB)
C        THE VECTOR OF THE NF REAL AND IMAGINARY COMPONENTS OF THE
C        FOURIER COEFFICIENTS.
C     LOGICAL ERR01, ERR02, ERR03
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
C        ERROR MESSAGES (TRUE) OR NOT (FALSE).
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IEXTND
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
C        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
C        USED TO EXTEND THE SERIES.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER LAB
C        THE LENGTH OF THE VECTOR AB.
C     CHARACTER*1 LLAB(8), LN(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
C        FOR ERRORS.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS.
C     INTEGER N1
C        THE VALUE N+1.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODGRAM IS
C        TO BE COMPUTED.
C     INTEGER NFFT
C        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
C     INTEGER NFFT1
C        THE EFFECTIVE SERIES LENGTH ACTUALLY USED.
C     INTEGER NFFT2
C        THE EFFECTIVE LENGTH OF THE SERIES STORED AS A COMPLEX
C        VARIABLE.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     DOUBLE PRECISION YEXTND
C        THE VALUE USED TO EXTEND THE SERIES.
C     DOUBLE PRECISION YFFT(N)
C        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'F',       'F',       'T',       'R',       ' ',       ' '/
      DATA
     +   LLAB(1),   LLAB(2),   LLAB(3),   LLAB(4),   LLAB(5),   LLAB(6)
     + /     'L',       'A',       'B',       ' ',       ' ',       ' '/
      DATA
     +   LLAB(7),   LLAB(8)
     + /     ' ',       ' '/
      DATA
     +     LN(1),     LN(2),     LN(3),     LN(4),     LN(5),     LN(6)
     + /     'N',       ' ',       ' ',       ' ',       ' ',       ' '/
      DATA
     +     LN(7),     LN(8)
     + /     ' ',       ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
      IF (ERR01) GO TO 5
C
      CALL ENFFT(NMSUB, NFFT, 2, N, LAB, NFFT1, HEAD, ERR02, LN)
      NF = NFFT1/2
C
      CALL EISGE(NMSUB, LLAB, LAB, NFFT1, 9, HEAD, ERR03, LLAB)
C
      IF (ERR02 .OR. ERR03) GO TO 5
      GO TO 10
C
    5 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   10 CONTINUE
C
C     COPY THE INPUT SERIES TO AB, EXTENDING APPROPRIATELY.
C
      YEXTND = 0.0D0
      IF (IEXTND .NE. 0) CALL AMEAN (YFFT, N, YEXTND)
C
      DO 20 I = 1, N
         AB(I) = YFFT(I)
   20 CONTINUE
C
      N1 = N+1
      DO 30 I = N1, NFFT1
         AB(I) = YEXTND
   30 CONTINUE
C
      NFFT2 = (NFFT1-2) / 2
      ISN = 2
C
      CALL FFT (AB(1), AB(2), NFFT2, NFFT2, NFFT2, ISN)
      CALL REALTR (AB(1), AB(2), NFFT2, ISN)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   53H       CALL FFTR (YFFT, N, NFFT, IEXTND, NF, AB, LAB))
      END
*FITEXT
      SUBROUTINE FITEXT(RSS, YSS, EXACT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS WHETHER THE FIT IS EXACT TO MACHINE
C     PRECISION.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSS,YSS
      LOGICAL
     +   EXACT
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLRS,RSSTST
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL EXACT
C        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
C        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION FPLRS
C        THE FLOATING POINT LARGEST RELATIVE SPACING.
C     DOUBLE PRECISION RSS
C        THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION RSSTST
C        THE VALUE FOR TESTING WHETHER THE RESIDUAL SUM OF SQUARES
C        IS ZERO (TO WITHIN MACHINE PRECISION).
C     DOUBLE PRECISION YSS
C        THE SUM OF SQUARES OF THE DEPENDENT VARIABLE Y.
C
      FPLRS = D1MACH(4)
C
C     TEST FOR EXACT FIT
C
      EXACT = .FALSE.
      RSSTST = RSS
      IF (YSS.GT.0.0D0) RSSTST = RSSTST / YSS
      RSSTST = SQRT(RSSTST)
      IF (RSSTST.LT.10.0D0*FPLRS) EXACT = .TRUE.
C
      RETURN
C
      END
*FITPT1
      SUBROUTINE FITPT1(N, M, XM, Y, PV, SDPV, RES, SDRES, WT, IXM,
     +   NNZW, WEIGHT, IPTOUT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBOUTINE PRINTS THE DATA SUMMARY FOR THE NONLINEAR
C     LEAST SQUARES SUBROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IPTOUT,IXM,M,N,NNZW
      LOGICAL
     +   WEIGHT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PV(N),RES(N),SDPV(N),SDRES(N),WT(N),XM(IXM,M),Y(N)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,IPRT,JCOL1,JCOLM,K,NMAX
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,OBSSUM
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS HAVE
C        BEEN DETECTED.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED.
C     INTEGER IPTOUT
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER JCOLM
C        THE LAST COLUMN OF THE INDEPENDENT VARIABLE TO BE PRINTED.
C     INTEGER JCOL1
C        THE FIRST COLUMN OF THE INDEPENDENT VARIABLE TO BE PRINTED.
C     INTEGER K
C        AN INDEX VARIABLE.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NMAX
C        THE MAXIMUM NUMBER OF ROWS TO BE PRINTED.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION SDPV(N)
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(N)
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(N)
C        THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
      FPLM = D1MACH(2)
C
      CALL IPRINT(IPRT)
C
      WRITE (IPRT,1100)
C
      IF (WEIGHT) THEN
         WRITE (IPRT,1010)
      ELSE
         WRITE (IPRT,1000)
      END IF
      WRITE (IPRT, 1110)
C
C     TEST WHETHER COLUMN VECTOR XM(*, 1) = VECTOR 1.0D0
C
      DO 10 I=1,N
         IF (XM(I,1).NE.1.0D0) GO TO 20
   10 CONTINUE
      GO TO 30
C
C     NOT A UNIT VECTOR
C
   20 JCOL1 = 1
      JCOLM = MIN(M,3)
      GO TO 40
C
C     UNIT VECTOR
C
   30 JCOLM = MIN(M,4)
      JCOL1 = MIN(2,JCOLM)
   40 K = JCOLM - JCOL1 + 1
C
      NMAX = N
      IF ((IPTOUT.EQ.1) .AND. (N.GE.45)) NMAX = MIN(N,40)
C
C     PRINT OBSERVATION SUMMARY
C
      CALL OBSSUM(N, M, XM, Y, PV, SDPV, RES, SDRES, WT, IXM,
     +   WEIGHT, K, 1, NMAX, JCOL1, JCOLM)
C
      IF (NMAX.GE.N) GO TO 200
C
      DO 195 I = 1, 3
C
         GO TO (160, 170, 180), K
  160    WRITE (IPRT,1120)
         GO TO 190
  170    WRITE (IPRT,1130)
         GO TO 190
  180    WRITE (IPRT,1140)
C
  190    CONTINUE
         WRITE (IPRT, 1150)
         IF (WEIGHT) WRITE (IPRT, 1160)
C
  195 CONTINUE
C
C     PRINT LAST LINE OF OUTPUT
C
      CALL OBSSUM(N, M, XM, Y, PV, SDPV, RES, SDRES, WT, IXM,
     +   WEIGHT, K, N, N, JCOL1, JCOLM)
C
  200 CONTINUE
C
      IF ((NNZW.LT.N) .AND. (IERR.EQ.0)) WRITE (IPRT, 1060)
      IF ((NNZW.LT.N) .AND. (IERR.EQ.4)) WRITE (IPRT, 1070)
      IF ((NNZW.EQ.N) .AND. (IERR.EQ.4)) WRITE (IPRT, 1080)
      IF ((IERR.GT.0) .AND. (IERR.NE.4)) WRITE (IPRT, 1090)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/53X, 9HDEPENDENT, 7X, 9HPREDICTED, 5X, 12H STD DEV OF ,
     +   24X, 4HSTD /
     +   2X, 3HROW, 13X, 16HPREDICTOR VALUES, 20X, 8HVARIABLE, 8X,
     +   6H VALUE, 8X, 12HPRED VALUE  , 6X, 9HRESIDUAL , 8X, 3HRES)
 1010 FORMAT (/53X, 9HDEPENDENT, 7X, 9HPREDICTED, 5X, 12H STD DEV OF ,
     +   24X, 4HSTD /
     +   2X, 3HROW, 13X, 16HPREDICTOR VALUES, 20X, 8HVARIABLE, 8X,
     +   6H VALUE, 8X, 12HPRED VALUE  , 6X, 9HRESIDUAL , 8X, 3HRES,
     +   4X, 6HWEIGHT)
 1060 FORMAT (// 37H *  NC  -  VALUE NOT COMPUTED BECAUSE,
     +   20H THE WEIGHT IS ZERO.)
 1070 FORMAT (// 44H *  NC  -  VALUE NOT COMPUTED BECAUSE EITHER,
     +   53H THE WEIGHT OR THE STANDARD DEVIATION OF THE RESIDUAL,
     +   9H IS ZERO.)
 1080 FORMAT (// 37H *  NC  -  VALUE NOT COMPUTED BECAUSE,
     +   48H THE STANDARD DEVIATION OF THE RESIDUAL IS ZERO.)
 1090 FORMAT (// 29H *  NC  -  VALUE NOT COMPUTED,
     +   54H BECAUSE CONVERGENCE PROBLEMS PREVENTED THE COVARIANCE,
     +   28H MATRIX FROM BEING COMPUTED.)
 1100 FORMAT (//31H RESULTS FROM LEAST SQUARES FIT/ 1X, 31('-'))
 1110 FORMAT (' ')
 1120 FORMAT (4X, '.', 25X, '.')
 1130 FORMAT (4X, '.', 3X, 2(14X, '.'))
 1140 FORMAT (4X, '.', 10X, '.', 2(14X, '.'))
 1150 FORMAT ('+', 49X, 11X, '.', 3(15X, '.'), 11X, '.')
 1160 FORMAT ('+', 130X, '.')
      END
*FITPT2
      SUBROUTINE FITPT2 (SDRES, PV, WT, N, NNZW, WEIGHT, RES, RSS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE, ADAPTED FROM OMNITAB II, PRINTS
C     THE FOUR STANDARDIZED RESIDUAL PLOTS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSS
      INTEGER
     +   N,NNZW
      LOGICAL
     +   WEIGHT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PV(N),RES(N),SDRES(N),WT(N)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ANNZW,DOT,FAC1,FAC2,FPLM,GAMMA,PI,PVDIV,PVMAX,PVMID,PVMIN,
     +   RATIO,ROWDIV,ROWMAX,ROWMID,ROWMIN,W,XDIV,XMAX,XMIN,YLABEL,
     +   YMAX,YMIN
      INTEGER
     +   I,I1,I2,IDOT,IFIRST,IMID,IPLOT,IPRB,IPRT,IPV,IROW,IX,K,L,
     +   NCOL,NCOLP1,NCOLPL,NCOLT2,NDOT,NROW
      CHARACTER
     +   IBLANK*1,IMINUS*1,IPLUS*1,ISTAR*1
C
C  LOCAL ARRAYS
      CHARACTER
     +   LINE(102)*1
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      LOGICAL
     +   MVCHK
      EXTERNAL D1MACH,MVCHK
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GETPI,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC INT,MAX,MIN,MOD
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ANNZW
C        THE NUMBER OF NONZERO WEIGHTS, USED IN COMPUTING
C        THE NORMAL PROBABILITY PLOT.
C     DOUBLE PRECISION DOT
C        ...
C     DOUBLE PRECISION FAC1, FAC2
C        FACTORS USED IN COMPUTING THE NORMAL PROBABILITY PLOT.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     DOUBLE PRECISION GAMMA
C        A VALUE USED IN COMPUTING THE NORMAL PROBABILITY PLOT.
C     INTEGER I
C        AN INDEX VARIABLE.
C     CHARACTER*1 IBLANK
C        THE VALUE OF THE CHARACTER -BLANK-.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS HAVE
C        BEEN DETECTED.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED.
C     INTEGER IFIRST
C        THE FIRST ROW OF THE VARIABLES TO BE PLOTTED.
C     INTEGER IMID
C        THE MIDPOINT OF THE FIRST PLOT OF THE SECOND SET
C     CHARACTER*1 IMINUS
C        THE CHARACTER MINUS.
C     INTEGER IPLOT
C        AN INDICATOR VARIABLE DESIGNATING WHETHER THE FIRST OR
C        SECOND SET OF TWO PLOTS ARE BEING PRINTED.
C     CHARACTER*1 IPLUS
C        THE CHARACTER PLUS.
C     INTEGER IPRB
C        THE LOCATION IN THE PLOT STRING OF THE SYMBOL FOR THE
C        PROBABILITY PLOT.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IPV
C        THE LOCATION IN THE PLOT STRING OF THE SYMBOL FOR THE PLOT
C        VERSUS PREDICTED VALUE.
C     INTEGER IROW
C        THE ROW OF THE VARIABLES BEING PLOTTED.
C     CHARACTER*1 ISTAR
C        THE CHARACTER STAR.
C     INTEGER IX
C        THE LOCATION IN THE PLOT STRING OF THE SYMBOL FOR THE PLOTS
C        VERSUS THE INDEPENDENT VARIABLE.
C     INTEGER I1, I2
C        ...
C     INTEGER K, L
C        INDEX VARIABLES.
C     CHARACTER*1 LINE(102)
C        THE SYMBOLS (BLANKS AND CHARACTERS) FOR A GIVEN LINE
C        OF THE PLOT.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN EACH COLUMN OF DATA.
C     INTEGER NCOL, NCOLPL, NCOLP1, NCOLT2
C        THE NUMBER OF COLUMNS IN THE PLOT, NCOL+L, NCOL+1,
C        AND NCOL * 2.
C     INTEGER NDOT
C        ...
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NROW
C        THE NUMBER OF COLUMNS IN THE PLOT.
C     DOUBLE PRECISION PI
C        THE VALUE OF PI.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT COEFFICIENT ESTIMATES
C     DOUBLE PRECISION PVDIV
C        THE VALUE OF A DIVISION ALONG THE -PREDICTED VALUE- AXIS.
C     DOUBLE PRECISION PVMAX
C        THE LARGEST VALUE IN THE VECTOR PV.
C     DOUBLE PRECISION PVMID
C        THE MIDPOINT OF THE RANGE OF VALUES IN THE VECTOR PV.
C     DOUBLE PRECISION PVMIN
C        THE SMALLEST VALUE IN THE VECTOR PV.
C     DOUBLE PRECISION RATIO
C        A VALUE USED TO PRODUCE THE NORMAL PROBABILITY PLOT.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION ROWDIV
C        THE VALUE OF A DIVISION ALONG THE -ROW- AXIS.
C     DOUBLE PRECISION ROWMAX
C        THE LARGEST ROW VALUE.
C     DOUBLE PRECISION ROWMID
C        THE MIDPOINT OF THE RANGE OF THE ROWS PLOTTED.
C     DOUBLE PRECISION ROWMIN
C        THE SMALLEST ROW VALUE PLOTTED.
C     DOUBLE PRECISION RSS
C        THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION SDRES(N)
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION W
C        THE VALUE OF THE WEIGHT FOR THE CURRENT VALUE BEING PLOTTED.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(N)
C        THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION XDIV
C        THE VALUE OF A DIVISION ALONG THE X AXIS.
C     DOUBLE PRECISION XMAX
C        THE LARGEST VALUE ALONG THE X AXIS.
C     DOUBLE PRECISION XMIN
C        THE SMALLEST VALUE ALONG THE X AXIS.
C     DOUBLE PRECISION YLABEL
C        THE LABEL TO BE PRINTED ALONG THE Y AXIS.
C     DOUBLE PRECISION YMAX
C        THE LARGEST VALUE ALONG THE Y AXIS
C     DOUBLE PRECISION YMIN
C        THE SMALLEST VALUE ALONG THE Y AXIS.
C
      DATA IPLUS/'+'/, IMINUS/'-'/, ISTAR/'*'/, IBLANK/' '/
C
      CALL IPRINT(IPRT)
C
      FPLM = D1MACH(2)
C
C     CHECK FOR INSUFFICIENT POINTS TO PLOT
C
      IF (IERR.EQ.4) THEN
         DO 1 I = 1, N
            IF (SDRES(I).NE.FPLM) GO TO 5
    1    CONTINUE
         WRITE (IPRT, 1090)
         RETURN
      END IF
    5 CONTINUE
C
C     INITIALIZE VARIABLES FOR PROBABILITY PLOT
C
      CALL GETPI(PI)
      GAMMA = PI/8.0D0
      ANNZW = NNZW
      FAC1 = 1.0D0 / (ANNZW - 2.0D0*GAMMA + 1.0D0)
      FAC2 = 10.0D0
C
C     INITIALIZE THE PLOT SIZE (IN PLOT UNITS)
C
      NROW = 26
      NCOL = 51
      NCOLP1 = NCOL + 1
      NCOLT2 = 2*NCOL
      IMID = (NCOL-1)/2
C
C     FIND THE FIRST ROW OF OBSERVATIONS WITH NONZERO WEIGHTS
C
      IFIRST = 1
      IF (.NOT. WEIGHT) GO TO 20
      DO 10 I=1,N
         IF (WT(I).LE.0.0D0) GO TO 10
         IFIRST = I
         GO TO 20
   10 CONTINUE
C
C     BEGIN COMPUTATIONS FOR FIRST SET OF PLOTS
C
   20 IPLOT = 1
C
C     SET X AXIS LIMITS FOR STANDARDIZED RESIDUAL VS ROW PLOT,
C     AND STANDARDIZED RESIDUALS VS PREDICTED VALUES PLOT.
C
      ROWMIN = IFIRST
      PVMIN = PV(IFIRST)
      PVMAX = PV(IFIRST)
      ROWMAX = IFIRST
      DO 30 I=IFIRST,N
         W = 1.0D0
         IF (WEIGHT) W = WT(I)
         IF (W.GT.0.0D0) THEN
            ROWMAX = I
            IF (PV(I).LT.PVMIN) PVMIN = PV(I)
            IF (PV(I).GT.PVMAX) PVMAX = PV(I)
         END IF
   30 CONTINUE
C
      IF (PVMIN.LT.PVMAX) GO TO 35
         IF (PVMIN.EQ.0.0D0) GO TO 33
            PVMIN = PVMIN - PVMIN/2.0D0
            PVMAX = PVMAX + PVMAX/2.0D0
         GO TO 35
   33    CONTINUE
            PVMIN = -0.5D0
            PVMAX = 0.5D0
   35 CONTINUE
C
      ROWMID = (ROWMAX+ROWMIN)/2.0D0
      ROWDIV = (ROWMAX-ROWMIN)/(NCOL-1)
      PVMID = (PVMAX+PVMIN)/2.0D0
      PVDIV = (PVMAX-PVMIN)/(NCOL-1)
C
C     PRINT TITLES FOR FIRST PLOTS
C
      WRITE (IPRT,1000)
      GO TO 90
C
C     BEGIN COMPUTATIONS FOR SECOND SET OF PLOTS
C
   40 IPLOT = 2
C
C     SET AXIS LIMITS FOR THE STANDARDIZED RESIDUALS VS
C     STANDARDIZED RESIDUALS LAGED BY ONE AND FOR PROBABILITY PLOT
C
      XMIN = -3.75D0
      XMAX = 3.75D0
      XDIV = (XMAX-XMIN)/(NCOL-1)
C
C     PRINT TITLES FOR SECOND PLOTS
C
      WRITE (IPRT,1050)
C
C     WRITE FIRST LINE OF PLOTS
C
   90 CONTINUE
C
C     PRINT PLOTS, ONE LINE AT A TIME
C
      YLABEL = 3.75D0
      YMAX = FPLM
      YMIN = 4.05D0
      DO 160 K=1,NROW
         YMIN = YMIN - 0.3D0
         IF (-3.70D0.GE.YMIN) YMIN = -FPLM
         DO 100 L=1,NCOL
            NCOLPL = L + NCOL
            LINE(L) = IBLANK
            LINE(NCOLPL) = IBLANK
            IF ((K.NE.1) .AND. (K.NE.NROW)) GO TO 100
               LINE(L) = IMINUS
               LINE(NCOLPL) = IMINUS
               IF ((MOD(L,10).NE.1) .AND. (L.NE.1+NCOL/2)) GO TO 100
                  LINE(L) = IPLUS
                  LINE(NCOLPL) = IPLUS
  100    CONTINUE
         DO 110 I=1,N
            IF (WEIGHT) THEN
               W = WT(I)
            ELSE
               W = 1.0D0
            END IF
            IF ((W.NE.0.0D0) .AND. (.NOT.MVCHK(SDRES(I),FPLM))) THEN
               IF ((SDRES(I).GT.YMIN) .AND. (SDRES(I).LE.YMAX)) THEN
                  IF (IPLOT.EQ.1) THEN
C
C     SET PLOT LINE FOR FIRST SET OF PLOTS
C
                     IROW = INT(((I-ROWMIN)/ROWDIV)+1.5D0)
                     LINE(IROW) = ISTAR
                     IPV = INT((PV(I)-PVMIN)/PVDIV+1.5D0) + NCOL
                     LINE(IPV) = ISTAR
                  ELSE
C
C     SET PLOT LINE FOR PROBABILITY PLOT
C
                     RATIO = (ANNZW-GAMMA) * FAC1
                     IPRB = INT(4.91D0*(RATIO**0.14D0-
     +                         (1.0D0-RATIO)**0.14D0)*FAC2) + 77
                     IF (IPRB.LE.NCOL) IPRB = NCOL+1
                     IF (IPRB.GE.103) IPRB = 102
                     LINE(IPRB) = ISTAR
                     ANNZW = ANNZW - 1.0D0
                     IF ((ANNZW.LT.2.0D0) .AND. (NNZW.LE.10)) THEN
                        GAMMA = 1.0D0/3.0D0
                     END IF
                  END IF
               END IF
            END IF
  110    CONTINUE
C
C     SET PLOT LINE FOR CORRELATION PLOT
C
         IF (IPLOT.EQ.2) THEN
            IF (K.LE.N-1) THEN
              DOT = 0.0D0
              IF (WEIGHT) THEN
                NDOT = 0
                DO 120 IDOT = 1, N-K
                  IF ((WT(IDOT).GT.0.0D0) .AND.
     +                (WT(IDOT+K).GT.0.0D0)) THEN
                    NDOT = NDOT + 1
                    DOT = DOT + RES(IDOT)*RES(IDOT+K)
                  END IF
  120           CONTINUE
                IF (NDOT.GE.1) THEN
                   DOT = DOT * (N-K) / NDOT
                END IF
              ELSE
                DO 130 IDOT = 1, N-K
                  DOT = DOT + RES(IDOT)*RES(IDOT+K)
  130           CONTINUE
              END IF
              IX = INT(IMID*DOT/RSS) + IMID + 1
              I1 = MIN(IX,IMID+1)
              I2 = MAX(IX,IMID+1)
              DO 140 IX=I1,I2
                LINE(IX) = ISTAR
  140         CONTINUE
            END IF
         END IF
         IF (MOD(K,5).EQ.1) THEN
            IF (IPLOT.EQ.1) THEN
               WRITE (IPRT,2020) YLABEL, (LINE(L),L=1,NCOL), YLABEL,
     +         (LINE(L),L=NCOLP1,NCOLT2)
            ELSE
               WRITE (IPRT,1020) K, (LINE(L),L=1,NCOL), YLABEL,
     +         (LINE(L),L=NCOLP1,NCOLT2)
            END IF
            YLABEL = YLABEL - 1.5
         ELSE
            WRITE (IPRT,1030) (LINE(L),L=1,102)
         END IF
         YMAX = YMIN
  160 CONTINUE
C
C     PRINT BOTTOM LINE OF GRAPHS
C
      IF (IPLOT.EQ.1) THEN
C
C     PRINT X AXIS LABELS FOR FIRST SET OF PLOTS
C
         WRITE (IPRT,1040) ROWMIN, ROWMID, ROWMAX, PVMIN, PVMID, PVMAX
         GO TO 40
      ELSE
C
C     PRINT X AXIS LABELS FOR SECOND SET OF PLOTS
C
         WRITE (IPRT,1070)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/20X, 23H STD RES VS ROW NUMBER , 35X,
     +   29H STD RES VS PREDICTED VALUES )
C1010 FORMAT (7X, 2('+', 9A1), '+', 4A1, 'X', 4A1, 2('+', 9A1), '+',
C    *   10X, 2('+', 9A1), '+', 4A1, 'X', 4A1, 2('+', 9A1), '+')
 1020 FORMAT (1X, I5, '+', 51A1, '+', 3X, F5.2, '+', 51A1, '+')
 1030 FORMAT (6X, '-', 51A1, '-', 8X, '-', 51A1, '-')
 1040 FORMAT (1X, F8.1, 17X, F8.1, 17X, F8.1, 4X, G11.4, 14X, G11.4,
     +   10X, G11.4)
 1050 FORMAT (/13X, 'AUTOCORRELATION FUNCTION OF RESIDUALS',
     +   23X, 36H NORMAL PROBABILITY PLOT OF STD RES )
C1060 FORMAT ('+', F5.2, '+', 51A1, '+', 3X, F5.2, '+', 51A1, '+')
 1070 FORMAT (4X, 5H-1.00, 22X, 3H0.0, 21X, 4H1.00, 5X, 4H-2.5, 23X,
     +   3H0.0, 22X, 3H2.5)
C1080 FORMAT ('+', 6X, 2('+', 9A1), '+', 4A1, 'X', 4A1, 2('+', 9A1),
C    *   '+', 10X, 2('+', 9A1), '+', 4A1, 'X', 4A1, 2('+', 9A1), '+')
 1090 FORMAT (// 1X, 13('*')/ 1X, 13H*  WARNING  */ 1X, 13('*')//
     +   54H THE STANDARDIZED RESIDUAL PLOTS HAVE BEEN SUPPRESSED.,
     +   45H  NONE OF THE STANDARDIZED RESIDUALS COULD BE,
     +   10H COMPUTED,/
     +   50H BECAUSE FOR EACH OBSERVATION EITHER THE WEIGHT OR,
     +   48H THE STANDARD DEVIATION OF THE RESIDUAL IS ZERO.)
 2020 FORMAT (1X, F5.2, '+', 51A1, '+', 3X, F5.2, '+', 51A1, '+')
      END
*FITSXP
      SUBROUTINE FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV,
     +    RSD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     GENERATES REPORTS FOR LEAST SQUARES EXERCISER RETURNED STORAGE
C
C     WRITTEN BY  -  LINDA L. MITCHELL
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PV(N),RES(N),SDPV(N),SDRES(N),VCV(IVCV,NPAR)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LSTVEC,MATPRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        INDEX VARIABLE
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT
C     INTEGER IVCV
C        ACTUAL FIRST DIMENSION OF VCV
C     INTEGER N
C        NUMBER OF OBSERVATIONS
C     INTEGER NPAR
C        NUMBER OF PARAMETERS
C     DOUBLE PRECISION PAR(NPAR)
C        THE ESTIMATED PARAMETERS.
C     DOUBLE PRECISION PV(N)
C        PREDICTED VALUES
C     DOUBLE PRECISION RES(N)
C        RESIDUALS
C     DOUBLE PRECISION RSD
C        RESIDUAL STANDARD DEVIATION
C     DOUBLE PRECISION SDPV(N)
C        STANDARD DEVIATION OF PREDICTED VALUES
C     DOUBLE PRECISION SDRES(N)
C        STANDARD DEVIATION OF RESIDUALS
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        VARIANCE COVARANCE MATRIX
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      WRITE (IPRT,1002)
      CALL LSTVEC(NPAR, PAR)
      WRITE (IPRT,1001)
      DO 10 I=1,N
         WRITE (IPRT,1010) PV(I), SDPV(I), RES(I), SDRES(I)
   10 CONTINUE
      WRITE (IPRT,1020)
      CALL MATPRT(VCV, VCV, NPAR, IPRT, 1, 1, IVCV)
      WRITE (IPRT,1030) RSD
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(//40H RETURNED RESULTS FROM LEAST SQUARES FIT/ 1X, 39('-'))
 1001 FORMAT (//7X, 2HPV, 13X, 4HSDPV, 12X, 3HRES,12X, 5HSDRES)
 1002 FORMAT (//20H PARAMETERS FROM FIT)
 1010 FORMAT (1X, G14.7, 2X, G14.7, 2X, G14.7, 2X, G14.7)
 1020 FORMAT (//27H VARIANCE COVARIANCE MATRIX)
 1030 FORMAT (//6H RSD =, G14.7)
      END
*FITXSP
      SUBROUTINE FITXSP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV,
     +   NNZW, NPARE, RSD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     GENERATES REPORTS FOR LEAST SQUARES EXERCISER RETURNED STORAGE
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,N,NNZW,NPAR,NPARE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PV(N),RES(N),SDPV(N),SDRES(N),VCV(IVCV,NPAR)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,MATPRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        INDEX VARIABLE
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT
C     INTEGER IVCV
C        ACTUAL FIRST DIMENSION OF VCV
C     INTEGER N
C        NUMBER OF OBSERVATIONS
C     INTEGER NPAR
C        NUMBER OF PARAMETERS
C     INTEGER NPARE
C        NUMBER OF PARAMETERS ESTIMATED BY ROUTINE.
C     INTEGER NNZW
C        NUMBER OF NONZERO WEIGHTS.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ESTIMATED PARAMETERS.
C     DOUBLE PRECISION PV(N)
C        PREDICTED VALUES
C     DOUBLE PRECISION RES(N)
C        RESIDUALS
C     DOUBLE PRECISION RSD
C        RESIDUAL STANDARD DEVIATION
C     DOUBLE PRECISION SDPV(N)
C        STANDARD DEVIATION OF PREDICTED VALUES
C     DOUBLE PRECISION SDRES(N)
C        STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        VARIANCE COVARANCE MATRIX
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      DO 10 I=1,N
         IF (I.LE.NPAR) THEN
            WRITE (IPRT,1010) I,PAR(I),RES(I),PV(I),SDPV(I),SDRES(I)
         ELSE
            WRITE (IPRT,1070) I,RES(I),PV(I),SDPV(I),SDRES(I)
         END IF
   10 CONTINUE
      WRITE (IPRT,1030)
      CALL MATPRT(VCV, VCV, IVCV, IPRT, 1, 1, IVCV)
      WRITE (IPRT,1060) RSD
      WRITE (IPRT,1040) NNZW
      WRITE (IPRT,1050) NPARE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/12X, 3HPAR, 12X, 3HRES, 12X, 2HPV, 13X, 4HSDPV, 12X,
     +   5HSDRES/)
 1010 FORMAT (1X, I5, G14.7, 2X, 4(G14.7, 2X))
 1030 FORMAT (/27H VARIANCE COVARIANCE MATRIX)
 1040 FORMAT (8H NNZW = , I5)
 1050 FORMAT (9H NPARE = , I5)
 1060 FORMAT (/7H RSD = , G14.7)
 1070 FORMAT (1X, I5, 16X, 4(G14.7, 2X))
      END
*FIXPRT
      SUBROUTINE FIXPRT(IFIX, FIXED)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SETS THE CHARACTER ARRAY FIXED.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IFIX
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   FIXED(3)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C  LOCAL ARRAYS
      CHARACTER
     +   NO(3)*1,YES(3)*1
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     CHARACTER*1 FIXED(3)
C        THE CHARACTERS USED TO LABEL THE PARAMETERS FIXED OR NOT.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IFIX
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIX.EQ.0, THEN FIXED WILL BE SET TO NO.
C        IF IFIX.NE.0, THEN FIXED WILL BE SET TO YES.
C     CHARACTER*1 NO(3)
C        THE CHARACTERS BLANK, N, AND O
C     CHARACTER*1 YES(3)
C        THE CHARACTERS Y, E, AND S
C
      DATA NO(1)/' '/, NO(2)/'N'/, NO(3)/'O'/
      DATA YES(1)/'Y'/, YES(2)/'E'/, YES(3)/'S'/
C
      IF (IFIX.NE.0) THEN
C
C     SET FIXED TO YES
C
         DO 10 I = 1, 3
            FIXED(I) = YES(I)
   10    CONTINUE
C
      ELSE
C
C     SET FIXED TO NO
C
         DO 20 I = 1, 3
            FIXED(I) = NO(I)
   20    CONTINUE
      END IF
C
      RETURN
C
      END
*FLTAR
      SUBROUTINE FLTAR (Y, N, IAR, PHI, YF, NYF)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE FILTERS THE INPUT SERIES Y USING THE IAR TERMS
C     OF THE AUTOREGRESSIVE FILTER PHI, COPYING THE FILTERED SERIES
C     INTO YF.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DEVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IAR,N,NYF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PHI(*),Y(*),YF(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   TEMP
      INTEGER
     +   I,I1,J,K
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IAR
C        THE NUMBER OF FILTER TERMS.
C     INTEGER I1, J, K
C        INDEXING VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     INTEGER NYF
C        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
C     DOUBLE PRECISION PHI(IAR)
C        THE ARRAY IN WHICH THE FILTER COEFFICIENTS ARE STORED.
C     DOUBLE PRECISION TEMP
C        A TEMPORARY STORAGE LOCATION.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YF(N)
C        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
C
      DO 10 I = 1, N
         YF(I) = Y(I)
   10 CONTINUE
C
      NYF = N - IAR
C
      DO 30 I = 1, NYF
         K = I + IAR
         TEMP = YF(K)
         DO 20 J = 1, IAR
            K = K - 1
            TEMP = TEMP - PHI(J) * YF(K)
   20    CONTINUE
         YF(I) = TEMP
   30 CONTINUE
C
      I1 = NYF + 1
C
      DO 40 I = I1, N
         YF(I) = 0.0D0
   40 CONTINUE
      RETURN
      END
*FLTARM
      SUBROUTINE FLTARM (Y, YMISS, N, IAR, PHI, YF, YFMISS, NYF)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE FILTERS THE INPUT SERIES Y, WHICH CONTAINS MISSING
C     DATA, USING THE IAR TERMS OF THE AUTOREGRESSIVE FILTER PHI,
C     COPYING THE FILTERED SERIES INTO YF.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DEVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YFMISS,YMISS
      INTEGER
     +   IAR,N,NYF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PHI(*),Y(*),YF(*)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM,TEMP
      INTEGER
     +   I,I1,J,K
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      LOGICAL
     +   MVCHK
      EXTERNAL D1MACH,MVCHK
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IAR
C        THE NUMBER OF FILTER TERMS.
C     INTEGER I1, J, K
C        INDEXING VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     INTEGER NYF
C        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
C     DOUBLE PRECISION PHI(IAR)
C        THE ARRAY IN WHICH THE FILTER COEFFICIENTS ARE STORED.
C     DOUBLE PRECISION TEMP
C        A TEMPORARY STORAGE LOCATION.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YF(N)
C        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
C     DOUBLE PRECISION YFMISS
C        THE MISSING VALUE CODE USED IN THE FILTERED SERIES TO
C        INDICATE THE VALUE COULD NOT BE COMPUTED DUE TO MISSING DATA.
C     DOUBLE PRECISION YMISS
C        THE MISSING VALUE CODE USED IN THE INPUT SERIES TO INDICATE
C        AN OBSERVATION IS MISSING.
C
      FPLM = D1MACH(2)
C
      YFMISS = FPLM
C
      DO 10 I = 1, N
         YF(I) = Y(I)
   10 CONTINUE
C
      NYF = N - IAR
C
      DO 50 I = 1, NYF
         TEMP = YFMISS
         K = I + IAR
         IF (MVCHK(YF(K), YMISS)) GO TO 40
         TEMP = YF(K)
         DO 30 J = 1, IAR
            K = K - 1
            IF (.NOT. MVCHK(YF(K), YMISS)) GO TO 20
            TEMP = YFMISS
            GO TO 40
   20       CONTINUE
            TEMP = TEMP - PHI(J) * YF(K)
   30    CONTINUE
   40    YF(I) = TEMP
   50 CONTINUE
C
      I1 = NYF + 1
C
      DO 60 I = I1, N
         YF(I) = 0.0D0
   60 CONTINUE
      RETURN
      END
*FLTMA
      SUBROUTINE FLTMA (Y, N, K, HMA, YF, NYF)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE FILTERS THE INPUT SERIES Y USING THE K TERMS
C     OF H, COPYING THE FILTERED SERIES INTO YF.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DEVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   HMA
      INTEGER
     +   K,N,NYF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(N),YF(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   SUM
      INTEGER
     +   I,I1,II,J
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION HMA
C        THE VALUE OF EACH OF THE SIMPLE MOVING AVERAGE LINEAR FILTER
C        COEFFICIENTS.
C     INTEGER I, II, I1, J
C        INDEXING VARIABLES.
C     INTEGER K
C        THE NUMBER OF FILTER TERMS.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     INTEGER NYF
C        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
C     DOUBLE PRECISION SUM
C        A TEMPORARY LOCATION USED IN COMPUTING THE FILTERED SERIES.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YF(N)
C        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
C
      DO 10 I = 1, N
         YF(I) = Y(I)
   10 CONTINUE
C
      NYF = N - (K - 1)
C
      DO 30 I = 1, NYF
         II = I - 1
         SUM = 0.0D0
         DO 20 J = 1, K
            II = II + 1
            SUM = SUM + HMA*YF(II)
   20    CONTINUE
         YF(I) = SUM
   30 CONTINUE
C
      I1 = NYF + 1
C
      DO 40 I = I1, N
         YF(I) = 0.0D0
   40 CONTINUE
C
      RETURN
      END
*FLTMD
      SUBROUTINE FLTMD (X, Y, N, KMD, SYM)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE APPLIES ONE MODIFIED DANIEL FILTERS TO A SYMMETRIC
C     SERIES.  THIS ROUTINE IS ADAPTED FROM BLOOMFIELDS ROUTINE MODDAN.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SYM
      INTEGER
     +   KMD,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N),Y(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CON
      INTEGER
     +   I,J,KUSED,LIM
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   EXTEND
      EXTERNAL EXTEND
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MOD
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CON
C        A FACTOR USED IN THE COMPUTATIONS.
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER J
C        AN INDEXING VARIABLE.
C     INTEGER KMD
C        THE INPUT FILTER LENGTH.
C     INTEGER KUSED
C        THE FILTER LENGTH ACTUALLY USED.
C     INTEGER LIM
C        A LOOP LIMIT.
C     INTEGER N
C        THE NUMBER OF POINTS IN THE SERIES TO BE FILTERED.
C     DOUBLE PRECISION SYM
C        AN INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE SERIES
C        IS SYMMETRIC (SYM = 1.0D0) OR NOT (SYM = -1.0D0).
C     DOUBLE PRECISION X(N)
C        ON INPUT, THE SERIES TO BE FILTERED.  ON OUTPUT, THE
C        SMOOTHED SERIES.
C     DOUBLE PRECISION Y(N)
C        ON INPUT, A WORK VECTOR.  ON OUTPUT, THE INPUT SERIES X.
C
C
      DO 10 I = 1, N
         Y(I) = X(I)
   10 CONTINUE
C
      IF (KMD .LE. 0) RETURN
C
      KUSED = KMD + MOD(KMD,2)
      IF (KUSED .GT. N) KUSED = KUSED - 2
C
      LIM = KUSED-1
      CON = 1.0D0 / (2*KUSED)
      DO 40 I = 1, N
         X(I) = Y(I)
         IF (LIM .EQ. 0) GO TO 30
         DO 20 J = 1, LIM
            X(I) = X(I) + EXTEND(Y, I-J, N, SYM)
     +         + EXTEND(Y, I+J, N, SYM)
   20    CONTINUE
   30    X(I) = (X(I) + (EXTEND(Y, I-KUSED, N, SYM)
     +      + EXTEND(Y, I+KUSED, N, SYM)) * 0.5D0) * CON
   40 CONTINUE
C
      RETURN
C
      END
*FLTSL
      SUBROUTINE FLTSL (Y, N, K, H, YF, NYF)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE FILTERS THE INPUT SERIES Y USING THE K TERMS
C     OF H, COPYING THE FILTERED SERIES INTO YF.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DEVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   K,N,NYF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   H(K),Y(N),YF(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   TEMP
      INTEGER
     +   I,I1,IHM,IHP,IKMID,IM,IP,J,KHALF,KMID
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION H(K)
C        THE ARRAY IN WHICH THE FILTER COEFFICIENTS ARE STORED.
C     INTEGER I, IHM, IHP, IKMID, IM, IP
C        INDEXING VARIABLES.
C     INTEGER J
C        AN INDEXING VARIABLE.
C     INTEGER K
C        THE NUMBER OF FILTER TERMS.
C     INTEGER KHALF, KMID
C        THE HALF LENGTH OF THE FILTER AND THE MIDPOINT OF THE FILTER.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     INTEGER NYF
C        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
C     DOUBLE PRECISION TEMP
C        A TEMPORY STORAGE LOCATION.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YF(N)
C        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
C
      DO 10 I = 1, N
         YF(I) = Y(I)
   10 CONTINUE
C
      NYF = N - (K - 1)
C
      KHALF = (K - 1) / 2
C
      KMID = KHALF + 1
C
      DO 30 I = 1, NYF
         IKMID = I + KHALF
         TEMP = H(KMID) * YF(IKMID)
         DO 20 J = 1, KHALF
            IP = IKMID + J
            IHP = KMID + J
            IM = IKMID - J
            IHM = KMID - J
            TEMP = TEMP + H(IHP)*YF(IP) + H(IHM)*YF(IM)
   20    CONTINUE
         YF(I) = TEMP
   30 CONTINUE
C
      I1 = NYF + 1
C
      DO 40 I = I1, N
         YF(I) = 0.0D0
   40 CONTINUE
      RETURN
      END
*GENI
      SUBROUTINE GENI(IVECT, N, IINIT, ISTP)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     PUT VALUES IINIT STEP ISTP THROUGH IINIT + (N - 1)*ISTP INTO
C     A VECTOR IVECT OF LENGTH N.  NO ERROR CHECKING IS DONE.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING LAB/BOULDER
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IINIT,ISTP,N
C
C  ARRAY ARGUMENTS
      INTEGER
     +   IVECT(N)
C
C  LOCAL SCALARS
      INTEGER
     +   I,J
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        INITIALIZATION VALUE.
C     INTEGER IINIT, ISTP
C        INPUT PARAMETERS.  THE INITIAL VALUE AND THE INCREMENT USED
C        IN CREATING THE INITIALIZATION VALUES.
C     INTEGER IVECT(N)
C        OUTPUT PARAMETER.  THE VECTOR INTO WHICH TO PUT THE VALUES
C        IINIT, IINIT + ISTP, ..., IINIT + (N - 1)*ISTP.
C     INTEGER J
C        LOOP PARAMETER.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF IVECT.
C
      I = IINIT
      DO 10 J=1,N
         IVECT(J) = I
         I = I + ISTP
   10 CONTINUE
      RETURN
      END
*GENR
      SUBROUTINE GENR(RVECT, N, RINIT, RSTP)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     PUT VALUES RINIT STEP RSTP THROUGH RINIT + (N - 1)*RSTP INTO
C     A VECTOR RVECT OF LENGTH N.  NO ERROR CHECKING IS DONE.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING LAB/BOULDER
C                  NATIONAL BUREAU OF STANDARDS
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RINIT,RSTP
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RVECT(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   R
      INTEGER
     +   J
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER J
C        LOOP PARAMETER.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF RVECT.
C     DOUBLE PRECISION R
C        INITIALIZATION VALUE.
C     DOUBLE PRECISION RINIT, RSTP
C        INPUT PARAMETERS.  THE INITIAL VALUE AND THE INCREMENT USED
C        IN CREATING THE INITIALIZATION VALUES.
C     DOUBLE PRECISION RVECT(N)
C        OUTPUT PARAMETER.  THE VECTOR INTO WHICH TO PUT THE VALUES
C        RINIT, RINIT + RSTP, ..., RINIT + (N - 1)*RSTP.
C
      R = RINIT
      DO 10 J=1,N
         RVECT(J) = R
         R = R + RSTP
   10 CONTINUE
      RETURN
      END
*GETPI
      SUBROUTINE GETPI(PI)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SETS THE VALUE OF PI.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   PI
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION PI
C        THE VALUE OF PI.
C
      PI = 3.141592653589793238462643383279D0
      RETURN
      END
*GFAEST
      SUBROUTINE GFAEST (PHI, IAR, NF, FREQ, GAIN, PHAS, DELTA)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE GAIN FUNCTION OF AN AUTOREGRESSIVE
C     LINEAR FILTER USING THE ALGORITHM GIVEN ON PAGES 419 AND 420
C     JENKINS AND WATTS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA
      INTEGER
     +   IAR,NF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),GAIN(NF),PHAS(NF),PHI(IAR)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ARG,C,PI,S,V0,V1,V2,Z0,Z1,Z2
      INTEGER
     +   I,J,JJ
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ATAN2,COS,SIN,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ARG
C        A VALUE USED TO COMPUTE THE GAIN FUNCTION ESTIMATES.
C     DOUBLE PRECISION C
C        A VALUE USED TO COMPUTE THE GAIN FUNCTION ESTIMATES.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL OF THE ORIGINAL SERIES.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO
C        BE ESTIMATED.
C     DOUBLE PRECISION GAIN(NF)
C        THE ARRAY IN WHICH THE GAIN FUNCTION ESTIMATES ARE RETURNED.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IAR
C        THE NUMBER OF FILTER COEFFICIENTS.
C     INTEGER J, JJ
C        INDEX VARIABLES.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES FOR WHICH THE GAIN FUNCTION ESTIMATES
C        ARE TO BE COMPUTED.
C     DOUBLE PRECISION PHAS(NF)
C        THE ARRAY IN WHICH THE PHASE OF THE FILTER IS RETURNED.
C     DOUBLE PRECISION PHI(IAR)
C        THE VECTOR CONTAINING THE AUTOREGRESSIVE FILTER COEFFICIENTS.
C     DOUBLE PRECISION PI
C        THE VALUE OF PI.
C     DOUBLE PRECISION S
C        A VALUE USED TO COMPUTE THE GAIN FUNCTION ESTIMATES.
C     DOUBLE PRECISION V0, V1, V2
C        CONSTANTS USED FOR COMPUTING THE GAIN FUNCTION ESTIMATES.
C     DOUBLE PRECISION Z0, Z1, Z2
C        CONSTANTS USED FOR COMPUTING THE GAIN FUNCTION ESTIMATES.
C
      CALL GETPI(PI)
C
C     COMPUTE GAIN FUNCTION ESTIMATES AND THEIR CONFIDENCE LIMITS.
C
      DO 30 I = 1, NF
         IF (FREQ(I).EQ.0.0D0) THEN
            ARG = 0.0D0
            C = 1.0D0
            S = 0.0D0
         ELSE IF (FREQ(I).EQ.0.25D0) THEN
            ARG = PI/2.0D0
            C = 0.0D0
            S = 1.0D0
         ELSE IF (FREQ(I).EQ.0.5D0) THEN
            ARG = PI
            C = -1.0D0
            S = 0.0D0
         ELSE
            ARG = 2.0D0 * PI * FREQ(I)
            C = COS(ARG)
            S = SIN(ARG)
         END IF
         V0 = 0.0D0
         V1 = 0.0D0
         Z0 = 0.0D0
         Z1 = 0.0D0
C
         JJ = IAR + 1
C
         DO 20 J = 1, IAR
            JJ = JJ -1
C
            V2 = C * V1 - V0 - PHI(JJ)
            V0 = V1
            V1 = V2
C
            Z2 = S * Z1 - Z0 - PHI(JJ)
            Z0 = Z1
            Z1 = Z2
   20    CONTINUE
C
         V2 = DELTA * (1.0D0 + (V1 * C - V0))
C
         Z2 = DELTA * Z1 * S
C
         GAIN(I) = SQRT(V2*V2 + Z2*Z2)
C
         PHAS(I) = -0.5D0 * PI
         IF (Z2.NE.0.0D0 .AND. V2.NE.0.0D0) PHAS(I) = ATAN2(Z2, V2)
C
   30 CONTINUE
C
      RETURN
      END
*GFARF
      SUBROUTINE GFARF (PHI, IAR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE TO COMPUTE THE GAIN
C     FUNCTION OF AN AUTOREGRESSIVE FILTER (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PHI(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,FMAX,FMIN,YPLTMN,YPLTMX
      INTEGER
     +   IGFERR,IPRT,NF,NORD,NPRT
      LOGICAL
     +   ERR01,HEAD,SYM
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FREQ(101),GAIN(101),PHAS(101),XORD(101),YORD(101)
      INTEGER
     +   ISORT(101)
      CHARACTER
     +   LIAR(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,GFAEST,GFORD,GFOUT,IPRINT,SETFRQ
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     LOGICAL ERR01
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION FMAX, FMIN
C        THE MINIMUM AND MAXIMUM FREQUENCY FOR WHICH THE GAIN
C        FUNCTION IS TO BE ESTIMATED.
C     DOUBLE PRECISION FREQ(101)
C        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION
C        HAS BEEN ESTIMATED.
C     DOUBLE PRECISION GAIN(101)
C        THE VECTOR IN WHICH THE GAIN FUNCTION ESTIMATES ARE
C        STORED.
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IAR
C        THE NUMBER OF FILTER COEFFICIENTS.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IGFERR
C        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
C        TO HAVE PRODUCED REASONABLE RESULTS.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     INTEGER ISORT(101)
C        AN ARRAY USED FOR SORTING.
C     CHARACTER*1 LIAR(8)
C        THE ARRAY CONTAINING THE NAME OF THE VARIABLE IAR.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE GAIN FUNCTION
C        IS TO BE ESTIMATED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NORD
C        THE NUMBER OF VALUES TO BE PLOTTED.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     DOUBLE PRECISION PHAS(101)
C        THE ARRAY IN WHICH THE PHASE OF THE FILTER IS RETURNED.
C     DOUBLE PRECISION PHI(IAR)
C        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
C     LOGICAL SYM
C        THE VARIABLE USED TO INDICATE WHETHER THE GAIN FUNCTION
C        COMPUTED WAS FOR A SYMMETRIC OR AUTOREGRESSIVE FILTER.
C     DOUBLE PRECISION XORD(101)
C        THE X COORDINATES FOR THE GAIN FUNCTION PLOT
C     DOUBLE PRECISION YORD(101)
C        THE Y COORDINATES FOR THE GAIN FUNCTION PLOT
C     DOUBLE PRECISION YPLTMN, YPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'G',       'F',       'A',       'R',       'F',       ' '/
      DATA
     +  LIAR(1), LIAR(2), LIAR(3), LIAR(4), LIAR(5), LIAR(6), LIAR(7),
     +  LIAR(8)
     + /  'I',   'A',   'R',   ' ',   ' ',   ' ',   ' ',   ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LIAR, IAR, 1, 1, HEAD, ERR01, LIAR)
C
      IF (.NOT. ERR01) GO TO 10
C
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   10 CONTINUE
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      SYM = .FALSE.
C
      NF = 101
C
      FMIN = 0.0D0
      FMAX = 0.5D0
C
      DELTA = 1.0D0
C
      NPRT = -1
C
C     SET FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO BE ESTIMATED
C
      CALL SETFRQ (FREQ, NF, NPRT, FMIN, FMAX, DELTA)
C
C     COMPUTE THE GAIN FUNCTION
C
      CALL GFAEST (PHI, IAR, NF, FREQ, GAIN, PHAS, DELTA)
C
C     SET THE COORDINATES FOR THE PLOT.
C
      CALL GFORD (FREQ, GAIN, ISORT, NF, XORD, YORD, NORD,
     +   YPLTMN, YPLTMX, NPRT, IGFERR)
C
C     PLOT THE RESULTS.
C
      CALL GFOUT (XORD, YORD, NORD, FREQ, PHAS, NF, IAR, SYM, FMIN,
     +   FMAX, YPLTMN, YPLTMX, NPRT, IGFERR, NMSUB)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   28H       CALL GFARF (PHI, IAR))
      END
*GFARFS
      SUBROUTINE GFARFS (PHI, IAR, NF, FMIN, FMAX, GAIN, PHAS, FREQ,
     +   NPRT, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE TO COMPUTE THE GAIN
C     FUNCTION OF AN AUTOREGRESSIVE FILTER (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   IAR,LDSTAK,NF,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),GAIN(*),PHAS(*),PHI(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,FMN,FMX,YPLTMN,YPLTMX
      INTEGER
     +   IGFERR,IO,IPRT,ISORT,LDSMIN,NALL0,NORD,XORD,YORD
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD,SYM
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   LIAR(8)*1,LLDS(8)*1,LNF(8)*1,NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,GFAEST,GFORD,GFOUT,IPRINT,LDSCMP,SETFRQ,STKCLR,
     +   STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL ERR01, ERR02, ERR03
C        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION FMAX, FMIN
C        THE MINIMUM AND MAXIMUM FREQUENCY FOR WHICH THE GAIN
C        FUNCTION IS TO BE ESTIMATED.
C     DOUBLE PRECISION FMN, FMX
C        THE FREQUENCY RANGE ACTUALLY USED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION
C        HAS BEEN ESTIMATED.
C     DOUBLE PRECISION GAIN(NF)
C        THE VECTOR IN WHICH THE GAIN FUNCTION ESTIMATES ARE
C        STORED.
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IAR
C        THE NUMBER OF FILTER COEFFICIENTS.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IGFERR
C        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
C        TO HAVE PRODUCED REASONABLE RESULTS.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
C        BASED ON PRINTED OUTPUT.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     INTEGER ISORT
C        THE STARTING LOCATION IN ISTAK FOR
C        THE ARRAY USED FOR SORTING.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     CHARACTER*1 LIAR(8), LLDS(8), LNF(8)
C        THE ARRAYS CONTAINING THE NAMES OF CHECKED VARIABLES
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE GAIN FUNCTION
C        IS TO BE ESTIMATED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NORD
C        THE NUMBER OF POINTS TO BE PLOTTED.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     DOUBLE PRECISION PHAS(NF)
C        THE ARRAY IN WHICH THE PHASE OF THE FILTER IS RETURNED.
C     DOUBLE PRECISION PHI(IAR)
C        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL SYM
C        THE VARIABLE USED TO INDICATE WHETHER THE GAIN FUNCTION
C        COMPUTED WAS FOR A SYMMETRIC OR AUTOREGRESSIVE FILTER.
C     INTEGER XORD
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE X COORDINATES FOR THE GAIN FUNCTION PLOT
C     INTEGER YORD
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE Y COORDINATES FOR THE GAIN FUNCTION PLOT
C     DOUBLE PRECISION YPLTMN, YPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'G',       'F',       'A',       'R',       'F',       'S'/
      DATA
     +  LIAR(1), LIAR(2), LIAR(3), LIAR(4), LIAR(5), LIAR(6),
     +  LIAR(7), LIAR(8) /'I', 'A', 'R', ' ', ' ', ' ', ' ', ' '/
      DATA
     +  LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6), LLDS(7),
     +  LLDS(8) /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
      DATA
     +  LNF(1), LNF(2), LNF(3), LNF(4), LNF(5), LNF(6), LNF(7), LNF(8)
     + /  'N',   'F',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
      IO = 1
      IF (NPRT .EQ. 0) IO = 0
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LIAR, IAR, 1, 1, HEAD, ERR01, LIAR)
C
      CALL EISGE(NMSUB, LNF, NF, 1, 1, HEAD, ERR02, LNF)
C
      IF (ERR02) GO TO 10
C
      CALL LDSCMP(3*IO, 0, NF, 0, 0, 0, 'D', 2*IO*NF, LDSMIN)
C
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR03, LLDS)
C
      IF (ERR01.OR.ERR02.OR.ERR03) GO TO 10
      GO TO 20
C
   10   IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
        RETURN
C
   20 CONTINUE
C
      IF (NPRT .NE. 0) THEN
        CALL STKSET (LDSTAK, 4)
        NALL0 = STKST(1)
      ELSE
        NALL0 = 0
      END IF
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      SYM = .FALSE.
C
      DELTA = 1.0D0
C
C     SET FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO BE ESTIMATED
C
      FMN = MAX(FMIN, 0.0D0)
      FMX = MIN(FMAX, 0.5D0)
      IF (FMN.GE.FMX) THEN
        FMN = 0.0D0
        FMX = 0.5D0
      END IF
      CALL SETFRQ (FREQ, NF, 2, FMN, FMX, DELTA)
C
C     COMPUTE THE GAIN FUNCTION
C
      CALL GFAEST (PHI, IAR, NF, FREQ, GAIN, PHAS, DELTA)
C
      IF (NPRT .EQ. 0) RETURN
C
C     SET VARIOUS POINTERS FOR THE PLOTTING ARRAYS
C
      XORD = STKGET(NF, 4)
      YORD = STKGET(NF, 4)
C
      ISORT = STKGET(NF, 2)
C
      IF (IERR .EQ. 1) GO TO 10
C
C     PLOT THE RESULTS
C
      CALL GFORD (FREQ, GAIN, ISTAK(ISORT), NF, RSTAK(XORD),
     +   RSTAK(YORD), NORD, YPLTMN, YPLTMX, NPRT, IGFERR)
      CALL GFOUT (RSTAK(XORD), RSTAK(YORD), NORD, FREQ, PHAS, NF,
     +   IAR, SYM, FMN, FMX, YPLTMN, YPLTMX, NPRT, IGFERR, NMSUB)
C
      CALL STKCLR(NALL0)
C
      IF (IERR .EQ. 1) GO TO 10
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL GFARFS (PHI, IAR,'/
     + '      +             NF, FMIN, FMAX, GAIN, PHAS, FREQ, NPRT,',
     + ' LDSTAK)')
      END
*GFORD
      SUBROUTINE GFORD (FREQ, GAIN, ISORT, NF, XORD, YORD,
     +   NORD, YPLTMN, YPLTMX, NPRT, IGFERR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRODUCES ORDANENTS FOR THE GAIN FUNCTION PLOTS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YPLTMN,YPLTMX
      INTEGER
     +   IGFERR,NF,NORD,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),GAIN(NF),XORD(NF),YORD(NF)
      INTEGER
     +   ISORT(NF)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   GAINMN,GAINMX,YMAX
      INTEGER
     +   I,J
C
C  EXTERNAL SUBROUTINES
      EXTERNAL SPCCK
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG10
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        ESTIMATED.
C     DOUBLE PRECISION GAIN(NF)
C        THE VECTOR IN WHICH THE GAIN FUNCTION IS STORED.
C     DOUBLE PRECISION GAINMN, GAINMX
C        THE MINIMUM AND MAXIMUM GAIN FUNCTION VALUE TO BE PLOTTED.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER IGFERR
C        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
C        TO HAVE PRODUCED REASONABLE RESULTS.
C     INTEGER ISORT(NF)
C        THE ARRAY USED FOR SORTING.
C     INTEGER J
C        AN INDEXING VARIABLE.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
C        ARE TO BE ESTIMATED.
C     INTEGER NORD
C        THE NUMBER OF ORDINATES TO BE PLOTTED.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     DOUBLE PRECISION XORD(NF)
C        THE X ORDINATES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YMAX
C        THE MAXIMUM ACTUAL SPECTRUM VALUE (IN DECIBELS) TO BE PLOTTED.
C     DOUBLE PRECISION YORD(NF)
C        THE Y ORDINATES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YPLTMN, YPLTMX
C        THE MINIMUM AND MAXIMUM VAUES TO BE PLOTTED FOR THE Y AXIS.
C
      IGFERR = 0
C
      CALL SPCCK (GAIN, ISORT, NF, GAINMN, GAINMX, NORD, IGFERR)
C
      IF (IGFERR .NE. 0) RETURN
C
      J = 0
C
      IF (NPRT.GE.1) GO TO 30
C
C     SET ORDINATES FOR DECIBLE PLOTS
C
      YMAX = 10.0D0 * LOG10(GAINMX)
C
      YPLTMX = 0.0D0
      YPLTMN = 10.0D0 * LOG10(GAINMN) - YMAX
C
      DO 10 I = 1, NF
         IF (GAIN(I) .LT. GAINMN) GO TO 10
         J = J + 1
         XORD(J) = FREQ(I)
         YORD(J) = 10.0D0 * LOG10(GAIN(I)) - YMAX
   10 CONTINUE
C
      RETURN
C
   30 CONTINUE
C
      YPLTMX = GAINMX
      YPLTMN = GAINMN
C
C     SET ORDINATES FOR LOG PLOTS
C
      DO 50 I = 1, NF
         IF (GAIN(I) .LT. GAINMN) GO TO 50
         J = J + 1
         XORD(J) = FREQ(I)
         YORD(J) = GAIN(I)
   50 CONTINUE
C
      RETURN
      END
*GFOUT
      SUBROUTINE GFOUT (XORD, YORD, NORD, FREQ, PHAS, NF,
     +   NTERM, SYM, XPLTMN, XPLTMX, YPLTMN, YPLTMX, NPRT, IGFERR,
     +   NMSUB)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRODUCES THE GAIN FUNCTION PLOTS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XPLTMN,XPLTMX,YPLTMN,YPLTMX
      INTEGER
     +   IGFERR,NF,NORD,NPRT,NTERM
      LOGICAL
     +   SYM
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),PHAS(NF),XORD(NORD),YORD(NORD)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   PI,XMN,XMX,YMN,YMX
      INTEGER
     +   ILOG,IPRT
      LOGICAL
     +   ERROR
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GETPI,IPRINT,PPLMT,PPMN,VERSP
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        AN ERROR FLAG.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO
C        BE ESTIMATED.
C     INTEGER IERR
C        THE ERROR FLAG.
C     INTEGER IGFERR
C        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
C        TO HAVE PRODUCED REASONABLE RESULTS.
C     INTEGER ILOG
C        THE VARIABLE CONTROLLING THE PLOT AXIS TYPE (LOG OR LINEAR)
C     INTEGER IPRT
C        THE UNIT NUMBER FOR THE OUTPUT.
C     INTEGER ISYM(1)
C        A DUMMY ARRAY FOR THE CALL TO PPMN.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES FOR WHICH THE GAIN FUNCTION ESTIMATES
C        ARE TO BE COMPUTED.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE CALLING SUBROUTINE.
C     INTEGER NORD
C        THE NUMBER OF ORDINATES TO BE PLOTTED.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NTERM
C        THE NUMBER OF TERMS IN THE FILTER FOR WHICH THE GAIN
C        FUNCTION WAS COMPUTED.
C     DOUBLE PRECISION PHAS(NF)
C        THE ARRAY IN WHICH THE PHASE OF THE FILTER IS RETURNED.
C     DOUBLE PRECISION PI
C        THE VALUE OF PI.
C     LOGICAL SYM
C        AN INDICATOR VARIABLE USED TO DETERMINE IF THE FILTER WAS
C        SYMMETRIC OR NOT.
C     DOUBLE PRECISION XMN, XMX
C        ...
C     DOUBLE PRECISION XORD(NORD)
C        THE X COORDINATES FOR THE GAIN FUNCTION PLOT
C     DOUBLE PRECISION XPLTMN, XPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
C     DOUBLE PRECISION YMN, YMX
C        ...
C     DOUBLE PRECISION YORD(NORD)
C        THE Y COORDINATES FOR THE GAIN FUNCTION PLOT
C     DOUBLE PRECISION YPLTMN, YPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
C
C     SET UNIT NUMBER FOR OUTPUT AND SET OUTPUT WIDTH.
C
      CALL IPRINT (IPRT)
C
      CALL VERSP(.TRUE.)
C
      IF (SYM) WRITE (IPRT, 1000) NTERM
      IF (.NOT. SYM) WRITE (IPRT, 1003) NTERM
C
      IF (IGFERR .EQ. 0) GO TO 5
      WRITE (IPRT, 1004)
      RETURN
C
    5 CONTINUE
C
      IF (NPRT.GE.1) THEN
        ILOG = 1
      ELSE
        ILOG = 0
      END IF
C
C     DETERMINE THE BOUNDS FOR THE X AND Y AXIS AND COMPLETE THE
C     ERROR CHECKING
C
      CALL PPLMT (YORD, YORD, XORD, XORD, NORD, 1, NORD,
     +   YPLTMN, YPLTMX, YMN, YMX, XPLTMN, XPLTMX, XMN, XMX,
     +   ERROR, NMSUB, .FALSE.)
      IF (ERROR) THEN
        IERR = 1
        RETURN
      ELSE
        CALL PPMN (YORD, YORD, XORD, XORD, NORD, 1, NORD, 0, ISYM, 1, 0,
     +   0, YMN, YMX, XMN, XMX, .FALSE., ILOG)
      END IF
C
      IF (XPLTMN .NE. 0.0D0 .OR. XPLTMX .NE. 0.5D0) GO TO 10
C
      WRITE (IPRT, 1002)
C
   10 IF (SYM) RETURN
C
      WRITE (IPRT, 1006)
C
      CALL VERSP(.TRUE.)
C
C     PRINT PHASE PLOT FOR AUTOREGRESSIVE FILTER
C
      CALL GETPI(PI)
C
      WRITE (IPRT, 1005) NTERM
C
      CALL PPLMT (PHAS, PHAS, FREQ, FREQ, NORD, 1, NORD,
     +   -PI, PI, YMN, YMX, XPLTMN, XPLTMX, XMN, XMX,
     +   ERROR, NMSUB, .FALSE.)
      IF (ERROR) THEN
        IERR = 1
        RETURN
      ELSE
        CALL PPMN (PHAS, PHAS, FREQ, FREQ, NORD, 1, NORD, 0, ISYM, 1, 0,
     +   0, YMN, YMX, XMN, XMX, .FALSE., 0)
      END IF
C
      IF (XPLTMN .NE. 0.0D0 .OR. XPLTMX .NE. 0.5D0) RETURN
C
      WRITE (IPRT, 1002)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (18H GAIN FUNCTION OF , I3, 15H TERM SYMMETRIC,
     +   14H LINEAR FILTER)
 1002 FORMAT(5H+FREQ/
     +   7H PERIOD, 9X, 3HINF, 7X, 3H20., 7X, 3H10., 8X, 6H6.6667, 4X,
     +   2H5., 8X, 2H4., 8X, 6H3.3333, 4X, 6H2.8571, 4X, 3H2.5, 7X,
     +   6H2.2222, 4X, 2H2.)
 1003 FORMAT (18H GAIN FUNCTION OF , I3, 21H TERM AUTOREGRESSIVE,,
     +   22H OR DIFFERENCE, FILTER)
 1004 FORMAT (//51H THE PLOT HAS BEEN SUPRESSED BECAUSE FEWER THAN TWO/
     +   45H NON ZERO GAIN FUNCTION VALUES WERE COMPUTED.)
 1005 FORMAT (19H PHASE FUNCTION OF , I3, 21H TERM AUTOREGRESSIVE,,
     +   22H OR DIFFERENCE, FILTER)
 1006 FORMAT ('1')
      END
*GFSEST
      SUBROUTINE GFSEST (H, K, NF, FREQ, GAIN, DELTA)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE GAIN FUNCTION OF AN INPUT SYMMETRIC
C     LINEAR FILTER AT THE FREQUENCIES SPECIFIED IN FREQ USING THE
C     TRANSFORM ALGORITHM SHOWN ON PAGE 311 OF JENKINS AND WATTS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA
      INTEGER
     +   K,NF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),GAIN(NF),H(K)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   C,PI,V0,V1,V2
      INTEGER
     +   I,J,KHALF,KMID
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,COS
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION C
C        A VALUE USED TO COMPUTE THE GAIN FUNCTION.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL OF THE ORIGINAL SERIES.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO BE
C        ESTIMATED.
C     DOUBLE PRECISION GAIN(NF)
C        THE ARRAY IN WHICH THE GAIN FUNCTION ESTIMATES ARE RETURNED.
C     DOUBLE PRECISION H(K)
C        THE SYMMETRIC LINEAR FILTER WEIGHTS.
C     INTEGER I, J
C        INDEX VARIABLES.
C     INTEGER K
C        THE NUMBER OF TERMS IN THE SYMMETRIC LINEAR FILTER.
C     INTEGER KHALF, KMID
C        HALF THE FILTER LENGTH, AND THE MIDPOINT OF THE FILTER,
C        RESPECTIVELY.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES FOR WHICH THE GAIN FUNCTION ESTIMATES
C        ARE TO BE ESTIMATED.
C     DOUBLE PRECISION PI
C        THE VALUE OF PI.
C     DOUBLE PRECISION V0, V1, V2
C        CONSTANTS USED FOR COMPUTING THE GAIN FUNCTION ESTIMATES.
C
      CALL GETPI(PI)
C
C        COMPUTE GAIN FUNCTION ESTIMATES AND THEIR CONFIDENCE LIMITS.
C
      KMID = (K+1) / 2
      KHALF = KMID - 1
C
      DO 30 I = 1, NF
         C = COS(2.0D0 * PI * FREQ(I))
         V0 = 0.0D0
         V1 = 0.0D0
         DO 20 J = 1, KHALF
            V2 = 2.0D0 * C * V1 - V0 + H(J)
            V0 = V1
            V1 = V2
   20    CONTINUE
         GAIN(I) = ABS(DELTA * (H(KMID) + 2.0D0 * (V1 * C - V0)))
   30 CONTINUE
      RETURN
      END
*GFSLF
      SUBROUTINE GFSLF (H, K)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE
C     GAIN FUNCTION OF A SYMMETRIC LINEAR FILTER (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   K
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   H(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,FMAX,FMIN,YPLTMN,YPLTMX
      INTEGER
     +   IGFERR,IPRT,NF,NORD,NPRT
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD,SYM
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FREQ(101),GAIN(101),XORD(101),YORD(101)
      INTEGER
     +   ISORT(101)
      CHARACTER
     +   LH(8)*1,LK(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,ERIODD,ERSLF,GFORD,GFOUT,GFSEST,IPRINT,SETFRQ
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     LOGICAL ERR01, ERR02, ERR03
C        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION FMAX, FMIN
C        THE MINIMUM AND MAXIMUM FREQUENCY FOR WHICH THE GAIN
C        FUNCTION IS TO BE ESTIMATED.
C     DOUBLE PRECISION FREQ(101)
C        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION
C        HAS BEEN ESTIMATED.
C     DOUBLE PRECISION GAIN(101)
C        THE VECTOR IN WHICH THE GAIN FUNCTION ESTIMATES ARE
C        STORED.
C     DOUBLE PRECISION H(K)
C        THE ARRAY OF SYMMETRIC LINEAR FILTER COEFFICIENTS.
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IGFERR
C        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
C        TO HAVE PRODUCED REASONABLE RESULTS.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     INTEGER ISORT(101)
C        THE ARRAY USED FOR SORTING.
C     INTEGER K
C        THE NUMBER OF FILTER TERMS.
C     CHARACTER*1 LH(8), LK(8)
C        THE ARRAY CONTAINING THE NAME OF THE VARIABLES H AND K.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE GAIN FUNCTION
C        IS TO BE ESTIMATED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NORD
C        THE NUMBER OF POINTS TO BE PLOTTED.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     LOGICAL SYM
C        THE VARIABLE USED TO INDICATE WHETHER THE GAIN FUNCTION
C        COMPUTED WAS FOR A SYMMETRIC OR AUTOREGRESSIVE FILTER.
C     DOUBLE PRECISION XORD(101)
C        THE X COORDINATES FOR THE GAIN FUNCTION PLOT
C     DOUBLE PRECISION YORD(101)
C        THE Y COORDINATES FOR THE GAIN FUNCTION PLOT
C     DOUBLE PRECISION YPLTMN, YPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'G',       'F',       'S',       'L',       'F',       ' '/
      DATA
     +  LH(1), LH(2), LH(3), LH(4), LH(5), LH(6), LH(7), LH(8)
     + /  'H',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LK, K, 1, 1, HEAD, ERR01, LK)
C
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR02)
C
      IF ((.NOT. ERR01) .AND. (.NOT. ERR02)) THEN
         CALL ERSLF(NMSUB, LH, K, H, HEAD, ERR03)
      ELSE
         ERR03 = .FALSE.
      END IF
C
      IF (ERR01 .OR. ERR02 .OR. ERR03) GO TO 10
      GO TO 20
C
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   20 CONTINUE
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      SYM = .TRUE.
      NF = 101
C
      FMIN = 0.0D0
      FMAX = 0.5D0
C
      DELTA = 1.0D0
C
      NPRT = -1
C
C     SET FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO BE ESTIMATED
C
      CALL SETFRQ (FREQ, NF, NPRT, FMIN, FMAX, DELTA)
C
C     COMPUTE THE GAIN FUNCTION
C
      CALL GFSEST (H, K, NF, FREQ, GAIN, DELTA)
C
C     PLOT THE RESULTS
C
      CALL GFORD (FREQ, GAIN, ISORT, NF, XORD, YORD, NORD,
     +   YPLTMN, YPLTMX, NPRT, IGFERR)
C
      CALL GFOUT (XORD, YORD, NORD, FREQ, GAIN, NF, K,
     +   SYM, FMIN, FMAX, YPLTMN, YPLTMX, NPRT, IGFERR, NMSUB)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   24H       CALL GFSLF (H, K))
      END
*GFSLFS
      SUBROUTINE GFSLFS (H, K, NF, FMIN, FMAX, GAIN, FREQ, NPRT, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE
C     GAIN FUNCTION OF A SYMMETRIC LINEAR FILTER (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   K,LDSTAK,NF,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),GAIN(*),H(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,FMN,FMX,YPLTMN,YPLTMX
      INTEGER
     +   IGFERR,IO,IPRT,ISORT,LDSMIN,NALL0,NORD,XORD,YORD
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,HEAD,SYM
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   LH(8)*1,LK(8)*1,LLDS(8)*1,LNF(8)*1,NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,ERIODD,ERSLF,GFORD,GFOUT,GFSEST,IPRINT,LDSCMP,
     +   SETFRQ,STKCLR,STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION FMAX, FMIN
C        THE MINIMUM AND MAXIMUM FREQUENCY FOR WHICH THE GAIN
C        FUNCTION IS TO BE ESTIMATED.
C     DOUBLE PRECISION FMN, FMX
C        THE FREQUENCY RANGE ACTUALLY USED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION
C        HAS BEEN ESTIMATED.
C     DOUBLE PRECISION GAIN(NF)
C        THE VECTOR IN WHICH THE GAIN FUNCTION ESTIMATES ARE
C        STORED.
C     DOUBLE PRECISION H(K)
C        THE ARRAY OF SYMMETRIC LINEAR FILTER COEFFICIENTS.
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IGFERR
C        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
C        TO HAVE PRODUCED REASONABLE RESULTS.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
C        BASED ON PRINTED OUTPUT.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     INTEGER ISORT
C        THE STARTING LOCATION IN ISTAK FOR
C        THE ARRAY USED FOR SORTING.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER K
C        THE NUMBER OF FILTER TERMS.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     CHARACTER*1 LH(8), LK(8), LLDS(8), LNF(8)
C        THE ARRAYS CONTAINING THE NAMES OF THE CHECKED VARIABLES
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE GAIN FUNCTION
C        IS TO BE ESTIMATED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NORD
C        THE NUMBER OF POINTS TO BE PLOTTED.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL SYM
C        THE VARIABLE USED TO INDICATE WHETHER THE GAIN FUNCTION
C        COMPUTED WAS FOR A SYMMETRIC OR AUTOREGRESSIVE FILTER.
C     INTEGER XORD
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE X COORDINATES FOR THE GAIN FUNCTION PLOT
C     INTEGER YORD
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE Y COORDINATES FOR THE GAIN FUNCTION PLOT
C     DOUBLE PRECISION YPLTMN, YPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'G',       'F',       'S',       'L',       'F',       'S'/
      DATA
     +  LH(1), LH(2), LH(3), LH(4), LH(5), LH(6), LH(7), LH(8)
     + /  'H',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6),
     +  LK(7), LK(8) /'K', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA
     +  LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6), LLDS(7),
     +  LLDS(8) /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
      DATA
     +  LNF(1), LNF(2), LNF(3), LNF(4), LNF(5), LNF(6), LNF(7), LNF(8)
     + /  'N',   'F',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
      IO = 1
      IF (NPRT .EQ. 0) IO = 0
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LK, K, 1, 1, HEAD, ERR01, LK)
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR02)
      ERR03 = .TRUE.
      IF ((.NOT. ERR01) .AND. (.NOT. ERR02))
     +   CALL ERSLF(NMSUB, LH, K, H, HEAD, ERR03)
      CALL EISGE(NMSUB, LNF, NF, 1, 1, HEAD, ERR04, LNF)
C
      IF (ERR04) GO TO 10
C
      CALL LDSCMP(3*IO, 0, IO*NF, 0, 0, 0, 'D', 2*IO*NF, LDSMIN)
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR05, LLDS)
C
      IF (ERR01 .OR. ERR02 .OR. ERR03 .OR. ERR05) GO TO 10
      GO TO 20
C
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   20 CONTINUE
C
      IF (NPRT .NE. 0) THEN
        CALL STKSET (LDSTAK, 4)
        NALL0 = STKST(1)
      ELSE
        NALL0 = 0
      END IF
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      SYM = .TRUE.
C
      DELTA = 1.0D0
C
C     SET FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO BE ESTIMATED
C
      FMN = MAX(FMIN, 0.0D0)
      FMX = MIN(FMAX, 0.5D0)
      IF (FMN.GE.FMX) THEN
        FMN = 0.0D0
        FMX = 0.5D0
      END IF
      CALL SETFRQ (FREQ, NF, 2, FMN, FMX, DELTA)
C
C     COMPUTE THE GAIN FUNCTION
C
      CALL GFSEST (H, K, NF, FREQ, GAIN, DELTA)
C
      IF (NPRT .EQ. 0) RETURN
C
C     SET VARIOUS POINTERS FOR THE PLOTTING ARRAYS
C
      XORD = STKGET(NF, 4)
      YORD = STKGET(NF, 4)
C
      ISORT = STKGET(NF, 2)
C
      IF (IERR .EQ. 1) GO TO 10
C
C     PLOT THE RESULTS
C
      CALL GFORD (FREQ, GAIN, ISTAK(ISORT), NF, RSTAK(XORD),
     +   RSTAK(YORD), NORD, YPLTMN, YPLTMX, NPRT, IGFERR)
      CALL GFOUT (RSTAK(XORD), RSTAK(YORD), NORD, FREQ, GAIN, NF, K,
     +   SYM, FMN, FMX, YPLTMN, YPLTMX, NPRT, IGFERR, NMSUB)
C
      CALL STKCLR(NALL0)
C
      IF (IERR .EQ. 1) GO TO 10
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL GFSLFS (H, K, NF, FMIN, FMAX, GAIN, FREQ, NPRT,',
     +   ' LDSTAK)')
      END
*GMEAN
      SUBROUTINE GMEAN(Y, N, YMEAN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE GEOMETRIC MEAN OF A SERIES, ASSUMING
C     ALL VALUES IN Y ARE NON-ZERO.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMEAN
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(N)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C  INTRINSIC FUNCTIONS
      INTRINSIC EXP,LOG
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED SERIES
C     DOUBLE PRECISION YMEAN
C        THE GEOMETRIC MEAN OF THE OBSERVED SERIES
C
      YMEAN = 0.0D0
      DO 10 I = 1, N
         YMEAN = YMEAN + LOG(Y(I))
   10 CONTINUE
      YMEAN = EXP(YMEAN/N)
      RETURN
      END
*HIPASS
      SUBROUTINE HIPASS (Y, N, FC, K, HHP, YF, NYF)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE CARRIES OUT HI-PASS FILTERING OF THE
C     SERIES.  THE FILTER IS THE K-TERM
C     LEAST SQUARES APPROXIMATION TO THE CUTOFF FILTER
C     WITH CUTOF FREQUENCY FC.  ITS TRANSFER FUNCTION
C     HAS A TRANSITION BAND OF WIDTH DELTA SURROUNDING FC,
C     WHERE DELTA = 4*PI/K.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC
      INTEGER
     +   K,N,NYF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   HHP(*),Y(*),YF(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,HEAD
C
C  LOCAL ARRAYS
      CHARACTER
     +   LFC(8)*1,LK(8)*1,LN(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,ERIODD,ERSII,ERSLFS,FLTSL,HPFLT,IPRINT,LPFLT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION FC
C        THE USER SUPPLIED CUTOFF FREQUENCY.
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     DOUBLE PRECISION HHP(K)
C        THE ARRAY IN WHICH THE -IDEAL- HIGH PASS FILTER COEFFICIENTS
C        WILL BE RETURNED.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     INTEGER K
C        THE NUMBER OF FILTER TERMS TO BE COMPUTED.
C     CHARACTER*1 LFC(8), LK(8), LN(8)
C        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES FC, K AND N.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NYF
C        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YF(N)
C        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'H',       'I',       'P',       'A',       'S',       'S'/
      DATA
     +  LFC(1), LFC(2), LFC(3), LFC(4), LFC(5), LFC(6), LFC(7), LFC(8)
     + /  'F',   'C',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 3, 1, HEAD, ERR01, LN)
C
      CALL ERSII(NMSUB, LFC, FC, 0.0D0,
     +           0.5D0, 2, HEAD, ERR02, LFC, LFC)
C
      CALL EISII(NMSUB, LK, K, 1, N, 2, HEAD, ERR03, LK, LK)
C
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR04)
      IF (ERR01 .OR. ERR02 .OR. ERR03 .OR. ERR04) GO TO 10
C
      CALL ERSLFS(NMSUB, FC, K, HEAD, ERR05)
C
      IF (ERR05) GO TO 10
      GO TO 20
C
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   20 CONTINUE
C
      CALL LPFLT (FC, K, HHP)
C
      CALL HPFLT (HHP, K, HHP)
C
      CALL FLTSL (Y, N, K, HHP, YF, NYF)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   46H       CALL HIPASS (Y, N, FC, K, HHP, YF, NYF))
      END
*HIST
      SUBROUTINE HIST(Y, N, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR PRODUCING A HISTOGRAM
C     (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   YLB,YUB
      INTEGER
     +   IDP,IFP,IINT,IPRT,LSORT,NALL0,NCELLS,YDIST
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL HSTER,HSTMN,IPRINT,STKCLR,STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ANINT,LOG10,MIN,NINT,DBLE
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IDP
C        THE CODE VALUE FOR DOUBLE PRECISION FOR FRAMEWORK.
C     INTEGER IERR
C        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
C        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
C        SOME ERROR EXISTS.
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IINT
C        THE CODE VALUE FOR INTEGER FOR FRAMEWORK
C     INTEGER IPRT
C        THE NUMBER OF THE STANDARD OUTPUT UNIT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER LDSTAK
C        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
C        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
C     INTEGER LSORT
C        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION
C        VECTOR.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF Y.
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
C        WAS CALLED.
C     INTEGER NCELLS
C        THE NUMBER OF CELLS IN THE HISTOGRAM.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION Y(N)
C        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
C        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
C        TO ITS ORIGINAL ORDER AFTERWARDS.
C     INTEGER YDIST
C        THE STARTING LOCATION IN RSTAK OF THE DISTRIBUTION VECTOR.
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
C
C     INITIALIZE NAME VECTORS
C
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'H',      'I',      'S',      'T',      ' ',      ' '/
C
      DATA IDP /4/
      DATA IINT /2/
      DATA YLB/0.0D0/, YUB/0.0D0/
C
C     COMPUTE NCELLS
C
      IF (N.GE.1) THEN
         NCELLS = MIN(NINT(5.5D0+1.5D0*ANINT(LOG10(DBLE(N)))),25)
      ELSE
         NCELLS = 1
      END IF
C
C     CHECK FOR ERRORS IN THE INPUT PARAMETERS
C
      CALL HSTER(NMSUB, Y, N, NCELLS, LDSTAK, YLB, YUB, IERR)
      IF (IERR.EQ.0) GO TO 10
C
C     PRINT ERROR MESSAGE.
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     SET UP FRAMEWORK AREA.
C
   10 CALL STKSET (LDSTAK, IDP)
      NALL0 = STKST(1)
C
C     SET UP WORK VECTORS
C
      IFP = 4
C
      LSORT = STKGET(N,IINT)
      YDIST = STKGET(NCELLS,IFP)
C
C     COMPUTE THE HISTOGRAM.
C
      CALL HSTMN(Y, N, NCELLS, YLB, YUB, ISTAK(LSORT), RSTAK(YDIST))
C
C     RETURN THE WORK VECTORS.
C
      CALL STKCLR(NALL0)
      RETURN
C
C     FORMAT STATEMENTS.
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL HIST (Y, N, LDSTAK)')
      END
*HISTC
      SUBROUTINE HISTC (Y, N, NCELL, YLB, YUB, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR PRODUCING A HISTOGRAM
C     (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YLB,YUB
      INTEGER
     +   LDSTAK,N,NCELL
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IDP,IFP,IINT,IPRT,LSORT,NALL0,NCELLS,YDIST
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL HSTER,HSTMN,IPRINT,STKCLR,STKSET
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ANINT,LOG10,MIN,NINT,DBLE
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IDP
C        THE CODE VALUE FOR DOUBLE PRECISION FOR FRAMEWORK.
C     INTEGER IERR
C        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
C        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
C        SOME ERROR EXISTS.
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IINT
C        THE CODE VALUE FOR INTEGER FOR FRAMEWORK
C     INTEGER IPRT
C        THE NUMBER OF THE STANDARD OUTPUT UNIT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER LDSTAK
C        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
C        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
C     INTEGER LSORT
C        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION
C        VECTOR.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF Y.
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
C        WAS CALLED.
C     INTEGER NCELL
C        THE USER SUPPLIED VALUE FOR THE NUMBER OF CELLS IN THE
C        HISTOGRAM.  IF NCELL IS LESS THAN OR EQUAL TO ZERO, THE
C        NUMBER OF CELLS TO BE USED (NCELLS) WILL BE CALCULATED FROM
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NCELLS
C        THE NUMBER OF CELLS IN THE HISTOGRAM.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION Y(N)
C        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
C        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
C        TO ITS ORIGINAL ORDER AFTERWARDS.
C     INTEGER YDIST
C        THE STARTING LOCATION IN RSTAK OF THE DISTRIBUTION VECTOR.
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
C
C     INITIALIZE NAME VECTORS
C
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'H',      'I',      'S',      'T',      'C',      ' '/
C
      DATA IDP /4/
      DATA IINT /2/
C
C     COMPUTE NCELLS
C
      IF ((NCELL.LE.0) .AND. (N.GE.1)) THEN
         NCELLS = MIN(NINT(5.5D0+1.5D0*ANINT(LOG10(DBLE(N)))),25)
      ELSE
         NCELLS = NCELL
      END IF
C
C     CHECK FOR ERRORS IN THE INPUT PARAMETERS
C
      CALL HSTER(NMSUB, Y, N, NCELLS, LDSTAK, YLB, YUB, IERR)
      IF (IERR.EQ.0) GO TO 10
C
C     PRINT ERROR MESSAGE.
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     SET UP FRAMEWORK AREA.
C
   10 CALL STKSET (LDSTAK, IDP)
      NALL0 = STKST(1)
C
C     SET UP WORK VECTORS
C
      IFP = 4
C
      LSORT = STKGET(N,IINT)
      YDIST = STKGET(NCELLS,IFP)
C
C     COMPUTE THE HISTOGRAM.
C
      CALL HSTMN(Y, N, NCELLS, YLB, YUB, ISTAK(LSORT), RSTAK(YDIST))
C
C     RETURN THE WORK VECTORS.
C
      CALL STKCLR(NALL0)
      RETURN
C
C     FORMAT STATEMENTS.
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL HISTC (Y, N, NCELL, YLB, YUB, LDSTAK)')
      END
*HPCOEF
      SUBROUTINE HPCOEF (HLP, K, HHP)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE COMPUTE THE HI-PASS FILTER CORRESPONDING
C     TO THE INPUT K TERM LOW PASS FILTER COEFFICIENTS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   K
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   HHP(*),HLP(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD
C
C  LOCAL ARRAYS
      CHARACTER
     +   LHLP(8)*1,LK(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,ERIODD,ERSLF,HPFLT,IPRINT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01, ERR02, ERR03
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     DOUBLE PRECISION HHP(K)
C        THE ARRAY IN WHICH THE HIGH PASS FILTER COEFFICIENTS
C        WILL BE RETURNED.
C     DOUBLE PRECISION HLP(K)
C        THE ARRAY IN WHICH THE INPUT LOW PASS FILTER COEFFICIENTS
C        ARE STORED.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     INTEGER K
C        THE NUMBER OF FILTER TERMS TO BE COMPUTED.
C     CHARACTER*1 LHLP(8), LK(8)
C        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES HLP AND K.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'H',       'P',       'C',       'O',       'E',       'F'/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LHLP(1), LHLP(2), LHLP(3), LHLP(4), LHLP(5), LHLP(6), LHLP(7),
     +  LHLP(8)
     + /  'H',   'L',   'P',   ' ',   ' ',   ' ',   ' ',   ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LK, K, 1, 1, HEAD, ERR01, LK)
C
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR02)
C
      IF (ERR01 .OR. ERR02) GO TO 10
C
      CALL ERSLF(NMSUB, LHLP, K, HLP, HEAD, ERR03)
C
      IF (ERR03) GO TO 10
      GO TO 20
C
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   20 CONTINUE
C
      CALL HPFLT (HLP, K, HHP)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   32H       CALL HPCOEF (HLP, K, HHP))
      END
*HPFLT
      SUBROUTINE HPFLT (HLP, K, HHP)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE HIPASS FILTER COEFFICIENTS
C     CORRESPONDING TO THE INPUT LOW PASS FILTER.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   K
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   HHP(K),HLP(K)
C
C  LOCAL SCALARS
      INTEGER
     +   I,KMID
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION HHP(K)
C        THE ARRAY IN WHICH THE HIGH PASS FILTER COEFFICIENTS
C        WILL BE RETURNED.
C     DOUBLE PRECISION HLP(K)
C        THE ARRAY IN WHICH THE INPUT LOW PASS FILTER COEFFICIENTS
C        ARE STORED.
C     INTEGER I
C       AN INDEX VARIABLE.
C     INTEGER K
C        THE NUMBER OF FILTER TERMS TO BE COMPUTED.
C     INTEGER KMID
C        THE MIDPOINT OF THE FILTER.
C
      DO 20 I = 1, K
         HHP(I) = -HLP(I)
   20 CONTINUE
C
      KMID = (K + 1) / 2
C
      HHP(KMID) = HHP(KMID) + 1.0D0
C
      RETURN
      END
*HSTER
      SUBROUTINE HSTER(NMSUB, Y, N, NCELLS, LDSTAK, YLB, YUB, IERR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE CHECKS INPUT PARAMETERS TO THE USER
C     CALLABLE MEMBERS OF THE HIST FAMILY OF ROUTINES
C     FOR ERRORS AND REPORTS ANY THAT IT FINDS, BESIDES
C     RETURNING A FLAG INDICATING THAT ERRORS HAVE BEEN
C     FOUND.
C
C     WRITTEN BY - JOHN E. KOONTZ, JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YLB,YUB
      INTEGER
     +   IERR,LDSTAK,N,NCELLS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  LOCAL SCALARS
      INTEGER
     +   LDSMIN,NV
      LOGICAL
     +   HEAD,IER1,IER2,IER3,IER4
C
C  LOCAL ARRAYS
      CHARACTER
     +   LLDS(8)*1,LN(8)*1,LONE(8)*1,LY(8)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,ERVII,LDSCMP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IERR
C        OUTPUT PARAMETER.  A FLAG INDICATING WHETHER OR
C        NOT AN ERROR HAS BEEN FOUND.  0 = OK, 1 = ERROR.
C     LOGICAL IER1
C        TRUE IF N .LT. 3
C     LOGICAL IER2
C        TRUE IF LDSTAK .LT. (N + 13)/2.
C     LOGICAL IER3
C        TRUE IF ALL Y VALUES ARE EQUAL.
C     LOGICAL IER4
C        TRUE IF NO DATA WITHIN USER LIMITS
C     INTEGER LDSMIN
C        MINIMUM LENGTH OF FRAMEWORK AREA IN DOUBLE
C        PRECISION ELEMENTS.
C     INTEGER LDSTAK
C        INPUT PARAMETER.  THE NUMBER OF LOCATIONS PROVIDED IN
C        THE FRAMEWORK AREA.
C     CHARACTER*1 LLDS(8), LN(8), LONE(8), LY(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) FO THE VARIALBE(S) CHECKED
C        FOR ERRORS
C     INTEGER N
C        INPUT PARAMETER.  THE NUMBER OF ELEMENTS IN Y.
C     INTEGER NCELLS
C        THE NUMBER OF CELLS IN THE HISTOGRAM.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE CALLING SUBROUTINE
C     INTEGER NV
C        THE NUMBER OF VALUES OUTSIDE USER SUPPLIED LIMITS.
C     DOUBLE PRECISION Y(N)
C        INPUT PARAMETER.  THE VECTOR OF N OBSERVATIONS.
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
C
C     INITIALIZE NAME VECTORS
C
      DATA   LLDS(1),  LLDS(2),  LLDS(3),  LLDS(4),  LLDS(5),  LLDS(6),
     +  LLDS(7), LLDS(8) /'L', 'D', 'S', 'T', 'A', 'K', ' ', ' '/
      DATA     LN(1),    LN(2),    LN(3),    LN(4),    LN(5),    LN(6),
     +    LN(7),   LN(8) /'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA   LONE(1),  LONE(2),  LONE(3),  LONE(4),  LONE(5),  LONE(6),
     +  LONE(7), LONE(8) /'O', 'N', 'E', ' ', ' ', ' ', ' ', ' '/
      DATA     LY(1),    LY(2),    LY(3),    LY(4),    LY(5),    LY(6),
     +    LY(7),   LY(8) /'Y', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
C
C     INITIALIZE ERROR FLAGS
C
      IER1 = .FALSE.
      IER2 = .FALSE.
      IER3 = .FALSE.
      IER4 = .FALSE.
C
      IERR = 0
C
      HEAD = .TRUE.
C
C     CHECK TO SEE THAT THERE IS AT LEAST ONE DATA POINTS.
C
      CALL EISGE(NMSUB, LN, N, 1, 2, HEAD, IER1, LONE)
C
C     CHECK FOR SUFFICIENT WORK AREA
C
      CALL LDSCMP(2, 0, N, 0, 0, 0, 'D', NCELLS, LDSMIN)
C
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, IER2, LLDS)
C
C     CHECK WHETHER THERE IS ANY DATA BETWEEN USER SUPPLIED LIMITS
C
      IF ((YLB.LT.YUB) .AND. (N.GE.1))
     +  CALL ERVII (NMSUB, LY, Y, N, YLB, YUB, N-1, HEAD, 1, NV, IER4)
C
C     SEE IF ANY ERRORS WERE FOUND.
C
      IF (IER1 .OR. IER2 .OR. IER3 .OR. IER4) IERR = 1
      RETURN
      END
*HSTMN
      SUBROUTINE HSTMN(Y, N, NCELLS, YLB, YUB, LSORT, YDIST)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN ROUTINE FOR PRODUCING A HISTOGRAM
C
C     ORIGINAL VERSION ADAPTED FROM AN EARLY VERSION OF MINITAB.
C
C     ADAPTED BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YLB,YUB
      INTEGER
     +   N,NCELLS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(N),YDIST(NCELLS)
      INTEGER
     +   LSORT(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,B1SQRT,B2,CFRACT,CFRCTM,CNTMX,FRACT,P,SCALE,SUM1,SUM2,
     +   SUM3,SUMD2,SUMD3,SUMD4,SUMDA,SUMT1,TEMP,WIDTH,XN,XNN,YINTMP,
     +   YMAX,YMDDSD,YMEAN,YMEANT,YMED,YMIDRG,YMIN,YRANGE,YSD,YVAR
      INTEGER
     +   I,IFLAG,IPRT,J,MID,NHIGH,NLOW,NOBS,NUM,NUMS
      CHARACTER
     +   IPLUS*1
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   A(6)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GENI,IPRINT,SRTIR,SRTRI,STAT1,SUMBS,SUMDS,SUMSS,SUMTS,
     +   VERSP
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,INT,MAX,MOD,NINT,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION A(6)
C        A VECTOR USED FOR PRINTING THE HISTOGRAM SCALE.
C     DOUBLE PRECISION ALPHA
C        THE PERCENTAGE TO BE TRIMMED OFF EACH END OF Y FOR THE
C        TRIMMED MEANS CALCULATIONS.
C     DOUBLE PRECISION B1SQRT
C        BETA ONE  -  A MEASURE OF SKEWNESS
C     DOUBLE PRECISION B2
C        BETA TWO  -  A MEASURE OF KURTOSIS
C     DOUBLE PRECISION CFRACT
C        THE CUMULATIVE DISTRIBUTION
C     DOUBLE PRECISION CFRCTM
C        THE REVERSE CUMULATIVE DISTRIBUTION
C     DOUBLE PRECISION CNTMX
C        THE SIZE OF THE LARGEST CELL COUNT
C     DOUBLE PRECISION FRACT
C        THE FRACTION OF THE OBSERVATIONS IN A GIVEN CELL
C     INTEGER I
C        AN INDEX
C     INTEGER IFLAG
C        IF 1, THEN MORE THAN 50 OBS. FELL IN A SINGLE CELL,
C        AND A SCALED HISTOGRAM WILL BE PROVIDED.
C     CHARACTER*1 IPLUS
C        THE CHARACTER +
C     INTEGER IPRT
C        THE NUMBER OF THE STANDARD OUTPUT UNIT.
C     INTEGER J
C        AN INDEX.
C     INTEGER LSORT(N)
C        THE PERMUTATION VECTOR.
C     INTEGER MID
C        THE INDEX OF THE (AN) ELEMENT OF Y CLOSEST TO ZERO, WHEN
C        Y HAS BEEN SORTED.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF Y.
C     INTEGER NCELLS
C        THE NUMBER OF CELLS IN THE FREQUENCY DISTRIBUTION.
C     INTEGER NHIGH
C        THE INDEX OF THE LARGEST VALUE IN THE SORTED ARRAY
C        TO BE USED IN THE HISTOGRAM
C     INTEGER NLOW
C        THE INDEX OF THE SMALLEST VALUE IN THE SORTED ARRAY
C        TO BE USED IN THE HISTOGRAM
C     INTEGER NOBS
C        THE NUMBER OF OBSERVATIONS ACTUALLY USED IN THE HISTOGRAM
C     INTEGER NUM
C        THE CELL COUNT
C     INTEGER NUMS
C        THE SCALED CELL COUNT
C     DOUBLE PRECISION P
C        A VARIABLE USED TO DETERMINE THE SCALE
C     DOUBLE PRECISION SCALE
C        THE PRINTED INCREMENT ON THE HISTOGRAM SCALE
C     DOUBLE PRECISION SUMDA
C        THE SUM OF THE ABSOLUTE DIFFERENCES FROM THE MEAN.
C     DOUBLE PRECISION SUMD2
C        THE SUM OF THE SQUARES OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMD3
C        THE SUM OF THE CUBES OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMD4
C        THE SUM OF THE 4TH POWERS OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMT1
C        THE SUM OF THE ALPHA TRIMMED ARRAY Y.
C     DOUBLE PRECISION SUM1, SUM2, SUM3
C        VARIOUS SUMS OF THE DATA.
C     DOUBLE PRECISION TEMP
C        A TEMPORARY STORAGE VARIABLE
C     DOUBLE PRECISION WIDTH
C        THE WIDTH OF A CELL
C     DOUBLE PRECISION XN
C        THE FOATING POINT REPRESENTATION OF N
C     DOUBLE PRECISION XNN
C        THE UNROUNDED NUMBER OF PLOTTING POSISTIONS ON A SCALES
C        HISTOGRAM
C     DOUBLE PRECISION Y(N)
C        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
C        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
C        TO ITS ORIGINAL ORDER AFTERWARDS.
C     DOUBLE PRECISION YDIST(NCELLS)
C        THE FREQUENCY DISTRIBUTION USED TO CREATE THE HISTOGRAM.
C     DOUBLE PRECISION YINTMP
C        THE MIDPOINT OF THE ITH CELL
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
C     DOUBLE PRECISION YMAX
C        THE HISTOGRAM UPPER BOUND USED
C     DOUBLE PRECISION YMDDSD
C        THE MEAN ABSOLUTE DEVIATION / THE STANDARD DEVIATION
C     DOUBLE PRECISION YMEAN, YMEANT
C        THE MEAN OF THE OBSERVATIONS USED IN THE HISTOGRAM
C     DOUBLE PRECISION YMED
C        THE MEDIAN OF THE OBSERVATIONS USED IN THE HISTOGRAM
C     DOUBLE PRECISION YMIDRG
C        THE MID RANGE OF THE OBSERVATIONS USED IN THE HISTOGRAM
C     DOUBLE PRECISION YMIN
C        THE HISTOGRAM LOWER BOUND USED.
C     DOUBLE PRECISION YRANGE
C        THE RANGE OF THE OBSERVATIONS USED IN THE HISTOGRAM
C     DOUBLE PRECISION YSD
C        THE STANDARD DEVIATION OF THE OBSERVATIONS USED IN THE
C        HISTOGRAM.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
C     DOUBLE PRECISION YVAR
C        THE VARIANCE OF THE OBSERVATIONS.
C
      DATA IPLUS /'+'/
      DATA ALPHA/0.25D0/
C
      CALL IPRINT(IPRT)
C
C     SORT DATA
C
      CALL GENI(LSORT, N, 1, 1)
      CALL SRTIR(LSORT, N, Y)
C
C     FIX UPPER AND LOWER BOUNDS.
C
      NLOW = 1
      NHIGH = N
      IF (YLB.EQ.YUB) GO TO 50
C
C     FIND INDEX OF THE FIRST VALUE OF Y .GE. YLB
C
      DO 20 I=1,N
         IF (Y(I).LT.YLB) GO TO 20
         NLOW = I
         GO TO 30
   20 CONTINUE
C
C     FIND INDEX OF THE LAST VALUE OF Y .LE. YUB
C
   30 DO 40 I=1,N
         J = N - I + 1
         IF (Y(J).GT.YUB) GO TO 40
         NHIGH = J
         GO TO 50
   40 CONTINUE
   50 CONTINUE
      XN = NHIGH-NLOW+1
      NOBS = NHIGH - NLOW + 1
C
C     COMPUTE MEDIAN, EXTREMA, MID-RANGE, RANGE AND FREQUENCY
C     DISTRIBUTION FOR NCELLS CELLS
C
      CALL STAT1(Y(NLOW), NOBS, YMED, YMIN, YMAX, YMIDRG, YRANGE,
     +   NCELLS, YLB, YUB, YDIST)
C
      IF (YLB.GE.YUB) GO TO 55
C
      YMIN = YLB
      YMAX = YUB
C
   55 CONTINUE
C
C     COMPUTE MEAN, TRIMMED MEAN, STANDARD DEVIATION,
C     MEAN DEVIATION/STANDARD DEVIATION, BETA ONE, AND BETA TWO
C
      CALL SUMBS(Y, N, NLOW, MID, NHIGH)
      CALL SUMSS(Y, N, NLOW, MID, NHIGH, SUM1, SUM2, SUM3, YMEAN)
      CALL SUMTS(Y(NLOW), NOBS, ALPHA, SUMT1, YMEANT)
      CALL SUMDS(Y, N, NLOW, MID, NHIGH, YMEAN, SUMDA, SUMD2, SUMD3,
     +   SUMD4)
C
      YVAR = 0.0D0
      YSD = 0.0D0
      B1SQRT = 0.0D0
      B2 = 0.0D0
      YMDDSD = 0.0D0
C
      IF ((SUMD2.LE.0.0D0) .OR. (NOBS.LE.1)) GO TO 60
C
      YVAR = SUMD2/(NOBS-1)
      YSD = SQRT(YVAR)
      B1SQRT = ABS((SUMD3/XN)/((SUMD2/XN)**1.5D0))
      B2 = (SUMD4/XN)/((SUMD2/XN)**2)
      YMDDSD = SUMDA/(YSD*NOBS)
C
   60 CONTINUE
C
C     OUTPUT STATISTICS
C
      CALL VERSP(.TRUE.)
      WRITE (IPRT,1070) N, Y(NLOW), Y(NHIGH), YMIN, YMAX
      WRITE (IPRT,1000)
     +   NCELLS, NOBS, YMEANT, Y(NLOW), YSD, Y(NHIGH), YMDDSD,
     +   YMEAN, B1SQRT, YMED, B2
      WRITE (IPRT,1010)
C
C     CHECK FOR MORE THAN 50 VALUES IN INTERVAL AND FIND MAX. VALUE.
C
      IFLAG = 0
      CNTMX = 0.0D0
      DO 80 I=1,NCELLS
         IF (YDIST(I).GT.CNTMX) CNTMX = YDIST(I)
   80 CONTINUE
      IF (NINT(CNTMX).GT.50) IFLAG = 1
C
C     DETERMINE SCALE.
C
      IF (IFLAG.EQ.0) THEN
         SCALE = 1.0D0
      ELSE
         P = CNTMX/XN
         SCALE = 0.05D0
         IF (P.GT.0.25D0) SCALE = 0.1D0
         IF (P.GT.0.5D0) SCALE = 0.2D0
      END IF
C
C     PRINT COLUMN HEADINGS AND HISTOGRAM SCALE.
C
      IF (IFLAG.EQ.0) WRITE (IPRT,1020)
      IF (IFLAG.NE.0) WRITE (IPRT,1080)
      WRITE (IPRT,1090)
      IF (IFLAG.NE.0) GO TO 100
      WRITE (IPRT,1030) (I,I=10,50,10)
      GO TO 120
  100 A(1) = 0.0D0
      DO 110 I=1,5
         A(I+1) = A(I) + SCALE
  110 CONTINUE
      WRITE (IPRT,1040) (A(I),I=1,6)
  120 WRITE (IPRT,1050)
      CFRACT = 0.0D0
      CFRCTM = 1.0D0
      TEMP = 0.0D0
      WIDTH = (YMAX-YMIN)/NCELLS
      YINTMP = YMIN
      YINTMP = YINTMP - WIDTH/2.0D0
      DO 150 I=1,NCELLS
         NUM = INT(YDIST(I)+0.5D0)
         IF (MOD(NCELLS,2).EQ.1 .AND. I.EQ.NCELLS/2+1
     +       .AND. YMIN.EQ.(-YMAX)) THEN
            YINTMP = 0.0D0
         ELSE
            YINTMP = YINTMP + WIDTH
         END IF
         FRACT = YDIST(I)/XN
         CFRACT = CFRACT + FRACT
         CFRCTM = 1.0D0 - TEMP
         TEMP = CFRACT
         IF (NUM.LE.0) THEN
           WRITE (IPRT,1060) YINTMP, CFRACT, CFRCTM, FRACT, NUM
         ELSE
           IF (IFLAG.EQ.0) THEN
             NUMS = NUM
           ELSE
             XNN = FRACT*10.0D0/SCALE
             NUMS = INT(XNN)
             NUMS = MAX(1, NUMS + INT(XNN-NUMS+0.5D0))
           END IF
           WRITE (IPRT,1060) YINTMP, CFRACT, CFRCTM, FRACT,
     +        NUM, (IPLUS,J=1,NUMS)
         END IF
  150 CONTINUE
C
C     RESTORE DATA TO ORIGINAL ORDER
C
      CALL SRTRI(Y, N, LSORT)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(/26H NUMBER OF CELLS        = , I15/
     +        26H OBSERVATIONS USED      = , I15, 11X,
     +              22H25 PCT TRIMMED MEAN = , 1PE15.8/
     +        26H MIN. OBSERVATION USED  = , E15.8, 11X,
     +              22HSTANDARD DEVIATION  = , E15.8/
     +        26H MAX. OBSERVATION USED  = , E15.8, 11X,
     +              22HMEAN DEV./STD. DEV. = , E15.8/
     +        26H MEAN VALUE             = , E15.8, 11X,
     +              22HSQRT(BETA ONE)      = , E15.8/
     +        26H MEDIAN VALUE           = , E15.8, 11X,
     +              22HBETA TWO            = , E15.8)
 1010 FORMAT(//44H FOR A NORMAL DISTRIBUTION, THE VALUES (MEAN,
     +   56H DEVIATION/STANDARD DEVIATION), SQRT(BETA ONE), AND BETA,
     +   22H TWO ARE APPROXIMATELY/
     +   ' 0.8, 0.0 AND 3.0, RESPECTIVELY.  TO TEST THE ',
     +   59HNULL HYPOTHESIS OF NORMALITY, SEE TABLES OF CRITICAL VALUES,
     +   13H PP. 207-208,/  22H BIOMETRIKA TABLES FOR,
     +   58H STATISTICIANS, VOL. 1.  SEE PP. 67-68 FOR A DISCUSSION OF,
     +   13H THESE TESTS.)
 1020 FORMAT(///5X,39HINTERVAL     CUM.   1-CUM.   CELL   NO.,19X,
     + 22HNUMBER OF OBSERVATIONS)
 1030 FORMAT('+',47X,1H0,8X,5(I2,8X))
 1040 FORMAT('+',46X,6(F4.2,6X))
 1050 FORMAT(4X,42('-'),2X,'+',5(10H---------+))
 1060 FORMAT(3X,1PE13.6,2X,2(0PF5.3,3X),F5.3,1X,I5,4X,50A1)
 1070 FORMAT (10H HISTOGRAM//
     +        26H NUMBER OF OBSERVATIONS = , I15/
     +        26H MINIMUM OBSERVATION    = , 1PE15.8/
     +        26H MAXIMUM OBSERVATION    = , E15.8//
     +        26H HISTOGRAM LOWER BOUND  = , E15.8/
     +        26H HISTOGRAM UPPER BOUND  = , E15.8)
 1080 FORMAT(///5X,39HINTERVAL     CUM.   1-CUM.   CELL   NO.,23X,
     + 13HCELL FRACTION)
 1090 FORMAT(5X,41HMID POINT   FRACT.  FRACT.  FRACT.  OBS. )
      END
*ICNTI
      INTEGER FUNCTION ICNTI (IV, NIV, I)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COUNTS THE NUMBER OF OCCURENCES OF I IN IV.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING LAB/BOULDER
C                  NATIONAL BUREAU OF STANDARDS
C
C     CREATION DATE  -  APRIL 20, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   I,NIV
C
C  ARRAY ARGUMENTS
      INTEGER
     +   IV(NIV)
C
C  LOCAL SCALARS
      INTEGER
     +   J
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        INPUT PARAMETER.  THE INTEGER TO COUNT OCCURENCES OF.
C     INTEGER IV(NIV)
C        INPUT PARAMETER.  THE VECTOR IN WHICH TO COUNT.
C     INTEGER J
C        LOOP PARAMETER.
C     INTEGER NIV
C        INPUT PARAMETER.  THE LENGTH OF IV.
C
C     COMMENCE BODY OF ROUTINE
C
      ICNTI = 0
      DO 10 J = 1, NIV
         IF (IV(J) .EQ. I) ICNTI = ICNTI + 1
   10 CONTINUE
      RETURN
      END
*ICOPY
      SUBROUTINE ICOPY(N,ISX,INCX,ISY,INCY)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE IS A ADAPTATION OF THE BLAS SUBROUTINE DCOPY,
C     MODIFIED TO HANDLE INTEGER ARRAYS.
C
C     COPY INTEGER ISX TO INTEGER ISY.
C     FOR I = 0 TO N-1, COPY  ISX(LX+I*INCX) TO ISY(LY+I*INCY),
C     WHERE LX = 1 IF INCX .GE. 0, ELSE LX = (-INCX)*N, AND LY IS
C     DEFINED IN A SIMILAR WAY USING INCY.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   INCX,INCY,N
C
C  ARRAY ARGUMENTS
      INTEGER
     +   ISX(N),ISY(N)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IX,IY,M,MP1,NS
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MOD
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER INCX, INCY
C        THE INCREMENT USED FOR THE COPY FROM ONE VARIABLE TO THE OTHER.
C     INTEGER ISX(N)
C        THE ARRAY TO BE COPIED FROM.
C     INTEGER ISY(N)
C        THE ARRAY TO BE COPIED TO.
C     INTEGER IX, IY
C        INDEX VARIABLES.
C     INTEGER M
C        THE VALUE OF N MODULO 7.
C     INTEGER MP1
C        THE VALUE OF M + 1.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE ARRAYS ISX AND ISY.
C     INTEGER NS
C        THE VALUE OF N * INCX.
C
      IF(N.LE.0)RETURN
      IF(INCX.EQ.INCY) IF(INCX-1) 5,20,60
    5 CONTINUE
C
C        CODE FOR UNEQUAL OR NONPOSITIVE INCREMENTS.
C
      IX = 1
      IY = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      DO 10 I = 1,N
        ISY(IY) = ISX(IX)
        IX = IX + INCX
        IY = IY + INCY
   10 CONTINUE
      RETURN
C
C        CODE FOR BOTH INCREMENTS EQUAL TO 1
C
C
C        CLEAN-UP LOOP SO REMAINING VECTOR LENGTH IS A MULTIPLE OF 7.
C
   20 M = MOD(N,7)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        ISY(I) = ISX(I)
   30 CONTINUE
      IF( N .LT. 7 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,7
        ISY(I) = ISX(I)
        ISY(I + 1) = ISX(I + 1)
        ISY(I + 2) = ISX(I + 2)
        ISY(I + 3) = ISX(I + 3)
        ISY(I + 4) = ISX(I + 4)
        ISY(I + 5) = ISX(I + 5)
        ISY(I + 6) = ISX(I + 6)
   50 CONTINUE
      RETURN
C
C        CODE FOR EQUAL, POSITIVE, NONUNIT INCREMENTS.
C
   60 CONTINUE
      NS = N*INCX
      DO 70 I=1,NS,INCX
          ISY(I) = ISX(I)
   70 CONTINUE
      RETURN
      END
*INPERL
      INTEGER FUNCTION INPERL (IDUM)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE NUMBER OF VECTOR ELEMENTS THAT CAN
C     BE PRINTED IN A LINE OF OUTPUT ON THE STANDARD OUTPUT FILE.
C
C     ASSUMPTIONS RE -
C
C        1) MAXIMUM WIDTH OF LINE TO USE (IMAXW) IS 132.
C        2) NUMBER OF CHARACTERS NOT VECTOR ELEMENTS PER LINE
C                (IOCPL) IS 15.
C        2) WIDTH OF FIELD FOR AN ELEMENT, INCLUDING SPACING
C                BETWEEN ELEMENTS (IEW) IS 15.
C        4) MAXIMUM ELEMENTS PER LINE (IMAXE) IS 7.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C                       EXTRACTED FROM EARLIER LSTVEC.
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IDUM
C
C  LOCAL SCALARS
      INTEGER
     +   IEW,IMAXE,IMAXW,IOCPL,IWIDTH
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IDUM
C        INPUT PARAMETER.  UNUSED ARGUMENT.
C     INTEGER IEW
C        WIDTH OF A FIELD FOR PRINTING OUT A VECTOR ELEMENT,
C        INCLUDING SPACES BETWEEN ADJACENT ELEMENTS.
C     INTEGER IMAXE
C        MAXIMUM NUMBER OF ARRAY ELEMENTS PER LINE.
C     INTEGER IMAXW
C        MAXIMUM NUMBER OF CHARACTERS TO ALLOW PER LINE.
C     INTEGER IOCPL
C        NUMBER OF CHARACTERS TO BE INTRODUCED TO LINE IN ADDITION
C        TO CHARACTERS IN THE ELEMENT FIELDS.
C     INTEGER IWIDTH
C        NUMBER OF CHARACTERS IN A LINE ON THE STANDARD OUTPUT FILE.
C
C
C     INITIALIZATIONS
C
      DATA IEW /15/, IMAXE /7/, IMAXW /132/, IOCPL /15/
C
C     COMMENCE BODY OF ROUTINE
C
      IWIDTH = 132
      INPERL = (MIN(IWIDTH, IMAXW) - IOCPL)/IEW
      INPERL = MIN(INPERL, IMAXE)
      RETURN
      END
*IPGDV
      SUBROUTINE IPGDV (PER, NF, N, PERI, FREQ, XAXIS, YAXIS, ISYM,
     +   LPCV, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRODUCES CO-ORDINATES FOR THE SPECTRAL PLOTS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LPCV,N,NF,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),PER(NF),PERI(NF),XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISYM(LPCV)
C
C  LOCAL SCALARS
      INTEGER
     +   ISPCER,NPTS
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPGMN,IPGORD,IPGOUT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION FREQ(NF)
C        THE ARRAY IN WHICH THE FREQUENCIES AT WHICH THE PERIODOGRAM
C        WAS ESTIMATED ARE STORED.
C     INTEGER ISPCER
C        AN ERROR INDICATOR FOR THE INTEGRATED PERIODOGRAM COMPUTATIONS.
C     INTEGER ISYM(LPCV)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER N
C        THE ACTUAL NUMBER OF OBSERVATIONS IN THE SERIES FROM WHICH
C        THE PERIODOGRAM WAS COMPUTED.
C     INTEGER NPRT
C        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
C        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
C        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A PAGE PLOT.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
C        ARE ESTIMATED.
C     INTEGER NPTS
C        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
C     DOUBLE PRECISION PER(NF)
C        THE RAW PERIODOGRAM.
C     DOUBLE PRECISION PERI(NF)
C        THE ARRAY CONTAINING THE INTEGRATED PERIODOGRAM VALUES.
C     DOUBLE PRECISION XAXIS(LPCV), YAXIS(LPCV)
C        THE X, Y CO-ORDINATES FOR THE SPECTRAL PLOTS.
C
C     COMPUTE THE INTEGRATED PERIODOGRAM
C
      CALL IPGMN(PER, NF, PERI, ISPCER)
C
      IF (ISPCER .NE. 0) GO TO 10
C
      IF (NPRT .EQ. 0) RETURN
C
C     SET CO-ORDINATES FOR THE INTEGRATED PERIODOGRAM
C
      CALL IPGORD(PERI, NF, N, FREQ, XAXIS, YAXIS, ISYM, NPTS, LPCV)
C
C     PLOT THE INTEGRATED PERIODOGRAM
C
   10 CALL IPGOUT (XAXIS, YAXIS, ISYM, NPTS, LPCV, ISPCER)
C
      RETURN
C
      END
*IPGM
      SUBROUTINE IPGM (YFFT, N, LYFFT, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
C     THE INTEGRATED PERIODOGRAM OF A SERIES (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,LYFFT,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YFFT(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   FREQ,IEXTND,IPRT,ISYM,LDSMIN,LPCV,NALL0,NF,NFFT,NPRT,
     +   XAXIS,YAXIS
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   LLDS(8)*1,LLYFFT(8)*1,LN(8)*1,NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CNTR,EISGE,IPGDV,IPRINT,LDSCMP,PGMMN,SETESL,STKCLR,STKSET
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL ERR01, ERR02, ERR03
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     INTEGER FREQ
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
C        INTEGRATED SPECTRUM VALUES ARE STORED.
C     LOGICAL HEAD
C        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
C        ERROR MESSAGES (TRUE) OR NOT (FALSE).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IEXTND
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
C        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
C        USED TO EXTEND THE SERIES.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     CHARACTER*1 LLDS(8), LLYFFT(8), LN(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
C        FOR ERRORS.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS.
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING ALLOCATIONS OF THE STACK AT THE
C        TIME OF THIS CALL.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODGRAM IS
C        TO BE COMPUTED.
C     INTEGER NFFT
C        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
C        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
C        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A PAGE PLOT.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY IN WHICH THE X AXIS VALUES TO BE PLOTTED ARE STORED.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
C     DOUBLE PRECISION YFFT(LYFFT)
C        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'I',       'P',       'G',       'M',       ' ',       ' '/
      DATA
     + LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     +  LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA
     + LLYFFT(1), LLYFFT(2), LLYFFT(3), LLYFFT(4), LLYFFT(5),
     +  LLYFFT(6), LLYFFT(7), LLYFFT(8)
     +  /'L','Y','F','F','T',' ',' ',' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /'N',' ',' ',' ',' ',' ',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
      IF (ERR01) GO TO 5
C
C     SET LENGTH OF EXTENDED SERIES
C
      CALL SETESL(N, 2, NFFT)
      NF = NFFT/2
C
      CALL EISGE(NMSUB, LLYFFT, LYFFT, NFFT, 9, HEAD, ERR02, LLYFFT)
C
      CALL LDSCMP(3, 0, NF+103, 0, 0, 0, 'D', 2*NFFT+206, LDSMIN)
C
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR03, LLDS)
C
      IF (ERR01 .OR. ERR02 .OR. ERR03) GO TO 5
      GO TO 10
C
    5 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   10 CONTINUE
C
C     SET THE SIZE OF THE WORK AREA
C
      CALL STKSET(LDSTAK, 4)
C
C     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
C
      NALL0 = STKST(1)
C
C     SET VARIOUS PROGRAM PARAMETERS.
C
      LPCV = NF + 103
      NPRT = 1
C
C     CENTER THE SERIES
C
      CALL CNTR(YFFT, N, YFFT)
      IEXTND = 0
C
C     SUBDIVIDE THE STACK.
C
      ISYM = STKGET(LPCV, 2)
      XAXIS = STKGET(LPCV, 4)
      YAXIS = STKGET(LPCV, 4)
C
      FREQ = XAXIS
C
C     COMPUTE THE RAW PERIODOGRAM.
C
      CALL PGMMN (YFFT, N, NFFT, IEXTND, NF, YFFT, LYFFT, RSTAK(YAXIS),
     +   RSTAK(FREQ), LPCV, 0, NMSUB)
C
C     CALL THE MAIN DRIVER FOR COMPUTING (AND PLOTTING) THE INTEGRATED
C     PERIODOGRAM.
C
      CALL IPGDV (YFFT, NF, N, YFFT, RSTAK(FREQ), RSTAK(XAXIS),
     +   RSTAK(YAXIS), ISTAK(ISYM), LPCV, NPRT)
C
      CALL STKCLR(NALL0)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL IPGM (YFFT, N, LYFFT, LDSTAK)')
      END
*IPGMN
      SUBROUTINE IPGMN (PER, NF, PERI, ISPCER)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE INTEGRATED PERIODOGRAM.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISPCER,NF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PER(NF),PERI(NF)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   SM
      INTEGER
     +   I
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER ISPCER
C        AN ERROR INDICATOR FOR THE INTEGRATED PERIODOGRAM COMPUTATIONS.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODGRAM IS
C        COMPUTED.
C     DOUBLE PRECISION PER(NF)
C        THE RAW PERIODOGRAM.
C     DOUBLE PRECISION PERI(NF)
C        THE ARRAY WHICH CONTAINS THE INTEGRATED PERIODOGRAM.
C     DOUBLE PRECISION SM
C        A VALUE USED TO COMPUTE THE INTEGRATED PERIODOGRAM ESTIMATES.
C
C
      SM = 0.0D0
C
      DO 30 I = 1, NF
         SM = SM + PER(I)
         PERI(I) = SM
   30 CONTINUE
C
      ISPCER = 1
      IF (SM .EQ. 0.0D0) RETURN
C
      ISPCER = 0
C
      DO 40 I = 1, NF
         PERI(I) = PERI(I)/SM
   40 CONTINUE
C
      RETURN
      END
*IPGMP
      SUBROUTINE IPGMP (PER, FREQ, NF, N, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
C     THE INTEGRATED PERIODOGRAM OF A SERIES (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N,NF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),PER(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,ISYM,LDSMIN,LPCV,NALL0,NPRT,PERI,XAXIS,YAXIS
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   LLDS(8)*1,LN(8)*1,LNF(8)*1,NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,IPGDV,IPRINT,LDSCMP,STKCLR,STKSET
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL ERR01, ERR02, ERR03
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION FREQ(NF)
C        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
C        INTEGRATED SPECTRUM VALUES ARE STORED.
C     LOGICAL HEAD
C        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
C        ERROR MESSAGES (TRUE) OR NOT (FALSE).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER ISYM
C        ...
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     CHARACTER*1 LLDS(8), LN(8), LNF(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
C        FOR ERRORS.
C     INTEGER LPCV
C        ...
C     INTEGER N
C        THE ACTUAL NUMBER OF OBSERVATIONS IN THE SERIES FROM WHICH
C        THE PERIODOGRAM WAS COMPUTED.
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING ALLOCATIONS OF THE STACK AT THE
C        TIME OF THIS CALL.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODGRAM IS
C        TO BE COMPUTED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
C        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
C        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A PAGE PLOT.
C     DOUBLE PRECISION PER(NF)
C        THE RAW PERIODOGRAM.
C     INTEGER PERI
C        THE STARTING LOCATION IN THE STACK FOR
C        THE VECTOR CONTAINING THE INTEGRATED PERIODOGRAM.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY IN WHICH THE X AXIS VALUES TO BE PLOTTED ARE STORED.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'I',       'P',       'G',       'M',       'P',       ' '/
      DATA
     + LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     +  LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /'N',' ',' ',' ',' ',' ',' ',' '/
      DATA
     + LNF(1), LNF(2), LNF(3), LNF(4), LNF(5), LNF(6), LNF(7), LNF(8)
     + /'N','F',' ',' ',' ',' ',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
C
      CALL EISGE(NMSUB, LNF, NF, (N+2)/2, 1, HEAD, ERR02, LNF)
C
      IF (ERR01) GO TO 5
C
      CALL LDSCMP(4, 0, NF+103, 0, 0, 0, 'D', 3*NF+206, LDSMIN)
C
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR03, LLDS)
C
      IF (ERR02 .OR. ERR03) GO TO 5
      GO TO 10
C
    5 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   10 CONTINUE
C
C     SET THE SIZE OF THE WORK AREA
C
      CALL STKSET(LDSTAK, 4)
C
C     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
C
      NALL0 = STKST(1)
C
C     SET VARIOUS PROGRAM PARAMETERS.
C
      LPCV = NF + 103
      NPRT = 1
C
C     SUBDIVIDE THE STACK.
C
      ISYM = STKGET(LPCV, 2)
      PERI = STKGET(NF, 4)
      XAXIS = STKGET(LPCV, 4)
      YAXIS = STKGET(LPCV, 4)
C
C     CALL THE MAIN DRIVER FOR COMPUTING (AND PLOTTING) THE INTEGRATED
C     PERIODOGRAM.
C
      CALL IPGDV (PER, NF, N, RSTAK(PERI), FREQ, RSTAK(XAXIS),
     +   RSTAK(YAXIS), ISTAK(ISYM), LPCV, NPRT)
C
      CALL STKCLR(NALL0)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL IPGMP (PER, FREQ, NF, N, LDSTAK)')
      END
*IPGMPS
      SUBROUTINE IPGMPS (PER, FREQ, NF, N, LDSTAK, PERI, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
C     THE INTEGRATED PERIODOGRAM OF A SERIES (LONG CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N,NF,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),PER(*),PERI(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,ISYM,LDSMIN,LPCV,NALL0,XAXIS,YAXIS
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   LLDS(8)*1,LN(8)*1,LNF(8)*1,NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,IPGDV,IPRINT,LDSCMP,STKCLR,STKSET
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL ERR01, ERR02, ERR03
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION FREQ(NF)
C        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
C        INTEGRATED SPECTRUM VALUES ARE STORED.
C     LOGICAL HEAD
C        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
C        ERROR MESSAGES (TRUE) OR NOT (FALSE).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     CHARACTER*1 LLDS(8), LN(8), LNF(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
C        FOR ERRORS.
C     INTEGER N
C        THE ACTUAL NUMBER OF OBSERVATIONS IN THE SERIES FROM WHICH
C        THE PERIODOGRAM WAS COMPUTED.
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING ALLOCATIONS OF THE STACK AT THE
C        TIME OF THIS CALL.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODGRAM IS
C        COMPUTED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
C        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
C        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A PAGE PLOT.
C     DOUBLE PRECISION PER(NF)
C        THE INTEGRATED PERIODOGRAM.
C     DOUBLE PRECISION PERI(NF)
C        THE VECTOR IN WHICH THE INTEGRATED PERIODOGRAM IS STORED.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY IN WHICH THE X AXIS VALUES TO BE PLOTTED ARE STORED.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'I',       'P',       'G',       'M',       'P',       'S'/
      DATA
     + LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     +  LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /'N',' ',' ',' ',' ',' ',' ',' '/
      DATA
     + LNF(1), LNF(2), LNF(3), LNF(4), LNF(5), LNF(6), LNF(7), LNF(8)
     + /'N','F',' ',' ',' ',' ',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
C
      CALL EISGE(NMSUB, LNF, NF, (N+2)/2, 1, HEAD, ERR02, LNF)
C
      IF (ERR01) GO TO 5
C
      IF (NPRT .EQ. 0) THEN
        LDSMIN = 0
      ELSE
        CALL LDSCMP(3, 0, NF+103, 0, 0, 0, 'D', 2*NF+206, LDSMIN)
      END IF
C
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR03, LLDS)
C
      IF (ERR02 .OR. ERR03) GO TO 5
      GO TO 10
C
    5 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   10 CONTINUE
C
C     SET THE SIZE OF THE WORK AREA
C
      CALL STKSET(LDSTAK, 4)
C
C     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
C
      NALL0 = STKST(1)
C
C     SET VARIOUS PROGRAM PARAMETERS.
C
      LPCV = NF + 103
C
C     SUBDIVIDE THE STACK.
C
      IF (NPRT .EQ. 0) THEN
         ISYM = 1
         XAXIS = 1
         YAXIS = 1
      ELSE
         ISYM = STKGET(LPCV, 2)
         XAXIS = STKGET(LPCV, 4)
         YAXIS = STKGET(LPCV, 4)
      END IF
C
C     CALL THE MAIN DRIVER FOR COMPUTING (AND PLOTTING) THE INTEGRATED
C     PERIODOGRAM.
C
      CALL IPGDV (PER, NF, N, PERI, FREQ, RSTAK(XAXIS),
     +   RSTAK(YAXIS), ISTAK(ISYM), LPCV, NPRT)
C
      CALL STKCLR(NALL0)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL IPGMPS (PER, FREQ, NF, N, LDSTAK, PERI, NPRT)')
      END
*IPGMS
      SUBROUTINE IPGMS (YFFT, N, LYFFT, LDSTAK, NF, PERI, LPERI, FREQ,
     +   LFREQ, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
C     THE INTEGRATED PERIODOGRAM OF A SERIES (LONG CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,LFREQ,LPERI,LYFFT,N,NF,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),PERI(*),YFFT(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IEXTND,IPRT,ISYM,LDSMIN,LPCV,NALL0,NFFT,XAXIS,YAXIS
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,HEAD
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   LLDS(8)*1,LLFREQ(8)*1,LLPERI(8)*1,LLYFFT(8)*1,LN(8)*1,
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CNTR,EISGE,IPGDV,IPRINT,LDSCMP,PGMMN,SETESL,STKCLR,STKSET
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION FREQ(LFREQ)
C        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
C        INTEGRATED SPECTRUM VALUES ARE STORED.
C     LOGICAL HEAD
C        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
C        ERROR MESSAGES (TRUE) OR NOT (FALSE).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IEXTND
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
C        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
C        USED TO EXTEND THE SERIES.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LFREQ
C        THE LENGTH OF THE VECTOR FREQ.
C     CHARACTER*1 LLDS(8), LLFREQ(8), LLPERI(8), LLYFFT(8), LN(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
C        FOR ERRORS.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LPERI
C        THE LENGTH OF THE VECTOR PERI.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS.
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING ALLOCATIONS OF THE STACK AT THE
C        TIME OF THIS CALL.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODGRAM IS
C        TO BE COMPUTED.
C     INTEGER NFFT
C        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
C        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
C        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A PAGE PLOT.
C     DOUBLE PRECISION PERI(LPERI)
C        THE VECTOR IN WHICH THE INTEGRATED PERIODOGRAM IS STORED.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY IN WHICH THE X AXIS VALUES TO BE PLOTTED ARE STORED.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
C     DOUBLE PRECISION YFFT(LYFFT)
C        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'I',       'P',       'G',       'M',       'S',       ' '/
      DATA
     + LLFREQ(1), LLFREQ(2), LLFREQ(3), LLFREQ(4), LLFREQ(5),
     +  LLFREQ(6), LLFREQ(7), LLFREQ(8)
     +  /'L','F','R','E','Q',' ',' ',' '/
      DATA
     + LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     +  LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA
     + LLPERI(1), LLPERI(2), LLPERI(3), LLPERI(4), LLPERI(5),
     +  LLPERI(6), LLPERI(7), LLPERI(8)
     +  /'L','P','E','R','I',' ',' ',' '/
      DATA
     + LLYFFT(1), LLYFFT(2), LLYFFT(3), LLYFFT(4), LLYFFT(5),
     +  LLYFFT(6), LLYFFT(7), LLYFFT(8)
     +  /'L','Y','F','F','T',' ',' ',' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /'N',' ',' ',' ',' ',' ',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
      IF (ERR01) GO TO 5
C
C     SET LENGTH OF EXTENDED SERIES
C
      CALL SETESL(N, 2, NFFT)
      NF = NFFT/2
C
      CALL EISGE(NMSUB, LLYFFT, LYFFT, NFFT, 9, HEAD, ERR02, LLYFFT)
C
      CALL EISGE(NMSUB, LLPERI, LPERI, NF, 9, HEAD, ERR03, LLPERI)
C
      CALL EISGE(NMSUB, LLFREQ, LFREQ, NF, 9, HEAD, ERR04, LLFREQ)
C
      IF (NPRT .EQ. 0) THEN
        LDSMIN = 0
      ELSE
        CALL LDSCMP(3, 0, NF+103, 0, 0, 0, 'D', 2*NFFT+206, LDSMIN)
      END IF
C
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR05, LLDS)
C
      IF (ERR02 .OR. ERR03 .OR. ERR04 .OR. ERR05) GO TO 5
      GO TO 10
C
    5 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   10 CONTINUE
C
C     SET THE SIZE OF THE WORK AREA
C
      CALL STKSET(LDSTAK, 4)
C
C     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
C
      NALL0 = STKST(1)
C
C     SET VARIOUS PROGRAM PARAMETERS.
C
      LPCV = NF + 103
C
C     CENTER THE SERIES
C
      CALL CNTR(YFFT, N, YFFT)
      IEXTND = 0
C
C     SUBDIVIDE THE STACK.
C
      IF (NPRT .EQ. 0) THEN
         ISYM = 1
         XAXIS = 1
         YAXIS = 1
      ELSE
         ISYM = STKGET(LPCV, 2)
         XAXIS = STKGET(LPCV, 4)
         YAXIS = STKGET(LPCV, 4)
      END IF
C
C     COMPUTE THE RAW PERIODOGRAM.
C
      CALL PGMMN (YFFT, N, NFFT, IEXTND, NF, PERI, LPERI, RSTAK(YAXIS),
     +   FREQ, LFREQ, 0, NMSUB)
C
C     CALL THE MAIN DRIVER FOR COMPUTING (AND PLOTTING) THE INTEGRATED
C     PERIODOGRAM.
C
      CALL IPGDV (PERI, NF, N, PERI, FREQ, RSTAK(XAXIS),
     +   RSTAK(YAXIS), ISTAK(ISYM), LPCV, NPRT)
C
      CALL STKCLR(NALL0)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL IPGMS (YFFT, N, LYFFT, LDSTAK,'/
     +  '      +            NF, PERI, LPERI, FREQ, LFREQ, NPRT)')
      END
*IPGORD
      SUBROUTINE IPGORD (PERI, NF, N, FREQ, XAXIS, YAXIS, ISYM, NPTS,
     +   LPCV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRODUCES CO-ORDINATES FOR THE SPECTRAL PLOTS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LPCV,N,NF,NPTS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),PERI(NF),XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISYM(LPCV)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CI,CIMID
      INTEGER
     +   I,II,NLIM
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   S(40)
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MOD,DBLE,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CI, CIMID
C        THE WIDTH AND MIDPOINT OF THE TEST INTERVAL FOR WHITE NOISE.
C     DOUBLE PRECISION FREQ(NF)
C        THE ARRAY IN WHICH THE FREQUENCIES AT WHICH THE PERIODOGRAM
C        WAS ESTIMATED ARE STORED.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER II
C        AN INDEX VARIABLE
C     INTEGER ISYM(LPCV)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER N
C        THE ACTUAL NUMBER OF OBSERVATIONS IN THE SERIES FROM WHICH
C        THE PERIODOGRAM WAS COMPUTED.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
C        ARE ESTIMATED.
C     INTEGER NLIM
C        THE NUMBER OF POINTS AT WHICH THE WHITE NOISE LIMITS ARE TO
C        PLOTTED.
C     INTEGER NPTS
C        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
C     DOUBLE PRECISION PERI(NF)
C        THE ARRAY CONTAINING THE INTEGRATED PERIODOGRAM VALUES.
C     DOUBLE PRECISION S(40)
C        VALUES USED TO COMPUTE THE CONFIDENCE LIMITS.
C     DOUBLE PRECISION XAXIS(LPCV), YAXIS(LPCV)
C        THE X, Y CO-ORDINATES FOR THE SPECTRAL PLOTS.
C
      DATA S(1)/0.975D0/, S(2)/0.842D0/, S(3)/0.708D0/
      DATA S(4)/0.624D0/, S(5)/0.563D0/
      DATA S(6)/0.519D0/, S(7)/0.483D0/, S(8)/0.454D0/
      DATA S(9)/0.430D0/, S(10)/0.409D0/
      DATA S(11)/0.391D0/, S(12)/0.375D0/, S(13)/0.361D0/
      DATA S(14)/0.349D0/, S(15)/0.338D0/
      DATA S(16)/0.327D0/, S(17)/0.318D0/, S(18)/0.309D0/
      DATA S(19)/0.301D0/, S(20)/0.294D0/
      DATA S(21)/0.287D0/, S(22)/0.281D0/, S(23)/0.275D0/
      DATA S(24)/0.269D0/, S(25)/0.264D0/
      DATA S(26)/0.259D0/, S(27)/0.254D0/, S(28)/0.250D0/
      DATA S(29)/0.246D0/, S(30)/0.242D0/
      DATA S(31)/0.238D0/, S(32)/0.234D0/, S(33)/0.231D0/
      DATA S(34)/0.227D0/, S(35)/0.224D0/
      DATA S(36)/0.221D0/, S(37)/0.218D0/, S(38)/0.215D0/
      DATA S(39)/0.213D0/, S(40)/0.210D0/
C
      I = N + MOD(N,2) - 1
C
      IF (I .LE. 40) THEN
         CI = S(I)
      ELSE
         CI = 1.36D0 / SQRT(DBLE(I))
      END IF
C
      DO 10 I = 1, NF
         XAXIS(I) = FREQ(I)
         YAXIS(I) = PERI(I)
         ISYM(I) = 1
   10 CONTINUE
C
      NLIM = 101
C
      II = NF
C
      DO 30 I = 1, NLIM, 2
         CIMID = DBLE(I-1) / DBLE(NLIM-1)
         IF (CIMID - CI .LT. 0.0D0) GO TO 20
         II = II + 1
         XAXIS(II) = CIMID / 2.0D0
         YAXIS(II) = CIMID - CI
         ISYM(II) = 2
   20    IF (CIMID + CI .GT. 1.0D0) GO TO 30
         II = II + 1
         XAXIS(II) = CIMID / 2.0D0
         YAXIS(II) = CIMID + CI
         ISYM(II) = 2
   30 CONTINUE
C
      NPTS = II
C
      RETURN
      END
*IPGOUT
      SUBROUTINE IPGOUT (XAXIS, YAXIS, ISYM, NPTS, LPCV, ISPCER)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRODUCES THE INTEGRATED PERIODOGRAM PLOTS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISPCER,LPCV,NPTS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISYM(LPCV)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPMN,VERSP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IPRT
C        THE LOGICAL UNIT NUMBER FOR THE OUTPUT.
C     INTEGER ISPCER
C        AN ERROR INDICATOR FOR THE INTEGRATED PERIODOGRAM COMPUTATIONS.
C     INTEGER ISYM(LPCV)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER NPTS
C        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
C     DOUBLE PRECISION XAXIS(LPCV), YAXIS(LPCV)
C        THE X, Y CO-ORDINATES FOR THE SPECTRAL PLOTS.
C
C
C     SET LOGICAL UNIT NUMBER FOR OUTPUT AND SET OUTPUT WIDTH.
C
      CALL IPRINT (IPRT)
C
      CALL VERSP(.TRUE.)
      WRITE (IPRT, 1000)
C
      IF (ISPCER .EQ. 0) GO TO 5
C
      WRITE (IPRT, 1003)
      RETURN
C
    5 CONTINUE
C
      CALL PPMN (YAXIS, YAXIS, XAXIS, XAXIS, NPTS, 1, LPCV, 1, ISYM,
     +  LPCV, 0, -1, 0.0D0, 1.0D0, 0.0D0, 0.5D0, .FALSE., 0)
      WRITE(IPRT, 1002)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(34H INTEGRATED SAMPLE PERIODOGRAM (+)/
     +   5X, 49H WITH 95 PER CENT TEST LIMITS FOR WHITE NOISE (.))
C1001 FORMAT(5H+FREQ/
C    1   7H PERIOD, 9X, 3HINF, 7X, 3H10., 4X, 2H5., 8X, 6H3.3333, 4X,
C    2   3H2.5, 4X, 2H2.)
 1002 FORMAT(5H+FREQ/
     +   7H PERIOD, 9X, 3HINF, 7X, 3H20., 7X, 3H10., 8X, 6H6.6667, 4X,
     +   2H5., 8X, 2H4., 8X, 6H3.3333, 4X, 6H2.8571, 4X, 3H2.5, 7X,
     +   6H2.2222, 4X, 2H2.)
 1003 FORMAT (///42H THE INTEGRATED PERIODOGRAM OF THIS SERIES,
     +   22H COULD NOT BE COMPUTED/
     +   44H BECAUSE THE VARIANCE OF THE SERIES IS ZERO.)
      END
*IPRINT
      SUBROUTINE IPRINT(IPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SETS THE LOGICAL UNIT FOR PRINTED OUTPUT.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IPRT
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   I1MACH
      EXTERNAL I1MACH
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IPRT
C        THE UNIT NUMBER FOR OUTPUT.
C
      IPRT = I1MACH(2)
      RETURN
      END
*LDSCMP
      SUBROUTINE LDSCMP (NARR, NLOG, NINT, NREAL, NDBL, NCMP,
     +   FLAG, NFP, LDSMIN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     COMPUTES LDSMIN, THE MINIMUM NUMBER OF DOUBLE PRECISION LOCATIONS
C     NEEDED BY THE FRAMEWORK TO STORE NARR ARRAYS, COMPRISING NLOG
C     LOGICAL LOCATIONS, NINT INTEGER LOCATIONS, NREAL REAL LOCATIONS,
C     NDBL DOUBLE PRECISION LOCATIONS, AND NCMP COMPLEX LOCATIONS,
C     TOGETHER WITH THE NOVER OVERHEAD INTEGER LOCATIONS THAT THE
C     FRAMEWORK ALWAYS USES AND THE 3 OVERHEAD LOCATIONS THAT IT USES
C     PER ARRAY STORED.  (ALL THE LOCATIONS ARE ASSIGNED OUT OF THE
C     LABELED COMMON CSTAK, USING A STACK DISCIPLINE.)
C
C     IT IS ASSUMED, BASED UPON THE FORTRAN STANDARD (ANSI X3.9 1966),
C     THAT DOUBLE PRECISION AND COMPLEX DATA ELEMENTS ARE TWICE AS LONG
C     AS INTEGER AND LOGICAL ELEMENTS.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSMIN,NARR,NCMP,NDBL,NFP,NINT,NLOG,NREAL
      CHARACTER
     +   FLAG*1
C
C  LOCAL SCALARS
      INTEGER
     +   NOVER
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     CHARACTER*1 FLAG
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE NFP
C        ELEMENTS ARE REAL OR DOUBLE PRECISION, WHERE FLAG=S INDICATES
C        THE NFP ELEMENTS ARE REAL (SINGLE PRECISION), AND FLAG=D
C        INDICATES THE ELEMENTS ARE DOUBLE PRECISION.
C     INTEGER LDSMIN
C        OUTPUT PARAMETER.  THE MINIMUM NUMBER OF DOUBLE PRECISION
C        LOCATIONS IN CSTAK REQUIRED FOR THE QUANTITIES OF ARRAY
C        ELEMENTS AND ARRAYS SPECIFIED BY THE INPUT PARAMETERS.
C     INTEGER NARR
C        INPUT PARAMETER.  THE NUMBER OF ARRAYS TO BE STORED IN CSTAK.
C     INTEGER NCMP
C        INPUT PARAMETER.  THE NUMBER OF COMPLEX ELEMENTS IN THE
C        ARRAYS TO BE STORED IN CSTAK.
C     INTEGER NDBL
C        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION ELEMENTS IN
C        THE ARRAYS TO BE STORED, IN CSTAK.
C     INTEGER NFP
C        THE NUMBER OF ELEMENTS WHICH DEPEND ON THE PRECISION OF THE
C        VERSION OF STARPAC BEING USED.
C     INTEGER NINT
C        INPUT PARAMETER.  THE NUMBER OF INTEGER ELEMENTS IN THE
C        ARRAYS TO BE STORED IN CSTAK.
C     INTEGER NLOG
C        INPUT PARAMETER.  THE NUMBER OF LOGICAL ELEMENTS IN THE
C        ARRAYS TO BE STORED IN CSTAK.
C     INTEGER NOVER
C        THE NUMBER OF INTEGER LOCATIONS THAT THE FRAMEWORK ALWAYS
C        USES FOR OVERHEAD PURPOSES.
C     INTEGER NREAL
C        INPUT PARAMETER.  THE NUMBER OF REAL ELEMENTS IN THE ARRAYS
C        TO BE STORED IN CSTAK.
C
C     DEFINE CONSTANTS
C
      DATA NOVER /10/
C
C     COMMENCE BODY OF ROUTINE
C
      LDSMIN = (NLOG + NINT + NREAL + 3*NARR + NOVER + 1)/2
     +       + NDBL + NCMP
      IF (FLAG.EQ.'S') THEN
         LDSMIN = LDSMIN + (NFP+1)/2
      ELSE
         LDSMIN = LDSMIN + NFP
      END IF
      RETURN
      END
*LLCNT
      SUBROUTINE LLCNT(Y, WT, LWT, XM, N, M, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV,
     +   IVCV, LLHDR, IFIT, NMSUB, WEIGHT, SAVE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE CONTROLLING SUBROUTINE FOR LINEAR LEAST
C     SQUARES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IFIT,IVCV,IXM,LDSTAK,LPAR,LPV,LSDPV,LSDRES,LWT,M,N,NPAR,
     +   NPRT
      LOGICAL
     +   SAVE,WEIGHT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SDPV(*),SDRES(*),VCV(*),WT(*),XM(*),Y(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL LLHDR
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   ACC,C,FC,IFP,NALL0,NDIGIT,NNZW,PAR1,PARI,PVI,RED,RESI,
     +   RSDI,SDPVI,SDRESI,T,VCVI,WTI,WY,XMW
      LOGICAL
     +   PAGE,WIDE
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   IPTOUT(4),ISTAK(12)
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CPYMSS,LLER,LLSMN,PRTCNT,DCOPY,SETRV,STKCLR,STKSET
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER ACC
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE NUMBER OF ACCURATE DIGITS.
C     INTEGER C
C        *
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER FC
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE ORTHONORMALIZATION MATRIX.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
C        DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IFIT
C        THE INDICATOR VALUE DESIGNATING WHETHER THE FIT IS OF A
C        GENERAL MODEL (IFIT=3) OR A POLYNOMIAL MODEL (IFIT=1).
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IPTOUT(4)
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE MATRIX XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     EXTERNAL LLHDR
C        THE NAME OF THE ROUTINE THAT PRODUCED THE HEADING.
C     INTEGER LPAR
C        THE ACTUAL LENGTH OF THE VECTOR P.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NALL0
C        NUMBER OF ALLOCATIONS ON ENTRY.
C     INTEGER NDIGIT
C        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
C        PRINTED OUTPUT.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(LPAR)
C        THE PARAMETERS TO BE ESTIMATED.
C     INTEGER PARI
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE PARAMETERS TO BE ESTIMATED.
C     INTEGER PAR1
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE PARAMETERS TO BE ESTIMATED OMMITTING THE LAST
C        INDEPENDENT VARIABLE.
C     DOUBLE PRECISION PV(LPV)
C        THE PREDICTED VALUES.
C     INTEGER PVI
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE PREDICTED VALUES.
C     INTEGER RED
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE REDUCTION TO THE SUM OF SQUARES DUE TO EACH PARAMETER.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS.
C     INTEGER RESI
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE RESIDUALS.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     INTEGER RSDI
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE RESIDUAL STANDARD DEVIATION.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION SDPV(LSDPV)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     INTEGER SDPVI
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(LSDRES)
C        THE STANDARDIZED RESIDUALS.
C     INTEGER SDRESI
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE STANDARDIZED RESIDUALS.
C     INTEGER T
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE TRIANGULAR MATRIX FROM THE DECOMPOSITION.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE VARIANCE COVARIANCE MATRIX.
C     INTEGER VCVI
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE WEIGHTS.
C     INTEGER WTI
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE WEIGHTS.
C     INTEGER WY
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE VECTOR CONTAINING SQRT(WT)*Y.
C     DOUBLE PRECISION XM(IXM,M)
C        THE INDEPENDENT VARIABLE.
C     INTEGER XMW
C        THE STARTING LOCATION IN THE WORK AREA FOR
C        THE MATRIX CONTAINING XM * SQRT(WT).
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C
      WIDE = .TRUE.
      PAGE = .FALSE.
      NDIGIT = 4
C
      IFP = 4
C
C     SET PRINT CONTROL VALUES
C
      CALL PRTCNT(NPRT, NDIGIT, IPTOUT)
C
C     CHECK FOR ERRORS
C
      CALL LLER(NMSUB, IXM, IVCV, N, NPAR, LPAR, LDSTAK, WT, LWT,
     +   WEIGHT, NNZW, IFIT, SAVE)
      IF (IERR.NE.0) RETURN
C
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
C
C     SET UP SUBDIVISION OF WORK AREAS
C
      WTI = STKGET(N,IFP)
      RESI = STKGET(N,IFP)
      RSDI = STKGET(1,IFP)
      PARI = STKGET(NPAR,IFP)
      PVI = STKGET(N,IFP)
      SDPVI = STKGET(N,IFP)
      SDRESI = STKGET(N,IFP)
      VCVI = STKGET(NPAR*NPAR,IFP)
C
      WY = STKGET(N,IFP)
      XMW = STKGET(N*NPAR,IFP)
      RED = STKGET(NPAR,IFP)
      T = STKGET(NPAR*NPAR,IFP)
      PAR1 = STKGET(NPAR,IFP)
      ACC = STKGET(NPAR,IFP)
      C = STKGET(NPAR,IFP)
C
C     EQUIVALENCED LOCATIONS WITHIN SCRAT
C
      FC = XMW
C
C     SET UP WEIGHTS VECTOR
C
      IF (WEIGHT) THEN
         CALL DCOPY(N, WT, 1, RSTAK(WTI), 1)
      ELSE
         CALL SETRV(RSTAK(WTI), N, 1.0D0)
      END IF
C
      CALL LLSMN(Y, XM, RSTAK(WTI), N, M, NPAR, IXM, RSTAK(RESI),
     +   RSTAK(PARI), NNZW, RSTAK(RSDI), RSTAK(PVI), RSTAK(SDPVI),
     +   RSTAK(SDRESI), IPTOUT, RSTAK(WY), RSTAK(XMW), RSTAK(VCVI),
     +   RSTAK(FC), RSTAK(RED), RSTAK(T), RSTAK(PAR1), RSTAK(ACC), IFIT,
     +   WEIGHT, RSTAK(C), LLHDR, PAGE, WIDE)
C
      CALL DCOPY(N, RSTAK(RESI), 1, RES, 1)
C
      IF (SAVE) THEN
         RSD = RSTAK(RSDI)
         CALL DCOPY(NPAR, RSTAK(PARI), 1, PAR, 1)
         CALL DCOPY(N, RSTAK(PVI), 1, PV, 1)
         CALL DCOPY(N, RSTAK(SDPVI), 1, SDPV, 1)
         CALL DCOPY(N, RSTAK(SDRESI), 1, SDRES, 1)
         CALL CPYMSS(NPAR, NPAR, RSTAK(VCVI), NPAR, VCV, IVCV)
      END IF
      CALL STKCLR(NALL0)
C
      IF (IERR.EQ.3) IERR = 2
      IF (IERR.EQ.4) IERR = 3
C
      RETURN
C
      END
*LLCNTG
      SUBROUTINE LLCNTG(Y, WT, LWT, XM, N, IXM, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE CONTROLLING SUBROUTINE FOR GENERAL LINEAR LEAST
C     SQUARES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,IXM,LDSTAK,LPAR,LPV,LSDPV,LSDRES,LWT,N,NPAR,NPRT
      LOGICAL
     +   SAVE,WEIGHT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SDPV(*),SDRES(*),VCV(*),WT(*),XM(*),Y(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IFIT,M
C
C  EXTERNAL SUBROUTINES
      EXTERNAL LLCNT,LLHDRG
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
C        DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IFIT
C        THE INDICATOR VALUE DESIGNATING WHETHER THE LLS IS OF A
C        GENERAL MODEL (IFIT=3) OR A POLYNOMIAL MODEL (IFIT=1).
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE MATRIX XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     EXTERNAL LLHDRG
C        THE NAME OF THE ROUTINE THAT PRODUCED THE HEADING.
C     INTEGER LPAR
C        THE ACTUAL LENGTH OF THE VECTOR P.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
C        PRINTED OUTPUT.
C     DOUBLE PRECISION PAR(LPAR)
C        THE PARAMETERS TO BE ESTIMATED.
C     DOUBLE PRECISION PV(LPV)
C        THE PREDICTED VALUES.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION SDPV(LSDPV)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(LSDRES)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
C     DOUBLE PRECISION XM(IXM,M)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C
      IFIT = 3
      M = NPAR
C
      CALL LLCNT(Y, WT, LWT, XM, N, M, IXM, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   LLHDRG, IFIT, NMSUB, WEIGHT, SAVE)
C
      RETURN
C
      END
*LLCNTP
      SUBROUTINE LLCNTP(Y, WT, LWT, XM, N, NDEG, NPAR, RES, LDSTAK,
     +   NPRT, PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV,
     +   IVCV, NMSUB, WEIGHT, SAVE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE CONTROLLING SUBROUTINE FOR POLYNOMIAL LINEAR LEAST
C     SQUARES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,LDSTAK,LPAR,LPV,LSDPV,LSDRES,LWT,N,NDEG,NPAR,NPRT
      LOGICAL
     +   SAVE,WEIGHT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SDPV(*),SDRES(*),VCV(*),WT(*),XM(*),Y(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IFIT,IXM,M
C
C  EXTERNAL SUBROUTINES
      EXTERNAL LLCNT,LLHDRP
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
C        DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IFIT
C        THE INDICATOR VALUE DESIGNATING WHETHER THE LLS IS OF A
C        GENERAL MODEL (IFIT=3) OR A POLYNOMIAL MODEL (IFIT=1).
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE MATRIX XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     EXTERNAL LLHDRP
C        THE NAME OF THE ROUTINE THAT PRODUCED THE HEADING.
C     INTEGER LPAR
C        THE ACTUAL LENGTH OF THE VECTOR P.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NDEG
C        THE DEGREE OF THE MODEL.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
C        PRINTED OUTPUT.
C     DOUBLE PRECISION PAR(LPAR)
C        THE PARAMETERS TO BE ESTIMATED.
C     DOUBLE PRECISION PV(LPV)
C        THE PREDICTED VALUES.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION SDPV(LSDPV)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(LSDRES)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
C     DOUBLE PRECISION XM(N,1)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C
      IFIT = 1
      NPAR = NDEG + 1
      M = 1
      IXM = N
C
      CALL LLCNT(Y, WT, LWT, XM, N, M, IXM, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   LLHDRP, IFIT, NMSUB, WEIGHT, SAVE)
C
      RETURN
C
      END
*LLER
      SUBROUTINE LLER(NMSUB, IXM, IVCV, N, NPAR, LPAR, LDSTAK, WT, LNWT,
     +   WEIGHT, NNZW, IFIT, SAVE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE ERROR CHECKING ROUTINE FOR THE LINEAR LEAST
C     SQUARES LLSTING ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IFIT,IVCV,IXM,LDSTAK,LNWT,LPAR,N,NNZW,NPAR
      LOGICAL
     +   SAVE,WEIGHT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   WT(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I,LDSMIN,NZW
      LOGICAL
     +   HEAD
C
C  LOCAL ARRAYS
      LOGICAL
     +   ERROR(10)
      CHARACTER
     +   LIVCV(8)*1,LIXM(8)*1,LLDS(8)*1,LLPAR(8)*1,LN(8)*1,
     +   LN1(8)*1,LNC(8)*1,LNDEG(8)*1,LNDEG1(8)*1,LNPAR(8)*1,
     +   LONE(8)*1,LWT(8)*1,LZERO(8)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,ERVWT,LDSCMP
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR(10)
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIT
C        THE INDICATOR VALUE DESIGNATING WHETHER THE LLS IS OF A
C        GENERAL MODEL (IFIT=3) OR A POLYNOMIAL MODEL (IFIT=1).
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     CHARACTER*1 LIVCV(8), LIXM(8), LLPAR(8), LLDS(8), LN(8), LNC(8),
C    *   LNDEG(8), LNDEG1(8), LNPAR(8), LN1(8), LONE(8), LWT(8),
C    *   LZERO(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
C        CHECKED FOR ERRORS.
C     INTEGER LPAR
C        THE ACTUAL LENGTH OF THE VECTOR P.
C     INTEGER LNWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NZW
C        THE NUMBER OF ZERO WEIGHTS.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LNWT)
C        THE USER SUPPLIED WEIGHTS.
C
C     SET UP NAME ARRAYS
C
      DATA LIVCV(1), LIVCV(2), LIVCV(3), LIVCV(4), LIVCV(5), LIVCV(6),
     +   LIVCV(7), LIVCV(8) /'I','V','C','V',' ',' ',' ',' '/
      DATA LIXM(1), LIXM(2), LIXM(3), LIXM(4), LIXM(5), LIXM(6),
     +   LIXM(7), LIXM(8) /'I','X','M',' ',' ',' ',' ',' '/
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +   LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA LLPAR(1), LLPAR(2), LLPAR(3), LLPAR(4), LLPAR(5), LLPAR(6),
     +   LLPAR(7), LLPAR(8) /'L','P','A','R',' ',' ',' ',' '/
      DATA LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8) /'N',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LNDEG(1), LNDEG(2), LNDEG(3), LNDEG(4), LNDEG(5), LNDEG(6),
     +   LNDEG(7), LNDEG(8) /'N','D','E','G',' ',' ',' ',' '/
      DATA LNDEG1(1), LNDEG1(2), LNDEG1(3), LNDEG1(4), LNDEG1(5),
     +   LNDEG1(6), LNDEG1(7), LNDEG1(8) /'N','D','E','G','+','1',
     +   ' ',' '/
      DATA LNPAR(1), LNPAR(2), LNPAR(3), LNPAR(4), LNPAR(5),
     +   LNPAR(6), LNPAR(7), LNPAR(8) /'N','P','A','R',' ',' ',' ',
     +   ' '/
      DATA LN1(1), LN1(2), LN1(3), LN1(4), LN1(5), LN1(6),
     +   LN1(7), LN1(8) /'N','-','1',' ',' ',' ',' ',' '/
      DATA LONE(1), LONE(2), LONE(3), LONE(4), LONE(5), LONE(6),
     +   LONE(7), LONE(8) /'O','N','E',' ',' ',' ',' ',' '/
      DATA LWT(1), LWT(2), LWT(3), LWT(4), LWT(5), LWT(6), LWT(7),
     +   LWT(8) /'W','T',' ',' ',' ',' ',' ',' '/
      DATA LZERO(1), LZERO(2), LZERO(3), LZERO(4), LZERO(5), LZERO(6),
     +   LZERO(7), LZERO(8) /'Z','E','R','O',' ',' ',' ',' '/
C
C     ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
      DO 10 I=1,10
         ERROR(I) = .FALSE.
   10 CONTINUE
C
      IF (IFIT.EQ.1) GO TO 30
C
      DO 20 I = 1, 8
         LNC(I) = LNPAR(I)
   20 CONTINUE
      GO TO 50
C
   30 CONTINUE
      DO 40 I = 1, 8
         LNC(I) = LNDEG1(I)
   40 CONTINUE
C
   50 CONTINUE
C
      CALL EISGE(NMSUB, LN, N, 1, 1, HEAD, ERROR(1), LN)
C
      IF (IFIT.EQ.3)
     +   CALL EISII(NMSUB, LNPAR, NPAR, 1, N, 1, HEAD, ERROR(2), LONE,
     +   LN)
      IF (IFIT.EQ.1)
     +   CALL EISII(NMSUB, LNDEG, NPAR-1, 0, N-1, 1, HEAD, ERROR(2),
     +      LZERO, LN1)
C
      CALL EISGE(NMSUB, LIXM, IXM, N, 3, HEAD, ERROR(4), LN)
C
      IF (SAVE .AND. (IFIT.EQ.1))
     +   CALL EISGE(NMSUB, LLPAR, LPAR, NPAR, 7, HEAD, ERROR(5), LNDEG1)
C
      IF (SAVE)
     +    CALL EISGE(NMSUB, LIVCV, IVCV, NPAR, 3, HEAD, ERROR(6), LNC)
C
      IF (ERROR(1) .OR. ERROR(2) .OR. ERROR(3)) GO TO 70
C
      NNZW = N
      IF (WEIGHT) CALL ERVWT(NMSUB, LWT, WT, N, NPAR, HEAD, NNZW,
     +   NZW, 2, ERROR(8), LNC)
C
      CALL LDSCMP(15, 0, 0, 0, 0, 0, 'D',
     +            6*N + NPAR*(N+2*NPAR+5) + 1, LDSMIN)
C
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR(9), LLDS)
C
      DO 60 I=1,10
         IF (ERROR(I)) GO TO 70
   60 CONTINUE
      RETURN
C
   70 CONTINUE
      IERR = 1
      RETURN
C
      END
*LLHDRG
      SUBROUTINE LLHDRG(PAGE, WIDE, ISUBHD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS THE PAGE HEADINGS FOR THE UNRESTRICTED
C     LINEAR LEAST SQUARES ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISUBHD
      LOGICAL
     +   PAGE,WIDE
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VERSP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C
C
      CALL IPRINT(IPRT)
      IF (PAGE) WRITE (IPRT,1020)
      CALL VERSP(WIDE)
      IF (PAGE) WRITE (IPRT,1000)
      IF (.NOT.PAGE) WRITE (IPRT,1010)
      PAGE = .TRUE.
C
      IF (ISUBHD.EQ.0) RETURN
C
      GO TO (10), ISUBHD
C
   10 WRITE (IPRT,1030)
C
      RETURN
C
C     FORMAT STATEMENTS FOR PAGE HEADINGS
C
 1000 FORMAT (32H+LINEAR LEAST SQUARES ESTIMATION,
     +  ' WITH USER-SPECIFIED MODEL, CONTINUED')
 1010 FORMAT ('+', 63('*')/
     +   1X, 34H*  LINEAR LEAST SQUARES ESTIMATION,
     +   ' WITH USER-SPECIFIED MODEL  *'/ 1X, 63('*'))
 1020 FORMAT ('1')
 1030 FORMAT (//30H SUMMARY OF INITIAL CONDITIONS/ 1X, 30('-'))
      END
*LLHDRP
      SUBROUTINE LLHDRP(PAGE, WIDE, ISUBHD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS THE PAGE HEADINGS FOR THE POLYNOMIAL LINEAR
C     LEAST SQUARES LLSTING ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISUBHD
      LOGICAL
     +   PAGE,WIDE
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VERSP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C
      CALL IPRINT(IPRT)
      IF (PAGE) WRITE (IPRT,1020)
      CALL VERSP(WIDE)
      IF (PAGE) WRITE (IPRT,1000)
      IF (.NOT.PAGE) WRITE (IPRT,1010)
      PAGE = .TRUE.
C
      IF (ISUBHD.EQ.0) RETURN
C
      GO TO (10), ISUBHD
C
   10 WRITE (IPRT,1030)
C
      RETURN
C
C     FORMAT STATEMENTS FOR PAGE HEADINGS
C
 1000 FORMAT (32H+LINEAR LEAST SQUARES ESTIMATION,
     +   33H WITH POLYNOMIAL MODEL, CONTINUED)
 1010 FORMAT ('+', 59('*')/
     +   1X, 34H*  LINEAR LEAST SQUARES ESTIMATION,
     +   25H WITH POLYNOMIAL MODEL  */ 1X,
     +   59('*'))
 1020 FORMAT ('1')
 1030 FORMAT (//30H SUMMARY OF INITIAL CONDITIONS/ 1X, 30('-'))
      END
*LLS
      SUBROUTINE LLS(Y, XM, N, IXM, NPAR, RES, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     CALL FOR GENERAL LINEAR MODEL LEAST SQUARES FIT
C     NO WEIGHTS SPECIFIED
C     NO STORAGE OTHER THAN RESIDUALS
C     FOUR PAGES AUTOMATIC PRINTOUT
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RES(*),XM(*),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LPAR,LPV,LSDPV,LSDRES,LWT,NPRT
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(1),PV(1),SDPV(1),SDRES(1),VCV(1,1),WT(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLCNTG
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
C        DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE MATRIX XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPAR
C        THE ACTUAL LENGTH OF THE VECTOR P.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
C        PRINTED OUTPUT.
C     DOUBLE PRECISION PAR(1)
C        A DUMMY ARRAY FOR
C        THE PARAMETERS  TO BE ESTIMATED.
C     DOUBLE PRECISION PV(1)
C        A DUMMY ARRAY FOR
C        THE PREDICTED VALUES.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION SDPV(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(1)
C        A DUMMY ARRAY FOR
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION VCV(1,1)
C        A DUMMY ARRAY FOR
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(1)
C        A DUMMY ARRAY FOR
C        THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,NPAR)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'L','L','S',' ',' ',' '/
C
C     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
C
      WEIGHT = .FALSE.
      SAVE = .FALSE.
      NPRT = 1111
      LPAR = 1
      LPV = 1
      LSDPV = 1
      LSDRES = 1
      IVCV = 1
      LWT = 1
C
      CALL LLCNTG(Y, WT, LWT, XM, N, IXM, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (//42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   50H       CALL LLS (Y, XM, N, IXM, NPAR, RES, LSDTAK))
      END
*LLSMN
      SUBROUTINE LLSMN(Y, X, WT, N, M, NPAR, IX, RES, PAR, NNZW,
     +   RSD, PV, SDPV, SDRES, IPTOUT, WY, XW, VCV, FC, RED,
     +   T, PAR1, ACC, IFIT, WEIGHT, C, LLHDR, PAGE, WIDE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN PROGRAM FOR THE LINEAR LEAST SQUARES FITTING
C     PROGRAMS
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IFIT,IX,M,N,NNZW,NPAR
      LOGICAL
     +   PAGE,WEIGHT,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACC(NPAR),C(NPAR),FC(N,NPAR),PAR(NPAR),PAR1(NPAR),PV(N),
     +   RED(NPAR),RES(N),SDPV(N),SDRES(N),T(NPAR,NPAR),
     +   VCV(NPAR,NPAR),WT(N),WY(N),X(IX,M),XW(N,NPAR),Y(N)
      INTEGER
     +   IPTOUT(4)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL LLHDR
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   COND,DF,FPLM,FPLRS,FPSPM,PROBT,PROBT1,PX,R2,RATIO,RATIO1,
     +   RSD1,RSS,RSS1,RVAR,RVAR1,SDC,SDC1,SM,TD,WTSQRT,WTSUM,WTYM,YSUM
      INTEGER
     +   I,IDF,IDF1,IER,IPRT,IREFIT,ISUBHD,J,K,NC
      LOGICAL
     +   CONST
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   DET(2)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFT,D1MACH
      EXTERNAL CDFT,D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACCDIG,FITPT1,FITPT2,IPRINT,MGS,OANOVA,VCVOUT
      EXTERNAL DTRCO,DTRDI
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,SQRT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACC(NPAR)
C        THE NUMBER OF ACCURATE DIGITS.
C     DOUBLE PRECISION C(NPAR)
C        A WORK VECTOR.
C     DOUBLE PRECISION COND
C        THE CONDITION NUMBER OF THE DESIGN MATRIX.
C     LOGICAL CONST
C        AN INDICATOR VALUE DESIGNATING WHETHER THE FIRST COLUMN OF
C        THE DESIGN MATRIX IS ALL ONES FOR A CONSTANT.
C     DOUBLE PRECISION DET(2)
C        THE DETERMINENT.
C     DOUBLE PRECISION DF
C        THE DEGREES OF FREEDOM.
C     DOUBLE PRECISION FC(N,NPAR)
C        THE ORTHONORMALIZATION MATRIX.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     DOUBLE PRECISION FPLRS
C        THE FLOATING POINT LARGEST RELATIVE SPACING.
C     DOUBLE PRECISION FPSPM
C        THE FLOATING POINT SMALLEST POSITIVE MAGNITUDE.
C     INTEGER I
C        AN INDEX.
C     INTEGER IDF
C        THE DEGREES OF FREEDOM
C     INTEGER IDF1
C        THE DEGREES OF FREEDOM FOR THE FIT WITHOUT THE LAST INDEPENDENT
C        VARIABLE.
C     INTEGER IER
C        THE ERROR FLAG RETURNED BY THE INVERSION ROUTINES.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
C        DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IFIT
C        THE INDICATOR VALUE DESIGNATING WHETHER THE FIT IS OF A
C        GENERAL MODEL (IFIT=3) OR A POLYNOMIAL MODEL (IFIT=1).
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IPTOUT(4)
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
C     INTEGER IREFIT
C        AN INDICATOR USED TO DESIGNATE WHETHER THE FIT IS OF THE
C        FULL DESIGN MATRIX (IREFIT=0) OR IS OMITTING THE LAST
C        INDEPENDENT VARIABLE (IREFIT=1).
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     INTEGER IX
C        THE FIRST DIMENSION OF THE MATRIX X.
C     INTEGER J
C        AN INDEX.
C     INTEGER K
C        AN INDEX.
C     EXTERNAL LLHDR
C        THE NAME OF THE ROUTINE THAT PRODUCED THE HEADING.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NC
C        THE NUMBER OF PARAMETERS BEING FIT.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE PARAMETERS  TO BE ESTIMATED.
C     DOUBLE PRECISION PAR1(NPAR)
C        THE PARAMETERS TO BE ESTIMATED OMMITTING THE LAST
C        INDEPENDENT VARIABLE.
C     DOUBLE PRECISION PROBT
C        ...
C     DOUBLE PRECISION PROBT1
C        ...
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUES.
C     DOUBLE PRECISION PX
C        A WORK VARIABLE.
C     DOUBLE PRECISION RATIO
C        THE RATIO OF THE PARAMETERS TO THEIR STANDARD DEVIATIONS.
C     DOUBLE PRECISION RATIO1
C        THE RATIO OF THE PARAMETERS COMPUTED OMITTING THE LAST
C        INDEPENDENT VARIABLE TO THEIR STANDARD DEVIATIONS.
C     DOUBLE PRECISION RED(NPAR)
C        THE REDUCTION TO THE SUM OF SQUARES DUE TO EACH PARAMETER.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     DOUBLE PRECISION RSD1
C        THE RESIDUAL STANDARD DEVIATION FROM THE FIT OMITTING
C        THE LAST INDEPENDENT VARIABLE.
C     DOUBLE PRECISION RSS
C        THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION RSS1
C        THE RESIDUAL SUM OF SQUARES FROM THE FIT OMITTING
C        THE LAST INDEPENDENT VARIABLE.
C     DOUBLE PRECISION RVAR
C        THE RESIDUAL VARIANCE.
C     DOUBLE PRECISION RVAR1
C        THE RESIDUAL VARIANCE FROM THE FIT OMITTING
C        THE LAST INDEPENDENT VARIABLE.
C     DOUBLE PRECISION R2
C        THE MULTIPLE CORRELATION PARAMETER.
C     DOUBLE PRECISION SDC
C        THE ESTIMATED STANDARD DEVIATIONS OF THE PARAMETERS.
C     DOUBLE PRECISION SDC1
C        THE ESTIMATED STANDARD DEVIATIONS OF THE PARAMETERS OMITTING
C        THE LAST INDEPENDENT VARIABLE.
C     DOUBLE PRECISION SDPV(N)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(N)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION SM
C        A WORK VARIABLE.
C     DOUBLE PRECISION T(NPAR,NPAR)
C        THE TRIANGULAR MATRIX FROM THE DECOMPOSITION.
C     DOUBLE PRECISION TD
C        A WORK VARIABLE.
C     DOUBLE PRECISION VCV(NPAR,NPAR)
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(N)
C        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
C     DOUBLE PRECISION WTSQRT
C        THE SQUARE ROOT OF THE WEIGHT.
C     DOUBLE PRECISION WTSUM
C        THE SUM OF THE WEIGHTS.
C     DOUBLE PRECISION WTYM
C        THE SUM OF THE WEIGHTED DEPENDENT VARIABLES.
C     DOUBLE PRECISION WY(N)
C        THE VECTOR CONTAINING SQRT(WT)*Y.
C     DOUBLE PRECISION X(IX,M)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION XW(N,NPAR)
C        THE MATRIX CONTAINING X * SQRT(WT).
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C     DOUBLE PRECISION YSUM
C        THE SUM OF THE WEIGHTED DEPENDENT VARIABLES SQUARED.
C
      CALL IPRINT(IPRT)
C
C     INITIALIZE VARIABLES
C
      FPLM = D1MACH(2)
      FPLRS = D1MACH(4)
      FPSPM = D1MACH(1)
      NC = NPAR
      IDF = NNZW - NC
      DF = IDF
C
      R2 = 0.0
      RVAR1 = 0.0
      RSD1 = 0.0
      J = 0
      IDF1 = 0
      CONST = .FALSE.
C
      YSUM = 0.0D0
      WTSUM = 0.0D0
      DO 10 I=1,N
         IF (WT(I).LE.0.0D0) GO TO 10
         YSUM = YSUM + WT(I)*Y(I)*Y(I)
         WTSUM = WTSUM + WT(I)
   10 CONTINUE
C
C     BEGIN FIT
C
      IREFIT = -1
C
C     IF IREFIT IS EQUAL TO 1 FIT IS OMITTING THE LAST VARIABLE
C
   50 IREFIT = IREFIT + 1
C
C     COMPUTE WORKING VECTORS
C
      WTYM = 0.0D0
      I = 0
      DO 70 K=1,N
         IF (WT(K).LE.0.0D0) GO TO 70
         WTSQRT = SQRT(WT(K))
         I = I + 1
         PX = WTSQRT
         DO 60 J=1,NC
            IF (IFIT.EQ.1 .AND. J.GE.2) PX = PX*X(K,1)
            IF (IFIT.EQ.3) PX = X(K,J)*WTSQRT
            XW(I,J) = PX
   60    CONTINUE
C
C     COMPUTE WY ( WEIGHTS * Y VECTOR )
C
         WY(I) = Y(K)*WTSQRT
         WTYM = WTYM + WT(K)*Y(K)
   70 CONTINUE
      WTYM = WTYM/WTSUM
C
C     COMPUTE ESTIMATED VALUES OF PARAMETERS
C
      IF (IREFIT.EQ.1) GO TO 80
      IER = 0
      CALL MGS(XW, WY, NNZW, NC, PAR, C, T(1,1), T, NPAR, N, IER)
      IF (IER.EQ.0) GO TO 90
      IERR = 3
      ISUBHD = 0
      CALL LLHDR(PAGE, WIDE, ISUBHD)
      WRITE (IPRT,1160)
      WRITE (IPRT,1150)
      RETURN
   80 CONTINUE
      IER = 0
      CALL MGS(XW, WY, NNZW, NC, PAR1, C, T(1,1), T, NPAR, N, IER)
C
C     COMPUTE PREDICTED VALUES (PV) AND RESIDUALS (RES)
C             RESIDUAL SUM OF SQUARES (RSS) AND
C             RESIDUAL STANDARD DEVIATION (RSD) AND
C             SUM OF WEIGHTS (WTSUM) AND
C             RESIDUAL VARAINCE (RVAR)
C
   90 RSS = 0.0D0
      RSS1 = 0.0D0
      DO 120 I=1,N
         SM = 0.0D0
         PX = 1.0D0
         DO 100 J=1,NC
            IF (IFIT.EQ.1 .AND. J.GE.2) PX = PX*X(I,1)
            IF (IFIT.EQ.3) PX = X(I,J)
            IF (IREFIT.EQ.0) SM = SM + PAR(J)*PX
            IF (IREFIT.EQ.1) SM = SM + PAR1(J)*PX
  100    CONTINUE
         IF (IREFIT.EQ.0) THEN
            PV(I) = SM
            RES(I) = Y(I) - PV(I)
            RSS = RSS + RES(I)*WT(I)*RES(I)
         ELSE
            RSS1 = RSS1 + (Y(I)-SM)*WT(I)*(Y(I)-SM)
         END IF
  120 CONTINUE
C
      IF (IREFIT.EQ.0) GO TO 130
      RVAR1 = RSS1/(DF+1.0D0)
      RSD1 = SQRT(RVAR1)
      GO TO 380
  130 RVAR = 0.0D0
      IF (DF.GT.0.0D0) RVAR = RSS/DF
      RSD = SQRT(RVAR)
C
C     COMPUTE MULTIPLE CORRELATION PARAMETER SQUARED (R2)
C
      SM = 0.0D0
      CONST = .TRUE.
      DO 140 I=1,N
         IF ((X(I,1).NE.1.0D0) .AND. (IFIT.EQ.3)) CONST = .FALSE.
         SM = SM + (Y(I)-WTYM)*WT(I)*(Y(I)-WTYM)
  140 CONTINUE
      R2 = 1.0D0
      IF (SM.GT.0.0D0) R2 = 1.0D0-RSS/SM
C
C     CHECK FOR -EXACT- FIT
C
      TD = 0.0D0
      IF (DF.GT.0.0D0) TD = SQRT(RSS)
      IF (YSUM.GT.0.0D0) TD = TD/SQRT(YSUM)
      IF (TD.GT.10.0D0*FPLRS) GO TO 180
C
      IERR = 0
      IF ((IPTOUT(1).EQ.0) .AND. (IPTOUT(2).EQ.0) .AND. (IPTOUT(3).EQ.0)
     +   .AND. (IPTOUT(4).EQ.0)) GO TO 145
      ISUBHD = 0
      CALL LLHDR(PAGE, WIDE, ISUBHD)
      WRITE (IPRT,1180)
      WRITE (IPRT,1020) (I,PAR(I),I=1,NPAR)
C
C     ZERO OUT VCV MATRIX AND SDRES AND SDPV VECTORS
C
  145 CONTINUE
      DO 150 I=1,N
         SDPV(I) = 0.0D0
         SDRES(I) = 0.0D0
  150 CONTINUE
      DO 170 I=1,NPAR
         DO 160 J=1,NPAR
            VCV(I,J) = 0.0D0
  160    CONTINUE
  170 CONTINUE
      RETURN
C
  180 CONTINUE
C
C     COMPUTE ORTHO NORMALIZATION
C
      DO 200 I=1,NC
         T(I,I) = SQRT(T(I,1))
         DO 190 J=I,NC
            IF (I.EQ.J) GO TO 190
            T(I,J) = T(I,J)*T(I,I)
  190    CONTINUE
  200 CONTINUE
C
      CALL DTRCO(T, NPAR, NC, COND, C, 1)
      IF (COND.NE.0.0D0) THEN
         COND = 1.0D0/COND
      ELSE
         COND = FPLM
      END IF
      CALL DTRDI(T, NPAR, NC, DET, 011, IER)
C
      IF (IER.EQ.0) GO TO 210
      IERR = 3
      ISUBHD = 0
      CALL LLHDR(PAGE, WIDE, ISUBHD)
      WRITE (IPRT,1160)
      WRITE (IPRT,1120)
      RETURN
  210 CONTINUE
      DO 240 I=1,N
         DO 230 J=1,NC
            SM = 0.0D0
            PX = 1.0D0
            DO 220 K=1,J
               IF (IFIT.EQ.1 .AND. K.GE.2) PX = PX*X(I,1)
               IF (IFIT.EQ.3) PX = X(I,K)
               SM = SM + PX*T(K,J)
  220       CONTINUE
            FC(I,J) = SM
  230    CONTINUE
  240 CONTINUE
C
C     COMPUTE REDUCTION TO RSS DUE TO FITTING
C
      DO 260 J=1,NC
         SM = 0.0D0
         DO 250 I=1,N
            SM = SM + (FC(I,J))*WT(I)*Y(I)
  250    CONTINUE
         RED(J) = (SM*SM)
  260 CONTINUE
C
C     COMPUTE ESTIMATED VARIANCE COVARIANCE MATRIX
C
      DO 290 I=1,NC
         DO 280 J=I,NC
            SM = 0.0D0
            DO 270 K=J,NC
               SM = SM + T(I,K)*T(J,K)
  270       CONTINUE
            IF (SQRT(ABS(SM))*SQRT(RVAR).GE.SQRT(FPSPM)) THEN
               VCV(I,J) = SM*RVAR
            ELSE
               VCV(I,J) = 0.0D0
            END IF
            VCV(J,I) = VCV(I,J)
  280    CONTINUE
  290 CONTINUE
C
C     REFIT TO PREDICTED VALUES
C
      I = 0
      DO 310 K=1,N
         IF (WT(K).LE.0.0D0) GO TO 310
         WTSQRT = SQRT(WT(K))
         I = I + 1
         PX = WTSQRT
         DO 300 J=1,NC
            IF (IFIT.EQ.1 .AND. J.GE.2) PX = PX*X(K,1)
            IF (IFIT.EQ.3) PX = X(K,J)*WTSQRT
            XW(I,J) = PX
  300    CONTINUE
         WY(I) = PV(K)*WTSQRT
  310 CONTINUE
C
      IER = 0
      CALL MGS(XW, WY, NNZW, NC, PAR1, C, T(1,1), T, NPAR, N, IER)
C
      CALL ACCDIG(PAR, PAR1, ACC, NC)
C
C     COMPUTE STANDARD DEVIATION OF PREDICTED VALUES (SDPV)
C     AND STANDARDIZED RESIDUALS (SDRES)
C
      DO 360 I=1,N
         SM = 0.0D0
         DO 330 J=1,NC
            SM = 0.0D0
            PX = 1.0D0
            DO 320 K=1,NC
               IF (IFIT.EQ.1 .AND. K.GE.2) PX = PX*X(I,1)
               IF (IFIT.EQ.3) PX = X(I,K)
               SM = SM + PX*VCV(J,K)
  320       CONTINUE
            XW(I,J) = SM
  330    CONTINUE
         SM = 0.0D0
         PX = 1.0D0
         DO 340 K=1,NC
            IF (IFIT.EQ.1 .AND. K.GE.2) PX = PX*X(I,1)
            IF (IFIT.EQ.3) PX = X(I,K)
            SM = SM + XW(I,K)*PX
  340    CONTINUE
         SM = MAX(0.0D0, SM)
         SDPV(I) = SQRT(SM)
         SDRES(I) = FPLM
         IF (WT(I).LE.0.0D0) GO TO 360
         IF ((RVAR/WT(I)-SM).LE.0.0D0) IERR = 4
         IF (RVAR/WT(I)-SM.GT.0.0D0)
     +      SDRES(I) = (RES(I)/SQRT(RVAR/WT(I)-SM))
  360 CONTINUE
C
C     CHECK FOR PRINTED OUTPUT
C
      IF ((IPTOUT(1).EQ.0) .AND. (IPTOUT(2).EQ.0) .AND.
     +   (IPTOUT(3).EQ.0) .AND. (IPTOUT(4).EQ.0)) RETURN
C
C     BEGIN PRINTED OUTPUT
C
      IF (IPTOUT(1).EQ.0) GO TO 370
C
C     PRINT FIRST PAGE OF OUTPUT
C
      ISUBHD = 0
      CALL LLHDR(PAGE, WIDE, ISUBHD)
      CALL FITPT1(N, M, X, Y, PV, SDPV, RES, SDRES, WT, IX, NNZW,
     +   WEIGHT, IPTOUT(1))
C
C     PRINT PLOTS
C
  370 CONTINUE
      IF (IPTOUT(2).EQ.0) GO TO 375
      ISUBHD = 0
      CALL LLHDR(PAGE, WIDE, ISUBHD)
      CALL FITPT2 (SDRES, PV, WT, N, NNZW, WEIGHT, RES, RSS)
C
  375 CONTINUE
      IF (IPTOUT(3).EQ.0) GO TO 376
C
C     PRINT ANALYSIS OF VARIANCE
C
      ISUBHD = 0
      CALL LLHDR(PAGE, WIDE, ISUBHD)
      CALL OANOVA(YSUM, RED, NPAR, RVAR, NNZW, PAR1, IPRT)
C
  376 CONTINUE
      IF (IPTOUT(4).EQ.0) RETURN
C
      IF (NPAR.EQ.1) GO TO 450
      NC = NC - 1
      IDF1 = NNZW - NC
      GO TO 50
  380 CONTINUE
      DO 400 I=1,NC
         T(I,I) = SQRT(T(I,1))
         DO 390 J=I,NC
            IF (I.EQ.J) GO TO 390
            T(I,J) = T(I,J)*T(I,I)
  390    CONTINUE
  400 CONTINUE
C
      CALL DTRDI(T, NPAR, NC, DET, 011, IER)
C
      IF (IER.EQ.0) GO TO 420
      WRITE (IPRT,1140)
      DO 410 I=1,NC
         PAR1(I) = 0.0D0
         T(I,I) = 0.0D0
  410 CONTINUE
      GO TO 450
  420 CONTINUE
      DO 440 I=1,NC
         SM = 0.0D0
         DO 430 K=I,NC
            SM = SM + T(I,K)*T(I,K)
  430    CONTINUE
         T(I,I) = SM
  440 CONTINUE
C
C     PRINT PAGE HEADINGS
C
  450 CONTINUE
      ISUBHD = 0
      CALL LLHDR(PAGE, WIDE, ISUBHD)
C
C     PRINT VARIANCE COVARIANCE MATRIX
C
      CALL VCVOUT(NPAR, VCV, NPAR, .TRUE.)
C
      WRITE (IPRT,1030)
      IF (NPAR.GT.1) WRITE (IPRT,1040)
      WRITE (IPRT,1050)
      IF (NPAR.GT.1) WRITE (IPRT,1060)
      WRITE (IPRT, 1170)
      IF (NPAR.GE.2) THEN
         DO 460 I=1,NC
            SDC = SQRT(VCV(I,I))
            RATIO = FPLM
            PROBT = 0.0D0
            IF (SDC.GT.0.0D0) RATIO = PAR(I)/SDC
            IF (SDC.GT.0.0D0)
     +         PROBT = (1.0D0-CDFT(ABS(RATIO), NNZW-NPAR)) * 2.0D0
            SDC1 = SQRT(T(I,I))*SQRT(RVAR1)
            RATIO1 = FPLM
            PROBT1 = 0.0D0
            IF (SDC1.GT.0.0D0) RATIO1 = PAR1(I)/SDC1
            IF (SDC1.GT.0.0D0)
     +         PROBT1 = (1.0D0 - CDFT(ABS(RATIO1), NNZW-NPAR+1)) * 2.0D0
            WRITE (IPRT,1070) I, PAR(I), SDC, RATIO, PROBT, ACC(I),
     +         PAR1(I), SDC1, RATIO1, PROBT1
  460    CONTINUE
      END IF
      SDC = SQRT(VCV(NPAR,NPAR))
      RATIO = FPLM
      PROBT = 0.0D0
      IF (SDC.GT.0.0D0) RATIO = PAR(NPAR)/SDC
      IF (SDC.GT.0.0D0)
     +   PROBT = (1.0D0 - CDFT(ABS(RATIO), NNZW-NPAR)) * 2.0D0
      WRITE (IPRT,1070) NPAR, PAR(NPAR), SDC, RATIO, PROBT, ACC(NPAR)
      IF (NPAR.EQ.1) WRITE (IPRT,1080) RSD
      IF (NPAR.GT.1) WRITE (IPRT,1080) RSD, RSD1
      WRITE (IPRT,1090) NNZW, NPAR, IDF
      IF (NPAR.GT.1) WRITE (IPRT,1100) NNZW, NC, IDF1
      IF (CONST) WRITE (IPRT,1010) R2
      WRITE (IPRT,1000) COND
      WRITE (IPRT,1110)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/29H APPROXIMATE CONDITION NUMBER, 10X, G15.7)
 1010 FORMAT (/44H MULTIPLE CORRELATION COEFFICIENT SQUARED   , F7.4)
 1020 FORMAT (//46H THE VALUES COMPUTED FOR THE PARAMETERS ARE - /(5X,
     +   4HPAR(, I3, 4H) = , G15.7))
 1030 FORMAT (////1X, 25('-'), 1X, 18HESTIMATES FROM FIT, 1X, 24('-'))
 1040 FORMAT ('+', 72X, 4('-'), 1X,
     +   48HESTIMATES FROM FIT OMITTING LAST PREDICTOR VALUE, 1X,
     +   4('-'))
 1050 FORMAT (/2X, 19HESTIMATED PARAMETER, 7X, 9HSD OF PAR, 5X,
     +   8HT(PAR=0), 3X, 7HPROB(T), 2X, 8HACC DIG*)
 1060 FORMAT ('+', 72X, 19HESTIMATED PARAMETER, 7X, 9HSD OF PAR, 5X,
     +   8HT(PAR=0), 3X, 7HPROB(T))
 1070 FORMAT (1X, I3, 2X, G16.9, 3X, G16.9, 2X, G10.4, 1X, F5.3, 2X,
     +   F7.1, 9X, G16.9, 3X, G16.9, 2X, G10.4, 1X, F5.3)
 1080 FORMAT (//1X, 30HRESIDUAL STANDARD DEVIATION   , 9X, G15.7, 56X,
     +   G15.7)
 1090 FORMAT (1X, 27HBASED ON DEGREES OF FREEDOM, 7X, I4, 3H - , I2,
     +   3H = , I4)
 1100 FORMAT ('+', 105X, I4, 3H - , I2, 3H = , I4)
 1110 FORMAT (//52H * THE NUMBER OF CORRECTLY COMPUTED DIGITS IN EACH P,
     +   56HARAMETER USUALLY DIFFERS BY LESS THAN 1 FROM THE VALUE G,
     +   10HIVEN HERE.)
 1120 FORMAT (/47H THE PROGRAM WAS UNABLE TO COMPUTE THE VARIANCE,
     +   19H-COVARIANCE MATRIX./
     +   52H THE DESIGN MATRIX IS EITHER NEARLY SINGULAR OR VERY,
     +   17H ILL CONDITIONED./
     +   29H CHECK YOUR INPUT FOR ERRORS.)
 1140 FORMAT (54H0ESTIMATES FOR THE STANDARD DEVIATION OF THE ESTIMATED,
     +   55HPARAMETERS OMITTING THE LAST INDEPENDENT VARIABLE COULD/
     +   59H NOT BE COMPUTED.  THE ZEROS PRINTED FOR THE ESTIMATES OF T,
     +   50HHE PARAMETERS, THEIR STANDARD DEVIATIONS AND THEIR/
     +   59H RATIOS FOR THE FIT OMITTING THE LAST VARIABLE ARE MEANINGL,
     +   4HESS.)
 1150 FORMAT (/30H THE DESIGN MATRIX IS SINGULAR,
     +   29H TO WITHIN MACHINE PRECISION./
     +   50H CHECK THE DESIGN MATRIX FOR A LINEAR RELATIONSHIP,
     +   29H BETWEEN SOME OF THE COLUMNS.)
 1160 FORMAT (//1X, 11('*')/ 1X, 11H*  ERROR  */ 1X, 11('*'))
 1170 FORMAT (' ')
 1180 FORMAT (/50H THE LEAST SQUARES FIT OF THE DATA TO THE MODEL IS,
     +   35H EXACT TO WITHIN MACHINE PRECISION./
     +   38H STATISTICAL ANALYSIS IS NOT POSSIBLE.)
      END
*LLSP
      SUBROUTINE LLSP(Y, XM, N, NDEG, RES, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     CALL FOR POLYNOMIAL MODEL LEAST SQUARES FIT
C     NO WEIGHTS SPECIFIED
C     NO STORAGE OTHER THAN RESIDUALS
C     FOUR PAGES AUTOMATIC PRINTOUT
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N,NDEG
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RES(*),XM(*),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LPAR,LPV,LSDPV,LSDRES,LWT,NPAR,NPRT
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(1),PV(1),SDPV(1),SDRES(1),VCV(1,1),WT(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLCNTP
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
C        DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE MATRIX VCV.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPAR
C        THE ACTUAL LENGTH OF THE VECTOR P.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NDEG
C        THE DEGREE OF THE MODEL.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
C        PRINTED OUTPUT.
C     DOUBLE PRECISION PAR(1)
C        A DUMMY ARRAY FOR
C        THE PARAMETERS  TO BE ESTIMATED.
C     DOUBLE PRECISION PV(1)
C        A DUMMY ARRAY FOR
C        THE PREDICTED VALUES.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION SDPV(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(1)
C        A DUMMY ARRAY FOR
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION VCV(1,1)
C        A DUMMY ARRAY FOR
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(1)
C        A DUMMY ARRAY FOR
C        THE WEIGHTS.
C     DOUBLE PRECISION XM(N,1)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'L','L','S','P',' ',' '/
C
C     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
C
      WEIGHT = .FALSE.
      SAVE = .FALSE.
      NPRT = 1111
      LPAR = 1
      LPV = 1
      LSDPV = 1
      LSDRES = 1
      IVCV = 1
      LWT = 1
C
      CALL LLCNTP(Y, WT, LWT, XM, N, NDEG, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (//42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   45H       CALL LLSP (Y, X, N, NDEG, RES, LSDTAK))
      END
*LLSPS
      SUBROUTINE LLSPS(Y, XM, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     CALL FOR POLYNOMIAL MODEL LEAST SQUARES FIT
C     NO WEIGHTS SPECIFIED
C     FULL STORAGE
C     USER CONTROL OF AUTOMATIC PRINTOUT
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,LDSTAK,LPAR,N,NDEG,NPAR,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SDPV(*),SDRES(*),VCV(*),XM(*),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,LPV,LSDPV,LSDRES,LWT
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   WT(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLCNTP
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
C        DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE MATRIX VCV.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPAR
C        THE ACTUAL LENGTH OF THE VECTOR P.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NDEG
C        THE DEGREE OF THE MODEL.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
C        PRINTED OUTPUT.
C     DOUBLE PRECISION PAR(LPAR)
C        THE PARAMETERS  TO BE ESTIMATED.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUES.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION SDPV(N)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(N)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(1)
C        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
C     DOUBLE PRECISION XM(N,1)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'L','L','S','P','S',' '/
C
C     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
C
      WEIGHT = .FALSE.
      SAVE = .TRUE.
      LPV = N
      LSDPV = N
      LSDRES = N
      LWT = 1
C
      CALL LLCNTP(Y, WT, LWT, XM, N, NDEG, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (//42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL LLSPS (Y, X, N, NDEG, RES, LSDTAK,'/
     +   '      +            NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV,'/
     +   '      +            SDRES, VCV, IVCV)')
      END
*LLSPW
      SUBROUTINE LLSPW(Y, WT, XM, N, NDEG, RES, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     CALL FOR POLYNOMIAL MODEL LEAST SQUARES FIT
C     USER SUPPLIED WEIGHTS SPECIFIED
C     NO STORAGE OTHER THAN RESIDUALS
C     FOUR PAGES AUTOMATIC PRINTOUT
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N,NDEG
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RES(*),WT(*),XM(*),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LPAR,LPV,LSDPV,LSDRES,LWT,NPAR,NPRT
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(1),PV(1),SDPV(1),SDRES(1),VCV(1,1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLCNTP
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
C        DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE MATRIX VCV.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPAR
C        THE ACTUAL LENGTH OF THE VECTOR P.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NDEG
C        THE DEGREE OF THE MODEL.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
C        PRINTED OUTPUT.
C     DOUBLE PRECISION PAR(1)
C        A DUMMY ARRAY FOR
C        THE PARAMETERS  TO BE ESTIMATED.
C     DOUBLE PRECISION PV(1)
C        A DUMMY ARRAY FOR
C        THE PREDICTED VALUES.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION SDPV(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(1)
C        A DUMMY ARRAY FOR
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION VCV(1,1)
C        A DUMMY ARRAY FOR
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(N)
C        A DUMMY ARRAY FOR
C        THE WEIGHTS.
C     DOUBLE PRECISION XM(N,1)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'L','L','S','P','W',' '/
C
C     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
C
      WEIGHT = .TRUE.
      SAVE = .FALSE.
      NPRT = 1111
      LPAR = 1
      LPV = 1
      LSDPV = 1
      LSDRES = 1
      IVCV = 1
      LWT = N
C
      CALL LLCNTP(Y, WT, LWT, XM, N, NDEG, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (//42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   50H       CALL LLSPW (Y, WT, X, N, NDEG, RES, LSDTAK))
      END
*LLSPWS
      SUBROUTINE LLSPWS(Y, WT, XM, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     CALL FOR POLYNOMIAL MODEL LEAST SQUARES FIT
C     USER SUPPLIED WEIGHTS SPECIFIED
C     FULL STORAGE
C     USER CONTROL OF AUTOMATIC PRINTOUT
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,LDSTAK,LPAR,N,NDEG,NPAR,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SDPV(*),SDRES(*),VCV(*),WT(*),XM(*),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,LPV,LSDPV,LSDRES,LWT
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLCNTP
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
C        DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE MATRIX VCV.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPAR
C        THE ACTUAL LENGTH OF THE VECTOR P.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NDEG
C        THE DEGREE OF THE MODEL.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
C        PRINTED OUTPUT.
C     DOUBLE PRECISION PAR(LPAR)
C        THE PARAMETERS  TO BE ESTIMATED.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUES.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION SDPV(N)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(N)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(N)
C        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
C     DOUBLE PRECISION XM(N,1)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'L','L','S','P','W','S'/
C
C     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
C
      WEIGHT = .TRUE.
      SAVE = .TRUE.
      LPV = N
      LSDPV = N
      LSDRES = N
      LWT = N
C
      CALL LLCNTP(Y, WT, LWT, XM, N, NDEG, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (//42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL LLSPWS (Y, WT, X, N, NDEG, RES, LSDTAK,'/
     +   '      +             NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV,'/
     +   '      +             SDRES, VCV, IVCV)')
      END
*LLSS
      SUBROUTINE LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     CALL FOR GENERAL LINEAR MODEL LEAST SQUARES FIT
C     NO WEIGHTS SPECIFIED
C     FULL STORAGE
C     USER CONTROL OF AUTOMATIC PRINTOUT
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,IXM,LDSTAK,N,NPAR,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SDPV(*),SDRES(*),VCV(*),XM(*),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,LPAR,LPV,LSDPV,LSDRES,LWT
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   WT(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLCNTG
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
C        DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE MATRIX XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPAR
C        THE ACTUAL LENGTH OF THE VECTOR P.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
C        PRINTED OUTPUT.
C     DOUBLE PRECISION PAR(NPAR)
C        THE PARAMETERS  TO BE ESTIMATED.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUES.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION SDPV(N)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(N)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(1)
C        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
C     DOUBLE PRECISION XM(IXM,NPAR)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'L','L','S','S',' ',' '/
C
C     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
C
      WEIGHT = .FALSE.
      SAVE = .TRUE.
      LPAR = NPAR
      LPV = N
      LSDPV = N
      LSDRES = N
      LWT = 1
C
      CALL LLCNTG(Y, WT, LWT, XM, N, IXM, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (//42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL LLSS (Y, XM, N, IXM, NPAR, RES, LSDTAK,'/
     +  '      +           NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)')
      END
*LLSW
      SUBROUTINE LLSW(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     CALL FOR GENERAL LINEAR MODEL LEAST SQUARES FIT
C     USER SUPPLIED WEIGHTS SPECIFIED
C     NO STORAGE OTHER THAN RESIDUALS
C     FOUR PAGES AUTOMATIC PRINTOUT
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RES(*),WT(*),XM(*),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LPAR,LPV,LSDPV,LSDRES,LWT,NPRT
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(1),PV(1),SDPV(1),SDRES(1),VCV(1,1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLCNTG
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
C        DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE MATRIX XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPAR
C        THE ACTUAL LENGTH OF THE VECTOR P.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
C        PRINTED OUTPUT.
C     DOUBLE PRECISION PAR(1)
C        A DUMMY ARRAY FOR
C        THE PARAMETERS  TO BE ESTIMATED.
C     DOUBLE PRECISION PV(1)
C        A DUMMY ARRAY FOR
C        THE PREDICTED VALUES.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION SDPV(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(1)
C        A DUMMY ARRAY FOR
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION VCV(1,1)
C        A DUMMY ARRAY FOR
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(N)
C        A DUMMY ARRAY FOR
C        THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,NPAR)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'L','L','S','W',' ',' '/
C
C     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
C
      WEIGHT = .TRUE.
      SAVE = .FALSE.
      NPRT = 1111
      LPAR = 1
      LPV = 1
      LSDPV = 1
      LSDRES = 1
      IVCV = 1
      LWT = N
C
      CALL LLCNTG(Y, WT, LWT, XM, N, IXM, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (//42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL LLSW (Y, WT, XM, N, IXM, NPAR, RES, LSDTAK)')
      END
*LLSWS
      SUBROUTINE LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     CALL FOR GENERAL LINEAR MODEL LEAST SQUARES FIT
C     USER SUPPLIED WEIGHTS SPECIFIED
C     FULL STORAGE
C     USER CONTROL OF AUTOMATIC PRINTOUT
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,IXM,LDSTAK,N,NPAR,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SDPV(*),SDRES(*),VCV(*),WT(*),XM(*),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,LPAR,LPV,LSDPV,LSDRES,LWT
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLCNTG
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
C        DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE MATRIX XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPAR
C        THE ACTUAL LENGTH OF THE VECTOR P.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
C        PRINTED OUTPUT.
C     DOUBLE PRECISION PAR(NPAR)
C        THE PARAMETERS  TO BE ESTIMATED.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUES.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION SDPV(N)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(N)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(N)
C        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
C     DOUBLE PRECISION XM(IXM,NPAR)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'L','L','S','W','S',' '/
C
C     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
C
      WEIGHT = .TRUE.
      SAVE = .TRUE.
      LPAR = NPAR
      LPV = N
      LSDPV = N
      LSDRES = N
      LWT = N
C
      CALL LLCNTG(Y, WT, LWT, XM, N, IXM, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (//42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL LLSWS (Y, WT, XM, N, IXM, NPAR, RES, LSDTAK,'/
     + '      +            NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)')
      END
*LOGLMT
      SUBROUTINE LOGLMT (ILOGY, YMN, YMX, YLABEL, NUMROW, ISTEP, DELY,
     +  YWIDTH, NLABLY, YDMN, YDMX)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ADJUST PLOT LIMITS FOR LOG PLOTS, AND COMPUTE LOG AXIS LABELS
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELY,YDMN,YDMX,YMN,YMX,YWIDTH
      INTEGER
     +   ILOGY,ISTEP,NLABLY,NUMROW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YLABEL(20)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   YNLOG,YXLOG
      INTEGER
     +   IYN,IYNLOG,IYX,IYXLOG,J,K
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG10,MIN,MOD,NINT,DBLE
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELY
C     INTEGER ILOGY, ISTEP, IYN, IYNLOG, IYX, IYXLOG, J, K
C     INTEGER NLABLY, NUMROW
C     DOUBLE PRECISION YLABEL(20)
C        THE Y-AXIS LABLES.
C     DOUBLE PRECISION YDMN, YDMX
C        THE Y-AXIS DATA LIMITS ACTUALLY USED.
C     DOUBLE PRECISION YMN, YMX
C        THE Y-AXIS PLOT LIMITS ACTUALLY USED.
C     DOUBLE PRECISION YNLOG, YWIDTH, YXLOG
C
      IF (ILOGY.EQ.0) THEN
C
        YDMN = YMN
        YDMX = YMX
C
C       DETERMINE THE VALUE OF A DIVISION
C
        DELY=YMX-YMN
        YWIDTH=DELY/(NUMROW-1)
C
C       COMPUTE EVENLY SPACED LABELS FOR NON-LOG AXIS
C
        NLABLY = 0
        DO 10 J = 1, NUMROW, ISTEP
          NLABLY = NLABLY + 1
          YLABEL(NLABLY) = YMX+(1-J)*YWIDTH
   10   CONTINUE
          IF (MOD(NUMROW,ISTEP).EQ.1) YLABEL(NLABLY) = YMN
          IF (YMX.EQ.(-YMN) .AND. MOD(NLABLY,2).EQ.1) THEN
             YLABEL(NLABLY/2+1) = 0.0
          END IF
      ELSE
C
        YDMN = LOG10(YMN)
        YDMX = LOG10(YMX)
C
C       ADJUST AXIS LIMITS FOR LOG AXIS IF NECESSARY
C
        YXLOG=LOG10(YMX)
        IYXLOG=YXLOG
        IF (YMX.LT.1.0D0) IYXLOG=IYXLOG-1
        YNLOG=LOG10(YMN)
        IF ((YXLOG-YNLOG).LE.0.92082D0) THEN
C
C         RANGE IS LESS THAN .9 DECADES
C
          IYNLOG=YNLOG
          IF (YMN.LT.1.0D0) IYNLOG=IYNLOG-1
          IF (IYXLOG.LE.IYNLOG) THEN
C
C           VALUES FALL IN THE SAME DECADE
C
            YNLOG=IYNLOG
            YXLOG=YNLOG+1.0D0
            IYXLOG=YXLOG
          ELSE
C
C           VALUES FALL INTO TWO DECADES
C
            IYN=NINT(YMN/(10.0D0**IYNLOG))
            YNLOG=MIN(LOG10(IYN*(10.0D0**IYNLOG)),YNLOG)
            YXLOG=YNLOG+1.0D0
            IYXLOG=YXLOG
          END IF
        END IF
        YMX=YXLOG
        YMN=YNLOG
C
C       DETERMINE THE VALUE OF A DIVISION
C
        DELY=YMX-YMN
        YWIDTH=DELY/(NUMROW-1)
C
C       COMPUTE AXIS LABELS
C
        YLABEL(1)=10.0D0**YXLOG
        IYX=YLABEL(1)/(10.0D0**IYXLOG)
        K=2
        IF (YXLOG-YNLOG.GT.3.0D0) K=5
        IF (YXLOG-YNLOG.GT.6.0D0) K=10
C
        NLABLY = 1
C
        IF (YXLOG-YNLOG.LE.12.0D0) THEN
C
C       SET NICE LABELS
C
          IF (K.EQ.10) IYX=1
          IF (IYX.NE.1.AND.(IYX-((IYX/K)*K)).NE.0) IYX=((IYX/K)*K)
          IF (IYX.LE.1) THEN
            IYX=10
            IYXLOG=IYXLOG-1
          END IF
          IF (YLABEL(1)-IYX*(10.0D0**IYXLOG).GT.0.0D0 .AND.
     +     YXLOG-(YXLOG-YNLOG)/(2.0D0*(NUMROW-1)) .GT.
     +     LOG10(DBLE(IYX))+IYXLOG) IYX=IYX+K
          IYX=IYX-K
          IF (IYX.LE.0) THEN
            IYX=10
            IYXLOG=IYXLOG-1
          END IF
          DO 155 J=2,20
             NLABLY=NLABLY+1
             YLABEL(NLABLY)=IYX*(10.0D0**IYXLOG)
             IF (YLABEL(NLABLY).LE.10.0D0**YNLOG) GO TO 156
             IYX=IYX-K
             IF (IYX.GT.0) GO TO 155
             IYX=10
             IYXLOG=IYXLOG-1
  155     CONTINUE
  156     YLABEL(NLABLY)=10.0D0**YNLOG
        ELSE
C
C         COMPUTE EVENLY SPACED LABELS
C
          DO 160 J = ISTEP, NUMROW, ISTEP
            NLABLY = NLABLY + 1
            YLABEL(NLABLY) = 10.0D0**(YMX+(1.0D0-J)*YWIDTH)
  160     CONTINUE
        END IF
      END IF
C
      RETURN
      END
*LOPASS
      SUBROUTINE LOPASS (Y, N, FC, K, HLP, YF, NYF)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE CARRIES OUT LOW-PASS FILTERING OF THE
C     SERIES.  THE FILTER IS THE K-TERM
C     LEAST SQUARES APPROXIMATION TO THE CUTOFF FILTER
C     WITH CUTOF FREQUENCY FC.  ITS TRANSFER FUNCTION
C     HAS A TRANSITION BAND OF WIDTH DELTA SURROUNDING FC,
C     WHERE DELTA = 4*PI/K.
C
C     WRITTEN BY  -  PETER BLOOMFIELD
C                    FOURIER ANALYSIS OF TIME SERIES- AN
C                       INTRODUCTION
C                    JOHN WILEY AND SONS, NEW YORK, 1976
C                    PAGE 149
C     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
C                                STATISTICAL ENGINEERING DIVISION
C                                NATIONAL BUREAU OF STANDARDS
C                                BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC
      INTEGER
     +   K,N,NYF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   HLP(*),Y(*),YF(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,HEAD
C
C  LOCAL ARRAYS
      CHARACTER
     +   LFC(8)*1,LK(8)*1,LN(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,ERIODD,ERSII,ERSLFS,FLTSL,IPRINT,LPFLT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION FC
C        THE USER SUPPLIED CUTOFF FREQUENCY.
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     DOUBLE PRECISION HLP(K)
C        THE ARRAY IN WHICH THE -IDEAL- HIGH PASS FILTER COEFFICIENTS
C        WILL BE RETURNED.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     INTEGER K
C        THE NUMBER OF FILTER TERMS TO BE COMPUTED.
C     CHARACTER*1 LFC(8), LK(8), LN(8)
C        THE ARRAY CONTAINING THE NAMES OF THE VARIABLES FC, K AND N.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NYF
C        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YF(N)
C        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'L',       'O',       'P',       'A',       'S',       'S'/
      DATA
     +  LFC(1), LFC(2), LFC(3), LFC(4), LFC(5), LFC(6), LFC(7), LFC(8)
     + /  'F',   'C',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 3, 1, HEAD, ERR01, LN)
C
      CALL ERSII(NMSUB, LFC, FC, 0.0D0, 0.5D0, 2, HEAD, ERR02, LFC, LFC)
C
      CALL EISII(NMSUB, LK, K, 1, N, 2, HEAD, ERR03, LK, LK)
C
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR04)
C
      IF (ERR01 .OR. ERR02 .OR. ERR03 .OR. ERR04) GO TO 10
C
      CALL ERSLFS(NMSUB, FC, K, HEAD, ERR05)
C
      IF (.NOT. ERR05) GO TO 20
C
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   20 CONTINUE
C
      CALL LPFLT (FC, K, HLP)
C
      CALL FLTSL (Y, N, K, HLP, YF, NYF)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   46H       CALL LOPASS (Y, N, FC, K, HLP, YF, NYF))
      END
*LPCOEF
      SUBROUTINE LPCOEF (FC, K, HLP)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE COMPUTES THE K-TERM LEAST SQUARES
C     APPROXIMATION TO AN -IDEAL- LOW PASS FILTER
C     WITH CUTOF FREQUENCY FC.  ITS TRANSFER FUNCTION
C     HAS A TRANSITION BAND OF WIDTH DELTA SURROUNDING FC,
C     WHERE DELTA = 4*PI/K.
C
C     WRITTEN BY  -  PETER BLOOMFIELD
C                    FOURIER ANALYSIS OF TIME SERIES- AN
C                       INTRODUCTION
C                    JOHN WILEY AND SONS, NEW YORK, 1976
C                    PAGE 149
C     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
C                                STATISTICAL ENGINEERING DIVISION
C                                NATIONAL BUREAU OF STANDARDS
C                                BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC
      INTEGER
     +   K
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   HLP(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,HEAD
C
C  LOCAL ARRAYS
      CHARACTER
     +   LFC(8)*1,LK(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISII,ERIODD,ERSII,ERSLFS,IPRINT,LPFLT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01, ERR02, ERR03, ERR04
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION FC
C        THE USER SUPPLIED CUTOFF FREQUENCY.
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     DOUBLE PRECISION HLP(K)
C        THE ARRAY IN WHICH THE -IDEAL- LOW PASS FILTER COEFFICIENTS
C        WILL BE RETURNED.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     INTEGER K
C        THE NUMBER OF FILTER TERMS TO BE COMPUTED.
C     CHARACTER*1 LFC(8), LK(8)
C        THE ARRAY CONTAINING THE NAMES OF THE VARIABLES FC AND K.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'L',       'P',       'C',       'O',       'E',       'F'/
      DATA
     +  LFC(1), LFC(2), LFC(3), LFC(4), LFC(5), LFC(6), LFC(7), LFC(8)
     + /  'F',   'C',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL ERSII(NMSUB, LFC, FC, 0.0D0, 0.5D0, 2, HEAD, ERR01, LFC, LFC)
C
      CALL EISII(NMSUB, LK, K, 1, K, 2, HEAD, ERR02, LK, LK)
C
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR03)
C
      IF (ERR01 .OR. ERR02 .OR. ERR03) GO TO 10
C
      CALL ERSLFS(NMSUB, FC, K, HEAD, ERR04)
C
      IF (.NOT. ERR04) GO TO 20
C
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   20 CONTINUE
C
      CALL LPFLT (FC, K, HLP)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   31H       CALL LPCOEF (FC, K, HLP))
      END
*LPFLT
      SUBROUTINE LPFLT (FC, K, HLP)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE LOPASS FILTER COEFFICIENTS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC
      INTEGER
     +   K
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   HLP(K)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ARG,CON,PI,SUM
      INTEGER
     +   I,IHM,IHP,KHALF,KMID
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ARG, CON
C        VARIABLES USED IN THE COMPUTATION OF THE LOW PASS FILTER
C        COEFFICIENTS.
C     DOUBLE PRECISION FC
C        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
C     DOUBLE PRECISION HLP(K)
C        THE ARRAY IN WHICH THE INPUT LOW PASS FILTER COEFFICIENTS
C        ARE STORED.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IHM, IHP
C        INDEX VARIABLES FOR SYMMETRIC LOCATIONS AROUND THE MIDPOINT
C        OF THE FILTER.
C     INTEGER K
C        THE NUMBER OF TERMS IN THE FILTER.
C     INTEGER KHALF
C        THE VALUE OF THE MIDPOINT OF K MINUS 1.
C     INTEGER KMID
C        THE MIDPOINT OF THE FILTER.
C     DOUBLE PRECISION PI
C        THE VALUE OF PI.
C     DOUBLE PRECISION SUM
C        A VALUE USED FOR SUMMING.
C
      CALL GETPI(PI)
C
      KMID = (K + 1) / 2
C
      HLP(KMID) = 1.0D0
C
      IF (K .EQ. 1) RETURN
C
      HLP(KMID) = 2.0D0 * FC
      CON = 2.0D0 * PI / K
      SUM = HLP(KMID)
C
      KHALF = (K - 1) / 2
C
      DO 10 I = 1, KHALF
         ARG = I * CON
         IHP = KMID + I
         HLP(IHP) = SIN(I * FC * 2.0D0 * PI) * SIN(ARG) /
     +      (I * PI * ARG)
         IHM = KMID - I
         HLP(IHM) = HLP(IHP)
         SUM = SUM + HLP(IHM) + HLP(IHP)
   10 CONTINUE
      DO 20 I = 1, K
         HLP(I) = HLP(I) / SUM
   20 CONTINUE
      RETURN
      END
*LSTLAG
      INTEGER FUNCTION LSTLAG (NLPPA, LAGMAX, LACOV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE FINDS THE LAG VALUE OF THE LAST AUTOCOVARIANCE
C     COMPUTED BEFORE ONE COULD NOT BE COMPUTED DUE TO MISSING DATA.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LACOV,LAGMAX
C
C  ARRAY ARGUMENTS
      INTEGER
     +   NLPPA(LACOV)
C
C  LOCAL SCALARS
      INTEGER
     +   LAG
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAG
C        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
C        AUTOCORRELATION.
C     INTEGER NLPPA(LACOV)
C        THE ARRAY CONTAINING THE NUMBERS OF LAGGED PRODUCT PAIRS
C        USED TO COMPUTE THE ACVF AT EACH LAG.
C
C     FIND THE LAST AUTOCORRELATION TO BE COMPUTED BEFORE
C     ONE COULD NOT BE COMPUTED DUE TO MISSING DATA
C
      LSTLAG = -1
      IF (NLPPA(1) .LE. 0) RETURN
      DO 20 LAG = 1, LAGMAX
         IF (NLPPA(LAG + 1) .GE. 1) GO TO 20
         LSTLAG = LAG - 1
         RETURN
   20 CONTINUE
      LSTLAG = LAGMAX
      RETURN
      END
*LSTVCF
      SUBROUTINE LSTVCF(N, VEC, LMASK, MASK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS THE FIRST N ELEMENTS OF THE VECTOR
C     VEC.  THE I TH ELEMENT OF VEC IS IDENTIFIED WITH THE INDEX
C     OF THE I TH ZERO ELEMENT OF MASK.
C
C     WRITTEN BY  -  JOHN E. KOONTZ
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C                       PATTERNED AFTER LSTVEC OF JUNE 7, 1982.
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LMASK,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VEC(N)
      INTEGER
     +   MASK(LMASK)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IMASK,IMAX,IMIN,INDEX,IPRT,J,JMAX,NPERL
C
C  LOCAL ARRAYS
      INTEGER
     +   INDW(10)
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   INPERL
      EXTERNAL INPERL
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER IMASK
C        INDEX IN MASK.
C     INTEGER IMAX, IMIN
C        THE LARGEST AND SMALLEST INDICES IN VEC OF THE ELEMENTS TO BE
C        PRINTED.
C     INTEGER INDEX
C        THE INDEX OF THE VALUE TO BE PRINTED.
C     INTEGER INDW(10)
C        A WORK VECTOR FOR THE INDICES TO BE PRINTED FOR VEC.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER JMAX
C        INDEX IN INDW OF THE LARGEST INDEX TO BE PRINTED FOR VEC.
C     INTEGER LMASK
C        THE LENGTH OF MASK.  LMASK .GE. N.
C     INTEGER MASK(LMASK)
C        MASK VECTOR FOR VEC.  THE INDEX OF THE ITH ELEMENT OF MASK
C        EQUAL TO ZERO IS THE LABEL IN THE OUTPUT OF THE ITH ELEMENT
C        OF VEC.
C     INTEGER N
C        THE NUMBER OF VALUES TO BE PRINTED IN THE INPUT VECTOR.
C     INTEGER NPERL
C        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
C     DOUBLE PRECISION VEC(N)
C        THE VECTOR OF VALUES TO BE PRINTED.
C
      CALL IPRINT(IPRT)
C
      NPERL = INPERL(0)
C        NOTE - INPERL(0) IS ASSUMED TO BE AT MOST 10.0D0  IF GREATER,
C               INCREASE THE DIMENSION OF INDW.
C
C
      IMASK = 0
      DO 30 I = 1, N, NPERL
         IMIN = I
         IMAX = MIN(I+NPERL-1, N)
         JMAX = MIN(N - IMIN + 1, NPERL)
         DO 20 J = 1, JMAX
   10       IF (IMASK .GE. LMASK) GO TO 40
            IMASK = IMASK + 1
            IF (MASK(IMASK) .NE. 0) GO TO 10
            INDW(J) = IMASK
   20    CONTINUE
         WRITE(IPRT, 1010) (INDW(INDEX), INDEX = 1, JMAX)
         WRITE(IPRT, 1020) (VEC(INDEX), INDEX = IMIN, IMAX)
   30 CONTINUE
C
      RETURN
C
   40 WRITE (IPRT, 1030)
      RETURN
C
C     FORMAT STATEMENTS
C
 1010 FORMAT(10X, 5HINDEX, I5, 6I15)
 1020 FORMAT(10X, 5HVALUE, 7(1X, G14.7)/)
 1030 FORMAT (/47H ERROR IN STARPAC.  LSTVEC TRIED TO ACCESS MORE,
     +   29H ELEMENTS THAN EXIST IN MASK.)
C
      END
*LSTVEC
      SUBROUTINE LSTVEC(N, VEC)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS THE INDICES AND ELEMENT VALUES
C     OF THE VECTOR VEC.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VEC(N)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IMAX,IMIN,INDEX,IPRT,NPERL
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   INPERL
      EXTERNAL INPERL
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER IMAX, IMIN
C        THE LARGEST AND SMALLEST INDEX VALUE TO BE PRINTED ON EACH
C        LINE.
C     INTEGER INDEX
C        THE INDEX VALUE TO BE PRINTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER N
C        THE NUMBER OF VALUES TO BE PRINTED IN THE INPUT VECTOR.
C     INTEGER NPERL
C        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
C     DOUBLE PRECISION VEC(N)
C        THE VECTOR OF VALUES TO BE PRINTED.
C
      CALL IPRINT(IPRT)
C
      NPERL = INPERL(0)
C
      DO 10 I = 1, N, NPERL
         IMIN = I
         IMAX = MIN(I+NPERL-1, N)
         WRITE(IPRT, 1010) (INDEX, INDEX = IMIN, IMAX)
         WRITE(IPRT, 1020) (VEC(INDEX), INDEX = IMIN, IMAX)
   10 CONTINUE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1010 FORMAT(10X, 5HINDEX, I5, 6I15)
 1020 FORMAT(10X, 5HVALUE, 7(1X, G14.7)/)
C
      END
*MAFLT
      SUBROUTINE MAFLT (Y, N, K, YF, NYF)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PERFORMS A SIMPLE MOVING AVERAGE FILTERING
C     OPERATION ON AN INPUT SERIES Y, RETURNING THE FILTERED SERIES
C     IN YF.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   K,N,NYF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*),YF(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   HMA
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD
C
C  LOCAL ARRAYS
      CHARACTER
     +   LK(8)*1,LN(8)*1,LONE(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,ERIODD,FLTMA,IPRINT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01, ERR02, ERR03
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     DOUBLE PRECISION HMA
C        THE VALUE OF EACH OF THE SIMPLE MOVING AVERAGE LINEAR FILTER
C        COEFFICIENTS.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     INTEGER K
C        THE NUMBER OF FILTER TERMS.
C     CHARACTER*1 LK(8), LN(8), LONE(8)
C        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES K AND N.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NYF
C        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YF(N)
C        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'M',       'A',       'F',       'L',       'T',       ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA
     +  LONE(1), LONE(2), LONE(3), LONE(4), LONE(5), LONE(6), LONE(7),
     +  LONE(8)  /  ' ', ' ', 'O', 'N', 'E', ' ', ' ', ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 3, 1, HEAD, ERR01, LN)
C
      CALL EISII(NMSUB, LK, K, 1, N, 1, HEAD, ERR02, LONE, LN)
C
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR03)
C
      IF (ERR01 .OR. ERR02 .OR. ERR03) GO TO 10
      GO TO 20
C
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   20 CONTINUE
C
C     COMPUTE THE SIMPLE MOVING AVERAGE COEFFICIENTS
C
      HMA = K
      HMA = 1.0D0/HMA
C
      CALL FLTMA (Y, N, K, HMA, YF, NYF)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL MAFLT (Y, N, K, YF, NYF)')
      END
*MATPRF
      SUBROUTINE MATPRF(X, Y, NC, MODE, CODE, LENGTH, MASK, LMASK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THISROUTINE PRINTS A SQUARE MATRIX STORED IN SYMMETRIC
C     FORM.
C
C     WRITTEN BY - JOHN E. KOONTZ
C        STATISTICAL ENGINEERING DIVISION
C        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C        BASED ON THE JULY 1982 VERSION OF MATPRT, BY LINDA L. MITCHELL.
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   CODE,LENGTH,LMASK,MODE,NC
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(LENGTH),Y(LENGTH)
      INTEGER
     +   MASK(LMASK)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   SQXII,SQYII
      INTEGER
     +   I,I0,II,IK,IMASK,IPRT,J,JMASK,K,KI,KK,KM,KMAX,KN,L,NF,
     +   NLINE
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   XLINE(10),YLINE(10)
      INTEGER
     +   INDW(10)
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   INPERL
      EXTERNAL INPERL
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER CODE
C        IF 1 -SINGLE PRINTED, X ONLY (Y IS DUMMY ARG)
C           2 -DOUBLE PRINTED LINE, BOTH X AND Y
C     INTEGER I
C        ROW NUMBER
C     INTEGER II
C        THE INDEX OF THE (I,I)TH ELEMENT OF THE VCV MATRIX
C     INTEGER IK
C        THE INDEX OF THE (I,K)TH ELEMENT OF THE VCV MATRIX
C     INTEGER I0
C        THE INDEX OF THE ((I,I)-1)TH ELEMENT OF THE VCV MATRIX
C     INTEGER IMASK
C        INDEX IN MASK FOR LABELLING OF THE ROW DIMENSION.
C     INTEGER INDW(10)
C        A WORK VECTOR FOR THE INDICES TO BE PRINTED FOR THE
C        MATRIX.
C     INTEGER IPRT
C        THE OUTPUT UNIT NUMBER
C     INTEGER J
C        FIRST COLUMN IN THE SET TO BE PRINTED
C     INTEGER JMASK
C        INDEX IN MASK FOR LABELLING OF THE COLUMN DIMENSION.
C     INTEGER K
C        COLUMN NUMBER IN THE POSSIBLE SET OF NF
C     INTEGER KI
C        THE INDEX OF THE (K,I)TH ELEMENT OF THE VCV MATRIX
C     INTEGER KK
C        THE INDEX OF THE (K,K)TH ELEMENT OF THE VCV MATRIX
C     INTEGER KM
C        LAST COLUMN IN THE SET
C        LIMITED TO VALUES OF J-1 PLUS A NUMBER BETWEEN 1 AND
C        NF (INCLUSIVE)
C     INTEGER KMAX
C        INDEX IN INDW OF THE LARGEST INDEX TO BE PRINTED FOR
C        MATRIX.
C     INTEGER KN
C        LAST COLUMN TO PRINT WHEN PRINTING LOWER TRIANGLE
C     INTEGER L
C        FIRST ROW TO PRINT FOR THIS SET
C     INTEGER LMASK
C        LENGTH OF MASK.
C     INTEGER LENGTH
C        LENGTH OF X AND Y
C     INTEGER MASK(LMASK)
C        MASK VECTOR FOR VCV.  THE INDEX OF THE ITH ELEMENT OF
C        MASK EQUAL TO ZERO IS THE LABEL IN THE OUTPUT OF VCV
C        IN OF THE ITH ROW AND ITH COLUMN.
C     INTEGER MODE
C        IF 0, LOWER TRIANGULAR PART PRINTED
C           1, LOWER TRIANGULAR PART IS PRINTED WITH
C              SQUARE ROOTS OF THE DIAGONAL
C           2, LOWER TRIANGLE PRINTED AS CORRELATION MATRIX
C              WITH SQUARE ROOTS ON THE DIAGONAL
C           3, FULL MATRIX PRINTED
C           4, FULL MATRIX PRINTED WITH CORRELATION MATRIX
C              PRINTED BELOW THE DIAGONAL
C     INTEGER NC
C        ROW AND COLUMN DIMENSION OF X
C     INTEGER NF
C        THE NUMBER OF COLUMNS THAT CAN BE PRINTED, GIVEN
C        THE WIDTH IWIDTH OF THE OUTPUT DEVICE.
C     INTEGER NLINE
C        THE NUMBER OF VALUES TO BE PRINTED EACH LINE.
C     DOUBLE PRECISION SQXII, SQYII
C        THE SQUARE ROOT OF THE (I,I)TH ELEMENT OF X AND Y.
C     DOUBLE PRECISION X(LENGTH)
C        INPUT SYMMETRIC ARRAY STORED ROW WISE
C     DOUBLE PRECISION XLINE(10)
C        THE CURRENT VALUES BEING PRINTED FROM ARRAY X.
C     DOUBLE PRECISION Y(LENGTH)
C        ARRAY TO BE PRINTED ON THE SECOND LEVEL IF CODE=2
C     DOUBLE PRECISION YLINE(10)
C        THE CURRENT VALUES BEING PRINTED FROM ARRAY Y.
C
C     BODY OF ROUTINE
C
      CALL IPRINT(IPRT)
C
      NF = INPERL(0)
C
      L = 1
      JMASK = 0
C
C     SELECT INITIAL COLUMN TO PRINT THIS PASS OF THE REPORT
C
      DO 90 J=1,NC,NF
         KN = MIN(NC,J+NF-1)
         KMAX = MIN(NC-J+1,NF)
C
C     GENERATE VECTOR OF COLUMN HEAD LABELS
C
         DO 20 K=1,KMAX
   10       IF (JMASK.GE.LMASK) GO TO 100
            JMASK = JMASK + 1
            IF (MASK(JMASK).NE.0) GO TO 10
            INDW(K) = JMASK
   20    CONTINUE
C
C     PRINT VECTOR OF COLUMN HEAD LABELS
C
         WRITE (IPRT,1000) (INDW(K),K=1,KMAX)
         WRITE (IPRT,1030)
         IF (MODE.LE.2) L = INDW(1)
C
C     PRINT ALL ROWS IN COLUMN RANGE FOR THIS PASS
C
         IMASK = L - 1
         DO 80 I=L,NC
            KM = KN
            IF (MODE.LE.2) KM = J + MIN(I-L,NF-1)
            NLINE = 0
            I0 = I*(I-1)/2
            II = I0 + I
            SQXII = SQRT(X(II))
            IF (CODE.EQ.2) THEN
               SQYII = SQRT(Y(II))
            ELSE
               SQYII = 1.0D0
            END IF
            DO 60 K=J,KM
               NLINE = NLINE + 1
               IF (K.GT.I) GO TO 30
               IK = I0 + K
               XLINE(NLINE) = X(IK)
               IF (CODE.EQ.2) YLINE(NLINE) = Y(IK)
               GO TO 40
   30          KI = K*(K-1)/2 + I
               XLINE(NLINE) = X(KI)
               IF (CODE.EQ.2) YLINE(NLINE) = Y(KI)
   40          IF (((MODE.NE.1) .AND. (MODE.NE.2)) .OR. (I.NE.K)) GO TO
     +            50
               XLINE(NLINE) = SQXII
               IF (CODE.EQ.2) YLINE(NLINE) = SQXII
   50          IF (((MODE.NE.2) .AND. (MODE.NE.4)) .OR. (K.GE.I)) GO TO
     +            60
               KK = K*(K-1)/2 + K
               XLINE(NLINE) = XLINE(NLINE)/(SQXII*SQRT(X(KK)))
               IF (CODE.EQ.2)
     +            YLINE(NLINE) = YLINE(NLINE)/(SQYII*SQRT(Y(KK)))
   60       CONTINUE
   70       IF (IMASK.GE.LMASK) GO TO 100
            IMASK = IMASK + 1
            IF (MASK(IMASK).NE.0) GO TO 70
            WRITE (IPRT,1010) IMASK, (XLINE(K),K=1,NLINE)
            IF (CODE.EQ.2) WRITE (IPRT,1020) (YLINE(K),K=1,NLINE)
            IF (CODE.EQ.2) WRITE (IPRT,1030)
   80    CONTINUE
   90 CONTINUE
      RETURN
C
  100 WRITE (IPRT,1040)
      RETURN
C
C     FORMAT STATEMENTS
C
C
 1000 FORMAT (/' ', 7HCOLUMN , 7(I9, 8X))
 1010 FORMAT (' ', I6, 1X, 7(3X, G14.7))
 1020 FORMAT (' ', 5X, 7(3X, G14.7))
 1030 FORMAT (' ')
 1040 FORMAT (/47H ERROR IN STARPAC.  MATPRF TRIES TO ACCESS MORE,
     +   29H ELEMENTS THAN EXIST IN MASK.)
      END
*MATPRT
      SUBROUTINE MATPRT (X, Y, NC, IPRT, MODE, CODE, IRDIM)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE TAKES A SQUARE MATRIX AND PRINTS EITHER ITS
C     LOWER TRIANGULAR PART OR THE FULL MATRIX WITH OR WITHOUT DOUBLE
C     PRINTING.
C
C     WRITTEN BY - LINDA L. MITCHELL
C                  STATISTICAL ENGINEERING LAB/BOULDER
C                  NATIONAL BUREAU OF STANDARDS
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   CODE,IPRT,IRDIM,MODE,NC
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(IRDIM,NC),Y(IRDIM,NC)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   TEMP
      INTEGER
     +   I,IWIDTH,J,K,KM,KN,L,NF
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER CODE
C                  IF 1 -SINGLE PRINTED LINE, X ONLY (Y IS DUMMY ARG)
C                     2 -DOUBLE PRINTED LINE, BOTH X AND Y
C     INTEGER I
C                  ROW NUMBER
C     INTEGER IPRT
C                  THE OUTPUT UNIT NUMBER
C     INTEGER IRDIM
C                  ROW INDEX OF X
C     INTEGER IWIDTH
C                  THE WIDTH OF THE OUTPUT DEVICE.
C     INTEGER J
C                  FIRST COLUMN IN THE SET TO BE PRINTED
C     INTEGER K
C                  COLUMN NUMBER IN THE POSSIBLE SET OF NF
C     INTEGER KM
C                  LAST COLUMN IN THE SET
C                   LIMITED TO VALUES OF J-1 PLUS A NUMBER BETWEEN 1 AND
C                   NF (INCLUSIVE)
C     INTEGER KN
C                  LAST COLUMN TO PRINT WHEN PRINTING LOWER TRIANGLE
C     INTEGER L
C                  FIRST ROW TO PRINT FOR THIS SET
C     INTEGER MODE
C                  IF 0, LOWER TRIANGULAR PART PRINTED
C                     1, FULL MATRIX PRINTED
C                     2, LOWER TRIANGULAR PART IS PRINTED WITH
C                        SQUARE ROOTS OF THE DIAGONAL
C     INTEGER NC
C                  ROW AND COLUMN DIMENSION OF X
C     INTEGER NF
C                  THE NUMBER OF COLUMNS THAT CAN BE PRINTED, GIVEN
C                  THE WIDTH IWIDTH OF THE OUTPUT DEVICE.
C     DOUBLE PRECISION TEMP
C                  A TEMPORARY LOCATION
C     DOUBLE PRECISION X(IRDIM,NC)
C                  NC BY NC INPUT MATRIX
C     DOUBLE PRECISION Y(IRDIM,NC)
C                  MATRIX TO BE PRINTED ON THE SECOND LEVEL IF CODE=2
C
      IWIDTH = 132
      NF = MIN(7, (IWIDTH - 7)/17)
      L = 1
      DO 20 J=1,NC, NF
         KN = MIN(NC, J+NF-1)
         WRITE(IPRT,1000) (K,K=J,KN)
         WRITE(IPRT,1030)
         IF ((MODE.EQ.00) .OR. (MODE.EQ.2)) L = J
         DO 10 I=L,NC
            TEMP = X(I,I)
            KM = KN
            IF ((MODE.EQ.0) .OR. (MODE.EQ.2))
     +         KM = J + MIN(I-L, NF-1)
            IF ((MODE.EQ.2) .AND. ((I.GE.J) .AND. (I.LE.KM)))
     +         X(I,I) = SQRT(X(I,I))
            WRITE(IPRT,1010) I, (X(I,K),K=J,KM)
            IF (CODE.EQ.2) WRITE(IPRT,1020) (Y(I,K),K=J,KM)
            IF (CODE.EQ.2) WRITE(IPRT,1030)
            X(I,I) = TEMP
   10    CONTINUE
   20 CONTINUE
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/4X, 7HCOLUMN , 7(I9, 8X))
 1010 FORMAT (4X, I6, 1X, 7(3X, G14.8))
 1020 FORMAT (9X, 7(3X, G14.8))
 1030 FORMAT (4X)
      END
*MDFLT
      SUBROUTINE MDFLT (PER, NF, NK, KMD, PERF, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR APPLYING MODIFIED
C     DANIEL FILTERS TO A SYMMETRIC SERIES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,NF,NK
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PER(*),PERF(*)
      INTEGER
     +   KMD(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   SYM
      INTEGER
     +   I,IPRT,L,LDSMIN,NALL0,WORK
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      CHARACTER
     +   LKMD(8)*1,LLDS(8)*1,LNF(8)*1,LNK(8)*1,NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EIVEO,FLTMD,IPRINT,LDSCMP,STKCLR,STKSET
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL ERR01, ERR02, ERR03
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
C        ERROR MESSAGES (TRUE) OR NOT (FALSE).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IPRT
C        THE LOGICAL UNIT NUMBER USED FOR OUTPUT.
C     INTEGER KMD(NK)
C        THE ARRAY OF FILTER LENGTHS.
C     CHARACTER*1 LKMD(8), LLDS(8), LNK(8), LNF(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
C        FOR ERRORS.
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
C     INTEGER NF
C        THE NUMBER OF POINTS IN THE SERIES TO BE FILTERED.
C     INTEGER NK
C        THE NUMBER OF FILTERS TO BE APPLIED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     DOUBLE PRECISION PER(NF)
C        THE INPUT SERIES TO BE FILTERED.
C     DOUBLE PRECISION PERF(NF)
C        THE FILTERED SERIES.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION SYM
C        AN INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE SERIES
C        IS SYMMETRIC (SYM = 1.0D0) OR NOT (SYM = -1.0D0).
C     INTEGER WORK
C        THE STARTING LOCATION IN THE WORK AREA FOR THE WORK VECTOR.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'M',       'D',       'F',       'L',       'T',       ' '/
      DATA
     + LKMD(1), LKMD(2), LKMD(3), LKMD(4), LKMD(5),
     +  LKMD(6), LKMD(7), LKMD(8) /'K','M','D',' ',' ',' ',' ',' '/
      DATA
     + LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     +  LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA
     + LNF(1), LNF(2), LNF(3), LNF(4), LNF(5),
     +  LNF(6), LNF(7), LNF(8) /'N','F',' ',' ',' ',' ',' ',' '/
      DATA
     + LNK(1), LNK(2), LNK(3), LNK(4), LNK(5),
     +  LNK(6), LNK(7), LNK(8) /'N','K',' ',' ',' ',' ',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LNF, NF, 17, 1, HEAD, ERR01, LNF)
C
      CALL EISGE(NMSUB, LNK, NK, 1, 1, HEAD, ERR02, LNK)
C
      IF (.NOT.ERR02) CALL EIVEO(NMSUB, LKMD, KMD, NK, .TRUE., HEAD)
C
      IF (ERR01) GO TO 10
C
      CALL LDSCMP(1, 0, 0, 0, 0, 0, 'D', NF, LDSMIN)
C
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR03, LLDS)
C
      IF ((.NOT.ERR02) .AND. (.NOT.ERR03)) GO TO 20
C
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   20 CONTINUE
C
C     SET THE SIZE OF THE WORK AREA
C
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
C
C     SUBDIVIDE THE WORK AREA
C
      WORK = STKGET(NF, 4)
C
C     DESIGNATE THE SERIES IS SYMMETRIC
C
      SYM = 1.0D0
C
      DO 30 I = 1, NF
         PERF(I) = PER(I)
   30 CONTINUE
C
      DO 40 L = 1, NK
         CALL FLTMD(PERF, RSTAK(WORK), NF, KMD(L), SYM)
   40 CONTINUE
C
      CALL STKCLR(NALL0)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL MDFLT (PER, NF, NK, KMD, PERF, LDSTAK)')
      END
*MDLTS1
      SUBROUTINE MDLTS1 (PAR, NPAR, XM, N, M, IXM, RESTS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR ESTIMATING BOX-JENKINS
C     ARIMA MODELS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 4, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),RESTS(NRESTS),XM(IXM,M)
C
C  SCALARS IN COMMON
      INTEGER
     +   IFLAG,MBO,MBOL,MSPECT,NFACT,NPARAR,NPARDF,NPARMA,NRESTS,
     +   PARAR,PARDF,PARMA,T,TEMP
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   PMU
      INTEGER
     +   I,I1
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL MDLTS2
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /MDLTSC/MSPECT,NFACT,PARDF,NPARDF,PARAR,NPARAR,PARMA,
     +   NPARMA,MBO,MBOL,T,TEMP,NRESTS,IFLAG
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IFLAG
C        AN INDICATOR VARIABLE DESIGNATING WHETHER THE BACK FORECASTS
C        WERE ESSENTIALLY ZERO (IFLAG=0) OR NOT (IFLAG=1).
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IXM
C        THE FIRST DIMENSION OF MATRIX XM.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MBO
C        THE MAXIMUM BACK ORDER OPERATOR.
C     INTEGER MBOL
C        THE MAXIMUM BACK ORDER ON THE LEFT
C     INTEGER MSPECT
C        THE STARTING LOCATION IN THE WORK SPACE FOR
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFACT
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARAR
C        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
C     INTEGER NPARDF
C        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
C     INTEGER NPARMA
C        THE LENGTH OF THE VECTOR PARMA
C     INTEGER NRESTS
C        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     INTEGER PARAR
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        THE AUTOREGRESSIVE PARAMETERS
C     INTEGER PARDF
C        THE STARTING LOCATION IN THE WORK SPACE FOR
C        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
C     INTEGER PARMA
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        THE MOVING AVERAGE PARAMETERS
C     DOUBLE PRECISION PMU
C        THE VALUE OF MU, I.E., THE TREND OR MEAN.
C     DOUBLE PRECISION RESTS(NRESTS)
C        THE RESIDUALS FROM THE ARIMA MODEL.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER T
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        A TEMPORARY WORK VECTOR.
C     INTEGER TEMP
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        A TEMPORARY WORK VECTOR
C     DOUBLE PRECISION XM(IXM,M)
C        THE INDEPENDENT VARIABLE.
C
C
C     COMPUTE RESIDUALS
C
      CALL MDLTS2 (PAR, RESTS, XM(1,1), NPAR, N, NFACT, ISTAK(MSPECT),
     +  PMU, RSTAK(PARDF), NPARDF, RSTAK(T), RSTAK(TEMP), RSTAK(PARAR),
     +  RSTAK(PARMA), MBO, N-NRESTS+1, N, IFLAG)
C
C     COMPUTE PREDICTED VALUES
C
      I1=NRESTS-N
      DO 20 I = 1,N
        I1=I1+1
        RESTS(I) = XM(I1,1)-RESTS(I1)
   20 CONTINUE
C
      RETURN
      END
*MDLTS2
      SUBROUTINE MDLTS2 (PAR, RESTS, Y, NPAR, N, NFAC, MSPECT, PMU,
     +  PARDF, NPARDF, T, TEMP, PARAR, PARMA, MBO, N1, N2, IFLAG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MODEL ROUTINE FOR PACKS SPECIFICATION OF
C     BOX-JENKINS MODELS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 4, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   PMU
      INTEGER
     +   IFLAG,MBO,N,N1,N2,NFAC,NPAR,NPARDF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PARAR(*),PARDF(*),PARMA(*),RESTS(N1:N2),T(*),
     +   TEMP(*),Y(N)
      INTEGER
     +   MSPECT(NFAC,4)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLPM,RESMAX,WTEST
      INTEGER
     +   I,IMOD,IMOD1,IPAR,IPQ,ISTART,J,K,L,MAXORD,MBO1,NP,NPARAR,
     +   NPARMA
      LOGICAL
     +   PARLE1
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,LOG,MOD,SIGN,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION FPLPM
C        THE FLOATING POINT LARGEST POSITIVE MAGNITUDE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IFLAG
C        AN INDICATOR VARIABLE DESIGNATING WHETHER THE BACK FORECASTS
C        WERE ESSENTIALLY ZERO (IFLAG=0) OR NOT (IFLAG=1).
C     INTEGER IMOD
C        AN INDEX VARIABLE.
C     INTEGER IPAR
C        AN INDEX VARIABLE.
C     INTEGER IPQ
C        AN INDEX VARIABLE.
C     INTEGER ISTART
C        ***
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER K
C        AN INDEX VARIABLE.
C     INTEGER L
C        AN INDEX VARIABLE.
C     INTEGER MAXORD
C        THE LARGEST BACK ORDER.
C     INTEGER MBO
C        THE MAXIMUM BACK ORDER OPERATOR.
C     INTEGER MBO1
C        THE VALUE MBO+1
C     INTEGER MSPECT(NFAC,4)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NP
C        THE NUMBER OF PARAMETERS IN THE EXPANDED TERM.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARAR
C        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
C     INTEGER NPARDF
C        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
C     INTEGER NPARMA
C        THE LENGTH OF THE VECTOR PARMA
C     INTEGER N1
C        THE LOWER BOUND FOR RESTS.
C     INTEGER N2
C        THE UPPER BOUND FOR RESTS.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PARAR(MBO)
C        THE AUTOREGRESSIVE PARAMETERS
C     DOUBLE PRECISION PARDF(NPARDF)
C        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS.
C     LOGICAL PARLE1
C        A FLAG INDICATING WHETHER ALL OF THE MOVING AVERAGE PARAMETERS
C        ARE LESS THAN OR EQUAL TO 1 (PARLE1 = .TRUE.) OR NOT
C        (PARLE1 = .FALSE.)
C     DOUBLE PRECISION PARMA(MBO)
C        THE MOVING AVERAGE PARAMETERS
C     DOUBLE PRECISION PMU
C        THE VALUE OF MU, I.E., THE TREND OR MEAN.
C     DOUBLE PRECISION RESMAX
C        THE LARGEST POSSIBLE RESIDUAL WHICH WILL STILL AVOID OVERFLOW.
C     DOUBLE PRECISION RESTS(N1:N2)
C        THE PREDICTED VALUE OF THE FIT.
C     DOUBLE PRECISION T(2*MBO)
C        A TEMPORARY WORK VECTOR.
C     DOUBLE PRECISION TEMP(MBO)
C        A TEMPORARY WORK VECTOR
C     DOUBLE PRECISION WTEST
C        THE TEST VALUE USED TO DETERMINE IF THE DIFFERENCED SERIES
C        BACK FORECAST IS EFFECTIVELY ZERO OR NOT.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
      FPLPM = D1MACH(2)
C
C     ZERO THE PARAMETER ARRAYS PARAR AND PARMA
C
      DO 10 I=1,MBO
         T(I) = 0.0D0
         TEMP(I) = 0.0D0
   10 CONTINUE
C
      NP = 0
      IPAR = 0
      NPARAR = 0
      ISTART = 0
C
C     EXPAND THE MODEL AND STORE AUTOREGRESSIVE PARAMETERS IN PARAR
C     AND MOVING AVERAGE PARAMETERS IN PARMA
C
      DO 110 IPQ = 1, 3, 2
         DO 100 L=1,NFAC
            IF (MSPECT(L,IPQ).EQ.0) GO TO 100
            MAXORD = MSPECT(L,IPQ)*MSPECT(L,4)
            DO 90 K = MSPECT(L,4), MAXORD, MSPECT(L,4)
               IPAR = IPAR + 1
               TEMP(K) = TEMP(K) + PAR(IPAR)
               DO 80 I = 1, NP
                  TEMP(K+I) = TEMP(K+I) - T(I)*PAR(IPAR)
   80          CONTINUE
   90       CONTINUE
            NP = NP + MAXORD
            DO 95 K = 1, NP
               T(K) = TEMP(K)
   95       CONTINUE
  100    CONTINUE
          IF (IPQ.NE.3) THEN
            IPAR = IPAR + 1
            PMU = PAR(IPAR)
            NPARAR = NP
            DO 105 K =1, NPARAR
               PARAR(K) = T(K)
               T(K) = 0.0D0
               TEMP(K) = 0.0D0
  105       CONTINUE
            NP = 0
         END IF
  110 CONTINUE
      NPARMA = NP
      PARLE1 = .TRUE.
      DO 115 K =1, NPARMA
         PARMA(K) = T(K)
         IF (ABS(PARMA(K)).GT.1.0D0) PARLE1 = .FALSE.
  115 CONTINUE
C
C     COMPUTE FITTED VALUES AND RESIDUALS FOR MODEL.
C
C     COMPUTE W, THE DIFFERENCED SERIES MINUS ITS MEAN, AND STORE IN
C     RESTS(NPARDF+1) TO RESTS(N2)
C
      DO 140 I = NPARDF+1, N2, 1
         RESTS(I) = Y(I) - PMU
         DO 130 J = 1,NPARDF
            RESTS(I) = RESTS(I) - PARDF(J)*Y(I-J)
  130    CONTINUE
  140 CONTINUE
      WTEST = ABS(RESTS(NPARDF+1))*0.01
C
C     BACK FORECAST THE ERROR, E, FOR I = N-NPARAR TO NPARDF+1, AND
C     THE DIFFERENCED SERIES FOR I = NPARDF TO N1
C
      MBO1 = MBO+1
      IFLAG = 0
      DO 170 I = N2-NPARAR,NPARDF+1,-1
         IMOD = MOD(I+1-N1,MBO1) + 1
         T(IMOD) = RESTS(I)
         DO 150 J = 1,NPARAR
            T(IMOD) = T(IMOD) - PARAR(J)*RESTS(I+J)
  150    CONTINUE
         DO 160 J = 1,NPARMA
            IF ((I+J.GT.NPARDF) .AND. (I+J.LE.N))
     +         T(IMOD) = T(IMOD) + PARMA(J)*T(MOD(I+J+1-N1,MBO1)+1)
  160    CONTINUE
  170 CONTINUE
      DO 175 I = NPARDF,N1,-1
         IMOD = MOD(I+1-N1,MBO1) + 1
         RESTS(I) = 0.0D0
         DO 163 J = 1,NPARAR
            RESTS(I) = RESTS(I) + PARAR(J)*RESTS(I+J)
  163    CONTINUE
         DO 166 J = 1,NPARMA
            IF ((I+J.GT.NPARDF) .AND. (I+J.LE.N))
     +         RESTS(I) = RESTS(I) -
     +                    PARMA(J)*T(MOD(I+J+1-N1,MBO1)+1)
  166    CONTINUE
         ISTART = I
         IF ((ISTART.LE.1) .AND. (ABS(RESTS(I)).LE.WTEST)) GO TO 180
  175 CONTINUE
      IFLAG = 1
C
C     COMPUTE RESIDUALS AND STORE VALUES IN RESTS
C
  180 CONTINUE
      DO 210 I = ISTART,N2,1
         IMOD = MOD(I+1-N1,MBO1) + 1
         T(IMOD) = RESTS(I)
         DO 190 J = 1,NPARAR
            IF (I-J.GE.ISTART) T(IMOD) = T(IMOD) - PARAR(J)*RESTS(I-J)
  190    CONTINUE
C
         IF (PARLE1) THEN
C
C     COMPUTE RESIDUALS WHERE THERE IS NO CHANCE OF OVERFLOW
C
            DO 200 J = 1,NPARMA
               IF (I-J.GE.ISTART)
     +            T(IMOD) = T(IMOD) + PARMA(J)*T(MOD(I-J+1-N1,MBO1)+1)
  200       CONTINUE
         ELSE
C
C     COMPUTE RESIDUALS WHERE THERE IS A CHANCE OF OVERFLOW
C
            DO 205 J = 1,NPARMA
               IF (I-J.GE.ISTART) THEN
                  IMOD1 = MOD(I-J+1-N1,MBO1)+1
                  IF (PARMA(J).NE.0.0D0 .AND. T(IMOD1).NE.0.0D0) THEN
                     IF (LOG(ABS(PARMA(J)))+LOG(ABS(T(IMOD1))).LT.
     +                         LOG(FPLPM)
     +                     .AND.
     +                     (SIGN(1.0D0,T(IMOD)).NE.
     +                         SIGN(1.0D0,PARMA(J)*T(IMOD1))
     +                     .OR.
     +                     LOG(ABS(PARMA(J)))+LOG(ABS(T(IMOD1))).LT.
     +                         LOG(FPLPM-ABS(T(IMOD))))) THEN
                        T(IMOD) = T(IMOD) + PARMA(J)*T(IMOD1)
                     ELSE
                        GO TO 300
                     END IF
                  END IF
               END IF
  205       CONTINUE
         END IF
         IF (I-MBO.GE.ISTART) THEN
            RESTS(I-MBO) = T(MOD(I-MBO+1-N1,MBO1)+1)
         END IF
  210 CONTINUE
      DO 220 I = N-MBO+1,N
        RESTS(I) = T(MOD(I-MBO+2-N1,MBO1)+1)
  220 CONTINUE
C
      DO 230 I = N1, ISTART-1
         RESTS(I) = 0.0D0
  230 CONTINUE
C
      RETURN
C
C     SET RESIDUALS TO LARGEST POSSIBLE VALUE
C
  300 RESMAX = SQRT(FPLPM/(N2-N1+1))
      DO 310 I=N1,N2
         RESTS(I) = RESMAX
  310 CONTINUE
C
      RETURN
C
      END
*MDLTS3
      SUBROUTINE MDLTS3 (PAR, NPAR, XM, N, M, IXM, RESTS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR ESTIMATING BOX-JENKINS
C     ARIMA MODELS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 4, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),RESTS(NRESTS),XM(IXM,M)
C
C  SCALARS IN COMMON
      INTEGER
     +   IFLAG,MBO,MBOL,MSPECT,NFACT,NPARAR,NPARDF,NPARMA,NRESTS,
     +   PARAR,PARDF,PARMA,T,TEMP
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   PMU
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL MDLTS2
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /MDLTSC/MSPECT,NFACT,PARDF,NPARDF,PARAR,NPARAR,PARMA,
     +   NPARMA,MBO,MBOL,T,TEMP,NRESTS,IFLAG
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IFLAG
C        AN INDICATOR VARIABLE DESIGNATING WHETHER THE BACK FORECASTS
C        WERE ESSENTIALLY ZERO (IFLAG=0) OR NOT (IFLAG=1).
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IXM
C        THE FIRST DIMENSION OF MATRIX XM.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MBO
C        THE MAXIMUM BACK ORDER OPERATOR.
C     INTEGER MBOL
C        THE MAXIMUM BACK ORDER ON THE LEFT
C     INTEGER MSPECT
C        THE STARTING LOCATION IN THE WORK SPACE FOR
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFACT
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARAR
C        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
C     INTEGER NPARDF
C        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
C     INTEGER NPARMA
C        THE LENGTH OF THE VECTOR PARMA
C     INTEGER NRESTS
C        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     INTEGER PARAR
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        THE AUTOREGRESSIVE PARAMETERS
C     INTEGER PARDF
C        THE STARTING LOCATION IN THE WORK SPACE FOR
C        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
C     INTEGER PARMA
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        THE MOVING AVERAGE PARAMETERS
C     DOUBLE PRECISION PMU
C        THE VALUE OF MU, I.E., THE TREND OR MEAN.
C     DOUBLE PRECISION RESTS(NRESTS)
C        THE RESIDUALS FROM THE ARIMA MODEL.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER T
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        A TEMPORARY WORK VECTOR.
C     INTEGER TEMP
C        THE STARTING LOCATION IN THE WORK ARRAY FOR
C        A TEMPORARY WORK VECTOR
C     DOUBLE PRECISION XM(IXM,M)
C        THE INDEPENDENT VARIABLE.
C
C
C     COMPUTE RESIDUALS
C
      CALL MDLTS2 (PAR, RESTS, XM(1,1), NPAR, N, NFACT, ISTAK(MSPECT),
     +  PMU, RSTAK(PARDF), NPARDF, RSTAK(T), RSTAK(TEMP), RSTAK(PARAR),
     +  RSTAK(PARMA), MBO, N-NRESTS+1, N, IFLAG)
C
      RETURN
      END
*MDL1
      SUBROUTINE MDL1(PAR, NPAR, XM, N, M, IXM, PV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     MODEL FUNCTION FOR NLS EXERCISER
C
C     WRITTEN BY  -  LINDA L. MITCHELL
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PV(N),XM(IXM,M)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION PAR(NPAR)
C        MODEL PARAMETERS
C     INTEGER I
C        ROW INDEX
C     INTEGER IXM
C        ACTUAL FIRST DIMENSION OF XM
C     INTEGER M
C        NUMBER OF VARIABLES
C     INTEGER N
C        NUMBER OF OBSERVATIONS
C     INTEGER NPAR
C        NUMBER OF PARAMETERS
C     DOUBLE PRECISION PV(N)
C        PREDICTED VALUES
C     DOUBLE PRECISION XM(IXM,M)
C        INDEPENDENT VARIABLES
C
      DO 10 I=1,N
         PV(I) = PAR(1)*XM(I,1)**PAR(2)
   10 CONTINUE
      RETURN
      END
*MDL2
      SUBROUTINE MDL2(PAR, NPAR, XM, N, M, IXM, PV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     MODEL FUNCTION FOR NLS EXERCISER
C
C     WRITTEN BY  -  LINDA L. MITCHELL
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PV(N),XM(IXM,M)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        ROW INDEX
C     INTEGER IXM
C        ACTUAL FIRST DIMENSION OF XM
C     INTEGER M
C        NUMBER OF VARIABLES
C     INTEGER N
C        NUMBER OF OBSERVATIONS
C     INTEGER NPAR
C        NUMBER OF PARAMETERS
C     DOUBLE PRECISION PAR(NPAR)
C        MODEL PARAMETERS
C     DOUBLE PRECISION PV(N)
C        PREDICTED VALUES
C     DOUBLE PRECISION XM(IXM,M)
C        INDEPENDENT VARIABLES
C
      DO 10 I=1,N
         PV(I) = PAR(1)*XM(I,1) + PAR(2)*XM(I,2) + PAR(3)*XM(I,3)**3
   10 CONTINUE
      RETURN
      END
*MDL3
      SUBROUTINE MDL3(PAR, NPAR, XM, N, M, IXM, PV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     MODEL FUNCTION FOR NLS EXERCISER
C
C     WRITTEN BY  -  LINDA L. MITCHELL
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PV(N),XM(IXM,M)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        ROW INDEX
C     INTEGER IXM
C        ACTUAL FIRST DIMENSION OF XM
C     INTEGER M
C        NUMBER OF VARIABLES
C     INTEGER N
C        NUMBER OF OBSERVATIONS
C     INTEGER NPAR
C        NUMBER OF PARAMETERS
C     DOUBLE PRECISION PAR(NPAR)
C        MODEL PARAMETERS
C     DOUBLE PRECISION PV(N)
C        PREDICTED VALUES
C     DOUBLE PRECISION XM(IXM,M)
C        INDEPENDENT VARIABLES
C
      DO 10 I=1,N
         PV(I) = PAR(1)*XM(I,1) + PAR(2)*XM(I,2) + PAR(3)*XM(I,3) +
     +      PAR(4)*XM(I,4) + PAR(5)*XM(I,5)
   10 CONTINUE
      RETURN
      END
*MDL4
      SUBROUTINE MDL4 (PAR, NPAR, XM, N, M, IXM, PV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     MODEL ROUTINE FOR STEP SIZE AND DERIVATIVE CHECKING ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PV(N),XM(IXM,M)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C  INTRINSIC FUNCTIONS
      INTRINSIC EXP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS OF DATA.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN COEFFICIENTS IN THE MODEL.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        COEFFICIENTS ARE STORED.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUES FROM THE FIT.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
      DO 10 I = 1, N
         PV(I) = PAR(1) + PAR(3)*EXP(-((XM(I,1)-PAR(2))**2)/PAR(4))
   10 CONTINUE
C
      RETURN
C
      END
*MGS
      SUBROUTINE MGS(A, B, N, NP, X, C, D, R, IR, IA, IER)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE SOLUTION  X  TO THE LINEAR SYSTEM OF
C     EQUATIONS  AX=B, USING THE METHOD OF MODIFIED GRAM-SCHMIDT.
C     THE MATRIX A IS DECOMPOSED INTO THREE MATRICES
C        Q  AN ORTHOGONAL MATRIX
C        D  A DIAGONAL MATRIX AND
C        R  AN UPPER TRIANGULAR MATRIX
C     THE SOLUTION VECTOR X IS THE VECTOR WHICH SOLVES THE SYSTEM
C     OF EQUATIONS  RX = C
C     X, A, AND B ARE NOT PRESERVED ON OUTPUT
C
C     ADAPTED FROM OMNITAB II BY -
C                  JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IA,IER,IR,N,NP
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   A(IA,NP),B(N),C(NP),D(NP),R(IR,NP),X(NP)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   SM1,SM2
      INTEGER
     +   I,J,JJ,K,NPJJMJ
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION A(IA,NP)
C           THE COEFFICIENTS MATRIX (NOT PRESERVED ON OUTPUT)
C     DOUBLE PRECISION B(N)
C           THE CONSTANT COLUMN MATRIX OF THE SYSTEM (NOT PRESERVED
C           ON OUTPUT)
C     DOUBLE PRECISION C(NP)
C           THE MATRIX C DESCRIBED ABOVE
C     DOUBLE PRECISION D(NP)
C           THE DIAGONAL ELEMENTS OF THE MATRIX D DESCRIBED ABOVE
C     INTEGER I
C           *
C     INTEGER IA
C           THE ROW DIMENSION OF A.
C     INTEGER IER
C           *
C     INTEGER IR
C           THE ROW DIMENSION OF R.
C     INTEGER J
C           *
C     INTEGER JJ
C           *
C     INTEGER K
C           *
C     INTEGER N
C           THE NUMBER OF OBSERVATIONS
C     INTEGER NP
C           THE NUMBER OF PARAMETERS
C     INTEGER NPJJMJ
C           *
C     DOUBLE PRECISION R(IR,NP)
C           THE UPPER ELEMENTS OF THE MATRIX R DESCRIBED ABOVE
C     DOUBLE PRECISION SM1
C           *
C     DOUBLE PRECISION SM2
C           *
C     DOUBLE PRECISION X(NP)
C           THE SOLUTION MATRIX
C
C
      IER = 0
C
      SM1 = 0.0D0
      SM2 = 0.0D0
      DO 10 I=1,N
         SM1 = A(I,1)*A(I,1) + SM1
         SM2 = A(I,1)*B(I) + SM2
   10 CONTINUE
      IF (SM1.EQ.0.0D0) GO TO 100
      D(1) = SM1
      C(1) = SM2/SM1
      IF (NP.EQ.1) GO TO 70
      DO 60 K=2,NP
         DO 40 J=K,NP
            SM1 = 0.0D0
            DO 20 I=1,N
               SM1 = A(I,K-1)*A(I,J) + SM1
   20       CONTINUE
            R(K-1,J) = SM1/D(K-1)
            DO 30 I=1,N
               A(I,J) = A(I,J) - A(I,K-1)*R(K-1,J)
   30       CONTINUE
   40    CONTINUE
         SM1 = 0.0D0
         SM2 = 0.0D0
         DO 50 I=1,N
            B(I) = B(I) - A(I,K-1)*C(K-1)
            SM1 = A(I,K)*A(I,K) + SM1
            SM2 = A(I,K)*B(I) + SM2
   50    CONTINUE
         IF (SM1.EQ.0.0D0) GO TO 100
         D(K) = SM1
         C(K) = SM2/SM1
   60 CONTINUE
C
C     COMPLETE BACKSOLVE
C
   70 X(NP) = C(NP)
      IF (NP.EQ.1) RETURN
      DO 90 I=2,NP
         K = NP + 1 - I
         JJ = K + 1
         SM1 = 0.0D0
         DO 80 J=JJ,NP
            NPJJMJ = NP + JJ - J
            SM1 = R(K,NPJJMJ)*X(NPJJMJ) + SM1
   80    CONTINUE
         X(K) = C(K) - SM1
   90 CONTINUE
      RETURN
  100 IER = 1
      RETURN
      END
*MODSUM
      SUBROUTINE MODSUM(NFAC, MSPECT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRINTS THE MODEL SUMMARY FOR THE ARIMA ROUTINES
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 4, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   NFAC
C
C  ARRAY ARGUMENTS
      INTEGER
     +   MSPECT(NFAC,4)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT,J
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER MSPECT(NFAC,4)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
C
C
      CALL IPRINT(IPRT)
C
C     PRINT MODEL SPECIFICATION
C
      WRITE(IPRT, 1002) (I, (MSPECT(I,J),J=1,4), I=1,NFAC)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1002 FORMAT(//
     +   '    MODEL SPECIFICATION'//
     +   '       FACTOR          (P     D     Q)    S'//
     +   (7X, I6, 6X, 4I6))
      END
*MPP
      SUBROUTINE MPP(YM, X, N, M, IYM)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT WITH MULTIPLE Y-AXIS VALUES (SHORT CALL).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IYM,M,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   ILOG,IPRT,ISCHCK,ISIZE,LISYM,NOUT
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(IYM,M)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'P',       'P',       ' ',       ' ',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      XMISS = 1.0D0
      MULTI = .TRUE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 2
      ISIZE = -1
      NOUT = 0
      MISS = .FALSE.
      LISYM = 1
C
      CALL PPCNT (YM, YM, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL MPP (YM, X, N, M, IYM)')
      END
*MPPC
      SUBROUTINE MPPC(YM, X, N, M, IYM, ILOG, ISIZE, NOUT, YLB, YUB,
     +  XLB, XUB)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT WITH MULTIPLE Y-AXIS VALUES (LONG CALL).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   ILOG,ISIZE,IYM,M,N,NOUT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   IPRT,ISCHCK,LISYM
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(IYM,M)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'P',       'P',       'C',       ' ',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      XMISS = 1.0D0
      MULTI = .TRUE.
      ISCHCK = 2
      MISS = .FALSE.
      LISYM = 1
C
      CALL PPCNT (YM, YM, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL MPPC (YM, X, N, M, IYM, ILOG,'/
     +  '      +           ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      END
*MPPL
      SUBROUTINE MPPL(YM, X, N, M, IYM, ILOG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT WITH MULTIPLE Y-AXIS VALUES (LOG OPTION).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,IYM,M,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   IPRT,ISCHCK,ISIZE,LISYM,NOUT
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(IYM,M)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'P',       'P',       'L',       ' ',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      XMISS = 1.0D0
      MULTI = .TRUE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 2
      ISIZE = -1
      NOUT = 0
      MISS = .FALSE.
      LISYM = 1
C
      CALL PPCNT (YM, YM, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL MPPL (YM, X, N, M, IYM, ILOG)')
      END
*MPPM
      SUBROUTINE MPPM(YM, YMMISS, X, XMISS, N, M, IYM)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT WITH MULTIPLE Y-AXIS VALUES AND WITH MISSING
C     OBSERVATIONS (SHORT CALL).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   IYM,M,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   ILOG,IPRT,ISCHCK,ISIZE,LISYM,NOUT
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(IYM,M)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(M)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'P',       'P',       'M',       ' ',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      MULTI = .TRUE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 2
      ISIZE = -1
      NOUT = 0
      MISS = .TRUE.
      LISYM = 1
C
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL MPPM (YM, YMMISS, X, XMISS, N, M, IYM)')
      END
*MPPMC
      SUBROUTINE MPPMC(YM, YMMISS, X, XMISS, N, M, IYM, ILOG, ISIZE,
     +   NOUT, YLB, YUB, XLB, XUB)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT WITH MULTIPLE Y-AXIS VALUES AND WITH MISSING
C     OBSERVATIONS (LONG CALL).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   ILOG,ISIZE,IYM,M,N,NOUT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,ISCHCK,LISYM
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(N,M)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(M)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'P',       'P',       'M',       'C',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      MULTI = .TRUE.
      ISCHCK = 2
      MISS = .TRUE.
      LISYM = 1
C
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL MPPMC (YM, YMMISS, X, XMISS, N, M, IYM, ILOG,'/
     +   '      +            ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      END
*MPPML
      SUBROUTINE MPPML(YM, YMMISS, X, XMISS, N, M, IYM, ILOG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT WITH MULTIPLE Y-AXIS VALUES AND WITH MISSING
C     OBSERVATIONS (LOG OPTION).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   ILOG,IYM,M,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   IPRT,ISCHCK,ISIZE,LISYM,NOUT
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(IYM,M)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(M)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'P',       'P',       'M',       'L',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      MULTI = .TRUE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 2
      ISIZE = -1
      NOUT = 0
      MISS = .TRUE.
      LISYM = 1
C
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL MPPML (YM, YMMISS, X, XMISS, N, M, IYM, ILOG)')
      END
*MSGX
      SUBROUTINE MSGX(IER, IPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRINTS THE RETURNED AND EXPECTED VALUES FOR THE
C     ERROR FLAG IERR
C
C     WRITTEN BY -
C        LINDA MITCHELL
C        STATISTICAL ENGINEERING DIVISION
C        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IER,IPRT
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIBLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IER
C        EXPECTED VALUE OF ERROR FLAG IERR
C     INTEGER IERR
C        RETURNED ERROR FLAG FOUND IN THE COMMON ERRCHK
C     INTEGER IPRT
C        LOGICAL OUTPUT DEVICE
C
C
C     PRINT MESSAGE
      WRITE (IPRT,1000) IER, IERR
C
      IF (IER.NE.IERR) WRITE (IPRT,1010)
C
      RETURN
C
C     FORMAT STATEMENT
C
 1000 FORMAT(/28H EXPECTED VALUE FOR IERR IS , I1/15H RETURNED VALUE,
     +   12H FOR IERR IS, I2)
 1010 FORMAT(48H POSSIBLE ERROR, UNEXPECTED VALUE FOR ERROR FLAG)
      END
*MULTBP
      SUBROUTINE MULTBP(T, LT, C, LC, TEMP, LTEMP, MBO)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE MULTIPLIES TOGETHER TWO DIFFERENCE FACTORS FROM A
C     (BOX-JENKINS) TIME SERIES MODEL.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  AUGUST 1, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LC,LT,LTEMP,MBO
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   C(MBO),T(2*MBO),TEMP(MBO)
C
C  LOCAL SCALARS
      INTEGER
     +   I,J,JI,K
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION C(MBO)
C        THE SECOND FACTOR ON INPUT AND THE EXPANDED FACTOR ON OUTPUT.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER JI
C        AN INDEX VARIABLE
C     INTEGER K
C        AN INDEX VARIABLE.
C     INTEGER LC
C        THE LARGEST ORDER OF THE SECOND FACTOR ON INPUT, AND
C        THE LARGEST ORDER OF THE EXPANDED FACTOR ON OUTPUT.
C     INTEGER LT
C        THE LARGEST ORDER OF THE FIRST FACTOR.
C     INTEGER LTEMP
C        THE LENGTH OF THE VECTOR TEMP.
C     INTEGER MBO
C        THE MAXIMUM BACK ORDER OPERATOR.
C     DOUBLE PRECISION T(2*MBO)
C        A TEMPORARY WORK VECTOR.
C     DOUBLE PRECISION TEMP(MBO)
C        A TEMPORARY WORK VECTOR
C
      IF (LC .EQ. 0) GO TO 15
      DO 10 J = 1, LC
         TEMP(J) = C(J)
   10 CONTINUE
   15 K = LC + 1
      DO 20 J=K,LTEMP
         TEMP(J) = 0.0D0
   20 CONTINUE
      IF (LT .EQ. 0) GO TO 50
      DO 40 J=1,LT
         TEMP(J) = TEMP(J) + T(J)
         IF (LC .EQ. 0) GO TO 40
         DO 30 I=1,LC
            JI = J + I
            TEMP(JI) = TEMP(JI) - C(I)*T(J)
   30    CONTINUE
   40 CONTINUE
C
   50 DO 60 J=1,LTEMP
         C(J) = TEMP(J)
   60 CONTINUE
      LC = LTEMP
      RETURN
      END
*MVCHK
      LOGICAL FUNCTION MVCHK (X, XMISS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CHECKS WHETHER X = XMISS (MVCHK = TRUE) OR NOT
C     (MVCHK = FALSE) IN A MANNER WHICH WILL PREVENT VERY LARGE OR
C     VERY SMALL MISSING VALUE CODES FROM CAUSING AN OVERFLOW.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   X,XMISS
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION X
C        THE VALUE TO BE CHECKED.
C     DOUBLE PRECISION XMISS
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
C        NOT AN OBSERVATION IS MISSING.  IF X = XMISS,
C        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
C
      IF ((X .GT. 0.0D0 .AND. XMISS .LT. 0.0D0) .OR.
     +    (X .LT. 0.0D0 .AND. XMISS .GT. 0.0D0)) GO TO 10
C
      IF (ABS(X) .EQ. ABS(XMISS)) GO TO 20
C
   10 MVCHK = .FALSE.
      RETURN
C
   20 MVCHK = .TRUE.
      RETURN
C
      END
*MVP
      SUBROUTINE MVP(YM, N, M, IYM, NS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT WITH MULTIPLE Y-AXIS VALUES (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IYM,M,N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IPRT,IRLIN,ISCHCK,ISIZE,LISYM
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(IYM,M)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'V',       'P',       ' ',       ' ',       ' '/
C
C     DEFINE CONSTANTS
C
C     SET DEFAULT VALUES
C
      MULTI = .TRUE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 2
      ISIZE = -1
      MISS = .FALSE.
      LISYM = 1
      IRLIN = -1
      IBAR = 0
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YM, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL MVP (YM, N, M, IYM, NS)')
      END
*MVPC
      SUBROUTINE MVPC(YM, N, M, IYM, NS, ILOG, ISIZE,
     +   YLB, YUB, XLB, XINC)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT WITH MULTIPLE Y-AXIS VALUES (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   ILOG,ISIZE,IYM,M,N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IBAR,IPRT,IRLIN,ISCHCK,LISYM
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(IYM,M)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'V',       'P',       'C',       ' ',       ' '/
C
C     SET DEFAULT VALUES
C
      MULTI = .TRUE.
      IRLIN = -1
      IBAR = -1
      ISCHCK = 2
      MISS = .FALSE.
      LISYM = 1
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YM, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL MVPC (YM, N, M, IYM, NS, ILOG,'/
     + '      +           ISIZE, YLB, YUB, XLB, XINC)')
      END
*MVPL
      SUBROUTINE MVPL(YM, N, M, IYM, NS, ILOG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT WITH MULTIPLE Y-AXIS VALUES (LOG PLOT OPTION).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,IYM,M,N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,IPRT,IRLIN,ISCHCK,ISIZE,LISYM
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(IYM,M)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'V',       'P',       'L',       ' ',       ' '/
C
C     SET DEFAULT VALUES
C
      MULTI = .TRUE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 2
      ISIZE = -1
      MISS = .FALSE.
      LISYM = 1
      IRLIN = -1
      IBAR = 0
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YM, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL MVPL (YM, N, M, IYM, NS, ILOG)')
      END
*MVPM
      SUBROUTINE MVPM(YM, YMMISS, N, M, IYM, NS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT WITH MISSING DATA AND MULTIPLE Y-AXIS VALUES
C     (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IYM,M,N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IPRT,IRLIN,ISCHCK,ISIZE,LISYM
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(IYM,M)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(M)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'V',       'P',       'M',       ' ',       ' '/
C
C     SET DEFAULT VALUES
C
      MULTI = .TRUE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 2
      ISIZE = -1
      MISS = .TRUE.
      LISYM = 1
      IRLIN = -1
      IBAR = 0
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL MVPM (YM, YMMISS, N, M, IYM, NS)')
      END
*MVPMC
      SUBROUTINE MVPMC(YM, YMMISS, N, M, IYM, NS, ILOG, ISIZE,
     +   YLB, YUB, XLB, XINC)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT WITH MISSING DATA AND MULTIPLE Y-AXIS VALUES (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   ILOG,ISIZE,IYM,M,N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IBAR,IPRT,IRLIN,ISCHCK,LISYM
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(IYM,M)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(M)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'V',       'P',       'M',       'C',       ' '/
C
C     SET DEFAULT VALUES
C
      MULTI = .TRUE.
      IRLIN = -1
      IBAR = -1
      ISCHCK = 2
      MISS = .TRUE.
      LISYM = 1
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL MVPMC (YM, YMMISS, N, M, IYM, NS, ILOG,'/
     +  '      +            ISIZE, YLB, YUB, XLB, XINC)')
      END
*MVPML
      SUBROUTINE MVPML(YM, YMMISS, N, M, IYM, NS, ILOG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT WITH MISSING DATA AND MULTIPLE Y-AXIS VALUES
C     (LOG PLOT OPTION).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,IYM,M,N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,IPRT,IRLIN,ISCHCK,ISIZE,LISYM
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(IYM,M)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(M)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'V',       'P',       'M',       'L',       ' '/
C
C     SET DEFAULT VALUES
C
      MULTI = .TRUE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 2
      ISIZE = -1
      MISS = .TRUE.
      LISYM = 1
      IRLIN = -1
      IBAR = 0
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL MVPML (YM, YMMISS, N, M, IYM, NS, ILOG)')
      END
*NCHOSE
      INTEGER FUNCTION NCHOSE(N,K)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE IS USED TO COMBINE THE DIFFERENCE FACTORS FROM A
C     (BOX-JENKINS) TIME SERIES MODEL.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   K,N
C
C  LOCAL SCALARS
      INTEGER
     +   I,KK,NN
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN
C
C
      IF (N .GT. K) GO TO 10
      NCHOSE = 1
      RETURN
C
   10 KK = MIN(K, N - K)
      NN = 1
      DO 20 I = 1, KK
         NN = (NN*(N - I + 1))/I
   20 CONTINUE
      NCHOSE = NN
      RETURN
      END
*NLCMP
      SUBROUTINE NLCMP (Y, WEIGHT, WT, LWT, N, NPAR, NPARE,
     +   RES, D, RD, COND, VCVL, LVCVL, NNZW, IDF, RSSHLF, RSS, RSD,
     +   YSS, EXACT, PVT, SDPVT, SDREST, ISKULL)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES VARIOUS STATISTICS AND VALUES RETURNED
C     AND/OR PRINTED BY THE NLS FAMILY OF ROUTINES WHEN WEIGHTS ARE
C     INVOLVED.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   COND,RSD,RSS,RSSHLF,YSS
      INTEGER
     +   IDF,LVCVL,LWT,N,NNZW,NPAR,NPARE
      LOGICAL
     +   EXACT,WEIGHT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PVT(N),RD(N),RES(N),SDPVT(N),SDREST(N),VCVL(LVCVL),
     +   WT(LWT),Y(N)
      INTEGER
     +   ISKULL(10)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FAC,FPLM,RVAR,SM,TJ,WTI,WTSUM,YWTSM,YWTYSM
      INTEGER
     +   I,J,JK,K
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL FITEXT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,SQRT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION COND
C        THE CONDITION NUMBER OF D.
C     DOUBLE PRECISION D(N,NPAR)
C        THE FIRST DERIVATIVE OF THE MODEL (JACOBIAN).
C     LOGICAL EXACT
C        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
C        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION FAC
C        A FACTOR USED TO CORRECT FOR ZERO WEIGHTED OBSERVATIONS IN
C        THE VARIANCE COVARIANCE COMPUTATION.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IDF
C        THE DEGREES OF FREEDOM IN THE FIT.
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER ISKULL(10)
C        AN ERROR MESSAGE INDICATOR VARIABLE.
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER JK
C        THE INDEX OF THE (J,K)TH ELEMENT OF THE VARIANCE-COVARIANCE
C        MATRIX.
C     INTEGER K
C        AN INDEX VARIABLE.
C     INTEGER LVCVL
C        THE DIMENSION OF VECTOR VCVL.
C     INTEGER LWT
C        THE DIMENSION OF VECTOR WT.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
C     DOUBLE PRECISION PVT(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
C     DOUBLE PRECISION RD(N)
C        THE DIAGONAL ELEMENTS OF THE R MATRIX OF THE Q - R
C        FACTORIZATION OF D.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     DOUBLE PRECISION RSS
C        THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION RSSHLF
C        HALF THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION RVAR
C        THE RESIDUAL VARIANCE.
C     DOUBLE PRECISION SDPVT(N)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDREST(N)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION SM
C        A VARIABLE USED FOR SUMMATION.
C     DOUBLE PRECISION TJ
C        ...
C     DOUBLE PRECISION VCVL(LVCVL)
C        THE LOWER HALF OF THE VARIANCE-COVARIANCE MATRIX, STORED
C        ROW WISE.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION WTI
C        THE ACTUAL WEIGHT USED FOR THE ITH OBSERVATION.
C     DOUBLE PRECISION WTSUM
C        THE SUM OF THE WEIGHTS.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C     DOUBLE PRECISION YSS
C        THE SUM OF THE SQUARES ABOUT THE MEAN Y VALUE.
C     DOUBLE PRECISION YWTSM
C        THE SUM OF THE VALUES Y(I)*WT(I), I=1,N.
C     DOUBLE PRECISION YWTYSM
C        THE SUM OF THE VALUES Y(I)*WT(I)*WT(I), I=1,N.
C
      FPLM = D1MACH(2)
C
C     COMPUTE RESIDUALS
C
      DO 10 I=1,N
         RES(I) = Y(I) - PVT(I)
   10 CONTINUE
C
C     COMPUTE VARIOUS STATISTICS
C
      IDF = NNZW - NPARE
      RSS = 2.0D0*RSSHLF
      RVAR = 0.0D0
      IF (IDF.GE.1) RVAR = RSS/IDF
      RSD = SQRT(RVAR)
      YWTSM = 0.0D0
      YWTYSM = 0.0D0
      WTSUM = 0.0D0
      DO 20 I=1,N
         WTI = 1.0D0
         IF (WEIGHT) WTI = WT(I)
         YWTSM = YWTSM + Y(I)*WTI
         YWTYSM = YWTYSM + Y(I)*WTI*Y(I)
         WTSUM = WTSUM + WTI
   20 CONTINUE
      YSS = MAX(YWTYSM-(YWTSM*YWTSM)/WTSUM,0.0D0)
C
      CALL FITEXT(RSS, YSS, EXACT)
C
      COND = FPLM
      IF (RD(NPARE).NE.0.0D0) COND = ABS(RD(1)/RD(NPARE))
C
      IF (IERR.NE.0) RETURN
C
C     CORRECT FOR DEGREES OF FREEDOM IF NECESSARY BECAUSE OF ZERO
C     WEIGHTED OBSERVATIONS.
C
      IF (N.EQ.NNZW) GO TO 40
C
      FAC = N-NPARE
      IF (IDF.GE.1) FAC = FAC/IDF
      DO 30 I=1,LVCVL
         VCVL(I) = VCVL(I)*FAC
   30 CONTINUE
C
   40 CONTINUE
C
C     IF THE RESIDUAL SUM OF SQUARES IS IDENTICALLY ZERO, THEN
C     NO FURTHER COMPUTATIONS ARE NECESSARY
C
      IF ((IDF.LE.0) .OR. EXACT) RETURN
C
C     IF THE STANDARD DEVIATIONS OF THE PREDICTED VALUES AND
C     STANDARDIZED RESIDUALS ARE NOT SAVED OR PRINTED, THEN NO
C     FURTHER COMPUTATIONS ARE NECESSARY.
C
C     COMPUTE THE STANDARD DEVIATIONS OF THE PREDICTED VALUES (SDPVT)
C
      DO 90 I=1,N
         SM = 0.0D0
         DO 60 J=1,NPARE
            TJ = 0.0D0
            DO 50 K=1,NPARE
               IF (J.GE.K) THEN
                  JK = J*(J-1)/2 + K
               ELSE
                  JK = K*(K-1)/2 + J
               END IF
               TJ = TJ + VCVL(JK)*D(I,K)
   50       CONTINUE
               SM = SM + D(I,J)*TJ
   60    CONTINUE
         IF (SM.LT.0.0D0) SM = 0.0D0
         SDPVT(I) = SQRT(SM)
C
         SDREST(I) = FPLM
         WTI = 1.0D0
         IF (WEIGHT) WTI = WT(I)
         IF (WTI.EQ.0.0D0) GO TO 90
C
         IF (RVAR/WTI-SM.LE.0.0D0) GO TO 70
         GO TO 80
C
C           THEN
C
   70    SDREST(I) = FPLM
         ISKULL(1) = 1
         ISKULL(4) = 1
         IERR = 4
         GO TO 90
C
C           ELSE
C
   80    SDREST(I) = RES(I)/SQRT(RVAR/WTI-SM)
C
C        END IF
C
   90 CONTINUE
C
      RETURN
C
      END
*NLCNT
      SUBROUTINE NLCNT(Y, WT, LWT, XM, N, M, IXM, MDL, NLDRV, APRXDV,
     +   DRV, PAR, NPAR, RES, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS,
     +   STOPP, SCALE, LSCALE, DELTA, IVAPRX, RSD, PV, LPV, SDPV,
     +   LSDPV, SDRES, LSDRES, VCV, IVCV, WEIGHT, SAVE, NNZW, NPARE,
     +   NLHDR, PAGE, WIDE, IPTOUT, NDIGIT, HLFRPT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE CONTROLLING SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IVAPRX,IVCV,IXM,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,LWT,M,
     +   MIT,N,NDIGIT,NNZW,NPAR,NPARE
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,SAVE,WEIGHT,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),STP(*),VCV(*),
     +   WT(*),XM(*),Y(*)
      INTEGER
     +   IFIXED(*),IPTOUT(5)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL,NLDRV,NLHDR
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   D,IFIXD,IFP,IIWORK,IRWORK,IWORK,LVCVL,NALL0,PARE,PVI,
     +   RWORK,SDPVI,SDRESI,VCVL
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CPYASF,CPYVII,NLMN,DCOPY,SETIV,STKCLR
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL APRXDV
C        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
C        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
C        (FALSE).
C     INTEGER D
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE ARRAY IN WHICH THE NUMERICAL DERIVATIVES WITH RESPECT TO
C        EACH PARAMETER ARE STORED.
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL HLFRPT
C        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
C        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
C        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXD
C        THE STARTING LOCATION IN ISTAK OF
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IFIXED(LIFIXD)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IIWORK
C        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
C     INTEGER IPTOUT(5)
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
C     INTEGER IRWORK
C        THE DIMENSION OF THE DOUBLE PRECISION WORK VECTOR RWORK.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IWORK
C        THE STARTING LOCATION IN ISTAK OF
C        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LIFIXD
C        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LSTP
C        THE ACTUAL LENGTH OF THE VECTOR STP.
C     INTEGER LVCVL
C        THE LENGTH OF THE VECTOR CONTAINING
C        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NALL0
C        NUMBER OF ALLOCATIONS ON ENTRY.
C     INTEGER NDIGIT
C        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
C     EXTERNAL NLDRV
C        THE NAME OF THE ROUTINE WHICH CALCULATES THE DERIVATIVES.
C     EXTERNAL NLHDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     INTEGER PARE
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE CURRENT ESTIMATES OF THE PARAMETERS, BUT ONLY
C        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
C     DOUBLE PRECISION PV(LPV)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     INTEGER PVI
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE PREDICTED VALUES.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER RWORK
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE DOUBLE PRECISION WORK VECTOR USED BY THE NL2 SUBROUTINES.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(LSCALE)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(LSDPV)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     INTEGER SDPVI
C        THE STARTING LOCATION IN RWORK OF
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(LSDRES)
C        THE STANDARDIZED RESIDUALS.
C     INTEGER SDRESI
C        THE STARTING LOCATION IN RWORK OF THE
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(LSTP)
C        THE STEP SIZE ARRAY.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE VARIANCE-COVARIANCE MATRIX.
C     INTEGER VCVL
C        THE STARTING LOCATION IN RWORK OF
C        THE VARIANCE-COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     SET VARIOUS PROGRAM VALUES
C
      NALL0 = STKST(1)
C
      IFP = 4
C
      IERR = 0
C
C     SUBDIVIDE WORK AREA FOR LEAST SQUARES ANALYSIS
C
      IIWORK = NPARE + 60
      IRWORK = 94 + 2*N + NPARE*(3*NPARE+33)/2
C
      IFIXD = STKGET(NPAR,2)
      IWORK = STKGET(IIWORK,2)
C
      D = STKGET(N*NPAR,IFP)
      PARE = STKGET(NPARE,IFP)
      PVI = STKGET(N,IFP)
      RWORK = STKGET(IRWORK,IFP)
C
      IF (IERR.EQ.1) RETURN
C
C     SET VALUES FOR IFIXD
C
      IF (IFIXED(1).GE.0) CALL CPYVII(NPAR, IFIXED, 1, ISTAK(IFIXD), 1)
      IF (IFIXED(1).LT.0) CALL SETIV(ISTAK(IFIXD), NPAR, 0)
C
      CALL NLMN(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, MDL, NLDRV,
     +   APRXDV, DRV, ISTAK(IFIXD), PAR, RSTAK(PARE), NPAR, RES, PAGE,
     +   WIDE, HLFRPT, STP, LSTP, MIT, STOPSS, STOPP, SCALE, LSCALE,
     +   DELTA, IVAPRX, IPTOUT, NDIGIT, RSD, RSTAK(PVI), SDPVI,
     +   SDRESI, VCVL, LVCVL, RSTAK(D), ISTAK(IWORK), IIWORK,
     +   RSTAK(RWORK), IRWORK, NLHDR, NPARE)
C
      IF (.NOT.SAVE) GO TO 10
C
      SDPVI = RWORK + SDPVI - 1
      SDRESI = RWORK + SDRESI - 1
      VCVL = RWORK + VCVL - 1
C
      CALL DCOPY(N, RSTAK(PVI), 1, PV, 1)
      CALL DCOPY(N, RSTAK(SDPVI), 1, SDPV, 1)
      CALL DCOPY(N, RSTAK(SDRESI), 1, SDRES, 1)
      CALL CPYASF(NPARE, RSTAK(VCVL), LVCVL, VCV, IVCV)
C
   10 CALL STKCLR(NALL0)
C
      RETURN
C
      END
*NLCNTA
      SUBROUTINE NLCNTA(Y, WT, LWT, XM, N, M, IXM, MDL, DRV, PAR, NPAR,
     +   RES, LDSTAK, IFIXED, LIFIXD, IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE, LSCALE, DELTA, IVCVOP, NPRT, RSD, PV, LPV, SDPV, LSDPV,
     +   SDRES, LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE CONTROLLING SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION USING ANALYTIC (USER-SUPPLIED) DERIVATIVES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IVCV,IVCVOP,IXM,LDSTAK,LIFIXD,LPV,LSCALE,LSDPV,
     +   LSDRES,LWT,M,MIT,N,NNZW,NPAR,NPARE,NPRT
      LOGICAL
     +   SAVE,WEIGHT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),VCV(*),WT(*),
     +   XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   ISUBHD,LDSMIN,LSTP,NDIGIT,NETA,NROW,NTAU
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,PRTFXD,WIDE
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   STP(1)
      INTEGER
     +   IPTOUT(5)
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   ICNTI
      EXTERNAL ICNTI
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DCKCNT,LDSCMP,NLCNT,NLDRVA,NLER,NLHDRA,PRTCNT,STKSET
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL APRXDV
C        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
C        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL HLFRPT
C        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
C        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
C        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
C     INTEGER IDRVCK
C        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
C        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(LIFIXD)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IPTOUT(5)
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IVCVOP
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVCVOP LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVCVOP EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVCVOP EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVCVOP EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVCVOP EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVCVOP EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVCVOP EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVCVOP GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LSTP
C        THE ACTUAL LENGTH OF THE VECTOR STP.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NDIGIT
C        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
C     INTEGER NETA
C        THE NUMBER OF ACCURATE DIGITS IN THE MODEL RESULTS.
C     EXTERNAL NLDRVA
C        THE NAME OF THE ROUTINE WHICH CALCULATES THE DERIVATIVES.
C     EXTERNAL NLHDRA
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     INTEGER NROW
C        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
C        WHICH THE DERIVATIVE IS TO BE CHECKED.
C     INTEGER NTAU
C        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
C        NUMERICALLY APPROXIMATED DERIVATIVES AND THE USER SUPPLIED
C        DRVITIVES.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     LOGICAL PRTFXD
C        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
C        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
C        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PV(LPV)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(LSCALE)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(LSDPV)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(LSDRES)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(1)
C        THE DUMMY STEP SIZE ARRAY.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE VARIANCE-COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     SET VARIOUS PROGRAM VALUES
C
      HLFRPT = .FALSE.
      APRXDV = .FALSE.
      PRTFXD = .TRUE.
      STP(1) = 0.0D0
      LSTP = 1
      NETA = 0
      NTAU = 0
      NROW = 0
C
      WIDE = .TRUE.
      PAGE = .FALSE.
C
      NDIGIT = 5
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      IF ((IFIXED(1).GE.0) .AND. (NPAR.GE.1)) THEN
         NPARE = ICNTI(IFIXED,NPAR,0)
      ELSE
         NPARE = NPAR
      END IF
C
      CALL LDSCMP(6, 0, 60+2*NPAR, 0, 0, 0, 'D',
     +            94+N*(3+NPAR)+NPARE*(3*NPARE+35)/2, LDSMIN)
C
      CALL NLER (NMSUB, WEIGHT, WT, LWT, N, M, IXM,
     +   IFIXED, LIFIXD, NPAR, NPARE,
     +   LDSTAK, LDSMIN, STP, LSTP, SCALE, LSCALE, IVCV, SAVE, NNZW)
C
      IF (IERR.NE.0) RETURN
C
      CALL STKSET(LDSTAK, 4)
C
C     SET PRINT CONTROL VALUES
C
      CALL PRTCNT(NPRT, NDIGIT, IPTOUT)
C
      IF (IDRVCK.EQ.0) GO TO 10
C
C     CHECK DERIVATIVES, IF DESIRED
C
      ISUBHD = 1
      CALL DCKCNT(XM, N, M, IXM, MDL, DRV, PAR, NPAR, NETA, NTAU,
     +   SCALE, LSCALE, NROW, IPTOUT(1), NLHDRA, PAGE, WIDE, ISUBHD,
     +   HLFRPT, PRTFXD, IFIXED, LIFIXD)
C
C     CHECK FOR DEFINITE ERROR IN DERIVATIVES
C
      IF (IERR.LE.2) GO TO 10
      IERR = 1
      RETURN
C
   10 CONTINUE
C
      IERR = 0
C
      CALL NLCNT(Y, WT, LWT, XM, N, M, IXM, MDL, NLDRVA, APRXDV, DRV,
     +   PAR, NPAR, RES, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP,
     +   SCALE, LSCALE, DELTA, IVCVOP, RSD, PV, LPV, SDPV, LSDPV,
     +   SDRES, LSDRES, VCV, IVCV, WEIGHT, SAVE, NNZW, NPARE, NLHDRA,
     +   PAGE, WIDE, IPTOUT, NDIGIT, HLFRPT)
C
      RETURN
C
      END
*NLCNTN
      SUBROUTINE NLCNTN(Y, WT, LWT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVCVOP, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE CONTROLLING SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IVCV,IVCVOP,IXM,LDSTAK,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,
     +   LSTP,LWT,M,MIT,N,NNZW,NPAR,NPARE,NPRT
      LOGICAL
     +   SAVE,WEIGHT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),STP(*),VCV(*),
     +   WT(*),XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   EXMPT
      INTEGER
     +   IFP,IS,ISUBHD,LDSMIN,NALL0,NDIGIT,NETA,STPI
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,PRTFXD,WIDE
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   IPTOUT(5),ISTAK(12)
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   ICNTI,STKGET,STKST
      EXTERNAL ICNTI,STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DRV,LDSCMP,NLCNT,NLDRVN,NLER,NLHDRN,PRTCNT,DCOPY,STKCLR,
     +   STKSET,STPCNT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL APRXDV
C        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
C        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION EXMPT
C        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
C        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
C        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
C     LOGICAL HLFRPT
C        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
C        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
C        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(LIFIXD)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IPTOUT(5)
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
C     INTEGER IS
C        A VALUE USED TO DETERMINE THE AMOUNT OF WORK SPACE NEEDED
C        BASED ON WHETHER STEP SIZES ARE INPUT OR ARE TO BE CALCULATED.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISUBHD
C        AN INTEGER VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IVCVOP
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVCVOP LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVCVOP EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVCVOP EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVCVOP EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVCVOP EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVCVOP EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVCVOP EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVCVOP GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LSTP
C        THE ACTUAL LENGTH OF THE VECTOR STP.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NALL0
C        NUMBER OF ALLOCATIONS ON ENTRY.
C     INTEGER NDIGIT
C        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
C     INTEGER NETA
C        THE NUMBER OF ACCURATE DIGITS IN THE MODEL RESULTS.
C     EXTERNAL NLDRVN
C        THE NAME OF THE ROUTINE WHICH CALCULATES THE DERIVATIVES.
C     EXTERNAL NLHDRN
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     LOGICAL PRTFXD
C        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
C        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
C        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PV(LPV)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(LSCALE)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(LSDPV)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(LSDRES)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(LSTP)
C        THE STEP SIZE ARRAY.
C     INTEGER STPI
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE STEP SIZE ARRAY.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE VARIANCE-COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     SET VARIOUS PROGRAM VALUES
C
      HLFRPT = .FALSE.
      APRXDV = .TRUE.
      PRTFXD = .TRUE.
      EXMPT = -1.0D0
      NETA = 0
C
      WIDE = .TRUE.
      PAGE = .FALSE.
C
      NDIGIT = 5
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      IF ((IFIXED(1).GE.0) .AND. (NPAR.GE.1)) THEN
         NPARE = ICNTI(IFIXED,NPAR,0)
      ELSE
         NPARE = NPAR
      END IF
C
      IF (STP(1).LE.0.0D0) THEN
         IS = 1
      ELSE
         IS = 0
      END IF
C
      CALL LDSCMP(14, 0, MAX(IS*2*(N+NPAR),60+NPAR+NPARE), 0, 0, 0,
     +   'D',
     +   MAX(IS*(9*N+MAX(N,NPAR)),94+N*(3+NPAR)+NPARE*(3*NPARE+37)/2),
     +   LDSMIN)
C
      CALL NLER (NMSUB, WEIGHT, WT, LWT, N, M, IXM,
     +   IFIXED, LIFIXD, NPAR, NPARE,
     +   LDSTAK, LDSMIN, STP, LSTP, SCALE, LSCALE, IVCV, SAVE, NNZW)
C
      IF (IERR.NE.0) RETURN
C
      CALL STKSET(LDSTAK, 4)
C
C     SET PRINT CONTROL VALUES
C
      CALL PRTCNT(NPRT, NDIGIT, IPTOUT)
C
C     SUBDIVIDE WORKSPACE FOR STEP SIZES
C
      NALL0 = STKST(1)
C
      IFP = 4
C
      STPI = STKGET(NPAR,IFP)
C
C     COPY SUPPLIED STEP SIZES TO WORK SPACE
C
      CALL DCOPY(LSTP, STP, 1, RSTAK(STPI), 1)
C
      IF (IERR.NE.0) GO TO 10
C
C     SELECT STEP SIZES, IF DESIRED
C
      ISUBHD = 1
C
      IF (STP(1).LE.0.0D0) CALL STPCNT(XM, N, M, IXM, MDL, PAR, NPAR,
     +   RSTAK(STPI), EXMPT, NETA, SCALE, LSCALE, IPTOUT(1), NLHDRN,
     +   PAGE, WIDE, ISUBHD, HLFRPT, PRTFXD, IFIXED, LIFIXD)
C
      CALL NLCNT(Y, WT, LWT, XM, N, M, IXM, MDL, NLDRVN, APRXDV, DRV,
     +   PAR, NPAR, RES, IFIXED, LIFIXD, RSTAK(STPI), NPAR, MIT,
     +   STOPSS, STOPP, SCALE, LSCALE, DELTA, IVCVOP, RSD, PV, LPV,
     +   SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV, WEIGHT, SAVE, NNZW,
     +   NPARE, NLHDRN, PAGE, WIDE, IPTOUT, NDIGIT, HLFRPT)
C
   10 CONTINUE
C
      CALL STKCLR(NALL0)
C
      RETURN
C
      END
*NLDRVA
      SUBROUTINE NLDRVA (MDL, DRV, DONE, IFIXD, PAR, NPAR, XM, N, M,
     +   IXM, PV, D, WEIGHT, WT, LWT, STP, LSTP, SCL, LSCL)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE ANALYTIC DERIVATIVE MATRIX (JACOBIAN)
C     USING USER-SUPPLIED ROUTINE DERIV.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LSCL,LSTP,LWT,M,N,NPAR
      LOGICAL
     +   DONE,WEIGHT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PAR(NPAR),PV(N),SCL(LSCL),STP(LSTP),WT(LWT),
     +   XM(IXM,M)
      INTEGER
     +   IFIXD(NPAR)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   WTSQRT
      INTEGER
     +   I,J,JPK
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION D(N,NPAR)
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     LOGICAL DONE
C        THE VARIABLE USED TO INDICATE WHETHER THIS IS THE FINAL
C        COMPUTATION OF THE JACOBIAN OR NOT.
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER J
C        THE INDEX OF THE PARAMETER BEING EXAMINED.
C     INTEGER JPK
C        THE INDEX OF THE PACKED PARAMETERS.
C     INTEGER LSCL
C        THE ACTUAL LENGTH OF THE VECTOR SCL.
C     INTEGER LSTP
C        THE ACTUAL LENGTH OF THE VECTOR STP.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION SCL(LSCL)
C        THE SCALE VALUES.
C     DOUBLE PRECISION STP(LSTP)
C        THE SELECTED RELATIVE STEP SIZES.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION WTSQRT
C        THE SQUARE ROOT OF THE ITH WEIGHT.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C
C     COMPUTE JACOBIAN
C
      CALL DRV(PAR, NPAR, XM, N, M, IXM, D)
C
      JPK = 0
C
      DO 20 J=1,NPAR
         IF (IFIXD(J).NE.0) GO TO 20
         JPK = JPK + 1
         DO 10 I=1,N
            WTSQRT = 1.0D0
            IF (WEIGHT .AND. (.NOT.DONE)) WTSQRT = SQRT(WT(I))
            D(I,JPK) = -WTSQRT*D(I,J)
   10    CONTINUE
   20 CONTINUE
C
      RETURN
C
      END
*NLDRVN
      SUBROUTINE NLDRVN (MDL, DRV, DONE, IFIXD, PAR, NPAR, XM, N, M,
     +   IXM, PVT, D, WEIGHT, WT, LWT, STPT, LSTPT, SCL, LSCL)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE NUMERICAL APPROXIMATIONS TO THE
C     DERIVATIVE MATRIX (JACOBIAN).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LSCL,LSTPT,LWT,M,N,NPAR
      LOGICAL
     +   DONE,WEIGHT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PAR(NPAR),PVT(N),SCL(LSCL),STPT(LSTPT),WT(LWT),
     +   XM(IXM,M)
      INTEGER
     +   IFIXD(NPAR)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   PJ,STPJ,WTSQRT
      INTEGER
     +   I,J,JPK
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,SIGN,SQRT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION D(N,NPAR)
C        THE FIRST DERIVATIVE OF THE MODEL (JACOBIAN).
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     LOGICAL DONE
C        THE VARIABLE USED TO INDICATE WHETHER THIS IS THE FINAL
C        COMPUTATION OF THE JACOBIAN OR NOT.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IXM
C        THE FIRST DIMENSION OF MATRIX XM.
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER JPK
C        AN INDEX VARIABLE.
C     INTEGER LSCL
C        THE DIMENSION OF VECTOR SCL.
C     INTEGER LSTPT
C        THE DIMENSION OF VECTOR STPT.
C     INTEGER LWT
C        THE DIMENSION OF VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PJ
C        A TEMPORARY LOCATION FOR STORAGE OF THE JTH PARAMETER.
C     DOUBLE PRECISION PVT(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
C     DOUBLE PRECISION SCL(LSCL)
C        THE SCALE VALUES.
C     DOUBLE PRECISION STPT(LSTPT)
C        THE STEP SIZE ARRAY.
C     DOUBLE PRECISION STPJ
C        THE JTH STEP SIZE.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION WTSQRT
C        THE SQUARE ROOT OF THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE INDEPENDENT VARIABLE.
C
C     COMPUTE FINITE-DIFFERENCE JACOBIAN OF THE OPTIMIZED PARAMETERS
C
      JPK = 0
C
      DO 20 J=1,NPAR
         IF (IFIXD(J).EQ.0) THEN
            JPK = JPK + 1
            PJ = PAR(J)
            IF (SCL(JPK).EQ.0.0D0) THEN
               IF (PAR(J).NE.0.0D0) THEN
                  STPJ = STPT(J)*SIGN(1.0D0,PAR(J))*ABS(PAR(J))
               ELSE
                  STPJ = STPT(J)
               END IF
            ELSE
               STPJ = STPT(J)*
     +                SIGN(1.0D0,PAR(J))*MAX(ABS(PAR(J)),1.0D0/
     +                ABS(SCL(JPK)))
            END IF
C
            STPJ = STPJ + PAR(J)
            STPJ = STPJ - PAR(J)
C
            PAR(J) = PJ + STPJ
            CALL MDL(PAR, NPAR, XM, N, M, IXM, D(1,J))
C
            DO 10 I=1,N
               WTSQRT = 1.0D0
               IF (WEIGHT .AND. (.NOT.DONE)) WTSQRT = SQRT(WT(I))
               D(I,JPK) = WTSQRT*(PVT(I)-D(I,J))/STPJ
   10       CONTINUE
C
            PAR(J) = PJ
         END IF
   20 CONTINUE
C
      RETURN
C
      END
*NLER
      SUBROUTINE NLER (NMSUB, WEIGHT, WT, LWT, N, M, IXM,
     +   IFIXED, LIFIXD, NPAR, NPARE,
     +   LDSTAK, LDSMIN, STP, LSTP, SCALE, LSCALE, IVCV, SAVE, NNZW)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE ERROR CHECKING ROUTINE FOR NONLINEAR LEAST SQUARES
C     ESTIMATION ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IVCV,IXM,LDSMIN,LDSTAK,LIFIXD,LSCALE,LSTP,LWT,M,N,NNZW,
     +   NPAR,NPARE
      LOGICAL
     +   SAVE,WEIGHT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   SCALE(*),STP(*),WT(*)
      INTEGER
     +   IFIXED(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I,NFIX,NNFIX,NV,NZW
      LOGICAL
     +   HEAD
C
C  LOCAL ARRAYS
      LOGICAL
     +   ERROR(20)
      CHARACTER
     +   LIFIX(8)*1,LIVCV(8)*1,LIXM(8)*1,LLDS(8)*1,LM(8)*1,
     +   LN(8)*1,LNPAR(8)*1,LNPARE(8)*1,LONE(8)*1,LSCL(8)*1,
     +   LSTEP(8)*1,LWGT(8)*1,LZERO(8)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EIVEQ,ERVGT,ERVWT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR(20)
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(LIFIXD)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     CHARACTER*1
C    +   LIFIX(8), LIVCV(8), LIXM(8), LLDS(8), LM(8), LN(8), LNPAR(8),
C    +   LNPARE(8), LONE(8), LSCL(8), LSTEP(8), LWGT(8), LZERO(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
C        CHECKED FOR ERRORS.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSTP
C        THE ACTUAL LENGTH OF THE VECTOR STP.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NZW
C        THE NUMBER OF ZERO WEIGHTS.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION STP(LSTP)
C        THE STEP SIZE ARRAY.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE USER SUPPLIED WEIGHTS.
C
C
C     SET UP NAME ARRAYS
C
      DATA LIFIX(1), LIFIX(2), LIFIX(3), LIFIX(4), LIFIX(5),
     +   LIFIX(6), LIFIX(7), LIFIX(8) /'I','F','I','X','E','D',' ',' '/
      DATA LIVCV(1), LIVCV(2), LIVCV(3), LIVCV(4), LIVCV(5),
     +   LIVCV(6), LIVCV(7), LIVCV(8) /'I','V','C','V',' ',' ',' ',' '/
      DATA LIXM(1), LIXM(2), LIXM(3), LIXM(4), LIXM(5), LIXM(6),
     +   LIXM(7), LIXM(8) /'I','X','M',' ',' ',' ',' ',' '/
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +   LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA LM(1), LM(2), LM(3), LM(4), LM(5), LM(6), LM(7), LM(8) /'M',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8) /'N',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LNPAR(1), LNPAR(2), LNPAR(3), LNPAR(4), LNPAR(5),
     +   LNPAR(6), LNPAR(7), LNPAR(8) /'N','P','A','R',' ',' ',' ',
     +   ' '/
      DATA LNPARE(1), LNPARE(2), LNPARE(3), LNPARE(4), LNPARE(5),
     +   LNPARE(6), LNPARE(7), LNPARE(8) /'N','P','A','R','E',' ',' ',
     +   ' '/
      DATA LONE(1), LONE(2), LONE(3), LONE(4), LONE(5),
     +   LONE(6), LONE(7), LONE(8) /'O','N','E',' ',' ',' ',' ',' '/
      DATA LSCL(1), LSCL(2), LSCL(3), LSCL(4), LSCL(5),
     +   LSCL(6), LSCL(7), LSCL(8) /'S','C','A','L','E',' ',' ',
     +   ' '/
      DATA LSTEP(1), LSTEP(2), LSTEP(3), LSTEP(4), LSTEP(5),
     +   LSTEP(6), LSTEP(7), LSTEP(8) /'S','T','P',' ',' ',' ',' ',' '/
      DATA LWGT(1), LWGT(2), LWGT(3), LWGT(4), LWGT(5),
     +   LWGT(6), LWGT(7), LWGT(8) /'W','T',' ',' ',' ',' ',' ',' '/
      DATA LZERO(1), LZERO(2), LZERO(3), LZERO(4), LZERO(5),
     +   LZERO(6), LZERO(7), LZERO(8) /'Z','E','R','O',' ',' ',' ',' '/
C
C     ERROR CHECKING
C
      DO 10 I=1,20
         ERROR(I) = .FALSE.
   10 CONTINUE
C
      IERR = 0
      HEAD = .TRUE.
      NNZW = N
C
      CALL EISGE(NMSUB, LNPAR, NPAR, 1, 2, HEAD, ERROR(1), LONE)
      IF (ERROR(1)) THEN
        ERROR(7) = .TRUE.
      ELSE
        IF (IFIXED(1).LT.0) THEN
          CALL EISGE(NMSUB, LN, N, NPAR, 2, HEAD, ERROR(7), LNPAR)
          IF (WEIGHT) THEN
            CALL ERVWT(NMSUB, LWGT, WT, LWT, NPAR, HEAD, NNZW,
     +                 NZW, 2, ERROR(3), LNPAR)
          END IF
        ELSE
          CALL EIVEQ(NMSUB, LIFIX, IFIXED, NPAR, 0, 1, HEAD, NNFIX,
     +               NFIX, 1, ERROR(2), LZERO, LONE)
          IF (.NOT.ERROR(2)) THEN
            CALL EISGE(NMSUB, LN, N, NPARE, 2, HEAD, ERROR(7), LNPARE)
            IF (WEIGHT) THEN
              CALL ERVWT(NMSUB, LWGT, WT, LWT, NPARE, HEAD, NNZW,
     +                   NZW, 2, ERROR(3), LNPARE)
            END IF
          END IF
        END IF
      END IF
C
      CALL EISGE(NMSUB, LM, M, 1, 2, HEAD, ERROR(4), LONE)
C
      IF (.NOT.ERROR(7))
     +   CALL EISGE(NMSUB, LIXM, IXM, N, 3, HEAD, ERROR(5), LN)
C
C
      IF (.NOT.ERROR(1)) THEN
         IF ((.NOT.ERROR(2)) .AND. (.NOT.ERROR(7)))
     +      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR(6),
     +      LLDS)
C
         CALL ERVGT(NMSUB, LSTEP, STP, LSTP, 0.0D0, 0, HEAD, 6, NV,
     +      ERROR(8), LZERO)
C
         CALL ERVGT(NMSUB, LSCL, SCALE, LSCALE, 0.0D0, 0, HEAD, 6, NV,
     +      ERROR(12), LZERO)
C
         IF (SAVE)
     +      CALL EISGE(NMSUB, LIVCV, IVCV, NPARE, 3, HEAD, ERROR(15),
     +      LNPARE)
      END IF
C
C
      DO 20 I=1,20
         IF (ERROR(I)) GO TO 30
   20 CONTINUE
      RETURN
C
   30 CONTINUE
      IERR = 1
      RETURN
C
      END
*NLERR
      SUBROUTINE NLERR (ICNVCD, ISKULL)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SETS THE ERROR FLAG IERR BASED ON THE CONVERGENCE
C     CODE RETURNED BY NL2.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ICNVCD
C
C  ARRAY ARGUMENTS
      INTEGER
     +   ISKULL(10)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER ICNVCD
C        THE CONVERGENCE CODE FROM NL2.
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER ISKULL(10)
C        AN ERROR MESSAGE INDICATOR VARIABLE.
C
C     INITIALIZE MESSAGE INDICATOR VARIABLE
C
      DO 5 I = 1, 10
         ISKULL(I) = 0
    5 CONTINUE
C
C     SET ERROR FLAG
C
      GO TO (10, 10, 20, 20, 20, 20, 40, 50, 60, 60, 10, 30, 10, 10,
     +   10), ICNVCD
C
C     BAD VALUE
C
   10 IERR = 1
      RETURN
C
C     ACCEPTABLE STOPPING CONDITION
C
   20 IERR = 0
      RETURN
C
C     INITIAL VARIANCE COMPUTATION OVERFLOWS
C
   30 IERR = 2
      ISKULL(2) = 1
      RETURN
C
C     SINGULAR CONVERGENCE
C
   40 IERR = 3
      ISKULL(3) = 1
      RETURN
C
C     FALSE CONVERGENCE
C
   50 IERR = 5
      ISKULL(5) = 1
      RETURN
C
C     ITERATION OR FUNCTION EVALUATION LIMIT
C
   60 IERR = 6
      ISKULL(6) = 1
      RETURN
C
      END
*NLFIN
      SUBROUTINE NLFIN(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, IFIXD,
     +   PAR, NPAR, NPARE, RES, PAGE, WIDE, IPTOUT, NDIGIT, RSSHLF, RSD,
     +   PV, SDPV, SDRES, RD, VCVL, LVCVL, D, NLHDR, IVCVPT, ISKULL)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPLETES THE ANALYSIS FOR THE NONLINEAR
C     LEAST SQUARES ESTIMATION ROUTINES ONCE THE ESTIMATES
C     HAVE BEEN FOUND.
C
C     REFERENCES
C
C        DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1979), AN ADAPTIVE
C             NONLINEAR LEAST-SQUARES ALGORITHM, (BEING REVISED).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD,RSSHLF
      INTEGER
     +   IVCVPT,IXM,LVCVL,LWT,M,N,NDIGIT,NNZW,NPAR,NPARE
      LOGICAL
     +   PAGE,WEIGHT,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PAR(NPAR),PV(N),RD(NPARE),RES(N),SDPV(N),SDRES(N),
     +   VCVL(LVCVL),WT(LWT),XM(IXM,M),Y(N)
      INTEGER
     +   IFIXD(NPAR),IPTOUT(NDIGIT),ISKULL(10)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL NLHDR
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   COND,RSS,YSS
      INTEGER
     +   IDF
      LOGICAL
     +   EXACT,PRTFSM
C
C  EXTERNAL SUBROUTINES
      EXTERNAL NLCMP,NLOUT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION COND
C        THE CONDITION NUMBER OF D.
C     DOUBLE PRECISION D(N,NPAR)
C        THE DERIVATIVE OF THE MODEL (JACOBIAN).
C     LOGICAL EXACT
C        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
C        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
C     INTEGER IDF
C        THE DEGREES OF FREEDOM IN THE FIT.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) HAVE BEEN HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) HAVE BEEN OPTIMIZED.
C     INTEGER IPTOUT(NDIGIT)
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
C     INTEGER ISKULL(10)
C        AN ERROR MESSAGE INDICATOR VARIABLE.
C     INTEGER IVCVPT
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
C        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
C        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                       *INVERSE(HESSIAN)
C        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(HESSIAN)
C        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LVCVL
C        THE LENGTH OF THE VECTOR CONTAINING
C        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NDIGIT
C        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
C     EXTERNAL NLHDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
C        PARAMETERS ARE STORED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     LOGICAL PRTFSM
C        THE VARIABLE USED TO INDICATE WHETHER ANY OF THE SUMMARY
C        INFORMATION IS TO BE PRINTED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RD(NPARE)
C        THE DIAGONAL ELEMENTS OF THE R MATRIX OF THE Q - R
C        FACTORIZATION OF D.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSSHLF
C        HALF THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     DOUBLE PRECISION RSS
C        THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION SDPV(N)
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(N)
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION VCVL(LVCVL)
C        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C     DOUBLE PRECISION YSS
C        THE SUM OF SQUARES OF THE DEPENDENT VARIABLE Y.
C
C
C     COMPUTE RETURNED AND/OR PRINTED VALUES.
C
      CALL NLCMP (Y, WEIGHT, WT, LWT, N, NPAR, NPARE, RES,
     +   D, RD, COND, VCVL, LVCVL, NNZW, IDF, RSSHLF, RSS, RSD, YSS,
     +   EXACT, PV, SDPV, SDRES, ISKULL)
C
      PRTFSM = ((IPTOUT(3).NE.0) .OR. (IPTOUT(4).NE.0) .OR.
     +   (IPTOUT(5).NE.0) .OR. (IERR.NE.0))
C
C     PRINT SUMMARY INFORMATION IF DESIRED OR IF AN ERROR FLAG
C     HAS BEEN SET.
C
      IF (PRTFSM) CALL NLOUT(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM,
     +   IFIXD, PAR, NPAR, NPARE, RES, IPTOUT, NDIGIT, PAGE, IDF, COND,
     +   RSS, RSD, YSS, EXACT, PV, SDPV, SDRES, VCVL, LVCVL, IVCVPT,
     +   ISKULL, NLHDR, WIDE)
      RETURN
C
      END
*NLHDRA
      SUBROUTINE NLHDRA(PAGE, WIDE, ISUBHD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS THE PAGE HEADINGS FOR THE NONLINEAR
C     LEAST SQUARES ESTIMATION ROUTINES THAT USE ANALYTIC
C     (USER-SUPPLIED) DERIVATIVES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISUBHD
      LOGICAL
     +   PAGE,WIDE
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VERSP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C
C
      CALL IPRINT(IPRT)
      IF (PAGE) WRITE (IPRT, 1020)
      CALL VERSP(WIDE)
      IF (PAGE) WRITE (IPRT,1000)
      IF (.NOT.PAGE) WRITE (IPRT,1010)
      PAGE = .TRUE.
C
      IF (ISUBHD.EQ.0) RETURN
C
      GO TO (10), ISUBHD
C
   10 WRITE (IPRT, 1030)
C
      RETURN
C
C     FORMAT STATEMENTS FOR PAGE HEADINGS
C
 1000 FORMAT (35H+NONLINEAR LEAST SQUARES ESTIMATION,
     +   42H WITH USER-SUPPLIED DERIVATIVES, CONTINUED)
 1010 FORMAT ('+', 71(1H*)/
     +   1X, 37H*  NONLINEAR LEAST SQUARES ESTIMATION,
     +   34H WITH USER-SUPPLIED DERIVATIVES  */ 1X, 71(1H*))
 1020 FORMAT ('1')
 1030 FORMAT (//30H SUMMARY OF INITIAL CONDITIONS/ 1X, 30('-'))
      END
*NLHDRN
      SUBROUTINE NLHDRN(PAGE, WIDE, ISUBHD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS THE PAGE HEADINGS FOR THE NONLINEAR
C     LEAST SQUARES ESTIMATION ROUTINES THAT USE NUMERICAL
C     APPROXIMATIONS TO THE DERIVATIVES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISUBHD
      LOGICAL
     +   PAGE,WIDE
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VERSP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C
C
      CALL IPRINT(IPRT)
      IF (PAGE) WRITE (IPRT, 1020)
      CALL VERSP(WIDE)
      IF (PAGE) WRITE (IPRT,1000)
      IF (.NOT.PAGE) WRITE (IPRT,1010)
      PAGE = .TRUE.
C
      IF (ISUBHD.EQ.0) RETURN
C
      GO TO (10), ISUBHD
C
   10 WRITE (IPRT, 1030)
C
      RETURN
C
C     FORMAT STATEMENTS FOR PAGE HEADINGS
C
 1000 FORMAT (35H+NONLINEAR LEAST SQUARES ESTIMATION,
     +   53H WITH NUMERICALLY APPROXIMATED DERIVATIVES, CONTINUED)
 1010 FORMAT ('+', 82(1H*)/
     +   1X, 37H*  NONLINEAR LEAST SQUARES ESTIMATION,
     +   45H WITH NUMERICALLY APPROXIMATED DERIVATIVES  */ 1X, 82(1H*))
 1020 FORMAT ('1')
 1030 FORMAT (//30H SUMMARY OF INITIAL CONDITIONS/ 1X, 30('-'))
      END
*NLINIT
      SUBROUTINE NLINIT (N, IFIXD, PAR, NPAR, PARE, NPARE, MIT,
     +   STOPSS, STOPP, SCALE, LSCALE, DELTA, IVAPRX, APRXDV, IVCVPT,
     +   IWORK, IIWORK, RWORK, IRWORK, SCL)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PERFORMS INITIALIZATION FOR THE NONLINEAR
C     LEAST SQUARES ROUTINES.
C
C     REFERENCES
C
C     DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1979), AN ADAPTIVE
C             NONLINEAR LEAST-SQUARES ALGORITHM, (BEING REVISED).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,STOPP,STOPSS
      INTEGER
     +   IIWORK,IRWORK,IVAPRX,IVCVPT,LSCALE,MIT,N,NPAR,NPARE,SCL
      LOGICAL
     +   APRXDV
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PARE(NPAR),RWORK(IRWORK),SCALE(LSCALE)
      INTEGER
     +   IFIXD(NPAR),IWORK(IIWORK)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   AFCTOL,CNVCOD,COVPRT,COVREQ,DINIT,DTYPE,ISCL,J,LMAX0,
     +   MXFCAL,MXITER,NITER,OUTLEV,PRUNIT,RFCTOL,SCLJ,SOLPRT,
     +   STATPR,X0PRT,XCTOL
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   RMDCON
      EXTERNAL RMDCON
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DFAULT,NLSPK
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,IABS,MAX
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER AFCTOL
C        THE LOCATION IN RWORK OF THE ABSOLUTE CONVERGENCE TOLERANCE.
C     LOGICAL APRXDV
C        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
C        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
C        (FALSE).
C     INTEGER CNVCOD
C        A VALUE USED TO CONTROL THE PRINTING OF ITERATION REPORTS.
C     INTEGER COVPRT
C        THE LOCATION IN IWORK OF THE VARIABLE USED TO INDICATE WHETHER
C        THE COVARIANCE MATRIX IS TO BE PRINTED BY THE NL2 CODE, WHERE
C        IWORK(COVPRT) = 0 INDICATES IT IS NOT.
C     INTEGER COVREQ
C        THE LOCATION IN IWORK OF THE VARIABLE USED TO INDICATE HOW
C        THE COVARIANCE MATRIX IS TO BE COMPUTED BY THE NL2 CODE, WHERE
C        IWORK(COVREQ) = 3 INDICATES THE COVARIANCE MATRIX IS TO BE COMP
C        AS THE RESIDUAL VARIANCE TIMES THE INVERSE OF THE JACOBIAN MATR
C        TRANSPOSED TIMES THE JACOBIAN MATRIX .
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     INTEGER DINIT
C        THE LOCATION IN IWORK OF THE VALUE USED TO INDICATE
C        WHETHER OR NOT USER SUPPLIED SCALE VALUES ARE TO BE
C        USED, WHERE THE (NL2) DEFAULT VALUE OF RWORK(DINIT) = 0.0D0
C        INIDCATES NO, AND THE VALUE RWORK(DINIT) = -1.0D0 INDICATES
C        YES.
C     INTEGER DTYPE
C        THE LOCATION IN IWORK OF THE VALUE INDICATING WHETHER THE
C        SCALE VALUES HAVE BEEN SUPPLIED BY THE USER (IWORK(DTYPE) .LE.
C        OR THE DEFAULT VALUES ARE TO BE USED (IWORK(DTYPE) .GT. 0).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IIWORK
C        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
C     INTEGER IRWORK
C        THE DIMENSION OF THE DOUBLE PRECISION WORK VECTOR RWORK.
C     INTEGER ISCL
C        THE LOCATION IN IWORK INDICATING THE STARTING LOCATION IN
C         RWORK OF THE SCALE VECTOR.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCVPT
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
C        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
C        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(HESSIAN)
C        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                       *INVERSE(HESSIAN)
C     INTEGER IWORK(IIWORK)
C        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
C     INTEGER J
C        THE INDEX OF THE PARAMETER BEING EXAMINED.
C     INTEGER LMAX0
C        THE LOCATION IN RWORK OF THE VALUE INDICATING THE
C        MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     INTEGER MXFCAL
C        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
C        MAXIMUM NUMBER OF FUNCTION CALLS ALLOWED, EXCLUDING
C        CALLS NECESSARY TO COMPUTE THE DERIVATIVES AND VARIANCE
C        COVARIANCE MATRIX.
C     INTEGER MXITER
C        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
C        MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NITER
C        THE LOCATION IN IWORK OF THE NUMBER OF THE CURRENT ITERATION.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF UNKNOWN PARAMETERS TO BE OPTIMIZED.
C     INTEGER OUTLEV
C        THE LOCATION IN IWORK OF THE PARAMETER USED TO CONTROL THE
C        PRINTING OF THE ITERATION REPORTS BY NL2.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION PARE(NPAR)
C        THE CURRENT ESTIMATES OF THE UNKNOWN PARAMETERS, BUT ONLY
C        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
C     INTEGER PRUNIT
C        THE LOCATION IN IWORK OF THE PARAMETER USED TO CONTROL
C        THE PRINT UNIT USED BY NL2.  IWORK(PRUNIT) = 0 MEANS
C        DONT PRINT ANYTHING.
C     INTEGER RFCTOL
C        THE LOCATION IN RWORK OF THE RELATIVE FUNCTION CONVERGENCE
C        TOLERANCE.
C     DOUBLE PRECISION RWORK(IRWORK)
C        THE DOUBLE PRECISION WORK VECTOR USED BY THE NL2 SUBROUTINES.
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
C     INTEGER SCL
C        THE INDEX IN RWORK OF THE 1ST VALUE OF THE USER SUPPLIED SCALE
C        VALUE.
C     INTEGER SCLJ
C        THE INDEX IN RWORK OF THE JTH VALUE OF THE USER SUPPLIED SCALE
C        VALUE.
C     INTEGER SOLPRT
C        THE LOCATION IN IWORK OF THE PARAMETER USED TO CONTROL PRINTING
C        BY NL2 OF THE FINAL SOLUTION.
C     INTEGER STATPR
C        THE LOCATION IN IWORK OF THE PARAMETER USED TO CONTROL PRINTING
C        BY NL2 OF SUMMARY STATISTICS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     INTEGER XCTOL
C        THE LOCATION IN RSTAK/DSTAK OF THE P CONVERGENCE TOLERANCE.
C     INTEGER X0PRT
C         THE LOCATION IN IWORK OF THE PARAMETER USED TO CONTROL PRINTIN
C        BY NL2 OF THE INITIAL PARAMETER AND SCALE VALUES.
C
C     IWORK SUBSCRIPT VALUES
C
      DATA CNVCOD /34/, COVPRT /14/, COVREQ /15/, DINIT /38/, DTYPE
     +   /16/, ISCL /27/, MXFCAL /17/, MXITER /18/,
     +   NITER /31/, OUTLEV /19/, PRUNIT /21/, SOLPRT /22/, STATPR
     +   /23/, X0PRT /24/
C
C     RWORK SUBSCRIPT VALUES
C
      DATA AFCTOL /31/, LMAX0 /35/, RFCTOL /32/, XCTOL /33/
C
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C
C     PACK PARAMETERS INTO PARE
C
      CALL NLSPK(PAR, IFIXD, NPAR, PARE, NPAR)
C
C     SET NL2SOL DEFAULT VALUES
C
      CALL DFAULT(IWORK, RWORK)
C
C     SET NON NL2 DEFAULT VALUES
C
      IWORK(MXITER) = MIT
      IF (MIT.LE.0) IWORK(MXITER) = 21
C
      IWORK(MXFCAL) = 2*IWORK(MXITER)
C
C     SET STOPPING CRITERION
C
      RWORK(AFCTOL) = RMDCON(1)
      IF ((STOPSS.GE.RMDCON(3)) .AND. (STOPSS.LE.0.1)) RWORK(RFCTOL) =
     +   STOPSS
C
      IF ((STOPP.GE.0.0D0) .AND. (STOPP.LE.1.0D0))
     +   RWORK(XCTOL) = STOPP
C
C     SET SCALE VALUES
C
      SCL = 94 + 2*N + NPARE*(3*NPARE+31)/2
      IWORK(ISCL) = SCL
      IF (SCALE(1).GT.0.0D0) GO TO 40
C
      IWORK(DTYPE) = 1
C
C     INITIALIZE SCALE VALUES FOR FIRST ITERATION
C
      SCLJ = SCL - 1
      DO 30 J=1,NPAR
         IF (IFIXD(J).NE.0) GO TO 30
         SCLJ = SCLJ + 1
         IF (PAR(J).EQ.0.0D0) RWORK(SCLJ) = 1.0D0
         IF (PAR(J).NE.0.0D0) RWORK(SCLJ) = 1.0D0/ABS(PAR(J))
   30 CONTINUE
C
      GO TO 60
C
   40 IWORK(DTYPE) = 0
      RWORK(DINIT) = -1.0D0
      SCLJ = SCL - 1
      DO 50 J=1,NPAR
         IF (IFIXD(J).NE.0) GO TO 50
         SCLJ = SCLJ + 1
         RWORK(SCLJ) = 1.0D0/MAX(ABS(SCALE(J)),ABS(PAR(J)))
   50 CONTINUE
C
   60 IF (DELTA.LE.0.0D0) RWORK(LMAX0) = 100.0D0
      IF (DELTA.GT.0.0D0) RWORK(LMAX0) = DELTA
C
C     SET NL2 COVARIANCE COMPUTATION CONTROL PARAMETER
C
      IF ((IVAPRX.LE.1) .OR. (IVAPRX.EQ.4) .OR. (IVAPRX.GE.7))
     +   IWORK(COVREQ) = 3
      IF ((IVAPRX.EQ.2) .OR. (IVAPRX.EQ.5)) IWORK(COVREQ) = 2
      IF ((IVAPRX.EQ.3) .OR. (IVAPRX.EQ.6)) IWORK(COVREQ) = 1
      IF ((IVAPRX.GE.4) .AND. (IVAPRX.LE.6))
     +   IWORK(COVREQ) = -IWORK(COVREQ)
      IF (APRXDV) IWORK(COVREQ) = -IABS(IWORK(COVREQ))
      IF ((IVAPRX.LE.1) .OR. (IVAPRX.EQ.4) .OR. (IVAPRX.GE.7))
     +   IVCVPT = 1
      IF ((IVAPRX.EQ.2) .OR. (IVAPRX.EQ.5)) IVCVPT = 2
      IF ((IVAPRX.EQ.3) .OR. (IVAPRX.EQ.6)) IVCVPT = 3
C
C     INITIALIZE THE ITERATION COUNTER
C
      IWORK(NITER) = 0
C
C     SET NL2 PRINT CONTROL PARAMETERS
C
      IWORK(CNVCOD) = 0
      IWORK(COVPRT) = 0
      IWORK(OUTLEV) = 0
      IWORK(PRUNIT) = 0
      IWORK(SOLPRT) = 0
      IWORK(STATPR) = 0
      IWORK(X0PRT) = 0
C
      RETURN
C
      END
*NLISM
      SUBROUTINE NLISM (NLHDR, PAGE, WIDE, HLFRPT, NPAR, M, N, NNZW,
     +   WEIGHT, IFIXD, PAR, SCALE, IWORK, IIWORK, RWORK, IRWORK, RES,
     +   APRXDV, STP, LSTP, NPARE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS AN INITIAL SUMMARY OF THE STARTING
C     ESTIMATES AND THE CONTROL PARAMETERS FOR THE NONLINEAR
C     LEAST SQUARES SUBROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IIWORK,IRWORK,LSTP,M,N,NNZW,NPAR,NPARE
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,WEIGHT,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),RES(N),RWORK(IRWORK),SCALE(NPAR),STP(LSTP)
      INTEGER
     +   IFIXD(NPAR),IWORK(IIWORK)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL NLHDR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD,RSS
      INTEGER
     +   I,IPRT,ISUBHD,LMAX0,MXFCAL,MXITER,RFCTOL,XCTOL
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   DNRM2
      EXTERNAL DNRM2
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC DBLE,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL APRXDV
C        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
C        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HLFRPT
C        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
C        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
C        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IIWORK
C        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IRWORK
C        THE DIMENSION OF THE DOUBLE PRECISION WORK VECTOR RWORK.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     INTEGER IWORK(IIWORK)
C        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
C     INTEGER LMAX0
C        THE LOCATION IN RWORK OF THE VALUE INDICATING THE
C        MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     INTEGER LSTP
C        THE ACTUAL LENGTH OF THE VECTOR STP.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MXFCAL
C        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
C        MAXIMUM NUMBER OF FUNCTION CALLS ALLOWED, EXCLUDING
C        CALLS NECESSARY TO COMPUTE THE DERIVATIVES AND COVARIANCE
C        MATRIX.
C     INTEGER MXITER
C        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
C        MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     EXTERNAL NLHDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        NUMBER OF PARAMETERS ESTIMATED BY ROUTINE.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     INTEGER RFCTOL
C        THE LOCATION IN RWORK OF THE RELATIVE FUNCTION CONVERGENCE
C        TOLERANCE.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION AT THE INITIAL PARAMETER VALUES
C     DOUBLE PRECISION RSS
C        THE RESIDUAL SUM OF SQUARES AT THE INITIAL PARAMETER VALUES
C     DOUBLE PRECISION RWORK(IRWORK)
C        THE DOUBLE PRECISION WORK VECTOR USED BY THE NL2 SUBROUTINES.
C     DOUBLE PRECISION SCALE(NPAR)
C        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
C     DOUBLE PRECISION STP(LSTP)
C        THE SELECTED RELATIVE STEP SIZES.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C       THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        FULL WIDTH (TRUE) OR NOT (FALSE).
C     INTEGER XCTOL
C        THE LOCATION IN RSTAK/DSTAK OF THE P CONVERGENCE TOLERANCE.
C
C     IWORK SUBSCRIPT VALUES
C
      DATA MXFCAL/17/, MXITER/18/
C
C     RWORK SUBSCRIPT VALUES
C
      DATA LMAX0/35/, RFCTOL/32/, XCTOL/33/
C
      CALL IPRINT(IPRT)
C
      IF (.NOT.HLFRPT) THEN
C
         ISUBHD = 1
         CALL NLHDR(PAGE, WIDE, ISUBHD)
C
         IF (APRXDV) THEN
            WRITE (IPRT, 1260)
         ELSE
            WRITE (IPRT, 1270)
         END IF
C
         DO 40 I = 1, NPAR
            IF (IFIXD(I).EQ.0) THEN
               IF (SCALE(1).GT.0.0D0) THEN
                  IF (APRXDV) THEN
                     WRITE (IPRT, 1410) I, PAR(I), SCALE(I), STP(I)
                  ELSE
                     WRITE (IPRT, 1410) I, PAR(I), SCALE(I)
                  END IF
               ELSE
                  IF (APRXDV) THEN
                     WRITE (IPRT, 1310) I, PAR(I), STP(I)
                  ELSE
                     WRITE (IPRT, 1310) I, PAR(I)
                  END IF
               END IF
            ELSE
               IF (APRXDV) THEN
                  WRITE (IPRT, 1510) I, PAR(I)
               ELSE
                  WRITE (IPRT, 1610) I, PAR(I)
               END IF
            END IF
   40    CONTINUE
C
         WRITE (IPRT, 1160) N
C
      END IF
C
      IF (WEIGHT) WRITE (IPRT, 1170) NNZW
      WRITE (IPRT, 1180) M
      WRITE(IPRT, 1070) IWORK(MXITER)
      WRITE(IPRT, 1090) IWORK(MXFCAL)
      WRITE(IPRT, 1080)
      WRITE(IPRT, 1100) RWORK(RFCTOL)
      WRITE(IPRT, 1110) RWORK(XCTOL)
      WRITE(IPRT, 1120) RWORK(LMAX0)
C
      RSD = DNRM2(N, RES, 1)
      RSS = RSD * RSD
      IF (NNZW-NPARE.GE.1) RSD = RSD /SQRT(DBLE(NNZW-NPARE))
      WRITE (IPRT, 1200) RSS
      WRITE (IPRT, 1210) RSD
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1070 FORMAT (/37H MAXIMUM NUMBER OF ITERATIONS ALLOWED, 32X, 5H(MIT),
     +   1X, I5)
 1080 FORMAT(/44H CONVERGENCE CRITERION FOR TEST BASED ON THE/)
 1090 FORMAT(/41H MAXIMUM NUMBER OF MODEL SUBROUTINE CALLS,
     +   8H ALLOWED, 26X, I5)
 1100 FORMAT (5X, 39H FORECASTED RELATIVE CHANGE IN RESIDUAL,
     +   15H SUM OF SQUARES, 7X, 8H(STOPSS), 1X, G11.4)
 1110 FORMAT(5X, 49H MAXIMUM SCALED RELATIVE CHANGE IN THE PARAMETERS,
     +   13X, 7H(STOPP), 1X, G11.4)
 1120 FORMAT(//41H MAXIMUM CHANGE ALLOWED IN THE PARAMETERS,
     +   23H AT THE FIRST ITERATION, 3X, 7H(DELTA), 1X, G11.4)
 1160 FORMAT (/23H NUMBER OF OBSERVATIONS, 48X, 3H(N), 1X, I5)
 1170 FORMAT (/41H NUMBER OF NON ZERO WEIGHTED OBSERVATIONS, 27X,
     +   6H(NNZW), 1X, I5)
 1180 FORMAT (/32H NUMBER OF INDEPENDENT VARIABLES, 39X, 3H(M), 1X, I5)
 1200 FORMAT (/44H RESIDUAL SUM OF SQUARES FOR INPUT PARAMETER,
     +   7H VALUES, 24X, G11.4)
 1210 FORMAT (/48H RESIDUAL STANDARD DEVIATION FOR INPUT PARAMETER,
     +   7H VALUES, 14X, 5H(RSD), 1X, G11.4)
 1260 FORMAT (//50X, 13HSTEP SIZE FOR/
     +   50X, 13HAPPROXIMATING/
     +   7X, 24HPARAMETER STARTING VALUE, 6X, 5HSCALE, 10X,
     +   10HDERIVATIVE/
     +   1X, 5HINDEX, 2X, 5HFIXED, 6X, 5H(PAR), 12X, 7H(SCALE), 11X,
     +   5H(STP)/)
 1270 FORMAT (//6X, 25HPARAMETER STARTING VALUES, 5X, 5HSCALE/
     +   1X, 5HINDEX, 2X, 5HFIXED, 6X, 5H(PAR), 11X, 7H(SCALE)/)
 1310 FORMAT (1X, I3, 5X, ' NO', G17.8, 7X, 7HDEFAULT, 3X, G17.8)
 1410 FORMAT (1X, I3, 5X, ' NO', 3G17.8)
 1510 FORMAT (1X, I3, 5X, 'YES', G17.8, 9X, '---', 14X, '---')
 1610 FORMAT (1X, I3, 5X, 'YES', G17.8, 9X, '---')
      END
*NLITRP
      SUBROUTINE NLITRP(NLHDR, HEAD, PAGE, WIDE, IPTOUT, NPAR, NNZW,
     +   IWORK, IIWORK, RWORK, IRWORK, IFIXD, PARE, NPARE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS THE ITERATION REPORTS FOR THE
C     NONLINEAR LEAST SQUARES REGRESSION SUBROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IIWORK,IPTOUT,IRWORK,NNZW,NPAR,NPARE
      LOGICAL
     +   HEAD,PAGE,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PARE(NPAR),RWORK(IRWORK)
      INTEGER
     +   IFIXD(NPAR),IWORK(IIWORK)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL NLHDR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD,RSS,RSSC,RSSPC
      INTEGER
     +   DST0,F,F0,FDIF,ICASE,IPRT,ISUBHD,MXITER,NFCALL,NITER,
     +   NREDUC,PREDUC,RELDX,STPPAR
      CHARACTER
     +   LETTRN*1,LETTRY*1
C
C  LOCAL ARRAYS
      CHARACTER
     +   ISCHKD(2)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LSTVCF
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MOD,DBLE,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER DST0
C        THE LOCATION IN RWORK OF THE VALUE OF THE 2 NORM OF D TIMES
C        THE  NEWTON STEP.
C     INTEGER F
C        THE LOCATION IN RWORK OF THE VALUE OF HALF THE RESIDUAL
C        SUM OF SQUARES AT THE CURRENT PARAMETER VALUES.
C     INTEGER FDIF
C        THE LOCATION IN RWORK OF THE DIFFERENCE BETWEEN THE
C        RESIDUAL SUM OF SQUARES AT THE BEGINNING AND END OF THE
C        CURRENT ITERATION.
C     INTEGER F0
C        THE LOCATION IN RWORK OF THE VALUE OF HALF THE RESIDUAL
C        VARIANCE AT THE BEGINNING OF THE CURRENT ITERATION.
C     LOGICAL HEAD
C        THE VARIABLE USED TO INDICATE WHETHER A HEADING IS TO BE
C        PRINTED DURING A GIVEN CALL TO THE ITERATION REPORT (TRUE)
C        OR NOT (FALSE).
C     INTEGER ICASE
C        AN INDICATER VARIABLE USED TO DESIGNATE THE MESSAGE TO BE
C        PRINTED.
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IIWORK
C        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IRWORK
C        THE DIMENSION OF THE DOUBLE PRECISION WORK VECTOR RWORK.
C     CHARACTER*1 ISCHKD(2)
C        THE INDICATOR USED TO DESIGNATE WHETHER THE
C        TEST VALUE WAS CHECKED FOR CONVERGENCE (Y) OR NOT (N).
C     INTEGER ISUBHD
C        AN INTEGER VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     INTEGER IWORK(IIWORK)
C        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
C     CHARACTER*1 LETTRN, LETTRY
C        THE LETTERS N AND Y, RESPECTIVELY.
C     INTEGER MXITER
C        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
C        MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     INTEGER NFCALL
C        THE LOCATION IN IWORK OF THE NUMBER OF FUNCTION EVALUATIONS.
C     INTEGER NITER
C        THE LOCATION IN IWORK OF THE NUMBER OF THE CURRENT ITERATION.
C     EXTERNAL NLHDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF UNKNOWN PARAMETERS TO BE OPTIMIZED.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NREDUC
C        THE LOCATION IN RWORK OF THE VALUE USED TO CHECK IF THE
C        HESSIAN APPROXIMATION IS POSITIVE DEFINITE.  IF
C        IF RWORK(NREDUC) .EQ. 0, THE HESSIAN IS SINGULAR, OTHERWISE
C        IT IS NOT.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PARE(NPAR)
C        THE CURRENT ESTIMATES OF THE UNKNOWN PARAMETERS, BUT ONLY
C        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
C     INTEGER PREDUC
C        THE LOCATION IN RWORK OF THE PREDICTED FUNCTION REDUCTION
C        FOR THE CURRENT STEP.
C     INTEGER RELDX
C        THE LOCATION IN RWORK OF THE SCALED RELATIVE CHANGE IN
C        THE PARAMETER VALUES CAUSED BY THE CURRENT ITERATION.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     DOUBLE PRECISION RSS
C        THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION RSSC
C        THE CHANGE IN THE RESIDUAL SUM OF SQUARES CAUSED BY THIS
C        ITERATION.
C     DOUBLE PRECISION RSSPC
C        THE PREDICTED CHANGE IN THE RESIDUAL SUM OF SQUARES AT THIS
C        ITERATION.
C     DOUBLE PRECISION RWORK(IRWORK)
C        THE DOUBLE PRECISION WORK VECTOR USED BY THE NL2 SUBROUTINES.
C     INTEGER STPPAR
C        THE LOCATION IN RWORK OF THE MARQUARDT LAMBDA PARAMETER.
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C
C
      DATA LETTRN /'N'/, LETTRY /'Y'/
C
C     IWORK SUBSCRIPT VALUES
C
      DATA MXITER /18/, NFCALL /6/, NITER /31/
C
C     RWORK SUBSCRIPT VALUES
C
      DATA DST0 /3/, F /10/, FDIF /11/, F0 /13/, NREDUC /6/, PREDUC
     +   /7/, RELDX /17/, STPPAR /5/
C
      CALL IPRINT(IPRT)
C
      IF (IWORK(1).EQ.10) GO TO 90
      IF ((IPTOUT.EQ.1) .AND. (IWORK(NITER).NE.1) .AND.
     +   (IWORK(NITER).NE.IWORK(MXITER)) .AND. (IWORK(1).LE.2)) RETURN
C
      ISUBHD = 0
      IF (HEAD) CALL NLHDR(PAGE, WIDE, ISUBHD)
      HEAD = .FALSE.
      IF (MOD(IWORK(NITER),4).EQ.0) HEAD = .TRUE.
C
      WRITE (IPRT,1000) IWORK(NITER)
C
C     COMPUTE STATISTICS TO BE PRINTED
C
      RSS = 2.0D0*RWORK(F)
      RSD = SQRT(RSS)
      IF (NNZW-NPARE.GE.1) RSD = RSD/SQRT(DBLE(NNZW-NPARE))
C
      RSSC = 0.0D0
      IF (RWORK(F0).GT.0.0D0) RSSC = RWORK(FDIF)/RWORK(F0)
C
      RSSPC = 0.0D0
      IF (RWORK(F0).GT.0.0D0) RSSPC = RWORK(NREDUC)/RWORK(F0)
C
C     REFERENCE NL2 SUBROUTINE ASSESS, STATEMENT LABEL 300 TO 320
C
      ISCHKD(1) = LETTRN
      ISCHKD(2) = LETTRN
      IF (RWORK(FDIF).GT.2.0D0*RWORK(PREDUC)) GO TO 10
      IF (RWORK(DST0).LT.0.0D0) GO TO 10
      IF (RWORK(NREDUC).GE.0.0D0) ISCHKD(1) = LETTRY
      IF (RWORK(STPPAR).EQ.0.0D0) ISCHKD(2) = LETTRY
   10 CONTINUE
C
      WRITE (IPRT,1010) IWORK(NFCALL), RSD, RSS, RSSC, RSSPC,
     +   ISCHKD(1), RWORK(RELDX), ISCHKD(2)
      IF (NPARE.LT.NPAR) WRITE (IPRT,1020)
      IF (NPARE.GE.NPAR) WRITE (IPRT,1150)
      CALL LSTVCF(NPARE, PARE, NPAR, IFIXD)
C
      IF (IWORK(1).LE.2) RETURN
C
C     PRINT FINAL ITERATION MESSAGE
C
      ICASE = IWORK(1) - 2
      GO TO (20, 30, 40, 50, 60, 70, 80, 90, 100, 140, 110, 120, 130),
     +   ICASE
C
C     ***** PARAMETER CONVERGENCE *****
C
   20 WRITE (IPRT,1030)
      RETURN
C
C     ***** RESIDUAL SUM OF SQUARES CONVERGENCE *****
C
   30 WRITE (IPRT,1040)
      RETURN
C
C     ***** PARAMETER AND RESIDUAL SUM OF SQUARES CONVERGENCE ****
C
   40 WRITE (IPRT,1050)
      RETURN
C
C     ***** RESIDUAL SUM OF SQUARES IS EXACTLY ZERO *****
C
   50 WRITE (IPRT,1060)
      RETURN
C
C     ***** SINGULAR CONVERGENCE *****
C
   60 WRITE (IPRT,1070)
      RETURN
C
C     ***** FALSE CONVERGENCE *****
C
   70 WRITE (IPRT,1080)
      RETURN
C
C     ***** LIMIT ON NUM. OF CALLS TO THE MODEL SUBROUTINE REACHED *****
C
   80 WRITE (IPRT,1090)
      RETURN
C
C     ***** ITERATION LIMIT REACHED *****
C
   90 WRITE (IPRT,1100)
      RETURN
C
C     ***** STOPX *****
C
  100 WRITE (IPRT,1110)
      RETURN
C
C     ***** INITIAL RESIDUAL SUM OF SQUARES OVERFLOWS *****
C
  110 WRITE (IPRT,1120)
      RETURN
C
C     ***** BAD PARAMETERS TO ASSESS *****
C
  120 WRITE (IPRT,1130)
      RETURN
C
C     ***** J COULD NOT BE COMPUTED *****
C
  130 WRITE (IPRT,1140)
      RETURN
C
  140 RETURN
C
C      FORMAT STATEMENTS
C
 1000 FORMAT (//17H ITERATION NUMBER, I5/1X, 22('-'))
 1010 FORMAT (5X, 5HMODEL, 53X, 10HFORECASTED/5X, 5HCALLS, 9X, 3HRSD,
     +   13X, 3HRSS, 8X, 12HREL CHNG RSS, 4X, 12HREL CHNG RSS, 4X,
     +   12HREL CHNG PAR/62X, 5HVALUE, 3X, 4HCHKD, 4X, 5HVALUE, 3X,
     +   4HCHKD/3X, I7, 3(2X, G14.4), 2(G12.4, 3X, A1))
 1020 FORMAT (/5X, 25H CURRENT PARAMETER VALUES, 19H (ONLY UNFIXED PARA,
     +   18HMETERS ARE LISTED))
 1030 FORMAT (/34H ***** PARAMETER CONVERGENCE *****)
 1040 FORMAT (/48H ***** RESIDUAL SUM OF SQUARES CONVERGENCE *****)
 1050 FORMAT (/44H ***** PARAMETER AND RESIDUAL SUM OF SQUARES,
     +   18H CONVERGENCE *****)
 1060 FORMAT (/50H ***** THE RESIDUAL SUM OF SQUARES IS EXACTLY ZERO,
     +   6H *****)
 1070 FORMAT (/33H ***** SINGULAR CONVERGENCE *****)
 1080 FORMAT (/30H ***** FALSE CONVERGENCE *****)
 1090 FORMAT (/44H ***** LIMIT ON NUMBER OF CALLS TO THE MODEL,
     +   25H SUBROUTINE REACHED *****)
 1100 FORMAT (/36H ***** ITERATION LIMIT REACHED *****)
 1110 FORMAT (/18H ***** STOPX *****)
 1120 FORMAT (/53H ***** INITIAL RESIDUAL SUM OF SQUARES OVERFLOWS ****,
     +   1H*)
 1130 FORMAT (/37H ***** BAD PARAMETERS TO ASSESS *****)
 1140 FORMAT (/52H ***** DERIVATIVE MATRIX COULD NOT BE COMPUTED *****)
 1150 FORMAT (/5X, 25H CURRENT PARAMETER VALUES)
      END
*NLMN
      SUBROUTINE NLMN(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, MDL,
     +   NLDRV, APRXDV, DRV, IFIXD, PAR, PARE, NPAR, RES, PAGE, WIDE,
     +   HLFRPT, STP, LSTP, MIT, STOPSS, STOPP, SCALE, LSCALE, DELTA,
     +   IVAPRX, IPTOUT, NDIGIT, RSD, PV, SDPVI, SDRESI, VCVL, LVCVL, D,
     +   IWORK, IIWORK, RWORK, IRWORK, NLHDR, NPARE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE CONTROLING SUBROUTINE FOR PERFORMING NONLINEAR
C     LEAST SQUARES REGRESSION USING THE NL2 SOFTWARE PACKAGE
C     (IMPLEMENTING THE METHOD OF DENNIS, GAY AND WELSCH).
C     THIS SUBROUTINE WAS ADAPTED FROM SUBROUTINE NL2SOL.
C
C     REFERENCES
C
C     DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1979), AN ADAPTIVE
C             NONLINEAR LEAST-SQUARES ALGORITHM, (BEING REVISED).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IIWORK,IRWORK,IVAPRX,IXM,LSCALE,LSTP,LVCVL,LWT,M,MIT,N,
     +   NDIGIT,NNZW,NPAR,NPARE,SDPVI,SDRESI,VCVL
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,WEIGHT,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PAR(NPAR),PARE(NPAR),PV(N),RES(N),RWORK(IRWORK),
     +   SCALE(LSCALE),STP(LSTP),WT(LWT),XM(IXM,M),Y(N)
      INTEGER
     +   IFIXD(NPAR),IPTOUT(NDIGIT),IWORK(IIWORK)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL,NLDRV,NLHDR
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   WTSQRT
      INTEGER
     +   CNVCOD,COVMAT,I,ICNVCD,IVCVPT,QTR,RD,RDI,RSAVE,RSSHLF,S,
     +   SCL
      LOGICAL
     +   CMPDRV,DONE,HEAD,NEWITR,PRTSMY
C
C  LOCAL ARRAYS
      INTEGER
     +   ISKULL(10)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL NL2ITR,NLERR,NLFIN,NLINIT,NLISM,NLITRP,NLSUPK
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL APRXDV
C        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
C        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL CMPDRV
C        THE VARIABLE USED TO INDICATE WHETHER DERIVATIVES MUST BE
C        COMPUTED (TRUE) OR NOT (FALSE).
C     INTEGER CNVCOD
C        A VALUE USED TO CONTROL THE PRINTING OF ITERATION REPORTS.
C     INTEGER COVMAT
C        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
C        OF THE BEGINNING OF THE VCV MATRIX.
C     DOUBLE PRECISION D(N,NPAR)
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     LOGICAL DONE
C        THE VARIABLE USED TO INDICATE WHETHER THIS IS THE FINAL
C        COMPUTATION OF THE JACOBIAN OR NOT.
C     LOGICAL HEAD
C        THE VARIABLE USED TO INDICATE WHETHER A HEADING IS TO BE
C        PRINTED DURING A GIVEN CALL TO THE ITERATION REPORT (TRUE)
C        OR NOT (FALSE).
C     LOGICAL HLFRPT
C        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
C        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
C        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER ICNVCD
C        THE LOCATION IN IWORK OF
C        THE CONVERGENCE CONDITION.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IIWORK
C        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
C     INTEGER IPTOUT(NDIGIT)
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
C     INTEGER IRWORK
C        THE DIMENSION OF THE DOUBLE PRECISION WORK VECTOR RWORK.
C     INTEGER ISKULL(10)
C        AN ERROR MESSAGE INDICATOR VARIABLE.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCVPT
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
C        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
C        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(HESSIAN)
C        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                       *INVERSE(HESSIAN)
C     INTEGER IWORK(IIWORK)
C        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSTP
C        THE ACTUAL LENGTH OF THE VECTOR STP.
C     INTEGER LVCVL
C        THE LENGTH OF THE VECTOR CONTAINING
C        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NDIGIT
C        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
C     LOGICAL NEWITR
C        A FLAG USED TO INDICATE WHETHER A NEW ITERATION HAS BEEN
C        COMPLETED (TRUE) OR NOT (FALSE).
C     EXTERNAL NLDRV
C        THE NAME OF THE ROUTINE WHICH CALCULATED THE DERIVATIVES
C     EXTERNAL NLHDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PARE(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS, BUT ONLY
C        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
C     LOGICAL PRTSMY
C        THE VARIABLE USED TO INDICATE WHETHER THE SUMMARY
C        INFORMATION IS TO BE PRINTED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUES.
C     INTEGER QTR
C        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
C        THE ARRAY Q TRANSPOSE R.
C     INTEGER RD
C        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK OF
C        THE DIAGONAL ELEMENTS OF THE R MATRIX OF THE Q - R
C        FACTORIZATION OF D.
C     INTEGER RDI
C        THE LOCATION IN RWORK OF THE DIAGONAL ELEMENTS OF THE R
C        MATRIX OF THE Q - R FACTORIZATION OF D.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     INTEGER RSAVE
C        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
C        THE ARRAY RSAVE.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     INTEGER RSSHLF
C        THE LOCATION IN RWORK OF
C        HALF THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION RWORK(IRWORK)
C        THE DOUBLE PRECISION WORK VECTOR USED BY THE NL2 SUBROUTINES.
C     INTEGER S
C        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
C        THE ARRAY OF SECOND ORDER TERMS OF THE HESSIAN.
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     INTEGER SCL
C        THE INDEX IN RWORK OF THE 1ST VALUE OF THE USER SUPPLIED SCALE
C        VALUE.
C     INTEGER SDPVI
C        THE STARTING LOCATION IN RWORK OF
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     INTEGER SDRESI
C        THE STARTING LOCATION IN RWORK OF THE
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C        PREDICTED DECREASE IN THE RESIDUAL STANDARD DEVIATION (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FORTHE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(LSTP)
C        THE DUMMY STEP SIZE ARRAY.
C     INTEGER VCVL
C        THE STARTING LOCATION IN RWORK OF THE LOWER HALF OF THE
C        VCV MATRIX, STORED ROW WISE.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION WTSQRT
C        THE SQUARE ROOT OF THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     IWORK SUBSCRIPT VALUES
C
      DATA CNVCOD /34/, ICNVCD /1/, COVMAT /26/, QTR /49/, RD /51/,
     +   RSAVE /52/, S/53/
      DATA RSSHLF /10/
C
C+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
C
C     INITIALIZE CONTROL PARAMETERS
C
      CALL NLINIT (N, IFIXD, PAR, NPAR, PARE, NPARE, MIT, STOPSS,
     +   STOPP, SCALE, LSCALE, DELTA, IVAPRX, APRXDV, IVCVPT, IWORK,
     +   IIWORK, RWORK, IRWORK, SCL)
C
      CMPDRV = .TRUE.
      DONE = .FALSE.
      HEAD = .TRUE.
      NEWITR = .FALSE.
      PRTSMY = (IPTOUT(1).NE.0)
C
C
C     COMPUTE RESIDUALS
C
   10 CALL MDL(PAR, NPAR, XM, N, M, IXM, PV)
C
      DO 20 I=1,N
         WTSQRT = 1.0D0
         IF (WEIGHT) WTSQRT = SQRT(WT(I))
         RES(I) = WTSQRT*(Y(I)-PV(I))
   20 CONTINUE
C
C     PRINT INITIAL SUMMARY
C
      IF (.NOT.PRTSMY) GO TO 30
      CALL NLISM(NLHDR, PAGE, WIDE, HLFRPT, NPAR, M, N, NNZW, WEIGHT,
     +   IFIXD, PAR, SCALE, IWORK, IIWORK, RWORK, IRWORK, RES, APRXDV,
     +   STP, LSTP, NPARE)
      PRTSMY = .FALSE.
C
   30 CONTINUE
C
      IF (.NOT.CMPDRV) GO TO 50
C
      CMPDRV = .FALSE.
C
   40 CONTINUE
C
C     PRINT ITERATION REPORT IF DESIRED
C
      IF ((IPTOUT(2).NE.0) .AND. NEWITR) CALL NLITRP(NLHDR, HEAD, PAGE,
     +   WIDE, IPTOUT(2), NPAR, NNZW, IWORK, IIWORK, RWORK, IRWORK,
     +   IFIXD, PARE, NPARE)
C
C  ***  COMPUTE JACOBIAN  ***
C
      IF (DONE) CALL MDL(PAR, NPAR, XM, N, M, IXM, PV)
C
      CALL NLDRV (MDL, DRV, DONE, IFIXD, PAR, NPAR, XM, N, M, IXM,
     +   PV, D, WEIGHT, WT, LWT, STP, LSTP, RWORK(SCL), NPARE)
C
      IF (DONE) GO TO 70
C
C     COMPUTE NEXT ITERATION
C
   50 CALL NL2ITR(RWORK(SCL), IWORK, D, N, N, NPARE, RES, RWORK, PARE)
C
C     UNPACK PARAMETERS
C
      CALL NLSUPK(PARE, NPARE, PAR, IFIXD, NPAR)
C
      NEWITR = (IWORK(CNVCOD).EQ.0)
      IF (IWORK(1)-2) 10, 40, 60
C
   60 DONE = .TRUE.
      GO TO 40
   70 CONTINUE
C
C     SET ERROR FLAGS, IF NECESSARY
C
      CALL NLERR(IWORK(ICNVCD), ISKULL)
C
C     FINISH COMPUTATIONS AND PRINT ANY DESIRED RESULTS
C
C     EQUIVALENCE LOCATIONS WITHIN RWORK.
C
      SDPVI = IWORK(RSAVE)
      SDRESI = IWORK(QTR)
      VCVL = IWORK(COVMAT)
      IF (VCVL.GE.1) GO TO 80
C
      VCVL = IWORK(S)
      IF (IERR.NE.0) GO TO 80
      ISKULL(1) = 1
      ISKULL(7) = 1
      IERR = 7
C
   80 CONTINUE
C
      LVCVL = NPARE*(NPARE+1)/2
C
      RDI = IWORK(RD)
C
      CALL NLFIN(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, IFIXD, PAR,
     +   NPAR, NPARE, RES, PAGE, WIDE, IPTOUT, NDIGIT, RWORK(RSSHLF),
     +   RSD, PV, RWORK(SDPVI), RWORK(SDRESI), RWORK(RDI), RWORK(VCVL),
     +   LVCVL, D, NLHDR, IVCVPT, ISKULL)
C
      RETURN
C
      END
*NLOUT
      SUBROUTINE NLOUT(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, IFIXD,
     +   PAR, NPAR, NPARE, RES, IPTOUT, NDIGIT, PAGE, IDF, COND, RSS,
     +   RSD, YSS, EXACT, PV, SDPV, SDRES, VCVL, LVCVL, IVCVPT, ISKULL,
     +   NLHDR, WIDE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS THE FINAL SUMMARY OUTPUT FROM THE
C     NONLINEAR LEAST SQUARES SUBOUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   COND,RSD,RSS,YSS
      INTEGER
     +   IDF,IVCVPT,IXM,LVCVL,LWT,M,N,NDIGIT,NNZW,NPAR,NPARE
      LOGICAL
     +   EXACT,PAGE,WEIGHT,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PV(N),RES(N),SDPV(N),SDRES(N),VCVL(LVCVL),WT(LWT),
     +   XM(IXM,M),Y(N)
      INTEGER
     +   IFIXD(NPAR),IPTOUT(NDIGIT),ISKULL(10)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL NLHDR
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM,PLL,PUL,RATIO,SDPAR,T
      INTEGER
     +   I,IPK,IPK2,IPRT,ISUBHD
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   PPFT,D1MACH
      EXTERNAL PPFT,D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL FITPT1,FITPT2,IPRINT,NLSKL,VCVOTF
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX,SQRT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION COND
C        THE CONDITION NUMBER OF D.
C     LOGICAL EXACT
C        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
C        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IDF
C        THE DEGREES OF FREEDOM IN THE FIT.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
C        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
C     INTEGER IPK
C        AN INDEX.
C     INTEGER IPK2
C        THE INDEX OF THE "DIAGONAL" ELEMENT OF THE VCV
C        MATRIX.
C     INTEGER IPRT
C        THE LOGICAL UNIT FOR PRINTED OUTPUT.
C     INTEGER IPTOUT(NDIGIT)
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
C     INTEGER ISKULL(10)
C        AN ERROR MESSAGE INDICATOR VARIABLE.
C     INTEGER ISUBHD
C        AN INTEGER VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     INTEGER IVCVPT
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
C        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
C        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(HESSIAN)
C        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                       *INVERSE(HESSIAN)
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LVCVL
C        THE LENGTH OF THE VECTOR CONTANING
C        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NDIGIT
C        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
C     EXTERNAL NLHDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE PARAMETER ESTIMATES.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE OUTPUT
C        IS TO BEGIN ON A NEW PAGE.
C     DOUBLE PRECISION PLL, PUL
C        THE LOWER AND UPPER CONFIDENCE LIMITS FOR A GIVEN PARAMETER.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RATIO
C        THE RATIO OF A GIVEN PARAMETER VALUE TO ITS STANDARD ERROR.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     DOUBLE PRECISION RSS
C        THE RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION SDPAR
C        THE STANDARD DEVIATION OF A GIVEN PARAMETER VALUE.
C     DOUBLE PRECISION SDPV(N)
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(N)
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION T
C        THE VALUE OF THE 97.5 PERCENT POINT FUNCTION FOR THE
C        T DISTRIBUTION.
C     DOUBLE PRECISION VCVL(LVCVL)
C        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(LWT)
C        THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C     DOUBLE PRECISION YSS
C        THE SUM OF SQUARES OF THE DEPENDENT VARIABLE Y.
C
C
      FPLM = D1MACH(2)
C
      CALL IPRINT(IPRT)
C
      IF ((IERR.GE.1) .AND. (IERR.NE.4)) GO TO 60
C
C     TEST FOR EXACT FIT
C
      IF ((IDF.LE.0) .OR. EXACT) GO TO 70
C
C     PRINT ERROR HEADING IF NECESSARY
C
      IF (IERR.EQ.4) CALL NLSKL(ISKULL, PAGE, WIDE, NLHDR)
C
C     PRINT PRIMARY REPORT
C
      IF ((IERR.EQ.0) .AND. (IPTOUT(3).EQ.0)) GO TO 10
      ISUBHD = 0
      CALL NLHDR(PAGE, WIDE, ISUBHD)
      CALL FITPT1(N, M, XM, Y, PV, SDPV, RES, SDRES, WT, IXM, NNZW,
     +   WEIGHT, MAX(1, IPTOUT(3)))
C
C     PRINT STANDARDIZED RESIDUAL PLOTS
C
   10 IF (IPTOUT(4).EQ.0) GO TO 20
      ISUBHD = 0
      CALL NLHDR(PAGE, WIDE, ISUBHD)
C
      CALL FITPT2 (SDRES, PV, WT, N, NNZW, WEIGHT, RES, RSS)
C
C     PRINT THE COVARIANCE AND CORRELATION MATRIX
C
   20 IF ((IERR.EQ.0) .AND. (IPTOUT(5).EQ.0)) RETURN
      ISUBHD = 0
      CALL NLHDR(PAGE, WIDE, ISUBHD)
C
      IF ((IERR.EQ.0) .AND. (IPTOUT(5).LE.1)) GO TO 30
C
      CALL VCVOTF(NPARE, VCVL, LVCVL, .TRUE., NPAR, IFIXD, IVCVPT)
C
C     PRINT ANALYSIS SUMMARY
C
   30 WRITE (IPRT,1000)
      WRITE (IPRT,1010)
C
      T = PPFT(0.975D0,IDF)
      IPK = 0
      DO 50 I=1,NPAR
C
         IF (IFIXD(I).EQ.0) GO TO 40
C
         WRITE (IPRT,1030) I, PAR(I)
         GO TO 50
C
   40    IPK = IPK + 1
         IPK2 = IPK*(IPK-1)/2 + IPK
         RATIO = FPLM
         SDPAR = SQRT(VCVL(IPK2))
         IF (SDPAR.GT.0.0D0) RATIO = PAR(I)/SDPAR
         PLL = PAR(I) - T*SDPAR
         PUL = PAR(I) + T*SDPAR
         WRITE (IPRT,1020) I, PAR(I), SDPAR, RATIO, PLL, PUL
   50 CONTINUE
      WRITE (IPRT,1040) RSS, RSD, NNZW, NPARE, IDF
      WRITE (IPRT,1050) COND
C
      IF (RSS.GT.YSS) WRITE (IPRT,1060)
C
      RETURN
C
C     PRINT OUT ERROR HEADING
C
   60 CALL NLSKL(ISKULL, PAGE, WIDE, NLHDR)
C
      IF (IERR.LE.2) RETURN
C
C     PRINT SECONDARY REPORT
C
   70 CONTINUE
      ISUBHD = 0
      CALL NLHDR(PAGE, WIDE, ISUBHD)
      IF (IERR.NE.0) WRITE (IPRT,1080)
      WRITE (IPRT,1000)
      WRITE (IPRT,1100)
      DO 80 I=1,NPAR
         IF (IFIXD(I).EQ.0) WRITE (IPRT,1110) I, PAR(I)
         IF (IFIXD(I).NE.0) WRITE (IPRT,1120) I, PAR(I)
   80 CONTINUE
      WRITE (IPRT,1040) RSS, RSD, NNZW, NPARE, IDF
      IF (IERR.NE.3) WRITE (IPRT,1050) COND
C
      IF ((IERR.EQ.0) .AND. (.NOT.EXACT) .AND. (IDF.LE.0)) WRITE
     +   (IPRT,1070)
      IF ((IERR.EQ.0) .AND. EXACT) WRITE (IPRT,1090)
C
      IF (IERR.NE.0) GO TO 100
C
      DO 90 I=1,N
         SDRES(I) = 0.0D0
         SDPV(I) = 0.0D0
   90 CONTINUE
C
      RETURN
C
  100 CONTINUE
C
      DO 110 I=1,N
         SDRES(I) = FPLM
         SDPV(I) = FPLM
  110 CONTINUE
C
C     PRINT OUT ERROR EXIT STATISTICS
C
      CALL FITPT1(N, M, XM, Y, PV, SDPV, RES, SDRES, WT, IXM, NNZW,
     +   WEIGHT, MAX(IPTOUT(3),1))
C
C
C     WIPE OUT SDRES VECTOR
C
      DO 120 I=1,N
         SDRES(I) = FPLM
  120 CONTINUE
C
C     WIPE OUT VCV MATRIX
C
      DO 140 I=1,LVCVL
         VCVL(I) = FPLM
  140 CONTINUE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (///33H ESTIMATES FROM LEAST SQUARES FIT/1X, 33('-'))
 1010 FORMAT (//69X, 11HAPPROXIMATE/61X, 28H95 PERCENT CONFIDENCE LIMITS
     +   /1X, 5HINDEX, 2X, 5HFIXED, 3X, 9HPARAMETER, 8X, 9HSD OF PAR,
     +   7X, 5HRATIO, 12X, 5HLOWER, 12X, 5HUPPER/)
 1020 FORMAT (1X, I3, 5X, 3H NO, 2G17.8, 2X, G10.4, 2G17.8)
 1030 FORMAT (1X, I3, 5X, 3HYES, G17.8, 10X, 3H---, 8X, 3H---, 15X,
     +   3H---, 14X, 3H---)
 1040 FORMAT (//31H RESIDUAL SUM OF SQUARES       , 8X, G15.7//6H RESID,
     +   25HUAL STANDARD DEVIATION   , 8X, G15.7/19H BASED ON DEGREES O,
     +   9HF FREEDOM, 5X, I4, 3H - , I3, 3H = , I4)
 1050 FORMAT (/29H APPROXIMATE CONDITION NUMBER, 10X, G15.7)
 1060 FORMAT (52H THE RESIDUAL SUM OF SQUARES AFTER THE LEAST SQUARES,
     +   20H FIT IS GREATER THAN/35H THE SUM OF SQUARES ABOUT THE MEAN ,
     +   19HY OBSERVATION.  THE, 14H MODEL IS LESS/17H REPRESENTATIVE O,
     +   39HF THE DATA THAN A SIMPLE AVERAGE.  DATA, 15H AND MODEL SHOU,
     +   2HLD/48H BE CHECKED TO BE SURE THAT THEY ARE COMPATABLE.)
 1070 FORMAT (/49H THE DEGREES OF FREEDOM FOR THIS PROBLEM IS ZERO.,
     +   54H  STATISTICAL ANALYSIS OF THE RESULTS IS NOT POSSIBLE.)
 1080 FORMAT (//40H THE FOLLOWING SUMMARY SHOULD BE USED TO, 8H ANALYZE,
     +   30H THE ABOVE MENTIONED PROBLEMS.)
 1090 FORMAT (/50H THE LEAST SQUARES FIT OF THE DATA TO THE MODEL IS,
     +   35H EXACT TO WITHIN MACHINE PRECISION./20H STATISTICAL ANALYSI,
     +   33HS OF THE RESULTS IS NOT POSSIBLE.)
 1100 FORMAT (//1X, 5HINDEX, 2X, 5HFIXED, 3X, 9HPARAMETER)
 1110 FORMAT (1X, I3, 5X, 3H NO, G17.8)
 1120 FORMAT (1X, I3, 5X, 3HYES, G17.8)
      END
*NLS
      SUBROUTINE NLS(Y, XM, N, M, IXM, MDL, PAR, NPAR, RES, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
C     (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),XM(*),Y(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IPRT,IVAPRX,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,LWT,
     +   MIT,NNZW,NPARE,NPRT
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SCALE(1),SDPV(1),SDRES(1),STP(1),VCV(1,1),WT(1)
      INTEGER
     +   IFIXED(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTN
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(1)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LSTP
C        THE ACTUAL LENGTH OF THE VECTOR STP.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PV(1)
C        A DUMMY ARRAY FOR
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(1)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(1)
C        THE STEP SIZE ARRAY.
C     DOUBLE PRECISION VCV(1,1)
C        A DUMMY ARRAY FOR
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(1)
C        THE DUMMY ARRAY FOR THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S',' ',' ',' '/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      WEIGHT = .FALSE.
      SAVE = .FALSE.
C
      WT(1) = 1.0D0
      STP(1) = -1.0D0
      MIT = -1
      STOPSS = -1.0D0
      STOPP = -1.0D0
      SCALE(1) = -1.0D0
      DELTA = -1.0D0
      NPRT = -1
      IFIXED(1) = -1
      IVAPRX = 0
      LIFIXD = 1
      LPV = 1
      LSTP = 1
      LSCALE = 1
      LSDPV = 1
      LSDRES = 1
      LWT = 1
      IVCV = 1
C
      CALL NLCNTN(Y, WT, LWT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLS (Y, XM, N, M, IXM, NLSMDL,'/
     +   '      +          PAR, NPAR, RES, LDSTAK)')
      END
*NLSC
      SUBROUTINE NLSC(Y, XM, N, M, IXM, MDL, PAR, NPAR, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
C     (CONTROL CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,STOPP,STOPSS
      INTEGER
     +   IVAPRX,IXM,LDSTAK,M,MIT,N,NPAR,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),SCALE(*),STP(*),XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,LWT,NNZW,
     +   NPARE
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SDPV(1),SDRES(1),VCV(1,1),WT(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTN
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LSTP
C        THE ACTUAL LENGTH OF THE VECTOR STP.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PV(1)
C        A DUMMY ARRAY FOR
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(NPAR)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(NPAR)
C        THE STEP SIZE ARRAY.
C     DOUBLE PRECISION VCV(1,1)
C        A DUMMY ARRAY FOR
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(1)
C        THE DUMMY ARRAY FOR THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','C',' ',' '/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      WEIGHT = .FALSE.
      SAVE = .FALSE.
C
      WT(1) = 1.0D0
      LIFIXD = NPAR
      LPV = 1
      LSCALE = NPAR
      LSTP = NPAR
      LSDPV = 1
      LSDRES = 1
      LWT = 1
      IVCV = 1
C
      CALL NLCNTN(Y, WT, LWT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSC (Y, XM, N, M, IXM, NLSMDL,'/
     +   '      +           PAR, NPAR, RES, LDSTAK,'/
     +   '      +           IFIXED, STP, MIT, STOPSS, STOPP,'/
     +   '      +           SCALE, DELTA, IVAPRX, NPRT)')
      END
*NLSD
      SUBROUTINE NLSD(Y, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION USING ANALYTIC DERIVATIVES (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),XM(*),Y(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IPRT,IVAPRX,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,
     +   LWT,MIT,NNZW,NPARE,NPRT
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SCALE(1),SDPV(1),SDRES(1),VCV(1,1),WT(1)
      INTEGER
     +   IFIXED(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTA
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IDRVCK
C        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE DERIVATIVES WE
C        CHECKED OR NOT.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(1)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PV(1)
C        A DUMMY ARRAY FOR
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(1)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION VCV(1,1)
C        A DUMMY ARRAY FOR
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(1)
C        THE DUMMY ARRAY FOR THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','D',' ',' '/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      WEIGHT = .FALSE.
      SAVE = .FALSE.
C
      WT(1) = 1.0D0
      IDRVCK = 1
      MIT = -1
      STOPSS = -1.0D0
      STOPP = -1.0D0
      SCALE(1) = -1.0D0
      DELTA = -1.0D0
      NPRT = -1
      IFIXED(1) = -1
      IVAPRX = 0
      LIFIXD = 1
      LPV = 1
      LSCALE = 1
      LSDPV = 1
      LSDRES = 1
      LWT = 1
      IVCV = 1
C
      CALL NLCNTA(Y, WT, LWT, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, IDRVCK, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSD (Y, XM, N, M, IXM, NLSMDL, NLSDRV,'/
     +   '      +           PAR, NPAR, RES, LDSTAK)')
      END
*NLSDC
      SUBROUTINE NLSDC(Y, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION USING ANALYTIC DERIVATIVES WITH USER
C     SUPPLIED CONTROL PARAMETERS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IVAPRX,IXM,LDSTAK,M,MIT,N,NPAR,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),SCALE(*),XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LWT,NNZW,NPARE
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SDPV(1),SDRES(1),VCV(1,1),WT(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTA
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IDRVCK
C        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE DERIVATIVES WE
C        CHECKED OR NOT.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PV(1)
C        A DUMMY ARRAY FOR
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(NPAR)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION VCV(1,1)
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(1)
C        THE DUMMY ARRAY FOR THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','D','C',' '/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      WEIGHT = .FALSE.
      SAVE = .FALSE.
C
      WT(1) = 1.0D0
      LIFIXD = NPAR
      LPV = 1
      LSCALE = NPAR
      LSDPV = 1
      LSDRES = 1
      LWT = 1
      IVCV = 1
C
      CALL NLCNTA(Y, WT, LWT, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, IDRVCK, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSDC (Y, XM, N, M, IXM, NLSMDL, NLSDRV,'/
     +   '      +            PAR, NPAR, RES, LDSTAK,'/
     +   '      +            IFIXED, IDRVCK, MIT, STOPSS, STOPP,'/
     +   '      +            SCALE, DELTA, IVAPRX, NPRT)')
      END
*NLSDS
      SUBROUTINE NLSDS(Y, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION USING ANALYTIC DERIVATIVES WITH USER
C     SUPPLIED CONTROL PARAMETERS, AND WITH COMPUTED VALUES RETURNED
C     TO THE USER.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IVAPRX,IVCV,IXM,LDSTAK,M,MIT,N,NPAR,NPARE,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),VCV(*),XM(*),
     +   Y(*)
      INTEGER
     +   IFIXED(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LWT,NNZW
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   WT(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTA
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IDRVCK
C        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE DERIVATIVES WE
C        CHECKED OR NOT.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(NPAR)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(N)
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(N)
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(1)
C        THE DUMMY ARRAY FOR THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','D','S',' '/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      WEIGHT = .FALSE.
      SAVE = .TRUE.
C
      WT(1) = 1.0D0
      LIFIXD = NPAR
      LPV = N
      LSCALE = NPAR
      LSDPV = N
      LSDRES = N
      LWT = 1
C
      CALL NLCNTA(Y, WT, LWT, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, IDRVCK, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSDS (Y, XM, N, M, IXM, NLSMDL, NLSDRV,'/
     +   '      +            PAR, NPAR, RES, LDSTAK,'/
     +   '      +            IFIXED, IDRVCK, MIT, STOPSS, STOPP,'/
     +   '      +            SCALE, DELTA, IVAPRX, NPRT,'/
     +   '      +            NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)')
      END
*NLSKL
      SUBROUTINE NLSKL(ISKULL, PAGE, WIDE, NLHDR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRINTS A HEADING AND WARNING MESSAGES FOR
C     SERIOUS ERRORS DETECTED BY THE NONLINEAR LEAST SQUARES ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      LOGICAL
     +   PAGE,WIDE
C
C  ARRAY ARGUMENTS
      INTEGER
     +   ISKULL(10)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL NLHDR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,ISUBHD
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     EXTERNAL NLHDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ISKULL(10)
C        AN ERROR MESSAGE INDICATOR VARIABLE.
C     INTEGER ISUBHD
C        AN INTEGER VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE OUTPUT
C        IS TO BEGIN ON A NEW PAGE.
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C
      CALL IPRINT(IPRT)
C
      ISUBHD = 0
      CALL NLHDR(PAGE, WIDE, ISUBHD)
C
      IF (WIDE) THEN
         WRITE (IPRT,1010)
         WRITE (IPRT,1020)
C        WRITE (IPRT,1030)
C        WRITE (IPRT,1040)
C        WRITE (IPRT,1050)
         WRITE (IPRT,1000)
      END IF
      WRITE (IPRT,1060)
C
C     VCV COMPUTATION NOT COMPLETED
C
      IF (ISKULL(7).NE.0) WRITE (IPRT,1120)
C
C     MAXIMUM NUMBER OF ITERATIONS REACHED BEFORE CONVERGENCE
C
      IF (ISKULL(6).NE.0) WRITE (IPRT,1100)
C
C     FALSE CONVERGENCE
C
      IF (ISKULL(5).NE.0) WRITE (IPRT,1090)
C
C     MEANINGLESS VCV MATRIX
C
      IF (ISKULL(4).NE.0) WRITE (IPRT,1080)
C
C     PROBLEM IS COMPUTATIONALLY SINGULAR
C
      IF (ISKULL(3).NE.0) WRITE (IPRT,1070)
C
C     INITIAL RESIDUAL SUM OF SQUARES COMPUTATION OVERFLOWED
C
      IF (ISKULL(2).NE.0) WRITE (IPRT,1110)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (///)
 1010 FORMAT (/48H  W      W     AA     RRRRRRR   N      N    IIII,
     +   19H    N      N    GGG/31H  W      W    A  A    R     RR ,
     +   38H NN     N     II     NN     N   G    G/12H  W      W  ,
     +   51H  A  A    R      R  N N    N     II     N N    N  G/
     +   59H  WW    WW   AA  AA   R     RR  N  N   N     II     N  N   ,
     +   4HN  G/47H   W    W    AAAAAA   RRRRRRR   N  NN  N     II,
     +   23H     N  NN  N  G  GGGGG)
 1020 FORMAT (49H   W WW W    A    A   R R       N   N  N     II  ,
     +   21H   N   N  N  G      G/29H   W WW W    A    A   R  R   ,
     +   41H   N    N N     II     N    N N  G      G/9H    W  W ,
     +   59H   AA    AA  R   R     N     NN     II     N     NN   G    ,
     +   2HGG/49H    W  W    A      A  R    R    N      N    IIII ,
     +   21H   N      N    GGGG G/)
C1010 FORMAT (/30X, 48H  W      W     AA     RRRRRRR   N      N    IIII,
C    *   19H    N      N    GGG/30X, 31H  W      W    A  A    R     RR ,
C    *   38H NN     N     II     NN     N   G    G/30X, 12H  W      W  ,
C    *   51H  A  A    R      R  N N    N     II     N N    N  G/30X,
C    *   59H  WW    WW   AA  AA   R     RR  N  N   N     II     N  N   ,
C    *   4HN  G/30X, 47H   W    W    AAAAAA   RRRRRRR   N  NN  N     II,
C    *   23H     N  NN  N  G  GGGGG)
C1020 FORMAT (30X, 49H   W WW W    A    A   R R       N   N  N     II  ,
C    *   21H   N   N  N  G      G/30X, 29H   W WW W    A    A   R  R   ,
C    *   41H   N    N N     II     N    N N  G      G/30X, 9H    W  W ,
C    *   59H   AA    AA  R   R     N     NN     II     N     NN   G    ,
C    *   2HGG/30X, 49H    W  W    A      A  R    R    N      N    IIII ,
C    *   21H   N      N    GGGG G/)
C1030 FORMAT (1(34X, 3HXXX, 58X, 3HXXX/), 31X, 6('X'), 58X, 6('X')/31X,
C    *   7('X'), 56X, 7('X')/31X, 9('X'), 52X, 9('X')/36X, 5('X'), 17X,
C    *   '(', 14('-'), ')', 17X, 5('X')/38X, 5('X'), 14X, 2H((, 14X,
C    *   2H)), 14X, 5('X')/40X, 5('X'), 10X, 2H((, 18X, 2H)), 10X,
C    *   5('X')/41X, 5('X'), 8X, 2H((, 20X, 2H)), 8X, 5('X')/43X,
C    *   5('X'), 5X, 2H((, 22X, 2H)), 5X, 5('X')/44X, 5('X'), 3X, 2H((,
C    *   24X, 2H)), 3X, 5('X'))
C1040 FORMAT (46X, 7HXXXXX (, 26X, 7H) XXXXX/48X,
C    *   5HXXX((, 7X, 2HOO, 8X, 2HOO, 7X, 5H))XXX/49X, 3HXX(, 7X,
C    *   4HO  O, 6X, 4HO  O, 7X, 3H)XX/50X, 2HX(, 7X, 4HO  O, 6X,
C    *   4HO  O, 7X, 2H)X/51X, '(', 8X, 2HOO, 8X, 2HOO, 8X, ')'/2(51X,
C    *   '(', 28X, ')'/), 51X, '(', 11X, 6HOO  OO, 11X, ')'/51X, 2H((,
C    *   10X, 6HOO  OO, 10X, 2H))/52X, 2H((, 24X, 2H))/53X, '(', 24X,
C    *   ')'/54X, '(', 22X, ')')
C1050 FORMAT (55X, 4H(--(, 14X, 4H)--)/59X, '(', 12X, ')'/58X,
C    *   3HX((, 10X, 3H))X/56X, 5HXXXX(, 10X, 5H)XXXX/54X, 9HXXXXX (II,
C    *   15HIIIIIIII) XXXXX/53X, 5('X'), 2X, 12H(IIIIIIIIII), 2X, 5('X')
C    *   /51X, 5('X'), 4X, '(', 10X, ')', 4X, 5('X')/49X, 5('X'), 6X,
C    *   2H((, 8X, 2H)), 6X, 5('X')/48X, 5('X'), 8X, 10H(--------), 8X,
C    *   5('X')/46X, 5('X'), 30X, 5('X')/44X, 5('X'), 34X, 5('X')/43X,
C    *   5('X'), 36X, 5('X')/41X, 5('X'), 40X, 5('X')/40X, 4HXXXX, 44X,
C    *   4HXXXX/38X, 5('X'), 46X, 5('X')/36X, 5('X'), 50X, 5('X')/31X,
C    *   9('X'), 52X, 9('X')/31X, 7('X'), 56X, 7('X')/31X, 6('X'), 58X,
C    *   6('X')/1(34X, 3HXXX, 58X, 3HXXX))
 1060 FORMAT (22H **  ERROR SUMMARY  **)
 1070 FORMAT (/50H THIS MODEL AND DATA ARE COMPUTATIONALLY SINGULAR.,
     +   29H CHECK YOUR INPUT FOR ERRORS.)
 1080 FORMAT (/43H AT LEAST ONE OF THE STANDARDIZED RESIDUALS, 6H COULD,
     +   47H NOT BE COMPUTED BECAUSE THE STANDARD DEVIATION, 8H OF THE ,
     +   18HRESIDUAL WAS ZERO./37H THE VALIDITY OF THE COVARIANCE MATRI,
     +   18HX IS QUESTIONABLE.)
 1090 FORMAT (/46H THE ITERATIONS DO NOT APPEAR TO BE CONVERGING,
     +   13H TO A MINIMUM, 41H (FALSE CONVERGENCE), INDICATING THAT THE,
     +   12H CONVERGENCE, 16H CRITERIA STOPSS/22H AND STOPP MAY BE TOO ,
     +   35HSMALL FOR THE ACCURACY OF THE MODEL, 17H AND DERIVATIVES,,
     +   52H THAT THERE IS AN ERROR IN THE DERIVATIVE MATRIX, OR/
     +   15H THAT THE MODEL, 39H IS DISCONTINUOUS NEAR THE CURRENT COEF,
     +   18HFICIENT ESTIMATES.)
 1100 FORMAT (/53H PROGRAM DID NOT CONVERGE IN THE NUMBER OF ITERATIONS,
     +   13H OR NUMBER OF, 32H MODEL SUBROUTINE CALLS ALLOWED.)
 1110 FORMAT (/50H THE RESIDUAL SUM OF SQUARES COULD NOT BE COMPUTED,
     +   19H USING THE STARTING, 26H MODEL COEFFICIENT VALUES.)
 1120 FORMAT (/44H THE VARIANCE-COVARIANCE MATRIX COULD NOT BE,
     +   26H COMPUTED AT THE SOLUTION.)
      END
*NLSPK
      SUBROUTINE NLSPK(PAR, MASK, NPAR, PPAR, NPPAR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PACKS A VECTOR PAR INTO A VECTOR PPAR, BY
C     OMITTING FROM THE PACKED VERSION THOSE ELEMENTS OF THE
C     UNPACKED VERSION CORRESPONDING TO ELEMENTS OF MASK WHICH
C     HAVE THE VALUE 1.  OTHER ELEMENTS OF MASK SHOULD BE ZERO.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   NPAR,NPPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PPAR(NPPAR)
      INTEGER
     +   MASK(NPAR)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPPAR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION PAR(NPAR)
C        INPUT PARAMETER.  THE UNPACKED VECTOR.
C     INTEGER I
C        LOOP PARAMETER.
C     INTEGER IPPAR
C        CURRENT ELEMENT OF PPAR.  RANGES FROM 0 (ON INITIALIZATION)
C        TO NPPAR.
C     INTEGER MASK(NPAR)
C        INPUT PARAMETER.  THE MASK GOVERNING THE PACKING OF PAR.
C        ELEMENTS OF MASK ARE 1 IF THE CORRESPONDING ELEMENT OF PAR
C        IS TO BE ELIMINATED IN PPAR, 0 IF IT IS TO BE INCLUDED.
C     INTEGER NPAR
C        INPUT PARAMETER.  THE LENGTH OF PAR.
C     INTEGER NPPAR
C        INPUT PARAMETER.  THE LENGTH OF PPAR.
C     DOUBLE PRECISION PPAR(NPPAR)
C        OUTPUT PARAMETER.  THE PACKED VERSION OF PAR.  SEE INITIAL
C        DESCRIPTION.
C
C     COMMENCE BODY OF ROUTINE
C
      IPPAR = 0
      DO 10 I=1,NPAR
         IF (MASK(I).NE.0) GO TO 10
         IPPAR = IPPAR + 1
         PPAR(IPPAR) = PAR(I)
   10 CONTINUE
      RETURN
      END
*NLSS
      SUBROUTINE NLSS(Y, XM, N, M, IXM, MDL, PAR, NPAR, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
C     (LONG CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IVAPRX,IVCV,IXM,LDSTAK,M,MIT,N,NPAR,NPARE,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),STP(*),VCV(*),
     +   XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,LWT,NNZW
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   WT(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTN
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LSTP
C        THE ACTUAL LENGTH OF THE VECTOR STP.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(NPAR)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(N)
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(N)
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(NPAR)
C        THE STEP SIZE ARRAY.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(1)
C        THE DUMMY ARRAY FOR THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','S',' ',' '/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      WEIGHT = .FALSE.
      SAVE = .TRUE.
C
      WT(1) = 1.0D0
      LIFIXD = NPAR
      LPV = N
      LSCALE = NPAR
      LSTP = NPAR
      LSDPV = N
      LSDRES = N
      LWT = 1
C
      CALL NLCNTN(Y, WT, LWT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSS (Y, XM, N, M, IXM, NLSMDL,'/
     +   '      +           PAR, NPAR, RES, LDSTAK,'/
     +   '      +           IFIXED, STP, MIT, STOPSS, STOPP,'/
     +   '      +           SCALE, DELTA, IVAPRX, NPRT,'/
     +   '      +           NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)')
      END
*NLSUPK
      SUBROUTINE NLSUPK(PARE, NPARE, PAR, MASK, NPAR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE UNPACKS A VECTOR PARE INTO A VECTOR PAR, BY
C     PLACING SUCCEDING ELEMENTS OF PARE INTO ELEMENTS OF PAR
C     WHICH CORRESPOND TO ELEMENTS OF MASK WITH THE VALUE 1.
C     OTHER ELEMENTS OF MASK SHOULD BE 0.  THE NUMBER OF ELEMENTS
C     NPARE IN PARE SHOULD EQUAL THE NUMBER OF ELEMENTS OF
C     MASK WHICH ARE 1.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   NPAR,NPARE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PARE(NPAR)
      INTEGER
     +   MASK(NPAR)
C
C  LOCAL SCALARS
      INTEGER
     +   I,JPK
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER JPK
C        AN INDEX VARIABLE.
C     INTEGER MASK(NPAR)
C        INPUT PARAMETER.  THE MASK GOVERNING THE PACKING OF PAR.
C        ELEMENTS OF MASK ARE 1 IF THE CORRESPONDING ELEMENT OF PAR
C        WAS ELIMINATED IN PARE, 0 IF IT WAS INCLUDED.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
C     DOUBLE PRECISION PARE(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS BEING OPTIMIZED,
C        NOT INCLUDING THOSE WHOSE VALUES ARE FIXED.
C
C     COMMENCE BODY OF ROUTINE
C
      JPK = 0
      DO 20 I=1,NPAR
         IF (MASK(I).NE.0) GO TO 20
         JPK = JPK + 1
         PAR(I) = PARE(JPK)
   20 CONTINUE
      RETURN
      END
*NLSW
      SUBROUTINE NLSW(Y, WT, XM, N, M, IXM, MDL, PAR, NPAR, RES, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
C     AND WEIGHTS (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),WT(*),XM(*),Y(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IPRT,IVAPRX,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,LWT,
     +   MIT,NNZW,NPARE,NPRT
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SCALE(1),SDPV(1),SDRES(1),STP(1),VCV(1,1)
      INTEGER
     +   IFIXED(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTN
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(1)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LSTP
C        THE ACTUAL LENGTH OF THE VECTOR STP.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PV(1)
C        A DUMMY ARRAY FOR
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(1)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(1)
C        THE STEP SIZE ARRAY.
C     DOUBLE PRECISION VCV(1,1)
C        A DUMMY ARRAY FOR
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(N)
C        THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','W',' ',' '/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      WEIGHT = .TRUE.
      SAVE = .FALSE.
C
      STP(1) = -1.0D0
      MIT = -1
      STOPSS = -1.0D0
      STOPP = -1.0D0
      SCALE(1) = -1.0D0
      DELTA = -1.0D0
      NPRT = -1
      IFIXED(1) = -1
      IVAPRX = 0
      LIFIXD = 1
      LPV = 1
      LSTP = 1
      LSCALE = 1
      LSDPV = 1
      LSDRES = 1
      LWT = N
      IVCV = 1
C
      CALL NLCNTN(Y, WT, LWT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSW (Y, WT, XM, N, M, IXM, NLSMDL,'/
     +   '      +           PAR, NPAR, RES, LDSTAK)')
      END
*NLSWC
      SUBROUTINE NLSWC(Y, WT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
C     AND WEIGHTS (CONTROL CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,STOPP,STOPSS
      INTEGER
     +   IVAPRX,IXM,LDSTAK,M,MIT,N,NPAR,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),SCALE(*),STP(*),WT(*),XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,LWT,NNZW,
     +   NPARE
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SDPV(1),SDRES(1),VCV(1,1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTN
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LSTP
C        THE ACTUAL LENGTH OF THE VECTOR STP.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PV(1)
C        A DUMMY ARRAY FOR
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(NPAR)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(NPAR)
C        THE STEP SIZE ARRAY.
C     DOUBLE PRECISION VCV(1,1)
C        A DUMMY ARRAY FOR
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(N)
C        THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','W','C',' '/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      WEIGHT = .TRUE.
      SAVE = .FALSE.
C
      LIFIXD = NPAR
      LPV = 1
      LSCALE = NPAR
      LSTP = NPAR
      LSDPV = 1
      LSDRES = 1
      LWT = N
      IVCV = 1
C
      CALL NLCNTN(Y, WT, LWT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSWC (Y, WT, XM, N, M, IXM, NLSMDL,'/
     +   '      +            PAR, NPAR, RES, LDSTAK,'/
     +   '      +            IFIXED, STP, MIT, STOPSS, STOPP, SCALE,'/
     +   '      +            DELTA, IVAPRX, NPRT)')
      END
*NLSWD
      SUBROUTINE NLSWD(Y, WT, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION USING ANALYTIC DERIVATIVES AND WEIGHTS
C     (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),WT(*),XM(*),Y(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IPRT,IVAPRX,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,
     +   LWT,MIT,NNZW,NPARE,NPRT
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SCALE(1),SDPV(1),SDRES(1),VCV(1,1)
      INTEGER
     +   IFIXED(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTA
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IDRVCK
C        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE DERIVATIVES WE
C        CHECKED OR NOT.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(1)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF IFIXED(I).EQ
C        THEN PAR(I) WILL BE HELD FIXED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PV(1)
C        A DUMMY ARRAY FOR
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(1)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION VCV(1,1)
C        A DUMMY ARRAY FOR
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(N)
C        THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','W','D',' '/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      WEIGHT = .TRUE.
      SAVE = .FALSE.
C
      IDRVCK = 1
      MIT = -1
      STOPSS = -1.0D0
      STOPP = -1.0D0
      SCALE(1) = -1.0D0
      DELTA = -1.0D0
      NPRT = -1
      IFIXED(1) = -1
      IVAPRX = 0
      LIFIXD = 1
      LPV = 1
      LSCALE = 1
      LSDPV = 1
      LSDRES = 1
      LWT = N
      IVCV = 1
C
      CALL NLCNTA(Y, WT, LWT, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, IDRVCK, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSWD (Y, WT, XM, N, M, IXM, NLSMDL, NLSDRV,'/
     +   '      +            PAR, NPAR, RES, LDSTAK)')
      END
*NLSWDC
      SUBROUTINE NLSWDC(Y, WT, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION USING ANALYTIC DERIVATIVES, WEIGHTS, AND
C     USER SUPPLIED CONTROL PARAMETERS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IVAPRX,IXM,LDSTAK,M,MIT,N,NPAR,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),SCALE(*),WT(*),XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LWT,NNZW,NPARE
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SDPV(1),SDRES(1),VCV(1,1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTA
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IDRVCK
C        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
C        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF IFIXED(I).EQ
C        THEN PAR(I) WILL BE HELD FIXED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PV(1)
C        A DUMMY ARRAY FOR
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(NPAR)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(1)
C        A DUMMY ARRAY FOR
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION VCV(1,1)
C        A DUMMY ARRAY FOR
C        THE VARIANCE-COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(N)
C        THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','W','D','C'/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      WEIGHT = .TRUE.
      SAVE = .FALSE.
C
      LIFIXD = NPAR
      LPV = 1
      LSCALE = NPAR
      LSDPV = 1
      LSDRES = 1
      LWT = N
      IVCV = 1
C
      CALL NLCNTA(Y, WT, LWT, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, IDRVCK, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSWDC (Y, WT, XM, N, M, IXM, NLSMDL, NLSDRV,'/
     +   '      +             PAR, NPAR, RES, LDSTAK,'/
     +   '      +             IFIXED, IDRVCK, MIT, STOPSS, STOPP,'/
     +   '      +             SCALE, DELTA, IVAPRX, NPRT)')
      END
*NLSWDS
      SUBROUTINE NLSWDS (Y, WT, XM, N, M, IXM, MDL, DRV, PAR,
     +   NPAR, RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE,
     +   DELTA, IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV,
     +   IVCV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION USING ANALYTIC DERIVATIVES, WEIGHTS, AND
C     USER SUPPLIED CONTROL PARAMETERS, AND WITH COMPUTED VALUES
C     RETURNED TO THE USER.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IVAPRX,IVCV,IXM,LDSTAK,M,MIT,N,NNZW,NPAR,NPARE,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),VCV(*),WT(*),
     +   XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LWT
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTA
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     EXTERNAL DRV
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IDRVCK
C        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
C        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF IFIXED(I).EQ
C        THEN PAR(I) WILL BE HELD FIXED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(NPAR)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(N)
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(N)
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL STANDARD DEVIATION (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE VARIANCE-COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(N)
C        THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'N',       'L',       'S',       'W',       'D',       'S'/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      WEIGHT = .TRUE.
      SAVE = .TRUE.
C
      LIFIXD = NPAR
      LPV = N
      LSCALE = NPAR
      LSDPV = N
      LSDRES = N
      LWT = N
C
      CALL NLCNTA(Y, WT, LWT, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, IDRVCK, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSWDS (Y, WT, XM, N, M, IXM, NLSMDL, NLSDRV,'/
     +   '      +             PAR, NPAR, RES, LDSTAK,'/
     +   '      +             IFIXED, IDRVCK, MIT, STOPSS, STOPP,'/
     +   '      +             SCALE, DELTA, IVAPRX, NPRT,'/
     +   '      +             NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV,',
     +   ' IVCV)')
C
      END
*NLSWS
      SUBROUTINE NLSWS(Y, WT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
C     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
C     AND WEIGHTS (LONG CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IVAPRX,IVCV,IXM,LDSTAK,M,MIT,N,NNZW,NPAR,NPARE,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),STP(*),VCV(*),
     +   WT(*),XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,LWT
      LOGICAL
     +   SAVE,WEIGHT
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTN
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF IFIXED(I).EQ
C        THEN PAR(I) WILL BE HELD FIXED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
C     INTEGER LPV
C        THE ACTUAL LENGTH OF THE VECTOR PV.
C     INTEGER LSCALE
C        THE ACTUAL LENGTH OF THE VECTOR SCALE.
C     INTEGER LSDPV
C        THE ACTUAL LENGTH OF THE VECTOR SDPV.
C     INTEGER LSDRES
C        THE ACTUAL LENGTH OF THE VECTOR SDRES.
C     INTEGER LSTP
C        THE ACTUAL LENGTH OF THE VECTOR STP.
C     INTEGER LWT
C        THE ACTUAL LENGTH OF THE VECTOR WT.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(NPAR)
C        THE CURRENT ESTIMATES OF THE PARAMETERS.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     LOGICAL SAVE
C        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
C        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION SCALE(NPAR)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SDPV(N)
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(N)
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(NPAR)
C        THE STEP SIZE ARRAY.
C     DOUBLE PRECISION VCV(IVCV,NPAR)
C        THE VARIANCE COVARIANCE MATRIX.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(N)
C        THE WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','W','S',' '/
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      WEIGHT = .TRUE.
      SAVE = .TRUE.
C
      LIFIXD = NPAR
      LPV = N
      LSCALE = NPAR
      LSTP = NPAR
      LSDPV = N
      LSDRES = N
      LWT = N
C
      CALL NLCNTN(Y, WT, LWT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
C
      IF (IERR.NE.1) RETURN
C
C     PRINT PROPER CALL SEQUENCE
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSWS (Y, WT, XM, N, M, IXM, NLSMDL,'/
     +   '      +            PAR, NPAR, RES, LDSTAK,'/
     +   '      +            IFIXED, STP, MIT, STOPSS, STOPP,'/
     +   '      +            SCALE, DELTA, IVAPRX, NPRT,'/
     +   '      +            NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV,',
     +   ' IVCV)')
      END
*NLSX1
      SUBROUTINE NLSX1(MOD, PAR, NPAR, PV, SDPV, RES, SDRES, VCV, N,
     +   IVCV, NNZW, NPARE, RSD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     SET THE STARTING PARAMETER VALUES FOR NLSX
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,MOD,N,NNZW,NPAR,NPARE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PV(N),RES(N),SDPV(N),SDRES(N),VCV(IVCV,IVCV)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I,J
C
C  EXTERNAL SUBROUTINES
      EXTERNAL SETRV
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IVCV
C        THE ACTUAL FIRST DIMENSION OF VCV.
C     INTEGER MOD
C        AN INDICATOR VALUE USED TO DESIGNATE THE MODEL FOR WHICH
C        THE PARAMETERS ARE TO BE SET.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C        TO BE PROVIDED.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
C     INTEGER NNZW
C        THE NUMBER OF NONZERO WEIGHTS.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUES.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     DOUBLE PRECISION SDPV(N)
C        THE STANDARD DEVIATION OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(N)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION VCV(IVCV,IVCV)
C        THE VARIANCE COVARIANCE MATRIX.
C
C
C
      GO TO (10, 20, 30, 40, 50, 60), MOD
C
   10 PAR(1) = 0.725D0
      PAR(2) = 4.0D0
C
      GO TO 70
C
C
   20 PAR(1) = 1.0D0
      PAR(2) = 2.0D0
      PAR(3) = 3.0D0
C
      GO TO 70
C
C
   30 PAR(1) = 6.0D0
      PAR(2) = 5.0D0
      PAR(3) = 4.0D0
      PAR(4) = 3.0D0
      PAR(5) = 2.0D0
C
      GO TO 70
C
C
   40 CALL SETRV(PAR, NPAR, 0.0D0)
C
      GO TO 70
C
C
   50 CALL SETRV(PAR, NPAR, 0.5D0)
C
      GO TO 70
C
C
   60 PAR(1) = 100.0D0
      PAR(2) = 15.0D0
C
   70 CONTINUE
C
      DO 80 I=1,N
         RES(I) = -1.0D0
         PV(I) = -1.0D0
         SDPV(I) = -1.0D0
         SDRES(I) = -1.0D0
   80 CONTINUE
C
      DO 100 I=1,IVCV
         DO 90 J=1,IVCV
            VCV(I,J) = -1.0D0
   90    CONTINUE
  100 CONTINUE
C
      NNZW = -1
      NPARE = -1
      RSD = -1.0D0
C
      IERR = -1
C
      RETURN
C
      END
*NLSX2
      SUBROUTINE NLSX2(N, M, IXM, NPAR, IFIXED, STP, IDRVCK, MIT,
     +   STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     SET UP PROBLEM SPECIFICATION FOR TESTING THE USER CALLABLE
C     ROUTINES IN THE NONLINEAR  LEAST SQUARES FAMILY.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IVAPRX,IVCV,IXM,M,MIT,N,NPAR,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   SCALE(10),STP(10)
      INTEGER
     +   IFIXED(10)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   SQMEPS
      INTEGER
     +   I
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   RMDCON
      EXTERNAL RMDCON
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     INTEGER IDRVCK
C        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
C        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
C     INTEGER IFIXED(10)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION SCALE(10)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
C     DOUBLE PRECISION SQMEPS
C        THE SQUARE ROOT OF MACHINE PRECISION
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL STANDARD DEVIATION (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(10)
C        THE STEP SIZE ARRAY.
C
C
C     **SET UP FOR NORMAL STATEMENT**
C
      SQMEPS = SQRT(RMDCON(3))
C
      N = 6
      M = 1
      IXM = 10
      NPAR = 2
      MIT = 500
      DO 10 I=1,10
         STP(I) = SQMEPS
         SCALE(I) = 1.0D0
   10 CONTINUE
      IFIXED(1) = -1
      IDRVCK = 0
      STOPSS = 10.0D-5
      STOPP = 10.0D-5
      DELTA = 0.5D0
      NPRT = 11111
      IVAPRX = 3
      IVCV = 6
C
      RETURN
C
      END
*NRAND
      SUBROUTINE NRAND (Y, N, ISEED)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE GENERATES N NORMALLY DISTRIBUTED PSEUDO-
C     RANDOM NUMBERS WITH ZERO MEAN AND UNIT STANDARD DEVIATION.  THE
C     NUMBERS GENERATED ARE DETERMINED BY ISEED.  THEY ARE RETURNED IN Y
C
C     ORIGIN - CONCEIVED BY DR. PETER TRYON TO FACILITATE USE OF
C          EXISTING RANDOM NUMBER GENERATOR
C
C     WRITTEN BY -
C          JOHN E. KOONTZ AND JANET R. DONALDSON
C          STATISTICAL ENGINEERING DIVISION
C          NATIONAL BUREAU OF STANDARDS
C          BOULDER, COLORADO 80302
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISEED,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT,ISEEDU
      LOGICAL
     +   ERR01,HEAD
C
C  LOCAL ARRAYS
      CHARACTER
     +   LN(8)*1,LONE(8)*1,NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   RANDN
      EXTERNAL RANDN
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISRNG,IPRINT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C          THE INDEX OF THE COMPUTING LOOP
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THEIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN FOUND.
C     INTEGER IPRT
C        THE STANDARD OUTPUT FILE UNIT NUMBER
C     INTEGER ISEED
C        THE ISEED TO THE RANDOM NUMBER GENERATOR.
C        ISEED MUST LIE BETWEEN 0 AND 2**((MIN(32,I1MACH(8)+1))-1) -1,
C        INCLUSIVE.  IF ISEED IS NOT EQUAL TO 0, ISEED MUST BE ODD.
C     INTEGER ISEEDU
C        THE VALUE OF THE SEED ACTUALLY USED.
C     CHARACTER*1 LN(8), LONE(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE VARIABLES(S) CHECKED
C        FOR ERRORS
C     INTEGER N
C        THE LENGTH OF DATA SET GENERATED
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THIS SUBROUTINE
C     DOUBLE PRECISION Y(N)
C        THE GENERATED RANDOM VALUES.
C
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'N',      'R',      'A',      'N',      'D',      ' '/
      DATA     LN(1),    LN(2),    LN(3),    LN(4),    LN(5),    LN(6),
     +         LN(7),    LN(8)/'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA   LONE(1),  LONE(2),  LONE(3),  LONE(4),  LONE(5),  LONE(6),
     +       LONE(7),  LONE(8)/'O', 'N', 'E', ' ', ' ', ' ', ' ', ' '/
C
      IERR = 0
C
      HEAD = .TRUE.
C
C     CHECK FOR INPUT ERRORS
C
      CALL EISGE(NMSUB, LN, N, 1, 2, HEAD, ERR01, LONE)
      CALL EISRNG(NMSUB, ISEED, ISEEDU, HEAD)
C
      IF (ERR01) THEN
C
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
        IERR = 1
C
      ELSE
C
C     GENERATE THE PSEUDO-RANDOM NUMBERS
C
        Y(1) = RANDN(ISEEDU)
        DO 20 I=1,N
           Y(I) = RANDN(0)
   20   CONTINUE
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NRAND(Y, N, ISEED)')
      END
*NRANDC
      SUBROUTINE NRANDC(Y, N, ISEED, YMEAN, SIGMA)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE GENERATES N NORMALLY DISTRIBUTED PSEUDO-
C     RANDOM NUMBERS WITH MEAN YMEAN AND STANDARD DEVIATION SIGMA.  THE
C     NUMBERS GENERATED ARE DETERMINED BY ISEED.  THEY ARE RETURNED IN Y
C
C     ORIGIN - CONCEIVED BY DR. PETER TRYON TO FACILITATE USE OF
C          EXISTING RANDOM NUMBER GENERATOR
C
C     WRITTEN BY -
C          JOHN E. KOONTZ AND JANET R. DONALDSON
C          STATISTICAL ENGINEERING DIVISION
C          NATIONAL BUREAU OF STANDARDS,
C          BOULDER, COLORADO 80302
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SIGMA,YMEAN
      INTEGER
     +   ISEED,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT,ISEEDU
      LOGICAL
     +   ERR01,ERR02,HEAD
C
C  LOCAL ARRAYS
      CHARACTER
     +   LN(8)*1,LONE(8)*1,LSIGMA(8)*1,LZERO(8)*1,NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   RANDN
      EXTERNAL RANDN
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISRNG,ERSGE,IPRINT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01, ERR02
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C          THE INDEX OF THE COMPUTING LOOP
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THEIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN FOUND.
C     INTEGER IPRT
C        THE STANDARD OUTPUT FILE UNIT NUMBER
C     INTEGER ISEED
C        THE ISEED TO THE RANDOM NUMBER GENERATOR.
C        ISEED MUST LIE BETWEEN 0 AND 2**((MIN(32,I1MACH(8)+1))-1) -1,
C        INCLUSIVE.  IF ISEED IS NOT EQUAL TO 0, ISEED MUST BE ODD.
C     INTEGER ISEEDU
C        THE VALUE OF THE SEED ACTUALLY USED.
C     CHARACTER*1 LN(8), LONE(8), LSIGMA(8), LZERO(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE VARIABLES(S) CHECKED
C        FOR ERRORS
C     INTEGER N
C        THE LENGTH OF DATA SET GENERATED
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THIS SUBROUTINE
C     DOUBLE PRECISION SIGMA
C        THE STANDARD DEVIATION OF THE GENERATED VALUES.
C     DOUBLE PRECISION Y(N)
C        THE GENERATED RANDOM VALUES.
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE GENERATED VALUES.
C
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'N',      'R',      'A',      'N',      'D',      'C'/
      DATA     LN(1),    LN(2),    LN(3),    LN(4),    LN(5),    LN(6),
     +         LN(7),    LN(8)/'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA   LONE(1),  LONE(2),  LONE(3),  LONE(4),  LONE(5),  LONE(6),
     +       LONE(7),  LONE(8)/'O', 'N', 'E', ' ', ' ', ' ', ' ', ' '/
      DATA LSIGMA(1),LSIGMA(2),LSIGMA(3),LSIGMA(4),LSIGMA(5),LSIGMA(6),
     +     LSIGMA(7),LSIGMA(8)/'S', 'I', 'G', 'M', 'A', ' ', ' ', ' '/
      DATA  LZERO(1), LZERO(2), LZERO(3), LZERO(4), LZERO(5), LZERO(6),
     +      LZERO(7), LZERO(8)/'Z', 'E', 'R', 'O', ' ', ' ', ' ', ' '/
C
      IERR = 0
C
      HEAD = .TRUE.
C
C     CHECK FOR INPUT ERRORS
C
      CALL EISGE(NMSUB, LN, N, 1, 2, HEAD, ERR01, LONE)
      CALL ERSGE(NMSUB, LSIGMA, SIGMA, 0.0D0, 2, HEAD, ERR02, LZERO)
      CALL EISRNG(NMSUB, ISEED, ISEEDU, HEAD)
C
      IF (ERR01.OR.ERR02) THEN
C
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
        IERR = 1
C
      ELSE
C
C     GENERATE THE PSEUDO-RANDOM NUMBERS
C
        Y(1) = RANDN(ISEEDU)
        DO 20 I=1,N
           Y(I) = RANDN(0)*SIGMA + YMEAN
   20   CONTINUE
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NRANDC (Y, N, ISEED, YMEAN, SIGMA)')
      END
*OANOVA
      SUBROUTINE OANOVA(YSUM, RED, NPAR, RVAR, NNZW, TEMP, IPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     COMPUTE AND PRINT ANALYSIS OF VARIANCE
C
C     WRITTEN BY DAVID HOGBEN, SEL, NBS.   10/09/69.
C
C     THIS ROUTINE WAS ADAPTED FROM THE OMNITAB ROUTINE OANOVA
C     BY - -
C
C     JANET R. DONALDSON
C     STATISTICAL ENGINEERING DIVISION
C     NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RVAR,YSUM
      INTEGER
     +   IPRT,NNZW,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RED(NPAR),TEMP(NPAR)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ASUM,CR,F1,F2,FPLM,PF1,PF2,RESMS,RESSS,SSU,V1F2,VR
      INTEGER
     +   I,K,NSUA
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFF,D1MACH
      EXTERNAL CDFF,D1MACH
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ASUM
C        *
C     DOUBLE PRECISION CR
C        *
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     DOUBLE PRECISION F1
C        *
C     DOUBLE PRECISION F2
C        *
C     INTEGER I
C        AN INDEX.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER K
C        *
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NSUA
C        *
C     DOUBLE PRECISION PF1
C        *
C     DOUBLE PRECISION PF2
C        *
C     DOUBLE PRECISION RED(NPAR)
C        THE REDUCTION TO THE SUM OF SQUARES DUE TO EACH PARAMETER.
C     DOUBLE PRECISION RESMS
C        *
C     DOUBLE PRECISION RESSS
C        *
C     DOUBLE PRECISION RVAR
C        THE RESIDUAL VARIANCE.
C     DOUBLE PRECISION SSU
C        *
C     DOUBLE PRECISION TEMP(NPAR)
C        A WORK VECTOR.
C     DOUBLE PRECISION VR
C        *
C     DOUBLE PRECISION V1F2
C        *
C     DOUBLE PRECISION YSUM
C        THE SUM OF THE WEIGHTED DEPENDENT VARIABLES SQUARED.
C
C
      FPLM = D1MACH(2)
C
      RESMS = YSUM/NNZW
      NSUA = NNZW
      WRITE (IPRT,1000)
      ASUM = 0.0D0
      VR = NNZW-NPAR
      RESSS = VR*RVAR
      TEMP(NPAR) = RESSS
      IF (NPAR.EQ.1) GO TO 20
      DO 10 I=2,NPAR
         K = NPAR + 2 - I
         TEMP(K-1) = TEMP(K) + RED(K)
   10 CONTINUE
   20 V1F2 = NPAR+1
      SSU = NNZW
      DO 50 I=1,NPAR
         NSUA = NSUA - 1
         ASUM = ASUM + RED(I)
         SSU = SSU - 1.0D0
         CR = ASUM/I
         RESMS = 0.0D0
         IF (SSU.GT.0.0D0) RESMS = TEMP(I)/SSU
         V1F2 = V1F2 - 1.0D0
C
C     NEVER POOL
C
         IF (RVAR.GT.0.0D0) GO TO 30
         F1 = FPLM
         F2 = FPLM
         PF1 = 0.0D0
         PF2 = 0.0D0
         GO TO 40
   30    F1 = RED(I)/RVAR
         PF1 = 1.0D0 - CDFF(F1,1.0D0,VR)
C
C     TEST HIGHER SUB-HYPOTHESES
C
         F2 = (TEMP(I)+RED(I)-RESSS)/V1F2/RVAR
         PF2 = 1.0D0 - CDFF(F2,V1F2,VR)
   40    CONTINUE
         WRITE (IPRT,1010) I, RED(I), CR, I, RESMS, NSUA, F1, PF1, F2,
     +      PF2
   50 CONTINUE
      WRITE (IPRT,1020) RESSS, NSUA
      WRITE (IPRT,1030) YSUM, NNZW
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (////50X, 20HANALYSIS OF VARIANCE/24X, 16H-DEPENDENT ON OR,
     +   33HDER VARIABLES ARE ENTERED, UNLESS, 21H VECTORS ARE ORTHOGON,
     +   3HAL-//
     +   1X, 5H PAR , 4X, 14HSUM OF SQUARES, 63X,
     +   19H------ PAR=0 ------, 4X, 19H------ PARS=0 -----/
     +   1X, 5HINDEX, 4X, 14HRED DUE TO PAR, 7X, 10HCUM MS RED,
     +   6X, 9HDF(MSRED), 6X, 10HCUM RES MS, 6X, 7HDF(RMS), 5X,
     +   'F', 8X, 7HPROB(F), 7X, 'F', 8X, 7HPROB(F)/)
 1010 FORMAT (1X, I3, 6X, G16.9, 3X, G16.9, 1X, I6, 8X, G16.9, 1X, I5,
     +   4X, G12.6, F7.3, 4X, G12.6, F7.3)
 1020 FORMAT (/1X, 10HRESIDUAL  , 1X, G14.7, 20X, I6)
 1030 FORMAT (1X, 10HTOTAL     , 1X, G14.7, 20X, I6)
      END
*OBSSM2
      SUBROUTINE OBSSM2(N, Y, PVT, SDPVT, RES, SDREST, IFIRST, ILAST)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBOUTINE LISTS THE DATA SUMMARY FOR THE ARIMA ESTIMATION
C     SUBROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IFIRST,ILAST,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PVT(N),RES(N),SDPVT(N),SDREST(N),Y(N)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,IPRT
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IERR
C        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIRST, ILAST
C        THE FIRST AND LAST INDICES TO BE LISTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     DOUBLE PRECISION PVT(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION SDPVT(N)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDREST(N)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION Y(N)
C        THE DEPENDENT VARIABLE.
C
      FPLM = D1MACH(2)
C
      CALL IPRINT(IPRT)
C
      DO 140 I=IFIRST,ILAST
C
C     PRINT DATA SUMMARY.
C
         IF ((SDPVT(I).NE.FPLM) .AND. (SDREST(I).NE.FPLM))
     +      WRITE (IPRT, 1060) I, Y(I), PVT(I), SDPVT(I), RES(I),
     +      SDREST(I)
         IF ((SDPVT(I).NE.FPLM) .AND. (SDREST(I).EQ.FPLM))
     +      WRITE (IPRT, 1050) I, Y(I), PVT(I), SDPVT(I), RES(I)
         IF ((SDPVT(I).EQ.FPLM) .AND. (SDREST(I).EQ.FPLM))
     +      WRITE (IPRT, 1080) I, Y(I), PVT(I), RES(I)
C
  140 CONTINUE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1050 FORMAT (1X, I4, 4E16.8, 4X, 4HNC *, 1X, E9.3)
 1060 FORMAT (1X, I4, 4E16.8, 1X, F7.2, 1X, E9.3)
 1080 FORMAT (1X, I4, 2E16.8, 8X, 4HNC *, 4X, E16.8, 4X, 4HNC *,
     +   1X, E9.3)
      END
*OBSSUM
      SUBROUTINE OBSSUM(N, M, XM, Y, PV, SDPV, RES, SDRES, WT, IXM,
     +   WEIGHT, K, IFIRST, ILAST, JCOL1, JCOLM)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBOUTINE LISTS THE DATA SUMMARY FOR THE
C     LEAST SQUARES SUBROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29,  1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IFIRST,ILAST,IXM,JCOL1,JCOLM,K,M,N
      LOGICAL
     +   WEIGHT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PV(N),RES(N),SDPV(N),SDRES(N),WT(N),XM(IXM,M),Y(N)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,IPRT,J
      CHARACTER
     +   STRING*20,FMT1*160,FMT2*160,FMT3*160
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      LOGICAL
     +   MVCHK
      EXTERNAL D1MACH,MVCHK
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     CHARACTER*160 FMT1,FMT2,FMT3
C        THE FORMATS USED TO PRINT THE INFORMATION.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS HAVE
C        BEEN DETECTED.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED.
C     INTEGER IFIRST, ILAST
C        THE FIRST AND LAST INDICES TO BE LISTED.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER J
C        THE INDEX OF THE PARAMETER BEING EXAMINED.
C     INTEGER JCOLM
C        THE LAST COLUMN OF THE INDEPENDENT VARIABLE TO BE PRINTED.
C     INTEGER JCOL1
C        THE FIRST COLUMN OF THE INDEPENDENT VARIABLE TO BE PRINTED.
C     INTEGER K
C        AN INDEX VARIABLE.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(N)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION SDPV(N)
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(N)
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     CHARACTER*20 STRING
C        CHARACTER STRING USED TO BUILD THE FORMATS.
C     LOGICAL WEIGHT
C        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
C        BE PERFORMED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION WT(N)
C        THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
      FPLM = D1MACH(2)
C
      CALL IPRINT(IPRT)
C
C     CONSTRUCT FORMAT
C
      IF (K.EQ.1) THEN
         STRING = '1X,I4,15X,G15.8,15X,'
      ELSE IF (K.EQ.2) THEN
         STRING = '1X,I4,7X,2G15.8,8X, '
      ELSE
         STRING = '1X,I4,3G15.8,       '
      END IF
      WRITE (FMT1,1020) STRING
      WRITE (FMT2,1030) STRING
      WRITE (FMT3,1040) STRING
C
      DO 140 I=IFIRST, ILAST
         IF (MVCHK(SDPV(I),FPLM)) THEN
            IF (WEIGHT) THEN
               WRITE (IPRT, FMT1) I, (XM(I,J),J=JCOL1,JCOLM),
     +                            Y(I), PV(I), RES(I), WT(I)
            ELSE
               WRITE (IPRT, FMT1) I, (XM(I,J),J=JCOL1,JCOLM),
     +                            Y(I), PV(I), RES(I)
            END IF
         ELSE
            IF (MVCHK(SDRES(I),FPLM)) THEN
               IF (WEIGHT) THEN
                  WRITE (IPRT, FMT2) I, (XM(I,J),J=JCOL1,JCOLM),
     +                               Y(I), PV(I), SDPV(I), RES(I), WT(I)
               ELSE
                  WRITE (IPRT, FMT2) I, (XM(I,J),J=JCOL1,JCOLM),
     +                               Y(I), PV(I), SDPV(I), RES(I)
               END IF
            ELSE
               IF (WEIGHT) THEN
                  WRITE (IPRT, FMT3) I, (XM(I,J),J=JCOL1,JCOLM),
     +                               Y(I), PV(I), SDPV(I), RES(I),
     +                               SDRES(I), WT(I)
               ELSE
                  WRITE (IPRT, FMT3) I, (XM(I,J),J=JCOL1,JCOLM),
     +                               Y(I), PV(I), SDPV(I), RES(I),
     +                               SDRES(I)
               END IF
            END IF
         END IF
  140 CONTINUE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1020 FORMAT ('(',A20,'2G16.8,8X,4HNC *,4X,G16.8,4X,4HNC *,1X,E9.3)')
 1030 FORMAT ('(',A20,'4G16.8,4X,4HNC *,1X,E9.3)')
 1040 FORMAT ('(',A20,'4G16.8,1X,F7.2,1X,E9.3)')
      END
*PARZEN
      SUBROUTINE PARZEN (LAG, W, LW)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE COMPUTES AND STORES THE PARZEN LAG WINDOW
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LAG,LW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   W(LW)
C
C  LOCAL SCALARS
      INTEGER
     +   K,L
C
C  INTRINSIC FUNCTIONS
      INTRINSIC DBLE
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER K
C        AN INDEX VARIABLE
C     INTEGER L
C        THE VALUE LAG/2.
C     INTEGER LAG
C        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
C     INTEGER LW
C        THE LENGTH OF THE VECTOR W.
C     DOUBLE PRECISION W(LW)
C        THE VECTOR OF LAG WINDOWS.
C
      L = LAG/2
      W(1) = 1.0D0
      IF (L.LE.0) GO TO 15
      DO 10 K = 1, L
         W(K+1) = DBLE(K) / DBLE(LAG)
         W(K+1) = 1.0D0 + 6.0D0 * W(K+1) * W(K+1) * (W(K+1) - 1.0D0)
   10 CONTINUE
C
   15 CONTINUE
      L = L + 1
      DO 20 K = L, LAG
         W(K+1) = 1.0D0 - DBLE(K) / DBLE(LAG)
         W(K+1) = 2.0D0 * W(K+1) * W(K+1) * W(K+1)
   20 CONTINUE
C
      RETURN
      END
*PGM
      SUBROUTINE PGM (YFFT, N, LYFFT, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
C     THE (RAW) PERIODOGRAM OF A SERIES (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,LYFFT,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YFFT(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   FREQ,IEXTND,IPRT,LDSMIN,NALL0,NF,NFFT,NPRT,YAXIS
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      CHARACTER
     +   LLDS(8)*1,LLYFFT(8)*1,LN(8)*1,NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,IPRINT,LDSCMP,PGMMN,SETESL,STKCLR,STKSET
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     LOGICAL ERR01, ERR02, ERR03
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     INTEGER FREQ
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
C        INTEGRATED SPECTRUM VALUES ARE STORED.
C     LOGICAL HEAD
C        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
C        ERROR MESSAGES (TRUE) OR NOT (FALSE).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IEXTND
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
C        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
C        USED TO EXTEND THE SERIES.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     CHARACTER*1 LLDS(8), LLYFFT(8), LN(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
C        FOR ERRORS.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS.
C     INTEGER NALL0
C        THE NUMBER OF OUTSTANDING ALLOCATIONS OF THE STACK AT THE
C        TIME OF THIS CALL.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODGRAM IS
C        TO BE COMPUTED.
C     INTEGER NFFT
C        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
C        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
C                         PERIODOGRAM ON A LOG-LINEAR SCALE,
C        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
C                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
C        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
C        IF NPRT .EQ.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
C                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
C        IF NPRT .GE.  2, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
C                         PERIODOGRAM ON A LOG-LINEAR SCALE,
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
C     DOUBLE PRECISION YFFT(LYFFT)
C        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'P',       'G',       'M',       ' ',       ' ',       ' '/
      DATA
     + LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     +  LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA
     + LLYFFT(1), LLYFFT(2), LLYFFT(3), LLYFFT(4), LLYFFT(5),
     +  LLYFFT(6), LLYFFT(7), LLYFFT(8)
     +  /'L','Y','F','F','T',' ',' ',' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /'N',' ',' ',' ',' ',' ',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
      IF (ERR01) GO TO 5
C
C     SET LENGTH OF EXTENDED SERIES
C
      CALL SETESL(N, 2, NFFT)
C
      CALL EISGE(NMSUB, LLYFFT, LYFFT, NFFT, 9, HEAD, ERR02, LLYFFT)
C
      CALL LDSCMP(2, 0, 0, 0, 0, 0, 'D', NFFT, LDSMIN)
C
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 2, HEAD, ERR03, LLDS)
C
      IF (ERR01 .OR. ERR02 .OR. ERR03) GO TO 5
      GO TO 10
C
    5 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   10 CONTINUE
C
C     SET THE SIZE OF THE WORK AREA
C
      CALL STKSET(LDSTAK, 4)
C
C     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
C
      NALL0 = STKST(1)
C
C     SET DEFAULT VALUES
C
      NPRT = -1
      IEXTND = 0
C
C     SUBDIVIDE THE WORK ARRAY
C
      YAXIS = STKGET(NFFT/2, 4)
      FREQ = STKGET(NFFT/2, 4)
      CALL PGMMN (YFFT, N, NFFT, IEXTND, NF, YFFT, LYFFT, RSTAK(YAXIS),
     +   RSTAK(FREQ), NFFT/2, NPRT, NMSUB)
C
      CALL STKCLR(NALL0)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL PGM (YFFT, N, LYFFT, LDSTAK)')
      END
*PGMEST
      SUBROUTINE PGMEST (YFFT, NFFT, NF, CNST, PER, LPER)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE PERIODOGRAM ESTIMATES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CNST
      INTEGER
     +   LPER,NF,NFFT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PER(LPER),YFFT(NFFT)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FAC
      INTEGER
     +   I,ISN,NFFT2
C
C  EXTERNAL SUBROUTINES
      EXTERNAL FFT,REALTR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CNST
C        THE VARIANCE OF THE OBSERVED TIME SERIES TIMES THE NUMBER OF
C        OBSERVATIONS IN THE SERIES IF CALLED BY IPGM,
C        OR 1.0D0 IF CALLED BY PGM.
C     DOUBLE PRECISION FAC
C        A FACTOR USED FOR COMPUTATIONS OF THE INTEGRATED PERIODOGRAM.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER ISN
C        A CODE USED FOR THE FFT.
C     INTEGER LPER
C        THE LENGTH OF THE PERIODOGRAM ARRAY.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
C        COMPUTED.
C     INTEGER NFFT
C        THE EFFECTIVE NUMBER OF OBSERVATIONS FOR THE FFT TRANSFORM.
C     INTEGER NFFT2
C        THE EFFECTIVE NUMBER OF COMPLEX OBSERVATIONS FOR THE FFT
C        TRANSFORM.
C     DOUBLE PRECISION PER(LPER)
C        THE PERIODOGRAM.
C     DOUBLE PRECISION YFFT(NFFT)
C        THE CENTERED SERIES.
C
C     COMPUTE THE FOURIER COEFFICIENTS
C
      NFFT2 = (NFFT-2) / 2
      ISN = 2
C
      CALL FFT (YFFT(1), YFFT(2), NFFT2, NFFT2, NFFT2, ISN)
      CALL REALTR (YFFT(1), YFFT(2), NFFT2, ISN)
C
      FAC = 0.5D0 / (CNST * (NFFT-2))
C
      NF = NFFT2 + 1
C
      DO 10 I = 1, NF
         PER(I) = (YFFT(2*I-1)*YFFT(2*I-1) + YFFT(2*I)*YFFT(2*I)) * FAC
   10 CONTINUE
C
      RETURN
      END
*PGMMN
      SUBROUTINE PGMMN (YFFT, N, NFFT, IEXTND, NF, PER, LPER, YAXIS,
     +   FREQ, LFREQ, NPRT, NMSUB)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS THE MAIN ROUTINE FOR COMPUTING THE RAW PERIODOGRAM.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IEXTND,LFREQ,LPER,N,NF,NFFT,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(LFREQ),PER(LPER),YAXIS(LFREQ),YFFT(NFFT)
      CHARACTER
     +   NMSUB(6)*1
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   YEXTND
      INTEGER
     +   I,N1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN,PGMEST,PGORD,PGOUT,SETFRQ
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION FREQ(LFREQ)
C        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
C        INTEGRATED SPECTRUM VALUES ARE STORED.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IEXTND
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
C        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
C        USED TO EXTEND THE SERIES.
C     INTEGER LFREQ
C        THE LENGTH OF THE ARRAY FREQ.
C     INTEGER LPER
C        THE LENGTH OF THE ARRAY PER.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODGRAM IS
C        TO BE COMPUTED.
C     INTEGER NFFT
C        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE CALLING SUBROUTINE
C     INTEGER NPRT
C        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
C        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
C                         PERIODOGRAM ON A LOG-LINEAR SCALE,
C        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
C                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
C        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
C        IF NPRT .EQ.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
C                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
C        IF NPRT .GE.  2, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
C                         PERIODOGRAM ON A LOG-LINEAR SCALE,
C     DOUBLE PRECISION PER(LPER)
C        THE ARRAY IN WHICH THE PERIODOGRAM IS STORED.
C     DOUBLE PRECISION YAXIS(LFREQ)
C        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
C     DOUBLE PRECISION YEXTND
C        THE VALUE USED TO EXTEND THE SERIES.
C     DOUBLE PRECISION YFFT(NFFT)
C        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C
      YEXTND = 0.0D0
      IF (IEXTND .NE. 0) CALL AMEAN (YFFT, N, YEXTND)
C
C     EXTEND THE PERIODOGRAM ARRAY BY ITS MEAN  OR ZERO TO THE
C     EXTENDED LENGTH NFFT.
C
      N1 = N + 1
C
      DO 40 I = N1, NFFT
         YFFT(I) = YEXTND
   40 CONTINUE
C
C     COMPUTE THE PERIODOGRAM.
C
      CALL PGMEST (YFFT, NFFT, NF, 1.0D0, PER, LPER)
C
C     SET FREQUENCIES FOR PERIODOGRAM VALUES
C
      CALL SETFRQ (FREQ, NF, 1, 0.0D0, 0.5D0, 1.0D0)
C
      IF (NPRT .EQ. 0) RETURN
C
C     SET Y CO-ORDINATES FOR PERIODOGRAM PLOT.
C
      CALL PGORD (PER, NF, YAXIS, NPRT)
C
C     PLOT PERIODOGRAM IF OUTPUT NOT SUPPRESSED
C
      CALL PGOUT (YAXIS, FREQ, NF, NPRT, NMSUB)
C
      RETURN
C
      END
*PGMS
      SUBROUTINE PGMS (YFFT, N, NFFT, LYFFT, IEXTND, NF, PER, LPER,
     +   FREQ, LFREQ, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
C     THE (RAW) PERIODOGRAM OF A SERIES (LONG CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IEXTND,LFREQ,LPER,LYFFT,N,NF,NFFT,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),PER(*),YFFT(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,NFFT2
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,HEAD
C
C  LOCAL ARRAYS
      CHARACTER
     +   LLFREQ(8)*1,LLPER(8)*1,LLYFFT(8)*1,LN(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,ENFFT,IPRINT,PGMMN
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION FREQ(LFREQ)
C        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
C        INTEGRATED SPECTRUM VALUES ARE STORED.
C     LOGICAL HEAD
C        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
C        ERROR MESSAGES (TRUE) OR NOT (FALSE).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IEXTND
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
C        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
C        USED TO EXTEND THE SERIES.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER LFREQ
C        THE LENGTH OF THE ARRAY FREQ.
C     CHARACTER*1 LLFREQ(8), LLPER(8), LLYFFT(8), LN(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
C        FOR ERRORS.
C     INTEGER LPER
C        THE LENGTH OF THE ARRAY PER.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODGRAM IS
C        TO BE COMPUTED.
C     INTEGER NFFT
C        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
C     INTEGER NFFT2
C        THE EFFECTIVE SERIES LENGTH ACTUALLY USED.
C     INTEGER NPRT
C        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
C        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
C                         PERIODOGRAM ON A LOG-LINEAR SCALE,
C        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
C                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
C        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
C        IF NPRT .EQ.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
C                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
C        IF NPRT .GE.  2, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
C                         PERIODOGRAM ON A LOG-LINEAR SCALE,
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     DOUBLE PRECISION PER(LPER)
C        THE ARRAY IN WHICH THE PERIODOGRAM IS STORED.
C     DOUBLE PRECISION YFFT(LYFFT)
C        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'P',       'G',       'M',       'S',       ' ',       ' '/
      DATA
     + LLFREQ(1), LLFREQ(2), LLFREQ(3), LLFREQ(4), LLFREQ(5),
     +  LLFREQ(6), LLFREQ(7), LLFREQ(8)
     +  /'L','F','R','E','Q',' ',' ',' '/
      DATA
     + LLPER(1), LLPER(2), LLPER(3), LLPER(4), LLPER(5),
     +  LLPER(6), LLPER(7), LLPER(8) /'L','P','E','R',' ',' ',' ',' '/
      DATA
     + LLYFFT(1), LLYFFT(2), LLYFFT(3), LLYFFT(4), LLYFFT(5),
     +  LLYFFT(6), LLYFFT(7), LLYFFT(8)
     +  /'L','Y','F','F','T',' ',' ',' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /'N',' ',' ',' ',' ',' ',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
      IF (ERR01) GO TO 5
C
      CALL ENFFT(NMSUB, NFFT, 2, N, LYFFT, NFFT2, HEAD, ERR02)
      NF = NFFT2/2
C
      CALL EISGE(NMSUB, LLYFFT, LYFFT, NFFT2, 9, HEAD, ERR03, LLYFFT)
C
      CALL EISGE(NMSUB, LLPER, LPER, NF, 9, HEAD, ERR04, LLPER)
C
      CALL EISGE(NMSUB, LLFREQ, LFREQ, NF, 9, HEAD, ERR05, LLFREQ)
C
      IF (ERR02 .OR. ERR03 .OR. ERR04 .OR. ERR05) GO TO 5
      GO TO 10
C
    5 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   10 CONTINUE
C
      CALL PGMMN (YFFT, N, NFFT2, IEXTND, NF, PER, LPER, YFFT, FREQ,
     +   LFREQ, NPRT, NMSUB)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL PGMS (YFFT, N, NFFT, LYFFT,'/
     +  '      +           IEXTND, NF, PER, LPER, FREQ, LFREQ, NPRT)')
      END
*PGORD
      SUBROUTINE PGORD (PER, NPTS, YAXIS, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRODUCES CO-ORDINATES FOR THE PERIODOGRAM PLOT.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   NPRT,NPTS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PER(NPTS),YAXIS(NPTS)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  INTRINSIC FUNCTIONS
      INTRINSIC IABS,LOG10
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER NPRT
C        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
C        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
C                         PERIODOGRAM ON A LOG-LINEAR SCALE,
C        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
C                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
C        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
C        IF NPRT .EQ.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
C                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
C        IF NPRT .GE.  2, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
C                         PERIODOGRAM ON A LOG-LINEAR SCALE,
C     INTEGER NPTS
C        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
C        ARE ESTIMATED.
C     DOUBLE PRECISION PER(NPTS)
C        THE ARRAY CONTAINING THE PERIODOGRAM VALUES.
C     DOUBLE PRECISION YAXIS(NPTS)
C        THE Y CO-ORDINATES FOR THE PERIODOGRAM PLOTS.
C
      FPLM = D1MACH(2)
C
C     THE FIRST VALUE SHOULD BE ZERO, SO NO ATTEMPT IS MADE TO PLOT IT.
C
      YAXIS(1) = FPLM
C
      DO 10 I = 2, NPTS
         YAXIS(I) = FPLM
         IF (PER(I) .LE. 0.0D0) GO TO 10
            YAXIS(I) = PER(I)
            IF (IABS(NPRT) .EQ. 1) YAXIS(I) = 10.0D0*LOG10(YAXIS(I))
   10 CONTINUE
C
      RETURN
C
      END
*PGOUT
      SUBROUTINE PGOUT (YAXIS, XAXIS, NPTS, NPRT, NMSUB)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRODUCES THE PERIODOGRAM PLOTS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   NPRT,NPTS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   XAXIS(NPTS),YAXIS(NPTS)
      CHARACTER
     +   NMSUB(6)*1
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM,XMISS,XMN,XMX,YMN,YMX
      INTEGER
     +   ILOG,IPRT
      LOGICAL
     +   ERROR
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMISS(1)
      INTEGER
     +   ISYM(1)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPLMT,PPMN,VERSP,VPLMT,VPMN
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,IABS
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C       AN ERROR FLAG
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER ILOG
C        ...
C     INTEGER IPRT
C        THE LOGICAL UNIT NUMBER FOR THE OUTPUT.
C     INTEGER ISYM(1)
C        A DUMMY ARRAY FOR THE PAGE PLOTS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE CALLING SUBROUTINE.
C     INTEGER NPRT
C        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
C        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
C                         PERIODOGRAM ON A LOG-LINEAR SCALE,
C        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
C                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
C        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
C        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
C                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
C     INTEGER NPTS
C        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
C     DOUBLE PRECISION XAXIS(NPTS)
C        THE X CO-ORDINATES FOR THE PAGE PLOTS.
C     DOUBLE PRECISION XMISS
C        THE VALUE USED TO SPECIFY IF THE PERIODOGRAM VALUE WAS
C        LESS THAN OR EQUAL TO ZERO.
C     DOUBLE PRECISION XMN, XMX
C        ...
C     DOUBLE PRECISION YAXIS(NPTS)
C        THE Y CO-ORDINATES FOR THE SPECTRAL PLOTS.
C     DOUBLE PRECISION YMISS(1)
C        THE VALUE USED TO SPECIFY IF AN PERIODOGRAM VALUE WAS
C        LESS THAN OR EQUAL TO ZERO.
C     DOUBLE PRECISION YMN, YMX
C
C
      FPLM = D1MACH(2)
C
      XMISS = FPLM
      YMISS(1) = FPLM
C
C     SET LOGICAL UNIT NUMBER FOR OUTPUT AND SET OUTPUT WIDTH.
C
      CALL IPRINT (IPRT)
C
      CALL VERSP(.TRUE.)
      IF (IABS(NPRT).EQ.1) THEN
         WRITE (IPRT, 1010)
      ELSE
         WRITE (IPRT, 1000)
      END IF
C
      IF (ABS(NPRT).EQ.1) THEN
        ILOG = 0
      ELSE
        ILOG = 1
      END IF
      IF (NPRT.GE.1) THEN
C
C       PLOT VERTICAL PLOTS
C
        CALL VPLMT(YAXIS, YMISS, NPTS, 1, NPTS, 0.0D0, 0.0D0, YMN, YMX,
     +    ERROR, NMSUB, .TRUE., 1)
        IF (.NOT.ERROR)
     +    CALL VPMN(YAXIS(2), YMISS, NPTS-1, 1, NPTS, 1, 0, ISYM, 1, 0,
     +    YMN, YMX, 0.5D0/(NPTS-1), 0.5D0/(NPTS-1),
     +   .TRUE., ILOG, -1, 0)
      ELSE
C
C       PLOT PAGE PLOTS
C
        CALL PPLMT(YAXIS, YMISS, XAXIS, XMISS, NPTS, 1, NPTS,
     +    0.0D0, 0.0D0, YMN, YMX, 0.0D0, 0.5D0, XMN, XMX,
     +    ERROR, NMSUB, .TRUE.)
        IF (.NOT.ERROR) THEN
          CALL PPMN (YAXIS, YMISS, XAXIS, XMISS, NPTS, 1, NPTS, 0,
     +      ISYM, 1, 0, -1, YMN, YMX, XMN, XMX, .TRUE., ILOG)
          WRITE(IPRT, 1030)
        END IF
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (' SAMPLE PERIODOGRAM')
 1010 FORMAT (' SAMPLE PERIODOGRAM (IN DECIBELS)')
C1020 FORMAT (5H+FREQ/
C    1   7H PERIOD, 9X, 3HINF, 7X, 3H10., 4X, 2H5., 8X, 6H3.3333, 4X,
C    2   3H2.5, 4X, 2H2.)
 1030 FORMAT (5H+FREQ/
     +   7H PERIOD, 9X, 3HINF, 7X, 3H20., 7X, 3H10., 8X, 6H6.6667, 4X,
     +   2H5., 8X, 2H4., 8X, 6H3.3333, 4X, 6H2.8571, 4X, 3H2.5, 7X,
     +   6H2.2222, 4X, 2H2.)
C
      END
*PLINE
      SUBROUTINE PLINE(IMIN, IMAX, ISYMBL, LINE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE DEFINES ONE LINE OF A PLOT STRING FOR THE
C     VERTICAL PLOT ROUTINES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IMAX,IMIN
      CHARACTER
     +   ISYMBL*1
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   LINE(103)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IMAX
C        THE LARGEST LOCATION IN THE PLOT STRING BEING DEFINED.
C     INTEGER IMIN
C        THE SMALLEST LOCATION IN THE PLOT STRING BEING DEFINED.
C     CHARACTER*1 ISYMBL
C        THE PLOTTING SYMBOL BEING USED.
C     CHARACTER*1 LINE(103)
C        THE VECTOR USED FOR THE PLOT STRING.
C
      DO 10 I = IMIN, IMAX
         LINE(I) = ISYMBL
   10 CONTINUE
      RETURN
      END
*PLTCHK
      SUBROUTINE PLTCHK (YM, YMMISS, X, XMISS, N, M, IYM, MULTI,
     +   ILOG, YLB, YUB, XLB, XUB, NMSUB, MISS, XCHECK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS PLOT FAMILY ROUTINE CHECKS FOR ERRORS IN THE PARAMETER LISTS
C     OF THE MULTIPLE PLOT ROUTINES
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   ILOG,IYM,M,N
      LOGICAL
     +   MISS,MULTI,XCHECK
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   NV
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,ERR06,ERR07,ERR08,ERR09,HEAD
C
C  LOCAL ARRAYS
      INTEGER
     +   ILOGXY(2)
      CHARACTER
     +   LIYM(8)*1,LM(8)*1,LN(8)*1,LONE(8)*1,LX(8)*1,LXLB(8)*1,
     +   LXUB(8)*1,LY(8)*1,LYLB(8)*1,LYM(8)*1,LYUB(8)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,ERAGT,ERAGTM,ERSGT,ERVGT,ERVGTM,PRTCNT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05, ERR06, ERR07, ERR08,
C    1   ERR09
C        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IERR
C        THE COMMON VARIABLE USED AS AN ERROR FLAG
C        IF = 0 THEN NO ERORRS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER ILOGXY(2)
C        ...
C     INTEGER IYM
C        ACTUAL ROW DIMENSION OF YM DECLARED IN USERS MAIN PROGRAM
C     CHARACTER*1 LIYM(8), LM(8), LN(8), LONE(8), LX(8), LXLB(8),
C    *  LXUB(8), LY(8), LYLB(8), LYM(8), LYUB(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE INPUT PARAMETERS(S)
C        CHECKED FOR ERRORS.
C     INTEGER M
C        THE NUMBER OF VECTORS IN YM
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        AN INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS AN M PREFIX (TRUE) OR NOT (FALSE).
C     INTEGER N
C        THE LENGTH OF THE VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NV
C        THE NUMBER OF VIOLATIONS FOUND IN THE X AND Y AXIS ARRAYS.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     LOGICAL XCHECK
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER X-AXIS VALUES
C        ARE TO BE CHECKED (XCHECK = .TRUE.) OR NOT (XCHECK = .FALSE.)
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(IYM,M)
C        MULTIVARIATE OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES.
C     DOUBLE PRECISION YMMISS(M)
C        THE MISSING VALUE CODE FOR EACH COLUMN OF YM.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +   LIYM(1),   LIYM(2),   LIYM(3),   LIYM(4),   LIYM(5),   LIYM(6)
     + /     'I',       'Y',       'M',       ' ',       ' ',       ' '/
      DATA LIYM(7), LIYM(8)
     +   /     ' ',     ' '/
      DATA
     +     LM(1),     LM(2),     LM(3),     LM(4),     LM(5),     LM(6)
     + /     'M',       ' ',       ' ',       ' ',       ' ',       ' '/
      DATA   LM(7),   LM(8)
     +   /     ' ',     ' '/
      DATA
     +     LN(1),     LN(2),     LN(3),     LN(4),     LN(5),     LN(6)
     + /     'N',       ' ',       ' ',       ' ',       ' ',       ' '/
      DATA   LN(7),   LN(8)
     +   /     ' ',     ' '/
      DATA   LONE(1),  LONE(2),  LONE(3),  LONE(4),  LONE(5),  LONE(6),
     +       LONE(7),  LONE(8)/'O', 'N', 'E', ' ', ' ', ' ', ' ', ' '/
      DATA
     +     LX(1),     LX(2),     LX(3),     LX(4),     LX(5),     LX(6)
     + /     'X',       ' ',       ' ',       ' ',       ' ',       ' '/
      DATA   LX(7),   LX(8)
     +   /     ' ',     ' '/
      DATA
     +   LXLB(1),   LXLB(2),   LXLB(3),   LXLB(4),   LXLB(5),   LXLB(6)
     + /     'X',       'L',       'B',       ' ',       ' ',       ' '/
      DATA LXLB(7), LXLB(8)
     +   /     ' ',     ' '/
      DATA
     +   LXUB(1),   LXUB(2),   LXUB(3),   LXUB(4),   LXUB(5),   LXUB(6)
     + /     'X',       'U',       'B',       ' ',       ' ',       ' '/
      DATA LXUB(7), LXUB(8)
     +   /     ' ',     ' '/
      DATA
     +     LY(1),     LY(2),     LY(3),     LY(4),     LY(5),     LY(6)
     + /     'Y',       ' ',       ' ',       ' ',       ' ',       ' '/
      DATA   LY(7),   LY(8)
     +   /     ' ',     ' '/
      DATA
     +   LYLB(1),   LYLB(2),   LYLB(3),   LYLB(4),   LYLB(5),   LYLB(6)
     + /     'Y',       'L',       'B',       ' ',       ' ',       ' '/
      DATA LYLB(7), LYLB(8)
     +   /     ' ',     ' '/
      DATA
     +    LYM(1),    LYM(2),    LYM(3),    LYM(4),    LYM(5),    LYM(6)
     + /     'Y',       'M',       ' ',       ' ',       ' ',       ' '/
      DATA  LYM(7),  LYM(8)
     +   /     ' ',     ' '/
      DATA
     +   LYUB(1),   LYUB(2),   LYUB(3),   LYUB(4),   LYUB(5),   LYUB(6)
     + /     'Y',       'U',       'B',       ' ',       ' ',       ' '/
      DATA LYUB(7), LYUB(8)
     +   /     ' ',     ' '/
C
C     COMMENCE BODY OF ROUTINE
C
      IERR = 0
      HEAD = .TRUE.
C
C     NUMBER OF POINTS MUST BE AT LEAST 1
C
      CALL EISGE(NMSUB, LN, N, 1, 2, HEAD, ERR01, LONE)
C
C     THERE MUST BE AT LEAST 1 COLUMN OF VECTORS
C
      CALL EISGE(NMSUB, LM, M, 1, 2, HEAD, ERR02, LONE)
C
C     THE ACTUAL LENGTH OF YM MUST EQUAL OR EXCEED THE NUMBER OF
C     OBSERVATIONS
C
      ERR03 = .TRUE.
      IF (.NOT.ERR01)
     +   CALL EISGE(NMSUB, LIYM, IYM, N, 3, HEAD, ERR03, LN)
C
C     IF THIS IS A LOG PLOT CHECK FOR NON-POSITIVE VALUES IN DATA
C
      IF (ERR01 .OR. ERR02 .OR. ERR03) IERR = 1
      IF (ILOG .LE. 0) RETURN
C
      ERR04 = .FALSE.
      ERR05 = .FALSE.
      ERR06 = .FALSE.
      ERR07 = .FALSE.
      ERR08 = .FALSE.
      ERR09 = .FALSE.
C
      CALL PRTCNT (MAX(0,ILOG),2,ILOGXY)
      IF ((ILOGXY(1).NE.0) .AND. XCHECK) THEN
        IF (.NOT.ERR01) THEN
C
C         IF X AXIS IS LOG SCALE, CHECK FOR NEGATIVE X AXIS VALUES
C
          IF (MISS) THEN
            CALL ERVGTM(NMSUB, LX, X, XMISS, N, 0.0D0, 0, HEAD, 1,
     +        NV, ERR04, LX)
          ELSE
            CALL ERVGT(NMSUB, LX, X, N, 0.0D0, 0, HEAD, 1, NV, ERR04,
     +        LX)
          END IF
        END IF
C
        IF (XLB.LT.XUB) THEN
C
C         CHECK FOR NEGATIVE PLOT BOUNDS
C
          CALL ERSGT(NMSUB, LXLB, XLB, 0.0D0, 1, HEAD, ERR05, LXLB)
          CALL ERSGT(NMSUB, LXUB, XUB, 0.0D0, 1, HEAD, ERR06, LXUB)
        END IF
      END IF
      IF (ILOGXY(2).NE.0) THEN
        IF ((.NOT.ERR01) .AND. (.NOT.ERR02) .AND. (.NOT.ERR03)) THEN
C
C         IF Y AYIS IS LOG SCALE, CHECK FOR NEGATIVE Y AYIS VALUES
C
          IF (MISS) THEN
            IF (MULTI) THEN
              CALL ERAGTM(NMSUB, LYM, YM, YMMISS, N, M, IYM, 0.0D0, 0,
     +           HEAD, 1, NV, ERR04, LYM)
            ELSE
              CALL ERVGTM(NMSUB, LY, YM, YMMISS(1), N, 0.0D0, 0, HEAD,
     +           1, NV, ERR04, LY)
            END IF
          ELSE
            IF (MULTI) THEN
              CALL ERAGT(NMSUB, LYM, YM, N, M, IYM, 0.0D0, 0, HEAD,
     +           1, NV, ERR04, LYM)
            ELSE
              CALL ERVGT(NMSUB, LY, YM, N, 0.0D0, 0, HEAD, 1,
     +           NV, ERR04, LY)
            END IF
          END IF
        END IF
C
        IF (YLB.LT.YUB) THEN
C
C         CHECK FOR NEGATIVE PLOT BOUNDS
C
          CALL ERSGT(NMSUB, LYLB, YLB, 0.0D0, 1, HEAD, ERR05, LYLB)
          CALL ERSGT(NMSUB, LYUB, YUB, 0.0D0, 1, HEAD, ERR06, LYUB)
        END IF
      END IF
C
      IF (ERR04 .OR. ERR05 .OR. ERR06 .OR. ERR07 .OR. ERR08 .OR. ERR09)
     +   IERR = 1
C
      RETURN
C
      END
*PLTPLX
      SUBROUTINE PLTPLX(POINT, YMN, SCALE, IPOINT, IEND)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE POINT LOCATION IN THE PLOT STRING.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   POINT,SCALE,YMN
      INTEGER
     +   IEND,IPOINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IEND
C        THE NUMBER OF LOCATIONS IN THE PLOT STRING.
C     INTEGER IPOINT
C        THE LOCATION IN THE PLOT STRING OF THE VALUE BEING PLOTTED.
C     DOUBLE PRECISION POINT
C        THE VALUE TO BE PLOTTED.
C     DOUBLE PRECISION SCALE
C        THE SCALE INTERVAL OF THE PLOT.
C     DOUBLE PRECISION YMN
C        THE GRAPH AXIS LOWER LIMITS ACTUALLY USED.
C
      IPOINT = (POINT-YMN)/SCALE + 2.5
      IF (IPOINT .LT. 2) IPOINT = 1
      IF (IPOINT .GT. IEND) IPOINT = IEND
      RETURN
      END
*PLTSYM
      SUBROUTINE PLTSYM(IPTSYM, I, J, ISYM, N, IPOINT, LINE, ICOUNT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SUPPLIES THE APPROPRIATE PLOT SYMBOL FOR
C     THE PLOT LINE.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   I,IPOINT,IPTSYM,J,N
C
C  ARRAY ARGUMENTS
      INTEGER
     +   ICOUNT(103),ISYM(N)
      CHARACTER
     +   LINE(103)*1
C
C  LOCAL SCALARS
      INTEGER
     +   ISYMBL
C
C  LOCAL ARRAYS
      CHARACTER
     +   SYM(30)*1,SYM1(10)*1
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER ICOUNT(103)
C        THE NUMBER OF PLOT SYMBOLS AT EACH LOCATION.
C     INTEGER IPOINT
C        THE LOCATION IN THE PLOT STRING OF THE VALUE BEING PLOTTED.
C     INTEGER IPTSYM
C        AN INDICATOR VARIABLE USED TO DESIGNATE THE TYPE
C        OF PLOT.  IF IPTSYM = 1, THE PLOT IS A SYMPLE PAGE
C        OR VERTICAL PLOT.  IF IPTSYM = 2, THE PLOT IS A SYMBOL
C        PLOT.  IF IPTSYM = 3, THE PLOT IS A MULTIVARIATE PLOT.
C     INTEGER ISYM(N)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER ISYMBL
C        THE INDEX OF THE PLOT SYMBOL TO BE USED.
C     INTEGER J
C        AN INDEX VARIABLE.
C     CHARACTER*1 LINE(103)
C        THE VECTOR USED FOR THE PLOT STRING.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 SYM(30), SYM1(10)
C        THE PLOT SYMBOLS.
C
      DATA SYM( 1)/'+'/,SYM( 2)/'.'/,SYM( 3)/'*'/,SYM( 4)/'-'/,
     +     SYM( 5)/'A'/,SYM( 6)/'B'/,SYM( 7)/'C'/,SYM( 8)/'D'/,
     +     SYM( 9)/'E'/,SYM(10)/'F'/,SYM(11)/'G'/,SYM(12)/'H'/,
     +     SYM(13)/'I'/,SYM(14)/'J'/,SYM(15)/'K'/,SYM(16)/'L'/,
     +     SYM(17)/'M'/,SYM(18)/'N'/,SYM(19)/'O'/,SYM(20)/'P'/,
     +     SYM(21)/'Q'/,SYM(22)/'R'/,SYM(23)/'S'/,SYM(24)/'T'/,
     +     SYM(25)/'U'/,SYM(26)/'V'/,SYM(27)/'W'/,SYM(28)/'Y'/,
     +     SYM(29)/'Z'/,SYM(30)/'Z'/
      DATA SYM1(1)/'1'/,SYM1(2)/'2'/,SYM1(3)/'3'/,SYM1(4)/'4'/,
     +     SYM1(5)/'5'/,SYM1(6)/'6'/,SYM1(7)/'7'/,SYM1(8)/'8'/,
     +     SYM1(9)/'9'/,SYM1(10)/'X'/
C
      ICOUNT(IPOINT) = ICOUNT(IPOINT) + 1
      IF (ICOUNT(IPOINT) .EQ. 1) GO TO 5
C
      ISYMBL = MIN(ICOUNT(IPOINT), 10)
      LINE(IPOINT) = SYM1(ISYMBL)
      RETURN
C
    5 CONTINUE
      GO TO (10, 20, 30), IPTSYM
C
   10 LINE(IPOINT) = SYM(1)
      RETURN
C
   20 ISYMBL = MIN(29, MAX(1, ISYM(I)))
      LINE(IPOINT) = SYM(ISYMBL)
      RETURN
C
   30 ISYMBL = MIN(29, MAX(1, J+4))
      LINE(IPOINT) = SYM(ISYMBL)
C
      RETURN
      END
*POLAR
      SUBROUTINE POLAR (AMPL, PHAS, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE CONVERTS THE PAIR OF SERIES AMPL AND PHAS
C     FROM THE REAL AND IMAGINARY PARTS OF A SERIES OF COMPLEX
C     NUMBERS TO THEIR MAGNITUDES AND PHASES.  THE CONVERSION IS
C     DONE IN PLACE.
C
C     WRITTEN BY  -  PETER BLOOMFIELD
C                    FOURIER ANALSERIESSIS OF TIME SERIES- AN
C                       INTRODUCTION
C                    JOHN WILESERIES AND SONS, NEW SERIESORK, 1976
C                    PAGE 150
C     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
C                                 STATISTICAL ENGINEERING DEVISION
C                                 NATIONAL BUREAU OF STANDARDS
C                                 BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AMPL(N),PHAS(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   PHASE,R
      INTEGER
     +   I
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ATAN2,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AMPL(N)
C        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     DOUBLE PRECISION PHAS(N)
C        THE ARRAY IN WHICH THE PRIMARY PHASE ESTIMATES ARE RETURNED.
C     DOUBLE PRECISION PHASE
C        THE PHASE COMPONENT OF THE DEMODULATED SERIES.
C     DOUBLE PRECISION R
C        THE AMPLITUDE COMPONENT OF THE DEMODULATED SERIES.
C
      DO 10 I = 1, N
         R = SQRT(AMPL(I)*AMPL(I) + PHAS(I)*PHAS(I))
         PHASE = 0.0D0
         IF (R .NE. 0.0D0) PHASE = ATAN2(PHAS(I), AMPL(I))
         AMPL(I) = R
         PHAS(I) = PHASE
   10 CONTINUE
      RETURN
      END
*PP
      SUBROUTINE PP(YM, X, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT (SHORT CALL).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   ILOG,IPRT,ISCHCK,ISIZE,IYM,LISYM,M,NOUT
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(N,1)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'P',       'P',       ' ',       ' ',       ' ',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      YMMISS(1) = 1.0D0
      XMISS = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 0
      ISIZE = -1
      NOUT = 0
      MISS = .FALSE.
      LISYM = 1
C
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL PP (Y, X, N)')
      END
*PPC
      SUBROUTINE PPC(YM, X, N, ILOG, ISIZE, NOUT, YLB, YUB, XLB, XUB)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT (LONG CALL).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   ILOG,ISIZE,N,NOUT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   IPRT,ISCHCK,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(N,1)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'P',       'P',       'C',       ' ',       ' ',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      YMMISS(1) = 1.0D0
      XMISS = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      ISCHCK = 0
      MISS = .FALSE.
      LISYM = 1
C
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL PPC (Y, X, N, ILOG,'/
     +   '      +          ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      END
*PPCNT
      SUBROUTINE PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE CONTROLING ROUTINE FOR USER CALLED PAGE PLOT ROUTINES
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   ILOG,ISCHCK,ISIZE,IYM,LISYM,M,N,NOUT
      LOGICAL
     +   MISS,MULTI
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(*)
      INTEGER
     +   ISYM(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XMN,XMX,YMN,YMX
      LOGICAL
     +   ERROR,XCHECK
C
C  EXTERNAL SUBROUTINES
      EXTERNAL PLTCHK,PPLMT,PPMN,VERSP
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        A VALUE INDICATING WHETHER AN ERROR WAS DETECTEC (TRUE)
C        OR NOT (FALSE).
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(LISYM)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING, NOT USED IN SOME CASES
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     LOGICAL XCHECK
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER X-AXIS VALUES
C        ARE TO BE CHECKED (XCHECK = .TRUE.) OR NOT (XCHECK = .FALSE.)
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XMN, XMX
C        THE X-AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(IYM,M)
C        VECTOR OF OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES
C     DOUBLE PRECISION YMMISS(M)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YMN, YMX
C        THE Y-AYIS LOWER AND UPPER LIMITS ACTUALLY USED.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     COMMENCE BODY OF ROUTINE
C
      XCHECK = .TRUE.
      CALL PLTCHK (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +   YLB, YUB, XLB, XUB, NMSUB, MISS, XCHECK)
C
      IF (IERR.EQ.0) THEN
C
C       DETERMINE THE BOUNDS FOR THE X AND Y AXIS AND COMPLETE ERROR
C       CHECKING
C
        CALL PPLMT (YM, YMMISS, X, XMISS, N, M, IYM, YLB, YUB, YMN, YMX,
     +    XLB, XUB, XMN, XMX, ERROR, NMSUB, MISS)
C
        IF (ERROR) THEN
          IERR = 1
        ELSE
C
C       PRINT PLOT
C
        IF (ISIZE.LE.9) THEN
          CALL VERSP(.TRUE.)
        ELSE
          CALL VERSP(.FALSE.)
        END IF
        CALL PPMN (YM, YMMISS, X, XMISS, N, M, IYM, ISCHCK, ISYM,
     +    LISYM, ISIZE, NOUT, YMN, YMX, XMN, XMX, MISS, ILOG)
C
        END IF
      END IF
C
      RETURN
C
      END
*PPFCHS
      DOUBLE PRECISION FUNCTION PPFCHS(P, NU)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS FUNCTION IS A VERSION OF DATAPAC SUBROUTINE CHSPPF, WITH
C     MODIFICATIONS TO FACILITATE CONVERSION TO DOUBLE PRECISION
C     AUTOMATICALLY USING THE NAG, INC., CODE APT, AND TO CORRESPOND
C     TO STARPAC CONVENTIONS.
C
C     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
C              FUNCTION VALUE FOR THE CHI-SQUARED DISTRIBUTION
C              WITH INTEGER DEGREES OF FREEDOM PARAMETER = NU.
C              THE CHI-SQUARED DISTRIBUTION USED
C              HEREIN IS DEFINED FOR ALL NON-NEGATIVE X,
C              AND ITS PROBABILITY DENSITY FUNCTION IS GIVEN
C              IN REFERENCES 2, 3, AND 4 BELOW.
C              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
C              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
C              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
C     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
C                                (BETWEEN 0.0D0 (INCLUSIVELY)
C                                AND 1.0D0 (EXCLUSIVELY))
C                                AT WHICH THE PERCENT POINT
C                                FUNCTION IS TO BE EVALUATED.
C                     --NU     = THE INTEGER NUMBER OF DEGREES
C                                OF FREEDOM.
C                                NU SHOULD BE POSITIVE.
C     OUTPUT ARGUMENTS--PPFCHS = THE SINGLE PRECISION PERCENT
C                                POINT FUNCTION VALUE.
C     OUTPUT--THE SINGLE PRECISION PERCENT POINT FUNCTION .
C             VALUE PPFCHS FOR THE CHI-SQUARED DISTRIBUTION
C             WITH DEGREES OF FREEDOM PARAMETER = NU.
C     PRINTING--DECEMBER 2, 1985  (JRD) UNLESS AN INPUT ARGUMENT ERROR C
C     RESTRICTIONS--NU SHOULD BE A POSITIVE INTEGER VARIABLE.
C                 --P SHOULD BE BETWEEN 0.0D0 (INCLUSIVELY)
C                   AND 1.0D0 (EXCLUSIVELY).
C     OTHER DATAPAC   SUBROUTINES NEEDED--NONE
C     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP, LOG.
C     MODE OF INTERNAL OPERATIONS--DOUBLE PRECISION.
C     LANGUAGE--ANSI FORTRAN.
C     ACCURACY--(ON THE UNIVAC 1108, EXEC 8 SYSTEM AT NBS)
C               COMPARED TO THE KNOWN NU = 2 (EXPONENTIAL)
C               RESULTS, AGREEMENT WAS HAD OUT TO 6 SIGNIFICANT
C               DIGITS FOR ALL TESTED P IN THE RANGE P = .001 TO
C               P = .999.  FOR P = .95 AND SMALLER, THE AGREEMENT
C               WAS EVEN BETTER--7 SIGNIFICANT DIGITS.
C               (NOTE THAT THE TABULATED VALUES GIVEN IN THE WILK,
C               GNANADESIKAN, AND HUYETT REFERENCE BELOW, PAGE 20,
C               ARE IN ERROR FOR AT LEAST THE GAMMA = 1 CASE--
C               THE WORST DETECTED ERROR WAS AGREEMENT TO ONLY 3
C               SIGNIFICANT DIGITS (IN THEIR 8 SIGNIFICANT DIGIT TABLE)
C               FOR P = .999.)
C     REFERENCES--WILK, GNANADESIKAN, AND HUYETT, "PROBABILITY
C                 PLOTS FOR THE GAMMA DISTRIBUTION",
C                 TECHNOMETRICS, 1962, PAGES 1-15,
C                 ESPECIALLY PAGES 3-5.
C               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
C                 SERIES 55, 1964, PAGE 257, FORMULA 6.1.41,
C                 AND PAGES 940-943.
C               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
C                 DISTRIBUTIONS--1, 1970, PAGES 166-206.
C               --HASTINGS AND PEACOCK, STATISTICAL
C                 DISTRIBUTIONS--A HANDBOOK FOR
C                 STUDENTS AND PRACTITIONERS, 1975,
C                 PAGES 46-51.
C     WRITTEN BY--JAMES J. FILLIBEN
C                 STATISTICAL ENGINEERING LABORATORY (205.03)
C                 NATIONAL BUREAU OF STANDARDS
C                 WASHINGTON, D. C. 20234
C                 PHONE  301-921-2315
C     ORIGINAL VERSION--SEPTEMBER 1975.
C     UPDATED         --NOVEMBER  1975.
C
C---------------------------------------------------------------------
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   P
      INTEGER
     +   NU
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   A,AJ,B,C,CUT1,CUT2,CUTOFF,DEN,DX,FP,GAMMA,
     +   PCALC,SUM,TERM,XDEL,XLOWER,XMAX,XMID,XMIN,XMIN0,XUPPER,
     +   Z,Z2,Z3,Z4,Z5
      INTEGER
     +   ICOUNT,ILOOP,IPRT,J,MAXIT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   D(10)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC EXP,LOG
C
C
      DATA C/0.918938533204672741D0/
      DATA D(3),D(4),D(5)
     +  /+0.793650793650793651D-3,
     +   -0.595238095238095238D-3,
     +   +0.8417508417508417151D-3/
      DATA D(6),D(7),D(8),D(9),D(10)
     +  /-0.191752691752691753D-2,
     +   +0.641025641025641025D-2,
     +   -0.2955065359147712418D-1,
     +   +0.179644372368830573D0,
     +   -0.139243221690590111D1/
C
      D(1) = 1.0D0/12.0D0
      D(2) = 1.0D0/360.0D0
C
      CALL IPRINT (IPRT)
C
C     CHECK THE INPUT ARGUMENTS FOR ERRORS
C
      IF (P.LT.0.0D0 .OR. P.GE.1.0D0) THEN
         WRITE(IPRT,1010)
         WRITE(IPRT,1030) P
         PPFCHS = 0.0D0
         RETURN
      END IF
      IF(NU.LT.1) THEN
         WRITE(IPRT,1020)
         WRITE(IPRT,1040) NU
         PPFCHS = 0.0D0
         RETURN
      END IF
C
C-----START POINT-----------------------------------------------------
C
C     EXPRESS THE CHI-SQUARED DISTRIBUTION PERCENT POINT
C     FUNCTION IN TERMS OF THE EQUIVALENT GAMMA
C     DISTRIBUTION PERCENT POINT FUNCTION,
C     AND THEN EVALUATE THE LATTER.
C
      FP = P
      GAMMA = NU/2.0D0
      MAXIT = 10000
C
C     COMPUTE THE GAMMA FUNCTION USING THE ALGORITHM IN THE
C     NBS APPLIED MATHEMATICS SERIES REFERENCE.
C     THIS GAMMA FUNCTION NEED BE CALCULATED ONLY ONCE.
C     IT IS USED IN THE CALCULATION OF THE CDF BASED ON
C     THE TENTATIVE VALUE OF THE PPFCHS IN THE ITERATION.
C
      Z = GAMMA
      DEN = 1.0D0
  150 IF(Z.LT.10.0D0) THEN
         DEN = DEN*Z
         Z = Z+1.0D0
         GO TO 150
      END IF
      Z2 = Z*Z
      Z3 = Z*Z2
      Z4 = Z2*Z2
      Z5 = Z2*Z3
      A = (Z-0.5D0)*LOG(Z)-Z+C
      B = D(1)/Z + D(2)/Z3 + D(3)/Z5 + D(4)/(Z2*Z5) + D(5)/(Z4*Z5) +
     +    D(6)/(Z*Z5*Z5) + D(7)/(Z3*Z5*Z5) + D(8)/(Z5*Z5*Z5) +
     +    D(9)/(Z2*Z5*Z5*Z5)
C     G = EXP(A+B)/DEN
C
C     DETERMINE LOWER AND UPPER LIMITS ON THE DESIRED 100P
C     PERCENT POINT.
C
      ILOOP = 1
C     XMIN0 = (FP*GAMMA*G)**(1.0D0/GAMMA)
      XMIN0 = EXP((1.0D0/GAMMA)*(LOG(FP)+LOG(GAMMA)+(A+B)-LOG(DEN)))
      XMIN = XMIN0
      XLOWER = XMIN
      XMID = XMIN
      XUPPER = XMIN
      ICOUNT = 1
  350 CONTINUE
      XMAX = ICOUNT*XMIN0
      DX = XMAX
      GO TO 600
  360 IF(PCALC.LT.FP) THEN
         XMIN = XMAX
         ICOUNT = ICOUNT+1
         IF(ICOUNT.LE.30000) GO TO 350
      END IF
      XMID = (XMIN+XMAX)/2.0D0
C
C     NOW ITERATE BY BISECTION UNTIL THE DESIRED ACCURACY IS ACHIEVED.
C
      ILOOP = 2
      XLOWER = XMIN
      XUPPER = XMAX
      ICOUNT = 0
  550 DX = XMID
      GO TO 600
  560 IF(PCALC.NE.FP) THEN
         IF(PCALC.GT.FP) THEN
            XUPPER = XMID
            XMID = (XMID+XLOWER)/2.0D0
         ELSE
            XLOWER = XMID
            XMID = (XMID+XUPPER)/2.0D0
         END IF
         XDEL = XMID-XLOWER
         IF(XDEL.LT.0.0D0)XDEL = -XDEL
         ICOUNT = ICOUNT+1
         IF((XDEL.GE.0.0000000001D0) .AND. (ICOUNT.LE.100)) GO TO 550
      END IF
      PPFCHS = 2.0D0*XMID
      RETURN
C
C********************************************************************
C     THIS SECTION BELOW IS LOGICALLY SEPARATE FROM THE ABOVE.
C     THIS SECTION COMPUTES A CDF VALUE FOR ANY GIVEN TENTATIVE
C     PERCENT POINT X VALUE AS DEFINED IN EITHER OF THE 2
C     ITERATION LOOPS IN THE ABOVE CODE.
C
C     COMPUTE T-SUB-Q AS DEFINED ON PAGE 4 OF THE WILK, GNANADESIKAN,
C     AND HUYETT REFERENCE
C
  600 SUM = 1.0D0/GAMMA
      TERM = 1.0D0/GAMMA
      CUT1 = DX-GAMMA
      CUT2 = DX*10000000000.0D0
      DO 700 J=1,MAXIT
         AJ = J
         TERM = DX*TERM/(GAMMA+AJ)
         SUM = SUM+TERM
         CUTOFF = CUT1+(CUT2*TERM/SUM)
         IF (AJ.GT.CUTOFF) GO TO 750
  700 CONTINUE
      WRITE(IPRT,1050)MAXIT
      WRITE(IPRT,1060)P
      WRITE(IPRT,1070)NU
      WRITE(IPRT,1080)
      PPFCHS = 0.0D0
      RETURN
C
  750 CONTINUE
C     PCALC = (DX**GAMMA)*(EXP(-DX))*SUM/G
      PCALC = EXP(GAMMA*LOG(DX) + LOG(SUM) + LOG(DEN) - DX - A - B)
      IF (ILOOP.EQ.1) GO TO 360
      GO TO 560
C
 1010 FORMAT(' ',115H***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE
     + PPFCHS FUNCTION IS OUTSIDE THE ALLOWABLE (0,1  ) INTERVAL *****)
 1020 FORMAT(' ', 91H***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE
     + PPFCHS FUNCTION IS NON-POSITIVE *****  )
 1030 FORMAT(' ', 35H***** THE VALUE OF THE ARGUMENT IS ,E15.8,6H *****)
 1040 FORMAT(' ', 35H***** THE VALUE OF THE ARGUMENT IS ,I8   ,6H *****)
 1050 FORMAT(' ',48H*****ERROR IN INTERNAL OPERATIONS IN THE PPFCHS ,
     + 43HFUNCTION--THE NUMBER OF ITERATIONS EXCEEDS ,I7)
 1060 FORMAT(' ',33H     THE INPUT VALUE OF P     IS ,E15.8)
 1070 FORMAT(' ',33H     THE INPUT VALUE OF NU    IS ,I8)
 1080 FORMAT(52H      THE OUTPUT VALUE OF PPFCHS HAS BEEN SET TO 0.0)
C
      END
*PPFF
      DOUBLE PRECISION FUNCTION PPFF(P, NU1, NU2)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS FUNCTION IS A VERSION OF DATAPLOT SUBROUTINE FPPF,
C     WITH MODIFICATIONS NECESSARY TO CORRESPOND TO STARPAC CONVENTIONS.
C
C     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
C              FOR THE F DISTRIBUTION
C              WITH INTEGER DEGREES OF FREEDOM
C              PARAMETERS = NU1 AND NU2.
C              THIS DISTRIBUTION IS DEFINED FOR ALL NON-NEGATIVE X.
C              THE PROBABILITY DENSITY FUNCTION IS GIVEN
C              IN THE REFERENCES BELOW.
C     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
C                                (BETWEEN 0.0D0 AND 1.0D0)
C                                AT WHICH THE PERCENT POINT
C                                FUNCTION IS TO BE EVALUATED.
C                     --NU1    = THE INTEGER DEGREES OF FREEDOM
C                                FOR THE NUMERATOR OF THE F RATIO.
C                                NU1 SHOULD BE POSITIVE.
C                     --NU2    = THE INTEGER DEGREES OF FREEDOM
C                                FOR THE DENOMINATOR OF THE F RATIO.
C                                NU2 SHOULD BE POSITIVE.
C     OUTPUT ARGUMENTS--PPFF    = THE SINGLE PRECISION PERCENT POINT
C                                FUNCTION VALUE.
C     OUTPUT--THE SINGLE PRECISION PERCENT POINT
C             FUNCTION VALUE PPFF FOR THE F DISTRIBUTION
C             WITH DEGREES OF FREEDOM
C             PARAMETERS = NU1 AND NU2.
C     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
C     RESTRICTIONS--P SHOULD BE BETWEEN
C                   0.0D0 (INCLUSIVELY) AND 1.0D0 (EXCLUSIVELY).
C                 --NU1 SHOULD BE A POSITIVE INTEGER VARIABLE.
C                 --NU2 SHOULD BE A POSITIVE INTEGER VARIABLE.
C     LANGUAGE--ANSI FORTRAN.
C     REFERENCES--NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
C                 SERIES 55, 1964, PAGES 946-947,
C                 FORMULAE 26.6.4, 26.6.5, 26.6.8, AND 26.6.15.
C               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
C                 DISTRIBUTIONS--2, 1970, PAGE 83, FORMULA 20,
C                 AND PAGE 84, THIRD FORMULA.
C               --PAULSON, AN APPROXIMATE NORMAILIZATION
C                 OF THE ANALYSIS OF VARIANCE DISTRIBUTION,
C                 ANNALS OF MATHEMATICAL STATISTICS, 1942,
C                 NUMBER 13, PAGES 233-135.
C               --SCHEFFE AND TUKEY, A FORMULA FOR SAMPLE SIZES
C                 FOR POPULATION TOLERANCE LIMITS, 1944,
C                 NUMBER 15, PAGE 217.
C     WRITTEN BY--JAMES J. FILLIBEN
C                 STATISTICAL ENGINEERING DIVISION
C                 CENTER FOR APPLIED MATHEMATICS
C                 NATIONAL BUREAU OF STANDARDS
C                 WASHINGTON, D. C. 20234
C                 PHONE--301-921-3651
C     NOTE-- THIS ROUTINE WAS ADAPTED FROM DATAPLOT SUBROUTINE
C            FPPF WITH PERMISSION FROM THE AUTHOR.  DATAPLOT IS
C            A REGISTERED TRADEMARK.
C
C           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
C           MODIFIED, OR OTHERWISE USED IN A CONTEXT
C           OUTSIDE OF THIS LANGUAGE/SYSTEM.
C     LANGUAGE--ANSI FORTRAN (1966)
C     VERSION NUMBER--82.3
C     ORIGINAL VERSION--MAY       1978.
C     UPDATED         --AUGUST    1979.
C     UPDATED         --DECEMBER  1981.
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   P
      INTEGER
     +   NU1,NU2
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ANU1,ANU2,EXPF,PCALC,SDF,TOL,X,XDEL,XLOW,XMAX,
     +   XMID,XMIN,XN,XUP,ZN
      INTEGER
     +   IBUG,ICOUNT,IPRT,MAXIT
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFF,PPFNML
      EXTERNAL CDFF,PPFNML
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,EXP,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ANU1
C        THE (DOUBLE PRECISION) DEGREES OF FREEDOM IN THE NUMERATOR.
C     DOUBLE PRECISION ANU2
C        THE (DOUBLE PRECISION) DEGREES OF FREEDOM IN THE DENOMINATOR.
C     DOUBLE PRECISION EXPF
C        *
C     INTEGER IBUG
C        *
C     INTEGER ICOUNT
C        *
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER MAXIT
C        *
C     INTEGER NU1
C        THE DEGREES OF FREEDOM IN THE NUMERATOR.
C     INTEGER  NU2
C        THE DEGREES OF FREEDOM IN THE DENOMINATOR.
C     DOUBLE PRECISION P
C        THE VALUE (BETWEEN 0.0D0 AND 1.0D0) AT WHICH THE PERCENT POINT
C        IS TO BE CALCULATED.
C     DOUBLE PRECISION PCALC
C        *
C     DOUBLE PRECISION SDF
C        *
C     DOUBLE PRECISION TOL
C        *
C     DOUBLE PRECISION X
C        *
C     DOUBLE PRECISION XDEL
C        *
C     DOUBLE PRECISION XLOW
C        *
C     DOUBLE PRECISION XMAX
C        *
C     DOUBLE PRECISION XMID
C        *
C     DOUBLE PRECISION XMIN
C        *
C     DOUBLE PRECISION XN
C        *
C     DOUBLE PRECISION XUP
C        *
C     DOUBLE PRECISION ZN
C        *
C
C---------------------------------------------------------------------
C
C     COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
C     COMMON /PRINT/IFEEDB,IPRINT
C
C-----START POINT-----------------------------------------------------
C
C     CHECK THE INPUT ARGUMENTS FOR ERRORS
C
      CALL IPRINT(IPRT)
C
      PPFF = 0.0D0
      IF (NU1.LE.0) GO TO 10
      IF (NU2.LE.0) GO TO 20
      IF (P.LT.0.0D0 .OR. P.GE.1.0D0) GO TO 30
      GO TO 40
   10 WRITE (IPRT,1010)
      WRITE (IPRT,1040) NU1
      PPFF = 0.0D0
      RETURN
   20 WRITE (IPRT,1020)
      WRITE (IPRT,1040) NU2
      PPFF = 0.0D0
      RETURN
   30 WRITE (IPRT,1000)
      WRITE (IPRT,1030) P
      PPFF = 0.0D0
      RETURN
   40 CONTINUE
C
C-----START POINT-----------------------------------------------------
C
      IBUG = 0.0D0
C
      TOL = 0.000001D0
      MAXIT = 100
      XMIN = 0.0D0
      XMAX = 10.0D30
      XLOW = XMIN
      XUP = XMAX
C
      ANU1 = NU1
      ANU2 = NU2
C
      EXPF = 0.5D0*((1.0D0/ANU2)-(1.0D0/ANU1))
      SDF = SQRT(0.5D0*((1.0D0/ANU2)+(1.0D0/ANU1)))
      ZN = PPFNML(P)
      XN = EXPF + ZN*SDF
      XMID = EXP(2.0D0*XN)
      IF (IBUG.EQ.1) WRITE (IPRT,1050) XMID
C
      IF (P.EQ.0.0D0) GO TO 50
      GO TO 60
   50 CONTINUE
      PPFF = XMIN
      RETURN
   60 CONTINUE
C
      ICOUNT = 0
C
   70 CONTINUE
      X = XMID
      PCALC = CDFF(X,ANU1,ANU2)
      IF (PCALC.EQ.P) GO TO 130
      IF (PCALC.GT.P) GO TO 100
C
   80 CONTINUE
      XLOW = XMID
      X = XMID*2.0D0
      IF (X.GE.XUP) GO TO 90
      XMID = X
      IF (IBUG.EQ.1) WRITE (IPRT,1050) XMID
      PCALC = CDFF(X,ANU1,ANU2)
      IF (PCALC.EQ.P) GO TO 130
      IF (PCALC.LT.P) GO TO 80
      XUP = X
   90 CONTINUE
      XMID = (XLOW+XUP)/2.0D0
      IF (IBUG.EQ.1) WRITE (IPRT,1050) XMID
      GO TO 120
C
  100 CONTINUE
      XUP = XMID
      X = XMID/2.0D0
      IF (X.LE.XLOW) GO TO 110
      XMID = X
      IF (IBUG.EQ.1) WRITE (IPRT,1050) XMID
      PCALC = CDFF(X,ANU1,ANU2)
      IF (PCALC.EQ.P) GO TO 130
      IF (PCALC.GT.P) GO TO 100
      XLOW = X
  110 CONTINUE
      XMID = (XLOW+XUP)/2.0D0
      IF (IBUG.EQ.1) WRITE (IPRT,1050) XMID
C
  120 CONTINUE
      XDEL = ABS(XMID-XLOW)
      ICOUNT = ICOUNT + 1
      IF (XDEL.LT.TOL .OR. ICOUNT.GT.MAXIT) GO TO 130
      GO TO 70
C
  130 CONTINUE
      PPFF = XMID
C
      RETURN
 1000 FORMAT (' ', 49H***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO T,
     +   59HHE FPPF SUBROUTINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL ,
     +   5H*****)
 1010 FORMAT (' ', 49H***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO T,
     +   42HHE FPPF   SUBROUTINE IS NON-POSITIVE *****)
 1020 FORMAT (' ', 49H***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO T,
     +   42HHE FCDF   SUBROUTINE IS NON-POSITIVE *****)
 1030 FORMAT (' ', 35H***** THE VALUE OF THE ARGUMENT IS , E15.8,
     +   6H *****)
 1040 FORMAT (' ', 35H***** THE VALUE OF THE ARGUMENT IS , I8, 6H *****)
 1050 FORMAT (' ', 7HXMID = , E15.7)
      END
*PPFNML
      DOUBLE PRECISION FUNCTION PPFNML(P)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS FUNCTION IS A VERSION OF DATAPAC SUBROUTINE
C     NORPPF, WITH MODIFICATIONS TO FACILITATE CONVERSION TO
C     DOUBLE PRECISION AUTOMATICALLY USING THE NAG, INC. CODE APT, AND
C     TO CORRESPOND TO STARPAC CONVENTIONS.
C
C     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
C              FUNCTION VALUE FOR THE NORMAL (GAUSSIAN)
C              DISTRIBUTION WITH MEAN = 0 AND STANDARD DEVIATION = 1.
C              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
C              THE PROBABILITY DENSITY FUNCTION
C              F(X) = (1/SQRT(2*PI))*EXP(-X*X/2).
C              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
C              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
C              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
C     ERROR CHECKING--NONE
C     RESTRICTIONS--P SHOULD BE BETWEEN 0.0D0 AND 1.0D0, EXCLUSIVELY.
C     REFERENCES--ODEH AND EVANS, THE PERCENTAGE POINTS
C                 OF THE NORMAL DISTRIBUTION, ALGORTIHM 70,
C                 APPLIED STATISTICS, 1974, PAGES 96-97.
C               --EVANS, ALGORITHMS FOR MINIMAL DEGREE
C                 POLYNOMIAL AND RATIONAL APPROXIMATION,
C                 M. SC. THESIS, 1972, UNIVERSITY
C                 OF VICTORIA, B. C., CANADA.
C               --HASTINGS, APPROXIMATIONS FOR DIGITAL
C                 COMPUTERS, 1955, PAGES 113, 191, 192.
C               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
C                 SERIES 55, 1964, PAGE 933, FORMULA 26.2.23.
C               --FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
C                 OF THE LOCATION PARAMETER OF A SYMMETRIC
C                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
C                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231.
C               --FILLIBEN, "THE PERCENT POINT FUNCTION",
C                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
C               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
C                 DISTRIBUTIONS--1, 1970, PAGES 40-111.
C               --THE KELLEY STATISTICAL TABLES, 1948.
C               --OWEN, HANDBOOK OF STATISTICAL TABLES,
C                 1962, PAGES 3-16.
C               --PEARSON AND HARTLEY, BIOMETRIKA TABLES
C                 FOR STATISTICIANS, VOLUME 1, 1954,
C                 PAGES 104-113.
C     COMMENTS--THE CODING AS PRESENTED BELOW
C               IS ESSENTIALLY IDENTICAL TO THAT
C               PRESENTED BY ODEH AND EVANS
C               AS ALGORTIHM 70 OF APPLIED STATISTICS.
C               THE PRESENT AUTHOR HAS MODIFIED THE
C               ORIGINAL ODEH AND EVANS CODE WITH ONLY
C               MINOR STYLISTIC CHANGES.
C             --AS POINTED OUT BY ODEH AND EVANS
C               IN APPLIED STATISTICS,
C               THEIR ALGORITHM REPRESENTES A
C               SUBSTANTIAL IMPROVEMENT OVER THE
C               PREVIOUSLY EMPLOYED
C               HASTINGS APPROXIMATION FOR THE
C               NORMAL PERCENT POINT FUNCTION--
C               THE ACCURACY OF APPROXIMATION
C               BEING IMPROVED FROM 4.5*(10**-4)
C               TO 1.5*(10**-8).
C
C     WRITTEN BY--JAMES J. FILLIBEN
C                 STATISTICAL ENGINEERING LABORATORY
C                 NATIONAL BUREAU OF STANDARDS
C                 WASHINGTON, D. C. 20234
C     ORIGINAL VERSION--JUNE      1972.
C     UPDATED         --SEPTEMBER 1975.
C     UPDATED         --NOVEMBER  1975.
C     UPDATED         --OCTOBER   1976.
C
C     MODIFIED BY     --JANET R. DONALDSON, DECEMBER 7, 1981
C                       STATISTICAL ENGINEERING DIVISION
C                       NATIONAL BUREAU OF STANDARDS, BOULDER, COLORDAO
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   P
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ADEN,ANUM,P0,P1,P2,P3,P4,Q0,Q1,Q2,Q3,Q4,R,T
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ADEN, ANUM
C        *
C     DOUBLE PRECISION P
C        THE PROBABILITY AT WHICH THE PERCENT POINT IS TO BE EVALUATED
C     DOUBLE PRECISION P0, P1, P2, P3, P4
C        VARIOUS PARAMETERS USED IN THE APPROXIMATIONS.
C     DOUBLE PRECISION Q0, Q1, Q2, Q3, Q4
C        VARIOUS ADDITIONAL PARAMETERS USED IN THE APPROXIMATIONS.
C     DOUBLE PRECISION R
C        *
C     DOUBLE PRECISION T
C        *
C
      DATA P0, P1, P2, P3, P4
     +  /-.322232431088D0, -1.0D0, -.342242088547D0,
     +   -.204231210245D-1,-.453642210148D-4/
      DATA Q0, Q1, Q2, Q3, Q4
     +  /.993484626060D-1, .588581570495D0,
     +   .531103462366D0, .103537752850D0, .38560700634D-2/
C
C
      IF (P.NE.0.5D0) GO TO 30
      PPFNML = 0.0D0
      RETURN
C
   30 R = P
      IF (P.GT.0.5D0) R = 1.0D0 - R
      T = SQRT(-2.0D0*LOG(R))
      ANUM = ((((T*P4+P3)*T+P2)*T+P1)*T+P0)
      ADEN = ((((T*Q4+Q3)*T+Q2)*T+Q1)*T+Q0)
      PPFNML = T + (ANUM/ADEN)
C
      IF (P.LT.0.5D0) PPFNML = -PPFNML
C
      RETURN
C
      END
*PPFT
      DOUBLE PRECISION FUNCTION PPFT(P, IDF)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS FUNCTION IS A VERSION OF DATAPAC SUBROUTINE
C     TPPF, WITH MODIFICATIONS TO FACILITATE CONVERSION TO
C     DOUBLE PRECISION AUTOMATICALLY USING THE NAG, INC. CODE APT,
C     AND TO CORRESPOND TO STARPAC CONVENTIONS.
C
C     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
C              FUNCTION VALUE FOR THE STUDENT"S T DISTRIBUTION
C              WITH INTEGER DEGREES OF FREEDOM PARAMETER = IDF.
C              THE STUDENT"S T DISTRIBUTION USED
C              HEREIN IS DEFINED FOR ALL X,
C              AND ITS PROBABILITY DENSITY FUNCTION IS GIVEN
C              IN THE REFERENCES BELOW.
C              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
C              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
C              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
C     ERROR CHECKING--NONE
C     RESTRICTIONS--IDF SHOULD BE A POSITIVE INTEGER VARIABLE.
C                 --P SHOULD BE BETWEEN 0.0D0 (EXCLUSIVELY)
C                   AND 1.0D0 (EXCLUSIVELY).
C     COMMENT--FOR IDF = 1 AND IDF = 2, THE PERCENT POINT FUNCTION
C              FOR THE T DISTRIBUTION EXISTS IN SIMPLE CLOSED FORM
C              AND SO THE COMPUTED PERCENT POINTS ARE EXACT.
C            --FOR OTHER SMALL VALUES OF IDF (IDF BETWEEN 3 AND 6,
C              INCLUSIVELY), THE APPROXIMATION
C              OF THE T PERCENT POINT BY THE FORMULA
C              GIVEN IN THE REFERENCE BELOW IS AUGMENTED
C              BY 3 ITERATIONS OF NEWTON"S METHOD FOR
C              ROOT DETERMINATION.
C              THIS IMPROVES THE ACCURACY--ESPECIALLY FOR
C              VALUES OF P NEAR 0 OR 1.
C     REFERENCES--NATIONAL BUREAU OF STANDARDS APPLIED MATHMATICS
C                 SERIES 55, 1964, PAGE 949, FORMULA 26.7.5.
C               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
C                 DISTRIBUTIONS--2, 1970, PAGE 102,
C                 FORMULA 11.
C               --FEDERIGHI, "EXTENDED TABLES OF THE
C                 PERCENTAGE POINTS OF STUDENT"S T
C                 DISTRIBUTION, JOURNAL OF THE
C                 AMERICAN STATISTICAL ASSOCIATION,
C                 1969, PAGES 683-688.
C               --HASTINGS AND PEACOCK, STATISTICAL
C                 DISTRIBUTIONS--A HANDBOOK FOR
C                 STUDENTS AND PRACTITIONERS, 1975,
C                 PAGES 120-123.
C     WRITTEN BY--JAMES J. FILLIBEN
C                 STATISTICAL ENGINEERING DIVISION
C                 NATIONAL BUREAU OF STANDARDS
C                 WASHINGTON, D. C. 20234
C     ORIGINAL VERSION--OCTOBER   1975.
C     UPDATED         --NOVEMBER  1975.
C
C     MODIFIED BY     --JANET R. DONALDSON, DECEMBER 7, 1981
C                       STATISTICAL ENGINEERING DIVISION
C                       NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   P
      INTEGER
     +   IDF
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ARG,B21,B31,B32,B33,B34,B41,B42,B43,B44,B45,
     +   B51,B52,B53,B54,B55,B56,C,CON,D1,D3,D5,D7,D9,DF,PI,PPFN,
     +   S,SQRT2,TERM1,TERM2,TERM3,TERM4,TERM5,Z
      INTEGER
     +   IPASS,MAXIT
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   PPFNML
      EXTERNAL PPFNML
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ATAN,COS,SIN,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ARG
C        *
C     DOUBLE PRECISION B21
C        *
C     DOUBLE PRECISION B31, B32, B33, B34
C        *
C     DOUBLE PRECISION B41, B42, B43, B44, B45
C        *
C     DOUBLE PRECISION B51, B52, B53, B54, B55, B56
C        *
C     DOUBLE PRECISION C, CON
C        *
C     DOUBLE PRECISION DF
C        THE DEGREES OF FREEDOM.
C     DOUBLE PRECISION D1, D3, D5, D7, D9
C        *
C     INTEGER IDF
C        THE (INTEGER) DEGREES OF FREEDOM.
C     INTEGER IPASS
C        *
C     INTEGER MAXIT
C        *
C     DOUBLE PRECISION P
C        THE PROBABILITY AT WHICH THE PERCENT POINT IS TO BE EVALUATED.
C     DOUBLE PRECISION PI
C        THE VALUE OF PI.
C     DOUBLE PRECISION PPFN
C        THE NORMAL PERCENT POINT VALUE.
C     DOUBLE PRECISION S
C        *
C     DOUBLE PRECISION SQRT2
C        THE SQUARE ROOT OF TWO.
C        *
C     DOUBLE PRECISION TERM1, TERM2, TERM3, TERM4, TERM5
C        *
C     DOUBLE PRECISION Z
C        *
C
C     DEFINE CONSTANTS USED IN THE APPROXIMATIONS
C
      DATA B21 /4.0D0/
      DATA B31, B32, B33, B34 /96.0D0, 5.0D0, 16.0D0, 3.0D0/
      DATA B41, B42, B43, B44, B45
     +  /384.0D0, 3.0D0, 19.0D0, 17.0D0, -15.0D0/
      DATA B51, B52, B53, B54, B55, B56
     +   /9216.0D0, 79.0D0, 776.0D0, 1482.0D0,
     +   -1920.0D0, -945.0D0/
C
      CALL GETPI(PI)
C
      SQRT2 = SQRT(2.0D0)
C
      DF = IDF
      MAXIT = 5
C
      IF (IDF.GE.3) GO TO 50
      IF (IDF.EQ.1) GO TO 30
      IF (IDF.EQ.2) GO TO 40
      PPFT = 0.0D0
      RETURN
C
C     TREAT THE IDF = 1 (CAUCHY) CASE
C
   30 ARG = PI*P
      PPFT = -COS(ARG)/SIN(ARG)
      RETURN
C
C     TREAT THE IDF = 2 CASE
C
   40 TERM1 = SQRT2/2.0D0
      TERM2 = 2.0D0*P - 1.0D0
      TERM3 = SQRT(P*(1.0D0-P))
      PPFT = TERM1*TERM2/TERM3
      RETURN
C
C     TREAT THE IDF GREATER THAN OR EQUAL TO 3 CASE
C
   50 PPFN = PPFNML(P)
      D1 = PPFN
      D3 = PPFN**3
      D5 = PPFN**5
      D7 = PPFN**7
      D9 = PPFN**9
      TERM1 = D1
      TERM2 = (1.0D0/B21)*(D3+D1)/DF
      TERM3 = (1.0D0/B31)*(B32*D5+B33*D3+B34*D1)/(DF**2)
      TERM4 = (1.0D0/B41)*(B42*D7+B43*D5+B44*D3+B45*D1)/(DF**3)
      TERM5 = (1.0D0/B51)*(B52*D9+B53*D7+B54*D5+B55*D3+B56*D1)/(DF**4)
      PPFT = TERM1 + TERM2 + TERM3 + TERM4 + TERM5
      IF (IDF.GE.7) RETURN
      IF (IDF.EQ.3) GO TO 60
      IF (IDF.EQ.4) GO TO 80
      IF (IDF.EQ.5) GO TO 100
      IF (IDF.EQ.6) GO TO 120
      RETURN
C
C     AUGMENT THE RESULTS FOR THE IDF = 3 CASE
C
   60 CON = PI*(P-0.5D0)
      ARG = PPFT/SQRT(DF)
      Z = ATAN(ARG)
      DO 70 IPASS=1,MAXIT
         S = SIN(Z)
         C = COS(Z)
         Z = Z - (Z+S*C-CON)/(2.0D0*C*C)
   70 CONTINUE
      PPFT = SQRT(DF)*S/C
      RETURN
C
C     AUGMENT THE RESULTS FOR THE IDF = 4 CASE
C
   80 CON = 2.0D0*(P-0.5D0)
      ARG = PPFT/SQRT(DF)
      Z = ATAN(ARG)
      DO 90 IPASS=1,MAXIT
         S = SIN(Z)
         C = COS(Z)
         Z = Z - ((1.0D0+0.5D0*C*C)*S-CON)/(1.5D0*C*C*C)
   90 CONTINUE
      PPFT = SQRT(DF)*S/C
      RETURN
C
C     AUGMENT THE RESULTS FOR THE IDF = 5 CASE
C
  100 CON = PI*(P-0.5D0)
      ARG = PPFT/SQRT(DF)
      Z = ATAN(ARG)
      DO 110 IPASS=1,MAXIT
         S = SIN(Z)
         C = COS(Z)
         Z = Z - (Z+(C+(2.0D0/3.0D0)*C*C*C)*S-CON)/((8.0D0/3.0D0)*C**4)
  110 CONTINUE
      PPFT = SQRT(DF)*S/C
      RETURN
C
C     AUGMENT THE RESULTS FOR THE IDF = 6 CASE
C
  120 CON = 2.0D0*(P-0.5D0)
      ARG = PPFT/SQRT(DF)
      Z = ATAN(ARG)
      DO 130 IPASS=1,MAXIT
         S = SIN(Z)
         C = COS(Z)
         Z = Z - ((1.0D0+0.5D0*C*C+0.375D0*C**4)*S-CON)/
     +           ((15.0D0/8.0D0)*C**5)
  130 CONTINUE
      PPFT = SQRT(DF)*S/C
      RETURN
C
      END
*PPL
      SUBROUTINE PPL(YM, X, N, ILOG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT (LOG OPTION).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   IPRT,ISCHCK,ISIZE,IYM,LISYM,M,NOUT
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(N,1)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'P',       'P',       'L',       ' ',       ' ',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      YMMISS(1) = 1.0D0
      XMISS = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 0
      ISIZE = -1
      NOUT = 0
      MISS = .FALSE.
      LISYM = 1
C
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL PPL (Y, X, N, ILOG)')
      END
*PPLMT
      SUBROUTINE PPLMT (YM, YMMISS, X, XMISS, N, M, IYM, YLB, YUB, YMN,
     +  YMX, XLB, XUB, XMN, XMX, ERROR, NMSUB, MISS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SETS THE PLOT LIMITS FOR PAGE PLOTS
C     WITH MISSING VALUES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XMISS,XMN,XMX,XUB,YLB,YMN,YMX,YUB
      INTEGER
     +   IYM,M,N
      LOGICAL
     +   ERROR,MISS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N),YM(IYM,M),YMMISS(M)
      CHARACTER
     +   NMSUB(6)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,II,IPRT,J
      LOGICAL
     +   HEAD,SETLMT,SKPROW
C
C  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ADJLMT,EHDR,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        A VALUE INDICATING WHETHER AN ERROR WAS DETECTED (TRUE)
C        OR NOT (FALSE).
C     LOGICAL HEAD
C        PRINT HEADING (HEAD=TRUE) OR NOT (HEAD=FALSE).
C     INTEGER I, II
C        INDEXING VARIABLES.
C     INTEGER IPRT
C        ...
C     INTEGER IYM
C        ACTUAL ROW DIMENSION OF YM DECLARED IN THE USERS MAIN PROGRAM
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER M
C        THE NUMBER OF VECTORS IN YM
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS .
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     LOGICAL SETLMT
C        AN INDICATOR VARIABLE USED TO DETERMINE IF STARTING VALUES
C        FOR XMN, XMX, YMN, YMX HAVE BEEN FOUND.
C     LOGICAL SKPROW
C        AN INDICATOR VARIABLE USED TO DESIGNATE WHETHER ALL
C        OBSERVATIONS IN A GIVEN ROW OF YM ARE UNUSED (TRUE)
C        OR NOT (FALSE).
C     DOUBLE PRECISION X(N)
C        THE ARRAY CONTAINING THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION XLB
C        THE USER SUPPLIED X-AXIS LOWER BOUND.
C     DOUBLE PRECISION XMISS
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
C        NOT AN OBSERVATION IS MISSING.
C        IF X(I) = XMISS, THE VALUE IS ASSUMED MISSING, OTHERWISE
C        IT IS NOT.
C     DOUBLE PRECISION XMN, XMX
C        THE X-AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
C     DOUBLE PRECISION XUB
C        THE USER SUPPLIED X-AXIS UPPER BOUNDS.
C     DOUBLE PRECISION YLB
C        THE USER SUPPLIED Y-AXIS LOWER BOUND.
C     DOUBLE PRECISION YM(IYM,M)
C        THE ARRAY CONTAINING THE DEPENDENT VARIABLE(S).
C     DOUBLE PRECISION YMMISS(M)
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
C        NOT AN OBSERVATION IS MISSING.
C        IF YM(I,J) = YMMISS(J), THE VALUE IS ASSUMED MISSING, OTHERWISE
C        IT IS NOT.
C     DOUBLE PRECISION YMN, YMX
C        THE Y-AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
C     DOUBLE PRECISION YUB
C        THE USER SUPPLIED Y-AXIS UPPER BOUNDS.
C
      ERROR = .FALSE.
C
      IF ((XLB .LT. XUB) .AND. (YLB .LT. YUB)) THEN
C
C       SET LIMITS TO USER SPECIFIED VALUES
C
        XMN = XLB
        XMX = XUB
        YMN = YLB
        YMX = YUB
C
      ELSE
C
C       SET LIMITS TO RANGE OF VALUES WITHIN ANY USER SPECIFIED VALUES
C
        SETLMT = .FALSE.
        II = 1
C
C       FIND FIRST VALUE TO BE PLOTTED
C
        DO 20 I=1,N
           IF (MISS .AND. MVCHK(X(I),XMISS)) GO TO 20
           IF ((XLB.LT.XUB) .AND. ((X(I).LT.XLB) .OR.
     +        (XUB.LT.X(I)))) GO TO 20
           XMN = X(I)
           XMX = X(I)
           DO 10 J=1,M
              IF (MISS .AND. MVCHK(YM(I,J),YMMISS(J))) GO TO 10
              IF ((YLB.LT.YUB) .AND. ((YM(I,J).LT.YLB) .OR.
     +           (YUB.LT.YM(I,J)))) GO TO 10
              IF (SETLMT) GO TO 5
              YMN = YM(I,J)
              YMX = YM(I,J)
              SETLMT = .TRUE.
              II = I + 1
              GO TO 10
    5         YMN = MIN(YMN, YM(I,J))
              YMX = MAX(YMX, YM(I,J))
   10      CONTINUE
           IF (SETLMT) GO TO 30
   20   CONTINUE
C
   30   IF (II.LE.1) THEN
C
C         NO VALUES TO BE PLOTTED.  PRINT ERROR MESSAGE
C
          ERROR = .TRUE.
          CALL IPRINT(IPRT)
          HEAD = .TRUE.
          CALL EHDR(NMSUB,HEAD)
          IF ((YLB.GE.YUB) .AND. (XLB.GE.XUB)) THEN
            WRITE (IPRT, 1010)
          ELSE
            WRITE (IPRT, 1020)
          END IF
          WRITE (IPRT, 1030)
C
        ELSE
C
C         FIND LIMITS FROM REMAINING VALUES
C
          IF (II.LE.N) THEN
            DO 50 I=II,N
               IF (MISS .AND. MVCHK(X(I),XMISS)) GO TO 50
               IF ((XLB.LT.XUB) .AND. ((X(I).LT.XLB) .OR.
     +            (XUB.LT.X(I)))) GO TO 50
               SKPROW = .TRUE.
               DO 40 J=1,M
                  IF (MISS .AND. MVCHK(YM(I,J),YMMISS(J))) GO TO 40
                  IF ((YLB.LT.YUB) .AND. ((YM(I,J).LT.YLB) .OR.
     +               (YUB.LT.YM(I,J)))) GO TO 40
                  SKPROW = .FALSE.
                  YMN = MIN(YMN, YM(I,J))
                  YMX = MAX(YMX, YM(I,J))
   40          CONTINUE
               IF (SKPROW) GO TO 50
               XMN = MIN(XMN, X(I))
               XMX = MAX(XMX, X(I))
   50       CONTINUE
          END IF
        END IF
C
        IF (YLB.LT.YUB) THEN
C
C       SET Y AXIS LIMITS TO USER SUPPLIED VALUES
C
          YMN = YLB
          YMX = YUB
        ELSE
C
C       ADJUST Y AXIS LIMITS IF EQUAL
C
          IF (YMN .GE. YMX) CALL ADJLMT(YMN, YMX)
        END IF
C
        IF (XLB.LT.XUB) THEN
C
C       SET X AXIS LIMITS TO USER SUPPLIED VALUES
C
          XMN = XLB
          XMX = XUB
        ELSE
C
C         ADJUST X AXIS LIMITS IF EQUAL
C
          IF (XMN .GE. XMX) CALL ADJLMT(XMN, XMX)
C
        END IF
C
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1010 FORMAT (/
     +   44H NO NON-MISSING PLOT COORDINATES WERE FOUND.)
 1020 FORMAT (/
     +   40H NO NON-MISSING VALUES WERE FOUND WITHIN,
     +   26H THE USER SUPPLIED LIMITS.)
 1030 FORMAT (/
     +   30H THE PLOT HAS BEEN SUPPRESSED.)
      END
*PPM
      SUBROUTINE PPM(YM, YMMISS, X, XMISS, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT FOR DATA WITH MISSING OBSERVATIONS (SHORT CALL).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(1)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   ILOG,IPRT,ISCHCK,ISIZE,IYM,LISYM,M,NOUT
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(N,1)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'P',       'P',       'M',       ' ',       ' ',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      M = 1
      IYM = N
      MULTI = .FALSE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 0
      ISIZE = -1
      NOUT = 0
      MISS = .TRUE.
      LISYM = 1
C
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL PPM (Y, YMISS, X, XMISS, N)')
      END
*PPMC
      SUBROUTINE PPMC(YM, YMMISS, X, XMISS, N, ILOG, ISIZE, NOUT, YLB,
     +   YUB, XLB, XUB)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT FOR DATA WITH MISSING OBSERVATIONS (LONG CALL).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   ILOG,ISIZE,N,NOUT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(1)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,ISCHCK,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(N,1)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'P',       'P',       'M',       'C',       ' ',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      M = 1
      IYM = N
      MULTI = .FALSE.
      ISCHCK = 0
      MISS = .TRUE.
      LISYM = 1
C
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL PPMC (Y, YMISS, X, XMISS, N, ILOG,'/
     +   '      +           ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      END
*PPML
      SUBROUTINE PPML(YM, YMMISS, X, XMISS, N, ILOG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT FOR DATA WITH MISSING OBSERVATIONS (LOG OPTION).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   ILOG,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(1)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   IPRT,ISCHCK,ISIZE,IYM,LISYM,M,NOUT
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(N,1)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'P',       'P',       'M',       'L',       ' ',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      M = 1
      IYM = N
      MULTI = .FALSE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 0
      ISIZE = -1
      NOUT = 0
      MISS = .TRUE.
      LISYM = 1
C
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL PPML (Y, YMISS, X, XMISS, N, ILOG)')
      END
*PPMN
      SUBROUTINE PPMN (YM, YMMISS, X, XMISS, N, M, IYM, ISCHCK, ISYM,
     +  LISYM, ISIZE, NOUT, YMN, YMX, XMN, XMX, MISS, ILOG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN ROUTINE FOR PAGE PLOTS
C
C     WRITTEN BY  --
C                 JANET R. DONALDSON
C                 STATISTICAL ENGINEERING DIVISION/BOULDER
C                 NATIONAL BUREAU OF STANDARDS
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C     INPUT ARGUMENTS - (IN ORDER OF USAGE)
C
C        X  THE N VECTOR OF OBSERVATIONS FOR THE X
C           COORDINATES
C        Y  THE N BY M MATRIX OF OBSERVATIONS FOR THE Y (VERTICAL)
C           COORDINATES
C           THE ITH COLUMN IS PLOTTED USING THE FOLLOWING SYMBOL
C               1 = A    2 = B    3 = C    4 = D
C               5 = E    6 = F    7 = G    8 = H
C               9 = I   10 = J   11 = K   12 = L
C              13 = M   14 = N   15 = O   16 = P
C              17 = Q   18 = R   19 = S   20 = T
C              21 = U   22 = V   23 = W   24 = Y
C              25 (AND ABOVE) = Z
C           THE NUMBERS 1 TO 9 INDICATE MULTIPLE POINTS ON A GIVEN
C           PLOT LOCATION, WHERE THE NUMBER INDICATES HOW MANY POINTS
C           ARE REPRESENTED
C           NOTE THAT  X  IS NOT USED AS A PLOTTING SYMBOL EXCEPT TO
C           INDICATE THAT MORE THAN 9 POINTS FELL ON THE SAME PLOT
C           LOCATION
C        N  THE INTEGER NUMBER OF OBSERVATIONS TO BE PLOTTED (IN EACH
C           COLUMN)
C        M  THE NUMBER OF COLUMNS IN THE Y ARRAY TO BE PLOTTED VERSUS X
C           FOR THE CASE OF A VECTOR Y, M MUST BE EQUAL TO 1
C    IYM  THE ACTUAL INTEGER VALUE OF THE ROW DIMENSION OF THE Y ARRAY
C           WHEN Y IS A VECTOR (M.EQ.1) IYM SHOULD BE SET EQUAL TO N
C   ISCHCK  THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     ISYM  THE N VECTOR OF INTEGERS DETERMINING THE PLOTTING SYMBOLS TO
C           USED FOR THE S SERIES OF PLOTS, WHERE
C               1 = +    2 = .    3 = *    4 = -
C               5 = A    6 = B    7 = C    8 = D
C               9 = E   10 = F   11 = G   12 = H
C              13 = I   14 = J   15 = K   16 = L
C              17 = M   18 = N   19 = O   20 = P
C              21 = Q   22 = R   23 = S   24 = T
C              25 = U   26 = V   27 = W   28 = Y
C              29 (AND ABOVE) = Z
C           THE NUMBERS 1 TO 9 INDICATE MULTIPLE POINTS ON A GIVEN
C           PLOT LOCATION, WHERE THE NUMBER INDICATES HOW MANY POINTS
C           ARE REPRESENTED
C           NOTE THAT  X  IS NOT USED AS A PLOTTING SYMBOL EXCEPT TO
C           INDICATE THAT MORE THAN 9 POINTS FELL ON THE SAME PLOT
C           LOCATION
C    ISIZE  THE INTEGER CODE FOR THE PLOT SIZE, WHERE
C           0 INDICATES A PLOT 100 COL BY 50 ROWS
C           1 INDICATES A PLOT 50 COL BY  50 ROWS
C     NOUT  THE INTEGER VALUE INDICATING HOW MANY OF THE POINTS WHICH
C           FELL OUTSIDE OF THE GRAPH LIMITS ARE TO BE LISTED
C           IF XLB.EQ.XUB AND YLB.EQ.YUB, NOUT SHOULD BE SET TO ZERO
C     XLB  THE MINIMUM VALUE OF X TO BE PLOTTED(IE, THE LOWER BOUND FOR
C           THE X AXIS), WHERE IF XLB=XUB THE ROUTINE WILL DETERMINE
C           THIS VALUE FROM THE MINIMUM VALUE OF THE X VECTOR
C     XUB  THE MAXIMUM VALUE OF X TO BE PLOTTED(IE, THE UPPER BOUND FOR
C           THE X AXIS), WHERE IF XLB=XUB THE ROUTINE WILL DETERMINE
C           THIS VALUE FROM THE MAXIMUM VALUE OF THE X VECTOR
C     YLB  THE MINIMUM VALUE OF Y TO BE PLOTTED(IE, THE LOWER BOUND FOR
C           THE Y AXIS), WHERE IF YLB=YUB THE ROUTINE WILL DETERMINE
C           THIS VALUE FROM THE MINIMUM VALUE OF THE Y VECTOR
C     YUB  THE MAXIMUM VALUE OF Y TO BE PLOTTED(IE, THE UPPER BOUND FOR
C           THE Y AXIS), WHERE IF YLB=YUB THE ROUTINE WILL DETERMINE
C           THIS VALUE FROM THE MAXIMUM VALUE OF THE Y VECTOR
C     ILOG  THE INTEGER INDICATOR VARIABLE USED TO DETERMINE WHETHER
C           THE Y AXIS SCALE IS TO BE LOG OR NOT
C           IF ILOG.EQ.0, THE SCALE IS NOT LOG
C           IF ILOG.NE.0, THE SCALE IS LOG
C
C
C     ADDITIONAL VARIABLES USED - (IN ALPHABETICAL ORDER)
C
C    ALINE  THE VECTOR OF THE CURRENT PLOT LINE
C   ALPHAI  THE PLOT AXIS SYMBOL I
C   AXISCH  THE Y A AXIS SYMBOL TO BE USED FOR THE CURRENT LINE,
C           EITHER I OR -
C   ALPHAX  THE PLOTTING SYMBOL X DESIGNATING MORE THAN 9 POINTS FELL ON
C           A SINGLE PLOTTING LOCATION
C    BLANK  THE PLOTTING SYMBOL BLANK
C     DELX  THE RANGE OF THE X AXIS
C     DELY  THE RANGE OF THE Y AXIS
C   HYPHEN  THE PLOT AXIS SYMBOL -
C       IC  THE COUNT OF THE NUMBER OF VALUES FALLING OUTSIDE OF THE
C           GRAPH BOUNDS
C     ICOL  THE COLUMN LOCATION FOR THE PLOT LINE
C     IOUT  THE MINIMUM OF NOUT OR 50, INDICATING HOW MANY OF THE
C           POINTS WHICH FELL OUTSIDE OF THE GRAPH LIMITS WILL ACTUALLY
C           BE LISTED
C   IPCODE  THE INTEGER CODE, USED IN ERROR CHECKING, WHICH DETERMINES
C           WHICH PLOT ROUTINE HAS BEEN CALLED
C      IPR  THE UNIT NUMBER OF THE PRINTER
C    ITEST  THE INDICATOR VARIABLE FOR WHETHER THE X AXIS LABELS ARE
C           PRINTED IN E OR F FORMAT
C      KSS  AN INTEGER VECTOR USED IN DETERMINING THE PLOT SYMBOL
C           NEEDED
C       NN  THE NUMBER OF Y LABELS TO BE LISTED ON THE LEFT AXIS,
C           (DEPENDENT ON THE GRAPH SIZE)
C   NUMCOL  THE INTEGER VALUE OF THE NUMBER OF COLUMNS IN THE GRAPH
C   NUMLAB  THE INTEGER NUMBER OF X LABELS TO BE LISTED AT THE BOTTOM
C           OF THE GRAPH (DEPENDENT ON GRAPH SIZE)
C   NUMROW  THE INTEGER NUMBER OF ROWS IN THE GRAPH
C      SYM  THE VECTOR OF PLOT SYMBOL ASSIGNMENTS (SEE IS ABOVE)
C     SYM1  THE VECTOR OF INTEGER VALUES USED TO INDICATE MULTIPLE
C           POINTS ON THE SAME PLOT LOCATION
C     TEMP  THE ARRAY OF VALUES TO BE PRINTED WHICH FALL OUTSIDE THE
C           GRAPH LIMITS
C   XLABEL  THE VECTOR OF X AXIS LABELS
C       XMN  THE MINIMUM X VALUE TO BE PLOTTED, COMPUTED FROM DATA OR
C           ASSIGNED BY XLB
C   XWIDTH  THE VALUE OF AN INDIVIDUAL X AXIS GRAPH INTERVAL
C       XMX  THE MAXIMUM X VALUE TO BE PLOTTED, COMPUTED FROM DATA OR
C           ASSIGNED BY XUB
C   YLABEL  THE VALUE OF THE Y AXIS LABEL TO BE PRINTED
C   YLOWER  THE LOWER BOUND FOR Y VALUES TO BE PLOTTED ON THE CURRENT
C           LINE
C       YMN  THE MINIMUM Y VALUE TO BE PLOTTED, COMPUTED FROM DATA OR
C           ASSIGNED BY YLB
C   YUPPER  THE UPPER BOUND FOR Y VALUES TO BE PLOTTED ON THE CURRENT
C           LINE
C   YWIDTH  THE VALUE OF AN INDIVIDUAL Y AXIS GRAPH INTERVAL
C       YMX  THE MAXIMUM Y VALUE TO BE PLOTTED, COMPUTED FROM DATA OR
C           ASSIGNED BY YUB
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XMISS,XMN,XMX,YMN,YMX
      INTEGER
     +   ILOG,ISCHCK,ISIZE,IYM,LISYM,M,N,NOUT
      LOGICAL
     +   MISS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N),YM(IYM,M),YMMISS(M)
      INTEGER
     +   ISYM(LISYM)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELX,DELY,TN,TX,XDMN,XDMX,XWIDTH,XX,YDMN,YDMX,YL,YLOWER,
     +   YUPPER,YWIDTH,YY
      INTEGER
     +   I,IC,ICOL,IK,ILOGX,ILOGY,IOUT,IPRT,IROW,IT,ITEST,J,JCOL,K,
     +   L,NLABLX,NLABLY,NLU,NN,NUMCOL,NUMCP2,NUMROW
      CHARACTER
     +   ALPHAI*1,ALPHAX*1,AXISCH*1,BLANK*1,HYPHEN*1,FMT*4,
     +   XLFMT*205,XLFMT2*205
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   TEMP(50,2),XLABEL(20),YLABEL(20)
      INTEGER
     +   ALINE(105),ILOGXY(2),ISIZXY(2),ISPACE(20),KSS(101)
      CHARACTER
     +   CLINE(105)*1,ITEMP(50)*1,SYM(30)*1,SYM1(9)*1
C
C  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LOGLMT,PRTCNT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,LOG10,MAX,MIN
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER ALINE(105)
C     CHARACTER*1 ALPHAI, ALPHAX
C     CHARACTER*1 AXISCH
C     CHARACTER*1 BLANK
C     CHARACTER*1 CLINE(105)
C     DOUBLE PRECISION DELX, DELY
C     CHARACTER FMT*4
C        THE FORMAT FOR THE X-AXIS LABELS
C     CHARACTER*1 HYPHEN
C     INTEGER I, IC, ICOL, IERR, IK
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER ILOGX
C        THE VALUES OF P AS SPECIFIED BY ILOG.
C     INTEGER ILOGXY(2)
C        THE VALUES OF P AND Q AS SPECIFIED BY ILOG.
C     INTEGER ILOGY
C        THE VALUES OF Q AS SPECIFIED BY ILOG.
C     INTEGER IOUT
C     INTEGER IPRT, IROW
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISIZXY(2)
C     INTEGER ISPACE(20)
C        THE SPACING FOR THE X-AXIS LABELS
C     INTEGER ISYM(LISYM)
C     INTEGER IT
C     CHARACTER*1 ITEMP(50)
C     INTEGER ITEST
C     INTEGER IYM
C     INTEGER J, JCOL
C     INTEGER K
C     INTEGER KSS(101)
C     INTEGER L
C     INTEGER LISYM
C     INTEGER M
C     LOGICAL MISS
C     INTEGER N
C     INTEGER NLABLX, NLABLY, NLU
C     INTEGER NN, NOUT, NUMCOL, NUMCP2, NUMROW
C     CHARACTER*1 SYM(30), SYM1(9)
C     DOUBLE PRECISION TEMP(50, 2)
C     DOUBLE PRECISION TN, TX
C     DOUBLE PRECISION X(N)
C     DOUBLE PRECISION XDMN, XDMX
C        THE X-AXIS DATA LIMITS ACTUALLY USED.
C     DOUBLE PRECISION XLABEL(20)
C        THE X-AXIS LABLES.
C     CHARACTER XLFMT*205, XLFMT2*205
C        THE FORMATS USED TO PRINT THE X-AXIS
C     DOUBLE PRECISION XMISS, XMN, XMX, XWIDTH, XX
C     DOUBLE PRECISION YDMN, YDMX
C        THE Y-AXIS DATA LIMITS ACTUALLY USED.
C     DOUBLE PRECISION YL
C     DOUBLE PRECISION YLABEL(20)
C        THE Y-AXIS LABLES.
C     DOUBLE PRECISION YLOWER
C     DOUBLE PRECISION YM(IYM, M)
C     DOUBLE PRECISION YMMISS(M)
C     DOUBLE PRECISION YMN, YMX, YUPPER, YWIDTH, YY
C
      DATA BLANK/' '/,HYPHEN/'-'/,ALPHAI/'I'/,ALPHAX/'X'/
      DATA SYM( 1)/'+'/,SYM( 2)/'.'/,SYM( 3)/'*'/,SYM( 4)/'-'/,
     +     SYM( 5)/'A'/,SYM( 6)/'B'/,SYM( 7)/'C'/,SYM( 8)/'D'/,
     +     SYM( 9)/'E'/,SYM(10)/'F'/,SYM(11)/'G'/,SYM(12)/'H'/,
     +     SYM(13)/'I'/,SYM(14)/'J'/,SYM(15)/'K'/,SYM(16)/'L'/,
     +     SYM(17)/'M'/,SYM(18)/'N'/,SYM(19)/'O'/,SYM(20)/'P'/,
     +     SYM(21)/'Q'/,SYM(22)/'R'/,SYM(23)/'S'/,SYM(24)/'T'/,
     +     SYM(25)/'U'/,SYM(26)/'V'/,SYM(27)/'W'/,SYM(28)/'Y'/,
     +     SYM(29)/'Z'/,SYM(30)/'Z'/
      DATA SYM1(1)/'1'/,SYM1(2)/'2'/,SYM1(3)/'3'/,SYM1(4)/'4'/,
     +     SYM1(5)/'5'/,SYM1(6)/'6'/,SYM1(7)/'7'/,SYM1(8)/'8'/,
     +     SYM1(9)/'9'/
C
      CALL IPRINT(IPRT)
C
C     DEFINE THE NUMBER OF ROWS AND COLUMNS WITHIN THE PLOT
C
      CALL PRTCNT(MAX(0,ISIZE),2,ISIZXY)
      IF (ISIZXY(1).EQ.0) THEN
        NUMCOL=101
      ELSE
        NUMCOL = 51
      END IF
      IF (ISIZXY(2).EQ.0) THEN
        NUMROW = 51
      ELSE
        NUMROW = 26
      END IF
C
      NUMCP2 = NUMCOL + 2
      NN=(NUMROW-1)/5
C
C     ADJUST FOR LOG PLOTS IF NECESSARY AND FIND AXIS LABELS
C
      CALL PRTCNT (MAX(0,ILOG),2,ILOGXY)
      ILOGX = ILOGXY(1)
      ILOGY = ILOGXY(2)
      CALL LOGLMT (ILOGY, YMN, YMX, YLABEL, NUMROW, 5, DELY, YWIDTH,
     +  NLABLY, YDMN, YDMX)
      CALL LOGLMT (ILOGX, XMN, XMX, XLABEL, NUMCOL, 10, DELX, XWIDTH,
     +  NLABLX, XDMN, XDMX)
C
C     TEST FOR FORMAT FOR Y AXIS LABELS
C
      ITEST=0
      TX=YMX
      TN=YMN
      IF (ILOGY.EQ.0) GO TO 190
      TX=10.0D0**TX
      TN=10.0D0**TN
  190 IF ((TN .GE. 1.0D6 .OR. TN .LE. (-1.0D5)) .OR.
     +   (ABS(TN).GT.0.0D0.AND.ABS(TN).LT.0.001D0)) ITEST=1
      IF ((TX .GE. 1.0D6 .OR. TX .LE. (-1.0D5)) .OR.
     +   (ABS(TX).GT.0.0D0.AND.ABS(TX).LT.0.001D0)) ITEST=1
C
C     BLANK OUT THE PLOT PRINT LINE CLINE
C
      DO 200 ICOL=1,105
         CLINE(ICOL)=BLANK
  200 CONTINUE
C
C     WRITE OUT THE TOP HORIZONTAL AXIS OF THE PLOT
C
      DO 210 ICOL=1,NUMCOL
         CLINE(ICOL)=HYPHEN
  210 CONTINUE
      CLINE(1)=ALPHAI
      IF (ILOGX.EQ.0) THEN
        DO 215 ICOL=11,NUMCOL,10
           CLINE(ICOL)=ALPHAI
  215   CONTINUE
      ELSE
        DO 216 IK = NLABLX, 1, -1
          ICOL = ((LOG10(XLABEL(IK))-XMN)/XWIDTH)+1.5D0
          CLINE(ICOL) = ALPHAI
  216   CONTINUE
      END IF
      CLINE(NUMCOL+1)=HYPHEN
      CLINE(NUMCOL+2)=BLANK
      WRITE (IPRT, 1004) HYPHEN,(CLINE(I),I=1,NUMCOL),HYPHEN
      DO 217 ICOL=1,105
         CLINE(ICOL)=BLANK
  217 CONTINUE
C
C     DETERMINE AND WRITE OUT THE PLOT POSITIONS ONE LINE AT A TIME.
C
      L=-1
      IK=1
      DO 320 IROW=1,NUMROW
         L=L+1
         IF (L.GT.NN) L=1
         DO 235 ICOL=1,NUMCOL
            ALINE(ICOL)=0
            KSS(ICOL)=0
  235    CONTINUE
         YUPPER=YMX+(1.5D0-IROW)*YWIDTH
         YLOWER=YMX+(0.5D0-IROW)*YWIDTH
      DO 255 I = 1, N
C
         IF (MISS .AND. MVCHK(X(I), XMISS)) GO TO 255
C
         IF (ILOGX.EQ.0) THEN
           XX=X(I)
         ELSE
           XX=LOG10(X(I))
         END IF
         DO 250 J=1,M
C
            IF (MISS .AND. MVCHK(YM(I,J), YMMISS(J))) GO TO 250
               IF (ILOGY.EQ.0) THEN
                 YY=YM(I,J)
               ELSE
                 YY=LOG10(YM(I,J))
               END IF
               IF (((YLOWER.LE.YY).AND.(YY.LT.YUPPER)) .AND.
     +             ((YY.GE.YDMN).AND.(YY.LE.YDMX))) THEN
                  IF ((XX.GE.XDMN) .AND. (XX.LE.XDMX)) THEN
                     ICOL=((XX-XMN)/XWIDTH)+1.5D0
                     ALINE(ICOL) = ALINE(ICOL) + 1
C     SIMPLE PLOTTING (PLT)
                     KSS(ICOL)=1
C     SYMBOL PLOTS (SPLT)
                     IF (ISCHCK .EQ. 1) KSS(ICOL) = ISYM(I)
C     MULTIPLE PLOTS (MPLT)
                     IF (ISCHCK .EQ. 2) KSS(ICOL) = J + 4
                     IF (KSS(ICOL).GT.30) KSS(ICOL)=30
                     IF (KSS(ICOL).LT.1) KSS(ICOL)=1
                  END IF
               END IF
  250       CONTINUE
  255    CONTINUE
         DO 290 ICOL=1,NUMCOL
            IF (ALINE(ICOL).EQ.0) THEN
              CLINE(ICOL)=BLANK
            ELSE
              IF (ALINE(ICOL).EQ.1) THEN
                K=KSS(ICOL)
                CLINE(ICOL)=SYM(K)
              ELSE
                IF (ALINE(ICOL).LE.9) THEN
                  CLINE(ICOL)=SYM1(ALINE(ICOL))
                ELSE
                  CLINE(ICOL)=ALPHAX
                END IF
              END IF
            END IF
  290    CONTINUE
         CLINE(NUMCOL+2)=HYPHEN
         AXISCH=HYPHEN
         IF (ILOGY.EQ.0) THEN
           YL = YLABEL(IK)
         ELSE
           YL = LOG10(YLABEL(IK))
         END IF
         IF ((YLOWER.GT.YL) .OR. (YL.GE.YUPPER)) THEN
C
C          PRINT LINE WITHOUT LABEL
C
           CLINE(NUMCP2)=ALPHAI
           WRITE(IPRT, 1008) ALPHAI, (CLINE(ICOL), ICOL=1,NUMCP2)
         ELSE
C
C          PRINT LINE WITH LABEL
C
           IF (ITEST.EQ.0) THEN
             WRITE(IPRT,1006) YLABEL(IK),AXISCH,
     +         (CLINE(ICOL),ICOL=1,NUMCP2)
           ELSE
             WRITE(IPRT,1007) YLABEL(IK),AXISCH,
     +         (CLINE(ICOL),ICOL=1,NUMCP2)
           END IF
           IK=IK+1
         END IF
  320 CONTINUE
C
C     WRITE OUT THE BOTTOM HORIZONTAL AXIS AND THE X AXIS LABELS.
C
      DO 330 ICOL=1,NUMCOL
         CLINE(ICOL)=HYPHEN
  330 CONTINUE
      CLINE(1)=ALPHAI
      IF (ILOGX.EQ.0) THEN
        NLU = NLABLX+1
        DO 340 ICOL=NUMCOL,1,-10
           CLINE(ICOL)=ALPHAI
           NLU = NLU - 1
           ISPACE(NLU) = 1
  340   CONTINUE
      ELSE
        JCOL = 1
        CLINE(JCOL) = ALPHAI
        NLU = NLABLX
        DO 345 IK = NLABLX, 1, -1
          ICOL = ((LOG10(XLABEL(IK))-XMN)/XWIDTH)+1.5
          CLINE(ICOL) = ALPHAI
          IF (ICOL-JCOL.GE.10) THEN
            ISPACE(NLU) = ICOL-JCOL-9
            NLU = NLU - 1
            XLABEL(NLU) = XLABEL(IK)
            JCOL = ICOL
          END IF
  345   CONTINUE
      END IF
      CLINE(NUMCOL+1)=HYPHEN
      CLINE(NUMCOL+2)=BLANK
C
      WRITE(IPRT, 1004) HYPHEN, (CLINE(ICOL), ICOL = 1, NUMCP2)
C
C     CHECK X-AXIS LABELS FOR FORMAT
C
      FMT = 'F9.4'
      DO 350 I=1,NLABLX
        IF (((ABS(XLABEL(I)).GT.0.0D0) .AND. (ABS(XLABEL(I)).LT.0.01D0))
     +      .OR.
     +      ((XLABEL(I).GE.1.0D4) .OR. (XLABEL(I).LE.(-1.0D3)))) THEN
          FMT = 'D9.4'
           GO TO 355
         END IF
  350 CONTINUE
  355 CONTINUE
      WRITE(XLFMT2,1000) NLABLX-NLU
      WRITE(XLFMT,XLFMT2) (FMT, ISPACE(I), I=NLABLX,NLU+1,-1), FMT
      WRITE(IPRT, XLFMT) (XLABEL(I),I=NLABLX,NLU,-1)
C
C     DETERMINE VALUES TO BE LISTED IF OUTSIDE OF AXIS LIMITS.
C
      IC = 0
      IOUT = MIN(NOUT,50)
      IF (IOUT.GE.0) THEN
        DO 180 I = 1, N
C
          IF (MISS .AND. MVCHK(X(I), XMISS)) GO TO 180
C
          IF (ILOGX.EQ.0) THEN
            XX = X(I)
          ELSE
            XX = LOG10(X(I))
          END IF
           DO 175 J=1,M
C
              IF (MISS .AND. MVCHK(YM(I,J), YMMISS(J))) GO TO 175
C
              IF (ILOGY.EQ.0) THEN
                YY = YM(I,J)
              ELSE
                YY = LOG10(YM(I,J))
              END IF
C
              IF (((YDMN .LE. YY) .AND. (YY .LE. YDMX)) .AND.
     +            ((XDMN .LE. XX) .AND. (XX .LE. XDMX))) GO TO 175
C
              IC=IC+1
              IF (IC.GT.IOUT) GO TO 175
              TEMP(IC,1)=X(I)
              TEMP(IC,2)=YM(I,J)
              IT=1
              IF (ISCHCK.EQ.1) IT=ISYM(I)
              IF (ISCHCK.EQ.2) IT=J+4
              IF (IT.LT.1) IT=1
              IF (IT.GT.30) IT=30
              ITEMP(IC) = SYM(IT)
  175      CONTINUE
  180   CONTINUE
      END IF
C
C     CHECK FOR POINTS OUTSIDE OF GRAPH LIMITS AND LIST IF REQUESTED
C     THE TOTAL NUMBER OF POINTS TO BE PLOTTED IS N*M
C
      IF (IC.EQ.0) RETURN
      IF (IOUT .LT. 0) RETURN
      WRITE (IPRT, 1010) IC
      IF (IOUT.LE.0) RETURN
      WRITE (IPRT, 1016)
      IF (IC.LE.IOUT) GO TO 360
      IC=IOUT
      WRITE(IPRT, 1011) IOUT
      GO TO 370
  360 WRITE(IPRT, 1012)
  370 WRITE(IPRT, 1013) (TEMP(I,1), TEMP(I,2), ITEMP(I), I = 1, IC)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT ('(''(14X'',', I2, '('', '', A4, '','', I2, ''X''),',
     +  ''', '', A4, '')'')')
 1004 FORMAT (' ',16X, A1, 105A1)
 1006 FORMAT(4X,F11.4,1X,A1,1X,105A1)
 1007 FORMAT (' ', E14.7, 1X, A1, 1X, 105A1)
 1008 FORMAT (' ', 15X, A1, 1X, 105A1)
 1010 FORMAT(16X,6H**NOTE,I4,43H VALUES FELL OUTSIDE THE SPECIFIED LIMIT
     +S**)
 1011 FORMAT ('1', 15X, 10HTHE FIRST , I3,
     +   35H VALUES OUTSIDE THE PLOT LIMITS ARE/ 22X,
     + 33H X               Y            SYM)
 1012 FORMAT ('1', 15X, 38HTHE VALUES OUTSIDE THE PLOT LIMITS ARE/ 22X,
     + 33H X               Y            SYM)
 1013 FORMAT (15X,2E15.8,9X,A1)
 1016 FORMAT (16X, 22HSEE NEXT PAGE FOR LIST)
C
      END
*PRTCNT
      SUBROUTINE PRTCNT(NPRT, NDIGIT, IPTOUT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SETS UP THE PRINT CONTROL PARAMETERS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   NDIGIT,NPRT
C
C  ARRAY ARGUMENTS
      INTEGER
     +   IPTOUT(NDIGIT)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IFAC1,IFAC2
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MOD
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I, IFAC1, IFAC2
C     INTEGER IPTOUT(NDIGIT)
C        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
C     INTEGER NDIGIT
C        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C
C
      IF (NPRT.LE.-1) GO TO 20
C
      IFAC1 = 10 ** (NDIGIT)
      DO 10 I = 1, NDIGIT
         IFAC2 = IFAC1/10
         IPTOUT(I) = MOD(NPRT, IFAC1) / IFAC2
         IFAC1 = IFAC2
   10 CONTINUE
      RETURN
C
   20 DO 30 I = 1, NDIGIT
         IPTOUT(I) = 1
   30 CONTINUE
      IPTOUT (NDIGIT) = 2
C
      RETURN
C
      END
*RANDN
      DOUBLE PRECISION FUNCTION RANDN(JD)
C***BEGIN PROLOGUE  RANDN (ORIGINALLY RNOR)
C***DATE WRITTEN   810915
C***REVISION DATE  900315
C***CATEGORY NO.  L6A14
C***KEYWORDS  RANDOM NUMBERS, UNIFORM RANDOM NUMBERS
C***AUTHOR    KAHANER, DAVID
C             APPLIED AND COMPUTATIONAL MATHEMATICS DIVISTION, NIST
C
C             MARSAGLIA, GEORGE
C             COMPUTER SCIENCE DEPT., WASH STATE UNIV
C
C             MODIFIED BY -
C             DONALDSON, JANET
C             APPLIED AND COMPUTATIONAL MATHEMATICS DIVISTION, NIST
C
C***PURPOSE  GENERATES QUASI NORMAL RANDOM NUMBERS, WITH MEAN ZERO AND
C             UNIT STANDARD DEVIATION, AND CAN BE USED WITH ANY COMPUTER
C             WITH INTEGERS AT LEAST AS LARGE AS 32767.
C***DESCRIPTION
C
C       RANDN GENERATES QUASI NORMAL RANDOM NUMBERS WITH ZERO MEAN AND
C       UNIT STANDARD DEVIATION.
C       IT CAN BE USED WITH ANY COMPUTER WITH INTEGERS AT LEAST AS
C       LARGE AS 32767.
C
C
C   USE
C       FIRST TIME....
C                   Z = RANDN(JD)
C                     HERE JD IS ANY  N O N - Z E R O  INTEGER.
C                     THIS CAUSES INITIALIZATION OF THE PROGRAM
C                     AND THE FIRST RANDOM NUMBER TO BE RETURNED AS Z.
C       SUBSEQUENT TIMES...
C                   Z = RANDN(0)
C                     CAUSES THE NEXT RANDOM NUMBER TO BE RETURNED AS Z.
C
C=======================================================================
C
C    NOTE: USERS WHO WISH TO TRANSPORT THIS PROGRAM TO OTHER
C           COMPUTERS SHOULD READ THE FOLLOWING ....
C
C   MACHINE DEPENDENCIES...
C      MDIG = A LOWER BOUND ON THE NUMBER OF BINARY DIGITS AVAILABLE
C              FOR REPRESENTING INTEGERS, INCLUDING THE SIGN BIT.
C              THIS MUST BE AT LEAST 16, BUT CAN BE INCREASED IN
C              LINE WITH REMARK A BELOW.
C
C   REMARKS...
C     A. THIS PROGRAM CAN BE USED IN TWO WAYS:
C        (1) TO OBTAIN REPEATABLE RESULTS ON DIFFERENT COMPUTERS,
C            SET 'MDIG' TO THE SMALLEST OF ITS VALUES ON EACH, OR,
C        (2) TO ALLOW THE LONGEST SEQUENCE OF RANDOM NUMBERS TO BE
C            GENERATED WITHOUT CYCLING (REPEATING) SET 'MDIG' TO THE
C            LARGEST POSSIBLE VALUE.
C     B. THE SEQUENCE OF NUMBERS GENERATED DEPENDS ON THE INITIAL
C          INPUT 'JD' AS WELL AS THE VALUE OF 'MDIG'.
C          IF MDIG=16 ONE SHOULD FIND THAT
C            THE FIRST EVALUATION
C              Z=RANDN(87) GIVES  Z=-.40079207...
C            THE SECOND EVALUATION
C              Z=RANDN(0) GIVES   Z=-1.8728870...
C            THE THIRD EVALUATION
C              Z=RANDN(0) GIVES   Z=1.8216004...
C            THE FOURTH EVALUATION
C              Z=RANDN(0) GIVES   Z=.69410355...
C            THE THOUSANDTH EVALUATION
C              Z=RANDN(0) GIVES   Z=.96782424...
C
C***REFERENCES  MARSAGLIA & TSANG, "A FAST, EASILY IMPLEMENTED
C                 METHOD FOR SAMPLING FROM DECREASING OR
C                 SYMMETRIC UNIMODAL DENSITY FUNCTIONS", TO BE
C                 PUBLISHED IN SIAM J SISC 1983.
C***ROUTINES CALLED  I1MACH,XERROR
C***END PROLOGUE  RANDN
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   JD
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   AA,B,C,C1,C2,ONE,P5,PC,RMAX,S,X,XN,Y
      INTEGER
     +   I,I1,J,J0,J1,JSEED,K0,K1,M1,M2,MDIG
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   V(65),W(65)
      INTEGER
     +   M(17)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   RANDU
      INTEGER
     +   I1MACH
      EXTERNAL RANDU,I1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL XERROR
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,EXP,LOG,MIN,MOD,REAL,SIGN
C
C  SAVE STATEMENT
      SAVE I1,J1,M,M1,M2,RMAX
C
      DATA AA,B,C,RMAX/12.37586D0,0.4878992D0,12.67706D0,3.0518509D-5/
      DATA C1,C2,PC,XN/0.9689279D0,1.301198D0,0.1958303D-1,2.776994D0/
      DATA (V(I),I=1,15)/0.3409450D0,0.4573146D0,0.5397793D0,
     +     0.6062427D0,0.6631691D0,0.7136975D0,0.7596125D0,0.8020356D0,
     +     0.8417227D0,0.8792102D0,0.9148948D0,0.9490791D0,0.9820005D0,
     +     1.0138492D0,1.0447810D0/
      DATA (V(I),I=16,30)/1.0749254D0,1.1043917D0,1.1332738D0,
     +     1.1616530D0,1.1896010D0,1.2171815D0,1.2444516D0,1.2714635D0,
     +     1.2982650D0,1.3249008D0,1.3514125D0,1.3778399D0,1.4042211D0,
     +     1.4305929D0,1.4569915D0/
      DATA (V(I),I=31,45)/1.4834526D0,1.5100121D0,1.5367061D0,
     +     1.5635712D0,1.5906454D0,1.6179680D0,1.6455802D0,1.6735255D0,
     +     1.7018503D0,1.7306045D0,1.7598422D0,1.7896223D0,1.8200099D0,
     +     1.8510770D0,1.8829044D0/
      DATA (V(I),I=46,60)/1.9155830D0,1.9492166D0,1.9839239D0,
     +     2.0198430D0,2.0571356D0,2.0959930D0,2.1366450D0,2.1793713D0,
     +     2.2245175D0,2.2725185D0,2.3239338D0,2.3795007D0,2.4402218D0,
     +     2.5075117D0,2.5834658D0/
      DATA (V(I),I=61,65)/2.6713916D0,2.7769943D0,2.7769943D0,
     +     2.7769943D0,2.7769943/
      DATA (W(I),I=1,20)/0.10405134D-04,0.13956560D-04,0.16473259D-04,
     +     0.18501623D-04,0.20238931D-04,0.21780983D-04,0.23182241D-04,
     +     0.24476931D-04,0.25688121D-04,0.26832186D-04,0.27921226D-04,
     +     0.28964480D-04,0.29969191D-04,0.30941168D-04,0.31885160D-04,
     +     0.32805121D-04,0.33704388D-04,0.34585827D-04,0.35451919D-04,
     +     0.36304851D-04/
      DATA (W(I),I=21,40)/0.37146564D-04,0.37978808D-04,0.38803170D-04,
     +     0.39621114D-04,0.40433997D-04,0.41243096D-04,0.42049621D-04,
     +     0.42854734D-04,0.43659562D-04,0.44465208D-04,0.45272764D-04,
     +     0.46083321D-04,0.46897980D-04,0.47717864D-04,0.48544128D-04,
     +     0.49377973D-04,0.50220656D-04,0.51073504D-04,0.51937936D-04,
     +     0.52815471D-04/
      DATA (W(I),I=41,60)/0.53707761D-04,0.54616606D-04,0.55543990D-04,
     +     0.56492112D-04,0.57463436D-04,0.58460740D-04,0.59487185D-04,
     +     0.60546402D-04,0.61642600D-04,0.62780711D-04,0.63966581D-04,
     +     0.65207221D-04,0.66511165D-04,0.67888959D-04,0.69353880D-04,
     +     0.70922996D-04,0.72618816D-04,0.74471933D-04,0.76525519D-04,
     +     0.78843526D-04/
      DATA (W(I),I=61,65)/0.81526890D-04,0.84749727D-04,0.84749727D-04,
     +     0.84749727D-04,0.84749727D-04/
      DATA M(1),M(2),M(3),M(4),M(5),M(6),M(7),M(8),M(9),M(10),M(11),
     +     M(12),M(13),M(14),M(15),M(16),M(17)/30788,23052,2053,19346,
     +     10646,19427,23975,19049,10949,19693,29746,26748,2796,23890,
     +     29168,31924,16499/
      DATA M1,M2,I1,J1/32767,256,5,17/
      DATA P5,ONE/0.5D0,1.0D0/
C
C FAST PART...
C
C
C***FIRST EXECUTABLE STATEMENT  RANDN
      IF (JD.NE.0) THEN
C  FILL
          MDIG = I1MACH(8) + 1
C
C  MODIFICATION SO SAME NUMBERS WILL BE GENERATED ON ALL MACHINES
C  WITH I1MACH(8) AT LEAST 31
C
          MDIG = MIN(MDIG,32)
C
C  BE SURE THAT MDIG AT LEAST 16...
          IF (MDIG.LT.16) CALL XERROR('RANDN--MDIG LESS THAN 16',23,1,2)
C
          M1 = 2** (MDIG-2) + (2** (MDIG-2)-1)
          M2 = 2** (MDIG/2)
          JSEED = MIN(ABS(JD),M1)
          IF (MOD(JSEED,2).EQ.0) JSEED = JSEED - 1
          K0 = MOD(9069,M2)
          K1 = 9069/M2
          J0 = MOD(JSEED,M2)
          J1 = JSEED/M2
          DO 10 I = 1,17
              JSEED = J0*K0
              J1 = MOD(JSEED/M2+J0*K1+J1*K0,M2/2)
              J0 = MOD(JSEED,M2)
              M(I) = J0 + M2*J1
   10     CONTINUE
          J1 = 17
          I1 = 5
          RMAX = ONE/DBLE(M1)
C  SEED UNIFORM (0,1] GENERATOR.  (JUST A DUMMY CALL)
          RANDN = RANDU(JD)
          DO 20 I = 1,65
              W(I) = RMAX*V(I)
   20     CONTINUE
      END IF

      I = M(I1) - M(J1)
      IF (I.LT.0) I = I + M1
      M(J1) = I
      I1 = I1 - 1
      IF (I1.EQ.0) I1 = 17
      J1 = J1 - 1
      IF (J1.EQ.0) J1 = 17
      J = MOD(I,64) + 1
      RANDN = I*W(J+1)
      IF (((I/M2)/2)*2.EQ. (I/M2)) RANDN = -RANDN
      IF (ABS(RANDN).GT.V(J)) THEN
C  SLOW PART; AA IS A*F(0)
          X = (ABS(RANDN)-V(J))/ (V(J+1)-V(J))
          Y = RANDU(0)
          S = X + Y
          IF (S.LE.C2) THEN
              IF (S.LE.C1) THEN
                  RETURN
              ELSE IF (Y.LE.C-AA*EXP(-P5 * (B-B*X)**2)) THEN
                  IF (EXP(-P5*V(J+1)**2)+Y*PC/V(J+1).GT.
     +                EXP(-P5*RANDN**2)) THEN
   30                 CONTINUE
C TAIL PART; 3.855849 IS .5*XN**2
                      S = XN - LOG(RANDU(0))/XN
                      IF (3.855849D0+LOG(RANDU(0))-XN*S.GT.
     +                    -P5*S**2) GO TO 30
                      RANDN = SIGN(S,RANDN)
                  END IF
                  RETURN
              ELSE
              END IF
          END IF
          RANDN = SIGN(B-B*X,RANDN)
      END IF
      END
*RANDU
      DOUBLE PRECISION FUNCTION RANDU(JD)
C***BEGIN PROLOGUE  RANDU  (ORIGINALLY UNI)
C***DATE WRITTEN   810915
C***REVISION DATE  900315
C***CATEGORY NO.  L6A21
C***KEYWORDS  RANDOM NUMBERS, UNIFORM RANDOM NUMBERS
C***AUTHOR    BLUE, JAMES
C             KAHANER, DAVID
C             APPLIED AND COMPUTATIONAL MATHEMATICS DIVISTION, NIST
C
C             MARSAGLIA, GEORGE
C             COMPUTER SCIENCE DEPT., WASH STATE UNIV
C
C             MODIFIED BY -
C             DONALDSON, JANET
C             APPLIED AND COMPUTATIONAL MATHEMATICS DIVISTION, NIST
C
C***PURPOSE  THIS ROUTINE GENERATES QUASI UNIFORM RANDOM NUMBERS ON
C             (0,1] AND CAN BE USED ON ANY COMPUTER WITH WHICH ALLOWS
C             INTEGERS AT LEAST AS LARGE AS 32767.
C***DESCRIPTION
C
C       THIS ROUTINE GENERATES QUASI UNIFORM RANDOM NUMBERS ON THE
C       INTERVAL (0,1].  IT CAN BE USED WITH ANY COMPUTER WHICH ALLOWS
C       INTEGERS AT LEAST AS LARGE AS 32767.
C
C
C   USE
C       FIRST TIME....
C                   Z = RANDU(JD)
C                     HERE JD IS ANY  N O N - Z E R O  INTEGER.
C                     THIS CAUSES INITIALIZATION OF THE PROGRAM
C                     AND THE FIRST RANDOM NUMBER TO BE RETURNED AS Z.
C       SUBSEQUENT TIMES...
C                   Z = RANDU(0)
C                     CAUSES THE NEXT RANDOM NUMBER TO BE RETURNED AS Z.
C
C
C===================================================================
C   NOTE: USERS WHO WISH TO TRANSPORT THIS PROGRAM FROM ONE COMPUTER
C         TO ANOTHER SHOULD READ THE FOLLOWING INFORMATION:
C
C   MACHINE DEPENDENCIES...
C      MDIG = A LOWER BOUND ON THE NUMBER OF BINARY DIGITS AVAILABLE
C              FOR REPRESENTING INTEGERS, INCLUDING THE SIGN BIT.
C              THIS VALUE MUST BE AT LEAST 16, BUT MAY BE INCREASED
C              IN LINE WITH REMARK A BELOW.
C
C   REMARKS...
C     A. THIS PROGRAM CAN BE USED IN TWO WAYS:
C        (1) TO OBTAIN REPEATABLE RESULTS ON DIFFERENT COMPUTERS,
C            SET 'MDIG' TO THE SMALLEST OF ITS VALUES ON EACH, OR,
C        (2) TO ALLOW THE LONGEST SEQUENCE OF RANDOM NUMBERS TO BE
C            GENERATED WITHOUT CYCLING (REPEATING) SET 'MDIG' TO THE
C            LARGEST POSSIBLE VALUE.
C     B. THE SEQUENCE OF NUMBERS GENERATED DEPENDS ON THE INITIAL
C          INPUT 'JD' AS WELL AS THE VALUE OF 'MDIG'.
C          IF MDIG=16 ONE SHOULD FIND THAT
C            THE FIRST EVALUATION
C              Z=RANDU(305) GIVES Z=.027832881...
C            THE SECOND EVALUATION
C              Z=RANDU(0) GIVES   Z=.56102176...
C            THE THIRD EVALUATION
C              Z=RANDU(0) GIVES   Z=.41456343...
C            THE THOUSANDTH EVALUATION
C              Z=RANDU(0) GIVES   Z=.19797357...
C
C***REFERENCES  MARSAGLIA G., "COMMENTS ON THE PERFECT UNIFORM RANDOM
C                 NUMBER GENERATOR", UNPUBLISHED NOTES, WASH S. U.
C***ROUTINES CALLED  I1MACH,XERROR
C***END PROLOGUE  RANDU
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   JD
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ONE,ZERO
      INTEGER
     +   I,J,J0,J1,JSEED,K,K0,K1,M1,M2,MDIG
C
C  LOCAL ARRAYS
      INTEGER
     +   M(17)
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   I1MACH
      EXTERNAL I1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL XERROR
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MIN,MOD,REAL
C
C  SAVE STATEMENT
      SAVE I,J,M,M1,M2
C
C
      DATA M(1),M(2),M(3),M(4),M(5),M(6),M(7),M(8),M(9),M(10),M(11),
     +     M(12),M(13),M(14),M(15),M(16),M(17)/30788,23052,2053,19346,
     +     10646,19427,23975,19049,10949,19693,29746,26748,2796,23890,
     +     29168,31924,16499/
      DATA M1,M2,I,J/32767,256,5,17/
      DATA ZERO,ONE /0.0D0,1.0D0/
C
C***FIRST EXECUTABLE STATEMENT  RANDU
      IF (JD.NE.0) THEN
C  FILL
          MDIG = I1MACH(8) + 1
C
C  MODIFICATION SO SAME NUMBERS WILL BE GENERATED ON ALL MACHINES
C  WITH I1MACH(8) AT LEAST 31
C
          MDIG = MIN(MDIG,32)
C
C  BE SURE THAT MDIG AT LEAST 16...
          IF (MDIG.LT.16) CALL XERROR('RANDU--MDIG LESS THAN 16',22,1,2)
          M1 = 2** (MDIG-2) + (2** (MDIG-2)-1)
          M2 = 2** (MDIG/2)
          JSEED = MIN(ABS(JD),M1)
          IF (MOD(JSEED,2).EQ.0) JSEED = JSEED - 1
          K0 = MOD(9069,M2)
          K1 = 9069/M2
          J0 = MOD(JSEED,M2)
          J1 = JSEED/M2
          DO 10 I = 1,17
              JSEED = J0*K0
              J1 = MOD(JSEED/M2+J0*K1+J1*K0,M2/2)
              J0 = MOD(JSEED,M2)
              M(I) = J0 + M2*J1
   10     CONTINUE
          I = 5
          J = 17
      END IF
C  BEGIN MAIN LOOP HERE
      K = M(I) - M(J)
      IF (K.LT.0) K = K + M1
      M(J) = K
      I = I - 1
      IF (I.EQ.0) I = 17
      J = J - 1
      IF (J.EQ.0) J = 17
      RANDU = DBLE(K)/DBLE(M1)
C
C  MODIFICATION SO RANDOM NUMBERS IN (0,1] RATHER THAN [0,1)
C
      IF (RANDU.EQ.ZERO) RANDU = ONE
      END
*RANKO
      SUBROUTINE RANKO(N, Y, H, R, T)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     VERSION  45.0    RANKO    3/ 6/70
C     *****
C     PUTS RANK OF N X"S IN VECTOR R. VECTOR H IS USED FOR STORAGE.
C     X,H AND R MUST BE DIMENSIONED N OR GREATER.
C     STORES CORRECTION FOR TIES IN T = SUM(T-1)*T*(T+1).
C        N.B.  T IS 12 TIMES VALUE COMPUTED BY ORIGINAL OMNITAB ROUTINE.
C     T=0  MEANS NO TIES.
C     WRITTEN BY DAVID HOGBEN, SEL, NBS.   4/9/69.
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   T
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   R(N),Y(N)
      INTEGER
     +   H(N)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IJ,J,K,K2
C
C  EXTERNAL SUBROUTINES
      EXTERNAL SRTIR,SRTRI
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER H(N)
C        THE INDICES TO THE HIERARCHY OF R
C     INTEGER I
C        INDEX VARIABLE
C     INTEGER IJ
C        INDEX VARIABLE BASED ON I-J
C     INTEGER J
C        INDEX VARIABLE
C     INTEGER K
C        INDEX VARIABLE
C     INTEGER K2
C          INDEX VARIABLE
C     INTEGER N
C        NUMBER OF OBSERVATIONS
C     DOUBLE PRECISION R(N)
C        FINAL VECTOR CONTAINING RANK
C     DOUBLE PRECISION T
C        12 TIMES THE OMNITAB CORRECTION FOR TIES
C             T = SUM(T-1)*T*(T+1)
C             T = 0 MEANS NO TIES
C     DOUBLE PRECISION Y(N)
C        VECTOR TO BE RANKED
C
C
C     MOVE Y TO R AND PUT I IN H
C
      DO 10 I=1,N
         H(I) = I
         R(I) = Y(I)
   10 CONTINUE
C
C     SORT Y IN R, CARRY ALONG I IN H TO OBTAIN HIERARCHY IN H.
C
      CALL SRTIR(H, N, R)
C
C     REPLACE R(I) BY I*.
C     LET K BE SUCH THAT R(I)=R(I-J+1),J=1,K. THEN I* = I-(K-1)/2.
C
      K = 1
      T = 0
      DO 40 I=2,N
         IF (R(I).EQ.R(I-1)) THEN
            K = K + 1
         ELSE
            DO 30 J=1,K
               IJ = I - J
               R(IJ) = (I-1) - (K-1)/2.0D0
   30       CONTINUE
            T = T + (K-1)*K*(K+1)
            K = 1
         END IF
   40 CONTINUE
      T = T + (K-1)*K*(K+1)
      DO 50 I=1,K
         K2 = N + 1 - I
         R(K2) = N - (K-1)/2.0D0
   50 CONTINUE
C
C     SORT H CARRY ALONG R TO OBTAIN RANKS IN R
C
      CALL SRTRI(R, N, H)
      RETURN
      END
*REALTR
      SUBROUTINE REALTR(A, B, N, ISN)
C  IF ISN=1, THIS SUBROUTINE COMPLETES THE FOURIER TRANSFORM
C    OF 2*N DATA VALUES, WHERE THE ORIGINAL DATA VALUES ARE
C    STORED ALTERNATELY IN ARRAYS A AND B, AND ARE FIRST
C    TRANSFORMED BY A COMPLEX FOURIER TRANSFORM OF DIMENSION N.
C    THE COSINE COEFFICIENTS ARE IN A(1),A(2),...A(N+1) AND
C    THE SINE COEFFICIENTS ARE IN B(1),B(2),...B(N+1).
C    A TYPICAL CALLING SEQUENCE IS
C      CALL FFT(A,B,N,N,N,1)
C      CALL REALTR(A,B,N,1)
C    THE RESULTS SHOULD BE MULTIPLIED BY 0.5D0/N TO GIVE THE
C    USUAL SCALING OF COEFFICIENTS.
C  IFISN-1, THE INVERSE TRANSFORMATION IS DONE, THE FIRST STEP
C    IN EVALUATING A DOUBLE PRECISION FOURIER SERIES.
C    A TYPICAL CALLING SEQUENCE IS
C      CALL REALTRA(A,B,N,-1)
C      CALL FFT(A,B,N,N,N,-1)
C    THE RESULTS SHOULD BE MULTIPLIED BY 0.5D0 TO GIVE THE USUAL
C    SCALING, AND THE TIME DOMAIN RESULTS ALTERNATE IN ARRAYS A
C    AND B, I.E. A(1),B(1),A(2),B(2),...A(N),B(N).
C  THE DATA MAY ALTERNATIVELY BE STORED IN A SINGLE COMPLEX
C    ARRAY A, THEN THE MAGNITUDE OF ISN CHANGED TO TWO TO
C    GIVE THE CORRECT INDEXING INCREMENT AND A(2) USED TO
C    PASS THE INITIAL ADDRESS FOR THE SEQUENCE OF IMAGINARY
C    VALUES, E.G.
C      CALL FFT(A,A(2),N,N,N,2)
C      CALL REALTR(A,A(2),N,2)
C    IN THIS CASE, THE COSINE AND SINE COEFFICIENTS ALTERNATE IN A.
C  BY R. C. SINGLETON, STANFORD RESEARCH INSTITUTE, OCT. 1968
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISN,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   A(1),B(1)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   AA,AB,BA,BB,CD,CN,IM,RE,SD,SN
      INTEGER
     +   INC,J,K,NH,NK
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ATAN,IABS,SIN
C
C
C
      INC = IABS(ISN)
      NK = N*INC + 2
      NH = NK/2
      SD = 2.0D0*ATAN(1.0D0)/N
      CD = 2.0D0*SIN(SD)**2
      SD = SIN(SD+SD)
      SN = 0.0D0
      IF (ISN.LT.0) GO TO 30
      CN = 1.0D0
      A(NK-1) = A(1)
      B(NK-1) = B(1)
   10 DO 20 J=1,NH,INC
         K = NK - J
         AA = A(J) + A(K)
         AB = A(J) - A(K)
         BA = B(J) + B(K)
         BB = B(J) - B(K)
         RE = CN*BA + SN*AB
         IM = SN*BA - CN*AB
         B(K) = IM - BB
         B(J) = IM + BB
         A(K) = AA - RE
         A(J) = AA + RE
         AA = CN - (CD*CN+SD*SN)
         SN = (SD*CN-CD*SN) + SN
         CN = 0.5D0/(AA**2+SN**2) + 0.5D0
         SN = CN*SN
         CN = CN*AA
   20 CONTINUE
      RETURN
   30 CN = -1.0D0
      SD = -SD
      GO TO 10
      END
*RELCOM
      SUBROUTINE RELCOM(N, V, W, RELTOL, ABSTOL, NFAIL, IFAIL)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE COMPUTES THE NUMBER OF TIMES THE
C     RELATIVE DIFFERENCE BETWEEN V(I) AND W(I), I = 1, 2, ..., N,
C     IS GREATER THAN   RELTOL  .
C
C     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ABSTOL,RELTOL
      INTEGER
     +   N,NFAIL
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   V(N),W(N)
      INTEGER
     +   IFAIL(N)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ABSTOL
C        THE ABSOLUTE TOLERANCE USED IN THE COMPARISON.
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IFAIL(N)
C        AN INDICATOR VARIABLE DESIGNATING WHETHER OR NOT THE COMPARISON
C        FAILED OR NOT, WHERE 0 INDICATES NOT FAILURE AND 1 INDICATES
C        FALURE.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFAIL
C        THE TOTAL NUMBER OF FAILURES.
C     DOUBLE PRECISION RELTOL
C        THE RELATIVE TOLERANCE USED IN THE COMPARISON.
C     DOUBLE PRECISION V(N), W(N)
C        THE VALUES BEING COMPARED.
C
      NFAIL = 0
C
      DO 30 I = 1, N
         IF ((ABS(V(I)-W(I)).LE.RELTOL*MAX(ABS(V(I)),ABS(W(I)))) .OR.
     +       (((V(I).EQ.0.0D0).OR.(W(I).EQ.0.0D0)).AND.
     +        (ABS(V(I)-W(I)).LE.ABSTOL))) THEN
            IFAIL(I) = 0
         ELSE
            IFAIL(I) = 1
            NFAIL = NFAIL + 1
         END IF
   30 CONTINUE
C
      RETURN
C
      END
*REPCK
      SUBROUTINE REPCK(D, NRESTS, NPAR, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE MODIFIES D TO CONFORM TO N BY NPAR FORMAT REQUIRED
C     BY NLCMP.  FUTURE REVISIONS TO NLCMP SHOULD BE MADE TO ELIMINATE
C     THE NEED FOR THIS ROUTINE.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NPAR,NRESTS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(NRESTS*NPAR)
C
C  LOCAL SCALARS
      INTEGER
     +   I,I1,I2,J
C
C
      I1 = -N
      I2 = -N
      DO 10 J = 1, NPAR
        I1 = I1 + NRESTS
        I2 = I2 + N
        DO 5 I = 1, N
          D(I2+I) = D(I1+I)
    5   CONTINUE
   10 CONTINUE
      RETURN
      END
*SAMPLE
      SUBROUTINE SAMPLE (Y, N, NS, YS, NYS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE SAMPLES EVERY KTH OBSERVATION FROM THE INPUT
C     SERIES Y, STORING THE SAMPLED SERIES IN YS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NS,NYS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*),YS(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,ERR02,HEAD
C
C  LOCAL ARRAYS
      CHARACTER
     +   LN(8)*1,LNS(8)*1,LONE(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,IPRINT,SMPLY
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01, ERR02
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     CHARACTER*1 LN(8), LNS(8), LONE(8)
C        THE ARRAY CONTAINING THE NAME OF THE VARIABLE N AND NS.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NS
C        THE SAMPLING RATE.
C     INTEGER NYS
C        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YS.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YS(N)
C        THE VECTOR IN WHICH THE SAMPLED SERIES IS RETURNED.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'S',       'A',       'M',       'P',       'L',       'E'/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LNS(1), LNS(2), LNS(3), LNS(4), LNS(5), LNS(6), LNS(7), LNS(8)
     + /  'N',   'S',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LONE(1), LONE(2), LONE(3), LONE(4), LONE(5), LONE(6), LONE(7),
     +  LONE(8)
     + /  'O',   'N',   'E',   ' ',   ' ',   ' ',   ' ',   ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 3, 1, HEAD, ERR01, LN)
C
      CALL EISII(NMSUB, LNS, NS, 1, N, 1, HEAD, ERR02, LONE, LN)
C
      IF (ERR01 .OR. ERR02) GO TO 10
      GO TO 20
C
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   20 CONTINUE
C
      CALL SMPLY (Y, N, NS, YS, NYS)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   38H       CALL SAMPLE (Y, N, NS, YS, NYS))
      END
*SETESL
      SUBROUTINE SETESL(N, NDIV, NFFT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE SMALLEST VALUE OF NFFT WHICH
C     EQUALS OR EXCEEDS N + 2, SUCH THAT NFFT - 2 IS
C     1. DIVISIBLE BY NDIV,
C     2. HAS NO MORE THAN 11 PRIME FACTORS,
C     3. HAS NO PRIME FACTOR GREATER THAN 23, AND
C     4. THE PRODUCT OF THE SQUARE FREE PRIME FACTORS OF
C        (NFFT-2)/NDIV DO NOT EXCEED 210 IF NDIV = 2, AND
C                                    105 IF NDIV = 4.
C     THE VALUE OF NFFT THUS MEET THE REQUIREMENTS OF
C     THE EXTENDED LENGTH OF THE SERIES REQUIRED FOR ANY ROUTINE
C     USING THE SINGLETON FFT PROVIDING THE PROPER VALUE OF NDIV
C     IS CHOSEN.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NDIV,NFFT
C
C  LOCAL SCALARS
      INTEGER
     +   I,NPF,NSFP
C
C  LOCAL ARRAYS
      INTEGER
     +   IPF(50),IPFEXP(50)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL FACTOR
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MOD
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C       AN INDEX VARIABLE.
C     INTEGER IPF(50), IPFEXP(50)
C        THE VECTORS OF PRIME FACTORS OF NFFT AND THEIR EXPONENTS,
C        RESPECTIVELY, WHERE THE LENGTH OF THESE VECTORS IS
C        SUFFICIENT TO ACCOMODATE THE PRIME FACTORS OF AN INTEGER
C        UP TO 2 ** 128 (APPROXIMATELY 10 ** 40).
C     INTEGER N
C        THE NUMBER UPON WHICH NFFT IS BASED.
C     INTEGER NDIV
C        A REQUIRED FACTOR OF NFFT - 2.
C     INTEGER NFFT
C        THE RETURNED VALUE WHICH MEETS THE ABOVE DESCRIPTION.
C     INTEGER NPF
C        THE NUMBER OF PRIME FACTORS IN NFFT.
C     INTEGER NSFP
C        THE PRODUCT OF THE NON SQUARE FACTORS.
C
      NFFT = N
      IF (NFFT.LE.0) RETURN
      IF (MOD(NFFT, NDIV) .NE. 0) NFFT = NFFT + NDIV - MOD(NFFT, NDIV)
      NFFT = NFFT - NDIV
   20 NFFT = NFFT + NDIV
      CALL FACTOR(NFFT/NDIV, NPF, IPF, IPFEXP)
      IF ((NPF.GE.11) .OR. (IPF(NPF).GT.23)) GO TO 20
      NSFP = 1
      IF (NDIV.EQ.4) NSFP = 2
      DO 30 I = 1, NPF
         IF (MOD(IPFEXP(I), 2).EQ.1) NSFP = NSFP * IPF(I)
   30 CONTINUE
      IF (NSFP .GE. 210) GO TO 20
C
      NFFT = NFFT + 2
C
      RETURN
C
      END
*SETFRQ
      SUBROUTINE SETFRQ (FREQ, NF, NPRT, FMIN, FMAX, H)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE FREQUENCIES AT WHICH THE
C     SPECTRUM IS TO BE ESTIMATED.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN,H
      INTEGER
     +   NF,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTAF
      INTEGER
     +   I
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG10
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTAF
C        THE FREQUENCY INCREMENT.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCIES AT WHICH THE
C        SPECTRUM IS TO BE ESTIMATED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        ESTIMATED.
C     DOUBLE PRECISION H
C        THE SAMPLING INTERVAL.
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
C        ARE TO BE ESTIMATED.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT EQUALS 2 THE FREQUENCY SCALE IS LINEAR, AND IF
C        NPRT EQUALS 3 THE FREQUENCY SCALE IS LOG.
C
      IF (NPRT .EQ. 3) GO TO 20
C
C     COMPUTE FREQUENCY VALUES FOR LINEAR SCALE
C
      FREQ(1) = FMIN
C
      IF (NF .EQ. 1) RETURN
C
      DELTAF = (FMAX - FMIN) / (H * (NF - 1))
      DO 10 I = 2, NF
         FREQ(I) = FREQ(I-1) + DELTAF
   10 CONTINUE
C
      FREQ(NF) = FMAX
      RETURN
C
   20 CONTINUE
C
C     COMPUTE FREQUENCY VALUES FOR LOG SCALE
C
      DELTAF = (LOG10(FMAX) - LOG10(FMIN)) / (H * (NF - 1))
C
      FREQ(1) = FMIN
C
      IF (NF .EQ. 1) RETURN
C
      DO 30 I = 2, NF
         FREQ(I) = 10.0D0**(LOG10(FREQ(I-1)) + DELTAF)
   30 CONTINUE
C
      FREQ(NF) = FMAX
C
C
      RETURN
      END
*SETIV
      SUBROUTINE SETIV(VECTOR, N, VALUE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SETS THE FIRST N ELEMENTS OF AN INTEGER VECTOR
C
C     WRITTEN BY  -  JOHN E. KOONTZ
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C        ADAPTED FROM SETRV, WRITTEN BY LINDA L. MITCHELL
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,VALUE
C
C  ARRAY ARGUMENTS
      INTEGER
     +   VECTOR(N)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        *
C     INTEGER N
C        NUMBER OF ELEMENTS TO SET
C     INTEGER VALUE
C        VALUE TO WHICH THE ELEMENTS ARE TO BE SET
C     INTEGER VECTOR(N)
C        VECTOR WHOSE FIRST N ELEMENTS ARE TO BE SET.
C
      DO 10 I=1,N
         VECTOR(I) = VALUE
   10 CONTINUE
C
      RETURN
C
      END
*SETLAG
      SUBROUTINE SETLAG (N, LAGMAX)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SETS THE NUMBER OF AUTOCORRELATIONS TO BE
C     COMPUTED.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LAGMAX,N
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER LAGMAX
C        THE NUMBER OF LAGS AT WHICH THE AUTOCOVARIANCES ARE TO BE
C        COMPUTED.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C
      IF (N .GE. 96)                 LAGMAX = MIN(N / 3, 100)
      IF (33 .LE. N .AND. N .LE. 95) LAGMAX = 32
      IF (N .LE. 32)                 LAGMAX = N - 1
      RETURN
      END
*SETRA
      SUBROUTINE SETRA(ARRAY, IM, M, N, VALUE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     SETS THE FIRST N ROWS AND M COLUMNS OF THE ARRAY
C
C     WRITTEN BY  -  LINDA L. MITCHELL
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VALUE
      INTEGER
     +   IM,M,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ARRAY(IM,M)
C
C  LOCAL SCALARS
      INTEGER
     +   I,J
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ARRAY(IM,M)
C        ARRAY FOR WHICH ELEMENTS WILL BE SET
C     INTEGER I
C        *
C     INTEGER IM
C        ACTUAL FIRST DIMENSION OF ARRAY IN CALLING PROGRAM
C     INTEGER J
C        *
C     INTEGER M
C        NUMBER OF COLUMNS TO SET
C     INTEGER N
C        NUMBER OF ROWS TO SET
C     DOUBLE PRECISION VALUE
C        VALUE TO WHICH THE ELEMENTS ARE TO BE SET
C
C
      DO 20 I=1,N
         DO 10 J=1,M
            ARRAY(I,J) = VALUE
   10    CONTINUE
   20 CONTINUE
      RETURN
      END
*SETROW
      SUBROUTINE SETROW (NROW, XM, N, M, IXM, NROWU)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SELECTS THE ROW USED BY THE DERIVATIVE CHECKING
C     PROCEDURE.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NROW,NROWU
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   XM(IXM,M)
C
C  LOCAL SCALARS
      INTEGER
     +   I,J
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS OF DATA.
C     INTEGER NROW, NROWU
C        THE USER-SUPPLIED NUMBER OF THE ROW OF THE INDEPENDENT
C        VARIABLE ARRAY AT WHICH THE DERIVATIVE IS TO BE CHECKED,
C        AND THE NUMBER OF THE ROW ACTUALLY USED.
C     DOUBLE PRECISION XM(IXM,M)
C        THE INDEPENDENT VARIABLE MATRIX.
C
      NROWU = NROW
C
      IF ((NROWU.GE.1) .AND. (NROWU.LE.N)) RETURN
C
C     SELECT FIRST ROW OF INDEPENDENT VARIABLES WHICH CONTAINS NO ZEROS
C     IF THERE IS ONE, OTHERWISE FIRST ROW IS USED.
C
      DO 20 I = 1, N
         DO 10 J = 1, M
            IF (XM(I,J) .EQ. 0.0D0) GO TO 20
   10    CONTINUE
         NROWU = I
         RETURN
   20 CONTINUE
C
      NROWU = 1
C
      RETURN
      END
*SETRV
      SUBROUTINE SETRV(VECTOR, N, VALUE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SETS THE FIRST N ELEMENTS OF VECTOR
C
C     WRITTEN BY  -  LINDA L. MITCHELL
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VALUE
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VECTOR(N)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        *
C     INTEGER N
C        NUMBER OF ELEMENTS TO SET
C     DOUBLE PRECISION VALUE
C        VALUE TO WHICH THE ELEMENTS ARE TO BE SET
C     DOUBLE PRECISION VECTOR(N)
C        VECTOR WHOSE FIRST N ELEMENTS ARE TO BE SET.
C
      DO 10 I=1,N
         VECTOR(I) = VALUE
   10 CONTINUE
C
      RETURN
C
      END
*SLFLT
      SUBROUTINE SLFLT (Y, N, K, H, YF, NYF)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PERFORMS A SYMMETRIC FILTERING OPERATION
C     ON AN INPUT SERIES Y, RETURNING THE FILTERED SERIES IN YF.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   K,N,NYF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   H(*),Y(*),YF(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,HEAD
C
C  LOCAL ARRAYS
      CHARACTER
     +   LH(8)*1,LK(8)*1,LN(8)*1,LONE(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,ERIODD,ERSLF,FLTSL,IPRINT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01, ERR02, ERR03, ERR04
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     DOUBLE PRECISION H(K)
C        THE ARRAY OF SYMMETRIC LINEAR FILTER COEFFICIENTS.
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     INTEGER K
C        THE NUMBER OF FILTER TERMS.
C     CHARACTER*1 LH(8), LK(8), LN(8), LONE(8)
C        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES K AND N.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NYF
C        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YF(N)
C        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'S',       'L',       'F',       'L',       'T',       ' '/
      DATA
     +  LH(1), LH(2), LH(3), LH(4), LH(5), LH(6), LH(7), LH(8)
     + /  'H',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LONE(1), LONE(2), LONE(3), LONE(4), LONE(5), LONE(6), LONE(7),
     +  LONE(8) /'O', 'N', 'E', ' ', ' ', ' ', ' ', ' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 3, 1, HEAD, ERR01, LN)
C
      CALL EISII(NMSUB, LK, K, 1, N, 1, HEAD, ERR02, LONE, LN)
C
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR03)
C
      IF (ERR01 .OR. ERR02 .OR. ERR03) GO TO 10
C
      CALL ERSLF(NMSUB, LH, K, H, HEAD, ERR04)
C
      IF (.NOT. ERR04) GO TO 20
C
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   20 CONTINUE
C
      CALL FLTSL (Y, N, K, H, YF, NYF)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   39H       CALL SLFLT (Y, N, K, H, YF, NYF))
      END
*SMPLY
      SUBROUTINE SMPLY (Y, N, NS, YS, NYS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE SAMPLES EVERY KTH OBSERVATION FROM THE INPUT
C     SERIES Y, STORING THE SAMPLED SERIES IN YS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DEVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NS,NYS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(N),YS(N)
C
C  LOCAL SCALARS
      INTEGER
     +   I,I1
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I, I1
C        INDEXING VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     INTEGER NS
C        THE SAMPLING RATE.
C     INTEGER NYS
C        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YS.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YS(N)
C        THE VECTOR IN WHICH THE SAMPLED SERIES IS RETURNED.
C
      NYS = 0
      DO 30 I = 1, N, NS
         NYS = NYS + 1
         YS(NYS) = Y(I)
   30 CONTINUE
      I1 = NYS + 1
      DO 40 I = I1, N
         YS(I) = 0.0D0
   40 CONTINUE
C
      RETURN
      END
*SPCCK
      SUBROUTINE SPCCK (SPC, ISORT, NF, SPCMN, SPCMX, NSPC, ISPCER)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE ANALYZES THE ORDINATES FOR THE SPECTRAL SEMI LOG
C     PLOTS PRODUCED BY THE ASPC SERIES OF ROUTINES.  Y AXIS VALUES
C     (YORD) MORE THAN 3 POWERS OF TEN LESS THAN THE NEXT LARGER
C     VALUE ARE CONSIDERED INSIGNIFICANT AND ARE CULLED FROM THE
C     ORDINATES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SPCMN,SPCMX
      INTEGER
     +   ISPCER,NF,NSPC
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   SPC(NF)
      INTEGER
     +   ISORT(NF)
C
C  LOCAL SCALARS
      INTEGER
     +   I,K1,K2,LOG1,LOG2
C
C  EXTERNAL SUBROUTINES
      EXTERNAL SRTIR,SRTRI
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG10
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER ISORT(NF)
C        THE ARRAY IN WHICH THE ORDER PERMUTATION FOR THE SORTED
C        DATA IS STORED.
C     INTEGER ISPCER
C        AN INDICATOR VARIABLE USED TO SUPRESS THE SPECTRAL PLOTS
C        WHEN FEWER THAN 1 VALID SPECTRAL VALUES WERE COMPUTED.
C     INTEGER K1, K2
C        INDEX VARIABLES.
C     INTEGER LOG1, LOG2
C        THE ORDER OF THE SPECTRAL ESTIMATES.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
C        ARE TO BE ESTIMATED.
C     INTEGER NSPC
C        THE NUMBER OF VALID SPECTRAL ESTIMATES.
C     DOUBLE PRECISION SPC(NF)
C        THE ARRAY CONTAINING THE SPECTRAL ESTIMATES.
C     DOUBLE PRECISION SPCMN, SPCMX
C        THE MINIMUM AND MAXIMUM SPECTRAL VALUE TO BE PLOTTED.
C
C     ORDER THE SPECTRAL ESTIMATES FROM SMALLEST TO LARGEST.
C
      DO 10 I = 1, NF
         ISORT(I) = I
   10 CONTINUE
      CALL SRTIR (ISORT, NF, SPC)
C
C     DETERMINE SIGINIFICANT VALUES TO BE PLOTTED.
C
      K1 = NF
      K2 = K1
      IF ((SPC(NF) .LE. 0.0D0) .OR. (NF.EQ.1)) GO TO 30
      LOG1 = LOG10(SPC(NF))
      IF (SPC(NF) .LT. 1.0D0) LOG1 = LOG1 - 1
      DO 20 I = 2, NF
         K2 = K1 - 1
         IF (SPC(K2) .LE. 0.0D0) GO TO 30
         LOG2 = LOG10(SPC(K2))
         IF (SPC(K2) .LT. 1.0D0) LOG2 = LOG2 - 1
         IF (LOG1-LOG2 .GE. 3 .AND. NF-K2 .GE. 5) GO TO 30
         LOG1 = LOG2
         K1 = K2
   20 CONTINUE
C
   30 SPCMN = SPC(K1)
      NSPC = NF + 1 - K1
C
      SPCMX = SPC(NF)
C
      CALL SRTRI (SPC, NF, ISORT)
      ISPCER = 0
      IF (NF-K2 .LE. 0) ISPCER = 1
C
      RETURN
      END
*SPP
      SUBROUTINE SPP(YM, X, N, ISYM)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT WITH USER CONTROL OF PLOT SYMBOLS (SHORT CALL).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
      INTEGER
     +   ISYM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   ILOG,IPRT,ISCHCK,ISIZE,IYM,LISYM,M,NOUT
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(N)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(N,1)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C     THE LABELED COMMON FOR COMMUNICATING ERROR FLAGS TO THE USER
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'P',       'P',       ' ',       ' ',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      YMMISS(1) = 1.0D0
      XMISS = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 1
      ISIZE = -1
      NOUT = 0
      MISS = .FALSE.
      LISYM = N
C
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL SPP (Y, X, N, ISYM)')
      END
*SPPC
      SUBROUTINE SPPC(YM, X, N, ISYM, ILOG, ISIZE, NOUT, YLB, YUB,
     +  XLB, XUB)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT WITH USER CONTROL OF PLOT SYMBOLS (LONG CALL).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   ILOG,ISIZE,N,NOUT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
      INTEGER
     +   ISYM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   IPRT,ISCHCK,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(N)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(N,1)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'P',       'P',       'C',       ' ',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      YMMISS(1) = 1.0D0
      XMISS = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      ISCHCK = 1
      MISS = .FALSE.
      LISYM = N
C
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL SPPC (Y, X, N, ISYM, ILOG,'/
     +  '      +           ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      END
*SPPL
      SUBROUTINE SPPL(YM, X, N, ISYM, ILOG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT WITH USER CONTROL OF PLOT SYMBOLS (LOG OPTION).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
      INTEGER
     +   ISYM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   IPRT,ISCHCK,ISIZE,IYM,LISYM,M,NOUT
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(N)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(N,1)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'P',       'P',       'L',       ' ',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      YMMISS(1) = 1.0D0
      XMISS = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 1
      ISIZE = -1
      NOUT = 0
      MISS = .FALSE.
      LISYM = N
C
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL SPPL (Y, X, N, ISYM, ILOG)')
      END
*SPPLTC
      SUBROUTINE SPPLTC (XAXIS, YAXIS, ISYM, NPTS, XPLTMN, XPLTMX, BW,
     +   CILOW, CIMID, CIUP, LPCV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRODUCES CONFIDENCE INTERVAL AND BANDWIDTH
C     CO-ORDINATES FOR THE SPECTRUM PLOTS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   BW,CILOW,CIMID,CIUP,XPLTMN,XPLTMX
      INTEGER
     +   LPCV,NPTS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISYM(LPCV)
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION BW
C       THE BANDWIDTH.
C     DOUBLE PRECISION CILOW, CIMID, CIUP
C        THE Y CORDNATES FOR THE LOWER  MID AND UPPER CONFIDENCE
C        INTERVAL POINTS.
C     INTEGER ISYM(LPCV)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LPCV
C        THE LENGTH OF THE VECTORS USED FOR THE PLOTS.
C     INTEGER NPTS
C        THE NUMBER OF CO-ORDINATES TO BE PLOTTED.
C     DOUBLE PRECISION XAXIS(LPCV)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION XPLTMN, XPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
C     DOUBLE PRECISION YAXIS(LPCV)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
C
      IF (XPLTMX - XPLTMN .GE. BW) GO TO 10
C
      XPLTMX = MAX(XPLTMX + (BW - XPLTMX + XPLTMN) / 2.0D0, 0.5D0)
      XPLTMN = XPLTMX - BW
C
   10 CONTINUE
C
      NPTS = NPTS + 1
C
      XAXIS(NPTS) = XPLTMX - 0.5D0 * BW
      YAXIS(NPTS) = CIUP
      ISYM(NPTS) = 7
C
      NPTS = NPTS + 1
C
      XAXIS(NPTS) = XPLTMX - 0.5D0 * BW
      YAXIS(NPTS) = CIMID
      ISYM(NPTS) = 3
C
      NPTS = NPTS + 1
C
      XAXIS(NPTS) = XPLTMX - 0.5D0 * BW
      YAXIS(NPTS) = CILOW
      ISYM(NPTS) = 13
C
      NPTS = NPTS + 1
C
      XAXIS(NPTS) = XPLTMX - BW
      YAXIS(NPTS)  = CIMID
      ISYM(NPTS) = 6
C
      NPTS = NPTS + 1
C
      XAXIS(NPTS) = XPLTMX
      YAXIS(NPTS)  = CIMID
      ISYM(NPTS) = 27
C
      RETURN
      END
*SPPLTD
      SUBROUTINE SPPLTD (SPCMN, SPCMX, ALOW, AUP, YPLTMN, YPLTMX,
     +   CILOW, CIMID, CIUP, YMAX)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SETS VARIOUS Y AXIS LIMITS FOR DECIBLE
C     SPECTRUM PLOTS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALOW,AUP,CILOW,CIMID,CIUP,SPCMN,SPCMX,YMAX,YPLTMN,YPLTMX
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RNGMN,YMIN
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,LOG10
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALOW, AUP
C        FACTORS USED TO COMPUTE THE CONFIDENCE INTERVALS.
C     DOUBLE PRECISION CILOW, CIMID, CIUP
C        THE Y CORDNATES FOR THE LOWER  MID AND UPPER CONFIDENCE
C        INTERVAL POINTS.
C     DOUBLE PRECISION RNGMN
C        THE MINIMUM Y AXIS RANGE FOR THE PLOT.
C     DOUBLE PRECISION SPCMN, SPCMX
C        THE MINIMUM AND MAXIMUM SPECTRAL VALUE TO BE PLOTTED.
C     DOUBLE PRECISION YMAX, YMIN
C        THE MAXIMUM AND MINIMUM ACTUAL SPECTRAL VALUE
C        (IN DECIBELS) TO BE PLOTTED.
C     DOUBLE PRECISION YPLTMN, YPLTMX
C        THE MINIMUM AND MAXIMUM VAUES TO BE PLOTTED FOR THE Y AXIS.
C
C     SET CO-ORDINATES FOR DECIBLE PLOTS
C
      YMAX = 10.0D0 * LOG10(SPCMX)
      YMIN = 10.0D0 * LOG10(SPCMN) - YMAX
C
      YPLTMX = 0.0D0
      RNGMN = 20.0D0 * (LOG10(AUP) - LOG10(ALOW))
      IF (ABS(YMIN) .LT. RNGMN) YPLTMX = (RNGMN + YMIN) * 0.5D0
      YPLTMN = YMIN - YPLTMX
      CIUP = YPLTMX
      CIMID = CIUP - 10.0D0 * LOG10(AUP)
      CILOW = CIMID + 10.0D0 * LOG10(ALOW)
C
      RETURN
      END
*SPPLTL
      SUBROUTINE SPPLTL (SPCMN, SPCMX, ALOW, AUP, YPLTMN, YPLTMX,
     +   CILOW, CIMID, CIUP)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SETS VARIOUS Y AXIS LIMITS FOR DECIBLE
C     SPECTRUM PLOTS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALOW,AUP,CILOW,CIMID,CIUP,SPCMN,SPCMX,YPLTMN,YPLTMX
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RNGMN,YMAX,YMIN
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG10
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALOW, AUP
C        FACTORS USED TO COMPUTE THE CONFIDENCE INTERVALS.
C     DOUBLE PRECISION CILOW, CIMID, CIUP
C        THE Y CORDNATES FOR THE LOWER  MID AND UPPER CONFIDENCE
C        INTERVAL POINTS.
C     DOUBLE PRECISION RNGMN
C        THE MINIMUM Y AXIS RANGE FOR THE PLOT.
C     DOUBLE PRECISION SPCMN, SPCMX
C        THE MINIMUM AND MAXIMUM SPECTRAL VALUE TO BE PLOTTED.
C     DOUBLE PRECISION YMAX, YMIN
C        THE MAXIMUM AND MINIMUM ACTUAL SPECTRUM VALUE TO BE PLOTTED.
C     DOUBLE PRECISION YPLTMN, YPLTMX
C        THE MINIMUM AND MAXIMUM VAUES TO BE PLOTTED FOR THE Y AXIS.
C
C     SET CO-ORDINATES FOR DECIBLE PLOTS
C
      YMAX = LOG10(SPCMX)
      YMIN = LOG10(SPCMN)
C
      YPLTMX = SPCMX
      YPLTMN = SPCMN
      RNGMN = 2.0D0 * (LOG10(AUP) - LOG10(ALOW))
      IF (YMAX - YMIN .GE. RNGMN) GO TO 10
C
      YPLTMX = 10.0D0 ** (YMAX + (RNGMN - YMAX + YMIN) * 0.5D0)
      YPLTMN = 10.0D0 ** (YMIN - (RNGMN - YMAX + YMIN) * 0.5D0)
C
   10 CIUP = YPLTMX
      CIMID = CIUP / AUP
      CILOW = CIMID * ALOW
C
      RETURN
      END
*SPPM
      SUBROUTINE SPPM(YM, YMMISS, X, XMISS, N, ISYM)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT WITH USER CONTROL OF PLOT SYMBOLS AND WITH MISSING
C     OBSERVATIONS (SHORT CALL).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(1)
      INTEGER
     +   ISYM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   ILOG,IPRT,ISCHCK,ISIZE,IYM,LISYM,M,NOUT
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(N)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(N,1)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'P',       'P',       'M',       ' ',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      M = 1
      IYM = N
      MULTI = .FALSE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 1
      ISIZE = -1
      NOUT = 0
      MISS = .TRUE.
      LISYM = N
C
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL SPPM (Y, YMISS, X, XMISS, N, ISYM)')
      END
*SPPMC
      SUBROUTINE SPPMC(YM, YMMISS, X, XMISS, N, ISYM, ILOG, ISIZE, NOUT,
     +   YLB, YUB, XLB, XUB)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT WITH USER CONTROL OF PLOT SYMBOLS AND WITH MISSING
C     OBSERVATIONS (LONG CALL).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   ILOG,ISIZE,N,NOUT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(1)
      INTEGER
     +   ISYM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,ISCHCK,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(N)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(N,1)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'P',       'P',       'M',       'C',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      M = 1
      IYM = N
      MULTI = .FALSE.
      ISCHCK = 1
      MISS = .TRUE.
      LISYM = N
C
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL SPPMC (Y, YMISS, X, XMISS, N, ISYM, ILOG,'/
     +   '      +            ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      END
*SPPML
      SUBROUTINE SPPML(YM, YMMISS, X, XMISS, N, ISYM, ILOG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
C     PLOT WITH USER CONTROL OF PLOT SYMBOLS AND WITH MISSING
C     OBSERVATIONS (LOG OPTION).
C
C     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   ILOG,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(1)
      INTEGER
     +   ISYM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   IPRT,ISCHCK,ISIZE,IYM,LISYM,M,NOUT
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(N)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     DOUBLE PRECISION X(N)
C        VECTOR OF OBSERVATIONS FOR X COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(N,1)
C        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'P',       'P',       'M',       'L',       ' '/
C
C     COMMENCE BODY OF ROUTINE
C
C     SET DEFAULT VALUES
C
      M = 1
      IYM = N
      MULTI = .FALSE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 1
      ISIZE = -1
      NOUT = 0
      MISS = .TRUE.
      LISYM = N
C
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL SPPML (Y, YMISS, X, XMISS, N, ISYM, ILOG)')
      END
*SRTIR
      SUBROUTINE SRTIR(IR, LA, A)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C   FUNCTION     SRTIR  - SORT INTEGER ARRAY IR ON KEY ARRAY A.
C                           IF THE INTEGER ARRAY CONSISTS OF THE
C                           ORDERED SEQUENCE 1, 2, ... LA, THEN
C                           ON COMPLETION IR IS  A PERMUTATION
C                           VECTOR FOR THE SORT OF A.
C   USAGE               - CALL SRTIR (A,LA,IR)
C   PARAMETERS   A(LA)  - ON INPUT, CONTAINS THE ARRAY TO BE SORTED ON
C                         ON OUTPUT, A CONTAINS THE SORTED ARRAY
C                LA     - INPUT VARIABLE CONTAINING THE NUMBER OF
C                           ELEMENTS IN THE ARRAY TO BE SORTED
C                IR(LA) - IF ON INPUT, IR CONTAINS THE INTEGER VALUES
C                           1,2,...,LA.
C                       - THEN ON OUTPUT, IR CONTAINS A RECORD OF THE
C                           PERMUTATIONS MADE ON THE VECTOR A.
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LA
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   A(LA)
      INTEGER
     +   IR(LA)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   R,T,TT
      INTEGER
     +   I,IJ,IT,ITT,J,K,L,M
C
C  LOCAL ARRAYS
      INTEGER
     +   IL(21),IU(21)
C
C  INTRINSIC FUNCTIONS
      INTRINSIC INT
C
C
      M = 1
      I = 1
      J = LA
      R = .375D0
   10 IF (I.EQ.J) GO TO 90
      IF (R.GT.0.5898437D0) GO TO 20
      R = R + 3.90625D-2
      GO TO 30
   20 R = R - .21875D0
   30 K = I
C                                  SELECT A CENTRAL ELEMENT OF THE
C                                  ARRAY AND SAVE IT IN LOCATION T
      IJ = I + INT((J-I)*R)
      T = A(IJ)
      IT = IR(IJ)
C                                  IF FIRST ELEMENT OF ARRAY IS GREATER
C                                  THAN T, INTERCHANGE WITH T
      IF (A(I).LE.T) GO TO 40
      A(IJ) = A(I)
      A(I) = T
      T = A(IJ)
      IR(IJ) = IR(I)
      IR(I) = IT
      IT = IR(IJ)
   40 L = J
C                                  IF LAST ELEMENT OF ARRAY IS LESS THAN
C                                  T, INTERCHANGE WITH T
      IF (A(J).GE.T) GO TO 60
      A(IJ) = A(J)
      A(J) = T
      T = A(IJ)
      IR(IJ) = IR(J)
      IR(J) = IT
      IT = IR(IJ)
C                                  IF FIRST ELEMENT OF ARRAY IS GREATER
C                                  THAN T, INTERCHANGE WITH T
      IF (A(I).LE.T) GO TO 60
      A(IJ) = A(I)
      A(I) = T
      T = A(IJ)
      IR(IJ) = IR(I)
      IR(I) = IT
      IT = IR(IJ)
      GO TO 60
   50 TT = A(L)
      A(L) = A(K)
      A(K) = TT
      ITT = IR(L)
      IR(L) = IR(K)
      IR(K) = ITT
C                                  FIND AN ELEMENT IN THE SECOND HALF OF
C                                  THE ARRAY WHICH IS SMALLER THAN T
   60 L = L - 1
      IF (A(L).GT.T) GO TO 60
C                                  FIND AN ELEMENT IN THE FIRST HALF OF
C                                  THE ARRAY WHICH IS GREATER THAN T
   70 K = K + 1
      IF (A(K).LT.T) GO TO 70
C                                  INTERCHANGE THESE ELEMENTS
      IF (K.LE.L) GO TO 50
C                                  SAVE UPPER AND LOWER SUBSCRIPTS OF
C                                  THE ARRAY YET TO BE SORTED
      IF (L-I.LE.J-K) GO TO 80
      IL(M) = I
      IU(M) = L
      I = K
      M = M + 1
      GO TO 100
   80 IL(M) = K
      IU(M) = J
      J = L
      M = M + 1
      GO TO 100
C                                  BEGIN AGAIN ON ANOTHER PORTION OF
C                                  THE UNSORTED ARRAY
   90 M = M - 1
      IF (M.EQ.0) RETURN
      I = IL(M)
      J = IU(M)
  100 IF (J-I.GE.1) GO TO 30
      IF (I.EQ.1) GO TO 10
      I = I - 1
  110 I = I + 1
      IF (I.EQ.J) GO TO 90
      T = A(I+1)
      IT = IR(I+1)
      IF (A(I).LE.T) GO TO 110
      K = I
  120 A(K+1) = A(K)
      IR(K+1) = IR(K)
      K = K - 1
      IF (T.LT.A(K)) GO TO 120
      A(K+1) = T
      IR(K+1) = IT
      GO TO 110
      END
*SRTIRR
      SUBROUTINE SRTIRR(IR, RR, LA, A)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SORTS THE LENGTH LA ARRAY A, THE LENGTH LA
C     INTEGER ARRAY IR, AND THE LENGTH LA ARRAY RR INTO
C     ASCENDING ORDER, BASED ON THE VALUES IN A.  THE ARRAY
C     A CONSTITUTES THE SORTING KEY.  THE OTHER TWO ARRAYS ARE
C     CARRIED ALONG.  ORDINARILY THE ARRAY IR CONTAINS THE
C     VALUES 1, ..., LA INITIALLY, SO THAT THE THREE ARRAYS CAN
C     LATER BE SORTED AGAIN WITH IR AS THE KEY, IN ORDER TO
C     RESTORE A AND RR TO THEIR ORIGINAL ORDER.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C        (BASED CLOSELY ON THE IMSL CDC LIBRARY 3 ROUTINE VSORTP)
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LA
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   A(LA),RR(LA)
      INTEGER
     +   IR(LA)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   R,RT,RTT,T,TT
      INTEGER
     +   I,IJ,IT,ITT,J,K,L,M
C
C  LOCAL ARRAYS
      INTEGER
     +   IL(21),IU(21)
C
C  INTRINSIC FUNCTIONS
      INTRINSIC INT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION A(LA)
C        INPUT/OUTPUT PARAMETER.  THE KEY ARRAY.
C     INTEGER I
C        *
C     INTEGER IJ
C        *
C     INTEGER IL(21)
C        *
C     INTEGER IR(LA)
C        INPUT/OUTPUT PARAMETER.  THE INTEGER ARRAY CARRIED ALONG
C        IN THE SORT.  INITIALLY IT SHOULD CONTAIN 1, ..., LA.
C        ON EXIT IT CONTAINS THE PERMUTATION VECTOR OF THE SORT.
C        SORTING ON THE PERMUTATION VECTOR WILL RESTORE THE KEY
C        ARRAY A AND THE ARRAY RR TO THEIR ORIGINAL ORDERS.
C     INTEGER IT
C        *
C     INTEGER ITT
C        *
C     INTEGER IU(21)
C        *
C     INTEGER J
C        *
C     INTEGER K
C        *
C     INTEGER L
C        *
C     INTEGER LA
C        INPUT PARAMETER.  THE LENGTH OF THE INPUT/OUTPUT PARAMETERS
C        A, IR, AND RR.
C     INTEGER M
C        *
C     DOUBLE PRECISION R
C        *
C     DOUBLE PRECISION RR(LA)
C        INPUT/OUTPUT PARAMETER.  THE ARRAY CARRIED ALONG IN
C        THE SORT.  IT MIGHT BE THE SET OF WEIGHTS FOR A.
C     DOUBLE PRECISION RT
C        *
C     DOUBLE PRECISION RTT
C        *
C     DOUBLE PRECISION T
C        *
C     DOUBLE PRECISION TT
C
      M = 1
      I = 1
      J = LA
      R = .375D0
   10 IF (I.EQ.J) GO TO 90
      IF (R.GT.0.5898437D0) GO TO 20
      R = R + 3.90625D-2
      GO TO 30
   20 R = R - .21875D0
   30 K = I
C                                  SELECT A CENTRAL ELEMENT OF THE
C                                  ARRAY AND SAVE IT IN LOCATION T
      IJ = I + INT((J-I)*R)
      T = A(IJ)
      IT = IR(IJ)
      RT = RR(IJ)
C                                  IF FIRST ELEMENT OF ARRAY IS GREATER
C                                  THAN T, INTERCHANGE WITH T
      IF (A(I).LE.T) GO TO 40
      A(IJ) = A(I)
      A(I) = T
      T = A(IJ)
      IR(IJ) = IR(I)
      IR(I) = IT
      IT = IR(IJ)
      RR(IJ) = RR(I)
      RR(I) = RT
      RT = RR(IJ)
   40 L = J
C                                  IF LAST ELEMENT OF ARRAY IS LESS THAN
C                                  T, INTERCHANGE WITH T
      IF (A(J).GE.T) GO TO 60
      A(IJ) = A(J)
      A(J) = T
      T = A(IJ)
      IR(IJ) = IR(J)
      IR(J) = IT
      IT = IR(IJ)
      RR(IJ) = RR(J)
      RR(J) = RT
      RT = RR(IJ)
C                                  IF FIRST ELEMENT OF ARRAY IS GREATER
C                                  THAN T, INTERCHANGE WITH T
      IF (A(I).LE.T) GO TO 60
      A(IJ) = A(I)
      A(I) = T
      T = A(IJ)
      IR(IJ) = IR(I)
      IR(I) = IT
      IT = IR(IJ)
      RR(IJ) = RR(I)
      RR(I) = RT
      RT = RR(IJ)
      GO TO 60
   50 TT = A(L)
      A(L) = A(K)
      A(K) = TT
      ITT = IR(L)
      IR(L) = IR(K)
      IR(K) = ITT
      RTT = RR(L)
      RR(L) = RR(K)
      RR(K) = RTT
C                                  FIND AN ELEMENT IN THE SECOND HALF OF
C                                  THE ARRAY WHICH IS SMALLER THAN T
   60 L = L - 1
      IF (A(L).GT.T) GO TO 60
C                                  FIND AN ELEMENT IN THE FIRST HALF OF
C                                  THE ARRAY WHICH IS GREATER THAN T
   70 K = K + 1
      IF (A(K).LT.T) GO TO 70
C                                  INTERCHANGE THESE ELEMENTS
      IF (K.LE.L) GO TO 50
C                                  SAVE UPPER AND LOWER SUBSCRIPTS OF
C                                  THE ARRAY YET TO BE SORTED
      IF (L-I.LE.J-K) GO TO 80
      IL(M) = I
      IU(M) = L
      I = K
      M = M + 1
      GO TO 100
   80 IL(M) = K
      IU(M) = J
      J = L
      M = M + 1
      GO TO 100
C                                  BEGIN AGAIN ON ANOTHER PORTION OF
C                                  THE UNSORTED ARRAY
   90 M = M - 1
      IF (M.EQ.0) RETURN
      I = IL(M)
      J = IU(M)
  100 IF (J-I.GE.1) GO TO 30
      IF (I.EQ.1) GO TO 10
      I = I - 1
  110 I = I + 1
      IF (I.EQ.J) GO TO 90
      T = A(I+1)
      IT = IR(I+1)
      RT = RR(I+1)
      IF (A(I).LE.T) GO TO 110
      K = I
  120 A(K+1) = A(K)
      IR(K+1) = IR(K)
      RR(K+1) = RR(K)
      K = K - 1
      IF (T.LT.A(K)) GO TO 120
      A(K+1) = T
      IR(K+1) = IT
      RR(K+1) = RT
      GO TO 110
      END
*SRTRI
      SUBROUTINE SRTRI(A, LA, IR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C   FUNCTION     SRTRI  - SORT ARRAY A ON AN INTEGER ARRAY IR.
C                           IF THE INTEGER ARRAY IS A PERMUTATION
C                           VECTOR FOR THE ARRAY, THEN THE
C                           ARRAY IS RESTORED TO ITS ORIGINAL
C                           (UNPERMUTED) ORDER.
C                           PERMUTATIONS RETURNED
C   USAGE               - CALL SRTRI (A,LA,IR)
C   PARAMETERS   A(LA)  - ON INPUT, CONTAINS THE ARRAY TO BE SORTED
C                         ON OUTPUT, A CONTAINS THE SORTED ARRAY
C                LA     - INPUT VARIABLE CONTAINING THE NUMBER OF
C                           ELEMENTS IN THE ARRAY TO BE SORTED
C                IR(LA) - ON INPUT, CONTAINS THE INTEGER KEY ARRAY
C                         ON OUTPUT, CONTAINS THE SORTED KEY ARRAY
C                           1,2,...,LA.
C                       - THEN ON OUTPUT, IR CONTAINS A RECORD OF THE
C                           PERMUTATIONS MADE ON THE VECTOR A.
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LA
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   A(LA)
      INTEGER
     +   IR(LA)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   R,T,TT
      INTEGER
     +   I,IJ,IT,ITT,J,K,L,M
C
C  LOCAL ARRAYS
      INTEGER
     +   IL(21),IU(21)
C
C  INTRINSIC FUNCTIONS
      INTRINSIC INT
C
C
      M = 1
      I = 1
      J = LA
      R = .375D0
   10 IF (I.EQ.J) GO TO 90
      IF (R.GT.0.5898437D0) GO TO 20
      R = R + 3.90625D-2
      GO TO 30
   20 R = R - .21875D0
   30 K = I
C                                  SELECT A CENTRAL ELEMENT OF THE
C                                  ARRAY AND SAVE IT IN LOCATION IT
      IJ = I + INT((J-I)*R)
      T = A(IJ)
      IT = IR(IJ)
C                                  IF FIRST ELEMENT OF ARRAY IS GREATER
C                                  THAN IT, INTERCHANGE WITH IT
      IF (IR(I).LE.IT) GO TO 40
      A(IJ) = A(I)
      A(I) = T
      T = A(IJ)
      IR(IJ) = IR(I)
      IR(I) = IT
      IT = IR(IJ)
   40 L = J
C                                  IF LAST ELEMENT OF ARRAY IS LESS THAN
C                                  IT, INTERCHANGE WITH IT
      IF (IR(J).GE.IT) GO TO 60
      A(IJ) = A(J)
      A(J) = T
      T = A(IJ)
      IR(IJ) = IR(J)
      IR(J) = IT
      IT = IR(IJ)
C                                  IF FIRST ELEMENT OF ARRAY IS GREATER
C                                  THAN IT, INTERCHANGE WITH IT
      IF (IR(I).LE.IT) GO TO 60
      A(IJ) = A(I)
      A(I) = T
      T = A(IJ)
      IR(IJ) = IR(I)
      IR(I) = IT
      IT = IR(IJ)
      GO TO 60
   50 TT = A(L)
      A(L) = A(K)
      A(K) = TT
      ITT = IR(L)
      IR(L) = IR(K)
      IR(K) = ITT
C                                  FIND AN ELEMENT IN THE SECOND HALF OF
C                                  THE ARRAY WHICH IS SMALLER THAN IT
   60 L = L - 1
      IF (IR(L).GT.IT) GO TO 60
C                                  FIND AN ELEMENT IN THE FIRST HALF OF
C                                  THE ARRAY WHICH IS GREATER THAN IT
   70 K = K + 1
      IF (IR(K).LT.IT) GO TO 70
C                                  INTERCHANGE THESE ELEMENTS
      IF (K.LE.L) GO TO 50
C                                  SAVE UPPER AND LOWER SUBSCRIPTS OF
C                                  THE ARRAY YET TO BE SORTED
      IF (L-I.LE.J-K) GO TO 80
      IL(M) = I
      IU(M) = L
      I = K
      M = M + 1
      GO TO 100
   80 IL(M) = K
      IU(M) = J
      J = L
      M = M + 1
      GO TO 100
C                                  BEGIN AGAIN ON ANOTHER PORTION OF
C                                  THE UNSORTED ARRAY
   90 M = M - 1
      IF (M.EQ.0) RETURN
      I = IL(M)
      J = IU(M)
  100 IF (J-I.GE.1) GO TO 30
      IF (I.EQ.1) GO TO 10
      I = I - 1
  110 I = I + 1
      IF (I.EQ.J) GO TO 90
      T = A(I+1)
      IT = IR(I+1)
      IF (IR(I).LE.IT) GO TO 110
      K = I
  120 A(K+1) = A(K)
      IR(K+1) = IR(K)
      K = K - 1
      IF (IT.LT.IR(K)) GO TO 120
      A(K+1) = T
      IR(K+1) = IT
      GO TO 110
      END
*SRTRRI
      SUBROUTINE SRTRRI(A, RR, LA, IR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SORTS THE LENGTH LA INTEGER ARRAY IR, THE LENGTH LA
C     ARRAY A, AND THE LENGTH LA ARRAY RR INTO ASCENDING
C     ORDER, BASED ON THE VALUES IN IR.  THE INTEGER ARRAY IR
C     CONSTITUTES THE KEY.  THE OTHER ARRAYS ARE CARRIED ALONG.
C     ORDINARILY THE ARRAY IR CONTAINS THE PERMUTATION VECTOR
C     RESULTING FROM AN APPLICATION OF THE ROUTINE SRTIRR, SO THAT
C     SORTING ON IR RESTORES A TO THE ORDER THAT IT HAD BEFORE
C     SRTIRR WAS APPLIED.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C        (BASED CLOSELY ON THE IMSL CDC LIBRARY 3 ROUTINE VSORTP)
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LA
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   A(LA),RR(LA)
      INTEGER
     +   IR(LA)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   R,RT,RTT,T,TT
      INTEGER
     +   I,IJ,IT,ITT,J,K,L,M
C
C  LOCAL ARRAYS
      INTEGER
     +   IL(21),IU(21)
C
C  INTRINSIC FUNCTIONS
      INTRINSIC INT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION A(LA)
C        INPUT/OUTPUT PARAMETER.  THE ARRAY TO BE SORTED ON
C        THE BASIS OF THE VALUES IN IR.  IF IR IS A PERMUTATION
C        VECTOR PRODUCED ORIGINALLY IN A SORT OF A, THEN THIS
C        OPERATION RESTORES A TO ITS ORIGINAL ORDER.
C     INTEGER I
C        *
C     INTEGER IJ
C        *
C     INTEGER IL(21)
C        *
C     INTEGER IR(LA)
C        INPUT/OUTPUT PARAMETER.  THE INTEGER KEY ARRAY.  ORDINARILY
C        IT WILL BE A PERMUTATION VECTOR PRODUCED BY SOME PREVIOUS
C        SORT OF A AND RR ON A, SO THAT SORTING ON IR WILL RESTORE
C        A TO ITS ORIGINAL ORDER.
C     INTEGER IT
C        *
C     INTEGER ITT
C        *
C     INTEGER IU(21)
C        *
C     INTEGER J
C        *
C     INTEGER K
C        *
C     INTEGER L
C        *
C     INTEGER LA
C        INPUT PARAMETER.  THE LENGTH OF THE INPUT/OUTPUT PARAMETERS
C        A, RR, AND IR.
C     INTEGER M
C        *
C     DOUBLE PRECISION R
C        *
C     DOUBLE PRECISION RR(LA)
C        INPUT/OUTPUT PARAMETER.  THE ARRAY CARRIED ALONG IN
C        THE SORT.  IT MIGHT BE THE SET OF WEIGHTS FOR A.
C     DOUBLE PRECISION RT
C        *
C     DOUBLE PRECISION RTT
C        *
C     DOUBLE PRECISION T
C        *
C     DOUBLE PRECISION TT
C        *
C
      M = 1
      I = 1
      J = LA
      R = .375D0
   10 IF (I.EQ.J) GO TO 90
      IF (R.GT.0.5898437D0) GO TO 20
      R = R + 3.90625D-2
      GO TO 30
   20 R = R - .21875D0
   30 K = I
C                                  SELECT A CENTRAL ELEMENT OF THE
C                                  ARRAY AND SAVE IT IN LOCATION IT
      IJ = I + INT((J-I)*R)
      T = A(IJ)
      IT = IR(IJ)
      RT = RR(IJ)
C                                  IF FIRST ELEMENT OF ARRAY IS GREATER
C                                  THAN IT, INTERCHANGE WITH IT
      IF (IR(I).LE.IT) GO TO 40
      A(IJ) = A(I)
      A(I) = T
      T = A(IJ)
      IR(IJ) = IR(I)
      IR(I) = IT
      IT = IR(IJ)
      RR(IJ) = RR(I)
      RR(I) = RT
      RT = RR(IJ)
   40 L = J
C                                  IF LAST ELEMENT OF ARRAY IS LESS THAN
C                                  IT, INTERCHANGE WITH IT
      IF (IR(J).GE.IT) GO TO 60
      A(IJ) = A(J)
      A(J) = T
      T = A(IJ)
      IR(IJ) = IR(J)
      IR(J) = IT
      IT = IR(IJ)
      RR(IJ) = RR(J)
      RR(J) = RT
      RT = RR(IJ)
C                                  IF FIRST ELEMENT OF ARRAY IS GREATER
C                                  THAN IT, INTERCHANGE WITH IT
      IF (IR(I).LE.IT) GO TO 60
      A(IJ) = A(I)
      A(I) = T
      T = A(IJ)
      IR(IJ) = IR(I)
      IR(I) = IT
      IT = IR(IJ)
      RR(IJ) = RR(I)
      RR(I) = RT
      RT = RR(IJ)
      GO TO 60
   50 TT = A(L)
      A(L) = A(K)
      A(K) = TT
      ITT = IR(L)
      IR(L) = IR(K)
      IR(K) = ITT
      RTT = RR(L)
      RR(L) = RR(K)
      RR(K) = RTT
C                                  FIND AN ELEMENT IN THE SECOND HALF OF
C                                  THE ARRAY WHICH IS SMALLER THAN IT
   60 L = L - 1
      IF (IR(L).GT.IT) GO TO 60
C                                  FIND AN ELEMENT IN THE FIRST HALF OF
C                                  THE ARRAY WHICH IS GREATER THAN IT
   70 K = K + 1
      IF (IR(K).LT.IT) GO TO 70
C                                  INTERCHANGE THESE ELEMENTS
      IF (K.LE.L) GO TO 50
C                                  SAVE UPPER AND LOWER SUBSCRIPTS OF
C                                  THE ARRAY YET TO BE SORTED
      IF (L-I.LE.J-K) GO TO 80
      IL(M) = I
      IU(M) = L
      I = K
      M = M + 1
      GO TO 100
   80 IL(M) = K
      IU(M) = J
      J = L
      M = M + 1
      GO TO 100
C                                  BEGIN AGAIN ON ANOTHER PORTION OF
C                                  THE UNSORTED ARRAY
   90 M = M - 1
      IF (M.EQ.0) RETURN
      I = IL(M)
      J = IU(M)
  100 IF (J-I.GE.1) GO TO 30
      IF (I.EQ.1) GO TO 10
      I = I - 1
  110 I = I + 1
      IF (I.EQ.J) GO TO 90
      T = A(I+1)
      IT = IR(I+1)
      RT = RR(I+1)
      IF (IR(I).LE.IT) GO TO 110
      K = I
  120 A(K+1) = A(K)
      IR(K+1) = IR(K)
      RR(K+1) = RR(K)
      K = K - 1
      IF (IT.LT.IR(K)) GO TO 120
      A(K+1) = T
      IR(K+1) = IT
      RR(K+1) = RT
      GO TO 110
      END
*STAT
      SUBROUTINE STAT(Y, N, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE COMPUTES 53 DIFFERENT STATISTICS FOR A VECTOR
C     Y, WITH NO WEIGHTS SPECIFIED.  ONE PAGE OF AUTOMATIC
C     PRINTOUT IS PRODUCED.
C
C     WRITTEN BY - JANET R. DONALDSON, JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C        (EXTENSIVE REVISION OF OLDER VERSION)
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,SUMD2,SUMD3,SUMD4,SUMDA,SUMDI,SUMT1
      INTEGER
     +   IDP,IINT,IPRT,LSORT,MID,NALL0,NNZW
      LOGICAL
     +   STACK,WTS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   STS(53),WT(1)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GENI,IPRINT,SRTIR,SRTRI,STAT1,STAT2,STATER,STKCLR,STKSET,
     +   SUMBS,SUMDS,SUMID,SUMOT,SUMSS,SUMTS
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        THE PERCENTAGE TO BE TRIMMED OFF EACH END OF Y FOR THE
C        TRIMMED MEANS CALCULATIONS.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IDP
C        THE CODE VALUE FOR DOUBLE PRECISION FOR FRAMEWORK.
C     INTEGER IERR
C        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
C        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
C        SOME ERROR EXISTS.
C     INTEGER IINT
C        THE CODE VALUE FOR INTEGER FOR FRAMEWORK
C     INTEGER IPRT
C        THE NUMBER OF THE STANDARD OUTPUT UNIT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER LDSTAK
C        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
C        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
C     INTEGER LSORT
C        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION
C        VECTOR.
C     INTEGER MID
C        THE INDEX OF THE (AN) ELEMENT OF Y CLOSEST TO ZERO, WHEN
C        Y HAS BEEN SORTED.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF Y.
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
C        WAS CALLED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NNZW
C        NUMBER OF NONZERO WEIGHTS.
C     LOGICAL STACK
C        A FLAG INDICATING WHETHER THIS ROUTINE USES THE STACK (TRUE)
C        OR NOT (FALSE).
C     DOUBLE PRECISION STS(53)
C        THE VECTOR OF THE 53 STATISTICS COMPUTED.
C     DOUBLE PRECISION SUMDA
C        THE SUM OF THE ABSOLUTE DIFFERENCES FROM THE MEAN.
C     DOUBLE PRECISION SUMDI
C        THE SUM OF THE PRODUCTS OF THE INDICES AND THE DIFFERENCES.
C     DOUBLE PRECISION SUMD2
C        THE SUM OF THE SQUARES OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMD3
C        THE SUM OF THE CUBES OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMD4
C        THE SUM OF THE 4TH POWERS OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMT1
C        THE SUM OF THE ALPHA TRIMMED ARRAY Y.
C     DOUBLE PRECISION WT(1)
C        THE DUMMY WEIGHTS VECTOR.
C     LOGICAL WTS
C        A FLAG INDICATING WHETHER THERE ARE WEIGHTS (TRUE)
C        OR NOT (FALSE).
C     DOUBLE PRECISION Y(N)
C        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
C        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
C        TO ITS ORIGINAL ORDER AFTERWARDS.
C
C
C     INITIALIZE NAME VECTORS
C
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'S',      'T',      'A',      'T',      ' ',      ' '/
C
      DATA ALPHA /0.25D0/
      DATA IDP /4/
      DATA IINT /2/
      DATA WTS /.FALSE./
      DATA STACK /.TRUE./
C
C     CHECK FOR ERRORS IN THE INPUT PARAMETERS
C
      CALL STATER(NMSUB, WT, N, LDSTAK, WTS, NNZW, STACK, IERR)
      IF (IERR.NE.0) THEN
C
C     PRINT ERROR MESSAGE.
C
         CALL IPRINT(IPRT)
         WRITE (IPRT,1000)
         RETURN
      END IF
C
C     SET UP FRAMEWORK AREA.
C
      CALL STKSET (LDSTAK, IDP)
      NALL0 = STKST(1)
C
C     SET UP LSORT, THE PERMUTATION VECTOR.
C
      LSORT = STKGET(N,IINT)
      CALL GENI(ISTAK(LSORT), N, 1, 1)
C
C     SORT THE VECTOR Y.
C
      CALL SRTIR(ISTAK(LSORT), N, Y)
C
C     COMPUTE THE STATISTICS WHICH USE A SORTED ARRAY.
C
      CALL STAT1(Y, N, STS(5), STS(34), STS(35), STS(6),
     +   STS(11), 10, 0.0D0, 0.0D0, STS(44))
C
C     CALCULATE SUMS OF THE SORTED ARRAY.
C
      CALL SUMBS(Y, N, 1, MID, N)
      CALL SUMSS(Y, N, 1, MID, N, STS(38), STS(39), STS(42),
     +   STS(3))
      STS(4) = STS(3)
      CALL SUMTS(Y, N, ALPHA, SUMT1, STS(7))
      STS(8) = STS(7)
      CALL SUMDS(Y, N, 1, MID, N, STS(3), SUMDA, SUMD2, SUMD3, SUMD4)
C
C     RESTORE THE VECTOR Y TO ITS ORIGINAL ORDER.
C
      CALL SRTRI(Y, N, ISTAK(LSORT))
C
C     COMPUTE REST OF STATISTICS.
C
      CALL SUMID(Y, N, STS(3), SUMDI)
      CALL STAT2(Y, N, STS, SUMDA, SUMDI, SUMD2, SUMD3, SUMD4)
      CALL SUMOT(STS, N, N, WTS)
C
C     RETURN THE VECTOR LSORT.
C
      CALL STKCLR(NALL0)
      RETURN
C
C     FORMAT STATEMENTS.
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL STAT (Y, N, LDSTAK)')
      END
*STATER
      SUBROUTINE STATER(NMSUB, WT, N, LDSTAK, WTS, NNZW, STACK, IERR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE CHECKS INPUT PARAMETERS TO THE USER
C     CALLABLE MEMBERS OF THE STAT FAMILY OF ROUTINES
C     FOR ERRORS AND REPORTS ANY THAT IT FINDS, BESIDES
C     RETURNING A FLAG INDICATING THAT ERRORS HAVE BEEN
C     FOUND.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IERR,LDSTAK,N,NNZW
      LOGICAL
     +   STACK,WTS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   WT(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  LOCAL SCALARS
      INTEGER
     +   LDSMIN,NZW
      LOGICAL
     +   HEAD,IER1,IER2,IER3
C
C  LOCAL ARRAYS
      CHARACTER
     +   LLDS(8)*1,LN(8)*1,LTHREE(8)*1,LWT(8)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,ERVWT,LDSCMP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IERR
C        OUTPUT PARAMETER.  A FLAG INDICATING WHETHER OR
C        NOT AN ERROR HAS BEEN FOUND.  0 = OK, 1 = ERROR.
C     LOGICAL IER1
C        TRUE IF N .LT. 3
C     LOGICAL IER2
C        TRUE IF LDSTAK .LT. (N + 13)/2.0D0
C     LOGICAL IER3
C        TRUE IF SOME WT .LT. 0.0D0 OR NNZW .LT. 3
C     INTEGER LDSMIN
C        MINIMUM LENGTH OF FRAMEWORK AREA IN DOUBLE
C        PRECISION ELEMENTS.
C     INTEGER LDSTAK
C        INPUT PARAMETER.  THE NUMBER OF LOCATIONS PROVIDED IN
C        THE FRAMEWORK AREA.
C     CHARACTER*1 LLDS(8), LN(8), LTHREE(8), LWT(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) FO THE VARIALBE(S) CHECKED
C        FOR ERRORS
C     INTEGER N
C        INPUT PARAMETER.  THE NUMBER OF ELEMENTS IN Y AND WT.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE CALLING SUBROUTINE
C     INTEGER NNZW
C        OUTPUT PARAMETER.  IF WTS, THEN SET EQUAL TO THE
C        NUMBER OF VALUES IN WT WHICH ARE POSITIVE.  ELSE,
C        UNDEFINED.
C     INTEGER NZW
C        THE NUMBER OF ZERO WEIGHTS.
C     LOGICAL STACK
C        A FLAG INDICATING WHETHER THIS ROUTINE USES THE STACK (TRUE)
C        OR NOT (FALSE).
C     DOUBLE PRECISION WT(N)
C        INPUT PARAMETER.  THE VECTOR OF WEIGHTS CORRESPONDING
C        TO THE VECTOR Y.
C     LOGICAL WTS
C        INPUT PARAMETER.  A FLAG INDICATING WHETHER OR NOT
C        THERE IS REALLY A VECTOR WT (TRUE), OR ONLY A DUMMY PARAMETER
C        (FALSE).
C
C     INITIALIZE NAME VECTORS
C
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +  LLDS(7), LLDS(8) / 'L', 'D', 'S', 'T', 'A', 'K', ' ', ' '/
      DATA     LN(1),    LN(2),    LN(3),    LN(4),    LN(5),    LN(6),
     +  LN(7), LN(8)  / 'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA LTHREE(1),LTHREE(2),LTHREE(3),LTHREE(4),LTHREE(5),LTHREE(6),
     +  LTHREE(7), LTHREE(8) / 'T', 'H', 'R', 'E', 'E', ' ', ' ', ' '/
      DATA    LWT(1),   LWT(2),   LWT(3),   LWT(4),   LWT(5),   LWT(6),
     +  LWT(7), LWT(8) / 'W', 'T', ' ', ' ', ' ', ' ', ' ', ' '/
C
C     INITIALIZE ERROR FLAGS
C
      IER1 = .FALSE.
      IER2 = .FALSE.
      IER3 = .FALSE.
C
      IERR = 0
C
      HEAD = .TRUE.
C
C     CHECK TO SEE THAT THERE ARE AT LEAST THREE DATA POINTS.
C
      CALL EISGE(NMSUB, LN, N, 3, 2, HEAD, IER1, LTHREE)
C
C     CHECK TO SEE THAT AN AMOUNT OF WORK AREA EQUAL
C     IN LENGTH TO THE REQUIREMENTS OF THE PERMUTATION
C     VECTOR WILL BE AVAILABLE.
C
      IF (STACK) THEN
         CALL LDSCMP(1, 0, N, 0, 0, 0, 'D', 0, LDSMIN)
         CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, IER2, LLDS)
      END IF
C
C     IF THERE ARE WEIGHTS
C     CHECK TO SEE THAT AT LEAST THREE DATA ITEMS HAVE NONZERO WEIGHTS.
C
      NNZW = N
      IF (WTS) THEN
         CALL ERVWT(NMSUB, LWT, WT, N, 3, HEAD, NNZW, NZW, 1, IER3,
     +              LTHREE)
      END IF
C
C     SEE IF ANY ERRORS WERE FOUND.
C
      IF (IER1 .OR. IER2 .OR. IER3) IERR = 1
      RETURN
      END
*STATS
      SUBROUTINE STATS(Y, N, LDSTAK, STS, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE COMPUTES 53 DIFFERENT STATISTICS FOR A VECTOR
C     Y, WITH NO WEIGHTS SPECIFIED.  ONE PAGE OF AUTOMATIC
C     PRINTOUT IS PRODUCED.
C
C     WRITTEN BY - JANET R. DONALDSON, JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS
C
C     CREATION DATE  -  MAY 17, 1982
C        (EXTENSIVE REVISION OF OLDER VERSION)
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   STS(53),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,SUMD2,SUMD3,SUMD4,SUMDA,SUMDI,SUMT1
      INTEGER
     +   IDP,IINT,IPRT,LSORT,MID,NALL0,NNZW
      LOGICAL
     +   STACK,WTS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   WT(1)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GENI,IPRINT,SRTIR,SRTRI,STAT1,STAT2,STATER,STKCLR,STKSET,
     +   SUMBS,SUMDS,SUMID,SUMOT,SUMSS,SUMTS
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        THE PERCENTAGE TO TRIM FROM EACH END IN THE TRIMMED
C        MEANS.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IDP
C        FRAMEWORK CODE VALUE FOR DOUBLE PRECISION NUMBERS.
C     INTEGER IERR
C        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
C        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
C        SOME ERROR EXISTS.
C     INTEGER IINT
C        THE CODE VALUE FOR INTEGER FOR FRAMEWORK.
C     INTEGER IPRT
C        THE NUMBER OF THE STANDARD OUTPUT UNIT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER LDSTAK
C        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
C        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
C     INTEGER LSORT
C        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION
C        VECTOR.
C     INTEGER MID
C        IN THE SORTED ARRAY Y, A POINT EQUAL TO OR THE POINT
C        CLOSEST TO, ZERO.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF Y.
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
C        WAS CALLED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        INPUT PARAMETER.  FLAG TO CONTROL OUTPUT.
C        0 MEANS NO OUTPUT.  OTHER VALUES MEAN OUTPUT.
C     INTEGER NNZW
C        NUMBER OF NONZERO WEIGHTS.
C     LOGICAL STACK
C        A FLAG INDICATING WHETHER THIS ROUTINE USES THE STACK (TRUE)
C        OR NOT (FALSE).
C     DOUBLE PRECISION STS(53)
C        OUTPUT PARAMETER.  THE VECTOR OF THE 53 STATISTICS COMPUTED.
C     DOUBLE PRECISION SUMDA
C        THE SUM OF THE ABSOLUTE VALUES OF THE DIFFERENCES FROM
C        THE MEAN.
C     DOUBLE PRECISION SUMDI
C        THE SUM OF THE PRODUCTS OF THE INDEX AND DIFFERENCES.
C     DOUBLE PRECISION SUMD2
C        THE SUM OF THE SQUARE OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMD3
C        THE SUM OF THE CUBE OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMD4
C        THE SUM OF THE 4TH POWERS OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMT1
C        THE TRIMMED UNWEIGHTED SIMPLE SUM OF ELEMENTS IN Y.
C     DOUBLE PRECISION WT(1)
C        THE DUMMY WEIGHTS VECTOR.
C     LOGICAL WTS
C        A FLAG INDICATING WHETHER THERE ARE WEIGHTS (TRUE)
C        OR NOT (FALSE).
C     DOUBLE PRECISION Y(N)
C        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
C        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
C        TO ITS ORIGINAL ORDER AFTERWARDS.
C
C
C     INITIALIZE NAME VECTORS
C
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'S',      'T',      'A',      'T',      'S',      ' '/
C
      DATA ALPHA /0.25D0/
      DATA IDP /4/
      DATA IINT /2/
      DATA WTS /.FALSE./
      DATA STACK /.TRUE./
C
C     CHECK FOR ERRORS IN THE INPUT PARAMETERS.
C
      CALL STATER(NMSUB, WT, N, LDSTAK, WTS, NNZW, STACK, IERR)
      IF (IERR.NE.0) THEN
C
C     SET UP THE OUTPUT UNIT NUMBER.
C
         CALL IPRINT(IPRT)
         WRITE (IPRT,1000)
         RETURN
      END IF
C
C     SET UP FRAMEWORK AREA
C
      CALL STKSET (LDSTAK, IDP)
      NALL0 = STKST(1)
C
C     SET UP LSORT, THE PERMUTATION VECTOR.
C
      LSORT = STKGET(N,IINT)
      CALL GENI(ISTAK(LSORT), N, 1, 1)
C
C     SORT THE VECTOR Y.
C
      CALL SRTIR(ISTAK(LSORT), N, Y)
C
C     COMPUTE THE STATISTICS WHICH USE A SORTED ARRAY.
C
      CALL STAT1(Y, N, STS(5), STS(34), STS(35), STS(6),
     +   STS(11), 10, 0.0D0, 0.0D0, STS(44))
C
C     CALCULATE SUMS OF THE SORTED ARRAY.
C
      CALL SUMBS(Y, N, 1, MID, N)
      CALL SUMSS(Y, N, 1, MID, N, STS(38), STS(39), STS(42),
     +   STS(3))
      STS(4) = STS(3)
      CALL SUMTS(Y, N, ALPHA, SUMT1, STS(7))
      STS(8) = STS(7)
      CALL SUMDS(Y, N, 1, MID, N, STS(3), SUMDA, SUMD2, SUMD3, SUMD4)
C
C     RESTORE THE VECTOR Y TO ITS ORIGINAL ORDER.
C
      CALL SRTRI(Y, N, ISTAK(LSORT))
C
C     COMPUTE REST OF STATISTICS.
C
      CALL SUMID(Y, N, STS(3), SUMDI)
      CALL STAT2(Y, N, STS, SUMDA, SUMDI, SUMD2, SUMD3, SUMD4)
      IF (NPRT.NE.0) CALL SUMOT(STS, N, N, WTS)
C
C     RETURN THE VECTOR LSORT.
C
      CALL STKCLR(NALL0)
      RETURN
C
C     FORMAT STATEMENTS.
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL STATS (Y, N, LDSTAK, STS, NPRT)')
      END
*STATW
      SUBROUTINE STATW(Y, WT, N, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE COMPUTES 53 DIFFERENT STATISTICS FOR A
C     VECTOR Y, WITH WEIGHTS SPECIFIED.  ONE PAGE OF AUTOMATIC
C     PRINTOUT IS PRODUCED.
C
C     WRITTEN BY - JANET R. DONALDSON, JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS
C
C     CREATION DATE  -  MAY 17, 1982
C        (EXTENSIVE REVISION OF OLDER VERSION)
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   WT(*),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,SUM1,SUMD2,SUMD3,SUMD4,SUMDA,SUMDI,SUMT1,SUMW,SUMWD2,
     +   SUMWT1
      INTEGER
     +   IDP,IINT,IPRT,LSORT,MID,NALL0,NNZW
      LOGICAL
     +   STACK,WTS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   STS(53)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GENI,IPRINT,SRTIRR,SRTRRI,STAT1W,STAT2W,STATER,STKCLR,
     +   STKSET,SUMBS,SUMIDW,SUMOT,SUMWDS,SUMWSS,SUMWTS
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        THE PERCENTAGE OF POINTS TO BE TRIMMED FROM EITHER END OF
C        Y IN CALCULATING THE TRIMMED MEANS.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IDP
C        FRAMEWORK CODE VALUE FOR DOUBLE PRECISION NUMBERS.
C     INTEGER IERR
C        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
C        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
C        SOME ERROR EXISTS.
C     INTEGER IINT
C        THE CODE VALUE FOR INTEGER FOR FRAMEWORK.
C     INTEGER IPRT
C        THE NUMBER OF THE STANDARD OUTPUT UNIT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER LDSTAK
C        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
C        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
C     INTEGER LSORT
C        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION
C        VECTOR.
C     INTEGER MID
C        THE INDEX OF A ZERO ELEMENT IN THE SORTED Y, OR OF THE
C        ELEMENT CLOSEST TO ZERO.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF Y.
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
C        WAS CALLED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NNZW
C        NUMBER OF NONZERO WEIGHTS.
C     LOGICAL STACK
C        A FLAG INDICATING WHETHER THIS ROUTINE USES THE STACK (TRUE)
C        OR NOT (FALSE).
C     DOUBLE PRECISION STS(53)
C        THE VECTOR OF THE 53 STATISTICS COMPUTED.
C     DOUBLE PRECISION SUMDA
C        THE SUM OF THE ABSOLUTE DIFFERENCES FROM THE MEAN.
C     DOUBLE PRECISION SUMDI
C        THE SUM OF THE PRODUCTS OF THE INDICES AND THE
C        DIFFERENCES.
C     DOUBLE PRECISION SUMD2
C        THE SUM OF THE SQUARES OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMD3
C        THE SUM OF THE CUBES OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMD4
C        THE SUM OF THE 4TH POWERS OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMT1
C        THE SUM OF THE ALPHA TRIMMED ARRAY Y.
C     DOUBLE PRECISION SUMW
C        THE SUM OF THE WEIGHTS VECTOR WT.
C     DOUBLE PRECISION SUMWD2
C        THE WEIGHTED SUM OF THE SQUARES OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMWT1
C        THE WEIGHTED SUM OF THE ALPHA TRIMMED ARRAY.
C     DOUBLE PRECISION SUM1
C        THE UNWEIGHTED SUM OF THE ELEMENTS OF Y.
C     DOUBLE PRECISION WT(N)
C        INPUT PARAMETER.  THE WEIGHTS VECTOR.
C     LOGICAL WTS
C        A FLAG INDICATING WHETHER THERE ARE WEIGHTS (TRUE)
C        OR NOT (FALSE).
C     DOUBLE PRECISION Y(N)
C        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
C        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
C        TO ITS ORIGINAL ORDER AFTERWARDS.
C
C
C     INITIALIZE NAME VECTORS
C
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'S',      'T',      'A',      'T',      'W',      ' '/
C
      DATA ALPHA /0.25D0/
      DATA IDP /4/
      DATA IINT /2/
      DATA WTS /.TRUE./
      DATA STACK /.TRUE./
C
C     CHECK FOR ERRORS IN THE INPUT PARAMETERS.
C
      CALL STATER(NMSUB, WT, N, LDSTAK, WTS, NNZW, STACK, IERR)
      IF (IERR.NE.0) THEN
C
C     PRINT ERROR MESSAGE.
C
         CALL IPRINT(IPRT)
         WRITE (IPRT,1000)
         RETURN
      END IF
C
C     SET UP FRAMEWORK AREA.
C
      CALL STKSET (LDSTAK, IDP)
      NALL0 = STKST(1)
C
C     SET UP LSORT, THE PERMUTATION VECTOR.
C
      LSORT = STKGET(N,IINT)
      CALL GENI(ISTAK(LSORT), N, 1, 1)
C
C     SORT THE VECTOR Y.
C
      CALL SRTIRR(ISTAK(LSORT), WT, N, Y)
C
C     COMPUTE THE STATISTICS WHICH USE A SORTED ARRAY.
C
      CALL STAT1W(Y, WT, N, STS(5), STS(34), STS(35), STS(6),
     +   STS(11), 10, 0.0D0, 0.0D0, STS(44), NNZW)
C
C     COMPUTED VARIOUS SUMS IN THE SORTED ARRAY Y.
C
      CALL SUMBS(Y, N, 1, MID, N)
      CALL SUMWSS(Y, WT, N, 1, MID, N, NNZW, SUM1, STS(38), STS(39),
     +   STS(42), SUMW, STS(3), STS(4))
      CALL SUMWTS(Y, WT, N, NNZW, ALPHA, SUMT1, SUMWT1, STS(7),
     +   STS(8))
      CALL SUMWDS(Y, WT, N, 1, MID, N, STS(4), SUMDA, SUMWD2, SUMD2,
     +   SUMD3, SUMD4)
C
C     RESTORE THE VECTOR Y TO ITS ORIGINAL ORDER.
C
      CALL SRTRRI(Y, WT, N, ISTAK(LSORT))
C
C     COMPUTE REST OF STATISTICS.
C
      CALL SUMIDW(Y, WT, N, STS(4), SUMDI)
      CALL STAT2W(Y, WT, N, NNZW, STS, SUMDA, SUMDI, SUMWD2, SUMD2,
     +   SUMD3, SUMD4, SUMW)
      CALL SUMOT(STS, N, NNZW, WTS)
C
C     RETURN THE VECTOR LSORT.
C
      CALL STKCLR(NALL0)
      RETURN
C
C     FORMAT STATEMENTS.
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL STATW (Y, WT, N, LDSTAK)')
      END
*STATWS
      SUBROUTINE STATWS(Y, WT, N, LDSTAK, STS, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE COMPUTES 53 DIFFERENT STATISTICS FOR A VECTOR
C     Y, WITH WEIGHTS SPECIFIED.  ONE PAGE OF AUTOMATIC
C     PRINTOUT IS PRODUCED.
C
C     WRITTEN BY - JANET R. DONALDSON, JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS
C
C     CREATION DATE  -  MAY 17, 1982
C        (EXTENSIVE REVISION OF OLDER VERSION)
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   STS(53),WT(*),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,SUM1,SUMD2,SUMD3,SUMD4,SUMDA,SUMDI,SUMT1,SUMW,SUMWD2,
     +   SUMWT1
      INTEGER
     +   IDP,IINT,IPRT,LSORT,MID,NALL0,NNZW
      LOGICAL
     +   STACK,WTS
C
C  LOCAL ARRAYS
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GENI,IPRINT,SRTIRR,SRTRRI,STAT1W,STAT2W,STATER,STKCLR,
     +   STKSET,SUMBS,SUMIDW,SUMOT,SUMWDS,SUMWSS,SUMWTS
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        THE PERCENTAGE TO BE TRIMMED FROM EACH END OF THE
C        SORTED ARRAY Y.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IDP
C        FRAMEWORK CODE VALUE FOR DOUBLE PRECISION NUMBERS.
C     INTEGER IERR
C        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
C        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
C        SOME ERROR EXISTS.
C     INTEGER IINT
C        THE CODE VALUE FOR INTEGER FOR FRAMEWORK.
C     INTEGER IPRT
C        THE NUMBER OF THE STANDARD OUTPUT UNIT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER LDSTAK
C        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
C        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
C     INTEGER LSORT
C        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION VECTOR.
C     INTEGER MID
C        THE INDEX OF A ZERO ELEMENT IN THE SORTED Y, OR OF THE
C        ELEMENT CLOSEST TO ZERO.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF Y.
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
C        WAS CALLED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        INPUT PARAMETER.  THE CODE INDICATING WHETHER PRINTOUT
C        IS DESIRED.  0 MEANS NO PRINTOUT, NOT 0 MEANS PRINTOUT.
C     INTEGER NNZW
C        NUMBER OF NONZERO WEIGHTS.
C     LOGICAL STACK
C        A FLAG INDICATING WHETHER THIS ROUTINE USES THE STACK (TRUE)
C        OR NOT (FALSE).
C     DOUBLE PRECISION STS(53)
C        OUTPUT PARAMETER.  THE VECTOR OF THE 53 STATISTICS COMPUTED.
C     DOUBLE PRECISION SUMDA
C        THE SUM OF THE ABSOLUTE DIFFERENCES FROM THE MEAN.
C     DOUBLE PRECISION SUMDI
C        THE SUM OF THE PRODUCTS OF THE INDICES AND THE
C        DIFFERENCES.
C     DOUBLE PRECISION SUMD2
C        THE SUM OF THE SQUARES OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMD3
C        THE SUM OF THE CUBES OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMD4
C        THE SUM OF THE 4TH POWERS OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMT1
C        THE SUM OF THE ALPHA TRIMMED ARRAY Y.
C     DOUBLE PRECISION SUMW
C        THE SUM OF THE WEIGHTS VECTOR WT.
C     DOUBLE PRECISION SUMWD2
C        THE WEIGHTED SUM OF THE SQUARES OF THE DIFFERENCES.
C     DOUBLE PRECISION SUMWT1
C        THE WEIGHTED SUM OF THE ALPHA TRIMMED ARRAY.
C     DOUBLE PRECISION SUM1
C        THE SUM OF THE ELEMENTS OF X.  A DUMMY VARIABLE.
C     DOUBLE PRECISION WT(N)
C        INPUT PARAMETER.  THE WEIGHTS VECTOR.
C     LOGICAL WTS
C        A FLAG INDICATING WHETHER THERE ARE WEIGHTS (TRUE)
C        OR NOT (FALSE).
C     DOUBLE PRECISION Y(N)
C        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
C        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
C        TO ITS ORIGINAL ORDER AFTERWARDS.
C
C
C     INITIALIZE NAME VECTORS
C
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'S',      'T',      'A',      'T',      'W',      'S'/
C
      DATA ALPHA /0.25D0/
      DATA IDP /4/
      DATA IINT /2/
      DATA WTS /.TRUE./
      DATA STACK /.TRUE./
C
C     CHECK FOR ERRORS IN THE INPUT PARAMETERS.
C
      CALL STATER(NMSUB, WT, N, LDSTAK, WTS, NNZW, STACK, IERR)
      IF (IERR.NE.0) THEN
C
C     PRINT ERROR MESSAGE.
C
         CALL IPRINT(IPRT)
         WRITE (IPRT,1000)
         RETURN
      END IF
C
C     SET UP FRAMEWORK AREA.
C
      CALL STKSET (LDSTAK, IDP)
      NALL0 = STKST(1)
C
C     SET UP LSORT, THE PERMUTATION VECTOR.
C
      LSORT = STKGET(N,IINT)
      CALL GENI(ISTAK(LSORT), N, 1, 1)
C
C     SORT THE VECTOR Y CARRYING ALONG THE CONTENTS OF THE VECTOR
C     ISTAK(LSORT).
C
      CALL SRTIRR(ISTAK(LSORT), WT, N, Y)
C
C     COMPUTE THE STATISTICS WHICH USE A SORTED ARRAY.
C
      CALL STAT1W(Y, WT, N, STS(5), STS(34), STS(35), STS(6),
     +   STS(11), 10, 0.0D0, 0.0D0, STS(44), NNZW)
C
C     COMPUTED VARIOUS SUMS IN THE SORTED ARRAY Y.
C
      CALL SUMBS(Y, N, 1, MID, N)
      CALL SUMWSS(Y, WT, N, 1, MID, N, NNZW, SUM1, STS(38), STS(39),
     +   STS(42), SUMW, STS(3), STS(4))
      CALL SUMWTS(Y, WT, N, NNZW, ALPHA, SUMT1, SUMWT1, STS(7),
     +   STS(8))
      CALL SUMWDS(Y, WT, N, 1, MID, N, STS(4), SUMDA, SUMWD2, SUMD2,
     +   SUMD3, SUMD4)
C
C     RESTORE THE VECTOR Y TO ITS ORIGINAL ORDER.
C
      CALL SRTRRI(Y, WT, N, ISTAK(LSORT))
C
C     COMPUTE REST OF STATISTICS.
C
      CALL SUMIDW(Y, WT, N, STS(4), SUMDI)
      CALL STAT2W(Y, WT, N, NNZW, STS, SUMDA, SUMDI, SUMWD2, SUMD2,
     +   SUMD3, SUMD4, SUMW)
      IF (NPRT.NE.0) CALL SUMOT(STS, N, NNZW, WTS)
C
C     RETURN THE VECTOR LSORT.
C
      CALL STKCLR(NALL0)
      RETURN
C
C     FORMAT STATEMENTS.
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL STATWS (Y, WT, N, LDSTAK, STS, NPRT)')
      END
*STAT1
      SUBROUTINE STAT1(Y, N, YMED, YMIN, YMAX, YMIDRG, YRANGE, NCELLS,
     +   YLB, YUB, YDISTR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS COMPUTES STATISTICS FOR A VECTOR Y THAT REQUIRE OR CAN
C     MAKE USE OF SORTEDNESS IN THE Y VECTOR.
C
C     THIS SUBROUTINE IS BASED ON A MODIFICATION OF THE STATIS
C     CODE USED IN OMNITAB, VERSION 5 (6/16/72), WRITTED BY
C     SALLY PEAVY.  THE ORIGINAL ADAPTATION TO STARPAC WAS MADE
C     BY JANET DONALDSON.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YLB,YMAX,YMED,YMIDRG,YMIN,YRANGE,YUB
      INTEGER
     +   N,NCELLS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(N),YDISTR(NCELLS)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELY,YT
      INTEGER
     +   I,IC,IC1,L,M,M1
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MOD
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELY
C        THE WIDTH OF AN INTERVAL ONE TENTH THE RANGE OF THE
C        DATA IN Y.
C     INTEGER I
C        A LOOP INDEX.
C     INTEGER IC
C        PREVIOUS SIGN IN RUNS CALCULATION.
C     INTEGER IC1
C        COUNT IN FREQUENCY DISTRIBUTION CALCULATIONS.
C     INTEGER L
C        A LOOP INDEX.
C     INTEGER M
C        A LOOP INDEX.
C     INTEGER M1
C        WHEN N IS EVEN, M1 IS M + 1, OTHERWISE IT IS M.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF Y AND WT.
C     INTEGER NCELLS
C        THE NUMBER OF CELLS IN THE FREQUENCY DISTRIBUTION.
C     DOUBLE PRECISION Y(N)
C        INPUT PARAMETER.  A SET OF N DATA POINTS, SORTED
C        INTO ASCENDING ORDER.
C     DOUBLE PRECISION YDISTR(NCELLS)
C        OUTPUT PARAMETER.  THE NUMBERS OF Y VALUES WITH
C        POSITIVE WEIGHTS IN EACH OF NCELLS EQUAL LENGTH INTERVALS
C        THAT DIVIDE THE RANGE OF Y VALUES.
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE FREQUENCY DISTRIBUTION.
C        IF YLB = YUB, THE MINIMUM OBSERVATION WILL BE USED.
C     DOUBLE PRECISION YMAX
C        OUTPUT PARAMETER.  THE MAXIMUM OF THE OBSERVATIONS Y HAVING
C        POSITIVE WEIGHT.
C     DOUBLE PRECISION YMED
C        OUTPUT PARAMETER.  THE MEDIAN OF THE OBSERVATIONS Y.
C     DOUBLE PRECISION YMIDRG
C        OUTPUT PARAMETER.  THE MIDRANGE OF THE OBSERVATIONS Y.
C     DOUBLE PRECISION YMIN
C        OUTPUT PARAMETER.  THE MINIMUM OF THE OBSERVATIONS Y HAVING
C        POSITIVE WEIGHT.
C     DOUBLE PRECISION YRANGE
C        THE RANGE OF THE OBSERVATIONS Y.
C     DOUBLE PRECISION YT
C        THE MAXIMUM VALUE IN EACH INTERVAL IN THE FREQUENCY
C        DISTRIBUTIONS CALCULATIONS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE FREQUENCY DISTRIBUTION.
C        IF YLB = YUB, THE MAXIMUM OBSERVATION WILL BE USED.
C
C     CALCULATE THE MEDIAN, MIDRANGE, RANGE, AND EXTREMA.
C
      M = (N+1)/2
      M1 = M
      IF (MOD(N,2).EQ.0) M1 = M1 + 1
      YMED = (Y(M)+Y(M1))/2.0D0
      YMIDRG = (Y(1)+Y(N))/2.0D0
      YRANGE = Y(N) - Y(1)
      YMIN = Y(1)
      YMAX = Y(N)
C
C     COMPUTE FREQUENCY DISTRIBUTION.
C
      IF (NCELLS.LE.0) RETURN
      IC1 = 0
      IF (NCELLS.EQ.1) GO TO 40
C
      DELY = YRANGE
      YT = YMIN
      IF (YLB.GE.YUB) GO TO 5
         DELY = YUB - YLB
         YT = YLB
    5 CONTINUE
      DELY = DELY / NCELLS
      YT = YT + DELY
      L = 0
      DO 30 I=2,NCELLS
         IC = 0
   10    L = L + 1
         IF (L.GT.N) GO TO 20
         IF (Y(L).GT.YT) GO TO 20
         IC = IC + 1
         IC1 = IC1 + 1
         GO TO 10
   20    YDISTR(I-1) = IC
         L = L - 1
         YT = YT + DELY
   30 CONTINUE
   40 YDISTR(NCELLS) = N - IC1
      RETURN
      END
*STAT1W
      SUBROUTINE STAT1W(Y, WT, N, YMED, YMIN, YMAX, YMIDRG, YRANGE,
     +   NCELLS, YLB, YUB, YDISTR, NNZW)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS COMPUTES STATISTICS FOR A VECTOR Y THAT REQUIRE OR CAN
C     MAKE USE OF SORTEDNESS IN THE VECTOR.  WEIGHTS ARE USED.
C
C     THIS SUBROUTINE IS BASED ON A MODIFICATION OF THE STATIS
C     CODE USED IN OMNITAB, VERSION 5 (6/16/72), WRITTED BY
C     SALLY PEAVY.  THE ORIGINAL ADAPTATION TO STARPAC WAS MADE
C     BY JANET DONALDSON.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YLB,YMAX,YMED,YMIDRG,YMIN,YRANGE,YUB
      INTEGER
     +   N,NCELLS,NNZW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   WT(N),Y(N),YDISTR(NCELLS)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELY,YT
      INTEGER
     +   I,IC,IC1,KK,L,M,M1,MAX,MAXY,MINY,N2
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MOD
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELY
C        THE WIDTH OF AN INTERVAL ONE TENTH THE RANGE OF THE
C        DATA IN Y.
C     INTEGER I
C        A LOOP INDEX.
C     INTEGER IC
C        PREVIOUS SIGN IN RUNS CALCULATION.
C     INTEGER IC1
C        COUNT IN FREQUENCY DISTRIBUTION CALCULATIONS.
C     INTEGER KK
C        A BACKWARDS, BOULDER, COLORADO LOOP INDEX.
C     INTEGER L
C        A LOOP INDEX.
C     INTEGER M
C        A LOOP INDEX.
C     INTEGER MAX
C        INDEX OF A MAXIMUM ELEMENT.
C     INTEGER MAXY
C        LAST ELEMENT OF Y, THE LARGEST ONE.
C     INTEGER MINY
C        FIRST ELEMENT OF Y, THE LEAST ONE.
C     INTEGER M1
C        ...
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF Y AND WT.
C     INTEGER NCELLS
C        THE NUMBER OF CELLS IN THE FREQUENCY DISTRIBUTION.
C     INTEGER NNZW
C        INPUT PARAMETER.  THE NUMBER OF POSITIVE ELEMENTS IN WT.
C     INTEGER N2
C        (NNZW + 1)/2
C     DOUBLE PRECISION WT(N)
C        INPUT PARAMETER.  THE VECTOR OF WEIGHTS FOR THE
C        Y OBSERVATIONS.
C     DOUBLE PRECISION Y(N)
C        INPUT PARAMETER.  A SET OF N DATA POINTS, SORTED
C        INTO ASCENDING ORDER.
C     DOUBLE PRECISION YDISTR(NCELLS)
C        OUTPUT PARAMETER.  THE NUMBERS OF Y VALUES WITH
C        POSITIVE WEIGHTS IN EACH OF TEN EQUAL LENGTH INTERVALS.
C        THAT DIVIDE THE RANGE OF Y VALUES.
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE FREQUENCY DISTRIBUTION.
C        IF YLB = YUB, THE MINIMUM OBSERVATION WILL BE USED.
C     DOUBLE PRECISION YMAX
C        OUTPUT PARAMETER.  THE MAXIMUM OF THE OBSERVATIONS Y HAVING
C        POSITIVE WEIGHT.
C     DOUBLE PRECISION YMED
C        OUTPUT PARAMETER.  THE MEDIAN OF THE OBSERVATIONS Y.
C     DOUBLE PRECISION YMIDRG
C        OUTPUT PARAMETER.  THE MIDRANGE OF THE OBSERVATIONS Y.
C     DOUBLE PRECISION YMIN
C        OUTPUT PARAMETER.  THE MINIMUM OF THE OBSERVATIONS Y HAVING
C        POSITIVE WEIGHT.
C     DOUBLE PRECISION YRANGE
C        OUTPUT PARAMETER.  THE RANGE OF THE OBSERVATIONS Y.
C     DOUBLE PRECISION YT
C        THE MAXIMUM VALUE IN EACH INTERVAL IN THE FREQUENCY
C        DISTRIBUTIONS CALCULATIONS.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE FREQUENCY DISTRIBUTION.
C        IF YLB = YUB, THE MAXIMUM OBSERVATION WILL BE USED.
C
C     CALCULATE THE MEDIAN.
C
      N2 = (NNZW+1)/2
      M = 1
      DO 10 I=1,N
         IF (I.GT.N2) GO TO 20
         M = I
         IF (WT(M).LE.0.0D0) N2 = N2 + 1
   10 CONTINUE
   20 M1 = M
      IF (MOD(NNZW,2).NE.0) GO TO 40
      DO 30 M1=M,N
         IF (WT(M1).GT.0.0D0) GO TO 40
   30 CONTINUE
   40 YMED = (Y(I)+Y(M1))/2.0D0
C
C     CALCULATE THE MIDRANGE, RANGE, MINIMUM, AND MAXIMUM.
C
      MAX = N - NNZW + 1
      DO 50 I=1,MAX
         MINY = I
         IF (WT(MINY).GT.0.0D0) GO TO 60
   50 CONTINUE
   60 DO 70 I=1,MAX
         KK = N + 1 - I
         MAXY = KK
         IF (WT(MAXY).GT.0.0D0) GO TO 80
   70 CONTINUE
   80 YMIDRG = (Y(MINY)+Y(MAXY))/2.0D0
      YRANGE = Y(MAXY) - Y(MINY)
      YMIN = Y(MINY)
      YMAX = Y(MAXY)
C
C     COMPUTE FREQUENCY DISTRIBUTION
C
      DELY = YRANGE
      YT = YMIN
      IF (YLB.GE.YUB) GO TO 5
         DELY = YUB - YLB
         YT = YLB
    5 CONTINUE
      DELY = DELY / NCELLS
      YT = YT + DELY
      L = 0
      IC1 = 0
      DO 110 I=2,NCELLS
         IC = 0
   90    L = L + 1
         IF (L.GT.N) GO TO 100
         IF (WT(L).LE.0.0D0) GO TO 90
         IF (Y(L).GT.YT) GO TO 100
         IC = IC + 1
         IC1 = IC1 + 1
         GO TO 90
  100    YDISTR(I-1) = IC
         L = L - 1
         YT = YT + DELY
  110 CONTINUE
      YDISTR(NCELLS) = NNZW - IC1
      RETURN
      END
*STAT2
      SUBROUTINE STAT2(Y, N, STS, SUMDA, SUMDI, SUMD2, SUMD3, SUMD4)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE COMPUTES FOR A VECTOR Y THE STATISTICS THAT DO
C     NOT REQUIRE SORTING OF THE VECTOR, THAT IS, THOSE NOT COMPUTED
C     BY STAT1.  NO WEIGHTS ARE USED.
C
C     THIS SUBROUTINE IS BASED ON A MODIFICATION OF THE STATIS
C     CODE USED IN OMNITAB, VERSION 5 (6/16/72), WRITTEN BY
C     SALLY PEAVY.  THE ORIGINAL ADAPTATION TO STARPAC WAS
C     DONE BY JANET DONALDSON.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SUMD2,SUMD3,SUMD4,SUMDA,SUMDI
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   STS(53),Y(N)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DIF,T,TA,TK1,TK2
      INTEGER
     +   I,IC,ICI,IDRUNS,IMINUS,IPLUS,IRUN
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFF,PPFCHS,PPFT
      EXTERNAL CDFF,PPFCHS,PPFT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,SQRT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DIF
C        THE SUM OF THE DIFFERENCES BETWEEN SUCCEEDING ELEMENTS
C        IN Y.
C     INTEGER I
C        A LOOP INDEX.
C     INTEGER IC
C        PREVIOUS SIGN IN RUNS CALCULATION.
C     INTEGER ICI
C        CURRENT SIGN IN RUNS CALCULATION.
C     INTEGER IDRUNS
C        THE NUMBER OF RUNS.
C     INTEGER IERR
C        AN ERROR FLAG SET IN COMMON ERRCHK.
C     INTEGER IMINUS, IPLUS
C        COUNTS OF SIGNS OF DEVIATIONS.
C     INTEGER IRUN
C        THE NUMBER OF RUNS UP AND DOWN.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF Y AND WT.
C     DOUBLE PRECISION STS(53)
C        OUTPUT PARAMETER.  THE VECTOR OF 53 STATISTICS COMPUTED.
C        ROW STATISTIC                    ROW STATISTIC
C         1  LENGTH OF VECTOR             TESTS FOR NONRANDOMNESS
C         2  NUMBER OF NONZERO WEIGHTS    23  NUMBER OF RUNS UP AND DOWN
C        MEASURES OF LOCATION             24  EXPECTED NUMBER OF RUNS
C         3  UNWEIGHTED MEAN              25  S.D. OF NUMBER OF RUNS
C         4  WEIGHTED MEAN                26  MEAN SQR. SUCCESSIVE DIFF.
C         5  MEDIAN                       27  MEAN SQR. SUCC. DIFF./VAR.
C         6  MID-RANGE                    DEVIATIONS FROM WTD MEAN
C         7  25 P.C. UNWTD. TRIMMED MEAN  28  NUMBER OF + SIGNS
C         8  25 P.C. WTD. TRIMMED MEAN    29  NUMBER OF - SIGNS
C        MEASURES OF DISPERSION           30  NUMBER OF RUNS
C         9  STANDARD DEVIATION (S.D.)    31  EXPECTED NUMBER OF RUNS
C        10  S.D. OF MEAN                 32  S.D. OF RUNS
C        11  RANGE                        33  DIFF./S.D. OF RUNS
C        12  MEAN VARIATION               OTHER STATISTICS
C        13  VARIANCE (VAR.)              34  MINIMUM
C        14  COEFFICIENT OF VARIATION     35  MAXIMUM
C        CONFIDENCE INTERVALS             36  BETA 1
C        15  LOWER CONFIDENCE LIMIT, MEAN 37  BETA 2
C        16  UPPER CONFIDENCE LIMIT, MEAN 38  WTD. SUM OF VALUES
C        17  LOWER CONFIDENCE LIMIT, S.D. 39  WTD. SUM OF SQUARES
C        18  UPPER CONFIDENCE LIMIT, S.D. 40  WTD. SUM OF SQRD. DEVS.
C        LINEAR TREND STATISTICS          41  STUDENTS T
C        19  SLOPE                        42  WTD. SUM OF ABS. VALUES
C        20  S.D. OF SLOPE                43  WTD. AVG. ABS. VALUES
C        21  SLOPE/S.D. OF SLOPE = T      44-53 FREQ. DISTRIBUTION
C        22  PROB ( X .GT. ABS(OBS. T))
C     DOUBLE PRECISION SUMDA
C        INPUT PARAMETER.  THE SUM OF THE ABSOLUTE VALUES OF THE
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION SUMDI
C        INPUT PARAMETER.  THE SUM OF THE PRODUCTS OF I AND THE
C        ITH DIFFERENCE DIFF.
C     DOUBLE PRECISION SUMD2
C        INPUT PARAMETER.  THE SUM OF THE SQUARES OF THE
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION SUMD3
C        INPUT PARAMETER.  THE SUM OF THE CUBES OF THE
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION SUMD4
C        INPUT PARAMETER.  THE SUM OF THE HYPERCUBES OF THE
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION T
C        A RESIDUAL (Y(I) - MEANY)
C     DOUBLE PRECISION TA
C        A TEMPORARY VARIABLE IN THE RUNS CALCULATION.
C     DOUBLE PRECISION TK1, TK2
C        CHI-SQUARED VALUES.
C     DOUBLE PRECISION Y(N)
C        INPUT PARAMETER.  A SET OF N DATA POINTS, SORTED
C        INTO ASCENDING ORDER.
C
C
C     BEGIN STORAGE OF STATISTICS.
C
      STS(1) = N
      STS(2) = STS(1)
      STS(24) = (2.0D0*STS(1)-1.0D0)/3.0D0
      STS(25) = SQRT((16.0D0*STS(1)-29.0D0)/90.0D0)
      STS(43) = STS(42)/STS(1)
C
C     COMPUTE RESIDUALS AND STANDARD DEVIATIONS.
C
      ICI = 0
      IPLUS = 0
      IMINUS = 0
      IDRUNS = 0
      IC = 0
      DO 30 I=1,N
         T = Y(I) - STS(4)
         IF (T.LT.0.0D0) GO TO 10
         IPLUS = IPLUS + 1
         ICI = +1
         GO TO 20
   10    IMINUS = IMINUS + 1
         ICI = -1
   20    IF (IC.EQ.ICI) GO TO 30
         IC = ICI
         IDRUNS = IDRUNS + 1
   30 CONTINUE
      STS(28) = IPLUS
      STS(29) = IMINUS
      STS(31) = 1.0D0 + (2.0D0*STS(28)*STS(29)/STS(1))
      STS(32) = SQRT((2.0D0*STS(28)*STS(29)*
     +                 (2.0D0*STS(28)*STS(29) -
     +                  STS(28)-STS(29)))/
     +            ((STS(28)+STS(29))**2*(STS(1)-1.0D0)))
      STS(30) = IDRUNS
      STS(33) = 0.0D0
      IF (STS(32).NE.0.0D0)
     +   STS(33) = (STS(30)-STS(31))/STS(32)
      STS(13) = SUMD2/(STS(1)-1.0D0)
      STS(9) = SQRT(STS(13))
      STS(10) = STS(9)/SQRT(STS(1))
      IF (STS(4).NE.0.0D0)
     +   STS(14) = 100.0D0*ABS(STS(9)/STS(4))
      IF (STS(4).EQ.0.0D0) STS(14) = 0.0D0
      STS(36) = 0.0D0
      IF (SUMD2.GT.0.0D0)
     +   STS(36) = (SUMD3/STS(1))**2/((SUMD2/STS(1))**3)
      STS(37) = 0.0D0
      IF (SUMD2.GT.0.0D0)
     +   STS(37) = (SUMD4/STS(1))/((SUMD2/STS(1))**2)
      STS(40) = SUMD2
      STS(19) = (12.0D0*SUMDI)/(STS(1)*(STS(1)**2-1.0D0))
      STS(20) = (1.0D0/(STS(1)-2.0D0)*
     +             (12.0D0*(SUMD2/(STS(1)*(STS(1)**2-1.0D0)))-
     +              STS(19)**2))
      IF (STS(20).LE.0.0D0) STS(20) = 0.0D0
      STS(20) = SQRT(STS(20))
      IF (STS(20).EQ.0.0D0) STS(21) = 0.0D0
      IF (STS(20).GT.0.0D0) STS(21) = STS(19)/STS(20)
C
      STS(22) = 1.0D0 - CDFF(STS(21)*STS(21), 1.0D0, STS(1)-2.0D0)
C
C     COMPUTE NUMBER OF RUNS IN THE DATA.
C
      DIF = 0.0D0
      IRUN = 1
      TA = 0.0D0
      DO 40 I=1,N
         IF (I.GE.N) GO TO 50
         TA = Y(I+1) - Y(I)
         IF (TA.NE.0.0D0) GO TO 50
   40 CONTINUE
   50 DO 60 I=1,N
         IF (I.EQ.N) GO TO 60
         T = Y(I+1) - Y(I)
         DIF = DIF + T*T
         IF (TA*T.GE.0.0D0) GO TO 60
         TA = T
         IRUN = IRUN + 1
   60 CONTINUE
      STS(23) = IRUN
      STS(26) = DIF/(STS(1)-1.0D0)
      STS(27) = 0.0D0
      IF (STS(13).NE.0.0D0)
     +   STS(27) = STS(26)/STS(13)
      STS(41) = 0.0D0
      IF (STS(9).NE.0.0D0)
     +   STS(41) = (STS(4)*SQRT(STS(1)))/STS(9)
      STS(12) = SUMDA/STS(1)
      T = PPFT(0.975D0, N-1)
      TK1 = PPFCHS(0.975D0, N-1)
      TK2 = PPFCHS(0.025D0, N-1)
      STS(15) = STS(4) - T*STS(10)
      STS(16) = STS(4) + T*STS(10)
      STS(17) = SQRT((STS(1)-1.0D0)/TK1)*STS(9)
      STS(18) = SQRT((STS(1)-1.0D0)/TK2)*STS(9)
      RETURN
      END
*STAT2W
      SUBROUTINE STAT2W(Y, WT, N, NNZW, STS, SUMDA, SUMDI, SUMWD2,
     +   SUMD2, SUMD3, SUMD4, SUMW)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE COMPUTES FOR A VECTOR Y THE STATISTICS THAT DO
C     NOT REQUIRE SORTING OF THE VECTOR, THAT IS, THOSE NOT COMPUTED
C     BY STAT1W.  WEIGHTS ARE USED IN THE CALCULATIONS.
C
C     THIS SUBROUTINE IS BASED ON A MODIFICATION OF THE STATIS
C     CODE USED IN OMNITAB, VERSION 5 (6/16/72), WRITTEN BY
C     SALLY PEAVY.  THE ORIGINAL ADAPTATION TO STARPAC WAS
C     DONE BY JANET DONALDSON.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SUMD2,SUMD3,SUMD4,SUMDA,SUMDI,SUMW,SUMWD2
      INTEGER
     +   N,NNZW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   STS(53),WT(N),Y(N)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DIF,T,TA,TK1,TK2
      INTEGER
     +   I,IC,ICI,ICOUNT,IDRUNS,IMINUS,IPLUS,IRUN,J
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFF,PPFCHS,PPFT
      EXTERNAL CDFF,PPFCHS,PPFT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,SQRT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DIF
C        THE SUM OF THE DIFFERENCES BETWEEN SUCCEEDING ELEMENTS
C        IN Y.
C     INTEGER I
C        A LOOP INDEX.
C     INTEGER IC
C        PREVIOUS SIGN IN RUNS CALCULATION.
C     INTEGER ICI
C        CURRENT SIGN IN RUNS CALCULATION.
C     INTEGER ICOUNT
C        USED IN RUNS CALCULATIONS.
C     INTEGER IDRUNS
C        THE NUMBER OF RUNS.
C     INTEGER IERR
C        AN ERROR FLAG SET IN COMMON ERRCHK.
C     INTEGER IMINUS, IPLUS
C        COUNTS OF SIGNS OF DEVIATIONS.
C     INTEGER IRUN
C        THE NUMBER OF RUNS UP AND DOWN.
C     INTEGER J
C        A LOOP INDEX.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF Y AND WT.
C     INTEGER NNZW
C        INPUT PARAMETER.  THE NUMBER OF POSITIVE ELEMENTS IN WT.
C     DOUBLE PRECISION STS(53)
C        OUTPUT PARAMETER.  THE VECTOR OF 53 STATISTICS COMPUTED.
C     ROW STATISTIC                    ROW STATISTIC
C         1  LENGTH OF VECTOR             TESTS FOR NONRANDOMNESS
C         2  NUMBER OF NONZERO WEIGHTS    23  NUMBER OF RUNS UP AND DOWN
C        MEASURES OF LOCATION             24  EXPECTED NUMBER OF RUNS
C         3  UNWEIGHTED MEAN              25  S.D. OF NUMBER OF RUNS
C         4  WEIGHTED MEAN                26  MEAN SQR. SUCCESSIVE DIFF.
C         5  MEDIAN                       27  MEAN SQR. SUCC. DIFF./VAR.
C         6  MID-RANGE                    DEVIATIONS FROM WTD MEAN
C         7  25 P.C. UNWTD. TRIMMED MEAN  28  NUMBER OF + SIGNS
C         8  25 P.C. WTD. TRIMMED MEAN    29  NUMBER OF - SIGNS
C        MEASURES OF DISPERSION           30  NUMBER OF RUNS
C         9  STANDARD DEVIATION (S.D.)    31  EXPECTED NUMBER OF RUNS
C        10  S.D. OF MEAN                 32  S.D. OF RUNS
C        11  RANGE                        33  DIFF./S.D. OF RUNS
C        12  MEAN VARIATION               OTHER STATISTICS
C        13  VARIANCE (VAR.)              34  MINIMUM
C        14  COEFFICIENT OF VARIATION     35  MAXIMUM
C        CONFIDENCE INTERVALS             36  BETA 1
C        15  LOWER CONFIDENCE LIMIT, MEAN 37  BETA 2
C        16  UPPER CONFIDENCE LIMIT, MEAN 38  WTD. SUM OF VALUES
C        17  LOWER CONFIDENCE LIMIT, S.D. 39  WTD. SUM OF SQUARES
C        18  UPPER CONFIDENCE LIMIT, S.D. 40  WTD. SUM OF SQRD. DEVS.
C        LINEAR TREND STATISTICS          41  STUDENTS T
C        19  SLOPE                        42  WTD. SUM OF ABS. VALUES
C        20  S.D. OF SLOPE                43  WTD. AVG. ABS. VALUES
C        21  SLOPE/S.D. OF SLOPE = T      44-53 FREQ. DISTRIBUTION
C        22  PROB ( X .GT. ABS(OBS. T))
C     DOUBLE PRECISION SUMDA
C        INPUT PARAMETER.  THE SUM OF THE ABSOLUTE VALUES OF THE
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION SUMDI
C        INPUT PARAMETER.  THE SUM OF THE PRODUCTS OF I AND THE
C        ITH DIFFERENCE DIFF.
C     DOUBLE PRECISION SUMD2
C        INPUT PARAMETER.  THE SUM OF THE SQUARES OF THE
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION SUMD3
C        INPUT PARAMETER.  THE SUM OF THE CUBES OF THE
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION SUMD4
C        INPUT PARAMETER.  THE SUM OF THE HYPERCUBES OF THE
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION SUMW
C        INPUT PARAMETER.  THE SUM OF THE WEIGHTS VECTOR WT.
C     DOUBLE PRECISION SUMWD2
C        INPUT PARAMETER.  THE WEIGHTED SUM OF THE SQUARED
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION T
C        A RESIDUAL (Y(I) - MEANY)
C     DOUBLE PRECISION TA
C        A TEMPORARY VARIABLE IN THE RUNS CALCULATION.
C     DOUBLE PRECISION TK1, TK2
C        CHI-SQUARED VALUES.
C     DOUBLE PRECISION WT(N)
C        INPUT PARAMETER.  THE VECTOR OF WEIGHTS FOR THE
C        Y OBSERVATIONS.
C     DOUBLE PRECISION Y(N)
C        INPUT PARAMETER.  A SET OF N DATA POINTS, SORTED
C        INTO ASCENDING ORDER.
C
C
C     BEGIN STORAGE OF STATISTICS.
C
      STS(1) = N
      STS(2) = NNZW
      STS(24) = (2.0D0*STS(2)-1.0D0)/3.0D0
      STS(25) = SQRT((16.0D0*STS(2)-29.0D0)/90.0D0)
      STS(43) = STS(42)/SUMW
C
C     COMPUTE RESIDUALS AND STANDARD DEVIATIONS.
C
      ICI = 0
      IPLUS = 0
      IMINUS = 0
      IDRUNS = 0
      IC = 0
      DO 30 I=1,N
         IF (WT(I).LE.0.0D0) GO TO 30
         T = Y(I) - STS(4)
         IF (T.LT.0.0D0) GO TO 10
         IPLUS = IPLUS + 1
         ICI = 1
         GO TO 20
   10    IMINUS = IMINUS + 1
         ICI = -1
   20    IF (IC.EQ.ICI) GO TO 30
         IC = ICI
         IDRUNS = IDRUNS + 1
   30 CONTINUE
      STS(28) = IPLUS
      STS(29) = IMINUS
      STS(31) = 1.0D0 + (2.0D0*STS(28)*STS(29)/STS(2))
      STS(32) =
     +   SQRT((2.0D0*STS(28)*STS(29)*(2.0D0*STS(28)*STS(29)-
     +                                     STS(28)-STS(29)))/
     +        ((STS(28)+STS(29))**2*(STS(2)-1.0D0)))
      STS(30) = IDRUNS
      STS(33) = 0.0D0
      IF (STS(32).NE.0.0D0)
     +   STS(33) = (STS(30)-STS(31))/STS(32)
      STS(13) = SUMWD2/(STS(2)-1.0D0)
      STS(9) = SQRT(STS(13))
      STS(10) = STS(9)/(SQRT(SUMW))
      IF (STS(4).NE.0.0D0)
     +   STS(14) = 100.0D0*ABS(STS(9)/STS(4))
      IF (STS(4).EQ.0.0D0) STS(14) = 0.0D0
      STS(36) = 0.0D0
      IF (SUMD2.NE.0.0D0)
     +   STS(36) = (SUMD3/STS(2))**2/((SUMD2/STS(2))**3)
      STS(37) = 0.0D0
      IF (SUMD2.NE.0.0D0)
     +   STS(37) = (SUMD4/STS(2))/((SUMD2/STS(2))**2)
      STS(40) = SUMWD2
      STS(19) = (12.0D0*SUMDI)/(STS(2)*(STS(2)**2-1.0D0))
      STS(20) = (1.0D0/(STS(2)-2.0D0)*
     +             (12.0D0*(SUMD2/(STS(2)*(STS(2)**2-1.0D0)))-
     +              STS(19)**2))
      IF (STS(20).LE.0.0D0) STS(20) = 0.0D0
      STS(20) = SQRT(STS(20))
      IF (STS(20).EQ.0.0D0) STS(21) = 0.0D0
      IF (STS(20).GT.0.0D0) STS(21) = STS(19)/STS(20)
C
      STS(22) = 1.0D0 - CDFF(STS(21)*STS(21), 1.0D0, STS(2)-2.0D0)
C
C     COMPUTE NUMBER OF RUNS IN THE DATA.
C
      DIF = 0.0D0
      IRUN = 1
      TA = 0.0D0
      DO 50 I=1,N
         IF (I.GE.N) GO TO 60
         IF (WT(I).LE.0.0D0) GO TO 50
         J = I
   40    J = J + 1
         IF (J.GE.N) GO TO 60
         IF (WT(J).LE.0.0D0) GO TO 40
         TA = Y(J) - Y(I)
         IF (TA.NE.0.0D0) GO TO 60
   50 CONTINUE
   60 ICOUNT = 0
      DO 80 I=1,N
         IF (WT(I).LE.0.0D0) GO TO 80
         ICOUNT = ICOUNT + 1
         IF (ICOUNT.GE.NNZW) GO TO 80
         J = I
   70    J = J + 1
         IF (WT(J).LE.0.0D0) GO TO 70
         T = Y(J) - Y(I)
         DIF = DIF + T*T
         IF (TA*T.GE.0.0D0) GO TO 80
         TA = T
         IRUN = IRUN + 1
   80 CONTINUE
      STS(23) = IRUN
      STS(26) = DIF/(STS(2)-1.0D0)
      STS(27) = 0.0D0
      IF (STS(13).NE.0.0D0)
     +   STS(27) = STS(26)/STS(13)
      STS(41) = 0.0D0
      IF (STS(9).NE.0.0D0)
     +   STS(41) = (STS(4)*SQRT(SUMW))/STS(9)
      STS(12) = SUMDA/STS(2)
      T = PPFT(0.975D0, NNZW-1)
      TK1 = PPFCHS(0.975D0, NNZW-1)
      TK2 = PPFCHS(0.025D0, NNZW-1)
      STS(15) = STS(4) - T*STS(10)
      STS(16) = STS(4) + T*STS(10)
      STS(17) = SQRT((STS(2)-1.0D0)/TK1)*STS(9)
      STS(18) = SQRT((STS(2)-1.0D0)/TK2)*STS(9)
      RETURN
      END
*STKCLR
      SUBROUTINE STKCLR (NALL0)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE IS AN ADDITION TO THE FRAMEWORK AREA MANIPULATION
C     ROUTINES.  IT CLEARS ALL ALLOCATIONS MADE SINCE THE FIRST NALL0.
C     IT IS INTENDED FOR USE DURING ERROR OR FINAL EXITS FROM STARPAC
C     ROUTINES WHICH MAKE ALLOCATIONS, TO RELEASE ALL ALLOCATIONS
C     MADE SINCE THE NALL0 EXISTING ON ENTRY TO THE STARPAC ROUTINE,
C     WITHOUT KNOWING HOW MANY ALLOCATIONS MUST BE RELEASED.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   NALL0
C
C  LOCAL SCALARS
      INTEGER
     +   NALLN
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKST
      EXTERNAL STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL STKREL
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER NALL0
C        INPUT PARAMETER.  THE NUMBER OF ALLOCATIONS TO BE PRESERVED
C        WHEN ALL LATER ONES ARE RELEASED.
C     INTEGER NALLN
C        THE TOTAL NUMBER OF ALLOCATIONS EXISTING BEFORE ANY ARE
C        RELEASED.
C
C     COMMENCE BODY OF ROUTINE
C
      NALLN = STKST(1)
      CALL STKREL (NALLN - NALL0)
      RETURN
      END
*STKGET
      INTEGER FUNCTION STKGET(NITEMS, ITYPE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C  ALLOCATES SPACE OUT OF THE INTEGER ARRAY ISTAK (IN COMMON
C  BLOCK CSTAK) FOR AN ARRAY OF LENGTH NITEMS AND OF TYPE
C  DETERMINED BY ITYPE AS FOLLOWS
C
C    1 - LOGICAL
C    2 - INTEGER
C    3 - REAL
C    4 - DOUBLE PRECISION
C    5 - COMPLEX
C
C  ON RETURN, THE ARRAY WILL OCCUPY
C
C    STAK(STKGET), STAK(STKGET+1), ..., STAK(STKGET-NITEMS+1)
C
C  WHERE STAK IS AN ARRAY OF TYPE ITYPE EQUIVALENCED TO ISTAK.
C
C  (FOR THOSE WANTING TO MAKE MACHINE DEPENDENT MODIFICATIONS
C  TO SUPPORT OTHER TYPES, CODES 6, 7, 8, 9, 10, 11 AND 12 HAVE
C  BEEN RESERVED FOR 1/4 LOGICAL, 1/2 LOGICAL, 1/4 INTEGER,
C  1/2 INTEGER, QUAD PRECISION, DOUBLE COMPLEX AND QUAD
C  COMPLEX, RESPECTIVELY.)
C
C  THE USE OF THE FIRST FIVE WORDS IS DESCRIBED BELOW.
C
C    ISTAK( 1) - LOUT,  THE NUMBER OF CURRENT ALLOCATIONS.
C    ISTAK( 2) - LNOW,  THE CURRENT ACTIVE LENGTH OF THE STACK.
C    ISTAK( 3) - LUSED, THE MAXIMUM VALUE OF ISTAK(2) ACHIEVED.
C    ISTAK( 4) - LMAX,  THE MAXIMUM LENGTH THE STACK.
C    ISTAK( 5) - LBOOK, THE NUMBER OF WORDS USED FOR BOOKEEPING.
C
C  THE NEXT FIVE WORDS CONTAIN INTEGERS DESCRIBING THE AMOUNT
C  OF STORAGE ALLOCATED BY THE FORTRAN SYSTEM TO THE VARIOUS
C  DATA TYPES.  THE UNIT OF MEASUREMENT IS ARBITRARY AND MAY
C  BE WORDS, BYTES OR BITS OR WHATEVER IS CONVENIENT.  THE
C  VALUES CURRENTLY ASSUMED CORRESPOND TO AN ANS FORTRAN
C  ENVIRONMENT.  FOR SOME MINI-COMPUTER SYSTEMS THE VALUES MAY
C  HAVE TO BE CHANGED (SEE I0TK00).
C
C    ISTAK( 6) - THE NUMBER OF UNITS ALLOCATED TO LOGICAL
C    ISTAK( 7) - THE NUMBER OF UNITS ALLOCATED TO INTEGER
C    ISTAK( 8) - THE NUMBER OF UNITS ALLOCATED TO REAL
C    ISTAK( 9) - THE NUMBER OF UNITS ALLOCATED TO DOUBLE PRECISION
C    ISTAK(10) - THE NUMBER OF UNITS ALLOCATED TO COMPLEX
C
C     THIS FUNCTION WAS ADAPTED FROM THE FRAMEWORK FUNCTION ISTKGT
C
C     ADAPTED BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ITYPE,NITEMS
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT,LBOOK,LMAX,LNOW,LOUT,LUSED
C
C  LOCAL ARRAYS
      INTEGER
     +   ISIZE(5),ISTAK(12)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (ISTAK(1),LOUT)
      EQUIVALENCE (ISTAK(2),LNOW)
      EQUIVALENCE (ISTAK(3),LUSED)
      EQUIVALENCE (ISTAK(4),LMAX)
      EQUIVALENCE (ISTAK(5),LBOOK)
      EQUIVALENCE (ISTAK(6),ISIZE(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER I
C        THE LOCATION OF A POINTER TO THE END OF THE PREVIOUS ALLOCATION
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ISIZE(5)
C        THE NUMBER OF WORDS IN EACH OF THE VARIOUS DATA TYPES.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ITYPE
C        THE TYPE OF ARRAY OF LENGTH NITEMS TO BE ALLOCATED.
C     INTEGER LBOOK
C        THE NUMBER OF WORDS USED FOR BOOKEEPING.
C     INTEGER LMAX
C        THE MAXIMUM LENGTH OF THE STACK.
C     INTEGER LNOW
C        THE CURRENT ACTIVE LENGTH OF THE STACK.
C     INTEGER LOUT
C        THE NUMBER OF CURRENT ALLOCATIONS.
C     INTEGER LUSED
C        THE MAXIMUM VALUE OF ISTAK(2) ACHEIVED.
C     INTEGER NITEMS
C        THE LENGTH OF THE ARRAY OF ITYPE TO BE ALLOCATED.
C
C
      STKGET = (LNOW*ISIZE(2)-1)/ISIZE(ITYPE) + 2
      I = ( (STKGET-1+NITEMS)*ISIZE(ITYPE) - 1 )/ISIZE(2) + 3
C
C  STACK OVERFLOW IS AN UNRECOVERABLE ERROR.
C
      IF (I .LE. LMAX) GO TO 10
C
      IERR = 1
      CALL IPRINT(IPRT)
      WRITE(IPRT, 1000)
      RETURN
C
   10 CONTINUE
C
C  ISTAK(I-1) CONTAINS THE TYPE FOR THIS ALLOCATION.
C  ISTAK(I  ) CONTAINS A POINTER TO THE END OF THE PREVIOUS
C             ALLOCATION.
C
      ISTAK(I-1) = ITYPE
      ISTAK(I  ) = LNOW
      LOUT = LOUT+1
      LNOW = I
      LUSED = MAX(LUSED, LNOW)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(20H DSTAK IS TOO SHORT.)
C
      END
*STKREL
      SUBROUTINE STKREL(NUMBER)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C  DE-ALLOCATES THE LAST (NUMBER) ALLOCATIONS MADE IN THE STACK
C  BY STKGET.
C
C  ERROR STATES -
C
C    1 - NUMBER .LT. 0
C    2 - LNOW, LUSED, LMAX OR LBOOK OVERWRITTEN
C    3 - ATTEMPT TO DE-ALLOCATE NON-EXISTENT ALLOCATION
C    4 - THE POINTER AT ISTAK(LNOW) OVERWRITTEN
C
C     THIS FUNCTION WAS ADAPTED FROM THE FRAMEWORK FUNCTION ISTKGT
C
C     ADAPTED BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   NUMBER
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IN,IPRT,LBOOK,LMAX,LNOW,LOUT,LUSED
C
C  LOCAL ARRAYS
      INTEGER
     +   ISTAK(12)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (ISTAK(1),LOUT)
      EQUIVALENCE (ISTAK(2),LNOW)
      EQUIVALENCE (ISTAK(3),LUSED)
      EQUIVALENCE (ISTAK(4),LMAX)
      EQUIVALENCE (ISTAK(5),LBOOK)
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IN
C        ...
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER LBOOK
C        THE NUMBER OF WORDS USED FOR BOOKEEPING.
C     INTEGER LMAX
C        THE MAXIMUM LENGTH OF THE STACK.
C     INTEGER LNOW
C        THE CURRENT ACTIVE LENGTH OF THE STACK.
C     INTEGER LOUT
C        THE NUMBER OF CURRENT ALLOCATIONS.
C     INTEGER LUSED
C        THE MAXIMUM VALUE OF ISTAK(2) ACHEIVED.
C     INTEGER NUMBER
C        THE NUMBER OF ALLOCATIONS TO BE FREED FROM THE STACK.
C
C
      IF (LNOW.LT.LBOOK.OR.LNOW.GT.LUSED.OR.LUSED.GT.LMAX) GO TO 20
C
      IN = NUMBER
 10      IF (IN.EQ.0) RETURN
C
         IF (LNOW.LE.LBOOK) GO TO 30
C
C     CHECK TO MAKE SURE THE BACK POINTERS ARE MONOTONE.
C
         IF (ISTAK(LNOW).LT.LBOOK.OR.ISTAK(LNOW).GE.LNOW-1) GO TO 40
C
         LOUT = LOUT-1
         LNOW = ISTAK(LNOW)
         IN = IN-1
         GO TO 10
C
C     PRINT ERROR MESSAGES
C
   20 IERR = 1
      CALL IPRINT(IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
   30 IERR = 1
      CALL IPRINT(IPRT)
      WRITE (IPRT, 1010)
      RETURN
C
   40 IERR = 1
      CALL IPRINT(IPRT)
      WRITE (IPRT, 1020) LOUT
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (///18H ***** ERROR *****//
     +   50H DSTAK BOOKKEEPING ELEMENTS HAVE BEEN OVERWRITTEN.)
 1010 FORMAT (///18H ***** ERROR *****//
     +   52H ATTEMPT HAS BEEN MADE TO DE-ALLOCATE A NON-EXISTANT,
     +   21H ALLOCATION IN DSTAK.)
 1020 FORMAT (///18H ***** ERROR *****//
     +   35H THE POINTER FOR ALLOCATION NUMBER , I3, 9H HAS BEEN,
     +   13H OVERWRITTEN.)
C
      END
*STKSET
      SUBROUTINE STKSET (NITEMS, ITYPE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C  INITIALIZES THE STACK TO NITEMS OF TYPE ITYPE
C
C     THIS FUNCTION WAS ADAPTED FROM THE FRAMEWORK SUBROUTINE ISTKIN
C
C     ADAPTED BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ITYPE,NITEMS
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   LBOOK,LMAX,LNOW,LOUT,LUSED
C
C  LOCAL ARRAYS
      INTEGER
     +   ISIZE(5),ISTAK(12)
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (ISTAK(1),LOUT)
      EQUIVALENCE (ISTAK(2),LNOW)
      EQUIVALENCE (ISTAK(3),LUSED)
      EQUIVALENCE (ISTAK(4),LMAX)
      EQUIVALENCE (ISTAK(5),LBOOK)
      EQUIVALENCE (ISTAK(6),ISIZE(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISIZE(5)
C        THE NUMBER OF WORDS IN EACH OF THE VARIOUS DATA TYPES.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ITYPE
C        THE TYPE OF ARRAY OF LENGTH NITEMS TO BE ALLOCATED.
C     INTEGER LBOOK
C        THE NUMBER OF WORDS USED FOR BOOKEEPING.
C     INTEGER LMAX
C        THE MAXIMUM LENGTH OF THE STACK.
C     INTEGER LNOW
C        THE CURRENT ACTIVE LENGTH OF THE STACK.
C     INTEGER LOUT
C        THE NUMBER OF CURRENT ALLOCATIONS.
C     INTEGER LUSED
C        THE MAXIMUM VALUE OF ISTAK(2) ACHEIVED.
C     INTEGER NITEMS
C        THE LENGTH OF THE ARRAY OF ITYPE TO BE ALLOCATED.
C
C  HERE TO INITIALIZE
C
C  SET DATA SIZES APPROPRIATE FOR A STANDARD CONFORMING
C  FORTRAN SYSTEM USING THE FORTRAN "STORAGE UNIT" AS THE
C  MEASURE OF SIZE.
C
C  LOGICAL
      ISIZE(1) = 1
C  INTEGER
      ISIZE(2) = 1
C  DOUBLE PRECISION
      ISIZE(3) = 1
C  DOUBLE PRECISION
      ISIZE(4) = 2
C  COMPLEX
      ISIZE(5) = 2
C
      LBOOK = 10
      LNOW  = LBOOK
      LUSED = LBOOK
      LMAX  = MAX( (NITEMS*ISIZE(ITYPE))/ISIZE(2), 12 )
      LOUT  = 0
C
      RETURN
C
      END
*STKST
      INTEGER FUNCTION STKST (NFACT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE REPLACES INTEGER FUNCTION ISTKST IN THE FRAMEWORK
C     FOR USE WITH STARPAC.  RETURNS ONE OF FOUR STATISTICS ON THE
C     STATE OF THE CSTAK STACK.
C
C     IMPORTANT - THIS ROUTINE ASSUMES THAT THE STACK IS INITIALIZED.
C                 IT DOES NOT CHECK TO SEE IF IT IS.  IN FACT, THERE
C                 IS NO WAY THAT IT COULD CHECK.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 14, 1983
C        BASED ON FRAMEWORK ROUTINE ISTKST.
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   NFACT
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
C
C  LOCAL ARRAYS
      INTEGER
     +   ISTAK(12),ISTATS(4)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (ISTAK(1),ISTATS(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IPRT
C        THE NUMBER OF THE STANDARD OUTPUT UNIT.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISTATS(4)
C        INTEGER ARRAY INCLUDING THE FOUR STACK STATISTICS.
C     INTEGER NFACT
C
C
C     COMMENCE BODY OF ROUTINE
C
      IF (NFACT .GT. 0 .AND. NFACT .LT. 6) GO TO 10
C
C     REPORT ERROR STATUS
C
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000) IPRT
      STKST = 0
      RETURN
C
C     REPORT TRUE VALUE OF A STATISTIC, ASSUMING STACK IS
C     DEFINED.
C
   10 STKST = ISTATS(NFACT)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (///18H ***** ERROR *****//
     +   24H ILLEGAL STACK STATISTIC, I5, 11H REQUESTED.)
      END
*STPADJ
      SUBROUTINE STPADJ(XM, N, M, IXM, MDL, PAR, NPAR,
     +   NEXMPT, STP, NFAIL, IFAIL, J, RELTOL, ABSTOL, STPLOW, STPMID,
     +   STPUP, ITEMP, FD, FDLAST, PV, PVNEW)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE ADJUSTS THE SELECTED STEP SIZES TO OPTIMAL
C     VALUES.
C
C     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ABSTOL,RELTOL,STP,STPLOW,STPMID,STPUP
      INTEGER
     +   IXM,J,M,N,NEXMPT,NFAIL,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FD(N),FDLAST(N),PAR(NPAR),PV(N),PVNEW(N),XM(IXM,M)
      INTEGER
     +   IFAIL(N),ITEMP(N)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  SCALARS IN COMMON
      DOUBLE PRECISION
     +   Q
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FACTOR,STPNEW,TEMP
      INTEGER
     +   NCOUNT
      LOGICAL
     +   DONE,FIRST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CMPFD,ICOPY,RELCOM,DCOPY
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,SIGN
C
C  COMMON BLOCKS
      COMMON /NOTOPT/Q
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ABSTOL
C        THE ABSOLUTE AGREEMENT TOLERANCE.
C     LOGICAL DONE
C        THE VARIABLE USED TO INDICATE WHETHER THE ADJUSTMENT
C        PROCESS IS COMPLETE OR NOT.
C     DOUBLE PRECISION FACTOR
C        A FACTOR USED IN COMPUTING THE STEP SIZE.
C     DOUBLE PRECISION FD(N)
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
C     DOUBLE PRECISION FDLAST(N)
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
C        COMPUTED WITH THE MOST RECENT STEP SIZE SELECTED.
C     LOGICAL FIRST
C        THE VARIABLE USED TO INDICATE WHETHER THIS STEP SIZE
C        IS BEING USED FOR THE FIRST TIME OR WHETHER IT HAS BEEN
C        PREVIOUSLY ADJUSTED.
C     INTEGER IFAIL(N)
C        AN INDICATOR VECTOR USED TO DESIGNATE THOSE OBSERVATIONS
C        FOR WHICH THE STEP SIZE DOES NOT MEET THE CRITERIA.
C     INTEGER ITEMP(N)
C        A TEMPORARY VECTOR USED FOR STORING PAST VALUES OF ITEMP.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER J
C        THE INDEX OF THE PARAMETER BEING EXAMINED.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NCOUNT
C        THE NUMBER OF OBSERVATIONS AT WHICH THE NEW STEP SIZE DOES
C        SATISFY THE CRITERIA.
C     INTEGER NEXMPT
C        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
C        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
C        SIZE STILL BE CONSIDERED OK.
C     INTEGER NFAIL
C        A VECTOR CONTAINING FOR EACH OBSERVATION THE NUMBER OF
C        OBSERVATIONS FOR WHICH THE STEP SIZE DID NOT MEET THE CRITERIA.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION PVNEW(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCD.
C     DOUBLE PRECISION Q
C        A DUMMY VARIABLE WHICH IS USED, ALONG WITH COMMON NOTOPT (NO
C        OPTIMIZATION), TO COMPUTE THE STEP SIZE.
C     DOUBLE PRECISION RELTOL
C        THE RELATIVE AGREEMENT TOLERANCE.
C     DOUBLE PRECISION STP
C        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FORWARD
C        DIFFERENCE APPROXIMATION TO THE DERIVATIVE.
C     DOUBLE PRECISION STPLOW
C        THE LOWER LIMIT ON THE STEP SIZE.
C     DOUBLE PRECISION STPMID
C        THE MIDPOINT OF THE ACCEPTABLE RANGE OF THE STEP SIZE.
C     DOUBLE PRECISION STPNEW
C        THE VALUE OF THE NEW STEP SIZE BEING TESTED.
C     DOUBLE PRECISION STPUP
C        THE UPPER LIMIT ON THE STEP SIZE.
C     DOUBLE PRECISION TEMP
C        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
C        PARAMETER IS STORED.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
      CALL ICOPY(N, IFAIL, 1, ITEMP, 1)
      NCOUNT = NFAIL
C
      IF ((STPLOW.LE.ABS(STP)) .AND. (ABS(STP).LE.STPUP)) RETURN
C
      IF (ABS(STP).GT.STPMID) THEN
C
            STPNEW = STPUP * SIGN(1.0D0, PAR(J))
            FACTOR = 10.0D0
      ELSE
C
            STPNEW = STPLOW * SIGN(1.0D0, PAR(J))
            FACTOR = 0.1D0
C
      END IF
C
      Q = STPNEW + PAR(J)
      STPNEW = Q - PAR(J)
C
      DONE = .FALSE.
      FIRST = .TRUE.
C
C     REPEAT STATEMENTS 60 TO 130 UNTIL (DONE)
C
   60 CONTINUE
C
         CALL DCOPY(N, FD, 1, FDLAST, 1)
C
         TEMP = PAR(J)
         PAR(J) = TEMP + STPNEW
         CALL MDL(PAR, NPAR, XM, N, M, IXM, PVNEW)
         PAR(J) = TEMP
C
         CALL CMPFD(N, STPNEW, PVNEW, PV, FD)
C
         CALL RELCOM(N, FD, FDLAST, RELTOL, ABSTOL, NCOUNT, ITEMP)
C
         IF (NCOUNT.LE.NEXMPT) THEN
               DONE = .TRUE.
               CALL ICOPY(N, ITEMP, 1, IFAIL, 1)
               NFAIL = NCOUNT
C
               IF (FIRST) THEN
                     STP = STPNEW
               ELSE
                     STP = STPNEW / FACTOR
               END IF
C
         ELSE
C
               FIRST = .FALSE.
               STPNEW = STPNEW * FACTOR
               Q = STPNEW + PAR(J)
               STPNEW = Q - PAR(J)
C
               IF ((FACTOR.GT.1.0D0 .AND. ABS(STPNEW).GT.ABS(STP))
     +            .OR.
     +            (FACTOR.LT.1.0D0 .AND. ABS(STPNEW).LT.ABS(STP)))
     +            DONE = .TRUE.
          END IF
C
      IF (DONE) THEN
         RETURN
      ELSE
         GO TO 60
      END IF
C
      END
*STPAMO
      SUBROUTINE STPAMO(HEAD, N, EXM, NEXMPT, NETA, J, PAR, NPAR, STP,
     +   NFAIL, IFAIL, SCALE, LSCALE, HDR, PAGE, WIDE, ISUBHD, NPRT,
     +   PRTFXD, IFIXD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS A DUMMY ROUTINE FOR THE ARIMA ESTIMATION ROUTINES
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   EXM
      INTEGER
     +   ISUBHD,J,LSCALE,N,NETA,NEXMPT,NPAR,NPRT
      LOGICAL
     +   HEAD,PAGE,PRTFXD,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),SCALE(LSCALE),STP(NPAR)
      INTEGER
     +   IFAIL(N),IFIXD(NPAR),NFAIL(NPAR)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL HDR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION EXM
C        THE PROPORTION OF OBSERVATIONS ACTUALLY USED FOR WHICH THE
C        COMPUTED NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE
C        EXEMPTED FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
C     EXTERNAL HDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IFAIL(N)
C        THE ARRAY OF INDICATOR VARIABLES DESIGNATING WHETHER
C        THE STEP SIZE SELECTED WAS SATISFACTORY FOR A GIVEN
C        OBSERVATION AND PARAMETER.
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXD(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXD(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C     INTEGER ISUBHD
C     INTEGER J
C        THE INDEX OF THE PARAMETER BEING EXAMINED.
C     INTEGER LSCALE
C        THE LENGTH OF VECTOR SCALE.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NETA
C        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
C     INTEGER NEXMPT
C        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
C        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
C        SIZE STILL BE CONSIDERED OK.
C     INTEGER NFAIL(NPAR)
C        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP
C        SIZE DOES NOT MEET THE CRITERIA.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE OUTPUT
C        IS TO BEGIN ON A NEW PAGE.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
C        PARAMETERS ARE STORED.
C     LOGICAL PRTFXD
C        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
C        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
C        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION STP(NPAR)
C        THE SELECTED STEP SIZE.
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C
      RETURN
C
      END
*STPCNT
      SUBROUTINE STPCNT(XM, N, M, IXM, MDL, PAR, NPAR, STP,
     +   EXMPT, NETA, SCALE, LSCALE, NPRT, HDR, PAGE, WIDE, ISUBHD,
     +   HLFRPT, PRTFXD, IFIXED, LIFIXD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CONTROLS THE STEP SIZE SELECTION PROCESS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   EXMPT
      INTEGER
     +   ISUBHD,IXM,LIFIXD,LSCALE,M,N,NETA,NPAR,NPRT
      LOGICAL
     +   HLFRPT,PAGE,PRTFXD,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),SCALE(LSCALE),STP(NPAR),XM(IXM,M)
      INTEGER
     +   IFIXED(LIFIXD)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL HDR,MDL
C
C  SCALARS IN COMMON
      DOUBLE PRECISION
     +   Q
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ETA,EXM,FPLRS,SCL,TAU
      INTEGER
     +   CD,FD,FDLAST,FDSAVE,IFAILJ,IFIXD,IFP,ITEMP,J,MXFAIL,NALL0,
     +   NDD,NDGT1,NEXMPT,NFAIL,NFAILJ,PARTMP,PV,PVMCD,PVNEW,PVPCD,
     +   PVSTP,PVTEMP
      LOGICAL
     +   HEAD
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      INTEGER
     +   STKGET,STKST
      EXTERNAL D1MACH,STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CPYVII,ETAMDL,SETIV,STKCLR,STPMN,STPOUT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,INT,LOG10,MAX,MIN
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
      COMMON /NOTOPT/Q
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER CD
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE CENTRAL DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION ETA
C        THE RELATIVE NOISE IN THE MODEL
C     DOUBLE PRECISION EXM
C        THE PROPORTION OF OBSERVATIONS ACTUALLY USED FOR WHICH THE
C        COMPUTED NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE
C        EXEMPTED FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
C     DOUBLE PRECISION EXMPT
C        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
C        NUMERICAL DRVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
C        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
C     INTEGER FD
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
C     INTEGER FDLAST
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
C        FOR THE LAST STEP SIZE TRIED.
C     INTEGER FDSAVE
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
C        FOR THE BEST STEP SIZE TRIED SO FAR.
C     DOUBLE PRECISION FPLRS
C        THE FLOATING POINT LARGEST RELATIVE SPACING.
C     EXTERNAL HDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     LOGICAL HLFRPT
C        THE VARIABLE WHICH INDICATES WHETHER THE STEP SIZE SELECTION
C        ROUTINE HAS ALREADY PRINTED PART OF THE INITIAL SUMMARY (TRUE)
C        OR NOT (FALSE).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFAILJ
C        THE STARTING LOCATION IN ISTAK FOR
C        THE ARRAY OF INDICATOR VARIABLES DESIGNATING WHETHER
C        THE SETP SIZE SELECTED WAS SATISFACOTRY FOR A GIVEN
C        OBSERVATION AND THE JTH PARAMETER.
C     INTEGER IFIXD
C        THE STARTING LOCATION IN ISTAK OF
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
C     INTEGER IFIXED(LIFIXD)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     INTEGER ITEMP
C        THE STARTING LOCATION IN ISTAK FOR
C        A TEMPORARY STORAGE VECTOR.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER J
C        THE INDEX OF THE PARAMETER BEING EXAMINED.
C     INTEGER LIFIXD
C        THE LENGTH OF THE VECTOR IFIXED.
C     INTEGER LSCALE
C        THE LENGTH OF VECTOR SCALE.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER MXFAIL
C        THE MAXIMUM NUMBER OF FAILURES FOR ANY PARAMETER.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NALL0
C        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
C     INTEGER NDD
C        THE NUMBER OF DECIMAL DIGITS CARRIED FOR A DOUBLE PRECISION
C        NUMBERS.
C     INTEGER NDGT1
C        THE NUMBER OF RELIABLE DIGITS IN THE MODEL USED, EITHER
C        SET TO THE USER SUPPLIED VALUE OF NETA, OR COMPUTED
C        BY ETAMDL.
C     INTEGER NETA
C        THE USER SUPPLIED NUMBER OF RELIABLE DIGITS IN THE MODEL.
C     INTEGER NEXMPT
C        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
C        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
C        SIZE STILL BE CONSIDERED OK.
C     INTEGER NFAIL
C        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP SIZE
C        FOR THE PARAMETER DOES NOT MEET THE CRITERIA.
C     INTEGER NFAILJ
C        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP SIZE
C        FOR THE JTH PARAMETER DOES NOT MEET THE CRITERIA.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     INTEGER PARTMP
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE MODIFIED MODEL PARAMETERS
C     LOGICAL PRTFXD
C        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
C        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
C        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
C     INTEGER PV
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     INTEGER PVMCD
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     INTEGER PVNEW
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPNEW.
C     INTEGER PVPCD
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCD.
C     INTEGER PVSTP
C        THE STARTING LOCATION IN THE WORK AREA OF
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STP(J).
C     INTEGER PVTEMP
C        THE STARTING LOCATION IN THE WORK AREA OF
C        A TEMPORY STORAGE LOCATION FOR PREDICTED VALUES BEGINS.
C     DOUBLE PRECISION Q
C        A DUMMY VARIABLE WHICH IS USED, ALONG WITH COMMON NOTOPT (NO
C        OPTIMIZATION), TO COMPUTE THE STEP SIZE.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION SCL
C        THE ACTUAL TYPICAL SIZE USED.
C     DOUBLE PRECISION STP(NPAR)
C        THE SELECTED STEP SIZES.
C     DOUBLE PRECISION TAU
C        THE AGREEMENT TOLERANCE.
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
C
      NALL0 = STKST(1)
C
      FPLRS = D1MACH(4)
      IFP = 4
C
C     SET PRINT CONTROLS
C
      HEAD = .TRUE.
C
C     SUBDIVIDE WORK AREA
C
      IFIXD = STKGET(NPAR, 2)
      ITEMP = STKGET(N, 2)
      IFAILJ = STKGET(N, 2)
      NFAIL = STKGET(NPAR, 2)
C
      CD = STKGET(MAX(N,NPAR), IFP)
      FD = STKGET(N, IFP)
      FDLAST = STKGET(N, IFP)
      FDSAVE = STKGET(N, IFP)
      PV = STKGET(N, IFP)
      PVMCD = STKGET(N, IFP)
      PVNEW = STKGET(N, IFP)
      PVPCD = STKGET(N, IFP)
      PVSTP = STKGET(N, IFP)
      PVTEMP = STKGET(N, IFP)
C
      IF (IERR .EQ. 1) RETURN
C
      PARTMP = CD
C
C     SET UP IFIXD
C
      IF (IFIXED(1).LT.0) THEN
         CALL SETIV(ISTAK(IFIXD), NPAR, 0)
      ELSE
         CALL CPYVII(NPAR, IFIXED, 1, ISTAK(IFIXD), 1)
      END IF
C
C     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
C
      NDD = INT(-LOG10(FPLRS))
C
      IF ((NETA.GE.2) .AND. (NETA.LE.NDD)) THEN
         ETA = 10.0D0 ** (-NETA)
         NDGT1 = NETA
      ELSE
         CALL ETAMDL(MDL, PAR, NPAR, XM, N, M, IXM, ETA, NDGT1,
     +               RSTAK(PARTMP), RSTAK(PVTEMP), 0)
      END IF
C
      TAU = MIN(ETA ** (0.25D0), 0.01D0)
C
      EXM = EXMPT
      IF ((EXM.LT.0.0D0) .OR. (EXM.GT.1.0D0)) EXM = 0.10D0
      NEXMPT = EXM * N
      IF (EXM .NE. 0.0D0) NEXMPT = MAX(NEXMPT, 1)
C
C     COMPUTE PREDICTED VALUES OF THE MODEL USING THE INPUT PARAMETER
C     ESTIMATES
C
      CALL MDL(PAR, NPAR, XM, N, M, IXM, RSTAK(PV))
C
      MXFAIL = 0
      NFAILJ = NFAIL
C
      DO 120 J = 1, NPAR
         IF (ISTAK(IFIXD-1+J).EQ.0) THEN
            IF (SCALE(1).LE.0.0D0) THEN
               IF (PAR(J).EQ.0.0D0) THEN
                  SCL = 1.0D0
               ELSE
                  SCL = ABS(PAR(J))
               END IF
            ELSE
               SCL = SCALE(J)
            END IF
C
            CALL STPMN(J, XM, N, M, IXM, MDL, PAR, NPAR, NEXMPT,
     +         ETA, TAU, SCL, STP(J), ISTAK(NFAILJ), ISTAK(IFAILJ),
     +         RSTAK(CD), ISTAK(ITEMP), RSTAK(FD), RSTAK(FDLAST),
     +         RSTAK(FDSAVE), RSTAK(PV), RSTAK(PVMCD), RSTAK(PVNEW),
     +         RSTAK(PVPCD), RSTAK(PVSTP), RSTAK(PVTEMP))
C
C     COMPUTE THE MAXIMUM NUMBER OF FAILURES FOR ANY PARAMETER
C
            MXFAIL = MAX(ISTAK(NFAILJ), MXFAIL)
C
         ELSE
            STP(J) = 0.0
         END IF
C
C     PRINT RESULTS IF THEY ARE DESIRED
C
         IF ((NPRT.NE.0) .OR. (MXFAIL.GT.NEXMPT))
     +      CALL STPOUT(HEAD, N, EXM, NEXMPT, NDGT1, J, PAR, NPAR,
     +            STP, ISTAK(NFAIL), ISTAK(IFAILJ), SCALE,  LSCALE, HDR,
     +            PAGE, WIDE, ISUBHD, NPRT, PRTFXD, ISTAK(IFIXD))
         NFAILJ = NFAILJ + 1
  120 CONTINUE
C
      HLFRPT = .FALSE.
      IF ((NPRT.NE.0) .OR. (MXFAIL.GT.NEXMPT)) HLFRPT = .TRUE.
C
      IF (MXFAIL.GT.NEXMPT) IERR = 2
C
      CALL STKCLR(NALL0)
C
      RETURN
C
      END
*STPDRV
      SUBROUTINE STPDRV(NMSUB, XM, N, M, IXM, MDL, PAR, NPAR, LDSTAK,
     +   STP, NETA, EXMPT, SCALE, LSCALE, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE DRIVER ROUTINE FOR SELECTING STEP SIZES
C     TO BE USED IN COMPUTING FORWARD DIFFERENCE QUOTIENT ESTIMATES
C     OF THE NUMERICAL DERIVATIVES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   EXMPT
      INTEGER
     +   IXM,LDSTAK,LSCALE,M,N,NETA,NPAR,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),SCALE(*),STP(*),XM(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   ISUBHD,LIFIXD
      LOGICAL
     +   HLFRPT,PAGE,PRTFXD,WIDE
C
C  LOCAL ARRAYS
      INTEGER
     +   IFIXED(1)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL STKSET,STPCNT,STPER,STPHDR
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION EXMPT
C        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
C        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXCEPTED
C        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
C     LOGICAL HLFRPT
C        THE VARIABLE WHICH INDICATES WHETHER THE STEP SIZE SELECTION
C        ROUTINE HAS ALREADY PRINTED PART OF THE INITIAL SUMMARY (TRUE)
C        OR NOT (FALSE).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(1)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LIFIXD
C        THE LENGTH OF THE VECTOR IFIXED.
C     INTEGER LSCALE
C        THE LENGTH OF VECTOR SCALE.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NETA
C        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     LOGICAL PRTFXD
C        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
C        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
C        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
C     DOUBLE PRECISION STP(NPAR)
C        THE SELECTED STEP SIZES.
C     EXTERNAL STPHDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C     DOUBLE PRECISION XM(IXM,M)
C        THE INDEPENDENT VARIABLE ARRAY
C
C
C     PERFORM ERROR CHECKING
C
      CALL STPER(NMSUB, N, M, IXM, NPAR, LDSTAK, SCALE, LSCALE)
C
      IF (IERR.NE.0) RETURN
C
      CALL STKSET(LDSTAK, 4)
C
      PAGE = .FALSE.
      WIDE = .TRUE.
      ISUBHD = 0
C
      PRTFXD = .FALSE.
      IFIXED(1) = -1
      LIFIXD = 1
C
C     PASS CONTROL OF STEP SIZE SELECTION TO SUBROUTINE STPCNT
C
      CALL STPCNT(XM, N, M, IXM, MDL, PAR, NPAR, STP, EXMPT, NETA,
     +   SCALE, LSCALE, NPRT, STPHDR, PAGE, WIDE, ISUBHD, HLFRPT,
     +   PRTFXD, IFIXED, LIFIXD)
C
      RETURN
C
      END
*STPER
      SUBROUTINE STPER(NMSUB, N, M, IXM, NPAR, LDSTAK, SCALE, LSCALE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE ERROR CHECKING ROUTINE FOR STEP SIZE SELECTION
C     ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,LSCALE,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   SCALE(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I,LDSMIN,NV
      LOGICAL
     +   HEAD
C
C  LOCAL ARRAYS
      LOGICAL
     +   ERROR(10)
      CHARACTER
     +   LIXM(8)*1,LLDS(8)*1,LM(8)*1,LN(8)*1,LNPAR(8)*1,
     +   LONE(8)*1,LSCL(8)*1,LZERO(8)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,ERVGT,LDSCMP
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR(10)
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     CHARACTER*1 LIXM(8), LLDS(8), LM(8), LN(8), LNPAR(8), LONE(8),
C    +            LSCL(8), LZERO(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
C        CHECKED FOR ERRORS.
C     INTEGER LSCALE
C        THE LENGTH OF VECTOR SCALE.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NV
C        THE NUMBER OF VIOLATIONS FOUND.
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
C
C     SET UP NAME ARRAYS
C
      DATA LIXM(1), LIXM(2), LIXM(3), LIXM(4), LIXM(5), LIXM(6),
     +   LIXM(7), LIXM(8) /'I','X','M',' ',' ',' ',' ',' '/
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +   LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA LM(1), LM(2), LM(3), LM(4), LM(5), LM(6), LM(7), LM(8) /'M',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8) /'N',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LNPAR(1), LNPAR(2), LNPAR(3), LNPAR(4), LNPAR(5),
     +   LNPAR(6), LNPAR(7), LNPAR(8) /'N','P','A','R',' ',' ',' ',
     +   ' '/
      DATA LONE(1), LONE(2), LONE(3), LONE(4), LONE(5),
     +   LONE(6), LONE(7), LONE(8) /' ',' ','O','N','E',' ',' ',
     +   ' '/
      DATA LSCL(1), LSCL(2), LSCL(3), LSCL(4), LSCL(5),
     +   LSCL(6), LSCL(7), LSCL(8) /'S','C','A','L','E',' ',' ',
     +   ' '/
      DATA LZERO(1), LZERO(2), LZERO(3), LZERO(4), LZERO(5),
     +   LZERO(6), LZERO(7), LZERO(8) /'Z','E','R','O',' ',' ',' ',' '/
C
C     ERROR CHECKING
C
      DO 10 I=1,10
         ERROR(I) = .FALSE.
   10 CONTINUE
C
      IERR = 0
      HEAD = .TRUE.
C
      CALL EISGE(NMSUB, LN, N, 1, 2, HEAD, ERROR(1), LONE)
C
      CALL EISGE(NMSUB, LM, M, 1, 2, HEAD, ERROR(2), LONE)
C
      CALL EISGE(NMSUB, LIXM, IXM, N, 3, HEAD, ERROR(3), LN)
C
      CALL EISGE(NMSUB, LNPAR, NPAR, 1, 2, HEAD, ERROR(4), LONE)
C
      CALL LDSCMP(14, 0, 2*(N+NPAR), 0, 0, 0, 'D', 9*N + MAX(N,NPAR),
     +            LDSMIN)
C
      IF ((.NOT.ERROR(1)) .AND. (.NOT.ERROR(4)))
     +   CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR(5),
     +   LLDS)
C
      CALL ERVGT(NMSUB, LSCL, SCALE, LSCALE, 0.0D0, 0, HEAD, 6, NV,
     +   ERROR(9), LZERO)
C
C
      DO 20 I=1,10
         IF (ERROR(I)) GO TO 30
   20 CONTINUE
      RETURN
C
   30 CONTINUE
      IERR = 1
      RETURN
C
      END
*STPHDR
      SUBROUTINE STPHDR(PAGE, WIDE, ISUBHD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS THE PAGE HEADINGS FOR THE
C     STEP SIZE SELECTION ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISUBHD
      LOGICAL
     +   PAGE,WIDE
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VERSP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ISUBHD
C        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
C        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     LOGICAL WIDE
C       THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        FULL WIDTH (TRUE) OR NOT (FALSE).
C
      CALL IPRINT(IPRT)
      IF (PAGE) WRITE (IPRT, 1020)
      CALL VERSP(WIDE)
      IF (PAGE) WRITE (IPRT,1000)
      IF (.NOT.PAGE) WRITE (IPRT,1010)
      PAGE = .TRUE.
C
      IF (ISUBHD.EQ.0) RETURN
C
      GO TO (10), ISUBHD
C
   10 WRITE (IPRT, 1030)
C
      RETURN
C
C     FORMAT STATEMENTS FOR PAGE HEADINGS
C
 1000 FORMAT (32H+DERIVATIVE STEP SIZE SELECTION,,
     +   10H CONTINUED)
 1010 FORMAT ('+', 34(1H*)/ 35H * DERIVATIVE STEP SIZE SELECTION */
     +   1X, 34(1H*))
 1020 FORMAT ('1')
 1030 FORMAT (//30H SUMMARY OF INITIAL CONDITIONS/ 1X, 30('-'))
      END
*STPLS
      SUBROUTINE STPLS(XM, N, M, IXM, MDL, PAR, NPAR, LDSTAK, STP)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR SELECTING STEP SIZES
C     TO BE USED IN COMPUTING FORWARD DIFFERENCE QUOTIENT ESTIMATES
C     OF THE NUMERICAL DERIVATIVES FOR THE NONLINEAR LEAST SQUARES
C     ROUTINES (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,M,N,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),STP(*),XM(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   EXMPT
      INTEGER
     +   IPRT,LSCALE,NETA,NPRT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   SCALE(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,STPDRV
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION EXMPT
C        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
C        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXCEPTED
C        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LSCALE
C        THE LENGTH OF VECTOR SCALE.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NETA
C        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION SCALE(1)
C        A DUMMY VECTOR USED TO DESIGNATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION STP(NPAR)
C        THE SELECTED STEP SIZES.
C     DOUBLE PRECISION XM(IXM,M)
C        THE INDEPENDENT VARIABLE ARRAY
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'S','T','P','L','S',' '/
C
C     SET UP DEFAULT VALUES
C
      EXMPT = 0.1D0
      NETA = 0
      SCALE(1) = 0.0D0
      LSCALE = 1
      NPRT = 1
C
C     PASS CONTROL TO STEP SIZE SELECTION DRIVER
C
      CALL STPDRV(NMSUB, XM, N, M, IXM, MDL, PAR, NPAR, LDSTAK, STP,
     +   NETA, EXMPT, SCALE, LSCALE, NPRT)
C
      IF (IERR.NE.1) RETURN
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL STPLS (XM, N, M, IXM, NLSMDL, PAR, NPAR, LDSTAK,',
     +   ' STP)')
      END
*STPLSC
      SUBROUTINE STPLSC(XM, N, M, IXM, MDL, PAR, NPAR, LDSTAK, STP,
     +   NETA, EXMPT, SCALE, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE SUBROUTINE FOR SELECTING STEP SIZES
C     TO BE USED IN COMPUTING FORWARD DIFFERENCE QUOTIENT ESTIMATES
C     OF THE NUMERICAL DERIVATIVES FOR THE NONLINEAR LEAST SQUARES
C     ROUTINES (LONG CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   EXMPT
      INTEGER
     +   IXM,LDSTAK,M,N,NETA,NPAR,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),SCALE(*),STP(*),XM(*)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,LSCALE
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,STPDRV
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION EXMPT
C        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
C        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
C        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LSCALE
C        THE LENGTH OF VECTOR SCALE.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NETA
C        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINES.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION SCALE(NPAR)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION STP(NPAR)
C        THE SELECTED STEP SIZES.
C     DOUBLE PRECISION XM(IXM,M)
C        THE INDEPENDENT VARIABLE ARRAY
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'S','T','P','L','S','C'/
C
C     SET LENGTH OF VECTOR SCALE.
C
      LSCALE = NPAR
C
C     PASS CONTROL TO STEP SIZE SELECTION DRIVER
C
      CALL STPDRV(NMSUB, XM, N, M, IXM, MDL, PAR, NPAR, LDSTAK, STP,
     +   NETA, EXMPT, SCALE, LSCALE, NPRT)
C
      IF (IERR.NE.1) RETURN
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL STPLSC (XM, N, M, IXM, NLSMDL, PAR, NPAR, LDSTAK,',
     + ' STP,'/
     + '      +             NETA, EXMPT, SCALE, NPRT)')
      END
*STPLS1
      SUBROUTINE STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     SET UP PROBLEM SPECIFICATION FOR TESTING THE USER CALLABLE
C     ROUTINES IN THE (LEAST SQUARES) STEP SIZE SELECTION FAMILY.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   EXMPT
      INTEGER
     +   IXM,M,N,NETA,NPAR,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(10),SCALE(10)
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION EXMPT
C        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
C        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
C        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NETA
C        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     DOUBLE PRECISION PAR(10)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION SCALE(10)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
C
      PAR(1) = 0.0D0
      PAR(2) = 3.125D0
      PAR(3) = 1.0D0
      PAR(4) = 2.0D0
C
      N = 101
      M = 1
      IXM = 200
      NPAR = 4
      DO 10 I=1,10
         SCALE(I) = 1.0D0
   10 CONTINUE
      NETA = 0
      EXMPT = 0.0D0
      NPRT = 1
C
      RETURN
C
      END
*STPLS2
      SUBROUTINE STPLS2(NPAR, STP)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     SET UP PROBLEM SPECIFICATION FOR TESTING THE USER CALLABLE
C     ROUTINES IN THE (LEAST SQUARES) STEP SIZE SELECTION FAMILY.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   STP(NPAR)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     DOUBLE PRECISION STP(NPAR)
C        THE STEP SIZE ARRAY.
C
      DO 10 I=1,NPAR
         STP(I) = -1.0D0
   10 CONTINUE
C
      IERR = -1
C
      RETURN
C
      END
*STPMN
      SUBROUTINE STPMN(J,XM,N,M,IXM,MDL,PAR,NPAR,
     +   NEXMPT,ETA,RELTOL,SCALE,STP,NFAIL,IFAIL,CD,
     +   ITEMP,FD,FDLAST,FDSAVE,PV,PVMCD,PVNEW,PVPCD,PVSTP,PVTEMP)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN SUBROUTINE FOR SELECTING THE STEP SIZE FOR
C     COMPUTING AGAINST NUMERICAL DERIVATIVES
C
C     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ETA,RELTOL,SCALE,STP
      INTEGER
     +   IXM,J,M,N,NEXMPT,NFAIL,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CD(N),FD(N),FDLAST(N),FDSAVE(N),PAR(NPAR),PV(N),PVMCD(N),
     +   PVNEW(N),PVPCD(N),PVSTP(N),PVTEMP(N),XM(IXM,M)
      INTEGER
     +   IFAIL(N),ITEMP(N)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  SCALARS IN COMMON
      DOUBLE PRECISION
     +   Q
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ABSTOL,CURVE,ETA3,FPLRS,PARMX,PVMEAN,PVTYP,STPCD,STPLOW,
     +   STPMID,STPUP,TAUABS,TEMP,THIRD
      INTEGER
     +   I
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CMPFD,GMEAN,RELCOM,STPADJ,STPSEL
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,SIGN,SQRT
C
C  COMMON BLOCKS
      COMMON /NOTOPT/Q
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ABSTOL
C        THE ABSOLUTE AGREEMENT TOLERANCE.
C     DOUBLE PRECISION CD(N)
C        THE CENTRAL DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
C     DOUBLE PRECISION CURVE
C        A MEASURE OF THE CURVATURE OF THE MODEL.
C     DOUBLE PRECISION ETA
C        THE RELATIVE NOISE IN THE MODEL
C     DOUBLE PRECISION ETA3
C        THE CUBE ROOT OF ETA.
C     DOUBLE PRECISION FD(N)
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
C     DOUBLE PRECISION FDLAST(N)
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
C        COMPUTED WITH THE MOST RECENT STEP SIZE SELECTED.
C     DOUBLE PRECISION FDSAVE(N)
C        A VECTOR USED TO SAVE THE BEST OF THE
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATIONS TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
C     DOUBLE PRECISION FPLRS
C        THE FLOATING POINT LARGEST RELATIVE SPACING.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IFAIL(N)
C        THE VECTOR OF INDICATOR VARIABLES DESIGNATING WHETHER
C        THE STEP SIZE SELECTED WAS SATISFACTORY FOR A GIVEN
C        OBSERVATION AND PARAMETER.
C     INTEGER ITEMP(N)
C        A TEMPORARY STORAGE VECTOR.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER J
C        THE INDEX OF THE PARAMETER BEING EXAMINED.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NEXMPT
C        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
C        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
C        SIZE STILL BE CONSIDERED OK.
C     INTEGER NFAIL
C        THE VECTOR CONTAINING THE COUNTS FOR EACH PARAMETER
C        OF THE NUMBER OF OBSERVATIONS THE SELECTED STEP SIZE WAS
C        NOT SATISFACTORY.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION PARMX
C        THE MAXIMUM OF THE CURRENT PARAMETER ESTIMATE AND THE
C        TYPICAL VALUE OF THAT PARAMETER
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION PVMCD(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)-STPCD.
C     DOUBLE PRECISION PVMEAN
C        THE MEAN OF A FUNCTION OF THE PREDICTED VALUES.
C     DOUBLE PRECISION PVNEW(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPNEW.
C     DOUBLE PRECISION PVPCD(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCD.
C     DOUBLE PRECISION PVSTP(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STP.
C     DOUBLE PRECISION PVTEMP(N)
C        A TEMPORARY STORAGE VECTOR FOR PREDICTED VALUES.
C     DOUBLE PRECISION PVTYP
C        THE TYPICAL SIZE OF THE PREDICTED VALUES OF THE MODEL.
C     DOUBLE PRECISION Q
C        A DUMMY VARIABLE WHICH IS USED, ALONG WITH COMMON NOTOPT (NO
C        OPTIMIZATION), TO COMPUTE THE STEP SIZE.
C     DOUBLE PRECISION SCALE
C        THE TYPICAL SIZE OF THE JTH PARAMETER.
C     DOUBLE PRECISION STP
C        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FORWARD
C        DIFFERENCE APPROXIMATION TO THE DERIVATIVE.
C     DOUBLE PRECISION STPCD
C        THE STEP SIZE USED FOR THE CENTRAL DIFFERENCE QUOTIENT.
C     DOUBLE PRECISION STPLOW
C        THE LOWER LIMIT ON THE STEP SIZE.
C     DOUBLE PRECISION STPMID
C        THE MIDPOINT OF THE ACCEPTABLE RANGE OF THE STEP SIZE.
C     DOUBLE PRECISION STPUP
C        THE UPPER LIMIT ON THE STEP SIZE.
C     DOUBLE PRECISION RELTOL
C        THE RELATIVE AGREEMENT TOLERANCE.
C     DOUBLE PRECISION TAUABS
C        THE ABSOLUTE AGREEMENT TOLERANCE.
C     DOUBLE PRECISION TEMP
C        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
C        PARAMETER IS STORED.
C     DOUBLE PRECISION THIRD
C        THE VALUE ONE THIRD.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
      FPLRS = D1MACH(4)
C
C     SET VARIOUS PARAMETERS NECESSARY FOR COMPUTING THE
C     OPTIMUM STEP SIZE
C
      THIRD = 1.0D0 / 3.0D0
C
      ETA3 = ETA ** THIRD
C
      PARMX = MAX(ABS(PAR(J)), ABS(SCALE))
      IF (PARMX .EQ. 0.0D0) PARMX = 1.0D0
C
      STPCD = ((3.0D0 ** THIRD) * ETA3 * PARMX * SIGN(1.0D0, PAR(J)))
C
      Q = STPCD + PAR(J)
      STPCD = Q - PAR(J)
C
      TEMP = PAR(J)
C
      PAR(J) = TEMP + STPCD
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVPCD)
C
      PAR(J) = TEMP - STPCD
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVMCD)
C
      PAR(J) = TEMP
C
C     ESTIMATE CURVATURE BY SECOND DERIVATIVE OF MODEL WITH RESPECT TO
C     PAR(J)
C
      DO 10 I = 1, N
         PVTEMP(I) = ABS((PVPCD(I)+PVMCD(I)) - 2*PV(I))
         IF (PVTEMP(I).EQ.0.0D0) THEN
            IF (PV(I).EQ.0.0D0) THEN
               PVTEMP(I) = FPLRS
            ELSE
               PVTEMP(I) = FPLRS*ABS(PV(I))
            END IF
         END IF
   10 CONTINUE
C
C     COMPUTE THE GEOMETRIC MEAN
C
      CALL GMEAN(PVTEMP, N, PVMEAN)
C
      CURVE = ABS(PVMEAN / STPCD / STPCD)
C
C     COMPUTE A TYPICAL VALUE OF THE MODEL
C
      DO 20 I = 1, N
         PVTEMP(I) = ABS(PVPCD(I) + PV(I) + PVMCD(I))
         IF (PVTEMP(I).EQ.0.0D0) THEN
            IF (PV(I).EQ.0.0D0) THEN
               PVTEMP(I) = FPLRS
            ELSE
               PVTEMP(I) = FPLRS*ABS(PV(I))
            END IF
         END IF
   20 CONTINUE
C
      CALL GMEAN(PVTEMP, N, PVMEAN)
C
      PVTYP = ABS(PVMEAN / 3.0D0)
C
C     SET VALUES REPRESENTATIVE OF THE RANGE THE STEP SIZE
C     CAN BE EXPECTED TO TAKE
C
      STPUP = (ETA3) * PARMX
      STPLOW = (ETA3) * STPUP
      STPMID = SQRT(STPLOW) * SQRT(STPUP)
C
C     SELECT AN OPTIMUM STARTING STEP SIZE
C
      IF (CURVE.EQ.0.0D0) THEN
         STP = PARMX * SIGN(1.0D0, PAR(J))
      ELSE
         STP = (2.0D0 * SQRT(ETA) * SQRT(PVTYP) / SQRT(CURVE)) *
     +         SIGN(1.0D0,PAR(J))
      END IF
C
      IF (ABS(STP).GT.PARMX) STP = PARMX * SIGN(1.0D0,PAR(J))
C
      Q = STP + PAR(J)
      STP = Q - PAR(J)
C
      IF (STP.EQ.0.0D0) THEN
         STP = FPLRS * PAR(J)
         IF (STP.EQ.0.0D0) STP = FPLRS
C
   30    CONTINUE
         Q = STP + PAR(J)
         STP = Q - PAR(J)
C
         IF (STP.EQ.0.0D0) THEN
            STP = 2.0D0 * STP
            GO TO 30
         END IF
      END IF
C
C     COMPUTE THE ABSOLUTE TOLERANCES
C
      ABSTOL = 10.0D0 * ETA * PVTYP
C
      TAUABS = 2.0D0 * SQRT(ETA) * SQRT(PVTYP)
      IF (CURVE .NE. 0.0D0) TAUABS = TAUABS * SQRT(CURVE)
C
      TEMP = PAR(J)
      PAR(J) = TEMP + STP
C
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVSTP)
C
      PAR(J) = TEMP
C
C     COMPUTE THE FORWARD AND CENTRAL DIFFERENCE QUOTIENT ESTIMATE
C     OF THE DERIVATIVE
C
      CALL CMPFD(N, STP, PVSTP, PV, FD)
C
      CALL CMPFD(N, 2.0D0*STPCD, PVPCD, PVMCD, CD)
C
C     COMPUTE THE NUMBER OF OBSERVATIONS FOR WHICH THE FD DOES NOT
C     AGREE WITH THE CD WITHIN THE TOLERANCE SPECIFIED.
C
      CALL RELCOM(N, FD, CD, RELTOL, ABSTOL, NFAIL, IFAIL)
C
C     IF THE FORWARD DIFFERENCE APPROXIMATION DOES NOT AGREE WITHIN
C     TOLERANCE FOR MORE THAN   NEXMPT   OBSERVATION, SELECT NEW
C     VALUE OF THE STEP SIZE, ELSE ADJUST THE STEP SIZE AND RETURN.
C
      IF (NFAIL.GT.NEXMPT) THEN
C
C        SELECT NEW VALUE OF THE STEP SIZE
C
            CALL STPSEL(XM, N, M, IXM, MDL, PAR, NPAR,
     +         NEXMPT, STP, NFAIL, IFAIL, J, ETA3, RELTOL, ABSTOL,
     +         TAUABS, STPLOW,
     +         STPMID, STPUP, ITEMP, FD, FDLAST, FDSAVE, PV, PVNEW)
      ELSE
C
C        ADJUST THE CURRENT STEP SIZE VALUE
C
            CALL STPADJ(XM, N, M, IXM, MDL, PAR, NPAR,
     +         NEXMPT, STP, NFAIL, IFAIL, J, RELTOL, ABSTOL, STPLOW,
     +         STPMID, STPUP, ITEMP, FD, FDLAST, PV, PVNEW)
C
      END IF
C
C     CONVERT SELECTED ABSOLUTE STEP SIZE TO RELATIVE STEP SIZE
C
      STP = ABS(STP) / PARMX
C
      RETURN
C
      END
*STPOUT
      SUBROUTINE STPOUT(HEAD, N, EXM, NEXMPT, NETA, J, PAR, NPAR, STP,
     +   NFAIL, IFAIL, SCALE, LSCALE, HDR, PAGE, WIDE, ISUBHD, NPRT,
     +   PRTFXD, IFIXD)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS THE RESULTS OF THE STEP SIZE SELECTING
C     SUBROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   EXM
      INTEGER
     +   ISUBHD,J,LSCALE,N,NETA,NEXMPT,NPAR,NPRT
      LOGICAL
     +   HEAD,PAGE,PRTFXD,WIDE
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),SCALE(LSCALE),STP(NPAR)
      INTEGER
     +   IFAIL(N),IFIXD(NPAR),NFAIL(NPAR)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL HDR
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT,K,NFLABS,NK,NPERL
      LOGICAL
     +   SAMELN
      CHARACTER
     +   BLANK*1,C*1,F*1,PLUS*1
C
C  LOCAL ARRAYS
      INTEGER
     +   INDEX(25)
      CHARACTER
     +   FIXED(3)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL FIXPRT,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC IABS
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     CHARACTER*1 BLANK
C        THE CHARACTER BLANK.
C     CHARACTER*1 C
C        THE CHARACTER FLAG INDICATING HIGH CURVATURE.
C     DOUBLE PRECISION EXM
C        THE PROPORTION OF OBSERVATIONS ACTUALLY USED FOR WHICH THE
C        COMPUTED NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE
C        EXEMPTED FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
C     CHARACTER*1 F
C        THE CHARACTER FLAG INDICATING NUMBER OF OBSERVATIONS
C        FAILING SELECTION CRITERIA EXCEEDED EXEMPTED NUMBER.
C     CHARACTER*1 FIXED(3)
C        THE CHARACTERS USED TO LABEL THE PARAMETERS FIXED OR NOT.
C     EXTERNAL HDR
C        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IFAIL(N)
C        THE ARRAY OF INDICATOR VARIABLES DESIGNATING WHETHER
C        THE STEP SIZE SELECTED WAS SATISFACTORY FOR A GIVEN
C        OBSERVATION AND PARAMETER.
C     INTEGER INDEX(25)
C        THE ROW NUMBERS OF OBSERVATIONS FOR WHICH THE STEP SIZE
C        SELECTED FAILED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IFIXD(NPAR)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXD(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXD(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C     INTEGER J
C        THE INDEX OF THE PARAMETER BEING EXAMINED.
C     INTEGER K
C        AN INDEX VARIABLE.
C     INTEGER LSCALE
C        THE LENGTH OF VECTOR SCALE.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS IN THE MODEL.
C     INTEGER NETA
C        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
C     INTEGER NEXMPT
C        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
C        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
C        SIZE STILL BE CONSIDERED OK.
C     INTEGER NFAIL(NPAR)
C        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP
C        SIZE DOES NOT MEET THE CRITERIA.
C     INTEGER NFLABS
C        THE ABSOLUTE VALUE OF NFAIL.
C     INTEGER NK
C        AN INDEX VARIABLE.
C     INTEGER NPERL
C        THE NUMBER OF OBSERVATIONS TO BE PRINTED PER LINE.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
C     LOGICAL PAGE
C        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE OUTPUT
C        IS TO BEGIN ON A NEW PAGE.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
C        PARAMETERS ARE STORED.
C     CHARACTER*1 PLUS
C        THE CHARACTER PLUS.
C     LOGICAL PRTFXD
C        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
C        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
C        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
C     LOGICAL SAMELN
C        AN INDICATOR VALUE TO DESIGNATE WHETHER THE LINE IS TO BE
C        PRINTED ON THE SAME LINE AS THE PREVIOUS LINE PRINTED (TRUE)
C        OR NOT (FALSE).
C     DOUBLE PRECISION SCALE(LSCALE)
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION STP(NPAR)
C        THE SELECTED STEP SIZE.
C     LOGICAL WIDE
C        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
C        BE FULL WIDTH (TRUE) OR NOT (FALSE).
C
      DATA BLANK /' '/, PLUS /'+'/
      CALL IPRINT(IPRT)
C
C     INITIALIZE ARRAY FIXED
C
      DO 10 K=1,3
         FIXED(K) = BLANK
   10 CONTINUE
C
      IF (HEAD) THEN
C
C     PRINT HEADING
C
         HEAD = .FALSE.
C
         CALL HDR(PAGE, WIDE, ISUBHD)
         IF (PRTFXD) THEN
            WRITE (IPRT,1000)
         ELSE
            WRITE (IPRT,1010)
         END IF
C
C     PRINT INFORMATION OTHERWISE SUPPRESSED BY PRINT CONTROL
C
         DO 20 I=1,J-1
            IF (PRTFXD) CALL FIXPRT(IFIXD(I), FIXED)
            IF (IFIXD(I).EQ.0) THEN
               F = BLANK
               C = BLANK
               NFLABS = IABS(NFAIL(I))
               IF (NFLABS.GT.NEXMPT) F = PLUS
               IF (NFAIL(I).LT.0) C = PLUS
               IF (SCALE(1).GT.0.0D0) THEN
                  WRITE (IPRT,1020) I, (FIXED(K),K=1,3), PAR(I),
     +                              SCALE(I),
     +                              STP(I), NFLABS, F, C
               ELSE
                  WRITE (IPRT,1040) I, (FIXED(K),K=1,3), PAR(I),
     +                              STP(I), NFLABS, F, C
               END IF
               IF (NFLABS.GT.NEXMPT) WRITE (IPRT,1030)
            ELSE
               WRITE (IPRT,1045) I, (FIXED(K),K=1,3), PAR(I)
            END IF
   20    CONTINUE
      END IF
C
C     PRINT INFORMATION FOR CURRENT PARAMETER
C
      I = J
      IF (PRTFXD) CALL FIXPRT(IFIXD(I), FIXED)
      IF (IFIXD(I).EQ.0) THEN
         F = BLANK
         C = BLANK
         NFLABS = IABS(NFAIL(I))
         IF (NFLABS.GT.NEXMPT) F = PLUS
         IF (NFAIL(I).LT.0) C = PLUS
         IF (SCALE(1).GT.0.0D0) THEN
            WRITE (IPRT,1020) I, (FIXED(K),K=1,3), PAR(I),
     +                        SCALE(I),
     +                        STP(I), NFLABS, F, C
         ELSE
            WRITE (IPRT,1040) I, (FIXED(K),K=1,3), PAR(I),
     +                        STP(I), NFLABS, F, C
         END IF
         IF (NFLABS.GE.1) THEN
            IF ((NPRT.EQ.0) .AND. (NFLABS.LE.NEXMPT)) THEN
               WRITE (IPRT,1030)
            ELSE
C
C     PRINT ROW NUMBERS
C
               NPERL = 7
C
               SAMELN = .TRUE.
               NK = 0
               DO 60 I=1,N
                  IF (IFAIL(I).EQ.0) GO TO 60
                  NK = NK + 1
                  INDEX(NK) = I
                  IF (NK.LT.NPERL) GO TO 60
                  IF (SAMELN) THEN
                     WRITE (IPRT,1050) (INDEX(K),K=1,NK)
                  ELSE
                     WRITE (IPRT,1060) (INDEX(K),K=1,NK)
                  END IF
                  SAMELN = .FALSE.
                  NK = 0
   60          CONTINUE
               IF (SAMELN) THEN
                  WRITE (IPRT,1050) (INDEX(K),K=1,NK)
               ELSE
                  WRITE (IPRT,1060) (INDEX(K),K=1,NK)
               END IF
            END IF
         END IF
      ELSE
         WRITE (IPRT,1045) I, (FIXED(K),K=1,3), PAR(I)
      END IF
      IF (J.LT.NPAR) RETURN
C
C     PRINT FINAL NOTES AND SUMMARY
C
      WRITE (IPRT,1070)
      IF (NPRT.NE.0) GO TO 100
      DO 90 I=1,NPAR
         IF (IFIXD(I).EQ.0) THEN
            IF (IABS(NFAIL(I)).GT.NEXMPT) GO TO 90
            WRITE (IPRT,1080)
            GO TO 100
         END IF
   90 CONTINUE
C
  100 CONTINUE
C
C     PRINT CONTROL VALUES USED.
C
      WRITE (IPRT,1090) NETA
      WRITE (IPRT,1100) EXM
      WRITE (IPRT,1110) NEXMPT
      WRITE (IPRT,1120) N
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (//50X, 13HSTEP SIZE FOR, 4X, 25HOBSERVATIONS FAILING STEP,
     +   24H SIZE SELECTION CRITERIA/50X, 13HAPPROXIMATING, 21X, 1H*/7X,
     +   24HPARAMETER STARTING VALUE, 6X, 5HSCALE, 10X, 10HDERIVATIVE,
     +   7X, 5HCOUNT, 5X, 5HNOTES, 5X, 10HROW NUMBER/1X, 5HINDEX, 2X,
     +   5HFIXED, 6X, 5H(PAR), 12X, 7H(SCALE), 11X, 5H(STP), 21X, 3HF C/
     +   )
 1010 FORMAT (//50X, 13HSTEP SIZE FOR, 4X, 25HOBSERVATIONS FAILING STEP,
     +   24H SIZE SELECTION CRITERIA/18X, 9HPARAMETER, 23X, 9HAPPROXIMA,
     +   4HTING, 21X, 1H*/16X, 14HSTARTING VALUE, 7X, 5HSCALE, 10X,
     +   10HDERIVATIVE, 7X, 5HCOUNT, 5X, 5HNOTES, 5X, 13HROW NUMBER(S)/
     +   1X, 5HINDEX, 13X, 5H(PAR), 12X, 7H(SCALE), 11X, 5H(STP), 21X,
     +   3HF C/)
 1020 FORMAT (1X, I3, 5X, 3A1, 3G17.8, 5X, I5, 7X, A1, 1X, A1)
 1030 FORMAT ('+', 89X, 2H**)
 1040 FORMAT (1X, I3, 5X, 3A1, G17.8, 7X, 7HDEFAULT, 3X, G17.8, 5X, I5,
     +   7X, A1, 1X, A1)
 1045 FORMAT (1X, I3, 5X, 3A1, G17.8, 9X, '---', 14X, '---',
     +        14X, '-')
 1050 FORMAT ('+', 86X, 7I5)
 1060 FORMAT (87X, 7I5)
 1070 FORMAT (//1X, 36H*  NOTES.  A PLUS (+) IN THE COLUMNS, 8H HEADED ,
     +   33HF OR C HAS THE FOLLOWING MEANING.//4X, 17HF - NUMBER OF OBS,
     +   27HERVATIONS FAILING STEP SIZE, 27H SELECTION CRITERIA EXCEEDS/
     +   8X, 29HNUMBER OF EXEMPTIONS ALLOWED.//4X, 17HC - HIGH CURVATUR,
     +   30HE IN THE MODEL IS SUSPECTED AS, 13H THE CAUSE OF/8X,
     +   19HALL FAILURES NOTED.)
 1080 FORMAT (//46H ** ROW NUMBERS ARE ONLY LISTED WHEN NUMBER OF,
     +   26H OBSERVATIONS FAILING STEP/4X, 25HSIZE SELECTION CRITERIA E,
     +   27HXCEEDS NUMBER OF EXEMPTIONS, 9H ALLOWED.)
 1090 FORMAT (/43H NUMBER OF RELIABLE DIGITS IN MODEL RESULTS, 25X,
     +   6H(NETA), 1X, I5)
 1100 FORMAT (/41H PROPORTION OF OBSERVATIONS EXEMPTED FROM, 8H SELECTI,
     +   11HON CRITERIA, 7X, 7H(EXMPT), 2X, F6.4)
 1110 FORMAT (/37H NUMBER OF OBSERVATIONS EXEMPTED FROM, 11H SELECTION ,
     +   8HCRITERIA, 19X, I5)
 1120 FORMAT (/23H NUMBER OF OBSERVATIONS, 48X, 3H(N), 1X, I5)
      END
*STPSEL
      SUBROUTINE STPSEL(XM, N, M, IXM, MDL, PAR, NPAR,
     +   NEXMPT, STP, NFAIL, IFAIL, J, ETA3, RELTOL, ABSTOL, TAUABS,
     +   STPLOW, STPMID, STPUP, ITEMP, FD, FDLAST, FDSAVE, PV, PVNEW)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE SELECTS NEW STEP SIZES UNITL EITHER
C     THE NUMBER OF OBSERVATIONS AT WHICH THE SELECTION CRITERIA
C     IS NOT MET DOES NOT EXCEED NEXMPT OR UNTIL NO FURTHER
C     IMPROVEMENT CAN BE MADE.
C
C     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ABSTOL,ETA3,RELTOL,STP,STPLOW,STPMID,STPUP,TAUABS
      INTEGER
     +   IXM,J,M,N,NEXMPT,NFAIL,NPAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FD(N),FDLAST(N),FDSAVE(N),PAR(NPAR),PV(N),PVNEW(N),XM(IXM,M)
      INTEGER
     +   IFAIL(N),ITEMP(N)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
C
C  SCALARS IN COMMON
      DOUBLE PRECISION
     +   Q
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FACTOR,STP1,STP2,STPNEW,TEMP
      INTEGER
     +   NCOUNT
      LOGICAL
     +   FAIL,FIRST,FORWRD,HICURV,SUCCES
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ABSCOM,CMPFD,ICOPY,RELCOM,DCOPY,STPADJ
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS
C
C  COMMON BLOCKS
      COMMON /NOTOPT/Q
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ABSTOL
C        THE ABSOLUTE AGREEMENT TOLERANCE.
C     DOUBLE PRECISION ETA3
C        THE CUBE ROOT OF THE RELATIVE NOISE IN THE MODEL
C     DOUBLE PRECISION FACTOR
C        A FACTOR USED IN COMPUTING THE STEP SIZE.
C     LOGICAL FAIL
C        THE VARIABLE USED TO INDICATE WHETHER A STEP SIZE
C        CANNOT BE SELECTED WHICH WILL SUCCESSFULLY MEET THE CRITERIA.
C     DOUBLE PRECISION FD(N)
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
C     DOUBLE PRECISION FDLAST(N)
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
C        COMPUTED WITH THE MOST RECENT STEP SIZE SELECTED.
C     DOUBLE PRECISION FDSAVE(N)
C        A VECTOR USED TO SAVE THE BEST OF THE
C        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATIONS TO THE
C        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
C     LOGICAL FIRST
C        THE VARIABLE USED TO INDICATE WHETHER THIS STEP SIZE
C        IS BEING USED FOR THE FIRST TIME OR WHETHER IT HAS BEEN
C        PREVIOUSLY ADJUSTED.
C     LOGICAL FORWRD
C        THE VARIABLE USED TO INDICATE THE DIRECTION OF CHANGE IN
C        THE STEP SIZE.
C     LOGICAL HICURV
C        THE VARIABLE USED TO INDICATE WHETHER THE MODEL HAS
C        HIGH CURVATURE.
C     INTEGER IFAIL(N)
C        AN INDICATOR VECTOR USED TO DESIGNATE THOSE OBSERVATIONS
C        FOR WHICH THE STEP SIZE DOES NOT MEET THE CRITERIA.
C     INTEGER ITEMP(N)
C        A TEMPORARY VECTOR USED FOR STORING PAST VALUES OF ITEMP.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER J
C        THE INDEX OF THE PARAMETER BEING EXAMINED.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NCOUNT
C        THE NUMBER OF OBSERVATIONS AT WHICH THE NEW STEP SIZE DOES
C        SATISFY THE CRITERIA.
C     INTEGER NEXMPT
C        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
C        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
C        SIZE STILL BE CONSIDERED OK.
C     INTEGER NFAIL
C        A VECTOR CONTAINING FOR EACH OBSERVATION THE NUMBER OF
C        OBSERVATIONS FOR WHICH THE STEP SIZE DID NOT MEET THE CRITERIA.
C     DOUBLE PRECISION PAR(NPAR)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION PV(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION PVNEW(N)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCD.
C     DOUBLE PRECISION Q
C        A DUMMY VARIABLE WHICH IS USED, ALONG WITH COMMON NOTOPT (NO
C        OPTIMIZATION), TO COMPUTE THE STEP SIZE.
C     DOUBLE PRECISION STP
C        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FORWARD
C        DIFFERENCE APPROXIMATION TO THE DERIVATIVE.
C     DOUBLE PRECISION STPLOW
C        THE LOWER LIMIT ON THE STEP SIZE.
C     DOUBLE PRECISION STPMID
C        THE MIDPOINT OF THE ACCEPTABLE RANGE OF THE STEP SIZE.
C     DOUBLE PRECISION STPNEW
C        THE VALUE OF THE NEW STEP SIZE BEING TESTED.
C     DOUBLE PRECISION STPUP
C        THE UPPER LIMIT ON THE STEP SIZE.
C     DOUBLE PRECISION STP1, STP2
C        TEMPORARY STORAGE LOCATIONS FOR STEP SIZES.
C     LOGICAL SUCCES
C        THE VARIABLE USED TO INDICATE WHETHER THE STEP SIZE
C        SUCCESSFULLY MEETS THE CRITERIA USED TO SELECT THE STEP
C        SIZES.
C     DOUBLE PRECISION RELTOL
C        THE RELATIVE AGREEMENT TOLERANCE.
C     DOUBLE PRECISION TAUABS
C        THE ABSOLUTE AGREEMENT TOLERANCE.
C     DOUBLE PRECISION TEMP
C        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
C        PARAMETER IS STORED.
C     DOUBLE PRECISION XM(IXM,M)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
      CALL DCOPY(N, FD, 1, FDSAVE, 1)
C
      FACTOR = 10.0D0
      IF (ABS(STP) .GT. STPMID) FACTOR = 0.1D0
C
      STPNEW = STP * FACTOR
      STP1 = STPNEW
      STP2 = STPNEW
C
      Q = STPNEW + PAR(J)
      STPNEW = Q - PAR(J)
C
      FIRST = .TRUE.
      FORWRD = .TRUE.
      SUCCES = .FALSE.
      FAIL = .FALSE.
C
      NFAIL = N + 1
C
C     REPEAT FOLLOWING UNTIL (SUCCES) OR (FAIL)
C
   10 CONTINUE
C
      CALL DCOPY(N, FD, 1, FDLAST, 1)
C
      TEMP = PAR(J)
      PAR(J) = TEMP + STPNEW
C
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVNEW)
C
      PAR(J) = TEMP
C
      CALL CMPFD(N, STPNEW, PVNEW, PV, FD)
C
      CALL RELCOM(N, FD, FDLAST, RELTOL, ABSTOL, NCOUNT, ITEMP)
C
      IF (NCOUNT.LE.NEXMPT) THEN
            SUCCES = .TRUE.
            NFAIL = NCOUNT
            CALL ICOPY(N, ITEMP, 1, IFAIL, 1)
            IF (ABS(ABS(STPNEW) - STPMID) .GT.
     +         ABS(ABS(STPNEW/FACTOR) - STPMID)) THEN
                  STP = STPNEW / FACTOR
            ELSE
                  STP = STPNEW
            END IF
      ELSE
            IF (NCOUNT.LT.NFAIL) THEN
                  NFAIL = NCOUNT
                  STP1 = STPNEW
                  STP2 = STPNEW / FACTOR
                  CALL ICOPY(N, ITEMP, 1, IFAIL, 1)
            END IF
            IF (FIRST) THEN
                  FIRST = .FALSE.
                  CALL ABSCOM(N, FD, FDLAST, TAUABS, NCOUNT)
                  IF (NCOUNT.LE.NEXMPT) THEN
                         HICURV = .TRUE.
                  ELSE
                         HICURV = .FALSE.
                  END IF
            END IF
            STPNEW = STPNEW * FACTOR
            Q = STPNEW + PAR(J)
            STPNEW = Q - PAR(J)
            IF ((FACTOR.GT.1.0D0 .AND. ABS(STPNEW).GT.STPUP) .OR.
     +          (FACTOR.LT.1.0D0 .AND. ABS(STPNEW).LT.STPLOW)) THEN
                  IF (FORWRD) THEN
                        FORWRD = .FALSE.
                        FACTOR = 1.0D0 / FACTOR
                        STPNEW = STP * FACTOR
                        Q = STPNEW + PAR(J)
                        STPNEW = Q - PAR(J)
                        CALL DCOPY(N, FDSAVE, 1, FD, 1)
                        STPLOW = STPLOW * (ETA3)
                        STPUP = STPUP / (ETA3)
                  ELSE
                        FAIL = .TRUE.
                  END IF
            END IF
      END IF
C
      IF (.NOT.(SUCCES.OR.FAIL)) GO TO 10
C
      IF (SUCCES .AND. FORWRD) THEN
            CALL STPADJ(XM, N, M, IXM, MDL, PAR, NPAR,
     +         NEXMPT, STP, NFAIL, IFAIL, J, RELTOL, ABSTOL, STPLOW,
     +         STPMID, STPUP, ITEMP, FD, FDLAST, PV, PVNEW)
            RETURN
      ELSE
            IF (SUCCES) THEN
                  RETURN
            ELSE
C                 IF (HICURV) NFAIL = -NFAIL
C
                  IF (ABS(STP1).LT.ABS(STP2)) THEN
                        STP = STP1
                        RETURN
                  ELSE
                        STP = STP2
                        RETURN
                  END IF
            END IF
      END IF
C
      END
*SUMBS
      SUBROUTINE SUMBS(X, N, LO, MID, HI)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     A ROUTINE TO FIND A ZERO OR VALUE CLOSEST TO ZERO IN
C     A SORTED VECTOR.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   HI,LO,MID,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N)
C
C  LOCAL SCALARS
      INTEGER
     +   CURHI,CURLO
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER CURHI
C        THE UPPER BOUND OF THE CURRENT INTERVAL.
C     INTEGER CURLO
C        THE LOWER BOUND OF THE CURRENT INTERVAL.
C     INTEGER HI
C        INPUT PARAMETER.  THE UPPER BOUND OF THE INITIAL
C        INTERVAL.
C     INTEGER LO
C        INPUT PARAMETER.  THE LOWER BOUND OF THE INITIAL
C        INTERVAL.
C     INTEGER MID
C        OUTPUT PARAMETER.  THE MIDPOINT OF THE CURRENT
C        INTERVAL, AND ON EXIT THE POINT IN THE INITIAL
C        INTERVAL CLOSEST TO ZERO.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
C     DOUBLE PRECISION X(N)
C        INPUT PARAMETER.  THE ARRAY X IN WHICH THE SEARCH FOR
C        A (NEAR) ZERO VALUE IS MADE.
C
C     BINARY SEARCH OF X FOR 0.0D0 OR CLOSEST TO IT.
C
      CURLO = LO
      CURHI = HI
C
C     SEE IF ZERO IS OUT OF THE RANGE X(LO) TO X(HI).
C
      IF (X(CURLO).LT.0.0D0) GO TO 10
      MID = CURLO
      GO TO 50
   10 IF (X(CURHI).GT.0.0D0) GO TO 20
      MID = CURHI
      GO TO 50
C
C     LOCATE EITHER A ZERO OR A PAIR OF ADJACENT VALUES BETWEEN
C     WHICH THERE LIES A ZERO.
C
   20 IF (CURLO+1.EQ.CURHI) GO TO 30
      MID = (CURLO+CURHI)/2
      IF (0.0D0.LT.X(MID)) CURHI = MID
      IF (0.0D0.GT.X(MID)) CURLO = MID
      IF (0.0D0.EQ.X(MID)) GO TO 50
      GO TO 20
C
C     PICK AS MIDPOINT THE CURRENT ENDPOINT CLOSEST TO ZERO.
C
   30 IF (X(CURHI)+X(CURLO).GT.0.0D0) GO TO 40
      MID = CURHI
      GO TO 50
   40 MID = CURLO
   50 RETURN
      END
*SUMDS
      SUBROUTINE SUMDS(X, N, LO, MID, HI, XMEANW, SUMDA, SUMD2, SUMD3,
     +   SUMD4)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     A ROUTINE TO CALCULATE UNWEIGHTED SUMS OF POWERS OF
C     DIFFERENCES FROM THE WEIGHTED MEAN FOR A SORTED
C     VECTOR IN WHICH THE MIDTH ELEMENT IS THE ELEMENT
C     CLOSEST TO ZERO.  USED BY THE STAT FAMILY.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SUMD2,SUMD3,SUMD4,SUMDA,XMEANW
      INTEGER
     +   HI,LO,MID,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DIFF
      INTEGER
     +   CURHI,CURLO,I,IREV
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER CURHI
C        THE UPPER BOUND OF THE CURRENT INTERVAL.
C     INTEGER CURLO
C        THE LOWER BOUND OF THE CURRENT INTERVAL.
C     DOUBLE PRECISION DIFF
C        THE DIFFERENCES BETWEEN X(I) AND XMEANW.
C     INTEGER HI
C        INPUT PARAMETER.  THE UPPER BOUND OF THE INITIAL
C        INTERVAL.
C     INTEGER I
C        A LOOP PARAMETER.
C     INTEGER IREV
C        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
C        IN THE REVERSE ORDER.
C     INTEGER LO
C        INPUT PARAMETER.  THE LOWER BOUND OF THE INITIAL
C        INTERVAL.
C     INTEGER MID
C        INPUT PARAMETER.  THE INDEX OF THE ELEMENT IN X CLOSEST TO
C        ZERO IN VALUE.  THE POINT OUT FROM WHICH THE SUMMING IS
C        DONE.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
C     DOUBLE PRECISION SUMDA
C        OUTPUT PARAMETER.  THE SUM OF THE ABSOLUTE VALUES OF THE
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION SUMD2
C        OUTPUT PARAMETER.  THE SUM OF THE SQUARES OF THE
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION SUMD3
C        OUTPUT PARAMETER.  THE SUM OF THE CUBES OF THE
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION SUMD4
C        OUTPUT PARAMETER.  THE SUM OF THE HYPERCUBES OF THE
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION X(N)
C        INPUT PARAMETER.  THE DATA ARRAY X IN WHICH THE SUMS ARE TAKEN.
C     DOUBLE PRECISION XMEANW
C        INPUT PARAMETER.  THE WEIGHTED MEAN OF X.
C
C     INITIALIZE SUMMATION VARIABLES.
C
      DIFF = X(MID) - XMEANW
      SUMDA = ABS(DIFF)
      SUMD2 = DIFF*DIFF
      SUMD3 = DIFF*DIFF*DIFF
      SUMD4 = DIFF*DIFF*DIFF*DIFF
      CURLO = MID - 1
      CURHI = MID + 1
C
C     SUM OUTWARDS FROM THE VALUE NEAREST ZERO.  THAT IS, SUM FROM
C     THE LEAST IN MAGNITUDE TO THE GREATEST.
C
   10 IF (CURHI.GT.HI .OR. CURLO.LT.LO) GO TO 30
      IF (ABS(X(CURHI)).LT.ABS(X(CURLO))) GO TO 20
      DIFF = X(CURLO) - XMEANW
      SUMDA = SUMDA + ABS(DIFF)
      SUMD2 = SUMD2 + DIFF*DIFF
      SUMD3 = SUMD3 + DIFF*DIFF*DIFF
      SUMD4 = SUMD4 + DIFF*DIFF*DIFF*DIFF
      CURLO = CURLO - 1
      GO TO 10
   20 DIFF = X(CURHI) - XMEANW
      SUMDA = SUMDA + ABS(DIFF)
      SUMD2 = SUMD2 + DIFF*DIFF
      SUMD3 = SUMD3 + DIFF*DIFF*DIFF
      SUMD4 = SUMD4 + DIFF*DIFF*DIFF*DIFF
      CURHI = CURHI + 1
      GO TO 10
C
C     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
C     CENTER ZERO POINT.
C
   30 IF (CURHI.GT.HI) GO TO 50
      DO 40 I=CURHI,HI
         DIFF = X(I) - XMEANW
         SUMDA = SUMDA + ABS(DIFF)
         SUMD2 = SUMD2 + DIFF*DIFF
         SUMD3 = SUMD3 + DIFF*DIFF*DIFF
         SUMD4 = SUMD4 + DIFF*DIFF*DIFF*DIFF
   40 CONTINUE
   50 IF (CURLO.LT.LO) GO TO 70
      DO 60 IREV=LO,CURLO
         I = LO - IREV + CURLO
         DIFF = X(I) - XMEANW
         SUMDA = SUMDA + ABS(DIFF)
         SUMD2 = SUMD2 + DIFF*DIFF
         SUMD3 = SUMD3 + DIFF*DIFF*DIFF
         SUMD4 = SUMD4 + DIFF*DIFF*DIFF*DIFF
   60 CONTINUE
   70 RETURN
      END
*SUMID
      SUBROUTINE SUMID(X, N, XMEAN, SUMDI)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     A ROUTINE TO CALCULATE THE SUM OF THE PRODUCTS OF I AND THE I TH
C     DIFFERENCE AMONG THE ELEMENTS OF THE VECTOR X - XMEAN.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SUMDI,XMEAN
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DIFF
      INTEGER
     +   I
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DIFF
C        THE DIFFERENCE OF A VALUE OF X AND THE WEIGHTED MEAN OF X.
C     INTEGER I
C        A LOOP INDEX.
C     INTEGER N
C        INPUT PARAMETER.  THE NUMBER OF ELEMENTS IN X.
C     DOUBLE PRECISION SUMDI
C        OUTPUT PARAMETER.  THE SUM OF THE PRODUCTS OF I AND THE
C        ELEMENTS OF THE VECTOR X - XMEAN.
C     DOUBLE PRECISION X(N)
C        INPUT PARAMETER.  THE VECTOR OF N DATA VALUES.
C     DOUBLE PRECISION XMEAN
C        INPUT PARAMETER.  THE MEAN OF X.
C
      SUMDI = 0.0D0
      DO 10 I=1,N
         DIFF = X(I) - XMEAN
         SUMDI = SUMDI + I*DIFF
   10 CONTINUE
      RETURN
      END
*SUMIDW
      SUBROUTINE SUMIDW(X, W, N, XMEANW, SUMDI)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     A ROUTINE TO CALCULATE THE SUM OF THE PRODUCTS OF I AND THE I TH
C     DIFFERENCE AMONG THE ELEMENTS OF THE VECTOR X - XMEANW WHICH
C     ARE NOT WEIGHTED ZERO.  (ELEMENTS WEIGHTED ZERO DO NOT
C     PRODUCE AN INCREMENT IN I.)
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SUMDI,XMEANW
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   W(N),X(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DIFF,I
      INTEGER
     +   K
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DIFF
C        THE DIFFERENCE OF A VALUE OF X AND THE WEIGHTED MEAN OF X.
C     DOUBLE PRECISION I
C        I COUNTS FROM 1 TO THE NUMBER OF NON-ZERO WEIGHTED ELEMENTS
C        FOUND IN X.
C     INTEGER K
C        A LOOP INDEX.
C     INTEGER N
C        INPUT PARAMETER.  THE NUMBER OF ELEMENTS IN X.
C     DOUBLE PRECISION SUMDI
C        OUTPUT PARAMETER.  THE SUM OF THE PRODUCTS OF I AND THE
C        NON-ZERO WEIGHTED ELEMENTS OF THE VECTOR X - XMEANW.
C     DOUBLE PRECISION W(N)
C        INPUT PARAMETER.  THE WEIGHTS VECTOR FOR X.
C     DOUBLE PRECISION X(N)
C        INPUT PARAMETER.  THE VECTOR OF N DATA VALUES.
C     DOUBLE PRECISION XMEANW
C        INPUT PARAMETER.  THE WEIGHTED MEAN OF X.
C
      I = 0.0D0
      SUMDI = 0.0D0
      DO 10 K=1,N
         IF (W(K).EQ.0.0D0) GO TO 10
         DIFF = X(K) - XMEANW
         I = I + 1.0D0
         SUMDI = SUMDI + I*DIFF
   10 CONTINUE
      RETURN
      END
*SUMOT
      SUBROUTINE SUMOT(STS, N, NNZW, WTS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE REPORTS THE RESULTS OF A STAT FAMILY
C     COMPUTATION OF 53 SELECTED STATISTICS.  THERE MAY OR
C     MAY NOT BE WEIGHTS.
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NNZW
      LOGICAL
     +   WTS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   STS(53)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT
C
C  LOCAL ARRAYS
      INTEGER
     +   ITEMP(10)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VERSP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        LOOP INDEX.
C     INTEGER IPRT
C        THE OUTPUT UNIT.
C     INTEGER ITEMP(10)
C        A TEMPORARY VECTOR OF INTEGER STORAGE.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF THE ORIGINAL DATA VECTOR.
C     INTEGER NNZW
C        INPUT PARAMETER.  THE NUMBER OF VALUES IN THE ORIGINAL DATA
C        VECTOR WITH WEIGHTS GREATER THAN 0.0D0.
C     DOUBLE PRECISION STS(53)
C        INPUT PARAMETER.  THE VECTOR OF 53 STATISTICS COMPUTED.
C        ROW STATISTIC                    ROW STATISTIC
C         1  LENGTH OF VECTOR             TESTS FOR NONRANDOMNESS
C         2  NUMBER OF NONZERO WEIGHTS    23  NUMBER OF RUNS UP AND DOWN
C        MEASURES OF LOCATION             24  EXPECTED NUMBER OF RUNS
C         3  UNWEIGHTED MEAN              25  S.D. OF NUMBER OF RUNS
C         4  WEIGHTED MEAN                26  MEAN SQR. SUCCESSIVE DIFF.
C         5  MEDIAN                       27  MEAN SQR. SUCC. DIFF./VAR.
C         6  MID-RANGE                    DEVIATIONS FROM WTD MEAN
C         7  25 P.C. UNWTD. TRIMMED MEAN  28  NUMBER OF + SIGNS
C         8  25 P.C. WTD. TRIMMED MEAN    29  NUMBER OF - SIGNS
C        MEASURES OF DISPERSION           30  NUMBER OF RUNS
C         9  STANDARD DEVIATION (S.D.)    31  EXPECTED NUMBER OF RUNS
C        10  S.D. OF MEAN                 32  S.D. OF RUNS
C        11  RANGE                        33  DIFF./S.D. OF RUNS
C        12  MEAN VARIATION               OTHER STATISTICS
C        13  VARIANCE (VAR.)              34  MINIMUM
C        14  COEFFICIENT OF VARIATION     35  MAXIMUM
C        CONFIDENCE INTERVALS             36  BETA 1
C        15  LOWER CONFIDENCE LIMIT, MEAN 37  BETA 2
C        16  UPPER CONFIDENCE LIMIT, MEAN 38  WTD. SUM OF VALUES
C        17  LOWER CONFIDENCE LIMIT, S.D. 39  WTD. SUM OF SQUARES
C        18  UPPER CONFIDENCE LIMIT, S.D. 40  WTD. SUM OF SQRD. DEVS.
C        LINEAR TREND STATISTICS          41  STUDENTS T
C        19  SLOPE                        42  WTD. SUM OF ABS. VALUES
C        20  S.D. OF SLOPE                43  WTD. AVG. ABS. VALUES
C        21  SLOPE/S.D. OF SLOPE = T      44-53 FREQ. DISTRIBUTION
C        22  PROB ( X .GT. ABS(OBS. T))
C     LOGICAL WTS
C        INPUT PARAMETER.  A FLAG TO INDICATE WHETHER OR NOT THERE ARE
C        WEIGHTS.
C
C     BEGIN PRINTOUT
C
      CALL IPRINT(IPRT)
C
C     PRINT HEADING
C
      CALL VERSP(.TRUE.)
C
C     PRINT NUMBERS OF OBSERVATIONS, RAW AND NONZERO WEIGHTED.
C
      IF (.NOT.WTS) WRITE (IPRT,1000)
      IF (WTS) WRITE (IPRT,1010)
      IF (NNZW.NE.N) GO TO 10
      WRITE (IPRT,1020) NNZW
      GO TO 20
   10 WRITE (IPRT,1030) NNZW, N
      WRITE (IPRT,1040)
C
C     PRINT FREQUENCY DISTRIBUTIONS
C
   20 DO 30 I=1,10
         ITEMP(I) = STS(I+43)
   30 CONTINUE
      WRITE (IPRT,1050) (ITEMP(I),I=1,10)
C
C     PRINT MEASURES OF LOCATION AND DISPERSION
C
      WRITE (IPRT,1060)
      IF (STS(4).NE.0.0D0)
     +   WRITE (IPRT,1070) (STS(I+2),STS(I+8),I=1,6)
      IF (STS(4).EQ.0.0D0)
     +   WRITE (IPRT,1080) (STS(I+2),STS(I+8),I=1,5), STS(8)
C
C     PRINT CONFIDENCE INTERVALS
C
      WRITE (IPRT,1090) (STS(I),I=15,18)
C
C     PRINT LINEAR TREND AND OTHER STATISTICS, AND PRINT HEADING FOR
C     TESTS FOR NONRANDOMNESS
C
      WRITE (IPRT,1100)
     +   (STS(I),STS(I+15),I=19,22), (STS(I),I=38,41)
      ITEMP(1) = STS(23)
      ITEMP(2) = STS(28)
      ITEMP(3) = STS(29)
      ITEMP(4) = STS(30)
C
C     PRINT TESTS FOR NONRANDOMNESS
C
      WRITE (IPRT,1110) ITEMP(1), STS(42), STS(24), STS(43),
     +   (STS(I),I=25,27), (ITEMP(I),I=2,4), (STS(I),I=31,33)
C
C     PRINT FOOTNOTE
C
      WRITE (IPRT,1120)
      RETURN
C
 1000 FORMAT('+STATISTICAL ANALYSIS')
 1010 FORMAT('+WEIGHTED STATISTICAL ANALYSIS')
 1020 FORMAT(//5X, 4HN = , I5)
 1030 FORMAT(//5X, 4HN = , I5, 32H (NO. OF NON-ZERO WTS)    LENGTH,
     +   2H =, I5)
 1040 FORMAT(/5X, 45HALL COMPUTATIONS ARE BASED ON OBSERVATIONS WI,
     +   19HTH NON-ZERO WEIGHTS)
 1050 FORMAT(//5X, 28HFREQUENCY DISTRIBUTION (1-6), 7X, 10I6)
 1060 FORMAT(//5X, 26HMEASURES OF LOCATION (2-2), 34X, 10HMEASURES O,
     +   18HF DISPERSION (2-6))
 1070 FORMAT(/10X, 26HUNWEIGHTED MEAN          =, 1PD15.7, 20X,
     +   26HWTD STANDARD DEVIATION   =, D15.7/10X, 17HWEIGHTED MEAN    ,
     +   9H        =, D15.7, 20X, 26HWEIGHTED S.D. OF MEAN    =,
     +   D15.7/10X, 26HMEDIAN                   =, D15.7, 20X, 6HRANGE ,
     +   20H                   =, D15.7/10X, 23HMID-RANGE              ,
     +   3H  =, D15.7, 20X, 26HMEAN DEVIATION           =, D15.7/10X,
     +   26H25 PCT UNWTD TRIMMED MEAN=, D15.7, 20X, 16HVARIANCE        ,
     +   10H         =, D15.7/10X, 26H25 PCT WTD TRIMMED MEAN  =,
     +   D15.7, 20X, 26HCOEF. OF. VAR. (PERCENT) =, D15.7)
 1080 FORMAT(/10X, 26HUNWEIGHTED MEAN          =, 1PD15.7, 20X,
     +   26HWTD STANDARD DEVIATION   =, D15.7/10X, 17HWEIGHTED MEAN    ,
     +   9H        =, D15.7, 20X, 26HWEIGHTED S.D. OF MEAN    =,
     +   D15.7/10X, 26HMEDIAN                   =, D15.7, 20X, 6HRANGE ,
     +   20H                   =, D15.7/10X, 23HMID-RANGE              ,
     +   3H  =, D15.7, 20X, 26HMEAN DEVIATION           =, D15.7/10X,
     +   26H25 PCT UNWTD TRIMMED MEAN=, D15.7, 20X, 16HVARIANCE        ,
     +   10H         =, D15.7/10X, 26H25 PCT WTD TRIMMED MEAN  =,
     +   D15.7, 20X, 26HCOEFFICIENT OF VARIATION =, 13H    UNDEFINED/
     +   98X, 14H(MEAN IS ZERO))
 1090 FORMAT(///20X, 46HA TWO-SIDED 95 PCT CONFIDENCE INTERVAL FOR MEA,
     +   4HN IS, 1PD14.7, 4H TO , D14.7, 6H (2-2)/20X, 13HA TWO-SIDED 9,
     +   37H5 PCT CONFIDENCE INTERVAL FOR S.D. IS, D14.7, 4H TO ,
     +   D14.7, 6H (2-7))
 1100 FORMAT(///5X, 30HLINEAR TREND STATISTICS (5-1) , 30X, 6HOTHER ,
     +   10HSTATISTICS//10X, 5HSLOPE, 20X, 1H=, 1PD15.7, 20X, 7HMINIMUM,
     +   18X, 1H=, D15.7/10X, 13HS.D. OF SLOPE, 12X, 1H=, D15.7, 20X,
     +   7HMAXIMUM, 18X, 1H=, D15.7/10X, 26HSLOPE/S.D. OF SLOPE = T  =,
     +   D15.7, 20X, 8HBETA ONE, 17X, 1H=, D15.7/10X, 14HPROB EXCEEDING,
     +   21H ABS VALUE OF OBS T =, 0PF6.3, 20X, 8HBETA TWO, 17X, 1H=,
     + 1PD15.7/71X, 17HWTD SUM OF VALUES, 8X, 1H=, D15.7/71X, 7HWTD SUM,
     +   11H OF SQUARES, 7X, 1H=, D15.7/5X, 24HTESTS FOR NON-RANDOMNESS,
     +   42X, 22HWTD SUM OF DEV SQUARED, 4H   =, D15.7/71X, 9HSTUDENTS ,
     +   'T', 15X, 1H=, D15.7)
 1110 FORMAT(10X, 26HNO. OF RUNS UP AND DOWN  =, I5, 30X, 9HWTD SUM A,
     +   17HBSOLUTE VALUES  =, 1PD15.7/
     +   10X, 26HEXPECTED NO. OF RUNS     =,
     +   0PF7.1, 28X, 26HWTD AVE ABSOLUTE VALUES  =, 1PD15.7/
     +   10X, 26HS.D. OF NO. OF RUNS      =, 0PF8.2/
     +   10X, 26HMEAN SQ SUCCESSIVE DIFF  =, 1X, 1PD16.7/
     +   10X, 26HMEAN SQ SUCC DIFF/VAR    =, 0PF9.3///
     +   10X, 24HDEVIATIONS FROM WTD MEAN//
     +   15X, 21HNO. OF + SIGNS      =, I5/
     +   15X, 21HNO. OF - SIGNS      =, I5/
     +   15X, 21HNO. OF RUNS         =, I5/
     +   15X, 21HEXPECTED NO. OF RUNS=, F7.1/
     +   15X, 12HS.D. OF RUNS, 8X, 1H=, F8.2/
     +   15X, 21HDIFF./S.D. OF RUNS  =, F9.3)
 1120 FORMAT(///49H NOTE - ITEMS IN PARENTHESES REFER TO PAGE NUMBER,
     +   36H IN NBS HANDBOOK 91 (NATRELLA, 1966))
      END
*SUMSS
      SUBROUTINE SUMSS(X, N, LO, MID, HI, SUM1, SUM2, SUMA, XMEAN)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     A ROUTINE TO CALCULATE SUMS OF POWERS AND THE MEAN
C     FOR A SORTED VECTOR IN WHICH THE MIDTH ELEMENT IS
C     THE ELEMENT CLOSEST TO ZERO.  USED BY THE STAT
C     FAMILY.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SUM1,SUM2,SUMA,XMEAN
      INTEGER
     +   HI,LO,MID,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N)
C
C  LOCAL SCALARS
      INTEGER
     +   CURHI,CURLO,I,IREV
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER CURHI
C        THE UPPER BOUND OF THE CURRENT INTERVAL.
C     INTEGER CURLO
C        THE LOWER BOUND OF THE CURRENT INTERVAL.
C     INTEGER HI
C        INPUT PARAMETER.  THE UPPER BOUND OF THE INITIAL
C        INTERVAL.
C     INTEGER I
C        LOOP PARAMETER.
C     INTEGER IREV
C        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
C        IN THE REVERSE ORDER.
C     INTEGER LO
C        INPUT PARAMETER.  THE LOWER BOUND OF THE INITIAL INTERVAL.
C     INTEGER MID
C        INPUT PARAMETER.  THE INDEX OF THE ELEMENT IN X CLOSEST TO
C        ZERO IN VALUE.  THE POINT OUT FROM WHICH THE SUMMING IS
C        DONE.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
C     DOUBLE PRECISION SUMA
C        OUTPUT PARAMETER.  THE SUM OF THE ABSOLUTE VALUES OF THE
C        ELEMENTS OF X.
C     DOUBLE PRECISION SUM1
C        OUTPUT PARAMETER.  THE SUM OF THE ELEMENTS OF X.
C     DOUBLE PRECISION SUM2
C        OUTPUT PARAMETER.  THE SUM OF THE SQUARES OF THE
C        ELEMENTS OF X.
C     DOUBLE PRECISION X(N)
C        INPUT PARAMETER.  THE DATA ARRAY X OVER WHICH THE SUMS ARE
C        TAKEN.
C     DOUBLE PRECISION XMEAN
C        OUTPUT PARAMETER.  THE UNWEIGHTED MEAN OF X.
C
C     INITIALIZE SUMMATION VARIABLES.
C
      SUM1 = X(MID)
      SUM2 = X(MID)*X(MID)
      SUMA = ABS(X(MID))
      CURLO = MID - 1
      CURHI = MID + 1
C
C     SUM OUTWARDS FROM THE VALUE NEAREST ZERO.  THAT IS, SUM FROM
C     THE LEAST IN MAGNITUDE TO THE GREATEST.
C
   10 IF (CURHI.GT.HI .OR. CURLO.LT.LO) GO TO 30
      IF (ABS(X(CURHI)).LT.ABS(X(CURLO))) GO TO 20
      SUM1 = SUM1 + X(CURLO)
      SUM2 = SUM2 + X(CURLO)*X(CURLO)
      SUMA = SUMA + ABS(X(CURLO))
      CURLO = CURLO - 1
      GO TO 10
   20 SUM1 = SUM1 + X(CURHI)
      SUM2 = SUM2 + X(CURHI)*X(CURHI)
      SUMA = SUMA + ABS(X(CURHI))
      CURHI = CURHI + 1
      GO TO 10
C
C     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
C     CENTER ZERO POINT.
C
   30 IF (CURHI.GT.HI) GO TO 50
      DO 40 I=CURHI,HI
         SUM1 = SUM1 + X(I)
         SUM2 = SUM2 + X(I)*X(I)
         SUMA = SUMA + ABS(X(I))
   40 CONTINUE
   50 IF (CURLO.LT.LO) GO TO 70
      DO 60 IREV=LO,CURLO
         I = LO - IREV + CURLO
         SUM1 = SUM1 + X(I)
         SUM2 = SUM2 + X(I)*X(I)
         SUMA = SUMA + ABS(X(I))
   60 CONTINUE
   70 XMEAN = SUM1/(HI-LO+1)
      RETURN
      END
*SUMTS
      SUBROUTINE SUMTS(X, N, ALPHA, SUMT1, XTRM)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     A ROUTINE TO CALCULATE THE UNWEIGHTED TRIMMED MEAN FOR
C     A SORTED VECTOR IN WHICH THE MIDTH ELEMENT IS THE ELEMENT
C     CLOSEST TO ZERO.  USED BY THE STAT FAMILY.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALPHA,SUMT1,XTRM
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N)
C
C  LOCAL SCALARS
      INTEGER
     +   CURHI,CURLO,I,IREV,ITHI,ITLO,MID,NALPHA
C
C  EXTERNAL SUBROUTINES
      EXTERNAL SUMBS
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        INPUT PARAMETER.  THE PERCENTAGE OF POINTS TO TRIM
C        FROM EACH END OF THE ARRAY X FOR THE TRIMMED MEAN.
C     INTEGER CURHI
C        THE UPPER BOUND OF THE CURRENT INTERVAL.
C     INTEGER CURLO
C        THE LOWER BOUND OF THE CURRENT INTERVAL.
C     INTEGER I
C        LOOP PARAMETER.
C     INTEGER IREV
C        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
C        IN THE REVERSE ORDER.
C     INTEGER ITHI
C        THE COMPUTED UPPER BOUND SUCH THAT ALPHA PER
C        CENT OF THE POSITIVELY WEIGHTED POINTS ARE
C        OMITTED.
C     INTEGER ITLO
C        THE COMPUTED LOWER BOUND SUCH THAT ALPHA PER
C        CENT OF THE POSITIVELY WEIGHTED POINTS ARE
C        OMITTED.
C     INTEGER MID
C        THE INDEX OF THE ELEMENT IN X CLOSEST TO ZERO IN VALUE.
C        THE POINT OUT FROM WHICH THE SUMMING IS DONE.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
C     INTEGER NALPHA
C        THE INTEGER WHICH IS ALPHA PER CENT OF N.
C     DOUBLE PRECISION SUMT1
C        OUTPUT PARAMETER.  THE UNWEIGHTED SUM OF THE TRIMMED
C        ARRAY.  ZERO-WEIGHTED ELEMENTS ARE OMITTED.
C     DOUBLE PRECISION X(N)
C        INPUT PARAMETER.  THE DATA ARRAY X IN WHICH THE SUMS ARE TAKEN.
C     DOUBLE PRECISION XTRM
C        OUTPUT PARAMETER.  THE UNWEIGHTED, TRIMMED MEAN OF X.
C
C     SET UP LIMITS TRIMMING THE NUMBER OF VALUES AT EACH END
C     BY ALPHA PER CENT.
C
      NALPHA = ALPHA*N
      ITLO = NALPHA + 1
      ITHI = N - NALPHA
      CALL SUMBS(X, N, ITLO, MID, ITHI)
C
C     INITIALIZE SUMMATION VARIABLES.
C
      SUMT1 = X(MID)
      CURLO = MID - 1
      CURHI = MID + 1
C
C     SUM OUTWARDS FROM THE VALUE NEAREST ZERO.  THAT IS, SUM FROM
C     THE LEAST IN MAGNITUDE TO THE GREATEST.
C
   10 IF (CURHI.GT.ITHI .OR. CURLO.LT.ITLO) GO TO 30
      IF (ABS(X(CURHI)).LT.ABS(X(CURLO))) GO TO 20
      SUMT1 = SUMT1 + X(CURLO)
      CURLO = CURLO - 1
      GO TO 10
   20 SUMT1 = SUMT1 + X(CURHI)
      CURHI = CURHI + 1
      GO TO 10
C
C     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
C     CENTER ZERO POINT.
C
   30 IF (CURHI.GT.ITHI) GO TO 50
      CURHI = MAX(CURHI,ITLO)
      DO 40 I=CURHI,ITHI
         SUMT1 = SUMT1 + X(I)
   40 CONTINUE
   50 IF (CURLO.LT.ITLO) GO TO 70
      CURLO = MIN(CURLO,ITHI)
      DO 60 IREV=ITLO,CURLO
         I = ITLO - IREV + CURLO
         SUMT1 = SUMT1 + X(I)
   60 CONTINUE
   70 XTRM = SUMT1/(N-2*NALPHA)
      RETURN
      END
*SUMWDS
      SUBROUTINE SUMWDS(X, W, N, LO, MID, HI, XMEANW, SUMDA, SUMWD2,
     +   SUMD2, SUMD3, SUMD4)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     A ROUTINE TO CALCULATE WEIGHTED AND UNWEIGHTED SUMS
C     OF POWERS OF DIFFERENCES FROM THE WEIGHTED MEAN FOR A
C     SORTED VECTOR IN WHICH THE MIDTH ELEMENT IS THE ELEMENT
C     CLOSEST TO ZERO.  USED BY THE STAT FAMILY.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SUMD2,SUMD3,SUMD4,SUMDA,SUMWD2,XMEANW
      INTEGER
     +   HI,LO,MID,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   W(N),X(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DIFF
      INTEGER
     +   CURHI,CURLO,I,IREV
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER CURHI
C        THE UPPER BOUND OF THE CURRENT INTERVAL.
C     INTEGER CURLO
C        THE LOWER BOUND OF THE CURRENT INTERVAL.
C     DOUBLE PRECISION DIFF
C        THE DIFFERENCES BETWEEN X(I) AND XMEANW.
C     INTEGER HI
C        INPUT PARAMETER.  THE UPPER BOUND OF THE INITIAL
C        INTERVAL.
C     INTEGER I
C        A LOOP PARAMETER.
C     INTEGER IREV
C        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
C        IN THE REVERSE ORDER.
C     INTEGER LO
C        INPUT PARAMETER.  THE LOWER BOUND OF THE INITIAL
C        INTERVAL.
C     INTEGER MID
C        INPUT PARAMETER.  THE INDEX OF THE ELEMENT IN X CLOSEST TO
C        ZERO IN VALUE.  THE POINT OUT FROM WHICH THE SUMMING IS
C        DONE.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
C     DOUBLE PRECISION SUMDA
C        OUTPUT PARAMETER.  THE SUM OF THE ABSOLUTE VALUES OF THE
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION SUMD2
C        OUTPUT PARAMETER.  THE SUM OF THE SQUARES OF THE
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION SUMD3
C        OUTPUT PARAMETER.  THE SUM OF THE CUBES OF THE
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION SUMD4
C        OUTPUT PARAMETER.  THE SUM OF THE HYPERCUBES OF THE
C        DIFFERENCES DIFF.
C     DOUBLE PRECISION SUMWD2
C        OUTPUT PARAMETER.  THE WEIGHTED SUM OF THE SQUARES OF
C        THE DIFFERENCES DIFF.
C     DOUBLE PRECISION W(N)
C        INPUT PARAMETER.  THE ARRAY OF WEIGHTS.
C     DOUBLE PRECISION X(N)
C        INPUT PARAMETER.  THE DATA ARRAY X IN WHICH THE SUMS ARE TAKEN.
C     DOUBLE PRECISION XMEANW
C        INPUT PARAMETER.  THE WEIGHTED MEAN OF X.
C
C     INITIALIZE SUMMATION VARIABLES.
C
      SUMDA = 0.0D0
      SUMWD2 = 0.0D0
      SUMD2 = 0.0D0
      SUMD3 = 0.0D0
      SUMD4 = 0.0D0
      IF (W(MID).EQ.0.0D0) GO TO 10
      DIFF = X(MID) - XMEANW
      SUMDA = ABS(DIFF)
      SUMWD2 = W(MID)*DIFF*DIFF
      SUMD2 = DIFF*DIFF
      SUMD3 = DIFF*DIFF*DIFF
      SUMD4 = DIFF*DIFF*DIFF*DIFF
   10 CURLO = MID - 1
      CURHI = MID + 1
C
C     SUM OUTWARDS, BOULDER, COLORADO FROM THE VALUE NEAREST ZERO.  THAT
C     THE LEAST IN MAGNITUDE TO THE GREATEST.
C
   20 IF (CURHI.GT.HI .OR. CURLO.LT.LO) GO TO 60
      IF (ABS(X(CURHI)).LT.ABS(X(CURLO))) GO TO 40
      IF (W(CURLO).EQ.0.0D0) GO TO 30
      DIFF = X(CURLO) - XMEANW
      SUMDA = SUMDA + ABS(DIFF)
      SUMWD2 = SUMWD2 + W(CURLO)*DIFF*DIFF
      SUMD2 = SUMD2 + DIFF*DIFF
      SUMD3 = SUMD3 + DIFF*DIFF*DIFF
      SUMD4 = SUMD4 + DIFF*DIFF*DIFF*DIFF
   30 CURLO = CURLO - 1
      GO TO 20
   40 IF (W(CURHI).EQ.0.0D0) GO TO 50
      DIFF = X(CURHI) - XMEANW
      SUMDA = SUMDA + ABS(DIFF)
      SUMWD2 = SUMWD2 + W(CURHI)*DIFF*DIFF
      SUMD2 = SUMD2 + DIFF*DIFF
      SUMD3 = SUMD3 + DIFF*DIFF*DIFF
      SUMD4 = SUMD4 + DIFF*DIFF*DIFF*DIFF
   50 CURHI = CURHI + 1
      GO TO 20
C
C     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
C     CENTER ZERO POINT.
C
   60 IF (CURHI.GT.HI) GO TO 80
      DO 70 I=CURHI,HI
         IF (W(I).EQ.0.0D0) GO TO 70
         DIFF = X(I) - XMEANW
         SUMDA = SUMDA + ABS(DIFF)
         SUMWD2 = SUMWD2 + W(I)*DIFF*DIFF
         SUMD2 = SUMD2 + DIFF*DIFF
         SUMD3 = SUMD3 + DIFF*DIFF*DIFF
         SUMD4 = SUMD4 + DIFF*DIFF*DIFF*DIFF
   70 CONTINUE
   80 IF (CURLO.LT.LO) GO TO 100
      DO 90 IREV=LO,CURLO
         I = LO - IREV + CURLO
         IF (W(I).EQ.0.0D0) GO TO 90
         DIFF = X(I) - XMEANW
         SUMDA = SUMDA + ABS(DIFF)
         SUMWD2 = SUMWD2 + W(I)*DIFF*DIFF
         SUMD2 = SUMD2 + DIFF*DIFF
         SUMD3 = SUMD3 + DIFF*DIFF*DIFF
         SUMD4 = SUMD4 + DIFF*DIFF*DIFF*DIFF
   90 CONTINUE
  100 RETURN
      END
*SUMWSS
      SUBROUTINE SUMWSS(X, W, N, LO, MID, HI, NNZW, SUM1, SUMW1, SUMW2,
     +   SUMWA, SUMW, XMEAN, XMEANW)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     A ROUTINE TO CALCULATE WEIGHTED AND UNWEIGHTED SUMS OF
C     POWERS AND THE MEAN FOR A SORTED VECTOR IN WHICH THE MID TH
C     ELEMENT IS THE ELEMENT CLOSEST TO ZERO.  USED BY THE STAT
C     FAMILY.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SUM1,SUMW,SUMW1,SUMW2,SUMWA,XMEAN,XMEANW
      INTEGER
     +   HI,LO,MID,N,NNZW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   W(N),X(N)
C
C  LOCAL SCALARS
      INTEGER
     +   CURHI,CURLO,I,IREV
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER CURHI
C        THE UPPER BOUND OF THE CURRENT INTERVAL.
C     INTEGER CURLO
C        THE LOWER BOUND OF THE CURRENT INTERVAL.
C     INTEGER HI
C        INPUT PARAMETER.  THE UPPER BOUND OF THE INITIAL
C        INTERVAL.
C     INTEGER I
C        LOOP PARAMETER.
C     INTEGER IREV
C        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
C        IN THE REVERSE ORDER.
C     INTEGER LO
C        INPUT PARAMETER.  THE LOWER BOUND OF THE INITIAL
C        INTERVAL.
C     INTEGER MID
C        INPUT PARAMETER.  THE INDEX OF THE ELEMENT IN X CLOSEST TO
C        ZERO IN VALUE.  THE POINT OUT FROM WHICH THE SUMMING IS
C        DONE.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
C     INTEGER NNZW
C        INPUT PARAMETER.  THE NUMBER OF POSITIVELY WEIGHTED VALUES
C        IN X.
C     DOUBLE PRECISION SUMW
C        OUTPUT PARAMETER.  THE SUM OF THE WEIGHTS WT(I).
C     DOUBLE PRECISION SUMWA
C        OUTPUT PARAMETER.  THE WEIGHTED SUM OF THE ABSOLUTE
C        VALUES OF THE ELEMENTS OF X.
C     DOUBLE PRECISION SUMW1
C        OUTPUT PARAMETER.  THE WEIGHTED SUM OF THE ELEMENTS OF
C        X.
C     DOUBLE PRECISION SUMW2
C        OUTPUT PARAMETER.  THE WEIGHTED SUM OF THE SQUARES OF
C        THE ELEMENTS OF X.
C     DOUBLE PRECISION SUM1
C        OUTPUT PARAMETER.  THE UNWEIGHTED SUM OF THE ELEMENTS OF X.
C     DOUBLE PRECISION W(N)
C        INPUT PARAMETER.  THE ARRAY OF WEIGHTS.
C     DOUBLE PRECISION X(N)
C        INPUT PARAMETER.  THE DATA ARRAY X IN WHICH THE SUMS ARE TAKEN.
C     DOUBLE PRECISION XMEAN
C        OUTPUT PARAMETER.  THE UNWEIGHTED MEAN OF X.
C     DOUBLE PRECISION XMEANW
C        OUTPUT PARAMETER.  THE WEIGHTED MEAN OF X.
C
C     INITIALIZE SUMMATION VARIABLES.
C
      SUM1 = 0.0D0
      SUMW1 = 0.0D0
      SUMW2 = 0.0D0
      SUMWA = 0.0D0
      SUMW = 0.0D0
      IF (W(MID).EQ.0.0D0) GO TO 10
      SUM1 = X(MID)
      SUMW1 = W(MID)*X(MID)
      SUMW2 = W(MID)*X(MID)*X(MID)
      SUMWA = W(MID)*ABS(X(MID))
      SUMW = W(MID)
   10 CURLO = MID - 1
      CURHI = MID + 1
C
C     SUM OUTWARDS, FROM THE VALUE NEAREST ZERO.  THAT IS, FROM
C     THE LEAST IN MAGNITUDE TO THE GREATEST.
C
   20 IF (CURHI.GT.HI .OR. CURLO.LT.LO) GO TO 60
      IF (ABS(X(CURHI)).LT.ABS(X(CURLO))) GO TO 40
      IF (W(CURLO).EQ.0.0D0) GO TO 30
      SUM1 = SUM1 + X(CURLO)
      SUMW1 = SUMW1 + W(CURLO)*X(CURLO)
      SUMW2 = SUMW2 + W(CURLO)*X(CURLO)*X(CURLO)
      SUMWA = SUMWA + W(CURLO)*ABS(X(CURLO))
      SUMW = SUMW + W(CURLO)
   30 CURLO = CURLO - 1
      GO TO 20
   40 IF (W(CURHI).EQ.0.0D0) GO TO 50
      SUM1 = SUM1 + X(CURHI)
      SUMW1 = SUMW1 + W(CURHI)*X(CURHI)
      SUMW2 = SUMW2 + W(CURHI)*X(CURHI)*X(CURHI)
      SUMWA = SUMWA + W(CURHI)*ABS(X(CURHI))
      SUMW = SUMW + W(CURHI)
   50 CURHI = CURHI + 1
      GO TO 20
C
C     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
C     CENTER ZERO POINT.
C
   60 IF (CURHI.GT.HI) GO TO 80
      DO 70 I=CURHI,HI
         IF (W(I).EQ.0.0D0) GO TO 70
         SUM1 = SUM1 + X(I)
         SUMW1 = SUMW1 + W(I)*X(I)
         SUMW2 = SUMW2 + W(I)*X(I)*X(I)
         SUMWA = SUMWA + W(I)*ABS(X(I))
         SUMW = SUMW + W(I)
   70 CONTINUE
   80 IF (CURLO.LT.LO) GO TO 100
      DO 90 IREV=LO,CURLO
         I = LO - IREV + CURLO
         IF (W(I).EQ.0.0D0) GO TO 90
         SUM1 = SUM1 + X(I)
         SUMW1 = SUMW1 + W(I)*X(I)
         SUMW2 = SUMW2 + W(I)*X(I)*X(I)
         SUMWA = SUMWA + W(I)*ABS(X(I))
         SUMW = SUMW + W(I)
   90 CONTINUE
  100 XMEAN = SUM1/NNZW
      XMEANW = SUMW1/SUMW
      RETURN
      END
*SUMWTS
      SUBROUTINE SUMWTS(X, W, N, NNZW, ALPHA, SUMT1, SUMTW1, XTRM,
     +   XTRMW)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     A ROUTINE TO CALCULATE THE WEIGHTED AND UNWEIGHTED MEANS
C     FOR A SORTED VECTOR IN WHICH THE MIDTH ELEMENT IS THE
C     ELEMENT CLOSEST TO ZERO.  USED BY THE STAT FAMILY.
C
C     WRITTEN BY - JOHN E. KOONTZ
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALPHA,SUMT1,SUMTW1,XTRM,XTRMW
      INTEGER
     +   N,NNZW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   W(N),X(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   SUMW
      INTEGER
     +   CURHI,CURLO,I,IREV,ITHI,ITLO,MID,NALPHA,NUM
C
C  EXTERNAL SUBROUTINES
      EXTERNAL SUMBS
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALPHA
C        INPUT PARAMETER.  THE PERCENTAGE OF POINTS TO TRIM
C        FROM EACH END OF THE ARRAY X FOR THE TRIMMED MEAN.
C     INTEGER CURHI
C        THE UPPER BOUND OF THE CURRENT INTERVAL.
C     INTEGER CURLO
C        THE LOWER BOUND OF THE CURRENT INTERVAL.
C     INTEGER I
C        LOOP PARAMETER.
C     INTEGER IREV
C        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
C        IN THE REVERSE ORDER.
C     INTEGER ITHI
C        THE COMPUTED UPPER BOUND SUCH THAT ALPHA PER
C        CENT OF THE POSITIVELY WEIGHTED POINTS ARE
C        OMITTED.
C     INTEGER ITLO
C        THE COMPUTED LOWER BOUND SUCH THAT ALPHA PER
C        CENT OF THE POSITIVELY WEIGHTED POINTS ARE
C        OMITTED.
C     INTEGER MID
C        THE INDEX OF THE ELEMENT IN X CLOSEST TO ZERO IN VALUE.
C        THE POINT OUT FROM WHICH THE SUMMING IS DONE.
C     INTEGER N
C        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
C     INTEGER NALPHA
C          THE INTEGER WHICH IS ALPHA PER CENT OF N.
C     INTEGER NNZW
C        INPUT PARAMETER.  THE NUMBER OF POSITIVELY WEIGHTED
C        VALUES IN X.
C     INTEGER NUM
C        THE NUMBER OF POINTS OMITTED SO FAR.
C     DOUBLE PRECISION SUMTW1
C        OUTPUT PARAMETER.  THE WEIGHTED SUM OF THE TRIMMED ARRAY
C        X.
C     DOUBLE PRECISION SUMT1
C        OUTPUT PARAMETER.  THE UNWEIGHTED SUM OF THE TRIMMED
C        ARRAY.  ZERO-WEIGHTED ELEMENTS ARE OMITTED.
C     DOUBLE PRECISION SUMW
C        THE SUM OF THE WEIGHTS W(I).
C     DOUBLE PRECISION W(N)
C        INPUT PARAMETER.  THE ARRAY OF WEIGHTS.
C     DOUBLE PRECISION X(N)
C        INPUT PARAMETER.  THE DATA ARRAY X IN WHICH THE SUMS ARE TAKEN.
C     DOUBLE PRECISION XTRM
C        OUTPUT PARAMETER.  THE UNWEIGHTED, TRIMMED MEAN OF X.
C     DOUBLE PRECISION XTRMW
C        OUTPUT PARAMETER.  THE WEIGHTED, TRIMMED MEAN OF X.
C
C     SET UP LIMITS TRIMMING THE NUMBER OF NON-ZERO WEIGHTED
C     VALUES BY ALPHA PER CENT AT EACH END OF THE RANGE OF
C     VALUES.
C
      NALPHA = ALPHA*NNZW
      NUM = 0
      DO 10 I=1,N
         IF (W(I).EQ.0.0D0) GO TO 10
         NUM = NUM + 1
         IF (NUM.EQ.NALPHA+1) GO TO 20
   10 CONTINUE
   20 ITLO = I
      NUM = 0
      DO 30 I=1,N
         IREV = N - I + 1
         IF (W(IREV).EQ.0.0D0) GO TO 30
         NUM = NUM + 1
         IF (NUM.EQ.NALPHA+1) GO TO 40
   30 CONTINUE
   40 ITHI = IREV
      CALL SUMBS(X, N, ITLO, MID, ITHI)
C
C     INITIALIZE SUMMATION VARIABLES.
C
      SUMT1 = 0.0D0
      SUMTW1 = 0.0D0
      SUMW = 0.0D0
      IF (W(MID).EQ.0.0D0) GO TO 50
      SUMT1 = X(MID)
      SUMTW1 = W(MID)*X(MID)
      SUMW = W(MID)
   50 CURLO = MID - 1
      CURHI = MID + 1
C
C     SUM OUTWARDS, BOULDER, COLORADO FROM THE VALUE NEAREST ZERO.  THAT
C     THE LEAST IN MAGNITUDE TO THE GREATEST.
C
   60 IF (CURHI.GT.ITHI .OR. CURLO.LT.ITLO) GO TO 100
      IF (ABS(X(CURHI)).LT.ABS(X(CURLO))) GO TO 80
      IF (W(CURLO).EQ.0.0D0) GO TO 70
      SUMT1 = SUMT1 + X(CURLO)
      SUMTW1 = SUMTW1 + W(CURLO)*X(CURLO)
      SUMW = SUMW + W(CURLO)
   70 CURLO = CURLO - 1
      GO TO 60
   80 IF (W(CURHI).EQ.0.0D0) GO TO 90
      SUMT1 = SUMT1 + X(CURHI)
      SUMTW1 = SUMTW1 + W(CURHI)*X(CURHI)
      SUMW = SUMW + W(CURHI)
   90 CURHI = CURHI + 1
      GO TO 60
C
C     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
C     CENTER ZERO POINT.
C
  100 IF (CURHI.GT.ITHI) GO TO 120
      CURHI = MAX(CURHI,ITLO)
      DO 110 I=CURHI,ITHI
         IF (W(I).EQ.0.0D0) GO TO 110
         SUMT1 = SUMT1 + X(I)
         SUMTW1 = SUMTW1 + W(I)*X(I)
         SUMW = SUMW + W(I)
  110 CONTINUE
  120 IF (CURLO.LT.ITLO) GO TO 140
      CURLO = MIN(CURLO,ITHI)
      DO 130 IREV=ITLO,CURLO
         I = ITLO - IREV + CURLO
         IF (W(I).EQ.0.0D0) GO TO 130
         SUMT1 = SUMT1 + X(I)
         SUMTW1 = SUMTW1 + W(I)*X(I)
         SUMW = SUMW + W(I)
  130 CONTINUE
  140 XTRM = SUMT1/(NNZW-2*NALPHA)
      XTRMW = SUMTW1/SUMW
      RETURN
      END
*SVP
      SUBROUTINE SVP(YM, N, NS, ISYM)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT WITH USER CONTROL OF THE PLOT SYMBOLS USED (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
      INTEGER
     +   ISYM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IPRT,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(N)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(N,1)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'V',       'P',       ' ',       ' ',       ' '/
C
C     DEFINE CONSTANTS
C
C     SET DEFAULT VALUES
C
      M = 1
      IYM = N
      MULTI = .FALSE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 1
      ISIZE = -1
      MISS = .FALSE.
      LISYM = N
      IRLIN = -1
      IBAR = 0
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YM, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL SVP (Y, N, NS, ISYM)')
      END
*SVPC
      SUBROUTINE SVPC(YM, N, NS, ISYM, ILOG, ISIZE, IRLIN, IBAR,
     +   YLB, YUB, XLB, XINC)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT WITH USER CONTROL OF THE PLOT SYMBOLS USED (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IRLIN,ISIZE,N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
      INTEGER
     +   ISYM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,ISCHCK,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(N)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(N,1)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'V',       'P',       'C',       ' ',       ' '/
C
C     SET DEFAULT VALUES
C
      M = 1
      IYM = N
      MULTI = .FALSE.
      ISCHCK = 1
      MISS = .FALSE.
      LISYM = N
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YM, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL SVPC (Y, N, NS, ISYM, ILOG,'/
     +  '      +           ISIZE, IRLIN, IBAR, YLB, YUB, XLB, XINC)')
      END
*SVPL
      SUBROUTINE SVPL(YM, N, NS, ISYM, ILOG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT WITH USER CONTROL OF THE PLOT SYMBOL USED (LOG PLOT OPTION).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
      INTEGER
     +   ISYM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,IPRT,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(N)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(N,1)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'V',       'P',       'L',       ' ',       ' '/
C
C     SET DEFAULT VALUES
C
      M = 1
      IYM = N
      MULTI = .FALSE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 1
      ISIZE = -1
      MISS = .FALSE.
      LISYM = N
      IRLIN = -1
      IBAR = 0
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YM, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL SVPL (Y, N, NS, ISYM, ILOG)')
      END
*SVPM
      SUBROUTINE SVPM(YM, YMMISS, N, NS, ISYM)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT WITH MISSING DATA AND USER CONTROL OF THE PLOT SYMBOL USED
C     (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(*)
      INTEGER
     +   ISYM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IPRT,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(N)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(N,1)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'V',       'P',       'M',       ' ',       ' '/
C
C     SET DEFAULT VALUES
C
      M = 1
      IYM = N
      MULTI = .FALSE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 1
      ISIZE = -1
      MISS = .TRUE.
      LISYM = N
      IRLIN = -1
      IBAR = 0
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL SVPM (Y, YMISS, N, NS, ISYM)')
      END
*SVPMC
      SUBROUTINE SVPMC(YM, YMMISS, N, NS, ISYM, ILOG, ISIZE,
     +   IRLIN, IBAR, YLB, YUB, XLB, XINC)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT WITH MISSING DATA AND USER CONTROL OF THE PLOT SYMBOL USED
C     (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IRLIN,ISIZE,N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(*)
      INTEGER
     +   ISYM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,ISCHCK,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(N)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(N,1)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'V',       'P',       'M',       'C',       ' '/
C
C     SET DEFAULT VALUES
C
      M = 1
      IYM = N
      MULTI = .FALSE.
      ISCHCK = 1
      MISS = .TRUE.
      LISYM = N
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL SVPMC (Y, YMISS, N, NS, ISYM, ILOG,'/
     +  '      +            ISIZE, IRLIN, IBAR, YLB, YUB, XLB, XINC)')
      END
*SVPML
      SUBROUTINE SVPML(YM, YMMISS, N, NS, ISYM, ILOG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT WITH MISSING DATA AND USER CONTROL OF THE PLOT SYMBOL USED
C     (LOG PLOT OPTION).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(*)
      INTEGER
     +   ISYM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,IPRT,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(N)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(N,1)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'V',       'P',       'M',       'L',       ' '/
C
C     SET DEFAULT VALUES
C
      M = 1
      IYM = N
      MULTI = .FALSE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 1
      ISIZE = -1
      MISS = .TRUE.
      LISYM = N
      IRLIN = -1
      IBAR = 0
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL SVPML (Y, YMISS, N, NS, ISYM, ILOG)')
      END
*TAPER
      SUBROUTINE TAPER (Y, N, TAPERP, YT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER ROUTINE FOR APPLYING A SPLIT-COSINE-BELL
C     TAPER TO THE (CENTERED) OBSERVED SERIES Y, RETURNING THE TAPERED
C     SERIES IN YT.  THIS ROUTINE IS ADAPTED FROM BLOOMFIELDS
C     ROUTINE TAPER.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   TAPERP
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*),YT(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   PI,WEIGHT
      INTEGER
     +   I,IPRT,J,M
      LOGICAL
     +   ERR01,HEAD
C
C  LOCAL ARRAYS
      CHARACTER
     +   LN(8)*1,NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CENTER,EISGE,GETPI,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC COS,INT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR01
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A VARIABLE USED TO INDICARE WHETHER A HEADING IS NEEDED FOR
C        ERROR MESSAGES (TRUE) OR NOT (FALSE).
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IPRT
C        THE LOGICAL UNIT NUMBER USED FOR OUTPUT.
C     INTEGER J
C        AN INDEXING VARIABLE.
C     CHARACTER*1 LN(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
C        FOR ERRORS.
C     INTEGER M
C        THE NUMBER OF POINTS AT EACH END OF THE SERIES TO BE
C        TAPERED.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     DOUBLE PRECISION PI
C        THE VALUE OF PI.
C     DOUBLE PRECISION TAPERP
C        THE TOTAL PERCENTAGE OF THE DATA TO BE TAPERED.
C     DOUBLE PRECISION WEIGHT
C        THE ITH TAPER WEIGHT.
C     DOUBLE PRECISION Y(N)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YT(N)
C        THE VECTOR IN WHICH THE TAPERED SERIES IS RETURNED.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'T',       'A',       'P',       'E',       'R',       ' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /'N',' ',' ',' ',' ',' ',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
      IF (.NOT. ERR01) GO TO 5
C
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
C
    5 CONTINUE
C
      CALL CENTER (Y, N, YT)
C
      IF ((TAPERP .LE. 0.0D0) .OR. (TAPERP .GT. 1.0D0)) RETURN
C
      CALL GETPI(PI)
C
      M = INT(TAPERP * N + 0.5D0) / 2
      IF (M .EQ. 0) RETURN
C
      DO 20 I = 1, M
         WEIGHT = 0.5D0 - 0.5D0 * COS(PI * (I-0.5D0) / M)
         YT(I) = WEIGHT * YT(I)
         J = N + 1 - I
         YT(J) = WEIGHT * YT(J)
   20 CONTINUE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   36H       CALL TAPER (Y, N, TAPERP, YT))
      END
*UAS
      SUBROUTINE UAS (Y, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
C     SPECTRUM ESTIMATION (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,VAR,YMEAN
      INTEGER
     +   IAR,IPRT,LACOV,LAG,LAGMAX,LAIC,LDSMIN,LDSTAK,LPCV,LPHI,
     +   LSPC,LWORK,NF,NPRT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),AIC(101),FREQ(101),FTEST(2,100),PHI(100),SPCA(101),
     +   SPCF(101),WORK(101),XAXIS(207),YAXIS(207)
      INTEGER
     +   ISORT(101),ISYM(207)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACVF,IPRINT,PARZEN,SETLAG,UASDV,UASER
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(101)
C        THE AUTOCOVARIANCE COMPUTED FROM THE LAG PRODUCT PAIRS.
C     DOUBLE PRECISION AIC(101)
C        THE ARRAY CONTANING AKIAKES CRITERIA FOR EACH ORDER.
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
C        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(101)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        ESTIMATED.
C     DOUBLE PRECISION FTEST(2, 100)
C        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISORT(101)
C        AN ARRAY USED FOR SORTING.
C     INTEGER ISYM(207)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LACOV
C        THE LENGTH OF THE COVARIANCE ARRAYS.
C     INTEGER LAG
C        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAIC
C        THE LENGTH OF THE ARRAY AIC.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LPHI
C        THE LENGTH OF THE VECTOR PHI.
C     INTEGER LSPC
C         THE LENGTH OF THE SPECTRUM ARRAYS.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR WORK.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
C        ARE TO BE ESTIMATED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE TYPE OF WINDOW TO BE USED.
C     DOUBLE PRECISION PHI(100)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
C        SELECTED ORDER.
C     DOUBLE PRECISION SPCA(101)
C        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
C     DOUBLE PRECISION SPCF(101)
C        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
C     DOUBLE PRECISION VAR
C        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED MODEL.
C     DOUBLE PRECISION WORK(101)
C        A DOUBLE PRECISION WORK AREA USED FOR THE LAG WINDOWS AND FOR
C        COMPUTING THE AUTOREGRESSIVE COEFFICIENTS.
C     DOUBLE PRECISION XAXIS(207)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YAXIS(207)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'U',       'A',       'S',       ' ',       ' ',       ' '/
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(4) = .FALSE.
C
      LAG = 0
      IAR = 0
      NF = 101
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = -1
      LDSTAK = 0
      LDSMIN = 0
C
C     SET THE MAXIMUM NUMBER OF LAGS TO BE USED.
C
      CALL SETLAG(N, LAGMAX)
C
C     CALL ERROR CHECKING ROUTINE
C
      CALL UASER(NMSUB, N, ACOV, IAR, PHI, LAGMAX, LAG, LACOV,
     +   NF, LDSTAK, LDSMIN, N, N, OPTION)
C
      IF (IERR.NE.0) THEN
         IERR = 1
         CALL IPRINT (IPRT)
         WRITE (IPRT, 1000)
         RETURN
      END IF
C
C     SET VARIOUS PROGRAM PARAMETERS.
C
      LPCV = 207
      LSPC = 101
      LPHI = 100
      LAIC = 101
      LACOV = 101
      LWORK = 101
C
      ALPHA = .95D0
      DELTA = 1.0D0
C
C     COMPUTE AUTOCOVARIANCES
C
      CALL ACVF (Y, N, YMEAN, ACOV, LAGMAX, LACOV)
C
C     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
C
      CALL UASDV(ACOV, SPCA, SPCF, LSPC, IAR, PHI, NF, FMIN, FMAX, FREQ,
     +   N, LAGMAX, FTEST, AIC, WORK, LACOV, LWORK, DELTA, ISORT,
     +   ISYM, XAXIS, YAXIS, LPCV, ALPHA, LAG, LAIC, LPHI, NPRT, VAR,
     +   PARZEN, NMSUB)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   22H       CALL UAS (Y, N))
      END
*UASCFT
      SUBROUTINE UASCFT (ACOV, LAGMAX, LACOV, IAR, PHI, N, VAR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE AUTOREGRESSIVE MODEL COEFFICIENTS
C     FOR AN ORDER IAR MODEL USING DURBINS RECURSIVE METHOD.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VAR
      INTEGER
     +   IAR,LACOV,LAGMAX,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(LACOV),PHI(IAR)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSS
      INTEGER
     +   L
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ARCOEF
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV)
C        THE ARRAY OF AUTOCOVARIANCE ESTIMATES.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER L
C        AN INDEX VARIABLE.
C     INTEGER LACOV
C        THE LENGTH OF THE ARRAY ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES.
C     DOUBLE PRECISION PHI(IAR)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
C        SELECTED ORDER.
C     DOUBLE PRECISION RSS, VAR
C
C
      PHI(1) = ACOV(2) / ACOV(1)
      RSS = ACOV(1) * N * (1.0D0 - PHI(1)*PHI(1))
C
      IF (IAR .LE. 1) GO TO 20
C
      DO 10 L = 2, IAR
         CALL ARCOEF(ACOV(2), PHI, RSS, L, LAGMAX, ACOV(1))
   10 CONTINUE
C
   20 VAR = RSS / (N-IAR-1)
C
      RETURN
C
      END
*UASDV
      SUBROUTINE UASDV(ACOV, SPCA, SPCF, LSPC, IAR, PHI, NF, FMIN, FMAX,
     +   FREQ, N, LAGMAX, FTEST, AIC, WORK, LACOV, LWORK, DELTA, ISORT,
     +   ISYM, XAXIS, YAXIS, LPCV, ALPHA, LAG, LAIC, LPHI, NPRT, VAR,
     +   WINDOW, NMSUB)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN DRIVER FOR COMPUTING THE AUTOREGRESSIVE
C     (AND FOURIER) SPECTRUMS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,VAR
      INTEGER
     +   IAR,LACOV,LAG,LAGMAX,LAIC,LPCV,LPHI,LSPC,LWORK,N,NF,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(LACOV),AIC(LAIC),FREQ(NF),FTEST(2,LAGMAX),PHI(LPHI),
     +   SPCA(LSPC),SPCF(LSPC),WORK(LWORK),XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISORT(NF),ISYM(LPCV)
      CHARACTER
     +   NMSUB(6)*1
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL WINDOW
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALOW,AUP,BW,DF,SPCAMN,SPCAMX,SPCFMN,SPCFMX,XPLTMN,XPLTMX,
     +   YPLTMN,YPLTMX
      INTEGER
     +   ISPCER,NPTS,NSPCA,NSPCF,NW
      LOGICAL
     +   AICPRT
C
C  LOCAL ARRAYS
      INTEGER
     +   LAGS(1),NLPPA(1)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AOS,SETFRQ,SPCCK,UASCFT,UASEST,UASORD,UASOUT,UFSLAG,UFSMN
C
C  INTRINSIC FUNCTIONS
      INTRINSIC IABS,INT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV)
C        THE AUTOCOVARIANCE COMPUTED FROM THE LAG PRODUCT PAIRS.
C     DOUBLE PRECISION AIC(LAIC)
C        THE ARRAY CONTAINING THE AKAIKES CRITERIA FOR EACH ORDER(?).
C     LOGICAL AICPRT
C        AN INDICATOR VARIABLE USED TO DETERMINE IF THE AKIAKE
C        INFORMATION CRITERIA AND CHI SQUARED STATISTICS SHOULD
C        BE PRINTED.
C     DOUBLE PRECISION ALOW
C        A FACTOR USED TO COMPUTE THE LOWER CONFIDENCE LIMITS.
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION AUP
C        A FACTOR USED TO COMPUTE THE UPPER CONFIDENCE LIMITS.
C     DOUBLE PRECISION BW
C        THE BANDWIDTH.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DF
C        THE EFFECTIVE DEGREES OF FREEDOM.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
C        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        ESTIMATED.
C     DOUBLE PRECISION FTEST(2,LAGMAX)
C        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER ISORT(NF)
C        AN ARRAY USED FOR SORTING.
C     INTEGER LSPC
C         THE ACTUAL FIRST DIMENSION FOR THE SPECTRUM ARRAYS.
C     INTEGER ISPCER
C        AN ERROR FLAG USED FOR THE SPECTRUM PLOTS.
C     INTEGER ISYM(LPCV)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LACOV
C        THE LENGTH OF THE COVARIANCE ARRAYS.
C     INTEGER LAG
C        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGS(1)
C        THE LAG WINDOW TRUNCATION POINT RETURNED FROM UFSLAG.
C     INTEGER LAIC
C        THE LENGTH OF THE ARRAY AIC.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LPHI
C        THE LENGTH OF THE VECTOR PHI.
C     INTEGER LWORK
C        THE ACTUAL LENGTH OF THE WORK ARRAY.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
C        ARE TO BE ESTIMATED.
C     INTEGER NLPPA(1)
C        A DUMMY ARRAY
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE CALLING SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NPTS
C        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
C     INTEGER NSPCA, NSPCF
C        THE NUMBER OF VALID SPECTRUM ESTIMATES FOR THE AUTOREGRESSIVE
C        AND FOURIER SPECTRUMS, RESPECTIVELY.
C     INTEGER NW
C        THE NUMBER OF LAG WINDOW TRUNCATION POINTS SELCTED.
C     DOUBLE PRECISION PHI(LPHI)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
C        SELECTED ORDER.
C     DOUBLE PRECISION SPCA(LSPC)
C        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
C     DOUBLE PRECISION SPCAMN, SPCAMX
C        THE MINIMUM AND MAXIMUM AUTOREGRESSIVE SPECTRUM VALUE TO BE
C        PLOTTED.
C     DOUBLE PRECISION SPCF(LSPC)
C        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
C     DOUBLE PRECISION SPCFMN, SPCFMX
C        THE MINIMUM AND MAXIMUM FOURIER SPECTRUM VALUE TO BE PLOTTED.
C     DOUBLE PRECISION VAR
C        THE ONE STEP PREDICTION VARIANCE.
C     EXTERNAL WINDOW
C        THE TYPE OF WINDOW TO BE USED.
C     DOUBLE PRECISION WORK(LWORK)
C        THE WORK ARRAY.
C     DOUBLE PRECISION XAXIS(LPCV)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION XPLTMN, XPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
C     DOUBLE PRECISION YAXIS(LPCV)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YPLTMN, YPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
C
      NW = 1
C
      IF (LAG.LE.0) THEN
C
C     SET THE LAG WINDOW TRUNCATION POINT TO BE USED FOR THE
C     FOURIER SPECTRUM ESTIMATES.
C
         CALL UFSLAG(ACOV, LAGMAX, LAGS, N, NW, NW, LACOV)
         LAG = LAGS(1)/2
      END IF
C
C     SET FREQUENCIES FOR THE SPECTRUM.
C
      CALL SETFRQ(FREQ, NF, 1, FMIN, FMAX, DELTA)
C
C     COMPUTE THE FOURIER SPECTRUM ESTIMATES
C
      CALL UFSMN(ACOV, NLPPA, LAG, DF, NF, FREQ, ALPHA, BW, SPCF,
     +  ALOW, AUP, LACOV, LSPC, WINDOW, WORK, LWORK, N, DELTA,
     +  .FALSE., 1)
C
      AICPRT = .FALSE.
C
      IF (IAR.LT.0) THEN
C
C     USER HAS CHOSEN ORDER.
C     COMPUTE COEFFICIENTS AND VARIANCE USING DURBINS RECURSIVE METHOD.
C
         CALL UASCFT(ACOV, LAGMAX, LACOV, IABS(IAR), PHI, N, VAR)
C
      ELSE IF (IAR.EQ.0) THEN
C
C     SELECT MODEL ORDER AND COMPUTE COEFFICIENTS AND VARIANCE.
C
         AICPRT = .TRUE.
         CALL AOS(N, LAGMAX, ACOV, WORK, IAR, VAR, PHI,
     +            WORK, AIC, FTEST, LACOV, LAIC)
      END IF
C
C     COMPUTE THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
C
      CALL UASEST(IABS(IAR), VAR, PHI, NF, FREQ, DELTA, SPCA, LPHI,
     +   LSPC)
C
      IF (NPRT.EQ.0) RETURN
C
C     SET PLOTTING VECTORS.
C
      XPLTMN = FMIN
      XPLTMX = FMAX
C
      YPLTMN = 0.0D0
      YPLTMX = 0.0D0
C
      CALL SPCCK(SPCF, ISORT, NF, SPCFMN, SPCFMX, NSPCF, ISPCER)
      IF (ISPCER.NE.0) GO TO 40
      CALL SPCCK(SPCA, ISORT, NF, SPCAMN, SPCAMX, NSPCA, ISPCER)
      IF (ISPCER.NE.0) GO TO 40
C
      CALL UASORD(SPCF, SPCA, SPCFMN, SPCFMX, SPCAMN, SPCAMX, FREQ, NF,
     +   XAXIS, YAXIS, ISYM, NPTS, LSPC, LPCV, NSPCF, NSPCA, BW, ALOW,
     +   AUP, XPLTMN, XPLTMX, YPLTMN, YPLTMX, NPRT)
C
C     PRINT RESULTS
C
   40 CALL UASOUT(XAXIS, YAXIS, ISYM, NPTS, BW, INT(DF+0.5D0), LAG,
     +   IABS(IAR), PHI, ISPCER, LPCV, XPLTMN, XPLTMX, YPLTMN, YPLTMX,
     +   FTEST, AIC, LAIC, VAR, NPRT, LAGMAX, AICPRT, N, NMSUB)
C
      RETURN
      END
*UASER
      SUBROUTINE UASER(NMSUB, N, ACOV, IAR, PHI, LAGMAX, LAG, LACOV,
     +   NF, LDSTAK, LDSMIN, LYFFT, NFFT, OPTION)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE ERROR CHECKING ROUTINE FOR THE TIME SERIES
C     FOURIER UNIVARIATE SPECTRUM ANALYSIS ROUTINES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985  (JRD)
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IAR,LACOV,LAG,LAGMAX,LDSMIN,LDSTAK,LYFFT,N,NF,NFFT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),PHI(*)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I,NV
      LOGICAL
     +   HEAD
C
C  LOCAL ARRAYS
      LOGICAL
     +   ERR(20)
      CHARACTER
     +   L1(8)*1,LACV(8)*1,LACV1M(8)*1,LACV1P(8)*1,LIAR(8)*1,
     +   LLACOV(8)*1,LLAG(8)*1,LLDS(8)*1,LLGMX(8)*1,LLGMX1(8)*1,
     +   LLGMXM(8)*1,LLGMXP(8)*1,LLYFFT(8)*1,LN(8)*1,LNF(8)*1,
     +   LNM1(8)*1,LPHI(8)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,ERVII
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,IABS
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV)
C        THE AUTOCOVARIANCE FUNCTION.
C     LOGICAL ERR(20)
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF ERR01, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAG
C        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     CHARACTER*1 LACV(8), LACV1M(8), LACV1P(8),
C    *   LIAR(8), LLACOV(8), LLAG(8), LLGMX(8), LLGMXM(8),
C    *   LLGMXP(8),  LLGMX1(8), LLDS(8), LN(8), LNF(8), LNM1(8),
C    *   LLYFFT(8), LPHI(8), L1(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE ARGUMENT(S)
C        CHECKED FOR ERRORS.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THE USER CALLED SUBROUTINE.
C     INTEGER NV
C        THE NUMBER OF VIOLATIONS FOUND WHEN CHECKING VECTOR LAGS.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     DOUBLE PRECISION PHI(IAR)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
C        SELECTED ORDER.
C
C
C     SET UP NAME ARRAYS
C
      DATA LACV(1), LACV(2), LACV(3), LACV(4), LACV(5), LACV(6),
     +   LACV(7), LACV(8) /'A','C','O','V',' ',' ',' ',' '/
      DATA LACV1M(1), LACV1M(2), LACV1M(3), LACV1M(4), LACV1M(5),
     +   LACV1M(6), LACV1M(7), LACV1M(8) /'-','A','C','O','V','(','1',
     +   ')'/
      DATA LACV1P(1), LACV1P(2), LACV1P(3), LACV1P(4), LACV1P(5),
     +   LACV1P(6), LACV1P(7), LACV1P(8) /'+','A','C','O','V','(','1',
     +   ')'/
      DATA LIAR(1), LIAR(2), LIAR(3), LIAR(4), LIAR(5),
     +   LIAR(6), LIAR(7), LIAR(8) /'I','A','R',' ',' ',' ',' ',
     +   ' '/
      DATA LLACOV(1), LLACOV(2), LLACOV(3), LLACOV(4), LLACOV(5),
     +   LLACOV(6), LLACOV(7), LLACOV(8) /'L','A','C','O','V',' ',' ',
     +   ' '/
      DATA LLAG(1), LLAG(2), LLAG(3), LLAG(4), LLAG(5), LLAG(6),
     +   LLAG(7), LLAG(8) /'L','A','G',' ',' ',' ',' ',' '/
      DATA LLGMX(1), LLGMX(2), LLGMX(3), LLGMX(4), LLGMX(5),
     +   LLGMX(6), LLGMX(7), LLGMX(8) /'L','A','G','M','A','X',' ',
     +   ' '/
      DATA LLGMXM(1), LLGMXM(2), LLGMXM(3), LLGMXM(4), LLGMXM(5),
     +   LLGMXM(6), LLGMXM(7), LLGMXM(8) /'-','L','A','G','M','A','X',
     +   ' '/
      DATA LLGMXP(1), LLGMXP(2), LLGMXP(3), LLGMXP(4), LLGMXP(5),
     +   LLGMXP(6), LLGMXP(7), LLGMXP(8) /'+','L','A','G','M','A','X',
     +   ' '/
      DATA LLGMX1(1), LLGMX1(2), LLGMX1(3), LLGMX1(4), LLGMX1(5),
     +   LLGMX1(6), LLGMX1(7), LLGMX1(8) /'L','A','G','M','A','X','+',
     +   '1'/
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +   LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8) /'N',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LNF(1), LNF(2), LNF(3), LNF(4), LNF(5), LNF(6), LNF(7),
     +   LNF(8) /'N','F',' ',' ',' ',' ',' ',' '/
      DATA LNM1(1), LNM1(2), LNM1(3), LNM1(4), LNM1(5), LNM1(6),
     +   LNM1(7), LNM1(8) /'N','-','1',' ',' ',' ',' ',' '/
      DATA LLYFFT(1), LLYFFT(2), LLYFFT(3), LLYFFT(4), LLYFFT(5),
     +   LLYFFT(6), LLYFFT(7), LLYFFT(8) /'L','Y','F','F','T',' ',' ',
     +   ' '/
      DATA LPHI(1), LPHI(2), LPHI(3), LPHI(4), LPHI(5), LPHI(6),
     +   LPHI(7), LPHI(8) /'P','H','I',' ',' ',' ',' ',' '/
      DATA L1(1), L1(2), L1(3), L1(4), L1(5), L1(6), L1(7), L1(8) /'1',
     +   ' ',' ',' ',' ',' ',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
C
      IERR = 0
      HEAD = .TRUE.
C
      DO 10 I=1,20
         ERR(I) = .FALSE.
   10 CONTINUE
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR(1), LN)
C
      IF ((.NOT.OPTION(3))) GO TO 15
C
      CALL ERVII(NMSUB, LACV, ACOV, LAGMAX+1, -ABS(ACOV(1)),
     +   ABS(ACOV(1)), 0, HEAD, 4, NV, ERR(15), LACV1M, LACV1P)
C
      CALL EISII(NMSUB, LLGMX, LAGMAX, 1, N-1, 1, HEAD, ERR(2),
     +   L1, LNM1)
C
      IF (OPTION(2)) THEN
         CALL EISGE(NMSUB, LLACOV, LACOV, LAGMAX+1, 8, HEAD, ERR(3),
     +   LLGMX1)
      ELSE
         CALL EISGE(NMSUB, LLACOV, LACOV, LAGMAX+1, 7, HEAD, ERR(3),
     +   LLGMX1)
      END IF
C
   15 IF (OPTION(1) .AND. (.NOT.ERR(1)))
     +   CALL EISGE(NMSUB, LLYFFT, LYFFT, NFFT, 9, HEAD, ERR(4),
     +   LLYFFT)
C
      IF (OPTION(1) .AND. (.NOT.OPTION(4)))
     +   CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR(5), LLDS)
C
      IF (OPTION(4)) GO TO 30
C
      DO 20 I=1,15
         IF (ERR(I)) GO TO 50
   20 CONTINUE
C
      RETURN
C
   30 CONTINUE
C
      CALL EISII(NMSUB, LIAR, IAR, -IABS(LAGMAX), IABS(LAGMAX), 1, HEAD,
     +   ERR(6), LLGMXM, LLGMXP)
C
      CALL ERVII(NMSUB, LPHI, PHI, IAR, -1.0D0, 1.0D0, 0, HEAD, 1, NV,
     +   ERR(7), L1, L1)
C
      IF (.NOT.OPTION(3))
     +   CALL EISII(NMSUB, LLGMX, LAGMAX, 1, N-1, 1, HEAD, ERR(2),
     +   L1, LNM1)
C
      CALL EISII(NMSUB, LLAG, LAG, -IABS(LAGMAX), IABS(LAGMAX), 1, HEAD,
     +   ERR(8), LLGMXM, LLGMXP)
C
      CALL EISGE(NMSUB, LNF, NF, 1, 1, HEAD, ERR(9), LNF)
C
      IF (ERR(1) .OR. ERR(2) .OR. ERR(9)) GO TO 50
C
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR(14), LLDS)
C
      DO 40 I=1,15
         IF (ERR(I)) GO TO 50
   40 CONTINUE
C
      RETURN
C
   50 CONTINUE
      IERR = 1
      RETURN
C
      END
*UASEST
      SUBROUTINE UASEST (IAR, VAR, PHI, NF, FREQ, DELTA, SPCA, LPHI,
     +   ISPC)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE CALCULATES THE AUTOREGRESSIVE SPECTRUM.  IT IS
C        MODELED AFTER SUBROUTINE UASEC BY DICK JONES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,VAR
      INTEGER
     +   IAR,ISPC,LPHI,NF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),PHI(LPHI),SPCA(ISPC)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ARG,EI,ER,EXI,EXR,EXRTMP,PI,TI,TR
      INTEGER
     +   I,J
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
C
C  INTRINSIC FUNCTIONS
      INTRINSIC COS,SIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ARG
C        THE ARGUMENT FOR THE SINE AND COSINE FUNCTIONS USED IN
C        CALCULATIONS OF THE SPECTRUM.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION EI, ER, EXI, EXR, EXRTMP
C        'COMPLEX' VARIABLES USED IN THE COMPUTATIONS.
C     DOUBLE PRECISION FREQ(NF)
C        THE ARRAY CONTAINING THE FREQUENCIES AT WHICH THE SPECTRUM
C        IS TO BE COMPUTED.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER ISPC
C        THE LENGTH OF THE ARRAY SPCA.
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER LPHI
C        THE LENGTH OF THE ARRAY PHI.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        ESTIMATED.
C     DOUBLE PRECISION PHI(LPHI)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
C        SELECTED ORDER.
C     DOUBLE PRECISION PI
C        THE VALUE OF PI.
C     DOUBLE PRECISION SPCA(ISPC)
C        THE ARRAY IN WHICH THE AUTOREGRESSIVE SPECTRUM IS STORED.
C     DOUBLE PRECISION TI, TR
C        A VARIABLE USED IN THE COMPUTATIONS.
C     DOUBLE PRECISION VAR
C        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED ORDER (IAR).
C
      CALL GETPI(PI)
C
      DO 20 J=1,NF
         SPCA(J) = DELTA * VAR
         IF (IAR.GE.1) THEN
            IF (DELTA.EQ.1.0D0) THEN
               IF (FREQ(J).EQ.0.0D0) THEN
                  ER = 1.0D0
                  EI = 0.0D0
               ELSE IF (FREQ(J).EQ.0.25D0) THEN
                  ER = 0.0D0
                  EI = 1.0D0
               ELSE IF (FREQ(J).EQ.0.5D0) THEN
                  ER = -1.0D0
                  EI = 0.0D0
               ELSE
                  ARG = 2.0D0 * PI * DELTA * FREQ(J)
                  ER = COS(ARG)
                  EI = SIN(ARG)
               END IF
            ELSE
               ARG = 2.0D0 * PI * DELTA * FREQ(J)
               ER = COS(ARG)
               EI = SIN(ARG)
            END IF
            EXR = 1.0D0
            EXI = 0.0D0
            TR = 1.0D0
            TI = 0.0D0
            DO 10 I=1,IAR
               EXRTMP = EXR*ER - EXI*EI
               EXI = EXR*EI + EXI*ER
               EXR = EXRTMP
               TR = TR - PHI(I) * EXR
               TI = TI - PHI(I) * EXI
   10       CONTINUE
            SPCA(J) = SPCA(J)/(TR*TR + TI*TI)
         END IF
   20 CONTINUE
      RETURN
      END
*UASF
      SUBROUTINE UASF (YFFT, N, LYFFT, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
C     SPECTRUM ESTIMATION USING THE FFT (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,LYFFT,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YFFT(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,VAR,YMEAN
      INTEGER
     +   IAR,IFP,IPRT,LACOV,LAG,LAGMAX,LAIC,LDSMIN,LPCV,LPHI,LSPC,
     +   LWORK,NALL0,NF,NFFT,NPRT,WORK
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),AIC(101),FREQ(101),FTEST(2,100),PHI(100),RSTAK(12),
     +   SPCA(101),SPCF(101),XAXIS(207),YAXIS(207)
      INTEGER
     +   ISORT(101),ISTAK(12),ISYM(207)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACVFF,IPRINT,LDSCMP,PARZEN,SETESL,SETLAG,STKCLR,STKSET,
     +   UASDV,UASER
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (ISYM(1),ISORT(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(101)
C        THE AUTOCOVARIANCE COMPUTED FROM THE LAG PRODUCT PAIRS.
C     DOUBLE PRECISION AIC(101)
C        THE ARRAY CONTANING AKIAKES CRITERIA FOR EACH ORDER.
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
C        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(101)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        ESTIMATED.
C     DOUBLE PRECISION FTEST(2, 100)
C        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISORT(101)
C        AN ARRAY USED FOR SORTING.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER LSPC
C         THE LENGTH OF THE SPECTRUM ARRAYS.
C     INTEGER ISYM(207)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LACOV
C        THE LENGTH OF THE COVARIANCE ARRAYS.
C     INTEGER LAG
C        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAIC
C        THE LENGTH OF THE ARRAY AIC.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LPHI
C        THE LENGTH OF THE VECTOR PHI.
C     INTEGER LWORK
C        THE LENGTH OF THE WORK ARRAY.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
C        THIS ROUTINE WAS CALLED.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
C        ARE TO BE ESTIMATED.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE TYPE OF WINDOW TO BE USED.
C     DOUBLE PRECISION PHI(100)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
C        SELECTED ORDER.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION SPCA(101)
C        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
C     DOUBLE PRECISION SPCF(101)
C        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
C     DOUBLE PRECISION VAR
C        THE ONE STEP PREDICTION VARIANCE.
C     INTEGER WORK
C        THE STARTING LOCATION IN RSTAK FOR
C        THE WORK VECTOR.
C     DOUBLE PRECISION XAXIS(207)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YAXIS(207)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YFFT(LYFFT)
C        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'U',       'A',       'S',       'F',       ' ',       ' '/
C
      IFP = 4
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(1) = .TRUE.
      OPTION(2) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(4) = .FALSE.
C
      LAG = 0
      IAR = 0
      NF = 101
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = -1
C
C     SET THE MAXIMUM NUMBER OF LAGS TO BE USED.
C
      CALL SETLAG(N, LAGMAX)
C
C     SET LENGTH OF EXTENDED SERIES
C
      CALL SETESL(N+LAGMAX, 4, NFFT)
C
      CALL LDSCMP(1, 0, 0, 0, 0, 0, 'D', NFFT, LDSMIN)
C
      CALL UASER(NMSUB, N, ACOV, IAR, PHI, LAGMAX, LAG, LACOV,
     +   NF, LDSTAK, LDSMIN, LYFFT, NFFT, OPTION)
C
      IF (IERR.NE.0) THEN
         IERR = 1
         CALL IPRINT (IPRT)
         WRITE (IPRT, 1000)
         RETURN
      END IF
C
C     SET THE SIZE OF THE WORK AREA
C
      CALL STKSET(LDSTAK, 4)
C
C     SAVE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
C
      NALL0 = STKST(1)
C
C     SET VARIOUS PROGRAM PARAMETERS.
C
      LPCV = 207
      LSPC = 101
      LPHI = 100
      LAIC = 101
      LACOV = 101
      LWORK = NFFT
C
      ALPHA = 0.95D0
      DELTA = 1.0D0
C
C     SUBDIVIDE THE WORK AREA
C
      WORK = STKGET(LWORK, IFP)
C
C     COMPUTE AUTOCOVARIANCES
C
      CALL ACVFF (YFFT, N, NFFT, YMEAN, ACOV, LAGMAX, LACOV, LYFFT,
     +   RSTAK(WORK), LWORK)
C
C     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
C
      CALL UASDV(ACOV, SPCA, SPCF, LSPC, IAR, PHI, NF, FMIN, FMAX, FREQ,
     +   N, LAGMAX, FTEST, AIC, RSTAK(WORK), LACOV, LWORK, DELTA, ISORT,
     +   ISYM, XAXIS, YAXIS, LPCV, ALPHA, LAG, LAIC, LPHI, NPRT, VAR,
     +   PARZEN, NMSUB)
C
      CALL STKCLR(NALL0)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL UASF (YFFT, N, LYFFT, LDSTAK)')
      END
*UASFS
      SUBROUTINE UASFS (YFFT, N, LYFFT, LDSTAK, IAR, PHI, LAGMAX, LAG,
     +  NF, FMIN, FMAX, NPRT, SPCA, SPCF, FREQ)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
C     SPECTRUM ESTIMATION USING THE FFT (LONG CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   IAR,LAG,LAGMAX,LDSTAK,LYFFT,N,NF,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),PHI(*),SPCA(*),SPCF(*),YFFT(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMN,FMX,VAR,YMEAN
      INTEGER
     +   ACOV,AIC,FTEST,IA,IFP,IO,IPRT,ISORT,ISYM,LACOV,LAIC,
     +   LDSMIN,LPCV,LPHI,LSPC,LWORK,NALL0,NFFT,WORK,XAXIS,YAXIS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACVFF,AMEAN,IPRINT,LDSCMP,PARZEN,SETESL,STKCLR,STKSET,
     +   UASDV,UASER,UASVAR
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER ACOV
C        THE STARTING LOCATION IN RSTAK FOR THE ARRAY OF
C        THE AUTOCOVARIANCE ARRAY.
C     INTEGER AIC
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY CONTAINING THE AIC.
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
C        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
C     DOUBLE PRECISION FMN, FMX
C        THE MAXIMUM AND MINIMUM FREQUENCY ACTUALLY USED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        ESTIMATED.
C     INTEGER FTEST
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
C     INTEGER IA
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
C        BASED ON WHETHER OR NOT THE MODEL ORDER IS TO BE SELECTED OR
C        HAS BEEN PROVIDED.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
C        BASED ON PRINTED OUTPUT REQUESTED.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISORT
C        THE STARTING LOCATION IN ISTAK FOR
C        AN ARRAY USED FOR SORTING.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISYM
C        THE STARTING LOCATION IN ISTAK FOR
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LACOV
C        THE LENGTH OF THE COVARIANCE ARRAYS.
C     INTEGER LAG
C        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAIC
C        THE LENGTH OF THE ARRAY AIC.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LPHI
C        THE LENGTH OF THE VECTOR PHI.
C     INTEGER LSPC
C         THE LENGTH OF THE SPECTRUM ARRAYS.
C     INTEGER LWORK
C        THE ACTUAL LENGTH OF THE WORK ARRAY.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
C     INTEGER NALL0
C        THE NUMBER OF STACK ALLOCATIONS OUTSTANDING WHEN THIS ROUTINE
C        WAS CALLED.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
C        ARE TO BE ESTIMATED.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE TYPE OF WINDOW TO BE USED.
C     DOUBLE PRECISION PHI(LAGMAX)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
C        SELECTED ORDER.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION SPCA(NF)
C        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
C     DOUBLE PRECISION SPCF(NF)
C        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
C     DOUBLE PRECISION VAR
C        THE ONE STEP PREDICTION VARIANCE.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE STACK FOR
C        THE WORK ARRAY.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN RSTAK FOR
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN RSTAK FOR
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YFFT(LYFFT)
C        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'U',       'A',       'S',       'F',       'S',       ' '/
C
      IFP = 4
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(1) = .TRUE.
      OPTION(2) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(4) = .TRUE.
C
C     SET EXTENDED SERIES LENGTH
C
      CALL SETESL(N+LAGMAX, 4, NFFT)
C
      IO = 1
      IF (NPRT .EQ. 0) IO = 0
      IA = 1
      IF (IAR .NE. 0) IA = 0
C
      CALL LDSCMP(7, 0, IO*(2*NF+5), 0, 0, 0, 'D',
     +   LAGMAX+1+NFFT+IA*(3*LAGMAX+1)+IO*(4*NF+10), LDSMIN)
C
      CALL UASER(NMSUB, N, YFFT, IAR, PHI, LAGMAX, LAG, LACOV,
     +   NF, LDSTAK, LDSMIN, LYFFT, NFFT, OPTION)
C
    5 IF (IERR.NE.0) THEN
         IERR = 1
         CALL IPRINT (IPRT)
         WRITE (IPRT, 1000)
         RETURN
      END IF
C
C     SET SIZE OF WORK AREA.
C
      CALL STKSET (LDSTAK, 4)
C
C     SAVE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
C
      NALL0 = STKST(1)
C
C     SET VARIOUS PROGRAM PARAMETERS.
C
      LSPC = NF
      LPCV = 2*NF + 5
      LPHI = LAGMAX
      LACOV = LAGMAX + 1
      LWORK = NFFT
C
      FMN = MAX(FMIN, 0.0D0)
      FMX = MIN(FMAX, 0.5D0)
      IF (FMN.GE.FMX) THEN
        FMN = 0.0D0
        FMX = 0.5D0
      END IF
C
      ALPHA = 0.95D0
      DELTA = 1.0D0
C
      IF (IAR.GE.1) THEN
C
C     USER HAS CHOSEN ORDER AND SUPPLIED COEFFICIENTS.
C     COMPUTE RESIDUAL VARIANCE.
C
         CALL AMEAN(YFFT, N, YMEAN)
         CALL UASVAR (YFFT, YMEAN, N, IAR, PHI, VAR)
      END IF
C
C     COMPUTE AUTOCOVARIANCES
C
      ACOV = STKGET(LACOV, IFP)
      WORK = STKGET(LWORK, IFP)
C
      CALL ACVFF (YFFT, N, NFFT, YMEAN, RSTAK(ACOV), LAGMAX, LAGMAX+1,
     +   LYFFT, RSTAK(WORK), NFFT)
C
C     SET UP ADDITIONAL STACK WORK AREA, IF NEEDED.
C
      IF (IAR.EQ.0) THEN
         LAIC = LAGMAX+1
         AIC = STKGET(LAIC, IFP)
         FTEST = STKGET(2*LAGMAX, IFP)
      ELSE
         LAIC = LWORK
         AIC = WORK
         FTEST = WORK
      END IF
      IF (NPRT.NE.0) THEN
         XAXIS = STKGET(LPCV, IFP)
         YAXIS = STKGET(LPCV, IFP)
         ISYM = STKGET(LPCV, 2)
         ISORT = ISYM
      ELSE
         XAXIS = WORK
         YAXIS = WORK
         ISYM = WORK
         ISORT = WORK
      END IF
C
      IF (IERR.EQ.1) GO TO 5
C
C     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
C
      CALL UASDV(RSTAK(ACOV), SPCA, SPCF, LSPC, IAR, PHI, NF, FMN,
     +   FMX, FREQ, N, LAGMAX, RSTAK(FTEST), RSTAK(AIC), RSTAK(WORK),
     +   LACOV, LWORK, DELTA, ISTAK(ISORT), ISTAK(ISYM), RSTAK(XAXIS),
     +   RSTAK(YAXIS), LPCV, ALPHA, LAG, LAIC, LPHI, NPRT, VAR, PARZEN,
     +   NMSUB)
C
      CALL STKCLR(NALL0)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL UASFS (YFFT, N, LYFFT, LDSTAK,'/
     + '      +            IAR, PHI, LAGMAX, LAG, NF, FMIN, FMAX, NPRT'/
     + '      +            SPCA, SPCF, FREQ)')
      END
*UASORD
      SUBROUTINE UASORD (SPCF, SPCA, SPCFMN, SPCFMX, SPCAMN, SPCAMX,
     +   FREQ, NF, XAXIS, YAXIS, ISYM, NPTS, ISPC, LPCV, NSPCF, NSPCA,
     +   BW, ALOW, AUP, XPLTMN, XPLTMX, YPLTMN, YPLTMX, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRODUCES CO-ORDINATES FOR THE SPECTRUM PLOTS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALOW,AUP,BW,SPCAMN,SPCAMX,SPCFMN,SPCFMX,XPLTMN,XPLTMX,YPLTMN,
     +   YPLTMX
      INTEGER
     +   ISPC,LPCV,NF,NPRT,NPTS,NSPCA,NSPCF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),SPCA(ISPC),SPCF(ISPC),XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISYM(LPCV)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CILOW,CIMID,CIUP,YMAX
      INTEGER
     +   I,ISPCA,ISPCF
C
C  EXTERNAL SUBROUTINES
      EXTERNAL SPPLTC,SPPLTD,SPPLTL
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG10,MAX,MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALOW
C        THE FACTOR USED TO COMPUTE THE LOWER CONFIDENCE LIMITS.
C     DOUBLE PRECISION AUP
C        THE FACTOR USED TO COMPUTE THE UPPER CONFIDENCE LIMITS.
C     DOUBLE PRECISION BW
C        THE BANDWIDTH.
C     DOUBLE PRECISION CILOW, CIMID, CIUP
C        THE Y AXIS VALUES FOR THE LOWER, MID AND UPPER CONFIDENCE
C        INTERVAL POINTS.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        ESTIMATED.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER ISPC
C         THE LENGTH OF THE SPECTRUM ARRAYS.
C     INTEGER ISPCA, ISPCF
C        THE INDEX FOR THE FOURIER AND AUTOREGRESSIVE  ESTIMATES,
C        RESPECTIVELY.
C     INTEGER ISYM(LPCV)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
C        ARE TO BE ESTIMATED.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NPTS
C        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
C     INTEGER NSPCA, NSPCF
C        THE NUMBER OF VALID SPECTRUM ESTIMATES FOR THE AUTOREGRESSIVE
C        AND FOURIER SPECTRUMS, RESPECTIVELY.
C     DOUBLE PRECISION SPCA(ISPC)
C        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
C     DOUBLE PRECISION SPCAMN, SPCAMX
C        THE MINIMUM AND MAXIMUM AUTOREGRESSIVE SPECTRUM VALUE TO BE
C        PLOTTED.
C     DOUBLE PRECISION SPCF(ISPC)
C        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
C     DOUBLE PRECISION SPCFMN, SPCFMX
C        THE MINIMUM AND MAXIMUM FOURIER SPECTRUM VALUE TO BE PLOTTED.
C     DOUBLE PRECISION XAXIS(LPCV)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION XPLTMN, XPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
C     DOUBLE PRECISION YAXIS(LPCV)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YMAX
C        THE MAXIMUM  ACTUAL SPECTRUM VALUE (IN DECIBLES) TO BE PLOTTED.
C     DOUBLE PRECISION YPLTMN, YPLTMX
C        THE MINIMUM AND MAYIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
C
      ISPCF = 0
      ISPCA = NSPCF
C
      IF (NPRT.GE.1) GO TO 30
C
C     SET VARIOUS Y AXIS VALUES FOR DECIBLE PLOTS
C
      CALL SPPLTD (MIN(SPCFMN, SPCAMN), MAX(SPCFMX, SPCAMX),
     +   ALOW, AUP, YPLTMN, YPLTMX, CILOW, CIMID, CIUP, YMAX)
C
C     SET CO-ORDINATES FOR DECIBLE PLOTS
C
      DO 20 I = 1, NF
         IF (SPCF(I) .LT. SPCFMN) GO TO 10
         ISPCF = ISPCF + 1
         XAXIS(ISPCF) = FREQ(I)
         YAXIS(ISPCF) = 10.0D0 * LOG10(SPCF(I)) - YMAX
         ISYM(ISPCF) = 1
C
   10    IF (SPCA(I) .LT. SPCAMN) GO TO 20
         ISPCA = ISPCA + 1
         XAXIS(ISPCA) = FREQ(I)
         YAXIS(ISPCA) = 10.0D0 * LOG10(SPCA(I)) - YMAX
         ISYM(ISPCA) = 2
   20 CONTINUE
C
      GO TO 70
   30 CONTINUE
C
C     SET VARIOUS Y AXIS VALUES FOR LOG PLOTS
C
      CALL SPPLTL (MIN(SPCFMN, SPCAMN), MAX(SPCFMX, SPCAMX),
     +   ALOW, AUP, YPLTMN, YPLTMX, CILOW, CIMID, CIUP)
C
C     SET CO-ORDINATES FOR LOG PLOTS
C
      DO 60 I = 1, NF
         IF (SPCF(I) .LT. SPCFMN) GO TO 50
         ISPCF = ISPCF + 1
         XAXIS(ISPCF) = FREQ(I)
         YAXIS(ISPCF) = SPCF(I)
         ISYM(ISPCF) = 1
C
   50    IF (SPCA(I) .LT. SPCAMN) GO TO 60
         ISPCA = ISPCA + 1
         XAXIS(ISPCA) = FREQ(I)
         YAXIS(ISPCA) = SPCA(I)
         ISYM(ISPCA) = 2
   60 CONTINUE
C
   70 CONTINUE
C
      NPTS = NSPCA + NSPCF
C
C     SET CO-ORDINATES FOR BANDWIDTH AND CONFIDENCE INTERVAL.
C
      CALL SPPLTC (XAXIS, YAXIS, ISYM, NPTS, XPLTMN, XPLTMX, BW, CILOW,
     +   CIMID, CIUP, LPCV)
C
      RETURN
      END
*UASOUT
      SUBROUTINE UASOUT (XAXIS, YAXIS, ISYM, NPTS, BW, IDF, LAG,
     +   IAR, PHI, ISPCER, LPCV, XPLTMN, XPLTMX, YPLTMN, YPLTMX,
     +   FTEST, AIC, LAIC, VAR, NPRT, LAGMAX, AICPRT, N, NMSUB)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRODUCES THE SPECTRUM PLOTS FOR THE
C     AUTOREGRESSIVE SPECTRUM ESTIMATES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   BW,VAR,XPLTMN,XPLTMX,YPLTMN,YPLTMX
      INTEGER
     +   IAR,IDF,ISPCER,LAG,LAGMAX,LAIC,LPCV,N,NPRT,NPTS
      LOGICAL
     +   AICPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AIC(LAIC),FTEST(2,LAGMAX),PHI(LAGMAX),XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISYM(LPCV)
      CHARACTER
     +   NMSUB(6)*1
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XMN,XMX,YMN,YMX
      INTEGER
     +   ILOG,IPRT
      LOGICAL
     +   ERROR
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PRHO(1)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AOSLST,IPRINT,PPLMT,PPMN,VERSP
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AIC(LAIC)
C        THE ARRAY CONTANING AKIAKES CRITERIA FOR EACH ORDER.
C     LOGICAL AICPRT
C        AN INDICATOR VARIABLE USED TO DETERMINE IF THE AKIAKE
C        INFORMATION CRITERIA AND CHI SQUARED STATISTICS SHOULD
C        BE PRINTED.
C     DOUBLE PRECISION BW
C        THE BANDWIDTH.
C     LOGICAL ERROR
C        AN ERROR FLAG
C     DOUBLE PRECISION FTEST(2,LAGMAX)
C        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IDF
C        THE EFFECTIVE DEGREES OF FREEDOM.
C     INTEGER IPRT
C        THE LOGICAL UNIT NUMBER FOR THE OUTPUT.
C     INTEGER ISPCER
C        A VARIABLE USED TO DESIGNATE AN ERROR IN THE SPECTRAL
C        ESTIMATES.
C     INTEGER ISYM(LPCV)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LAG
C        THE LAG WINDOW TRUNCATION POINT USED FOR THE FOURIER SPECTRUM.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAIC
C        THE LENGTH OF THE ARRAY AIC.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE CALLING SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NPTS
C        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
C     DOUBLE PRECISION PHI(LAGMAX)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
C        ORDER.
C     DOUBLE PRECISION PRHO(1)
C        A DUMMY VARIABLE.
C     DOUBLE PRECISION VAR
C        THE ONE STEP PREDICTION VARIANCE FOR ORDER IAR.
C     DOUBLE PRECISION XAXIS(LPCV)
C        THE X AXIS VALUES FOR THE SPECTRAL PLOT.
C     DOUBLE PRECISION XMN, XMX
C     DOUBLE PRECISION XPLTMN, XPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
C     DOUBLE PRECISION YAXIS(LPCV)
C        THE Y AXIS VALUES FOR THE SPECTRAL PLOT.
C     DOUBLE PRECISION YMN, YMX
C        *
C     DOUBLE PRECISION YPLTMN, YPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
C
C     SET LOGICAL UNIT NUMBER FOR OUTPUT AND SET OUTPUT WIDTH.
C
      CALL IPRINT (IPRT)
C
      IF (.NOT. AICPRT) GO TO 5
C
C     PRINT AUTOREGRESSIVE MODEL ORDER SELECTION STATISTICS
C
      CALL VERSP(.TRUE.)
      WRITE(IPRT, 1007)
      CALL AOSLST (PRHO, AIC, FTEST, LAGMAX, LAIC, IAR, PHI, VAR,
     +   .FALSE., N)
      WRITE (IPRT, 1001)
C
    5 CONTINUE
      CALL VERSP(.TRUE.)
C
      WRITE(IPRT, 1002) LAG, BW, IDF
      WRITE(IPRT, 1000) IAR
      IF (ISPCER .EQ. 0) GO TO 10
      WRITE(IPRT, 1006)
      RETURN
C
   10 CONTINUE
      IF (NPRT.LE.0) THEN
        ILOG = 0
      ELSE
        ILOG = 1
      END IF
C
      CALL PPLMT(YAXIS, YAXIS, XAXIS, XAXIS, NPTS, 1, LPCV, YPLTMN,
     +  YPLTMX, YMN, YMX, XPLTMN, XPLTMX, XMN, XMX, ERROR, NMSUB,
     +  .FALSE.)
      IF (.NOT.ERROR)
     +   CALL PPMN (YAXIS, YAXIS, XAXIS, XAXIS, NPTS, 1, LPCV, 1, ISYM,
     +    LPCV, 0, -1, YMN, YMX, XMN, XMX, .FALSE., ILOG)
      IF (XPLTMN .NE. 0.0D0 .OR. XPLTMX .NE. 0.5D0) RETURN
      WRITE (IPRT, 1004)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (11H AND ORDER , I2, 28H AUTOREGRESSIVE SPECTRUM (.))
 1001 FORMAT ('1')
 1002 FORMAT (44H FOURIER SPECTRUM (+) (LAG WIND. TRUNC. PT.=, I5,
     +   1X, 5H/ BW=, F6.4, 1X, 6H/ EDF=, I6, ')')
 1004 FORMAT(5H+FREQ/
     +   7H PERIOD, 9X, 3HINF, 7X, 3H20., 7X, 3H10., 8X, 6H6.6667, 4X,
     +   2H5., 8X, 2H4., 8X, 6H3.3333, 4X, 6H2.8571, 4X, 3H2.5, 7X,
     +   6H2.2222, 4X, 2H2.)
C1005 FORMAT(5H+FREQ/
C    1   7H PERIOD, 9X, 3HINF, 7X, 3H10., 4X, 2H5., 8X, 6H3.3333, 4X,
C    2   3H2.5, 4X, 2H2.)
 1006 FORMAT(//
     +   56H ** THE PLOT HAS BEEN SUPRESSED BECAUSE FEWER THAN    **/
     +   56H ** FOUR VALID (POSITIVE) SPECTRAL ESTIMATES COULD BE **/
     +   56H ** COMPUTED.                                         **)
 1007 FORMAT (/42H AUTOREGRESSIVE ORDER SELECTION STATISTICS/)
      END
*UASS
      SUBROUTINE UASS (Y, N, IAR, PHI, LAGMAX, LAG, NF, FMIN, FMAX,
     +   NPRT, SPCA, SPCF, FREQ, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
C     SPECTRUM ESTIMATION (LONG CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   IAR,LAG,LAGMAX,LDSTAK,N,NF,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),PHI(*),SPCA(*),SPCF(*),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMN,FMX,VAR,YMEAN
      INTEGER
     +   ACOV,AIC,FTEST,IA,IFP,IO,IPRT,ISORT,ISYM,LACOV,LAIC,
     +   LDSMIN,LPCV,LPHI,LSPC,LWORK,NALL0,WORK,XAXIS,YAXIS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACVF,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UASDV,UASER,
     +   UASVAR
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER ACOV
C        THE STARTING LOCATION IN RSTAK FOR THE ARRAY OF
C        THE AUTOCOVARIANCE ARRAY.
C     INTEGER AIC
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY CONTAINING THE AIC.
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
C        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
C     DOUBLE PRECISION FMN, FMX
C        THE MAXIMUM AND MINIMUM FREQUENCY ACTUALLY USED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        ESTIMATED.
C     INTEGER FTEST
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
C     INTEGER IA
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
C        BASED ON WHETHER OR NOT THE MODEL ORDER IS TO BE SELECTED OR
C        HAS BEEN PROVIDED.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
C        BASED ON PRINTED OUTPUT REQUESTED.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISORT
C        THE STARTING LOCATION IN ISTAK FOR
C        AN ARRAY USED FOR SORTING.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISYM
C        THE STARTING LOCATION IN ISTAK FOR
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LACOV
C        THE LENGTH OF THE COVARIANCE ARRAYS.
C     INTEGER LAG
C        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAIC
C        THE LENGTH OF THE ARRAY AIC.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LPHI
C        THE LENGTH OF THE VECTOR PHI.
C     INTEGER LSPC
C         THE LENGTH OF THE SPECTRUM ARRAYS.
C     INTEGER LWORK
C        THE LENGTH OF THE WORK ARRAY.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
C     INTEGER NALL0
C        THE NUMBER OF STACK ALLOCATIONS OUTSTANDING WHEN THIS ROUTINE
C        WAS CALLED.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
C        ARE TO BE ESTIMATED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE TYPE OF WINDOW TO BE USED.
C     DOUBLE PRECISION PHI(LAGMAX)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
C        SELECTED ORDER.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION SPCA(NF)
C        THE ARRAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
C     DOUBLE PRECISION SPCF(NF)
C        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
C     DOUBLE PRECISION VAR
C        THE ONE STEP PREDICTION VARIANCE.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE STACK FOR
C        THE WORK ARRAY.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN RSTAK FOR
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN RSTAK FOR
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'U',       'A',       'S',       'S',       ' ',       ' '/
C
      IFP = 4
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(4) = .TRUE.
C
      IO = 1
      IF (NPRT .EQ. 0) IO = 0
      IA = 1
      IF (IAR .NE. 0) IA = 0
C
      CALL LDSCMP(7, 0, IO*(2*NF+5), 0, 0, 0, 'D',
     +   2*LAGMAX+2+IA*(3*LAGMAX+1)+IO*(4*NF+10), LDSMIN)
C
C     CALL ERROR CHECKING ROUTINE
C
      CALL UASER(NMSUB, N, Y, IAR, PHI, LAGMAX, LAG, LACOV,
     +   NF, LDSTAK, LDSMIN, N, N, OPTION)
C
   10 IF (IERR.NE.0) THEN
         IERR = 1
         CALL IPRINT (IPRT)
         WRITE (IPRT, 1000)
         RETURN
      END IF
C
C     SET SIZE OF WORK AREA.
C
      CALL STKSET (LDSTAK, 4)
C
C     SAVE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
C
      NALL0 = STKST(1)
C
C     SET VARIOUS PROGRAM PARAMETERS.
C
      LSPC = NF
      LPCV = 2*NF + 5
      LPHI = LAGMAX
      LACOV = LAGMAX + 1
      LWORK = LAGMAX+1
C
      FMN = MAX(FMIN, 0.0D0)
      FMX = MIN(FMAX, 0.5D0)
      IF (FMN.GE.FMX) THEN
        FMN = 0.0D0
        FMX = 0.5D0
      END IF
C
      ALPHA = 0.95D0
      DELTA = 1.0D0
C
C     COMPUTE AUTOCOVARIANCES
C
      ACOV = STKGET(LACOV, IFP)
C
      CALL ACVF (Y, N, YMEAN, RSTAK(ACOV), LAGMAX, LACOV)
C
      IF (IAR.GE.1) THEN
C
C     USER HAS CHOSEN ORDER AND SUPPLIED COEFFICIENTS.
C     COMPUTE RESIDUAL VARIANCE.
C
         CALL UASVAR (Y, YMEAN, N, IAR, PHI, VAR)
      END IF
C
C     SET UP ADDITIONAL STACK WORK AREA, IF NEEDED.
C
      WORK = STKGET(LWORK, IFP)
C
      IF (IAR.EQ.0) THEN
         LAIC = LAGMAX+1
         AIC = STKGET(LAIC, IFP)
         FTEST = STKGET(2*LAGMAX, IFP)
      ELSE
         LAIC = LWORK
         AIC = WORK
         FTEST = WORK
      END IF
      IF (NPRT.EQ.0) THEN
         XAXIS = WORK
         YAXIS = WORK
         ISYM = WORK
         ISORT = WORK
      ELSE
         XAXIS = STKGET(LPCV, IFP)
         YAXIS = STKGET(LPCV, IFP)
         ISYM = STKGET(LPCV, 2)
         ISORT = ISYM
      END IF
C
      IF (IERR.EQ.1) GO TO 10
C
C     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
C
      CALL UASDV(RSTAK(ACOV), SPCA, SPCF, LSPC, IAR, PHI, NF, FMN,
     +   FMX, FREQ, N, LAGMAX, RSTAK(FTEST), RSTAK(AIC), RSTAK(WORK),
     +   LACOV, LWORK, DELTA, ISTAK(ISORT), ISTAK(ISYM), RSTAK(XAXIS),
     +   RSTAK(YAXIS), LPCV, ALPHA, LAG, LAIC, LPHI, NPRT, VAR, PARZEN,
     +   NMSUB)
C
      CALL STKCLR(NALL0)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL UASS (Y, N,'/
     + '      +           IAR, PHI, LAGMAX, LAG, NF, FMIN, FMAX, NPRT,'/
     + '      +           SPCA, SPCF, FREQ, LDSTAK)')
      END
*UASV
      SUBROUTINE UASV (ACOV, LAGMAX, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
C     SPECTRUM ESTIMATION WHEN THE ACVF HAVE PREVIOUSLY BEEN
C     COMPUTED AND STORED (SHORT CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LAGMAX,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,VAR
      INTEGER
     +   IAR,IPRT,LACOV,LAG,LAIC,LDSMIN,LDSTAK,LPCV,LPHI,LSPC,
     +   LWORK,NF,NPRT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AIC(101),FREQ(101),FTEST(2,100),PHI(100),SPCA(101),SPCF(101),
     +   WORK(101),XAXIS(207),YAXIS(207)
      INTEGER
     +   ISORT(101),ISYM(207)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PARZEN,UASDV,UASER
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LAGMAX+1)
C        THE AUTOCOVARIANCE COMPUTED FROM THE LAG PRODUCT PAIRS.
C     DOUBLE PRECISION AIC(101)
C        THE ARRAY CONTANING AKIAKES CRITERIA FOR EACH ORDER.
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
C        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(101)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        ESTIMATED.
C     DOUBLE PRECISION FTEST(2, 100)
C        THE ARRAY CONTAINING THE F RATIO AND F TEST.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISORT(101)
C        AN ARRAY USED FOR SORTING.
C     INTEGER ISYM(207)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LACOV
C        THE LENGTH OF THE COVARIANCE ARRAYS.
C     INTEGER LAG
C        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAIC
C        THE LENGTH OF THE ARRAY AIC.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LPHI
C        THE LENGTH OF THE VECTOR PHI.
C     INTEGER LSPC
C         THE LENGTH OF THE SPECTRUM ARRAYS.
C     INTEGER LWORK
C        THE LENGTH OF THE WORK ARRAY.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
C        ARE TO BE ESTIMATED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE TYPE OF WINDOW TO BE USED.
C     DOUBLE PRECISION PHI(100)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
C        SELECTED ORDER.
C     DOUBLE PRECISION SPCA(101)
C        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
C     DOUBLE PRECISION SPCF(101)
C        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
C     DOUBLE PRECISION VAR
C        THE ONE STEP PREDICTION VARIANCE.
C     DOUBLE PRECISION WORK(101)
C        A WORK AREA USED FOR THE LAG WINDOWS AND FOR
C        COMPUTING THE AUTOREGRESSIVE COEFFICIENTS.
C     DOUBLE PRECISION XAXIS(207)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YAXIS(207)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'U',       'A',       'S',       'V',       ' ',       ' '/
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .TRUE.
      OPTION(4) = .FALSE.
C
      LAG = 0
      IAR = 0
      NF = 101
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = -1
      LACOV = LAGMAX+1
      LDSTAK = 0
      LDSMIN = 0
C
C     CALL ERROR CHECKING ROUTINE
C
      CALL UASER(NMSUB, N, ACOV, IAR, PHI, LAGMAX, LAG, LACOV,
     +   NF, LDSTAK, LDSMIN, N, N, OPTION)
C
      IF (IERR.NE.0) THEN
         IERR = 1
         CALL IPRINT (IPRT)
         WRITE (IPRT, 1000)
         RETURN
      END IF
C
C     SET VARIOUS PROGRAM PARAMETERS
C
      LPCV = 207
      LAIC = 101
      LSPC = 101
      LPHI = 100
      LWORK = 101
C
      ALPHA = 0.95D0
      DELTA = 1.0D0
C
C     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
C
      CALL UASDV(ACOV, SPCA, SPCF, LSPC, IAR, PHI, NF, FMIN, FMAX, FREQ,
     +   N, LAGMAX, FTEST, AIC, WORK, LACOV, LWORK, DELTA, ISORT,
     +   ISYM, XAXIS, YAXIS, LPCV, ALPHA, LAG, LAIC, LPHI, NPRT, VAR,
     +   PARZEN, NMSUB)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL UASV (ACOV, LAGMAX, N)')
      END
*UASVAR
      SUBROUTINE UASVAR (Y, YMEAN, N, IAR, PHI, VAR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE VARIANCE FOR A GIVEN SERIES
C     AND AUTOREGRESSIVE MODEL.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VAR,YMEAN
      INTEGER
     +   IAR,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PHI(IAR),Y(N)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RES,RSS
      INTEGER
     +   I,IAR1,J,K
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IAR1
C        THE VALUE IAR + 1.
C     INTEGER J, K
C        INDEX VALUES.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     DOUBLE PRECISION PHI(IAR)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
C        SELECTED ORDER.
C     DOUBLE PRECISION RES
C        *
C     DOUBLE PRECISION RSS
C        THE ONE STEP PREDICTION RESIDUAL SUM OF SQUARES.
C     DOUBLE PRECISION VAR
C        THE ONE STEP PREDICTION VARIANCE.
C     DOUBLE PRECISION Y(N)
C         THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C
      RSS = 0.0D0
      IAR1 = IAR+1
      DO 20 I = IAR1, N
         RES = Y(I) - YMEAN
         DO 10 J = 1, IAR
            K = I-J
            RES = RES - PHI(J) * (Y(K)-YMEAN)
   10    CONTINUE
         RSS = RSS + RES*RES
   20 CONTINUE
C
      VAR = RSS / (N-IAR1)
C
      RETURN
C
      END
*UASVS
      SUBROUTINE UASVS (ACOV, LAGMAX, Y, N, IAR, PHI, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
C     SPECTRUM ESTIMATION WHEN THE ACVF HAVE PREVIOUSLY BEEN
C     COMPUTED AND STORED (LONG CALL).
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   IAR,LAG,LAGMAX,LDSTAK,N,NF,NPRT
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),FREQ(*),PHI(*),SPCA(*),SPCF(*),Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMN,FMX,VAR,YMEAN
      INTEGER
     +   AIC,FTEST,IA,IFP,IO,IPRT,ISORT,ISYM,LACOV,LAIC,LDSMIN,
     +   LPCV,LPHI,LSPC,LWORK,NALL0,WORK,XAXIS,YAXIS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UASDV,UASER,
     +   UASVAR
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LAGMAX+1)
C        THE ARRAY OF AUTOCOVARIANCE ESTIMATES.
C     INTEGER AIC
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY CONTAINING THE AIC.
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
C        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
C     DOUBLE PRECISION FMN, FMX
C        THE MAXIMUM AND MINIMUM FREQUENCY ACTUALLY USED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        ESTIMATED.
C     INTEGER FTEST
C        THE STARTING LOCATION IN THE STACK FOR
C        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
C     INTEGER IA
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
C        BASED ON WHETHER OR NOT THE MODEL ORDER IS TO BE SELECTED OR
C        HAS BEEN PROVIDED.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
C        BASED ON PRINTED OUTPUT REQUESTED.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISORT
C        THE STARTING LOCATION IN ISTAK FOR
C        AN ARRAY USED FOR SORTING.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISYM
C        THE STARTING LOCATION IN ISTAK FOR
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LACOV
C        THE LENGTH OF THE COVARIANCE ARRAYS.
C     INTEGER LAG
C        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAIC
C        THE LENGTH OF THE ARRAY AIC.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPCV
C        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
C     INTEGER LPHI
C        THE LENGTH OF THE VECTOR PHI.
C     INTEGER LSPC
C         THE LENGTH OF THE SPECTRUM ARRAYS.
C     INTEGER LWORK
C        THE ACTUAL LENGTH OF THE WORK ARRAY.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
C     INTEGER NALL0
C        THE NUMBER OF STACK ALLOCATIONS OUTSTANDING WHEN THIS ROUTINE
C        WAS CALLED.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
C        ARE TO BE ESTIMATED.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE TYPE OF WINDOW TO BE USED.
C     DOUBLE PRECISION PHI(LAGMAX)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
C        SELECTED ORDER.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION SPCA(NF)
C        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
C     DOUBLE PRECISION SPCF(NF)
C        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
C     DOUBLE PRECISION VAR
C        THE ONE STEP PREDICTION VARIANCE.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE STACK FOR
C        THE WORK ARRAY.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN RSTAK FOR
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN RSTAK FOR
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'U',       'A',       'S',       'V',       'S',       ' '/
C
      IFP = 4
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .TRUE.
      OPTION(4) = .TRUE.
C
      LACOV = LAGMAX+1
C
      IO = 1
      IF (NPRT .EQ. 0) IO = 0
      IA = 1
      IF (IAR .NE. 0) IA = 0
C
      CALL LDSCMP(6, 0, IO*(2*NF+5), 0, 0, 0, 'D',
     +   LAGMAX + 1 + IA*(3*LAGMAX+1) + IO*(4*NF+10), LDSMIN)
C
C     CALL ERROR CHECKING ROUTINE
C
      CALL UASER(NMSUB, N, ACOV, IAR, PHI, LAGMAX, LAG, LACOV,
     +   NF, LDSTAK, LDSMIN, N, N, OPTION)
C
    5 IF (IERR.NE.0) THEN
         IERR = 1
         CALL IPRINT (IPRT)
         WRITE (IPRT, 1000)
         RETURN
      END IF
C
C     SET SIZE OF WORK AREA.
C
      CALL STKSET (LDSTAK, 4)
C
C     SAVE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
C
      NALL0 = STKST(1)
C
C     SET VARIOUS PROGRAM PARAMETERS.
C
      LSPC = NF
      LPCV = 2*NF + 5
      LPHI = LAGMAX
      LWORK = LAGMAX+1
C
      FMN = MAX(FMIN, 0.0D0)
      FMX = MIN(FMAX, 0.5D0)
      IF (FMN.GE.FMX) THEN
        FMN = 0.0D0
        FMX = 0.5D0
      END IF
C
      ALPHA = 0.95D0
      DELTA = 1.0D0
C
      IF (IAR.GE.1) THEN
C
C     USER HAS CHOSEN ORDER AND SUPPLIED COEFFICIENTS.
C     COMPUTE RESIDUAL VARIANCE.
C
         CALL AMEAN (Y, N, YMEAN)
         CALL UASVAR (Y, YMEAN, N, IAR, PHI, VAR)
      END IF
C
C     SET UP ADDITIONAL STACK WORK AREA, IF NEEDED.
C
      WORK = STKGET(LWORK,IFP)
      IF (IAR.EQ.0) THEN
         LAIC = LAGMAX+1
         AIC = STKGET(LAIC, IFP)
         FTEST = STKGET(2*LAGMAX, IFP)
      ELSE
         LAIC = LWORK
         AIC = WORK
         FTEST = WORK
      END IF
      IF (NPRT.EQ.0) THEN
         XAXIS = WORK
         YAXIS = WORK
         ISYM = WORK
         ISORT = WORK
      ELSE
         XAXIS = STKGET(LPCV, IFP)
         YAXIS = STKGET(LPCV, IFP)
         ISYM = STKGET(LPCV, 2)
         ISORT = ISYM
      END IF
C
      IF (IERR.EQ.1) GO TO 5
C
C     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
C
      CALL UASDV(ACOV, SPCA, SPCF, LSPC, IAR, PHI, NF, FMN,
     +   FMX, FREQ, N, LAGMAX, RSTAK(FTEST), RSTAK(AIC), RSTAK(WORK),
     +   LACOV, LWORK, DELTA, ISTAK(ISORT), ISTAK(ISYM), RSTAK(XAXIS),
     +   RSTAK(YAXIS), LPCV, ALPHA, LAG, LAIC, LPHI, NPRT, VAR, PARZEN,
     +   NMSUB)
C
      CALL STKCLR(NALL0)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL UASVS (ACOV, LAGMAX, Y, N,'/
     +  '      +            IAR, PHI, LAG, NF, FMIN, FMAX, NPRT,'/
     +  '      +            SPCA, SPCF, FREQ, LDSTAK)')
      END
*UFS
      SUBROUTINE UFS(Y, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
C     SPECTRUM ANALYSIS (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS
      INTEGER
     +   IPRT,ISPCF,LACOV,LAGMAX,LDSMIN,LDSTAK,LNLPPA,LPCV,LWORK,
     +   LY,NF,NPRT,NW
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),FREQ(101),SPCF(101,4),WORK(101),XAXIS(106),
     +   YAXIS(106)
      INTEGER
     +   ISORT(101),ISYM(106),LAGS(4),NLPPA(1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PARZEN,SETLAG,UFSDRV
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(101)
C        THE AUTOCOVARIANCE AT LAG ZERO (BIASED VARIANCE).
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(101)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISORT(101)
C        AN ARRAY USED FOR SORTING.
C     INTEGER ISPCF
C         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
C     INTEGER ISYM(106)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGS(4)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LNLPPA
C        THE LENGTH OF THE VECTOR NLPPA.
C     INTEGER LPCV
C        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LY
C        THE LENGTH OF THE VECTOR Y.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPA(1)
C        A DUMMY ARRAY WHEN THE SERIES DOES NOT CONTAIN MISSING VALUES.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION SPCF(101,4)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     DOUBLE PRECISION WORK(101)
C        THE VECTOR OF LAG WINDOWS.
C     DOUBLE PRECISION XAXIS(106)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION Y(N)
C         THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YAXIS(106)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YMISS
C        A DUMMY VARIABLE WHEN THE SERIES DO NOT CONTAIN MISSING VALUES
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S',' ',' ',' '/
C
C     SET UP
C
      OPTION(4) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(1) = .FALSE.
C
      LDSTAK = 0
      LDSMIN = 0
C
      ISPCF = 101
      LACOV = 101
      LNLPPA = 1
      LY = N
      LPCV = 106
      LWORK = 101
      NF = 101
      YMISS = 1.0D0
C
C     SET MAXIMUM LAG VALUE TO BE USED.
C     AND NUMBER OF LAG WINDOW TRUNCATION POINTS TO USE.
C
      CALL SETLAG(N, LAGMAX)
      NW = 4
C
C     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
C     FOR SERIES WITH MISSING DATA.
C
      CALL UFSDRV(Y, LY, YMISS, ACOV, NLPPA, SPCF, ISPCF, NF, FMIN,
     +   FMAX, FREQ, N, NW, LAGMAX, LAGS, WORK, LACOV, LWORK, DELTA,
     +   ISORT, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, PARZEN, NMSUB,
     +   LDSMIN, LDSTAK, OPTION, LNLPPA, LY)
C
C     CHECK FOR ERRORS
C
      IF (IERR.EQ.0) RETURN
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL UFS (Y, N)')
      END
*UFSDRV
      SUBROUTINE UFSDRV(Y, LY, YMISS, ACOV, NLPPA, SPCF, ISPCF, NF,
     +   FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS, WORK, LACOV, LWORK,
     +   DELTA, ISORT, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, WINDOW,
     +   NMSUB, LDSMIN, LDSTAK, OPTION, LNLPPA, NFFT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE CONTROLING ROUTINE FOR TIME SERIES FOURIER
C     SPECTRUM ANALYSIS .
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS
      INTEGER
     +   ISPCF,LACOV,LAGMAX,LDSMIN,LDSTAK,LNLPPA,LPCV,LWORK,LY,N,
     +   NF,NFFT,NPRT,NW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),FREQ(*),SPCF(*),WORK(*),XAXIS(*),Y(*),YAXIS(*)
      INTEGER
     +   ISORT(*),ISYM(*),LAGS(*),NLPPA(*)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL WINDOW
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALOW,AUP,BW,DF,FMN,FMX,SPCFMN,SPCFMX,XPLTMN,XPLTMX,YMEAN,
     +   YPLTMN,YPLTMX
      INTEGER
     +   I,ILOG,ISPCER,LAG,LAGLST,NFUSED,NPTS,NSPC,NWUSED
      LOGICAL
     +   NEWPG,UNIVAR
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   LSTLAG
      EXTERNAL LSTLAG
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACVF,ACVFF,ACVFM,SETFRQ,SPCCK,UFSER,UFSLAG,UFSMN,UFSOUT,
     +   UFSPCV
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN,NINT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV)
C        THE AUTOCOVARIANCE.
C     DOUBLE PRECISION ALOW
C        A FACTOR USED TO COMPUTE THE LOWER CONFIDENCE LIMITS.
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION AUP
C        A FACTOR USED TO COMPUTE THE UPPER CONFIDENCE LIMITS.
C     DOUBLE PRECISION BW
C        THE BANDWIDTH.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DF
C        THE EFFECTIVE DEGREES OF FREEDOM.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FMN, FMX
C        THE MAXIMUM AND MINIMUM FREQUENCES ACTUALLY USED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER ILOG
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        ILOG = 0 THE PLOT IS LINEAR/LINEAR, IF
C        ILOG = 1 THE PLOT IS LOG/LINEAR, IF
C        ILOG = 2 THE PLOT IS LINEAR/LOG, AND IF
C        ILOG = 3 THE PLOT IS LOG/LOG.
C     INTEGER ISORT(NF)
C        THE VECTOR USED FOR SORTING.
C     INTEGER ISPCER
C        AN ERROR FLAG USED FOR THE SPECTRUM PLOTS.
C     INTEGER ISPCF
C         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
C     INTEGER ISYM(LPCV)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAG
C        THE LAG WINDWO TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
C     INTEGER LAGLST
C        THE LAST LAG BEFORE MISSING DATA CAUSED AN ACVF
C        TO BE UNABLE TO BE COMPUTED.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGS(NW)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LNLPPA
C        THE LENGTH OF THE VECTOR NLPPA.
C     INTEGER LPCV
C        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LY
C        THE LENGTH OF THE VECTOR Y.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     LOGICAL NEWPG
C        THE LOGICAL VARIABLE USED TO DETERMINE IF OUTPUT
C        WILL BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     INTEGER NFUSED
C        THE NUMBER OF FREQUENCIES ACTUALLY USED.
C     INTEGER NLPPA(LNLPPA)
C        THE ARRAY CONTAINING THE NUMBER OF LAG PRODUCT PAIRS.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NPTS
C        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
C     INTEGER NSPC
C        THE NUMBER OF VALID (POSITIVE) SPECTRUM VALUES.
C     INTEGER NW
C        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     INTEGER NWUSED
C        THE NUMBER OF DIFFERENT BANDWIDTHS ACTUALLY USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     DOUBLE PRECISION SPCF(ISPCF,NW)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     DOUBLE PRECISION SPCFMN, SPCFMX
C        THE MINIMUM AND MAXIMUM SPECTRUM VALUE TO BE PLOTTED.
C     LOGICAL UNIVAR
C        THE LOGICAL VARIABLE USED TO DETERMINE IF THE OUTPUT
C        IS FOR UNIVARIATE (TRUE) OR BIVARIATE (FALSE) SPECTRA.
C     EXTERNAL WINDOW
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION WORK(LWORK)
C        THE VECTOR OF LAG WINDOWS.
C     DOUBLE PRECISION XAXIS(LPCV)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION XPLTMN, XPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
C     DOUBLE PRECISION Y(LY)
C        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YAXIS(LPCV)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YMISS
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
C        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
C        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
C     DOUBLE PRECISION YPLTMN, YPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
C
      NFUSED = NF
      IF (OPTION(4)) THEN
        FMN = MAX(FMIN, 0.0D0)
        FMX = MIN(FMAX, 0.5D0)
        IF (FMN.GE.FMX) THEN
          FMN = 0.0D0
          FMX = 0.5D0
        END IF
      ELSE
C
C       SET VARIOUS VALUES FOR SHORT FORMS OF CALL STATEMENT
C
        NPRT = -1
        FMN = 0.0D0
        FMX = 0.5D0
      END IF
C
C     CHECK FOR ERRORS
C
      CALL UFSER(NMSUB, N, LAGMAX, LACOV, NFUSED, ISPCF, NW, LAGS,
     +  LDSTAK, LDSMIN, LY, NFFT, OPTION)
C
      IF (IERR.EQ.1) RETURN
C
C     SET VARIOUS PROGRAM PARAMETERS.
C
      ALPHA = 0.95D0
      DELTA = 1.0D0
C
C     COMPUTE COVARIANCES
C
      LAGLST = LAGMAX
      IF (OPTION(1)) THEN
        CALL ACVFF(Y, N, NFFT, YMEAN, ACOV, LAGMAX, LACOV,
     +   LY, WORK, NFFT)
      ELSE
        IF (.NOT.OPTION(3)) THEN
          IF (OPTION(2)) THEN
            CALL ACVFM(Y, YMISS, N, YMEAN, ACOV, LAGMAX, LAGLST,
     +        NLPPA, LACOV)
          ELSE
            CALL ACVF(Y, N, YMEAN, ACOV, LAGMAX, LACOV)
          END IF
        END IF
      END IF
      IF (OPTION(2) .AND. OPTION(3)) LAGLST = LSTLAG(NLPPA,LAGMAX,LACOV)
C
      IF (LAGLST.GE.1) GO TO 20
C
C     AN ERROR HAS BEEN DETECTED
C
      IERR = 2
      RETURN
C
   20 CONTINUE
C
C     COMPUTE THE VECTOR OF LAG WINDOW TRUNCATION POINTS, ORDERED
C     SMALLEST TO LARGEST.
C
      NWUSED = NW
      IF (.NOT.OPTION(4)) CALL UFSLAG(ACOV, LAGLST, LAGS, N, NW,
     +   NWUSED, LACOV)
C
C     BEGIN COMPUTING FOURIER SPECTRUM FOR SERIES
C
      UNIVAR = .TRUE.
C
      IF (NPRT.GE.1) THEN
        ILOG = 1
      ELSE
        ILOG = 0
      END IF
C
      XPLTMN = FMN
      XPLTMX = FMX
C
C     SET FREQUENCIES FOR THE SPECTRUM.
C
      CALL SETFRQ(FREQ, NFUSED, 2, FMN, FMX, DELTA)
C
C     COMPUTE AND PLOT SPECTRUM VALUES.
C
      NEWPG = .FALSE.
C
      DO 50 I=1,NWUSED
         LAG = LAGS(I)
         ISPCER = 0
         IF (LAG.LE.LAGLST) GO TO 30
         ISPCER = 2
         DF = 0.0D0
         GO TO 40
C
   30    CALL UFSMN(ACOV, NLPPA, LAG, DF, NFUSED, FREQ, ALPHA, BW,
     +              SPCF(1+(I-1)*ISPCF), ALOW, AUP, LACOV, ISPCF,
     +              WINDOW, WORK, LAG, N, DELTA, OPTION(2), LNLPPA)
C
         IF (NPRT.EQ.0) GO TO 50
C
         ISPCER = 0
         CALL SPCCK(SPCF(1+(I-1)*ISPCF), ISORT, NFUSED,
     +              SPCFMN, SPCFMX, NSPC, ISPCER)
C
         IF (ISPCER.NE.0) GO TO 40
C
         CALL UFSPCV(SPCF(1+(I-1)*ISPCF), SPCFMN, SPCFMX,
     +               FREQ, NFUSED, XAXIS, YAXIS, ISYM, NPTS, ISPCF,
     +               NFUSED+5, NSPC, BW, ALOW, AUP,
     +               XPLTMN, XPLTMX, YPLTMN, YPLTMX, NPRT)
C
   40    CALL UFSOUT(XAXIS, YAXIS, ISYM, NPTS, BW, NINT(DF), LAG,
     +      LAGLST, NEWPG, ISPCER, NFUSED+5, XPLTMN, XPLTMX, YPLTMN,
     +      YPLTMX, ILOG, YAXIS, XAXIS, NPTS, UNIVAR, NMSUB)
C
         NEWPG = .TRUE.
C
   50 CONTINUE
C
      RETURN
C
      END
*UFSER
      SUBROUTINE UFSER(NMSUB, N, LAGMAX, LACOV, NF, ISPCF, NW,
     +    LAGS, LDSTAK, LDSMIN, LYFFT, NFFT, OPTION)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE ERROR CHECKING ROUTINE FOR THE TIME SERIES
C     FOURIER UNIVARIATE SPECTRUM ANALYSIS ROUTINES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 10, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ISPCF,LACOV,LAGMAX,LDSMIN,LDSTAK,LYFFT,N,NF,NFFT,NW
C
C  ARRAY ARGUMENTS
      INTEGER
     +   LAGS(*)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I,NV
      LOGICAL
     +   HEAD
C
C  LOCAL ARRAYS
      LOGICAL
     +   ERR(15)
      CHARACTER
     +   L1(8)*1,LISPCF(8)*1,LLACOV(8)*1,LLAGMX(8)*1,LLAGS(8)*1,
     +   LLDS(8)*1,LLGMX1(8)*1,LLYFFT(8)*1,LN(8)*1,LNF(8)*1,
     +   LNM1(8)*1,LNW(8)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,EIVII
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR(15)
C        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF ERR01, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER ISPCF
C         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGS(NW)
C        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     CHARACTER*1 LISPCF(8), LLACOV(8), LLAGMX(8),
C    *   LLAGS(8), LLGMX1(8), LLDS(8), LN(8), LNF(8), LNM1(8),
C    *   LNW(8), LLYFFT(8), L1(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF THE ARGUMENT(S)
C        CHECKED FOR ERRORS.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THE USER CALLED SUBROUTINE.
C     INTEGER NV
C        THE NUMBER OF VIOLATIONS FOUND WHEN CHECKING VECTOR LAGS.
C     INTEGER NW
C        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C
C     SET UP NAME ARRAYS
C
      DATA LISPCF(1), LISPCF(2), LISPCF(3), LISPCF(4), LISPCF(5),
     +   LISPCF(6), LISPCF(7), LISPCF(8) /'I','S','P','C','F',' ',' ',
     +   ' '/
      DATA LLACOV(1), LLACOV(2), LLACOV(3), LLACOV(4), LLACOV(5),
     +   LLACOV(6), LLACOV(7), LLACOV(8) /'L','A','C','O','V',' ',' ',
     +   ' '/
      DATA LLAGMX(1), LLAGMX(2), LLAGMX(3), LLAGMX(4), LLAGMX(5),
     +   LLAGMX(6), LLAGMX(7), LLAGMX(8) /'L','A','G','M','A','X',' ',
     +   ' '/
      DATA LLAGS(1), LLAGS(2), LLAGS(3), LLAGS(4), LLAGS(5), LLAGS(6),
     +   LLAGS(7), LLAGS(8) /'L','A','G','S',' ',' ',' ',' '/
      DATA LLGMX1(1), LLGMX1(2), LLGMX1(3), LLGMX1(4), LLGMX1(5),
     +   LLGMX1(6), LLGMX1(7), LLGMX1(8) /'L','A','G','M','A','X','+',
     +   '1'/
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +   LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8) /'N',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LNF(1), LNF(2), LNF(3), LNF(4), LNF(5), LNF(6), LNF(7),
     +   LNF(8) /'N','F',' ',' ',' ',' ',' ',' '/
      DATA LNM1(1), LNM1(2), LNM1(3), LNM1(4), LNM1(5), LNM1(6),
     +   LNM1(7), LNM1(8) /'N','-','1',' ',' ',' ',' ',' '/
      DATA LNW(1), LNW(2), LNW(3), LNW(4), LNW(5), LNW(6), LNW(7),
     +   LNW(8) /'N','W',' ',' ',' ',' ',' ',' '/
      DATA LLYFFT(1), LLYFFT(2), LLYFFT(3), LLYFFT(4), LLYFFT(5),
     +   LLYFFT(6), LLYFFT(7), LLYFFT(8) /'L','Y','F','F','T',' ',' ',
     +   ' '/
      DATA L1(1), L1(2), L1(3), L1(4), L1(5), L1(6), L1(7), L1(8) /'1',
     +   ' ',' ',' ',' ',' ',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
C
      DO 10 I=1,15
         ERR(I) = .FALSE.
   10 CONTINUE
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR(1), LN)
C
      IF (OPTION(4)) THEN
        CALL EISGE(NMSUB, LNF, NF, 1, 1, HEAD, ERR(6), LNF)
        IF (.NOT.ERR(6))
     +     CALL EISGE(NMSUB, LISPCF, ISPCF, NF, 3, HEAD, ERR(7), LNF)
        CALL EISGE(NMSUB, LNW, NW, 1, 1, HEAD, ERR(8), LNW)
      END IF
C
      IF (.NOT.ERR(1)) THEN
        IF (OPTION(3)) THEN
          CALL EISII(NMSUB, LLAGMX, LAGMAX, 1, N-1, 1, HEAD, ERR(2),
     +       L1, LNM1)
          IF (.NOT.ERR(2)) THEN
            IF (OPTION(2)) THEN
              CALL EISGE(NMSUB, LLACOV, LACOV, LAGMAX+1, 8, HEAD,
     +          ERR(3), LLGMX1)
            ELSE
              CALL EISGE(NMSUB, LLACOV, LACOV, LAGMAX+1, 7, HEAD,
     +          ERR(3), LLGMX1)
            END IF
          END IF
        END IF
        IF (.NOT.ERR(2)) THEN
          IF (OPTION(1))
     +      CALL EISGE(NMSUB, LLYFFT, LYFFT, NFFT, 9, HEAD, ERR(4),
     +        LLYFFT)
C
          IF (.NOT.ERR(8)) THEN
           IF (OPTION(4)) THEN
            IF (OPTION(3)) THEN
             CALL EIVII(NMSUB, LLAGS, LAGS, NW, 1, LAGMAX, 0, HEAD, 3,
     +         NV, ERR(9), L1, LLAGMX)
            ELSE
             CALL EIVII(NMSUB, LLAGS, LAGS, NW, 1, N-1, 0, HEAD, 3, NV,
     +         ERR(9), L1, LNM1)
            END IF
           END IF
C
            IF ((.NOT.ERR(6)) .AND. (.NOT.ERR(9)))
     +         CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR(14),
     +            LLDS)
          END IF
        END IF
      END IF
C
      DO 40 I=1,15
         IF (ERR(I)) IERR = 1
   40 CONTINUE
C
      RETURN
C
      END
*UFSEST
      SUBROUTINE UFSEST(ACOV, W, LAG, SPCF, ISPCF, LACOV, LW, NF, FREQ,
     +   DELTA)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE SPECTRUM, SPCF, AND
C     THEIR LOWER AND UPPER CONFIDENCE LIMITS, SPCLCL AND SPCUCL,
C     RESPECTIVELY.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA
      INTEGER
     +   ISPCF,LACOV,LAG,LW,NF
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(LACOV),FREQ(NF),SPCF(ISPCF),W(LW)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   C,PI,V0,V1,V2
      INTEGER
     +   I,K,KK
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
C
C  INTRINSIC FUNCTIONS
      INTRINSIC COS
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV)
C        THE AUTOCOVARIANCES OF THE SERIES.
C     DOUBLE PRECISION C
C        A VALUE USED TO COMPUTE THE SPECTRUM VALUES.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER ISPCF
C         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
C     INTEGER K, KK
C        INDEXING VARIABLES.
C     INTEGER LACOV
C        THE LENGTH OF VECTOR ACOV.
C     INTEGER LAG
C        THE LAG WINDOW TRUCCATION POINT.
C     INTEGER LW
C        THE LENGTH OF THE VECTOR W.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     DOUBLE PRECISION PI
C        THE VALUE OF PI.
C     DOUBLE PRECISION SPCF(ISPCF)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     DOUBLE PRECISION V0, V1, V2
C        CONSTANTS USED FOR COMPUTING THE SPECTRUM VALUES.
C     DOUBLE PRECISION W(LW)
C        THE VECTOR OF LAG WINDOWS.
C
      CALL GETPI(PI)
C
C        COMPUTE THE SPECTRUM AND ITS CONFIDENCE LIMITS.
C
      DO 20 I=1,NF
         C = COS(2.0D0*PI*FREQ(I))
         V0 = 0.0D0
         V1 = 0.0D0
         DO 10 K=1,LAG
            KK = LAG + 1 - K
            V2 = 2.0D0*C*V1 - V0 + W(KK+1)*ACOV(KK+1)
            V0 = V1
            V1 = V2
   10    CONTINUE
         SPCF(I) = DELTA*(ACOV(1)*W(1)+2.0D0*(V1*C-V0))
         IF (SPCF(I).LT.0.0D0) SPCF(I) = 0.0D0
   20 CONTINUE
      RETURN
      END
*UFSF
      SUBROUTINE UFSF(YFFT, N, LYFFT, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
C     SPECTRUM ANALYSIS USING THE FFT (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,LYFFT,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YFFT(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS
      INTEGER
     +   IFP,IPRT,ISPCF,LACOV,LAGMAX,LDSMIN,LNLPPA,LPCV,LWORK,
     +   NALL0,NF,NFFT,NPRT,NW,WORK
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),FREQ(101),RSTAK(12),SPCF(101,4),XAXIS(106),
     +   YAXIS(106)
      INTEGER
     +   ISORT(101),ISYM(106),LAGS(4),NLPPA(1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LDSCMP,PARZEN,SETESL,SETLAG,STKSET,UFSDRV
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(101)
C        THE AUTOCOVARIANCE AT LAG ZERO (BIASED VARIANCE).
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(101)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP = 4 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISORT(101)
C        AN ARRAY USED FOR SORTING.
C     INTEGER ISPCF
C         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
C     INTEGER ISYM(106)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGS(4)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LNLPPA
C        THE LENGTH OF THE VECTOR NLPPA.
C     INTEGER LPCV
C        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
C       THIS ROUTINE WAS CALLED.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     INTEGER NLPPA(1)
C        A DUMMY ARRAY WHEN THE SERIES DOES NOT CONTAIN MISSING VALUES.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION SPCF(101,4)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY WORK.
C     DOUBLE PRECISION XAXIS(106)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YFFT(LYFFT)
C        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YAXIS(106)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YMISS
C        A DUMMY VARIABLE WHEN THE SERIES DO NOT CONTAIN MISSING VALUES
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','F',' ',' '/
C
C     SET UP
C
      OPTION(4) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(1) = .TRUE.
C
C     SET MAXIMUM LAG VALUE TO BE USED.
C     SET EXTENDED SERIES LENGTH.
C     SET NUMBER OF LAG WINDOW TRUNCATION POINTS TO USE.
C
      CALL SETLAG(N, LAGMAX)
      CALL SETESL(N+LAGMAX, 4, NFFT)
      NW = 4
C
      ISPCF = 101
      LACOV = 101
      LNLPPA = 1
      LPCV = 106
      LWORK = NFFT
      NF = 101
      YMISS = 1.0D0
C
C     COMPUTE MIIMUM ALLOWABLE STACK LENGTH
C
      CALL LDSCMP(1, 0, 0, 0, 0, 0, 'D', NFFT, LDSMIN)
C
C     SET SIZE OF WORK AREA.
C     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
C     SET THE STACK ALLOCATION TYPE.
C
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
C
      IFP = 4
C
C     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
C
      IF ((LDSMIN.LE.LDSTAK) .AND. (LDSMIN.GE.7)) THEN
         WORK = STKGET(LWORK,IFP)
      ELSE
         WORK = 1
      END IF
C
C     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
C     FOR SERIES WITH MISSING DATA.
C
      CALL UFSDRV(YFFT, LYFFT, YMISS, ACOV, NLPPA, SPCF, ISPCF, NF,
     +   FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS, RSTAK(WORK), LACOV,
     +   LWORK, DELTA, ISORT, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT,
     +   PARZEN, NMSUB, LDSMIN, LDSTAK, OPTION, LNLPPA, NFFT)
C
C     CHECK FOR ERRORS
C
      IF (IERR.EQ.0) RETURN
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL UFSF (YFFT, N, LYFFT, LDSTAK)')
      END
*UFSFS
      SUBROUTINE UFSFS(YFFT, N, LYFFT, LDSTAK, NW, LAGS, NF, FMIN, FMAX,
     +   NPRT, SPCF, ISPCF, FREQ)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
C     SPECTRUM ANALYSIS USING THE FFT (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   ISPCF,LDSTAK,LYFFT,N,NF,NPRT,NW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),SPCF(*),YFFT(*)
      INTEGER
     +   LAGS(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,YMISS
      INTEGER
     +   ACOV,I,IFP,IO,IPRT,ISORT,ISYM,LACOV,LAGMAX,LDSMIN,LNLPPA,
     +   LPCV,LWORK,NALL0,NFFT,WORK,XAXIS,YAXIS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12),NLPPA(1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LDSCMP,PARZEN,SETESL,STKCLR,STKSET,UFSDRV
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER ACOV
C        THE STARTING LOCATION IN RSTAK FOR THE ACVF VECTOR.
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE SPECTRUM
C        IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF ERR01, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
C        BASED ON PRINTED OUTPUT REQUESTED.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISORT
C        THE STARTING LOCATION FOR THE ARRAY USED FOR SORTING.
C     INTEGER ISPCF
C         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISYM
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY ISYM.
C     INTEGER LACOV
C        THE LENGTH OF VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGS(NW)
C        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LNLPPA
C        THE LENGTH OF THE VECTOR NLPPA.
C     INTEGER LPCV
C        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR Y.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
C        THIS ROUTINE WAS CALLED.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPA(1)
C        A DUMMY ARRAY FOR SERIES WITHOUT MISSING VALUES.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION SPCF(ISPCF,NW)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
C        FOR EACH LAG WINDOW.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY WORK.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY XAXIS.
C     DOUBLE PRECISION YFFT(LYFFT)
C        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY YAXIS.
C     DOUBLE PRECISION YMISS
C        THE MISSING VALUE CODE FOR THE SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','F','S',' '/
C
C     SET UP
C
      OPTION(4) = .TRUE.
      OPTION(3) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(1) = .TRUE.
C
C     SET MAXIMUM LAG VALUE TO BE USED.
C
      LAGMAX = N - 1
      IF (NW.LE.0) GO TO 20
      LAGMAX = LAGS(1)
      DO 10 I=1,NW
         LAGMAX = MAX(LAGMAX,LAGS(I))
   10 CONTINUE
   20 CONTINUE
      LACOV = LAGMAX + 1
      LNLPPA = 1
C
C     SET EXTENDED SERIES LENGTH
C
      CALL SETESL(N+LAGMAX, 4, NFFT)
C
C     COMPUTE MINIMUM ALLOWABLE STACK LENGTH
C
      IO = 1
      IF (NPRT.EQ.0) IO = 0
C
      CALL LDSCMP(5, 0, IO*(NF+5), 0, 0, 0, 'D',
     +   LAGMAX+1+NFFT+IO*(2*NF+10), LDSMIN)
C
      LPCV = NF + 5
      LWORK = NFFT
C
C     SET SIZE OF WORK AREA.
C     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
C     SET THE STACK ALLOCATION TYPE.
C
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
C
      IFP = 4
C
C     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
C
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         ACOV = 1
         WORK = 1
         XAXIS = 1
         YAXIS = 1
         ISYM = 1
         ISORT = 1
      ELSE
         ACOV = STKGET(LACOV,IFP)
         WORK = STKGET(LWORK,IFP)
         IF (NPRT.NE.0) THEN
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
            ISYM = STKGET(LPCV,2)
            ISORT = ISYM
         ELSE
            XAXIS = WORK
            YAXIS = WORK
            ISYM = WORK
            ISORT = ISYM
         END IF
      END IF
C
C     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
C
      CALL UFSDRV(YFFT, LYFFT, YMISS, RSTAK(ACOV), NLPPA, SPCF, ISPCF,
     +   NF, FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS, RSTAK(WORK), LACOV,
     +   LWORK, DELTA, ISTAK(ISORT), ISTAK(ISYM), RSTAK(XAXIS),
     +   RSTAK(YAXIS), LPCV, ALPHA, NPRT, PARZEN, NMSUB, LDSMIN, LDSTAK,
     +   OPTION, LNLPPA, NFFT)
C
      CALL STKCLR(NALL0)
C
C     CHECK FOR ERRORS
C
      IF (IERR.EQ.0) RETURN
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL UFSFS (YFFT, N, LYFFT, LDSTAK,'/
     +   '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +   '      +            SPCF, ISPCF, FREQ)')
      END
*UFSLAG
      SUBROUTINE UFSLAG (ACOV, LAGMAX, LAGS, N, NW, NWUSED, LACOV)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE COMPUTES THE LAG WINDOW TRUNCATION POINTS FOR
C     SPECTRUM ANALYSIS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LACOV,LAGMAX,N,NW,NWUSED
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(LACOV)
      INTEGER
     +   LAGS(NW)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ACOVMX,P95LIM
      INTEGER
     +   I,J,K,LAG,NWM1
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,DBLE,SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV)
C        THE ARRAY IN WHICH THE AUTOCOVARIANCES ARE STORED
C     DOUBLE PRECISION ACOVMX
C        THE MAXIMUM AUTOCOVARIANCE VALUE.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER J, K
C        INDEX VARIABLES.
C     INTEGER LACOV
C        THE LENGTH OF VECTOR ACOV.
C     INTEGER LAG, LAGMAX
C        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
C        AUTOCOVARIANCE BEING COMPUTED AND THE MAXIMUM LAG TO BE USED,
C        RESPECTIVELY.
C     INTEGER LAGS(NW)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NW
C        THE NUMBER OF DIFFERENT BANDWIDTHS REQUESTED.
C     INTEGER NWM1, NWUSED
C        THE NUMBER OF DIFFERENT BANDWIDTHS MINUS 1, AND THE
C        ACTUAL NUMBER OF BANDWIDTHS ACTUALLY USED.
C     DOUBLE PRECISION P95LIM
C        THE 95 PERCENT CONFIDENT LIMIT FOR WHITE NOISE.
C
      LAGS(NW) = LAGMAX
      IF (LAGS(NW) .LE. 32) GO TO 30
C
C     COMPUTE 95 PERCENT CONFIDENCE LIMITS ON AUTOCOVARIANCES,
C     ASSUMING WHITE NOISE.
C
      P95LIM = 1.96D0 * ACOV(1) / SQRT(DBLE(N))
C
C     CHECK FOR FIRST ACVF EXCEEDING 95 PERCENT LIMIT ON WHITE NOISE
C
      DO 10 I = 1, LAGMAX
         LAG = LAGMAX + 1 - I
         IF (ABS(ACOV(LAG + 1)) .GE. P95LIM) GO TO 30
         LAGS(NW) = LAGS(NW) - 1
   10 CONTINUE
C
C     IF NO ACVF EXCEEDS WHITE NOISE LIMITS, CHECK FOR LARGEST ACVF.
C
      LAGS(NW) = 1
      ACOVMX = ABS(ACOV(2))
      DO 20 LAG = 1, LAGMAX
         IF (ABS(ACOV(LAG + 1)) .LE. ACOVMX) GO TO 20
         LAGS(NW) = LAG
         ACOVMX = ABS(ACOV(LAG + 1))
   20 CONTINUE
C
C     COMPUTE LAG WINDOW TRUNCATION POINTS
C
   30 LAGS(NW) = LAGS(NW) * 3.0D0 / 2.0D0
      IF (LAGS(NW) .LT. 32) LAGS(NW) = 32
      IF (LAGS(NW) .GT. LAGMAX) LAGS(NW) = LAGMAX
      NWUSED = NW
      IF (NW .EQ. 1) RETURN
      NWM1 = NW - 1
      DO 40 I = 1, NWM1
         K = NW - I
         LAGS(K) = LAGS(K + 1) / 2
   40 CONTINUE
C
C     CHECK WHETHER ALL NW LAG WINDOW TRUNCATION POINTS CAN BE USED.
C
      NWUSED = NW
      IF (LAGS(1) .GE. 4) RETURN
C
C     RECONSTURCT -LAGS- VECTOR IF NOT ALL TRUNCATION POINTS ARE
C     TO BE USED
C
      DO 50 I = 2, NW
         NWUSED = NWUSED - 1
         IF (LAGS(I) .GE. 4) GO TO 60
   50 CONTINUE
C
   60 DO 70 I = 1, NWUSED
         J = NW - NWUSED + I
         LAGS(I) = LAGS(J)
   70 CONTINUE
C
      RETURN
      END
*UFSM
      SUBROUTINE UFSM(Y, YMISS, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
C     SPECTRUM ANALYSIS WITH MISSING DATA (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMISS
      INTEGER
     +   N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN
      INTEGER
     +   IPRT,ISPCF,LACOV,LAGMAX,LDSMIN,LDSTAK,LNLPPA,LPCV,LWORK,
     +   LY,NF,NPRT,NW
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),FREQ(101),SPCF(101,4),WORK(101),XAXIS(106),
     +   YAXIS(106)
      INTEGER
     +   ISORT(101),ISYM(106),LAGS(4),NLPPA(101)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ECVF,IPRINT,PARZEN,SETLAG,UFSDRV
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(101)
C        THE AUTOCOVARIANCE AT LAG ZERO (BIASED VARIANCE).
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(101)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISORT(101)
C        AN ARRAY USED FOR SORTING.
C     INTEGER ISPCF
C         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
C     INTEGER ISYM(106)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGS(4)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LNLPPA
C        THE LENGTH OF THE VECTOR NLPPA.
C     INTEGER LPCV
C        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LY
C        THE LENGTH OF THE VECTOR Y.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPA(101)
C        THE ARRAY CONTAINING THE NUMBER OF LAG PRODUCT PAIRS.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION SPCF(101,4)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     DOUBLE PRECISION WORK(101)
C        THE VECTOR OF LAG WINDOWS.
C     DOUBLE PRECISION XAXIS(106)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YAXIS(106)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YMISS
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
C        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
C        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','M',' ',' '/
C
C     SET UP
C
      OPTION(4) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(2) = .TRUE.
      OPTION(1) = .FALSE.
C
      LDSTAK = 0
      LDSMIN = 0
C
      ISPCF = 101
      LACOV = 101
      LNLPPA = 101
      LY = N
      LPCV = 106
      LWORK = 101
      NF = 101
C
C     SET MAXIMUM LAG VALUE TO BE USED.
C     AND NUMBER OF LAG WINDOW TRUNCATION POINTS TO USE.
C
      CALL SETLAG(N, LAGMAX)
      NW = 4
C
C     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
C     FOR SERIES WITH MISSING DATA.
C
      CALL UFSDRV(Y, LY, YMISS, ACOV, NLPPA, SPCF, ISPCF, NF, FMIN,
     +   FMAX, FREQ, N, NW, LAGMAX, LAGS, WORK, LACOV, LWORK, DELTA,
     +   ISORT, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, PARZEN, NMSUB,
     +   LDSMIN, LDSTAK, OPTION, LNLPPA, LY)
C
C     CHECK FOR ERRORS
C
      IF (IERR.EQ.0) RETURN
C
      IF (IERR.EQ.2) CALL ECVF(NMSUB)
      IERR = 1
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL UFSM (Y, YMISS, N)')
      END
*UFSMN
      SUBROUTINE UFSMN(ACOV, NLPPA, LAG, DF, NF, FREQ, ALPHA, BW, SPCF,
     +   ALOW, AUP, LACOV, ISPCF, WINDOW, W, LW, N, DELTA, MISS, LNLPPA)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE MAIN SUBROUTINE FOR COMPUTING AUTOCORRELATIONS AND
C     PARTIAL AUTOCORRELATIONS OF A TIME SERIES
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALOW,ALPHA,AUP,BW,DELTA,DF
      INTEGER
     +   ISPCF,LACOV,LAG,LNLPPA,LW,N,NF
      LOGICAL
     +   MISS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(LACOV),FREQ(NF),SPCF(ISPCF),W(LW)
      INTEGER
     +   NLPPA(LNLPPA)
C
C  SUBROUTINE ARGUMENTS
      EXTERNAL WINDOW
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   PPFCHS
      EXTERNAL PPFCHS
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DFBW,DFBWM,UFSEST
C
C  INTRINSIC FUNCTIONS
      INTRINSIC NINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LACOV)
C        THE AUTOCOVARIANCES OF THE SERIES.
C     DOUBLE PRECISION ALOW
C        A FACTOR USED TO COMPUTE THE LOWER CONFIDENCE LIMITS.
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION AUP
C        A FACTOR USED TO COMPUTE THE UPPER CONFIDENCE LIMITS.
C     DOUBLE PRECISION BW
C        THE BANDWIDTH.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DF
C        THE EFFECTIVE DEGREES OF FREEDOM.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER ISPCF
C         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
C     INTEGER LACOV
C        THE LENGTH OF VECTOR ACOV.
C     INTEGER LAG
C        THE VARIABLE INDICATING THE LAG VALUE BEING EXAMINED.
C     INTEGER LNLPPA
C        THE LENGTH OF THE VECTOR NLPPA.
C     INTEGER LW
C        THE LENGTH OF THE VECTOR W.
C     LOGICAL MISS
C        AN INDICATOR VARIABLE WHICH DESIGNATES WHETHER THERE ARE
C        MISSING VALUES (TRUE) OR NOT (FALSE)
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE TIME SERIES.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPA(LNLPPA)
C        THE NUMBERS OF LAGGED PRODUCT PAIRS IN EACH ACVF VALUE.
C     DOUBLE PRECISION SPCF(ISPCF)
C        THE ARRAY IN WHICH THE SPECTRUM IS STORED.
C     DOUBLE PRECISION W(LW)
C        THE VECTOR OF LAG WINDOWS.
C     EXTERNAL WINDOW
C        THE NAME OF THE WINDOW COMPUTING SUBROUTINE.
C
C     COMPUTE THE WINDOW, EFFECTIVE DEGREES OF FREEDOM AND
C     BANDWIDTH BASED ON THE WINDOW.
C
      CALL WINDOW(LAG, W, LW)
      IF (.NOT.MISS) CALL DFBW(N, LAG, W, LW, DF, BW)
      IF (MISS) CALL DFBWM(N, LAG, W, LW, NLPPA, NLPPA, LNLPPA, DF, BW)
C
C     COMPUTE THE SPECTRUM
C
      CALL UFSEST(ACOV, W, LAG, SPCF, ISPCF, LACOV, LW, NF, FREQ, DELTA)
C
C     COMPUTE -ALPHA- PERCENT POINT FUNCTION VALUE FOR
C     SPECTRUM WINDOW BEING USED.
C
      ALOW = DF/PPFCHS(0.5D0+ALPHA/2.0D0,NINT(DF))
      AUP = DF/PPFCHS(0.5D0-ALPHA/2.0D0,NINT(DF))
C
      RETURN
      END
*UFSMS
      SUBROUTINE UFSMS(Y, YMISS, N, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   SPCF, ISPCF, FREQ, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
C     SPECTRUM ANALYSIS WITH MISSING DATA (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN,YMISS
      INTEGER
     +   ISPCF,LDSTAK,N,NF,NPRT,NW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),SPCF(*),Y(*)
      INTEGER
     +   LAGS(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA
      INTEGER
     +   ACOV,I,IFP,IO,IPRT,ISORT,ISYM,LACOV,LAGMAX,LDSMIN,LNLPPA,
     +   LPCV,LWORK,LY,NALL0,NLPPA,WORK,XAXIS,YAXIS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ECVF,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UFSDRV
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER ACOV
C        THE STARTING LOCATION IN RSTAK FOR THE ACVF VECTOR.
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE SPECTRUM
C        IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF ERR01, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
C        BASED ON PRINTED OUTPUT REQUESTED.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISORT
C        THE STARTING LOCATION FOR THE ARRAY USED FOR SORTING.
C     INTEGER ISPCF
C         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISYM
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY ISYM.
C     INTEGER LACOV
C        THE LENGTH OF VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGS(NW)
C        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LNLPPA
C        THE LENGTH OF THE VECTOR NLPPA.
C     INTEGER LPCV
C        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LY
C        THE LENGTH OF THE VECTOR Y.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
C        THIS ROUTINE WAS CALLED.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPA
C        THE STARTING LOCATION IN ISTAK FOR THE ARRAY CONTAINING
C        THE NUMBERS OF LAGGED PRODUCT PAIRS USED FOR EACH ACVF.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION SPCF(ISPCF,NW)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
C        FOR EACH LAG WINDOW.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY WINDOW.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY XAXIS.
C     DOUBLE PRECISION Y(N)
C        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY YAXIS.
C     DOUBLE PRECISION YMISS
C        THE MISSING VALUE CODE FOR THE SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','M','S',' '/
C
C     SET UP
C
      OPTION(4) = .TRUE.
      OPTION(3) = .FALSE.
      OPTION(2) = .TRUE.
      OPTION(1) = .FALSE.
C
C     SET MAXIMUM LAG VALUE TO BE USED.
C
      LAGMAX = N - 1
      IF (NW.LE.0) GO TO 20
      LAGMAX = LAGS(1)
      DO 10 I=1,NW
         LAGMAX = MAX(LAGMAX,LAGS(I))
   10 CONTINUE
   20 CONTINUE
      LACOV = LAGMAX + 1
      LNLPPA = LAGMAX + 1
C
C     COMPUTE MINIMUM ALLOWABLE STACK LENGTH
C
      IO = 1
      IF (NPRT.EQ.0) IO = 0
C
      CALL LDSCMP(6, 0, LAGMAX+1+IO*(NF+5), 0, 0, 0, 'D',
     +   2*LAGMAX+2+IO*(2*NF+10), LDSMIN)
C
      LY = N
      LNLPPA = LACOV
      LPCV = NF + 5
      LWORK = LAGMAX+1
C
C     SET SIZE OF WORK AREA.
C     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
C     SET THE STACK ALLOCATION TYPE.
C
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
C
      IFP = 4
C
C     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
C
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         NLPPA = 1
         ACOV = 1
         WORK = 1
         XAXIS = 1
         YAXIS = 1
         ISYM = 1
         ISORT = 1
      ELSE
         NLPPA = STKGET(LACOV,2)
         ACOV = STKGET(LACOV,IFP)
         WORK = STKGET(LWORK,IFP)
         IF (NPRT.NE.0) THEN
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
            ISYM = STKGET(LPCV,2)
            ISORT = ISYM
         ELSE
            XAXIS = WORK
            YAXIS = WORK
            ISYM = WORK
            ISORT = ISYM
         END IF
      END IF
C
C     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
C     FOR SERIES WITH MISSING DATA.
C
      CALL UFSDRV(Y, LY, YMISS, RSTAK(ACOV), ISTAK(NLPPA), SPCF, ISPCF,
     +   NF, FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS, RSTAK(WORK), LACOV,
     +   LWORK, DELTA, ISTAK(ISORT), ISTAK(ISYM), RSTAK(XAXIS),
     +   RSTAK(YAXIS), LPCV, ALPHA, NPRT, PARZEN, NMSUB, LDSMIN, LDSTAK,
     +   OPTION, LNLPPA, LY)
C
      CALL STKCLR(NALL0)
C
C     CHECK FOR ERRORS
C
      IF (IERR.EQ.0) RETURN
C
      IF (IERR.EQ.2) CALL ECVF(NMSUB)
      IERR = 1
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL UFSMS (Y, YMISS, N,'/
     +   '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +   '      +            SPCF, ISPCF, FREQ, LDSTAK)')
      END
*UFSMV
      SUBROUTINE UFSMV(ACOV, NLPPA, LAGMAX, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
C     SPECTRUM ANALYSIS WITH MISSING DATA AND USER SUPPLIED
C     ACVF VALUES (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LAGMAX,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*)
      INTEGER
     +   NLPPA(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS
      INTEGER
     +   IPRT,ISPCF,LACOV,LDSMIN,LDSTAK,LNLPPA,LPCV,LWORK,LY,NF,
     +   NPRT,NW
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FREQ(101),SPCF(101,4),WORK(101),XAXIS(106),Y(1),YAXIS(106)
      INTEGER
     +   ISORT(101),ISYM(106),LAGS(4)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ECVF,IPRINT,PARZEN,UFSDRV
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LAGMAX+1)
C        THE AUTOCOVARIANCE AT LAG ZERO (BIASED VARIANCE).
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(101)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISORT(101)
C        AN ARRAY USED FOR SORTING.
C     INTEGER ISPCF
C         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
C     INTEGER ISYM(106)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGS(4)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LNLPPA
C        THE LENGTH OF THE VECTOR NLPPA.
C     INTEGER LPCV
C        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LY
C        THE LENGTH OF THE VECTOR Y.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPA(LAGMAX+1)
C        THE ARRAY CONTAINING THE NUMBER OF LAG PRODUCT PAIRS.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION SPCF(101,4)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     DOUBLE PRECISION WORK(101)
C        THE VECTOR OF LAG WINDOWS.
C     DOUBLE PRECISION XAXIS(106)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION Y(1)
C        A DUMMY ARRAY.
C     DOUBLE PRECISION YAXIS(106)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YMISS
C        A DUMMY VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','M','V',' '/
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(4) = .FALSE.
      OPTION(3) = .TRUE.
      OPTION(2) = .TRUE.
      OPTION(1) = .FALSE.
C
      LDSTAK = 0
      LDSMIN = 0
C
      YMISS = 1.0D0
      LACOV = LAGMAX+1
C
      ISPCF = 101
      LY = 1
      LNLPPA = LACOV
      LPCV = 106
      LWORK = 101
      NF = 101
C
C     SET NUMBER OF LAG WINDOW TRUNCATION POINTS
C
      NW = 4
C
C     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
C     FOR SERIES WITH MISSING DATA.
C
      CALL UFSDRV(Y, LY, YMISS, ACOV, NLPPA, SPCF, ISPCF, NF, FMIN,
     +   FMAX, FREQ, N, NW, LAGMAX, LAGS, WORK, LACOV, LWORK, DELTA,
     +   ISORT, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, PARZEN, NMSUB,
     +   LDSMIN, LDSTAK, OPTION, LNLPPA, LY)
C
C     CHECK FOR ERRORS
C
      IF (IERR.EQ.0) RETURN
C
      IF (IERR.EQ.2) CALL ECVF(NMSUB)
      IERR = 1
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL UFSMV (ACOV, NLPPA, LAGMAX, N)')
      END
*UFSMVS
      SUBROUTINE UFSMVS(ACOV, NLPPA, LAGMAX, N, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
C     SPECTRUM ANALYSIS WITH MISSING DATA (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   ISPCF,LAGMAX,LDSTAK,N,NF,NPRT,NW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),FREQ(*),SPCF(*)
      INTEGER
     +   LAGS(*),NLPPA(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,YMISS
      INTEGER
     +   IFP,IO,IPRT,ISORT,ISYM,LACOV,LDSMIN,LNLPPA,LPCV,LWORK,LY,
     +   NALL0,WORK,XAXIS,YAXIS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12),Y(1)
      INTEGER
     +   ISTAK(12)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ECVF,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UFSDRV
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LAGMAX+1)
C        THE AUTOCOVARIANCES OF THE SERIES.
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE SPECTRUM
C        IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF ERR01, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
C        BASED ON PRINTED OUTPUT REQUESTED.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISORT
C        THE STARTING LOCATION FOR THE ARRAY USED FOR SORTING.
C     INTEGER ISPCF
C         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISYM
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY ISYM.
C     INTEGER LACOV
C        THE LENGTH OF THE ACVF VECTORS.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGS(NW)
C        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LNLPPA
C        THE LENGTH OF THE VECTOR NLPPA.
C     INTEGER LPCV
C        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LY
C        THE LENGTH OF THE VECTOR Y.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
C        THIS ROUTINE WAS CALLED.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPA(LAGMAX+1)
C        THE ARRAY CONTAINING THE NUMBER OF LAG PRODUCT PAIRS.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION SPCF(ISPCF,NW)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
C        FOR EACH LAG WINDOW.
C     INTEGER WORK
C        THE STARTING LOCATION IN RSTAK FOR
C        THE WORK VECTOR.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY XAXIS.
C     DOUBLE PRECISION Y(1)
C        A DUMMY ARRAY.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY YAXIS.
C     DOUBLE PRECISION YMISS
C        A DUMMY VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','M','V','S'/
C
C     SET UP
C
      OPTION(4) = .TRUE.
      OPTION(3) = .TRUE.
      OPTION(2) = .TRUE.
      OPTION(1) = .FALSE.
C
C     COMPUTE MINIMUM ALLOWABLE STACK LENGTH
C
      IO = 1
      IF (NPRT.EQ.0) IO = 0
C
      CALL LDSCMP(4, 0, IO*(NF+5), 0, 0, 0, 'D',
     +   LAGMAX+1+IO*(2*NF+10), LDSMIN)
C
      YMISS = 1.0D0
      LACOV = LAGMAX+1
C
      LY = 1
      LNLPPA = LACOV
      LPCV = NF + 5
      LWORK = LAGMAX+1
C
C     SET SIZE OF WORK AREA.
C     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
C     SET THE STACK ALLOCATION TYPE.
C
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
C
      IFP = 4
C
C     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
C
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         WORK = 1
         XAXIS = 1
         YAXIS = 1
         ISYM = 1
         ISORT = 1
      ELSE
         WORK = STKGET(LWORK,IFP)
         IF (NPRT.NE.0) THEN
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
            ISYM = STKGET(LPCV,2)
            ISORT = ISYM
         ELSE
            XAXIS = WORK
            YAXIS = WORK
            ISYM = WORK
            ISORT = ISYM
         END IF
      END IF
C
C     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
C     FOR SERIES WITH MISSING DATA.
C
      CALL UFSDRV(Y, LY, YMISS, ACOV, NLPPA, SPCF, ISPCF, NF, FMIN,
     +   FMAX, FREQ, N, NW, LAGMAX, LAGS, RSTAK(WORK), LACOV, LWORK,
     +   DELTA, ISTAK(ISORT), ISTAK(ISYM), RSTAK(XAXIS), RSTAK(YAXIS),
     +   LPCV, ALPHA, NPRT, PARZEN, NMSUB, LDSMIN, LDSTAK, OPTION,
     +   LNLPPA, LY)
C
      CALL STKCLR(NALL0)
C
C     CHECK FOR ERRORS
C
      IF (IERR.EQ.0) RETURN
C
      IF (IERR.EQ.2) CALL ECVF(NMSUB)
      IERR = 1
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL UFSMVS (ACOV, NLPPA, LAGMAX, N,'/
     +  '      +             NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +  '      +             SPCF, ISPCF, FREQ, LDSTAK)')
      END
*UFSOUT
      SUBROUTINE UFSOUT(XAXIS, YAXIS, ISYM, NPTS, BW, IDF, LAG, LAGLST,
     +   NEWPG, ISPCER, LPCV, XPLTMN, XPLTMX, YPLTMN, YPLTMX, ILOG,
     +   PHAS, FREQ, NF, UNIVAR, NMSUB)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRODUCES THE FOURIER BIVARIATE SPECTRUM OUTPUT.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 10, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   BW,XPLTMN,XPLTMX,YPLTMN,YPLTMX
      INTEGER
     +   IDF,ILOG,ISPCER,LAG,LAGLST,LPCV,NF,NPTS
      LOGICAL
     +   NEWPG,UNIVAR
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),PHAS(NF),XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISYM(LPCV)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   PI,XMN,XMX,YMN,YMX
      INTEGER
     +   I,IPRT
      LOGICAL
     +   ERROR
C
C  EXTERNAL SUBROUTINES
      EXTERNAL GETPI,IPRINT,PPLMT,PPMN,VERSP
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION BW
C        THE BANDWIDTH.
C     LOGICAL ERROR
C        AN ERROR FLAG
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER IDF
C        THE EFFECTIVE DEGREES OF FREEDOM.
C     INTEGER IERR
C        THE ERROR FLAG.
C     INTEGER ILOG
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        ILOG = 0 THE PLOT IS LINEAR/LINEAR, IF
C        ILOG = 1 THE PLOT IS LOG/LINEAR, IF
C        ILOG = 2 THE PLOT IS LINEAR/LOG, AND IF
C        ILOG = 3 THE PLOT IS LOG/LOG.
C     INTEGER IPRT
C        THE LOGICAL UNIT NUMBER FOR THE OUTPUT.
C     INTEGER ISPCER
C        A VARIABLE USED TO DESIGNATE AN ERROR IN THE SPECTRUM
C        VALUES.
C     INTEGER ISYM(LPCV)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LAG
C        THE LAG WINDOW TRUNCATION POINT.
C     INTEGER LAGLST
C        THE LAST LAG BEFORE MISSING DATA CAUSED THE ACVF OF EITHER
C        SERIES 1 OR 2 NOT TO BE COMPUTED.
C     INTEGER LPCV
C        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
C     LOGICAL NEWPG
C        THE LOGICAL VARIABLE USED TO DETERMINE IF OUTPUT
C        WILL BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE CALLING SUBROUTINE.
C     INTEGER NPTS
C        THE NUMBER OF CO-ORDINATES TO BE PLOTTED.
C     DOUBLE PRECISION PHAS(NF)
C        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
C     DOUBLE PRECISION PI
C        THE VALUE OF PI.
C     LOGICAL UNIVAR
C        THE LOGICAL VARIABLE USED TO DETERMINE IF THE OUTPUT
C        IS FOR UNIVARIATE (TRUE) OR BIVARIATE (FALSE) SPECTRA.
C     DOUBLE PRECISION XAXIS(LPCV)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION XMN, XMX
C        *
C     DOUBLE PRECISION XPLTMN, XPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
C     DOUBLE PRECISION YAXIS(LPCV)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YMN, YMX
C        *
C     DOUBLE PRECISION YPLTMN, YPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
C
C      SET LOGICAL UNIT NUMBER FOR OUTPUT AND SET OUTPUT WIDTH.
C
      CALL IPRINT(IPRT)
C
      CALL GETPI(PI)
C
      IF (NEWPG) WRITE (IPRT,1010)
      IF (ISPCER.LE.1) GO TO 10
      CALL VERSP(.TRUE.)
      WRITE (IPRT,1060) LAGLST, LAG
      RETURN
C
   10 CONTINUE
      CALL VERSP(.TRUE.)
      IF (.NOT.UNIVAR) WRITE (IPRT,1070)
      IF (UNIVAR) WRITE (IPRT,1080)
      WRITE (IPRT,1020) LAG, BW, IDF
      IF (ISPCER.EQ.0) GO TO 20
      WRITE (IPRT,1050)
      GO TO 30
C
   20 CONTINUE
C
C     PRINT PLOTS
C
C     PLOT SQUARED COHERENCY COMPONENT OF SPECTRUM
C
      CALL PPLMT(YAXIS, YAXIS, XAXIS, XAXIS, NPTS, 1, LPCV, YPLTMN,
     +  YPLTMX, YMN, YMX, XPLTMN, XPLTMX, XMN, XMX, ERROR, NMSUB,
     +  .FALSE.)
      IF (.NOT.ERROR)
     +  CALL PPMN(YAXIS, YAXIS, XAXIS, XAXIS, NPTS, 1, LPCV, 1, ISYM,
     +  LPCV, 0, -1, YMN, YMX, XMN, XMX, .FALSE., ILOG)
      IF (XPLTMN.EQ.0.0D0 .AND. XPLTMX.EQ.0.5D0) WRITE (IPRT, 1030)
C
   30 IF (UNIVAR) RETURN
      DO 40 I=1,NF
         XAXIS(I) = FREQ(I)
         XAXIS(NF+I) = FREQ(I)
         YAXIS(I) = PHAS(I)
         IF (PHAS(I).GT.0.0D0) THEN
            YAXIS(NF+I) = PHAS(I) - 2*PI
         ELSE IF (PHAS(I).LT.0.0D0) THEN
            YAXIS(NF+I) = PHAS(I) + 2*PI
         ELSE
            YAXIS(NF+I) = 0.0D0
         END IF
   40 CONTINUE
C
C     PLOT SMOOTHED PHASE COMPONENT OF SPECTRUM
C
      WRITE (IPRT,1010)
      CALL VERSP(.TRUE.)
      WRITE (IPRT,1000)
      WRITE (IPRT,1020) LAG, BW, IDF
      CALL PPLMT(YAXIS, YAXIS, XAXIS, XAXIS, 2*NF, 1, 2*NF, -2*PI, 2*PI,
     +  YMN, YMX, XPLTMN, XPLTMX, XMN, XMX, ERROR, NMSUB, .FALSE.)
      IF (ERROR) THEN
        IERR = 1
      ELSE
        CALL PPMN(YAXIS, YAXIS, XAXIS, XAXIS,
     +            2*NF, 1, 2*NF, 0, ISYM, LPCV,
     +            0, -1, YMN, YMX, XMN, XMX, .FALSE., ILOG)
        IF (XPLTMN.EQ.0.0D0 .AND. XPLTMX.EQ.0.5D0) WRITE (IPRT, 1030)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (50H -- SMOOTHED FOURIER SPECTRUM (PHASE COMPONENT) --)
 1010 FORMAT ('1')
 1020 FORMAT (45H    (PARZEN WINDOW WITH LAG WIND. TRUNC. PT.=, I5, 1X,
     +   5H/ BW=, F6.4, 1X, 6H/ EDF=, I6, ')')
 1030 FORMAT (5H+FREQ/7H PERIOD, 9X, 3HINF, 7X, 3H20., 7X, 3H10., 8X,
     +   6H6.6667, 4X, 2H5., 8X, 2H4., 8X, 6H3.3333, 4X, 6H2.8571, 4X,
     +   3H2.5, 7X, 6H2.2222, 4X, 2H2.)
C1040 FORMAT (5H+FREQ/7H PERIOD, 9X, 3HINF, 7X, 3H10., 7X, 2H5., 8X,
C    *   6H3.3333, 4X, 3H2.5, 7X, 2H2.)
 1050 FORMAT (//39H THE PLOT HAS BEEN SUPRESSED BECAUSE NO/
     +   40H POSITIVE SPECTRUM VALUES WERE COMPUTED.)
 1060 FORMAT (//50H THE LARGEST LAG WINDOW TRUNCATION POINT WHICH CAN/
     +   12H BE USED IS , I5, '.'/34H THE SPECTRUM FOR THE REQUESTED LA,
     +   8HG WINDOW, 10H POINT OF , I5, ','/24H THEREFORE, CANNOT BE CO,
     +   7HMPUTED.)
 1070 FORMAT (48H -- SMOOTHED FOURIER SPECTRUM (SQUARED COHERENCY,
     +   46H COMPONENT) (+), 95 PCT. CONFIDENCE LIMITS (.),
     +   38H AND 95 PCT. SIGNIFICANCE LEVEL (-) --)
 1080 FORMAT (32H -- SMOOTHED FOURIER SPECTRUM --)
      END
*UFSPCV
      SUBROUTINE UFSPCV (SPCF, SPCMN, SPCMX, FREQ, NF, XAXIS, YAXIS,
     +   ISYM, NPTS, ISPCF, LPCV, NSPC, BW, ALOW, AUP, XPLTMN, XPLTMX,
     +   YPLTMN, YPLTMX, NPRT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRODUCES CO-ORDINATES FOR THE SPECTRUM PLOTS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALOW,AUP,BW,SPCMN,SPCMX,XPLTMN,XPLTMX,YPLTMN,YPLTMX
      INTEGER
     +   ISPCF,LPCV,NF,NPRT,NPTS,NSPC
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),SPCF(ISPCF),XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISYM(LPCV)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CILOW,CIMID,CIUP,YMAX
      INTEGER
     +   I,ISPCFW
C
C  EXTERNAL SUBROUTINES
      EXTERNAL SPPLTC,SPPLTD,SPPLTL
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG10
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ALOW, AUP
C        FACTORS USED TO COMPUTE THE CONFIDENCE INTERVALS.
C     DOUBLE PRECISION BW
C       THE BANDWIDTH.
C     DOUBLE PRECISION CILOW, CIMID, CIUP
C        THE Y AXIS VALUES FOR THE LOWER  MID AND UPPER CONFIDENCE
C        INTERVAL POINTS.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER ISPCF
C         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
C     INTEGER ISPCFW
C        AN INDEX VARIABLE.
C     INTEGER ISYM(LPCV)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LPCV
C        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NPTS
C        THE NUMBER OF CO-ORDINATES TO BE PLOTTED.
C     INTEGER NSPC
C        THE NUMBER OF VALID SPECTRUM VALUES.
C     DOUBLE PRECISION SPCF(ISPCF)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
C        FOR EACH LAG WINDOW.
C     DOUBLE PRECISION SPCMN, SPCMX
C        THE MINIMUM AND MAXIMUM SPECTRUM VALUE TO BE PLOTTED.
C     DOUBLE PRECISION XAXIS(LPCV)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION XPLTMN, XPLTMX
C        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
C     DOUBLE PRECISION YAXIS(LPCV)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
C     DOUBLE PRECISION YMAX
C        THE MAXIMUM ACTUAL SPECTRUM VALUE (IN DECIBELS) TO BE PLOTTED.
C     DOUBLE PRECISION YPLTMN, YPLTMX
C        THE MINIMUM AND MAXIMUM VAUES TO BE PLOTTED FOR THE Y AXIS.
C
C
      ISPCFW = 0
C
      IF (NPRT .GE. 1) GO TO 30
C
C     SET VARIOUS Y AXIS VALUES FOR DECIBLE PLOTS
C
      CALL SPPLTD (SPCMN, SPCMX, ALOW, AUP, YPLTMN, YPLTMX,
     +   CILOW, CIMID, CIUP, YMAX)
C
C     SET CO-ORDINATES FOR DECIBLE PLOTS
C
      DO 10 I = 1, NF
         IF (SPCF(I) .LT. SPCMN) GO TO 10
         ISPCFW = ISPCFW + 1
         XAXIS(ISPCFW) = FREQ(I)
         YAXIS(ISPCFW) = 10.0D0 * LOG10(SPCF(I)) - YMAX
         ISYM(ISPCFW) = 1
   10 CONTINUE
C
      GO TO 70
C
   30 CONTINUE
C
C     SET VARIOUS Y AXIS VALUES FOR LOG PLOTS
C
      CALL SPPLTL (SPCMN, SPCMX, ALOW, AUP, YPLTMN, YPLTMX,
     +   CILOW, CIMID, CIUP)
C
C     SET CO-ORDINATES FOR LOG PLOTS
C
      DO 50 I = 1, NF
         IF (SPCF(I) .LT. SPCMN) GO TO 50
         ISPCFW = ISPCFW + 1
         XAXIS(ISPCFW) = FREQ(I)
         YAXIS(ISPCFW) = SPCF(I)
         ISYM(ISPCFW) = 1
   50 CONTINUE
C
   70 CONTINUE
C
      NPTS = NSPC
C
C     SET CO-ORDINATES FOR BANDWIDTH AND CONFIDENCE INTERVAL.
C
      CALL SPPLTC (XAXIS, YAXIS, ISYM, NPTS, XPLTMN, XPLTMX, BW, CILOW,
     +   CIMID, CIUP, LPCV)
C
      RETURN
      END
*UFSS
      SUBROUTINE UFSS(Y, N, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   SPCF, ISPCF, FREQ, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
C     SPECTRUM ANALYSIS (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   ISPCF,LDSTAK,N,NF,NPRT,NW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),SPCF(*),Y(*)
      INTEGER
     +   LAGS(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,YMISS
      INTEGER
     +   ACOV,I,IFP,IO,IPRT,ISORT,ISYM,LACOV,LAGMAX,LDSMIN,LNLPPA,
     +   LPCV,LWORK,LY,NALL0,WORK,XAXIS,YAXIS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12),NLPPA(1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UFSDRV
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER ACOV
C        THE STARTING LOCATION IN RSTAK FOR THE ACVF VECTOR.
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE SPECTRUM
C        IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF ERR01, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
C        BASED ON PRINTED OUTPUT REQUESTED.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISORT
C        THE STARTING LOCATION FOR THE ARRAY USED FOR SORTING.
C     INTEGER ISPCF
C         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISYM
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY ISYM.
C     INTEGER LACOV
C        THE LENGTH OF VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGS(NW)
C        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LNLPPA
C        THE LENGTH OF THE VECTOR NLPPA.
C     INTEGER LPCV
C        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LY
C        THE LENGTH OF THE VECTOR Y.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
C        THIS ROUTINE WAS CALLED.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPA(1)
C        A DUMMY ARRAY FOR SERIES WITHOUT MISSING VALUES.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION SPCF(ISPCF,NW)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
C        FOR EACH LAG WINDOW.
C     INTEGER WORK
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY WINDOW.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY XAXIS.
C     DOUBLE PRECISION Y(N)
C         THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY YAXIS.
C     DOUBLE PRECISION YMISS
C        THE MISSING VALUE CODE FOR THE SERIES.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','S',' ',' '/
C
C     SET UP
C
      OPTION(4) = .TRUE.
      OPTION(3) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(1) = .FALSE.
C
C     SET MAXIMUM LAG VALUE TO BE USED.
C
      LAGMAX = N - 1
      IF (NW.LE.0) GO TO 20
      LAGMAX = LAGS(1)
      DO 10 I=1,NW
         LAGMAX = MAX(LAGMAX,LAGS(I))
   10 CONTINUE
   20 CONTINUE
      LACOV = LAGMAX + 1
      LNLPPA = 1
C
C     COMPUTE MINIMUM ALLOWABLE STACK LENGTH
C
      IO = 1
      IF (NPRT.EQ.0) IO = 0
C
      CALL LDSCMP(5, 0, IO*(NF+5), 0, 0, 0, 'D',
     +   2*LAGMAX+2+IO*(2*NF+10), LDSMIN)
C
      LY = N
      LPCV = NF + 5
      LWORK = LAGMAX+1
C
C     SET SIZE OF WORK AREA.
C     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
C     SET THE STACK ALLOCATION TYPE.
C
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
C
      IFP = 4
C
C     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
C
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         ACOV = 1
         WORK = 1
         XAXIS = 1
         YAXIS = 1
         ISYM = 1
         ISORT = 1
      ELSE
         ACOV = STKGET(LACOV,IFP)
         WORK = STKGET(LWORK,IFP)
         IF (NPRT.NE.0) THEN
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
            ISYM = STKGET(LPCV,2)
            ISORT = ISYM
         ELSE
            XAXIS = WORK
            YAXIS = WORK
            ISYM = WORK
            ISORT = ISYM
         END IF
      END IF
C
C     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
C
      CALL UFSDRV(Y, LY, YMISS, RSTAK(ACOV), NLPPA, SPCF, ISPCF,
     +   NF, FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS, RSTAK(WORK), LACOV,
     +   LWORK, DELTA, ISTAK(ISORT), ISTAK(ISYM), RSTAK(XAXIS),
     +   RSTAK(YAXIS), LPCV, ALPHA, NPRT, PARZEN, NMSUB, LDSMIN, LDSTAK,
     +   OPTION, LNLPPA, LY)
C
      CALL STKCLR(NALL0)
C
C     CHECK FOR ERRORS
C
      IF (IERR.EQ.0) RETURN
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL UFSS (Y, N,'/
     +   '      +           NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +   '      +           SPCF, ISPCF, FREQ, LDSTAK)')
      END
*UFSV
      SUBROUTINE UFSV(ACOV, LAGMAX, N)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
C     SPECTRUM ANALYSIS AND USER SUPPLIED ACVF VALUES (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LAGMAX,N
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS
      INTEGER
     +   IPRT,ISPCF,LACOV,LDSMIN,LDSTAK,LNLPPA,LPCV,LWORK,LY,NF,
     +   NPRT,NW
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FREQ(101),SPCF(101,4),WORK(101),XAXIS(106),Y(1),YAXIS(106)
      INTEGER
     +   ISORT(101),ISYM(106),LAGS(4),NLPPA(1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PARZEN,UFSDRV
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LAGMAX+1)
C        THE AUTOCOVARIANCE AT LAG ZERO (BIASED VARIANCE).
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(101)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISORT(101)
C        AN ARRAY USED FOR SORTING.
C     INTEGER ISPCF
C         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
C     INTEGER ISYM(106)
C        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGS(4)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LNLPPA
C        THE LENGTH OF THE VECTOR NLPPA.
C     INTEGER LPCV
C        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LY
C        THE LENGTH OF THE VECTOR Y.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPA(1)
C        A DUMMY ARRAY FOR SERIES WITHOUT MISSING VALUES.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION SPCF(101,4)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
C     DOUBLE PRECISION WORK(101)
C        THE VECTOR OF LAG WINDOWS.
C     DOUBLE PRECISION XAXIS(106)
C        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION Y(1)
C        A DUMMY ARRAY.
C     DOUBLE PRECISION YAXIS(106)
C        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
C     DOUBLE PRECISION YMISS
C        A DUMMY VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','V',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      OPTION(4) = .FALSE.
      OPTION(3) = .TRUE.
      OPTION(2) = .FALSE.
      OPTION(1) = .FALSE.
C
      LDSTAK = 0
      LDSMIN = 0
C
      YMISS = 1.0D0
      LACOV = LAGMAX+1
C
      ISPCF = 101
      LY = 1
      LNLPPA = 1
      LPCV = 106
      LWORK = 101
      NF = 101
C
C     SET NUMBER OF LAG WINDOW TRUNCATION POINTS
C
      NW = 4
C
C     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
C
      CALL UFSDRV(Y, LY, YMISS, ACOV, NLPPA, SPCF, ISPCF, NF, FMIN,
     +   FMAX, FREQ, N, NW, LAGMAX, LAGS, WORK, LACOV, LWORK, DELTA,
     +   ISORT, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, PARZEN, NMSUB,
     +   LDSMIN, LDSTAK, OPTION, LNLPPA, LY)
C
C     CHECK FOR ERRORS
C
      IF (IERR.EQ.0) RETURN
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL UFSV (ACOV, LAGMAX, N)')
      END
*UFSVS
      SUBROUTINE UFSVS(ACOV, LAGMAX, N, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
C     SPECTRUM ANALYSIS AND USER SUPPLIED ACVF VALUES (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   ISPCF,LAGMAX,LDSTAK,N,NF,NPRT,NW
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),FREQ(*),SPCF(*)
      INTEGER
     +   LAGS(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,YMISS
      INTEGER
     +   IFP,IO,IPRT,ISORT,ISYM,LACOV,LDSMIN,LNLPPA,LPCV,LWORK,LY,
     +   NALL0,WORK,XAXIS,YAXIS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12),Y(1)
      INTEGER
     +   ISTAK(12),NLPPA(1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UFSDRV
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(LAGMAX+1)
C        THE AUTOCOVARIANCES OF THE SERIES.
C     DOUBLE PRECISION ALPHA
C        THE DESIRED CONFIDENCE LEVEL.
C     DOUBLE PRECISION DELTA
C        THE SAMPLING INTERVAL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE SPECTRUM
C        IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(NF)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
C        COMPUTED.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF ERR01, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IFP
C        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
C        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
C     INTEGER IO
C        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
C        BASED ON PRINTED OUTPUT REQUESTED.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISORT
C        THE STARTING LOCATION FOR THE ARRAY USED FOR SORTING.
C     INTEGER ISPCF
C         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
C     INTEGER ISTAK(12)
C        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ISYM
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY ISYM.
C     INTEGER LACOV
C        THE LENGTH OF THE ACVF VECTORS.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE TO BE USED.
C     INTEGER LAGS(NW)
C        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LNLPPA
C        THE LENGTH OF THE VECTOR NLPPA.
C     INTEGER LPCV
C        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
C     INTEGER LWORK
C        THE LENGTH OF THE VECTOR W.
C     INTEGER LY
C        THE LENGTH OF THE VECTOR Y.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
C     INTEGER NALL0
C        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
C        THIS ROUTINE WAS CALLED.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPA(1)
C        A DUMMY ARRAY FOR SERIES WITHOUT MISSING VALUES.
C     CHARACTER*1 NMSUB(6)
C        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
C        BANDWIDTHS TO BE USED.
C     LOGICAL OPTION(4)
C        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
C        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
C        OR NOT (FALSE).
C     EXTERNAL PARZEN
C        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
C     DOUBLE PRECISION RSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION SPCF(ISPCF,NW)
C        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
C        FOR EACH LAG WINDOW.
C     INTEGER WORK
C        THE STARTING LOCATION IN RSTAK FOR
C        THE WORK VECTOR.
C     INTEGER XAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY XAXIS.
C     DOUBLE PRECISION Y(1)
C        A DUMMY ARRAY.
C     INTEGER YAXIS
C        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY YAXIS.
C     DOUBLE PRECISION YMISS
C        A DUMMY VARIABLE.
C
C     SET UP NAME ARRAYS
C
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','V','S',' '/
C
C     SET UP
C
      OPTION(4) = .TRUE.
      OPTION(3) = .TRUE.
      OPTION(2) = .FALSE.
      OPTION(1) = .FALSE.
C
      LACOV = LAGMAX+1
C
C     COMPUTE MINIMUM ALLOWABLE STACK LENGTH
C
      IO = 1
      IF (NPRT.EQ.0) IO = 0
C
      CALL LDSCMP(4, 0, IO*(NF+5), 0, 0, 0, 'D',
     +   LAGMAX+1+IO*(2*NF+10), LDSMIN)
C
      YMISS = 1.0D0
C
      LY = 1
      LNLPPA = 1
      LPCV = NF + 5
      LWORK = LAGMAX+1
C
C     SET SIZE OF WORK AREA.
C     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
C     SET THE STACK ALLOCATION TYPE.
C
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
C
      IFP = 4
C
C     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
C
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         WORK = 1
         XAXIS = 1
         YAXIS = 1
         ISYM = 1
         ISORT = 1
      ELSE
         WORK = STKGET(LWORK,IFP)
         IF (NPRT.NE.0) THEN
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
            ISYM = STKGET(LPCV,2)
            ISORT = ISYM
         ELSE
            XAXIS = WORK
            YAXIS = WORK
            ISYM = WORK
            ISORT = ISYM
         END IF
      END IF
C
C     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
C
      CALL UFSDRV(Y, LY, YMISS, ACOV, NLPPA, SPCF, ISPCF, NF, FMIN,
     +   FMAX, FREQ, N, NW, LAGMAX, LAGS, RSTAK(WORK), LACOV, LWORK,
     +   DELTA, ISTAK(ISORT), ISTAK(ISYM), RSTAK(XAXIS), RSTAK(YAXIS),
     +   LPCV, ALPHA, NPRT, PARZEN, NMSUB, LDSMIN, LDSTAK, OPTION,
     +   LNLPPA, LY)
C
      CALL STKCLR(NALL0)
C
C     CHECK FOR ERRORS
C
      IF (IERR.EQ.0) RETURN
C
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL UFSVS (ACOV, LAGMAX, N,'/
     +   '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +   '      +            SPCF, ISPCF, FREQ, LDSTAK)')
      END
*VCVOTF
      SUBROUTINE VCVOTF(NPAR, VCV, LVCV, EST, LMASK, MASK, IVCVPT)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS THE VARIANCE COVARIANCE MATRIX
C     STORED ROW WISE WHEN IT IS TO BE LABELLED ON THE BASIS OF A MASK.
C     IF EST IS TRUE, THE COVARIANCES ARE LISTED ABOVE THE
C     DIAGONAL, THE VARIANCES ON THE DIAGONAL, AND THE CORRELATION
C     COEFFICIENTS BELOW THE DIAGONAL.
C     IF EST IS FALSE, THE STANDARD DEVIATIONS ARE LISTED ON THE
C     DIAGONAL, AND THE CORRELATION COEFFICIENTS ARE BELOW THE
C     DIAGONAL.
C
C     WRITTEN BY  -  JOHN E. KOONTZ
C          STATISTICAL ENGINEERING DIVISION
C          NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 3, 1983
C        BASED ON VCVOUT VERSION OF DECEMBER 29, 1982
C        WRITTEN BY JANET R. DONALDSON
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IVCVPT,LMASK,LVCV,NPAR
      LOGICAL
     +   EST
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VCV(LVCV)
      INTEGER
     +   MASK(LMASK)
C
C  LOCAL SCALARS
      INTEGER
     +   CODE,I,II,IPRT,MODE
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,MATPRF
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER CODE
C        IF 1 -SINGLE PRINTED, X ONLY (Y IS DUMMY ARG)
C           2 -DOUBLE PRINTED LINE, BOTH X AND Y
C     LOGICAL EST
C        AN INDICATOR USED TO DESIGNATE WHETHER THE VCV TO BE PRINTED
C        IS OF THE ESTIMATED PARAMETERS (TRUE) OR NOT (FALSE).
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER II
C        THE INDEX OF THE (I,I)TH ELEMENT OF THE VCV MATRIX
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVCVPT
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
C        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
C        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(HESSIAN)
C        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
C                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                       *INVERSE(HESSIAN)
C     INTEGER LMASK
C        THE LENGTH OF MASK.
C     INTEGER LVCV
C        THE LENGTH OF ARRAY VCV.
C     INTEGER MASK(LMASK)
C        MASK VECTOR FOR VCV.  THE INDEX OF THE ITH ELEMENT OF
C        MASK EQUAL TO ZERO IS THE LABEL IN THE OUTPUT OF VCV
C        OF THE ITH ROW AND ITH COLUMN.
C     INTEGER MODE
C        IF 0, LOWER TRIANGULAR PART PRINTED
C           1, LOWER TRIANGULAR PART IS PRINTED WITH
C              SQUARE ROOTS OF THE DIAGONAL
C           2, LOWER TRIANGLE PRINTED AS CORRELATION MATRIX
C              WITH SQUARE ROOTS ON THE DIAGONAL
C           3, FULL MATRIX PRINTED
C           4, FULL MATRIX PRINTED WITH CORRELATION MATRIX
C              PRINTED BELOW THE DIAGONAL
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     DOUBLE PRECISION VCV(LVCV)
C        THE VARIANCE COVARIANCE MATRIX.
C
C     COMMENCE BODY OF ROUTINE
C
      CALL IPRINT(IPRT)
C
      CODE = 1
C
C     DETERMINE WHETHER TO ISSUE NEGATIVE VARIANCE WARNING
C
      MODE = 0
      DO 30 I=1,NPAR
         II = I*(I-1)/2 + I
         IF (VCV(II).GT.0.0D0) GO TO 30
         IF (EST) GO TO 10
         WRITE (IPRT,1000)
         GO TO 20
C
   10    CONTINUE
         WRITE (IPRT,1050)
         IF (IVCVPT.EQ.1) WRITE (IPRT,1060)
         IF (IVCVPT.EQ.2) WRITE (IPRT,1070)
         IF (IVCVPT.EQ.3) WRITE (IPRT,1080)
   20    WRITE (IPRT,1010)
         GO TO 50
   30 CONTINUE
C
      IF (EST) GO TO 40
C
C     PRINT HEADING FOR CORRELATION ROUTINES
C
      WRITE (IPRT,1040)
      WRITE (IPRT,1030)
      MODE = 2
      GO TO 50
C
   40 CONTINUE
C
C     PRINT HEADING FOR ESTIMATION ROUTINES
C
      WRITE (IPRT,1050)
      IF (IVCVPT.EQ.1) WRITE (IPRT,1060)
      IF (IVCVPT.EQ.2) WRITE (IPRT,1070)
      IF (IVCVPT.EQ.3) WRITE (IPRT,1080)
      WRITE (IPRT,1020)
      MODE = 4
C
   50 CALL MATPRF(VCV, VCV, NPAR, MODE, CODE, LVCV, MASK, LMASK)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (///18H COVARIANCE MATRIX)
 1010 FORMAT (/39H     NONPOSITIVE VARIANCES ENCOUNTERED./10H     CORRE,
     +   39HLATION COEFFICIENTS CANNOT BE COMPUTED.)
 1020 FORMAT (4X, 36H- COVARIANCES ARE ABOVE THE DIAGONAL/4X, 7H- VARIA,
     +   24HNCES ARE ON THE DIAGONAL/4X, 27H- CORRELATION COEFFICIENTS ,
     +   22HARE BELOW THE DIAGONAL)
 1030 FORMAT (4X, 41H- STANDARD DEVIATIONS ARE ON THE DIAGONAL/4X,
     +   49H- CORRELATION COEFFICIENTS ARE BELOW THE DIAGONAL)
 1040 FORMAT (/19H CORRELATION MATRIX)
 1050 FORMAT (///45H VARIANCE-COVARIANCE AND CORRELATION MATRICES,
     +   38H OF THE ESTIMATED (UNFIXED) PARAMETERS/ 1X, 82('-'))
 1060 FORMAT (/
     +   4X, 54H- APPROXIMATION BASED ON ASSUMPTION THAT RESIDUALS ARE,
     +   6H SMALL)
 1070 FORMAT (
     +   /4X, 51H- APPROXIMATION BASED ON ASYMPTOTIC MAXIMUM LIKELIH,
     +   10HOOD THEORY)
 1080 FORMAT (/4X,
     +   51H- APPROXIMATION BASED ON ASSUMPTION THAT CONDITIONS,
     +   10H NECESSARY/
     +   5X, 41H FOR ASYMPTOTIC MAXIMUM LIKELIHOOD THEORY,
     +   18H MIGHT BE VIOLATED)
      END
*VCVOUT
      SUBROUTINE VCVOUT(NP, VCV, IVCV, EST)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBROUTINE PRINTS THE VARIANCE COVARIANCE MATRIX.
C     IF EST IS TRUE, THE COVARIANCES ARE LISTED ABOVE THE
C     DIAGONAL, THE VARIANCES ON THE DIAGONAL, AND THE CORRELATION
C     COEFFICIENTS BELOW THE DIAGONAL.
C     IF EST IS FALSE, THE STANDARD DEVIATIONS ARE LISTED ON THE
C     DIAGONAL, AND THE CORRELATION COEFFICIENTS ARE BELOW THE
C     DIAGONAL.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  APRIL 2, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   IVCV,NP
      LOGICAL
     +   EST
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VCV(IVCV,NP)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DEN,SVCVII,SVCVJJ
      INTEGER
     +   I,IPRT,J,K,MODE
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,MATPRT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DEN
C        DENOMINATOR OF (I, J) CORRELATION COEFFICIENT
C     LOGICAL EST
C        AN INDICATOR USED TO DESIGNATE WHETHER THE VCV TO BE PRINTED
C        IS OF THE ESTIMATED PARAMETERS (TRUE) OR NOT (FALSE).
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVCV
C        THE EXACT FIRST DIMENSION OF THE MATRIX VCV.
C     INTEGER J
C        THE INDEX OF THE PARAMETER BEING EXAMINED.
C     INTEGER K
C        AN INDEX VARIABLE.
C     INTEGER MODE
C        IF MODE IS 1, PRINT FULL MATRIX.
C        IF MODE IS 2, PRINT LOWER TRIANGLE WITH SQUARE ROOTS OF
C                      OF THE DIAGONAL.
C     INTEGER NP
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     DOUBLE PRECISION SVCVII, SVCVJJ
C        SQUARE ROOTS OF VCV(I, I) AND VCV(J, J)
C     DOUBLE PRECISION VCV(IVCV,NP)
C        THE VARIANCE COVARIANCE MATRIX.
C
C     COMMENCE BODY OF ROUTINE
C
      CALL IPRINT(IPRT)
C
C     DETERMINE WHETHER TO ISSUE NEGATIVE VARIANCE WARNING
C
      MODE = 2
      DO 10 I=1,NP
         IF (VCV(I,I).GT.0.0D0) GO TO 10
         WRITE (IPRT,1000)
         IF (EST) WRITE (IPRT,1050)
         WRITE (IPRT,1010)
         MODE = 0
         GO TO 70
   10 CONTINUE
C
      IF (EST) GO TO 20
C
C     PRINT HEADING FOR CORRELATION ROUTINES
C
      WRITE (IPRT,1040)
      WRITE (IPRT,1030)
      MODE = 2
      GO TO 30
C
   20 CONTINUE
C
C     PRINT HEADING FOR ESTIMATION ROUTINES
C
      WRITE (IPRT,1050)
      WRITE (IPRT,1020)
      MODE = 1
C
   30 CONTINUE
C
C     COMPUTE THE CORRELATION COEFFICIENTS AND STORE IN THE BOTTOM HALF
C     OF THE VARIANCE COVARIANCE MATRIX
C
      IF (NP.EQ.1) GO TO 60
      DO 50 J=2,NP
         K = J - 1
         SVCVJJ = 0.0D0
         IF (VCV(J,J).GT.0.0D0) SVCVJJ = SQRT(VCV(J,J))
         DO 40 I=1,K
            SVCVII = 0.0D0
            IF (VCV(I,I).GT.0.0D0) SVCVII = SQRT(VCV(I,I))
            DEN = SVCVII*SVCVJJ
            IF (DEN.LE.0.0D0) VCV(J,I) = 0.0D0
            IF (DEN.GT.0.0D0) VCV(J,I) = VCV(J,I)/DEN
   40    CONTINUE
   50 CONTINUE
C
   60 CONTINUE
C
   70 CALL MATPRT(VCV, VCV, NP, IPRT, MODE, 1, IVCV)
C
C     RESTORE THE VCV MATRIX
C
      IF (NP.EQ.1) RETURN
      DO 90 J=2,NP
         K = J - 1
         DO 80 I=1,K
            VCV(J,I) = VCV(I,J)
   80    CONTINUE
   90 CONTINUE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/18H COVARIANCE MATRIX)
 1010 FORMAT (/39H     NONPOSITIVE VARIANCES ENCOUNTERED./10H     CORRE,
     +   39HLATION COEFFICIENTS CANNOT BE COMPUTED.)
 1020 FORMAT (4X, 36H- COVARIANCES ARE ABOVE THE DIAGONAL/4X, 7H- VARIA,
     +   24HNCES ARE ON THE DIAGONAL/4X, 27H- CORRELATION COEFFICIENTS ,
     +   22HARE BELOW THE DIAGONAL)
 1030 FORMAT (4X, 41H- STANDARD DEVIATIONS ARE ON THE DIAGONAL/4X,
     +   49H- CORRELATION COEFFICIENTS ARE BELOW THE DIAGONAL)
 1040 FORMAT (/19H CORRELATION MATRIX)
 1050 FORMAT (/45H VARIANCE-COVARIANCE AND CORRELATION MATRICES,
     +   28H OF THE ESTIMATED PARAMETERS/ 1X, 72('-')/)
      END
*VERSP
      SUBROUTINE VERSP (WIDE)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRINTS THE VERSION NUMBER.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  OCTOBER 4, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      LOGICAL
     +   WIDE
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IPRT
C        THE UNIT NUMBER OF THE DEVICE USED FOR PRINTED OUTPUT.
C     LOGICAL WIDE
C        THE MAXIMUM NUMBER OF COLUMNS THE PRINTED OUTPUT CAN USE.
C
      CALL IPRINT(IPRT)
C
      IF (WIDE) THEN
         WRITE(IPRT, 1000)
      ELSE
         WRITE(IPRT, 1010)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (105X, 'STARPAC 2.08D (03/15/90)')
 1010 FORMAT (54X, 'STARPAC 2.08D (03/15/90)')
      END
*VP
      SUBROUTINE VP(YM, N, NS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IPRT,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(N,1)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  ' ',       'V',       'P',       ' ',       ' ',       ' '/
C
C     DEFINE CONSTANTS
C
C     SET DEFAULT VALUES
C
      YMMISS(1) = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 0
      ISIZE = -1
      MISS = .FALSE.
      LISYM = 1
      IRLIN = -1
      IBAR = 0
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL VP (Y, N, NS)')
      END
*VPC
      SUBROUTINE VPC(YM, N, NS, ILOG, ISIZE, IRLIN, IBAR,
     +   YLB, YUB, XLB, XINC)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IRLIN,ISIZE,N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,ISCHCK,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(N,1)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  ' ',       'V',       'P',       'C',       ' ',       ' '/
C
C     SET DEFAULT VALUES
C
      YMMISS(1) = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      ISCHCK = 0
      MISS = .FALSE.
      LISYM = 1
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL VPC (Y, N, NS, ILOG,'/
     +  '      +          ISIZE, IRLIN, IBAR, YLB, YUB, XLB, XINC)')
      END
*VPCNT
      SUBROUTINE VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE CONTROLING ROUTINE FOR USER CALLED VERTICAL PLOTS
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M,N,NS
      LOGICAL
     +   MISS,MULTI
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(*)
      INTEGER
     +   ISYM(*)
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   YMN,YMX
      INTEGER
     +   NSAMPL
      LOGICAL
     +   ERROR,XCHECK
C
C  EXTERNAL SUBROUTINES
      EXTERNAL PLTCHK,VERSP,VPLMT,VPMN
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MOD
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        A VALUE INDICATING WHETHER AN ERROR WAS DETECTEC (TRUE)
C        OR NOT (FALSE).
C     INTEGER IBAR
C        THE INDICATOR USED TO DESIGNATE WHETHER THE PLOT IS TO BE A
C        BAR GRAPH (IBAR.GE.1) OR NOT (IBAR.LE.0).
C     INTEGER IERR
C        THE COMMON VARIABLE USED TO INDICATE ERRORS,
C        IF =0, THEN NO ERRORS
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IRLIN
C        THE INDICATOR USED TO DESIGNATE WHETHER THE PLOT WILL HAVE
C        THE LOCATION OF ZERO PLOTTED AS A REFERENCE LINE (IRLIN.EQ.0),
C        THE LOCATION OF THE MEAN PLOTTED AS A REFERENCE LINE (IRLIN.GE.
C        OR NO REFERENCE LINE (IRLIN.LT.0).
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(LISYM)
C        VECTOR CONTAINING SYMBOLS FOR PLOTTING, NOT USED IN SOME CASES
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS, NSAMPL
C        THE SAMPLING FREQUENCY.
C     LOGICAL XCHECK
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER X-AXIS VALUES
C        ARE TO BE CHECKED (XCHECK = .TRUE.) OR NOT (XCHECK = .FALSE.)
C     DOUBLE PRECISION XINC
C        THE INCREMENT FOR THE X-AXIS.
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(IYM,M)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(M)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YMN, YMX
C        THE Y-AYIS LOWER AND UPPER LIMITS ACTUALLY USED.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
C     COMMENCE BODY OF ROUTINE
C
      XCHECK = .FALSE.
      CALL PLTCHK (YM, YMMISS, YM, YMMISS, N, M, IYM, MULTI,
     +   ILOG, YLB, YUB, XLB, XINC, NMSUB, MISS, XCHECK)
C
      IF (IERR.EQ.0) THEN
C
C       DETERMINE THE BOUNDS FOR THEY AXIS AND COMPLETE ERROR CHECKING
C
        NSAMPL = MAX(1, NS)
        CALL VPLMT (YM, YMMISS, N, M, IYM, YLB, YUB, YMN, YMX,
     +    ERROR, NMSUB, MISS, NSAMPL)
C
        IF (ERROR) THEN
          IERR = 1
        ELSE
C
C       PRINT PLOT
C
        IF (MOD(MAX(0,ISIZE),10).EQ.0) THEN
          CALL VERSP(.TRUE.)
        ELSE
          CALL VERSP(.FALSE.)
        END IF
        CALL VPMN (YM, YMMISS, N, M, IYM, NSAMPL, ISCHCK, ISYM, LISYM,
     +    ISIZE, YMN, YMX, XLB, XINC, MISS, ILOG, IRLIN, IBAR)
C
        END IF
      END IF
C
      RETURN
C
      END
*VPHEAD
      SUBROUTINE VPHEAD(NSAMPL, IRLIN, IBAR,
     +                  REFPT, YWIDTH, YMN, YMX,
     +                  ISIZE, ILOG, LINE, NUMCOL, ILOGY, YDMN, YDMX)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRINTS THE HEADING FOR THE VERTICAL PLOT OUTPUT.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   REFPT,YDMN,YDMX,YMN,YMX,YWIDTH
      INTEGER
     +   IBAR,ILOG,ILOGY,IRLIN,ISIZE,NSAMPL,NUMCOL
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   LINE(103)*1
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELY
      INTEGER
     +   I,ICOL,IK,IPRT,JCOL,NLABLY,NLU
      CHARACTER
     +   FMT*4,YLFMT*205,YLFMT2*205
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YLABEL(20)
      INTEGER
     +   ISPACE(20)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LOGLMT,PRTCNT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS,LOG10,MAX,MOD
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELY
C        THE SCALE INTERVAL OF THE PLOT.
C     CHARACTER FMT*4
C        *
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER ICOL, IK
C        *
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER ILOGY
C        THE VALUE OF Q (SEE ILOG)
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISIZE
C     INTEGER ISPACE(20)
C     INTEGER JCOL
C     CHARACTER*1 LINE(103)
C     INTEGER NLABLY
C     INTEGER NLU
C     INTEGER NSAMPL
C        THE SAMPLING FREQUENCY,
C        WHERE IF NSAMPL .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     INTEGER NUMCOL
C        *
C     DOUBLE PRECISION REFPT
C        THE VALUE ZERO, OR THE MEAN OF THE SERIES, WHICH EVER IS
C        REQUESTED, USED AS A PLOT REFERENCE LINE.
C     DOUBLE PRECISION YDMN, YDMX
C        THE Y-AXIS DATA LIMITS ACTUALLY USED.
C     DOUBLE PRECISION YLABEL(20)
C        THE Y-AXIS LABLES.
C     CHARACTER YLFMT*205, YLFMT2*205
C        THE FORMATS USED TO PRINT THE X-AXIS
C     DOUBLE PRECISION YMN, YMX
C        THE GRAPH AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
C     DOUBLE PRECISION YWIDTH
C        *
C
      CALL IPRINT(IPRT)
C
C     CHECK PLOT SEQUENCE.
C
      IF (NSAMPL.EQ.2) THEN
         WRITE(IPRT, 1003)
      ELSE IF (NSAMPL.EQ.3) THEN
         WRITE(IPRT, 1004)
      ELSE IF (NSAMPL.GE.4) THEN
         WRITE(IPRT, 1005) NSAMPL
      END IF
C
C     PRINT HEADINGS FOR Y
C
      IF (IBAR.EQ.0) THEN
         IF (IRLIN.GE.1) THEN
            WRITE(IPRT, 1006)
         ELSE IF (IRLIN.EQ.0) THEN
            WRITE(IPRT, 1007)
         END IF
      END IF
C
C     FIND SIZE OF PLOT TO BE CREATED
C
      IF (MOD(MAX(0,ISIZE),10).EQ.0) THEN
        NUMCOL=101
      ELSE
        NUMCOL = 51
      END IF
C
C     ADJUST FOR LOG PLOTS IF NECESSARY AND FIND AXIS LABELS
C
      CALL PRTCNT (MOD(MAX(0,ILOG),10),1,ILOGY)
      CALL LOGLMT (ILOGY, YMN, YMX, YLABEL, NUMCOL, 10, DELY, YWIDTH,
     +  NLABLY, YDMN, YDMX)
C
C     WRITE OUT THE HORIZONTAL AXIS AND THE AXIS LABELS.
C
      DO 330 ICOL=1,NUMCOL
         LINE(ICOL)='-'
  330 CONTINUE
      LINE(1)='I'
      IF (ILOGY.EQ.0) THEN
        NLU = NLABLY+1
        DO 340 ICOL=NUMCOL,1,-10
           LINE(ICOL)='I'
           NLU = NLU - 1
           ISPACE(NLU) = 1
  340   CONTINUE
      ELSE
        JCOL = 1
        LINE(JCOL) = 'I'
        NLU = NLABLY
        DO 345 IK = NLABLY,1,-1
          ICOL = ((LOG10(YLABEL(IK))-YMN)/YWIDTH)+1.5D0
          LINE(ICOL) = 'I'
          IF (ICOL-JCOL.GE.10) THEN
            ISPACE(NLU) = ICOL-JCOL-9
            NLU = NLU - 1
            YLABEL(NLU) = YLABEL(IK)
            JCOL = ICOL
          END IF
  345   CONTINUE
      END IF
      LINE(NUMCOL+1)='-'
      LINE(NUMCOL+2)=' '
C
C     CHECK X-AXIS LABELS FOR FORMAT
C
      FMT = 'F9.4'
      DO 350 I=1,NLABLY
         IF (((ABS(YLABEL(I)).GT.0.0D0).AND.
     +        (ABS(YLABEL(I)).LT.0.01D0)) .OR.
     +       ((YLABEL(I).GE.1.0D4).OR.(YLABEL(I).LE.(-1.0D3)))) THEN
           FMT = 'D9.3'
           GO TO 355
         END IF
  350 CONTINUE
  355 CONTINUE
      WRITE(YLFMT2,1000) NLABLY-NLU
      WRITE(YLFMT,YLFMT2) (FMT, ISPACE(I), I=NLABLY,NLU+1,-1), FMT
      WRITE(IPRT, YLFMT) (YLABEL(I),I=NLABLY,NLU,-1)
C
      WRITE(IPRT, 1001) '-', (LINE(ICOL), ICOL=1,NUMCOL+2)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT ('(''(11X'',', I2, '('', '', A4, '','', I2, ''X''),',
     +  ''', '', A4, '')'')')
 1001 FORMAT (' ',13X, A1, 105A1)
 1003 FORMAT(45H0NOTE THAT EVERY OTHER POINT HAS BEEN PLOTTED)
 1004 FORMAT(45H0NOTE THAT EVERY THIRD POINT HAS BEEN PLOTTED)
 1005 FORMAT(17H0NOTE THAT EVERY , I2, 25HTH POINT HAS BEEN PLOTTED)
 1006 FORMAT(/' LOCATION OF MEAN IS GIVEN BY PLOT CHARACTER M')
 1007 FORMAT(/' LOCATION OF ZERO IS GIVEN BY PLOT CHARACTER 0')
      END
*VPL
      SUBROUTINE VPL(YM, N, NS, ILOG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT (LOG PLOT OPTION).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,IPRT,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(N,1)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  ' ',       'V',       'P',       'L',       ' ',       ' '/
C
C     SET DEFAULT VALUES
C
      YMMISS(1) = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 0
      ISIZE = -1
      MISS = .FALSE.
      LISYM = 1
      IRLIN = -1
      IBAR = 0
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL VPL (Y, N, NS, ILOG)')
      END
*VPLMT
      SUBROUTINE VPLMT (YM, YMMISS, N, M, IYM, YLB, YUB, YMN,
     +  YMX, ERROR, NMSUB, MISS, NSAMPL)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE SETS THE PLOT LIMITS FOR VERTICAL PLOTS
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YLB,YMN,YMX,YUB
      INTEGER
     +   IYM,M,N,NSAMPL
      LOGICAL
     +   ERROR,MISS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(IYM,M),YMMISS(M)
      CHARACTER
     +   NMSUB(6)*1
C
C  LOCAL SCALARS
      INTEGER
     +   I,II,IPRT,J
      LOGICAL
     +   HEAD,SETLMT
C
C  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ADJLMT,EHDR,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERROR
C        A VALUE INDICATING WHETHER AN ERROR WAS DETECTED (TRUE)
C        OR NOT (FALSE).
C     LOGICAL HEAD
C        PRINT HEADING (HEAD=TRUE) OR NOT (HEAD=FALSE).
C     INTEGER I, II
C        INDEXING VARIABLES.
C     INTEGER IPRT
C        *
C     INTEGER IYM
C        ACTUAL ROW DIMENSION OF YM DECLARED IN THE USERS MAIN PROGRAM
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER M
C        THE NUMBER OF VECTORS IN YM
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS .
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NSAMPL
C        *
C     LOGICAL SETLMT
C        AN INDICATOR VARIABLE USED TO DETERMINE IF STARTING VALUES
C        FOR XLB, XINC, YMN, YMX HAVE BEEN FOUND.
C     DOUBLE PRECISION YLB
C        THE USER SUPPLIED Y-AXIS LOWER BOUND.
C     DOUBLE PRECISION YM(IYM,M)
C        THE ARRAY CONTAINING THE DEPENDENT VARIABLE(S).
C     DOUBLE PRECISION YMMISS(M)
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
C        NOT AN OBSERVATION IS MISSING.
C        IF YM(I,J) = YMMISS(J), THE VALUE IS ASSUMED MISSING, OTHERWISE
C        IT IS NOT.
C     DOUBLE PRECISION YMN, YMX
C        THE Y-AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
C     DOUBLE PRECISION YUB
C        THE USER SUPPLIED Y-AXIS UPPER BOUNDS.
C
      ERROR = .FALSE.
C
      IF (YLB.LT.YUB) THEN
C
C       SET LIMITS TO USER SPECIFIED VALUES
C
        YMN = YLB
        YMX = YUB
C
      ELSE
C
C       SET LIMITS TO RANGE OF VALUES WITHIN ANY USER SPECIFIED VALUES
C
        SETLMT = .FALSE.
        II = 1
C
C       FIND FIRST VALUE TO BE PLOTTED
C
        DO 20 I=1,N,NSAMPL
           DO 10 J=1,M
              IF (MISS .AND. MVCHK(YM(I,J),YMMISS(J))) GO TO 10
              IF ((YLB.LT.YUB) .AND. ((YM(I,J).LT.YLB) .OR.
     +           (YUB.LT.YM(I,J)))) GO TO 10
              IF (SETLMT) THEN
                YMN = MIN(YMN, YM(I,J))
                YMX = MAX(YMX, YM(I,J))
              ELSE
                YMN = YM(I,J)
                YMX = YM(I,J)
                SETLMT = .TRUE.
                II = I + NSAMPL
              END IF
   10      CONTINUE
           IF (SETLMT) GO TO 30
   20   CONTINUE
C
   30   IF (II.LE.1) THEN
C
C         NO VALUES TO BE PLOTTED.  PRINT ERROR MESSAGE
C
          ERROR = .TRUE.
          CALL IPRINT(IPRT)
          HEAD = .TRUE.
          CALL EHDR(NMSUB,HEAD)
          IF (YLB.GE.YUB) THEN
            WRITE (IPRT, 1010)
          ELSE
            WRITE (IPRT, 1020)
          END IF
          WRITE (IPRT, 1030)
C
        ELSE
C
C         FIND LIMITS FROM REMAINING VALUES
C
          IF (II.LE.N) THEN
            DO 50 I=II,N,NSAMPL
               DO 40 J=1,M
                  IF (MISS .AND. MVCHK(YM(I,J),YMMISS(J))) GO TO 40
                  IF ((YLB.LT.YUB) .AND. ((YM(I,J).LT.YLB) .OR.
     +               (YUB.LT.YM(I,J)))) GO TO 40
                  YMN = MIN(YMN, YM(I,J))
                  YMX = MAX(YMX, YM(I,J))
   40          CONTINUE
   50       CONTINUE
          END IF
        END IF
C
C       ADJUST Y AXIS LIMITS IF EQUAL
C
        IF (YMN .GE. YMX) CALL ADJLMT(YMN, YMX)
C
      END IF
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1010 FORMAT (/
     +   44H NO NON-MISSING PLOT COORDINATES WERE FOUND.)
 1020 FORMAT (/
     +   40H NO NON-MISSING VALUES WERE FOUND WITHIN,
     +   26H THE USER SUPPLIED LIMITS.)
 1030 FORMAT (/
     +   30H THE PLOT HAS BEEN SUPPRESSED.)
      END
*VPM
      SUBROUTINE VPM(YM, YMMISS, N, NS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT WITH MISSING DATA (SHORT CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(1)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IPRT,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(N,1)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  ' ',       'V',       'P',       'M',       ' ',       ' '/
C
C     SET DEFAULT VALUES
C
      M = 1
      IYM = N
      MULTI = .FALSE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 0
      ISIZE = -1
      MISS = .TRUE.
      LISYM = 1
      IRLIN = -1
      IBAR = 0
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL VPM (Y, YMISS, N, NS)')
      END
*VPMC
      SUBROUTINE VPMC(YM, YMMISS, N, NS, ILOG, ISIZE,
     +   IRLIN, IBAR, YLB, YUB, XLB, XINC)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT WITH MISSING DATA (LONG CALL).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IRLIN,ISIZE,N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(1)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,ISCHCK,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(N,1)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  ' ',       'V',       'P',       'M',       'C',       ' '/
C
C     SET DEFAULT VALUES
C
      M = 1
      IYM = N
      MULTI = .FALSE.
      ISCHCK = 0
      MISS = .TRUE.
      LISYM = 1
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL VPMC (Y, YMISS, N, NS, ILOG,'/
     +  '      +           ISIZE, IRLIN, IBAR, YLB, YUB, XLB, XINC)')
      END
*VPML
      SUBROUTINE VPML(YM, YMMISS, N, NS, ILOG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
C     PLOT WITH MISSING DATA (LOG PLOT OPTION).
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,N,NS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(1)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,IPRT,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
C
C  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(1)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LISYM
C        THE LENGTH OF ARRAY ISYM.
C     INTEGER M
C        NUMBER OF Y VECTORS
C     LOGICAL MISS
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
C        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
C     LOGICAL MULTI
C        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
C        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
C     INTEGER N
C        LENGTH OF VECTORS
C     CHARACTER*1 NMSUB(6)
C        THE CHARACTERS OF THE CALLING ROUTINES NAME.
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     DOUBLE PRECISION XINC, XLB
C        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
C     DOUBLE PRECISION YLB
C        LOWER BOUND FOR Y-AXIS.
C     DOUBLE PRECISION YM(N,1)
C        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
C     DOUBLE PRECISION YMMISS(1)
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YUB
C        UPPER BOUND FOR Y-AXIS.
C
C     SET UP NAME ARRAYS
C
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  ' ',       'V',       'P',       'M',       'L',       ' '/
C
C     SET DEFAULT VALUES
C
      M = 1
      IYM = N
      MULTI = .FALSE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 0
      ISIZE = -1
      MISS = .TRUE.
      LISYM = 1
      IRLIN = -1
      IBAR = 0
C
C     COMMENCE BODY OF ROUTINE
C
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
C
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL VPML (Y, YMISS, N, NS, ILOG)')
      END
*VPMN
      SUBROUTINE VPMN (YM, YMMISS, N, M, IYM, NSAMPL, ISCHCK, ISYM,
     +  LISYM, ISIZE, YMN, YMX, XLB, XINC, MISS, ILOG, IRLIN, IBAR)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE PRODUCES VERTICAL PLOTS
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XINC,XLB,YMN,YMX
      INTEGER
     +   IBAR,ILOG,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M,N,NSAMPL
      LOGICAL
     +   MISS
C
C  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(IYM,M),YMMISS(M)
      INTEGER
     +   ISYM(LISYM)
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   REFPT,XLABEL,YDMN,YDMX,YWIDTH,YY
      INTEGER
     +   I,IEND,ILOGY,IMAX,IMIN,IPOINT,IPRT,IPTSYM,IREFPT,J,NUMCOL,
     +   NUSED
      LOGICAL
     +   IFMISS
      CHARACTER
     +   I0*1,IBLANK*1,IM*1,IPLTCH*1,IREFCH*1,FMT*72
C
C  LOCAL ARRAYS
      INTEGER
     +   ICOUNT(103)
      CHARACTER
     +   LINE(103)*1
C
C  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN,AMEANM,IPRINT,PLINE,PLTPLX,PLTSYM,SETIV,VPHEAD
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG10,MAX,MIN
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     CHARACTER FMT*72
C        THE FORMAT FOR THE X-AXIS LABELS
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
C        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
C     CHARACTER*1 IBLANK
C        THE PLOT SYMBOL BLANK.
C     INTEGER ICOUNT(103)
C        THE NUMBER OF PLOT SYMBOLS AT EACH LOCATION.
C     INTEGER IEND
C        THE NUMBER OF LOCATIONS IN THE PLOT STRING.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     LOGICAL IFMISS
C        THE INDICATOR VARIABLE USED TO DETERMINE WHETHER THE
C        INPUT SERIES HAS MISSING DATA (TRUE) OR NOT (FALSE).
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER ILOGY
C        THE VALUE OF Q (SEE ILOG).
C     CHARACTER*1 IM
C        THE PLOT SYMBOL M.
C     INTEGER IMAX
C        THE LARGEST LOCATION IN THE PLOT STRING BEING DEFINED.
C     INTEGER IMIN
C        THE SMALLEST LOCATION IN THE PLOT STRING BEING DEFINED.
C     CHARACTER*1 IPLTCH
C        THE PLOT CHARACTER USED FOR A GIVEN LINE OF THE PLOT.
C     INTEGER IPOINT
C        THE LOCATION IN THE PLOT STRING OF THE VALUE BEING PLOTTED.
C     INTEGER IPRT
C        *
C     INTEGER IPTSYM
C        AN INDICATOR VARIABLE USED TO DESIGNATE THE TYPE
C        OF PLOT.  IF ISCHCK = 1, THE PLOT IS A SYMPLE PAGE
C        OR VERTICAL PLOT.  IF ISCHCK = 2, THE PLOT IS A SYMBOL
C        PLOT.  IF ISCHCK = 3, THE PLOT IS A MULTIVARIATE PLOT.
C     CHARACTER*1 IREFCH
C        THE PLOT SYMBOL USED TO IDENTIFY THE PLOT REFERENCE LINE.
C     INTEGER IREFPT
C        THE LOCATION IN THE PLOT STRING FOR THE VALUE ZERO, OR
C        SERIES MEAN, WHICH EVER WAS REQUESTED.
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISCHCK
C        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
C           WILL BE DESIGNATED, WHERE
C           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
C             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
C           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
C             N VECTOR ISYM
C           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
C             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(LISYM)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER IYM
C        THE EXACT VALUE OF THE FIRST DIMENSION OF THE MATRIX YM.
C     CHARACTER*1 I0
C        THE PLOT SYMBOL -0-.
C     INTEGER J
C        AN INDEX VARIABLE.
C     CHARACTER*1 LINE(103)
C        THE VECTOR USED FOR THE PLOT STRING.
C     INTEGER LISYM
C        *
C     INTEGER M
C        THE NUMBER OF COLUMNS OF DATA IN YM.
C     LOGICAL MISS
C        *
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS .
C     INTEGER NSAMPL
C        THE SAMPLING FREQUENCY ACTUALLY USED.
C     INTEGER NUMCOL
C        *
C     INTEGER NUSED
C        THE NUMBER OF ACTIVE OBSERVATIONS.
C     DOUBLE PRECISION REFPT
C        THE VALUE ZERO, OR THE MEAN OF THE SERIES, WHICH EVER IS
C        REQUESTED, USED AS A PLOT REFERENCE LINE.
C     DOUBLE PRECISION XINC
C        THE VARIABLE USED TO SPECIFY THE INCREMENT FOR XLABEL.
C     DOUBLE PRECISION XLABEL
C        THE VALUE USED FOR THE LABELS ON THE RIGHT SIDE OF THE PLOT.
C     DOUBLE PRECISION XLB
C        THE STARTING VALUE FOR LABELS ON THE RIGHT SIDE OF THE GRAPH.
C     DOUBLE PRECISION YDMN, YDMX
C        THE Y-AXIS DATA LIMITS ACTUALLY USED.
C     DOUBLE PRECISION YM(IYM,M)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YMMISS(M)
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
C        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF YM(I) = YMMISS
C        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
C     DOUBLE PRECISION YMN, YMX
C        THE GRAPH AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
C     DOUBLE PRECISION YWIDTH
C        THE SCALE INTERVAL OF THE PLOT.
C     DOUBLE PRECISION YY
C        THE VALUE OF YM ACTUALLY BEING PLOTTED
C
C
      DATA IBLANK/' '/, IM/'M'/, I0/'0'/
C
C     PRINT PLOT HEADINGS
C
      CALL IPRINT(IPRT)
      CALL VPHEAD(NSAMPL, IRLIN, IBAR,
     +            REFPT, YWIDTH, YMN, YMX, ISIZE, ILOG,
     +            LINE, NUMCOL, ILOGY, YDMN, YDMX)
      IEND = NUMCOL + 2
C
C     COMPUTE REFERENCE POINT OF GRAPH, IF REQUIRED.
C
      IF (IRLIN.GE.0) THEN
        IF (IRLIN.EQ.0) THEN
C
C         REFERENCE POINT IS ZERO
C
          REFPT = 0.0D0
          IREFCH = I0
        ELSE
C
C         REFERENCE POINT IS MEAN
C
          IF (MISS) THEN
            CALL AMEANM(YM, YMMISS, N, NUSED, REFPT)
          ELSE
            CALL AMEAN(YM, N, REFPT)
          END IF
          IF (ILOGY.NE.0) REFPT = LOG10(REFPT)
          IREFCH = IM
        END IF
C
C       COMPUTE LOCATION OF REFPT IN PLOT STRING
C
        CALL PLTPLX(REFPT, YMN, YWIDTH, IREFPT, IEND)
      ELSE
        IREFPT = 1
      END IF
C
C     BEGIN PLOTTING
C
      IPTSYM = ISCHCK + 1
      XLABEL = XLB
      DO 50 I=1,N,NSAMPL
         CALL PLINE(1, IEND, IBLANK, LINE)
         CALL SETIV(ICOUNT, IEND, 0)
         IFMISS = .FALSE.
         IPOINT = 1
         DO 30 J=1,M
           IF (MISS) THEN
             IFMISS = (IFMISS .OR. (MVCHK(YM(I,J),YMMISS(J))))
             IF (.NOT.(MVCHK(YM(I,J),YMMISS(J)))) THEN
               IF (ILOGY.EQ.0) THEN
                 YY = YM(I,J)
               ELSE
                 YY = LOG10(YM(I,J))
               END IF
               IF ((YY.GE.YDMN) .AND. (YY.LE.YDMX)) THEN
                CALL PLTPLX(YY, YMN, YWIDTH, IPOINT, IEND)
                CALL PLTSYM(IPTSYM, I, J, ISYM, N, IPOINT, LINE, ICOUNT)
                IPLTCH = LINE(IPOINT)
               ELSE
                IPOINT = IREFPT
                IPLTCH = IBLANK
               END IF
             END IF
           ELSE
             IF (ILOGY.EQ.0) THEN
               YY = YM(I,J)
             ELSE
               YY = LOG10(YM(I,J))
             END IF
             IF ((YY.GE.YDMN) .AND. (YY.LE. YDMX)) THEN
                CALL PLTPLX(YY, YMN, YWIDTH, IPOINT, IEND)
                CALL PLTSYM(IPTSYM, I, J, ISYM, N, IPOINT, LINE, ICOUNT)
                IPLTCH = LINE(IPOINT)
             ELSE
                IPOINT = IREFPT
                IPLTCH = IBLANK
             END IF
           END IF
   30    CONTINUE
         IF ((IBAR.GE.1) .AND. (.NOT.IFMISS)) THEN
            IMIN = MIN(IPOINT,IREFPT)
            IMAX = MAX(IPOINT,IREFPT)
            CALL PLINE(IMIN, IMAX, IPLTCH, LINE)
         ELSE IF (IRLIN.GE.0) THEN
            LINE(IREFPT) = IREFCH
         END IF
C
         IF (IFMISS) THEN
           WRITE(FMT,1000) NUMCOL, '8H MISSING'
           WRITE(IPRT,FMT) XLABEL, (LINE(J), J=1,IEND)
         ELSE
           WRITE(FMT,1000) NUMCOL, '1X, G11.5 '
           IF (M.EQ.1) THEN
             WRITE(IPRT,FMT) XLABEL, (LINE(J),J=1,IEND), YM(I,1)
           ELSE
             WRITE(IPRT,FMT) XLABEL, (LINE(J),J=1,IEND)
           END IF
         END IF
         XLABEL = XLABEL + XINC*NSAMPL
   50 CONTINUE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT('(1X,G11.5,1X,A1,''I'',', I3, 'A1,''I'',A1,',A10,')')
      END
*XACF
      SUBROUTINE XACF(LDS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST THE TIME SERIES CORRELATION SUBROUTINES
C
C     SERIES Y IS LISTED AS SERIES X1 ON PAGE 362 IN JENKINS AND WATTS.
C
C     SERIES YD IS LISTED AS SERIES G ON PAGE 531 OF BOX AND JENKINS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDS
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   AMISS,YMISS
      INTEGER
     +   I,IAR,IPRT,ITEST,LACOV,LAGMAX,LDSTAK,LYFFT,N,NFAC,NPRT,NYD
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(21),PHI(21),Y(100),YD(150),YFFT(150)
      INTEGER
     +   IOD(2),ND(2),NLPPA(21)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACF,ACFD,ACFF,ACFFS,ACFM,ACFMS,ACFS,IPRINT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(21)
C        THE AUTOCOVARIANCE VECTOR.
C     DOUBLE PRECISION AMISS
C        THE MISSING VALUE CODE FOR THE RETURNED ACVF ESTIMATES
C        (VECTOR ACOV).
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C     INTEGER IOD(2)
C        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ITEST
C        THE NUMBER OF THE TEST BEING RUN
C     INTEGER LACOV
C        THE LENGTH OF THE ACVF RELATED VECTORS.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE REQUESTED.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LYFFT
C        THE LENGTH OF THE ARRAYS USED WHEN THE COMPUTATIONS ARE
C        PERFORMED BY THE FFT.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER ND(2)
C        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE
C        FACTORS ARE TO BE APPLIED.
C     INTEGER NFAC
C        THE NUMBER OF DIFFERENCE FACTORS.
C     INTEGER NLPPA(21)
C        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
C        USED TO COMPUTE EACH ACVF ESTIMATE.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO OUTPUT IS MADE.
C     INTEGER NYD
C        THE NUMBER OF OBSERVATIONS IN THE SERIES TO BE DIFFERENCED.
C     DOUBLE PRECISION PHI(21)
C        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
C        ORDER.
C     DOUBLE PRECISION Y(100), YD(150)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
C     DOUBLE PRECISION YFFT(150)
C        THE VECTORS USED FOR STORING THE SERIES FOR THE ROUTINES
C        USING THE FFT.
C     DOUBLE PRECISION YMISS
C        THE MISSING VALUE CODES FOR SERIES Y AND YM.
C
      DATA    Y(  1),   Y(  2),   Y(  3),   Y(  4),   Y(  5),   Y(  6)
     +    / -2.07D0, -1.15D0,  0.69D0, -0.46D0, -1.49D0, -0.70D0/
      DATA    Y(  7),   Y(  8),   Y(  9),   Y( 10),   Y( 11),   Y( 12)
     +    / -1.07D0, -0.69D0, -0.68D0,  1.27D0, -1.05D0, -0.05D0/
      DATA    Y( 13),   Y( 14),   Y( 15),   Y( 16),   Y( 17),   Y( 18)
     +    / -0.84D0, -0.62D0, -0.49D0, -1.29D0, -0.49D0, -1.06D0/
      DATA    Y( 19),   Y( 20),   Y( 21),   Y( 22),   Y( 23),   Y( 24)
     +    / -0.38D0, -0.52D0, -0.13D0,  1.30D0, -1.51D0, -0.43D0/
      DATA    Y( 25),   Y( 26),   Y( 27),   Y( 28),   Y( 29),   Y( 30)
     +    / -1.33D0, -0.78D0,  0.31D0, -0.95D0, -0.90D0, -0.30D0/
      DATA    Y( 31),   Y( 32),   Y( 33),   Y( 34),   Y( 35),   Y( 36)
     +    / -1.02D0, -0.53D0,  0.15D0,  1.40D0,  1.22D0,  0.59D0/
      DATA    Y( 37),   Y( 38),   Y( 39),   Y( 40),   Y( 41),   Y( 42)
     +    /  0.70D0,  1.70D0,  2.78D0,  1.98D0,  1.39D0,  1.85D0/
      DATA    Y( 43),   Y( 44),   Y( 45),   Y( 46),   Y( 47),   Y( 48)
     +    /  2.60D0,  0.51D0,  2.77D0,  1.16D0,  1.07D0, -0.48D0/
      DATA    Y( 49),   Y( 50),   Y( 51),   Y( 52),   Y( 53),   Y( 54)
     +    / -0.52D0,  0.37D0,  0.00D0, -1.99D0, -1.75D0,  0.70D0/
      DATA    Y( 55),   Y( 56),   Y( 57),   Y( 58),   Y( 59),   Y( 60)
     +    /  0.73D0,  1.16D0,  0.06D0, -0.02D0,  1.10D0, -0.35D0/
      DATA    Y( 61),   Y( 62),   Y( 63),   Y( 64),   Y( 65),   Y( 66)
     +    / -1.67D0, -1.57D0,  1.16D0,  1.84D0,  3.35D0,  0.40D0/
      DATA    Y( 67),   Y( 68),   Y( 69),   Y( 70),   Y( 71),   Y( 72)
     +    /  0.45D0,  1.30D0,  0.93D0,  1.17D0, -1.74D0, -1.28D0/
      DATA    Y( 73),   Y( 74),   Y( 75),   Y( 76),   Y( 77),   Y( 78)
     +    / -0.07D0,  1.50D0,  0.53D0,  0.20D0, -0.42D0,  1.18D0/
      DATA    Y( 79),   Y( 80),   Y( 81),   Y( 82),   Y( 83),   Y( 84)
     +    /  0.82D0,  1.50D0,  2.92D0,  1.18D0,  1.23D0,  3.16D0/
      DATA    Y( 85),   Y( 86),   Y( 87),   Y( 88),   Y( 89),   Y( 90)
     +    /  0.79D0,  0.68D0,  1.14D0,  1.02D0,  1.02D0, -0.71D0/
      DATA    Y( 91),   Y( 92),   Y( 93),   Y( 94),   Y( 95),   Y( 96)
     +    / -0.17D0, -1.50D0, -0.26D0, -0.38D0,  0.93D0, -0.33D0/
      DATA    Y( 97),   Y( 98),   Y( 99),   Y(100)
     +    / -1.12D0, -2.95D0, -2.09D0, -1.11D0                    /
C
      DATA   YD(  1),  YD(  2),  YD(  3),  YD(  4),  YD(  5),  YD(  6)
     +    /  112.0D0, 118.0D0, 132.0D0, 129.0D0, 121.0D0, 135.0D0/
      DATA   YD(  7),  YD(  8),  YD(  9),  YD( 10),  YD( 11),  YD( 12)
     +    /  148.0D0, 148.0D0, 136.0D0, 119.0D0, 104.0D0, 118.0D0/
      DATA   YD( 13),  YD( 14),  YD( 15),  YD( 16),  YD( 17),  YD( 18)
     +    /  115.0D0, 126.0D0, 141.0D0, 135.0D0, 125.0D0, 149.0D0/
      DATA   YD( 19),  YD( 20),  YD( 21),  YD( 22),  YD( 23),  YD( 24)
     +    /  170.0D0, 170.0D0, 158.0D0, 133.0D0, 114.0D0, 140.0D0/
      DATA   YD( 25),  YD( 26),  YD( 27),  YD( 28),  YD( 29),  YD( 30)
     +    /  145.0D0, 150.0D0, 178.0D0, 163.0D0, 172.0D0, 178.0D0/
      DATA   YD( 31),  YD( 32),  YD( 33),  YD( 34),  YD( 35),  YD( 36)
     +    /  199.0D0, 199.0D0, 184.0D0, 162.0D0, 146.0D0, 166.0D0/
      DATA   YD( 37),  YD( 38),  YD( 39),  YD( 40),  YD( 41),  YD( 42)
     +    /  171.0D0, 180.0D0, 193.0D0, 181.0D0, 183.0D0, 218.0D0/
      DATA   YD( 43),  YD( 44),  YD( 45),  YD( 46),  YD( 47),  YD( 48)
     +    /  230.0D0, 242.0D0, 209.0D0, 191.0D0, 172.0D0, 194.0D0/
      DATA   YD( 49),  YD( 50),  YD( 51),  YD( 52),  YD( 53),  YD( 54)
     +    /  196.0D0, 196.0D0, 236.0D0, 235.0D0, 229.0D0, 243.0D0/
      DATA   YD( 55),  YD( 56),  YD( 57),  YD( 58),  YD( 59),  YD( 60)
     +    /  264.0D0, 272.0D0, 237.0D0, 211.0D0, 180.0D0, 201.0D0/
      DATA   YD( 61),  YD( 62),  YD( 63),  YD( 64),  YD( 65),  YD( 66)
     +    /  204.0D0, 188.0D0, 235.0D0, 227.0D0, 234.0D0, 264.0D0/
      DATA   YD( 67),  YD( 68),  YD( 69),  YD( 70),  YD( 71),  YD( 72)
     +    /  302.0D0, 293.0D0, 259.0D0, 229.0D0, 203.0D0, 229.0D0/
      DATA   YD( 73),  YD( 74),  YD( 75),  YD( 76),  YD( 77),  YD( 78)
     +    /  242.0D0, 233.0D0, 267.0D0, 269.0D0, 270.0D0, 315.0D0/
      DATA   YD( 79),  YD( 80),  YD( 81),  YD( 82),  YD( 83),  YD( 84)
     +    /  364.0D0, 347.0D0, 312.0D0, 274.0D0, 237.0D0, 278.0D0/
      DATA   YD( 85),  YD( 86),  YD( 87),  YD( 88),  YD( 89),  YD( 90)
     +    /  284.0D0, 277.0D0, 317.0D0, 313.0D0, 318.0D0, 374.0D0/
      DATA   YD( 91),  YD( 92),  YD( 93),  YD( 94),  YD( 95),  YD( 96)
     +    /  413.0D0, 405.0D0, 355.0D0, 306.0D0, 271.0D0, 306.0D0/
      DATA   YD( 97),  YD( 98),  YD( 99),  YD(100),  YD(101),  YD(102)
     +    /  315.0D0, 301.0D0, 356.0D0, 348.0D0, 355.0D0, 422.0D0/
      DATA   YD(103),  YD(104),  YD(105),  YD(106),  YD(107),  YD(108)
     +    /  465.0D0, 467.0D0, 404.0D0, 347.0D0, 305.0D0, 336.0D0/
      DATA   YD(109),  YD(110),  YD(111),  YD(112),  YD(113),  YD(114)
     +    /  340.0D0, 318.0D0, 362.0D0, 348.0D0, 363.0D0, 435.0D0/
      DATA   YD(115),  YD(116),  YD(117),  YD(118),  YD(119),  YD(120)
     +    /  491.0D0, 505.0D0, 404.0D0, 359.0D0, 310.0D0, 337.0D0/
      DATA   YD(121),  YD(122),  YD(123),  YD(124),  YD(125),  YD(126)
     +    /  360.0D0, 342.0D0, 406.0D0, 396.0D0, 420.0D0, 472.0D0/
      DATA   YD(127),  YD(128),  YD(129),  YD(130),  YD(131),  YD(132)
     +    /  548.0D0, 559.0D0, 463.0D0, 407.0D0, 362.0D0, 405.0D0/
      DATA   YD(133),  YD(134),  YD(135),  YD(136),  YD(137),  YD(138)
     +    /  417.0D0, 391.0D0, 419.0D0, 461.0D0, 472.0D0, 535.0D0/
      DATA   YD(139),  YD(140),  YD(141),  YD(142),  YD(143),  YD(144)
     +    /  622.0D0, 606.0D0, 508.0D0, 461.0D0, 390.0D0, 432.0D0/
C
      CALL IPRINT(IPRT)
      ITEST = 1
      LDSTAK = LDS
C
      N = 100
      LAGMAX = 20
      NPRT = 1
      LYFFT = 150
      LACOV = 21
      NYD = 144
      NFAC = 2
      ND(1) = 1
      ND(2) = 1
      IOD(1) = 12
      IOD(2) = 1
      YMISS = 1.16D0
C
C     TEST OF ACF
C
    5 WRITE (IPRT,1000)
      CALL ACF(Y, N)
      WRITE (IPRT,1010) IERR
C
C     TEST OF ACFS
C
      WRITE (IPRT,1020)
      CALL ACFS(Y, N, LAGMAX, LACOV, ACOV, IAR, PHI, NPRT, LDSTAK)
      WRITE (IPRT,1010) IERR
C
C     PRINT STORAGE FROM ACFS
C
      IF (IERR.EQ.0) THEN
        WRITE (IPRT,1030) (ACOV(I),I=1,LAGMAX+1)
        WRITE (IPRT,1030) (PHI(I),I=1,IAR)
      END IF
C
C     TEST OF ACFD
C
      WRITE (IPRT,1040)
      CALL ACFD(YD, NYD, LAGMAX, NFAC, ND, IOD, LDSTAK)
      WRITE (IPRT,1010) IERR
C
C     TEST OF ACFM
C
      WRITE (IPRT,1050)
      CALL ACFM(Y, YMISS, N)
      WRITE (IPRT,1010) IERR
C
C     TEST OF ACFMS
C
      WRITE (IPRT,1120)
      CALL ACFMS(Y, YMISS, N, LAGMAX, LACOV, ACOV, AMISS, NLPPA, NPRT,
     +   LDSTAK)
      WRITE (IPRT,1010) IERR
C
C     PRINT STORAGE FROM ACFMS
C
      IF (IERR.EQ.0) THEN
        WRITE (IPRT,1030) (ACOV(I),I=1,LAGMAX+1)
        WRITE (IPRT,1140) (NLPPA(I),I=1,LAGMAX+1)
      END IF
C
C     COPY DATA INTO YFFT FOR ACFF
C
      DO 10 I=1,N
         YFFT(I) = Y(I)
   10 CONTINUE
C
C     TEST OF ACFF
C
      WRITE (IPRT,1090)
      CALL ACFF(YFFT, N, LYFFT, LDSTAK)
      WRITE (IPRT,1010) IERR
C
C     COPY DATA INTO YFFT FOR ACFFS
C
      DO 20 I=1,N
         YFFT(I) = Y(I)
   20 CONTINUE
C
C     TEST OF ACFFS
C
      WRITE (IPRT,1130)
      CALL ACFFS(YFFT, N, LYFFT, LDSTAK, LAGMAX, LACOV, ACOV, IAR, PHI,
     +   NPRT)
      WRITE (IPRT,1010) IERR
C
C     PRINT STORAGE FROM ACFFS
C
      IF (IERR.EQ.0) THEN
        WRITE (IPRT,1030) (ACOV(I),I=1,LAGMAX+1)
        WRITE (IPRT,1030) (PHI(I),I=1,IAR)
      END IF
C
      GO TO (100, 200, 300, 400), ITEST
C
C     TEST MINIMUM PROBLEM SIZE
C
  100 ITEST = ITEST + 1
      N = 13
      LAGMAX = 1
      NFAC = 1
      ND(1) = 1
      IOD(1) = 1
      GO TO 5
C
C     CHECK ERROR HANDLING
C
  200 ITEST = ITEST + 1
      N = 0
      LAGMAX = 20
      LYFFT = 0
      LACOV = 0
      NYD = 0
      NFAC = 1
      ND(1) = 0
      IOD(1) = 0
      GO TO 5
C
C     CHECK ERROR HANDLING
C
  300 ITEST = ITEST + 1
      N = 100
      LAGMAX = 0
      LYFFT = 0
      LACOV = 0
      NYD = 144
      NFAC = 0
      LDSTAK = 0
      GO TO 5
C
  400 RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT ('1TEST OF ACF')
 1010 FORMAT (8H IERR IS, I5)
 1020 FORMAT ('1', 12HTEST OF ACFS)
 1030 FORMAT (9F10.5)
 1040 FORMAT ('1', 12HTEST OF ACFD)
 1050 FORMAT ('1', 12HTEST OF ACFM)
 1090 FORMAT ('1', 12HTEST OF ACFF)
 1120 FORMAT ('1', 13HTEST OF ACFMS)
 1130 FORMAT ('1', 13HTEST OF ACFFS)
 1140 FORMAT (9I10)
      END
*XAIMD
      SUBROUTINE XAIMD(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     DEMONSTRATE THE USER CALLABLE ROUTINES IN THE ARIMA FAMILY.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  SEPTEMBER 1, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   I,IFCST,IPRT,IVAPRX,IVCV,MIT,MXFAC,MXFC,MXFCO,MXN,MXPAR,N,
     +   NFAC,NFCST,NFCSTO,NPAR,NPARE,NPRT,NTEST
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FCST(200,10),FCSTSD(200,10),PAR(10),PV(200),RES(200),
     +   SCALE(10),SDPV(200),SDRES(200),STP(10),VCV(10,10),Y(200)
      INTEGER
     +   IFCSTO(10),IFIXED(10),MSPEC(4,10)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AIME,AIMEC,AIMES,AIMF,AIMFS,AIMX1,FITXSP,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FCST(200, 10)
C        THE FORECASTS.
C     DOUBLE PRECISION FCSTSD(200, 10)
C        THE STANDARD DEVIATIONS OF THE FORECASTS.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFCST
C        THE FIRST DIMENSION OF THE ARRAY FCST.
C     INTEGER IFCSTO(10)
C        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
C     INTEGER IFIXED(10)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     INTEGER MSPEC(4,10)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH
C        FACTOR.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NFCST
C        THE NUMBER OF FORECASTS.
C     INTEGER NFCSTO
C        THE NUMBER OF THE ORIGINS.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     INTEGER NTEST
C        THE NUMBER OF THE CURRENT TEST.
C     DOUBLE PRECISION PAR(10)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION PV(200)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(200)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     DOUBLE PRECISION SCALE(10)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
C     DOUBLE PRECISION SDPV(200)
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(200)
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(10)
C        THE RCSTEP SIZE ARRAY.
C     DOUBLE PRECISION VCV(10,10)
C        THE COVARIANCE MATRIX.
C     DOUBLE PRECISION Y(200)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     DEFINE CONSTANTS
C
      DATA    Y(  1),   Y(  2),   Y(  3),   Y(  4),   Y(  5),   Y(  6)
     +    / 112.0D0, 118.0D0, 132.0D0, 129.0D0, 121.0D0, 135.0D0/
      DATA    Y(  7),   Y(  8),   Y(  9),   Y( 10),   Y( 11),   Y( 12)
     +    / 148.0D0, 148.0D0, 136.0D0, 119.0D0, 104.0D0, 118.0D0/
      DATA    Y( 13),   Y( 14),   Y( 15),   Y( 16),   Y( 17),   Y( 18)
     +    / 115.0D0, 126.0D0, 141.0D0, 135.0D0, 125.0D0, 149.0D0/
      DATA    Y( 19),   Y( 20),   Y( 21),   Y( 22),   Y( 23),   Y( 24)
     +    / 170.0D0, 170.0D0, 158.0D0, 133.0D0, 114.0D0, 140.0D0/
      DATA    Y( 25),   Y( 26),   Y( 27),   Y( 28),   Y( 29),   Y( 30)
     +    / 145.0D0, 150.0D0, 178.0D0, 163.0D0, 172.0D0, 178.0D0/
      DATA    Y( 31),   Y( 32),   Y( 33),   Y( 34),   Y( 35),   Y( 36)
     +    / 199.0D0, 199.0D0, 184.0D0, 162.0D0, 146.0D0, 166.0D0/
      DATA    Y( 37),   Y( 38),   Y( 39),   Y( 40),   Y( 41),   Y( 42)
     +    / 171.0D0, 180.0D0, 193.0D0, 181.0D0, 183.0D0, 218.0D0/
      DATA    Y( 43),   Y( 44),   Y( 45),   Y( 46),   Y( 47),   Y( 48)
     +    / 230.0D0, 242.0D0, 209.0D0, 191.0D0, 172.0D0, 194.0D0/
      DATA    Y( 49),   Y( 50),   Y( 51),   Y( 52),   Y( 53),   Y( 54)
     +    / 196.0D0, 196.0D0, 236.0D0, 235.0D0, 229.0D0, 243.0D0/
      DATA    Y( 55),   Y( 56),   Y( 57),   Y( 58),   Y( 59),   Y( 60)
     +    / 264.0D0, 272.0D0, 237.0D0, 211.0D0, 180.0D0, 201.0D0/
      DATA    Y( 61),   Y( 62),   Y( 63),   Y( 64),   Y( 65),   Y( 66)
     +    / 204.0D0, 188.0D0, 235.0D0, 227.0D0, 234.0D0, 264.0D0/
      DATA    Y( 67),   Y( 68),   Y( 69),   Y( 70),   Y( 71),   Y( 72)
     +    / 302.0D0, 293.0D0, 259.0D0, 229.0D0, 203.0D0, 229.0D0/
      DATA    Y( 73),   Y( 74),   Y( 75),   Y( 76),   Y( 77),   Y( 78)
     +    / 242.0D0, 233.0D0, 267.0D0, 269.0D0, 270.0D0, 315.0D0/
      DATA    Y( 79),   Y( 80),   Y( 81),   Y( 82),   Y( 83),   Y( 84)
     +    / 364.0D0, 347.0D0, 312.0D0, 274.0D0, 237.0D0, 278.0D0/
      DATA    Y( 85),   Y( 86),   Y( 87),   Y( 88),   Y( 89),   Y( 90)
     +    / 284.0D0, 277.0D0, 317.0D0, 313.0D0, 318.0D0, 374.0D0/
      DATA    Y( 91),   Y( 92),   Y( 93),   Y( 94),   Y( 95),   Y( 96)
     +    / 413.0D0, 405.0D0, 355.0D0, 306.0D0, 271.0D0, 306.0D0/
      DATA    Y( 97),   Y( 98),   Y( 99),   Y(100),   Y(101),   Y(102)
     +    / 315.0D0, 301.0D0, 356.0D0, 348.0D0, 355.0D0, 422.0D0/
      DATA    Y(103),   Y(104),   Y(105),   Y(106),   Y(107),   Y(108)
     +    / 465.0D0, 467.0D0, 404.0D0, 347.0D0, 305.0D0, 336.0D0/
      DATA    Y(109),   Y(110),   Y(111),   Y(112),   Y(113),   Y(114)
     +    / 340.0D0, 318.0D0, 362.0D0, 348.0D0, 363.0D0, 435.0D0/
      DATA    Y(115),   Y(116),   Y(117),   Y(118),   Y(119),   Y(120)
     +    / 491.0D0, 505.0D0, 404.0D0, 359.0D0, 310.0D0, 337.0D0/
      DATA    Y(121),   Y(122),   Y(123),   Y(124),   Y(125),   Y(126)
     +    / 360.0D0, 342.0D0, 406.0D0, 396.0D0, 420.0D0, 472.0D0/
      DATA    Y(127),   Y(128),   Y(129),   Y(130),   Y(131),   Y(132)
     +    / 548.0D0, 559.0D0, 463.0D0, 407.0D0, 362.0D0, 405.0D0/
      DATA    Y(133),   Y(134),   Y(135),   Y(136),   Y(137),   Y(138)
     +    / 417.0D0, 391.0D0, 419.0D0, 461.0D0, 472.0D0, 535.0D0/
      DATA    Y(139),   Y(140),   Y(141),   Y(142),   Y(143),   Y(144)
     +    / 622.0D0, 606.0D0, 508.0D0, 461.0D0, 390.0D0, 432.0D0/
C
      CALL IPRINT(IPRT)
C
      DO 10 I = 1, 144
        Y(I) = LOG(Y(I))
   10 CONTINUE
C
C     SET DIMENSIONS
C
      MXN = 200
      MXPAR = 10
      MXFC = 200
      MXFCO = 10
      MXFAC = 10
C
C
      NTEST = 0
C
C
C     **TEST ON NORMAL STATEMENT**
C
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1000)
      CALL AIMX1(MXN, MXPAR, MXFC, MXFCO, MXFAC,
     +   1, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV,
     +   NFCST, NFCSTO, IFCSTO, FCST, IFCST, FCSTSD)
      CALL AIME (Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK)
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV,
     +   N, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1010)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL AIMX1(MXN, MXPAR, MXFC, MXFCO, MXFAC,
     +   1, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV,
     +   NFCST, NFCSTO, IFCSTO, FCST, IFCST, FCSTSD)
      CALL AIMEC(Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV,
     +   N, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1020)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL AIMX1(MXN, MXPAR, MXFC, MXFCO, MXFAC,
     +   1, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV,
     +   NFCST, NFCSTO, IFCSTO, FCST, IFCST, FCSTSD)
      CALL AIMES(Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV,
     +   N, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1030)
      CALL AIMX1(MXN, MXPAR, MXFC, MXFCO, MXFAC,
     +   1, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV,
     +   NFCST, NFCSTO, IFCSTO, FCST, IFCST, FCSTSD)
      CALL AIMF (Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK)
      WRITE (IPRT,1120) IERR
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1040)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL AIMX1(MXN, MXPAR, MXFC, MXFCO, MXFAC,
     +   1, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV,
     +   NFCST, NFCSTO, IFCSTO, FCST, IFCST, FCSTSD)
      CALL AIMFS(Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK,
     +   NFCST, NFCSTO, IFCSTO, NPRT, FCST, IFCST, FCSTSD)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR, FCST(1,1), FCST(1,2), FCST(1,3), FCSTSD, VCV,
     +  N, NPAR, IVCV, N, NPARE, RSD)
C
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (14H TEST OF AIM  )
 1010 FORMAT (15H TEST OF AIMC  )
 1020 FORMAT (15H TEST OF AIMS  )
 1030 FORMAT (14H TEST OF AIMF )
 1040 FORMAT (15H TEST OF AIMFS )
 1120 FORMAT (/29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1130 FORMAT (15H NORMAL PROBLEM)
 1330 FORMAT ('1ARIMA TEST NUMBER', I5)
 1340 FORMAT (//24H INPUT   -  IFIXED(1) = , I6, 9X, ', STP(1) = ',
     +   G15.8, ',    MIT = ',I5, ', STOPSS = ', G15.8, 10H, STOPP = ,
     +   G15.8/13X, 'SCALE(1) = ', G15.8, ',  DELTA = ', G15.8,
     +   ', IVAPRX = ', I5, ',   NPRT = ', I5//)
 1350 FORMAT (//24H OUTPUT  -  IFIXED(1) = , I6, 9X, ', STP(1) = ',
     +   G15.8, ',    MIT = ',I5, ', STOPSS = ', G15.8, 10H, STOPP = ,
     +   G15.8/13X, 'SCALE(1) = ', G15.8, ',  DELTA = ', G15.8,
     +   ', IVAPRX = ', I5, ',   NPRT = ', I5//)
      END
*XAIMT
      SUBROUTINE XAIMT(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST THE TIME SERIES MODEL ESTIMATION ROUTINES.
C
C     SERIES Y IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND JENKINS
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   I,IFCST,IPRT,IVAPRX,IVCV,MIT,NFAC,NPAR,NPARE,NPRT,NY
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FCST(50,5),FCSTSD(50),PAR(50),PV(200),RES(200),SCALE(50),
     +   SDPV(200),SDRES(200),STP(50),VCV(10,10),Y(200),YLOG(200),
     +   YT(200)
      INTEGER
     +   IFIXED(50),MSPEC(4,50)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AIME,AIMEC,AIMES,AIMF,AIMFS,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FCST(50,5)
C        THE FORECASTS.
C     DOUBLE PRECISION FCSTSD(50)
C        THE STANDARD DEVIATIONS OF THE FORECASTS.
C     INTEGER I
C        *
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFCST
C        THE FIRST DIMENSION OF THE ARRAY FCST.
C     INTEGER IFIXED(50)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     INTEGER MSPEC(4,50)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH
C        FACTOR.
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     INTEGER NY
C        THE NUMBER OF OBSERVATIONS.
C     DOUBLE PRECISION PAR(50)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION PV(200)
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(200)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     DOUBLE PRECISION SCALE(50)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
C     DOUBLE PRECISION SDPV(200)
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(200)
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(50)
C        THE RCSTEP SIZE ARRAY.
C     DOUBLE PRECISION VCV(10,10)
C        THE COVARIANCE MATRIX.
C     DOUBLE PRECISION Y(200),YLOG(200),YT(200)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C
      DATA    Y(  1),   Y(  2),   Y(  3),   Y(  4),   Y(  5),   Y(  6)
     +    / 112.0D0, 118.0D0, 132.0D0, 129.0D0, 121.0D0, 135.0D0/
      DATA    Y(  7),   Y(  8),   Y(  9),   Y( 10),   Y( 11),   Y( 12)
     +    / 148.0D0, 148.0D0, 136.0D0, 119.0D0, 104.0D0, 118.0D0/
      DATA    Y( 13),   Y( 14),   Y( 15),   Y( 16),   Y( 17),   Y( 18)
     +    / 115.0D0, 126.0D0, 141.0D0, 135.0D0, 125.0D0, 149.0D0/
      DATA    Y( 19),   Y( 20),   Y( 21),   Y( 22),   Y( 23),   Y( 24)
     +    / 170.0D0, 170.0D0, 158.0D0, 133.0D0, 114.0D0, 140.0D0/
      DATA    Y( 25),   Y( 26),   Y( 27),   Y( 28),   Y( 29),   Y( 30)
     +    / 145.0D0, 150.0D0, 178.0D0, 163.0D0, 172.0D0, 178.0D0/
      DATA    Y( 31),   Y( 32),   Y( 33),   Y( 34),   Y( 35),   Y( 36)
     +    / 199.0D0, 199.0D0, 184.0D0, 162.0D0, 146.0D0, 166.0D0/
      DATA    Y( 37),   Y( 38),   Y( 39),   Y( 40),   Y( 41),   Y( 42)
     +    / 171.0D0, 180.0D0, 193.0D0, 181.0D0, 183.0D0, 218.0D0/
      DATA    Y( 43),   Y( 44),   Y( 45),   Y( 46),   Y( 47),   Y( 48)
     +    / 230.0D0, 242.0D0, 209.0D0, 191.0D0, 172.0D0, 194.0D0/
      DATA    Y( 49),   Y( 50),   Y( 51),   Y( 52),   Y( 53),   Y( 54)
     +    / 196.0D0, 196.0D0, 236.0D0, 235.0D0, 229.0D0, 243.0D0/
      DATA    Y( 55),   Y( 56),   Y( 57),   Y( 58),   Y( 59),   Y( 60)
     +    / 264.0D0, 272.0D0, 237.0D0, 211.0D0, 180.0D0, 201.0D0/
      DATA    Y( 61),   Y( 62),   Y( 63),   Y( 64),   Y( 65),   Y( 66)
     +    / 204.0D0, 188.0D0, 235.0D0, 227.0D0, 234.0D0, 264.0D0/
      DATA    Y( 67),   Y( 68),   Y( 69),   Y( 70),   Y( 71),   Y( 72)
     +    / 302.0D0, 293.0D0, 259.0D0, 229.0D0, 203.0D0, 229.0D0/
      DATA    Y( 73),   Y( 74),   Y( 75),   Y( 76),   Y( 77),   Y( 78)
     +    / 242.0D0, 233.0D0, 267.0D0, 269.0D0, 270.0D0, 315.0D0/
      DATA    Y( 79),   Y( 80),   Y( 81),   Y( 82),   Y( 83),   Y( 84)
     +    / 364.0D0, 347.0D0, 312.0D0, 274.0D0, 237.0D0, 278.0D0/
      DATA    Y( 85),   Y( 86),   Y( 87),   Y( 88),   Y( 89),   Y( 90)
     +    / 284.0D0, 277.0D0, 317.0D0, 313.0D0, 318.0D0, 374.0D0/
      DATA    Y( 91),   Y( 92),   Y( 93),   Y( 94),   Y( 95),   Y( 96)
     +    / 413.0D0, 405.0D0, 355.0D0, 306.0D0, 271.0D0, 306.0D0/
      DATA    Y( 97),   Y( 98),   Y( 99),   Y(100),   Y(101),   Y(102)
     +    / 315.0D0, 301.0D0, 356.0D0, 348.0D0, 355.0D0, 422.0D0/
      DATA    Y(103),   Y(104),   Y(105),   Y(106),   Y(107),   Y(108)
     +    / 465.0D0, 467.0D0, 404.0D0, 347.0D0, 305.0D0, 336.0D0/
      DATA    Y(109),   Y(110),   Y(111),   Y(112),   Y(113),   Y(114)
     +    / 340.0D0, 318.0D0, 362.0D0, 348.0D0, 363.0D0, 435.0D0/
      DATA    Y(115),   Y(116),   Y(117),   Y(118),   Y(119),   Y(120)
     +    / 491.0D0, 505.0D0, 404.0D0, 359.0D0, 310.0D0, 337.0D0/
      DATA    Y(121),   Y(122),   Y(123),   Y(124),   Y(125),   Y(126)
     +    / 360.0D0, 342.0D0, 406.0D0, 396.0D0, 420.0D0, 472.0D0/
      DATA    Y(127),   Y(128),   Y(129),   Y(130),   Y(131),   Y(132)
     +    / 548.0D0, 559.0D0, 463.0D0, 407.0D0, 362.0D0, 405.0D0/
      DATA    Y(133),   Y(134),   Y(135),   Y(136),   Y(137),   Y(138)
     +    / 417.0D0, 391.0D0, 419.0D0, 461.0D0, 472.0D0, 535.0D0/
      DATA    Y(139),   Y(140),   Y(141),   Y(142),   Y(143),   Y(144)
     +    / 622.0D0, 606.0D0, 508.0D0, 461.0D0, 390.0D0, 432.0D0/
C
      CALL IPRINT(IPRT)
C
C     COMMENCE BODY OF ROUTINE
C
C     TEST AGAINST PUBLISHED RESULTS
C
      NY = 144
      DO 10 I = 1, NY
         YLOG(I) = LOG(Y(I))
   10 CONTINUE
C
      NFAC = 2
      MSPEC(1,1) = 0
      MSPEC(2,1) = 1
      MSPEC(3,1) = 1
      MSPEC(4,1) = 1
C
      MSPEC(1,2) = 0
      MSPEC(2,2) = 1
      MSPEC(3,2) = 1
      MSPEC(4,2) = 12
C
      NPAR = 3
      PAR(1) = 0.0D0
      PAR(2) = 0.40D0
      PAR(3) = 0.60D0
C
      IFIXED(1) = 1
      IFIXED(2) = 0
      IFIXED(3) = 0
C
      STOPSS = -1.0D0
      STOPP = -1.0D0
      SCALE(1) = -1.0D0
      SCALE(2) = 1.0D-7
      SCALE(3) = 1.0D-7
      STP(1) = -1.0D0
      STP(2) = 1.0D-7
      STP(3) = 1.0D-7
      MIT = 0
      NPRT = -1
      DELTA = -1.0D0
      IVAPRX = -1
C
      WRITE(IPRT, 1000)
      CALL AIMEC (YLOG, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES,LDSTAK, IFIXED,STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
C
      WRITE (IPRT, 1005)
      PAR(1) = 0.0D0
      PAR(2) = 0.395D0
      PAR(3) = 0.615D0
      CALL AIMFS (YLOG, NY, MSPEC, NFAC,
     +   PAR, NPAR, LDSTAK, NY/10+1, 1, NY, NPRT, FCST, 50, FCSTSD)
C
      SCALE(1) = 1.0D-7
      SCALE(2) = 1.0D-7
      SCALE(3) = 1.0D-7
C
      NFAC = 2
      MSPEC(1,1) = 0
      MSPEC(2,1) = 1
      MSPEC(3,1) = 1
      MSPEC(4,1) = 1
C
      MSPEC(1,2) = 0
      MSPEC(2,2) = 0
      MSPEC(3,2) = 1
      MSPEC(4,2) = 12
C
      WRITE (IPRT, 1000)
      CALL AIMEC (YLOG, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES,LDSTAK, IFIXED,STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
      NY = 20
      WRITE (IPRT, 1000)
      CALL AIMEC (YLOG, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES,LDSTAK, IFIXED,STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
C
      NFAC = 2
      MSPEC(1,1) = 0
      MSPEC(2,1) = 0
      MSPEC(3,1) = 1
      MSPEC(4,1) = 1
C
      MSPEC(1,2) = 0
      MSPEC(2,2) = 0
      MSPEC(3,2) = 1
      MSPEC(4,2) = 12
C
      NY = 144
      WRITE (IPRT, 1000)
      CALL AIMEC (YLOG, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES,LDSTAK, IFIXED,STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
C
C     EXAMPLE FROM PAGE 212 OF BOX AND JENKINS (1970)
C     N.B. ADD PRINT STATEMENTS TO MDLTS2 TO CHECK COMPUTATIONS
C          AT FIRST CALL AGAINST THOSE LISTED ON PAGE 214.
C
      WRITE(IPRT, 1000)
      NY = 10
      YT(1) = 460.0D0
      YT(2) = 457.0D0
      YT(3) = 452.0D0
      YT(4) = 459.0D0
      YT(5) = 462.0D0
      YT(6) = 459.0D0
      YT(7) = 463.0D0
      YT(8) = 479.0D0
      YT(9) = 493.0D0
      YT(10) = 490.0D0
C
      NFAC = 1
      MSPEC(1,1) = 0
      MSPEC(2,1) = 1
      MSPEC(3,1) = 1
      MSPEC(4,1) = 1
C
      NPAR = 2
      PAR(1) = 0.0D0
      PAR(2) = 0.5D0
C
      IFIXED(1) = 1
      IFIXED(2) = 0
C
      CALL AIMEC (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES,LDSTAK, IFIXED,STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
C
C     EXAMPLE FROM PAGE 216 OF BOX AND JENKINS (1970)
C     N.B. ADD PRINT STATEMENTS TO MDLTS2 TO CHECK COMPUTATIONS
C          AT FIRST CALL AGAINST THOSE LISTED ON PAGE 218.
C
      WRITE(IPRT, 1000)
      NY = 12
      YT(1) = 2.0D0
      YT(2) = 0.8D0
      YT(3) = -0.3D0
      YT(4) = -0.3D0
      YT(5) = -1.9D0
      YT(6) = 0.3D0
      YT(7) = 3.2D0
      YT(8) = 1.6D0
      YT(9) = -0.7D0
      YT(10) = 3.0D0
      YT(11) = 4.3D0
      YT(12) = 1.1D0
C
      NFAC = 1
      MSPEC(1,1) = 1
      MSPEC(2,1) = 0
      MSPEC(3,1) = 1
      MSPEC(4,1) = 1
C
      NPAR = 3
      PAR(1) = 0.3D0
      PAR(2) = 0.0D0
      PAR(3) = 0.7D0
C
      IFIXED(1) = 0
      IFIXED(2) = 1
      IFIXED(3) = 0
C
      CALL AIMEC (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
C
C     TEST ERROR MESSAGES
C
      WRITE (IPRT, 1010)
      NY = 0
      NFAC = 0
      CALL AIME (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK)
      CALL AIMEC (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
      CALL AIMES (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT, NPARE, RSD, PV, SDPV, SDRES, VCV,
     +   IVCV)
      CALL AIMF (Y, NY, MSPEC, NFAC, PAR, NPAR, LDSTAK)
      CALL AIMFS (Y, NY, MSPEC, NFAC,
     +   PAR, NPAR, LDSTAK, NY/10+1, 1, NY, NPRT, FCST, 50, FCSTSD)
C
      NY = 144
      NFAC = 2
      MSPEC(1,1) = -1
      CALL AIME (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK)
      CALL AIMEC (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
      CALL AIMES (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT, NPARE, RSD, PV, SDPV, SDRES, VCV,
     +   IVCV)
      CALL AIMF (Y, NY, MSPEC, NFAC, PAR, NPAR, LDSTAK)
      CALL AIMFS (Y, NY, MSPEC, NFAC,
     +   PAR, NPAR, LDSTAK, NY/10+1, 1, NY, NPRT, FCST, 50, FCSTSD)
      NY = 144
      NFAC = 2
      MSPEC(1,1) = 0
      NPAR = 1
      CALL AIME (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK)
      CALL AIMEC (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
      CALL AIMES (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT, NPARE, RSD, PV, SDPV, SDRES, VCV,
     +   IVCV)
      CALL AIMF (Y, NY, MSPEC, NFAC, PAR, NPAR, LDSTAK)
      CALL AIMFS (Y, NY, MSPEC, NFAC,
     +   PAR, NPAR, LDSTAK, NY/10+1, 1, NY, NPRT, FCST, 50, FCSTSD)
      NY = 144
      NFAC = 2
      MSPEC(1,1) = 0
      NPAR = 3
      DO 20 I = 1, NPAR
        IFIXED(I) = 1
   20 CONTINUE
      IVCV = 0
      IFCST = 0
      CALL AIMEC (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
      CALL AIMES (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT, NPARE, RSD, PV, SDPV, SDRES, VCV,
     +   IVCV)
      CALL AIMFS (Y, NY, MSPEC, NFAC,
     +   PAR, NPAR, LDSTAK, NY/10+1, 1, NY, NPRT, FCST, IFCST, FCSTSD)
      DO 30 I = 1, NPAR
        IFIXED(I) = 1
   30 CONTINUE
      IVCV = 0
      STP(2) = -1.0D0
      SCALE(2) = -1.0D0
      CALL AIMEC (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT ('1TEST OF ARIMA ESTIMATION ROUTINES')
 1005 FORMAT ('1TEST OF ARIMA FORECASTING ROUTINES')
 1010 FORMAT ('1TEST OF ERROR CHECKING FACILITIES')
      END
*XAOV1
      SUBROUTINE XAOV1(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE EXCERCISES THE ONEWAY FAMILY ROUTINES.
C
C     WRITTEN BY -
C        LINDA MITCHELL
C        STATISTICAL ENGINEERING DIVISION
C        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FI
      INTEGER
     +   I,IGSTAT,IPRT,LDSMIN,N,NG
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   GSTAT(10,4),TAG(20),Y(20),Z(10),ZTAG(10)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AOV1,AOV1S,AOV1XP,IPRINT,LDSCMP,MSGX,SETRV
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (APHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FI
C        FLOAT OF INDEX I
C     DOUBLE PRECISION GSTAT(10,4)
C        THE GROUP STATISTICS.  COLUMNS CORRESPOND TO THE TAG
C        VALUE, SAMPLE SIZE, GROUP MEAN, AND GROUP STANDARD DEVIATION.
C     INTEGER I
C        INDEX VARIABLE
C     INTEGER IERR
C        COMMON FLAG INDICATING WHETHER OR NOT THERE WERE ANY ERRORS
C     INTEGER IGSTAT
C        THE FIRST DIMENSION OF GSTAT.
C     INTEGER IPRT
C        THE OUTPUT LOGICAL UNIT NUMBER
C     INTEGER LDSMIN
C        THE SMALLEST ACCEPTABLE SIZE OF THE COMMON CSTAK
C     INTEGER LDSTAK
C        THE SIZE OF THE COMMON CSTAK
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS
C     INTEGER NG
C        THE NUMBER OF DIFFERENT GROUPS
C     DOUBLE PRECISION TAG(20)
C        THE TAG VALUES FOR EACH OBSERVATION
C     DOUBLE PRECISION Y(20)
C        THE VECTOR OF OBSERVATIONS
C     DOUBLE PRECISION Z(10)
C        TEST VECTOR
C     DOUBLE PRECISION ZTAG(10)
C        TEST TAG VECTOR
C
      DATA   Y( 1),   Y( 2),   Y( 3),   Y( 4),   Y( 5)
     +   /    61.0D0,    61.0D0,    67.0D0,    67.0D0,    64.0D0/
      DATA   Y( 6),   Y( 7),   Y( 8),   Y( 9),   Y(10)
     +   /    78.0D0,    71.0D0,    75.0D0,    72.0D0,    74.0D0/
      DATA   Y(11),   Y(12),   Y(13),   Y(14),   Y(15)
     +   /    83.0D0,    81.0D0,    76.0D0,    78.0D0,    79.0D0/
      DATA   Y(16),   Y(17)
     +   /    72.0D0,   72.0D0/
C
      DATA TAG( 1), TAG( 2), TAG( 3), TAG( 4), TAG( 5)
     +   /    11.5D0,    11.5D0,    11.5D0,    11.5D0,    11.5D0/
      DATA TAG( 6), TAG( 7), TAG( 8), TAG( 9), TAG(10)
     +   /    12.0D0,    12.0D0,    12.0D0,    12.0D0,    12.0D0/
      DATA TAG(11), TAG(12), TAG(13), TAG(14), TAG(15)
     +   /    11.0D0,    11.0D0,    11.0D0,    11.0D0,    11.0D0/
      DATA TAG(16), TAG(17)
     +   /   -11.0D0,   11.0D0/
C
      CALL IPRINT(IPRT)
C
C     SET VARIOUS DIMENSIONS AND PROGRAM VARIABLES
C
      N = 17
      IGSTAT = 10
C
C**** TEST WITH CORRECT CALL STATEMENTS ****
C
      WRITE (IPRT,1060)
C
C     TEST AOV1
C
      WRITE (IPRT,1000)
      CALL AOV1(Y, TAG, N, LDSTAK)
      CALL MSGX(0, IPRT)
      WRITE (IPRT,1010)
      WRITE (IPRT,1020) (TAG(I),I=1,N)
C
C     TEST OF AOV1S
C
C     PRINTOUT NOT SUPRESSED
C
      WRITE (IPRT,1040)
      WRITE (IPRT,1030)
      CALL AOV1S(Y, TAG, N, LDSTAK, 1, GSTAT, IGSTAT, NG)
      CALL MSGX(0, IPRT)
C
C     PRINT STORAGE AND ZERO VECTORS BEFORE USING AGAIN
C
      CALL AOV1XP(GSTAT, IGSTAT, NG)
C
C     PRINTOUT SUPRESSED
C
      WRITE (IPRT,1050)
      CALL AOV1S(Y, TAG, N, LDSTAK, 0, GSTAT, IGSTAT, NG)
      CALL MSGX(0, IPRT)
C
C     PRINT STORAGE AND ZERO VECTORS BEFORE USING AGAIN
C
      CALL AOV1XP(GSTAT, IGSTAT, NG)
C
C**** NUMBER OF OBSERVATIONS LESS THAN 2 ****
C
      WRITE (IPRT,1090)
      CALL AOV1(Y, TAG, 1, LDSTAK)
      CALL MSGX(1, IPRT)
C
      CALL AOV1S(Y, TAG, -14, LDSTAK, 0, GSTAT, IGSTAT, NG)
      CALL MSGX(1, IPRT)
C
C**** ALL OBSERVATIONS THE SAME VALUE ****
C
      WRITE (IPRT,1100)
      WRITE (IPRT,1000)
      CALL SETRV(Z, 10, 0.0D0)
      CALL AOV1(Z, TAG, 10, LDSTAK)
      CALL MSGX(0, IPRT)
C
      CALL SETRV(Z, 10, 2.0D0)
      WRITE (IPRT,1100)
      WRITE (IPRT,1030)
      CALL AOV1S(Z, TAG, 10, LDSTAK, 1, GSTAT, IGSTAT, NG)
      CALL MSGX(0, IPRT)
C
C**** TEST WORK AREA SIZE HANDLING ****
C
      CALL LDSCMP(11, 0, 33, 0, 0, 0, 'D', 40, LDSMIN)
      WRITE (IPRT,1070)
      WRITE (IPRT,1000)
      CALL AOV1(Y, TAG, N, 1)
      CALL MSGX(1, IPRT)
      WRITE (IPRT,1070)
      WRITE (IPRT,1000)
      CALL AOV1(Y, TAG, N, LDSMIN-1)
      CALL MSGX(1, IPRT)
      WRITE (IPRT,1010)
      WRITE (IPRT,1020) (TAG(I),I=1,N)
      WRITE (IPRT,1080)
      WRITE (IPRT,1000)
      CALL AOV1(Y, TAG, N, LDSMIN)
      CALL MSGX(0, IPRT)
C
      CALL LDSCMP(11, 0, 33, 0, 0, 0, 'D', 28, LDSMIN)
      WRITE (IPRT,1070)
      WRITE (IPRT,1030)
      CALL AOV1S(Y, TAG, N, 1, 0, GSTAT, IGSTAT, NG)
      CALL MSGX(1, IPRT)
      WRITE (IPRT,1070)
      WRITE (IPRT,1030)
      CALL AOV1S(Y, TAG, N, LDSMIN-1, 0, GSTAT, IGSTAT, NG)
      CALL MSGX(1, IPRT)
      WRITE (IPRT,1010)
      WRITE (IPRT,1020) (TAG(I),I=1,N)
      WRITE (IPRT,1080)
      WRITE (IPRT,1030)
      CALL AOV1S(Y, TAG, N, LDSMIN, 1, GSTAT, IGSTAT, NG)
      CALL MSGX(0, IPRT)
C
C**** SAME NUMBER OF GROUPS AS NON-ZERO TAGS ****
C
      WRITE (IPRT,1120)
      DO 20 I=1,10
         FI = I
         ZTAG(I) = FI
         Z(I) = 13.0D0 - FI
   20 CONTINUE
      CALL AOV1(Z, ZTAG, 10, LDSTAK)
      CALL MSGX(1, IPRT)
      CALL AOV1S(Z, ZTAG, 10, LDSTAK, 1, GSTAT, IGSTAT, NG)
      CALL MSGX(1, IPRT)
C
C**** LESS THAN 2 DIFFERENT TAG GROUPS ****
C
      WRITE (IPRT,1130)
      CALL SETRV(ZTAG, 10, 1.0D0)
      CALL AOV1(Z, ZTAG, 10, LDSTAK)
      CALL MSGX(1, IPRT)
      CALL AOV1S(Z, ZTAG, 10, LDSTAK, 1, GSTAT, IGSTAT, NG)
      CALL MSGX(1, IPRT)
C
C**** LESS THAN 2 TAGS ****
C
      CALL SETRV(ZTAG, 9, 0.0D0)
      WRITE (IPRT,1140)
      CALL AOV1(Z, ZTAG, 10, LDSTAK)
      CALL MSGX(1, IPRT)
      CALL AOV1S(Z, ZTAG, 10, LDSTAK, 1, GSTAT, IGSTAT, NG)
      CALL MSGX(1, IPRT)
C
C**** INCORRECT DIMENSION OF GSTAT ****
C
      WRITE (IPRT,1150)
      CALL AOV1S(Y, TAG, N, LDSTAK, 1, GSTAT, 2, NG)
      CALL MSGX(1, IPRT)
C
C**** ALL OBSERVATIONS WITHIN A GROUP SAME VALUE ****
C
      Z(1) = 53.0D0
      ZTAG(1) = 1.0D0
      Z(2) = 62.0D0
      ZTAG(2) = 3.0D0
      Z(3) = 53.0D0
      ZTAG(3) = 1.0D0
      Z(4) = 71.0D0
      ZTAG(4) = 4.0D0
      Z(5) = 89.0D0
      ZTAG(5) = 2.0D0
      Z(6) = 71.0D0
      ZTAG(6) = 4.0D0
      Z(7) = 89.0D0
      ZTAG(7) = 2.0D0
      Z(8) = 62.0D0
      ZTAG(8) = 3.0D0
      Z(9) = 71.0D0
      ZTAG(9) = 4.0D0
      Z(10) = 62.0D0
      ZTAG(10) = 3.0D0
      WRITE (IPRT,1160)
      CALL AOV1(Z, ZTAG, 10, LDSTAK)
      CALL MSGX(0, IPRT)
C
C**** 2 TAGS ****
C
      WRITE (IPRT,1170)
      CALL AOV1(Z, ZTAG, 3, LDSTAK)
      CALL MSGX(0, IPRT)
C
C**** ALL GROUPS(EXCEPT FOR 1) WITH 1 OBSERVATION ****
C
      WRITE (IPRT,1180)
      CALL AOV1(Z, ZTAG, 5, LDSTAK)
      CALL MSGX(0, IPRT)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT(' TEST OF AOV1 ')
 1010 FORMAT(' CHECK TO SEE IF TAGS HAVE BEEN CHANGED')
 1020 FORMAT(4F12.6)
 1030 FORMAT(' TEST OF AOV1S ')
 1040 FORMAT('1PRINTOUT NOT SUPRESSED.')
 1050 FORMAT(' PRINTOUT SUPRESSED.')
 1060 FORMAT('1****TEST ROUTINES WITH CORRECT CALL****')
 1070 FORMAT('1****TEST WITH INSUFFICIENT WORK AREA****')
 1080 FORMAT('1****TEST WITH EXACTLY THE RIGHT AMOUNT OF WORK AREA****')
 1090 FORMAT('1****NUMBER OF OBSERVATIONS LESS THAN 2****')
 1100 FORMAT('1****ALL OBSERVATIONS WITH SAME VALUE****')
 1120 FORMAT('1****SAME NUMBER OF GROUPS AS NON-ZERO TAGS****')
 1130 FORMAT(' ****LESS THAN 2 DIFFERENT TAG GROUPS****')
 1140 FORMAT(' ****LESS THAN 2 TAGS****')
 1150 FORMAT('1****INCORRECT DIMENSION OF GSTAT****')
 1160 FORMAT('1****ALL OBSERVATIONS WITHIN A GROUP SAME VALUE****')
 1170 FORMAT('1****TEST WITH 2 TAGS****')
 1180 FORMAT('1****ALL GROUPS EXCEPT FOR 1 WITH 1 OBSERVATION ****')
      END
*XBFS
      SUBROUTINE XBFS(LDS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST THE FOURIER SPECTRUM ANALYSIS ROUTINES
C
C     SERIES Y1 AND Y2 ARE LISTED AS SERIES X1 AND X2 ON PAGE OF 361 OF
C     JENKINS AND WATTS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDS
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CMISS,FMAX,FMIN,YMISS,YMISS1,YMISS2
      INTEGER
     +   I,ICCOV,ICSPC2,INDEX1,INDEX2,INLPPC,IPHAS,IPRT,ISPCF,J,
     +   JCCOV,JNLPPC,LACOV,LAGMAX,LDSTAK,LYFFT,N,NF,NPRT,NW
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCOV(101,2,2),CSPC2(300,2),FREQ(300),PHAS(300,2),Y1(150),
     +   Y2(150),YFFT1(400),YFFT2(400),YM(150,2),YMMISS(4)
      INTEGER
     +   LAGS(4),NLPPC(101,2,2)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL BFS,BFSF,BFSFS,BFSM,BFSMS,BFSMV,BFSMVS,BFSS,BFSV,BFSVS,
     +   CCFMS,CCFS,IPRINT,NRAND,DCOPY,SETIV,SETRV
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (YM(1,1),Y1(1))
      EQUIVALENCE (YM(1,2),Y2(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CMISS
C         THE MISSING VALUE CODE FOR THE RETURNED CCVF ESTIMATES.
C     DOUBLE PRECISION CCOV(101,2,2)
C        THE COVARIANCES.
C     DOUBLE PRECISION CSPC2(300,2)
C        THE SQUARED COHERENCY COMPONENT OF THE SPECTRUM.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCIES AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(300)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS COMPUTED.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER ICSPC2
C        THE FIRST DIMENSION OF THE ARRAY CSPC2.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IPHAS
C        THE FIRST DIMENSION OF THE ARRAY PHAS.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISPCF
C         THE ACTUAL DIMENSION FOR THE SPECTRUM ARRAYS.
C     INTEGER J
C        INDEX VARIABLE.
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
C        AUTOCOVARIANCE BEING COMPUTED AND THE MAXIMUM LAG TO BE USED,
C        RESPECTIVELY.
C     INTEGER LAGS(4)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDS, LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTORS YFFT AND ZFFT, RESPECTIVELY..
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPC(101,2,2)
C        THE NUMBERS OF LAGGED PRODUCT PAIRS USED FOR EACH ACVF.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT.
C        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        IF NPRT = 0 THE PLOT IS SUPPRESSED.
C        IF NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NW
C        THE NUMBER OF DIFFERENT LAG WINDOW TRUNCATION POINTS SPECIFIED,
C        AND THEREFORE, THE NUMBER OF PLOTS.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     DOUBLE PRECISION PHAS(300,2)
C        THE PHASE COMPONENT OF THE SPECTRUM.
C     DOUBLE PRECISION YFFT1(400), YFFT2(400)
C        THE VECTORS OF THE OBSERVED TIME SERIES TO BE ANALYZED USING
C        THE FFT.
C     DOUBLE PRECISION YMISS, YMISS1, YMISS2, YMMISS(4)
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
C        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
C        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
C     DOUBLE PRECISION YM(150,2)
C        THE MULTIVARIATE REPRESENTATION OF THE DATA
C     DOUBLE PRECISION Y1(150), Y2(150)
C         THE VECTORS CONTAINING THE TIME SERIES FROM JENKINS AND WATTS.
C
      DATA   Y1(  1),  Y1(  2),  Y1(  3),  Y1(  4),  Y1(  5),  Y1(  6)
     +    /-0.88D0, -0.16D0, -1.87D0, -1.12D0,  1.38D0,  2.13D0/
      DATA   Y1(  7),  Y1(  8),  Y1(  9),  Y1( 10),  Y1( 11),  Y1( 12)
     +    / 2.76D0,  0.56D0, -0.69D0, -1.79D0, -3.82D0, -2.38D0/
      DATA   Y1( 13),  Y1( 14),  Y1( 15),  Y1( 16),  Y1( 17),  Y1( 18)
     +    / 1.00D0,  0.70D0, -0.15D0,  0.98D0,  0.11D0, -0.35D0/
      DATA   Y1( 19),  Y1( 20),  Y1( 21),  Y1( 22),  Y1( 23),  Y1( 24)
     +    /-0.73D0,  0.89D0, -1.63D0, -0.44D0, -1.37D0, -1.71D0/
      DATA   Y1( 25),  Y1( 26),  Y1( 27),  Y1( 28),  Y1( 29),  Y1( 30)
     +    /-1.22D0, -2.00D0, -0.22D0,  0.38D0,  1.31D0,  0.71D0/
      DATA   Y1( 31),  Y1( 32),  Y1( 33),  Y1( 34),  Y1( 35),  Y1( 36)
     +    / 0.32D0,  0.48D0, -1.88D0, -0.94D0, -1.54D0, -0.13D0/
      DATA   Y1( 37),  Y1( 38),  Y1( 39),  Y1( 40),  Y1( 41),  Y1( 42)
     +    / 1.02D0,  0.02D0, -0.77D0,  0.11D0, -0.60D0, -0.52D0/
      DATA   Y1( 43),  Y1( 44),  Y1( 45),  Y1( 46),  Y1( 47),  Y1( 48)
     +    /-0.09D0,  1.23D0,  1.46D0,  0.61D0,  0.42D0,  2.16D0/
      DATA   Y1( 49),  Y1( 50),  Y1( 51),  Y1( 52),  Y1( 53),  Y1( 54)
     +    / 3.18D0,  2.10D0,  0.37D0, -0.24D0,  0.57D0, -0.53D0/
      DATA   Y1( 55),  Y1( 56),  Y1( 57),  Y1( 58),  Y1( 59),  Y1( 60)
     +    / 2.44D0,  1.02D0, -0.53D0, -2.49D0, -2.12D0, -1.04D0/
      DATA   Y1( 61),  Y1( 62),  Y1( 63),  Y1( 64),  Y1( 65),  Y1( 66)
     +    /-0.12D0, -1.88D0, -1.50D0,  1.54D0,  3.33D0,  3.08D0/
      DATA   Y1( 67),  Y1( 68),  Y1( 69),  Y1( 70),  Y1( 71),  Y1( 72)
     +    / 1.71D0,  0.79D0,  1.55D0,  0.89D0, -0.89D0, -1.18D0/
      DATA   Y1( 73),  Y1( 74),  Y1( 75),  Y1( 76),  Y1( 77),  Y1( 78)
     +    / 0.89D0,  1.71D0,  3.05D0,  0.15D0, -1.04D0,  0.12D0/
      DATA   Y1( 79),  Y1( 80),  Y1( 81),  Y1( 82),  Y1( 83),  Y1( 84)
     +    / 0.08D0,  0.11D0, -2.62D0, -1.28D0,  1.07D0,  3.20D0/
      DATA   Y1( 85),  Y1( 86),  Y1( 87),  Y1( 88),  Y1( 89),  Y1( 90)
     +    / 1.92D0,  0.53D0, -1.08D0,  0.49D0, -0.58D0,  0.17D0/
      DATA   Y1( 91),  Y1( 92),  Y1( 93),  Y1( 94),  Y1( 95),  Y1( 96)
     +    / 1.15D0, -0.97D0, -1.63D0,  1.14D0, -0.67D0, -0.88D0/
      DATA   Y1( 97),  Y1( 98),  Y1( 99),  Y1(100)
     +    /-0.07D0,  0.24D0,  0.55D0, -2.16D0/
      DATA   Y2(  1),  Y2(  2),  Y2(  3),  Y2(  4),  Y2(  5),  Y2(  6)
     +    / 0.79D0,  1.12D0, -1.10D0, -2.39D0, -1.75D0, -0.82D0/
      DATA   Y2(  7),  Y2(  8),  Y2(  9),  Y2( 10),  Y2( 11),  Y2( 12)
     +    /-0.36D0,  1.27D0,  1.75D0,  2.44D0,  0.36D0, -2.10D0/
      DATA   Y2( 13),  Y2( 14),  Y2( 15),  Y2( 16),  Y2( 17),  Y2( 18)
     +    /-1.93D0, -1.30D0, -1.75D0, -0.34D0,  0.74D0,  0.49D0/
      DATA   Y2( 19),  Y2( 20),  Y2( 21),  Y2( 22),  Y2( 23),  Y2( 24)
     +    / 0.70D0,  0.71D0,  0.09D0,  0.59D0,  1.54D0,  0.14D0/
      DATA   Y2( 25),  Y2( 26),  Y2( 27),  Y2( 28),  Y2( 29),  Y2( 30)
     +    / 0.55D0, -1.40D0, -2.55D0, -1.66D0, -0.43D0,  0.58D0/
      DATA   Y2( 31),  Y2( 32),  Y2( 33),  Y2( 34),  Y2( 35),  Y2( 36)
     +    / 2.18D0, -0.24D0,  0.58D0, -0.18D0, -1.55D0, -0.64D0/
      DATA   Y2( 37),  Y2( 38),  Y2( 39),  Y2( 40),  Y2( 41),  Y2( 42)
     +    /-1.09D0,  0.90D0, -0.66D0, -0.35D0,  0.48D0,  0.50D0/
      DATA   Y2( 43),  Y2( 44),  Y2( 45),  Y2( 46),  Y2( 47),  Y2( 48)
     +    / 0.05D0, -0.68D0,  0.24D0,  0.58D0, -1.26D0, -0.25D0/
      DATA   Y2( 49),  Y2( 50),  Y2( 51),  Y2( 52),  Y2( 53),  Y2( 54)
     +    / 0.25D0,  2.18D0,  2.96D0,  1.56D0, -0.36D0, -0.59D0/
      DATA   Y2( 55),  Y2( 56),  Y2( 57),  Y2( 58),  Y2( 59),  Y2( 60)
     +    /-0.12D0,  3.03D0,  2.11D0,  0.78D0,  0.89D0, -1.45D0/
      DATA   Y2( 61),  Y2( 62),  Y2( 63),  Y2( 64),  Y2( 65),  Y2( 66)
     +    /-0.36D0, -0.37D0, -1.39D0, -4.19D0, -0.73D0, -0.98D0/
      DATA   Y2( 67),  Y2( 68),  Y2( 69),  Y2( 70),  Y2( 71),  Y2( 72)
     +    / 0.36D0,  0.06D0, -1.94D0, -0.08D0,  0.17D0,  1.00D0/
      DATA   Y2( 73),  Y2( 74),  Y2( 75),  Y2( 76),  Y2( 77),  Y2( 78)
     +    /-0.05D0,  0.43D0,  0.15D0,  2.69D0,  0.57D0,  0.29D0/
      DATA   Y2( 79),  Y2( 80),  Y2( 81),  Y2( 82),  Y2( 83),  Y2( 84)
     +    / 1.10D0,  0.48D0, -1.06D0, -2.28D0, -2.03D0, -0.75D0/
      DATA   Y2( 85),  Y2( 86),  Y2( 87),  Y2( 88),  Y2( 89),  Y2( 90)
     +    / 1.00D0,  1.71D0,  0.58D0,  1.97D0,  0.99D0,  1.94D0/
      DATA   Y2( 91),  Y2( 92),  Y2( 93),  Y2( 94),  Y2( 95),  Y2( 96)
     +    / 2.18D0,  3.14D0,  0.60D0,  0.51D0,  1.35D0,  0.56D0/
      DATA   Y2( 97),  Y2( 98),  Y2( 99),  Y2(100)
     +    / 0.11D0,  0.00D0,  2.34D0,  1.88D0/
C
C
      CALL IPRINT(IPRT)
      CALL SETRV(YMMISS, 4, 0.89D0)
C
C     CHECK ERROR HANDLING
C
C        TEST 1  -  MISCELANEOUS ERROR CHECKING
C
      WRITE (IPRT, 2000)
      LAGMAX = -1
      N = -10
      INDEX1 = 0
      INDEX2 = 0
      ICCOV = 0
      JCCOV = 0
      INLPPC = 0
      JNLPPC = 0
      ICSPC2 = -10
      IPHAS = -10
      LACOV = -11
      LYFFT = -11
      NW = -1
      NF = -5
      FMIN = 0.5D0
      FMAX = 0.0D0
      NPRT = -1
      ISPCF = -20
      LDSTAK = 0
      YMISS1 = 0.89D0
      YMISS2 = 0.89D0
C
      WRITE(IPRT, 1001)
      CALL BFS (Y1, Y2, N)
      WRITE (IPRT, 1002) IERR
C
      WRITE(IPRT, 1003)
      CALL BFSS(Y1, Y2, N, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
      WRITE(IPRT, 1019)
      CALL BFSF (YFFT1, YFFT2, N, LYFFT, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
      WRITE(IPRT, 1020)
      CALL BFSFS(YFFT1, YFFT2, N, LYFFT, LDSTAK, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ)
      WRITE (IPRT, 1002) IERR
C
      WRITE(IPRT, 1005)
      CALL BFSM (Y1, YMISS1, Y2, YMISS2, N)
      WRITE (IPRT, 1002) IERR
C
      WRITE(IPRT, 1006)
      CALL BFSMS(Y1, YMISS1, Y2, YMISS2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
      WRITE (IPRT, 1007)
      CALL BFSV(CCOV, INDEX1, INDEX2, N, LAGMAX, ICCOV, JCCOV)
      WRITE (IPRT, 1002) IERR
C
      WRITE (IPRT, 1008)
      CALL BFSVS (CCOV, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS,
     +   FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
      WRITE (IPRT, 1021)
      CALL BFSMV(CCOV, NLPPC, INDEX1, INDEX2, N, LAGMAX, ICCOV, JCCOV,
     +   INLPPC, JNLPPC)
      WRITE (IPRT, 1002) IERR
C
      WRITE (IPRT, 1022)
      CALL BFSMVS (CCOV, NLPPC, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   INLPPC, JNLPPC, NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2, ICSPC2,
     +   PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C        TEST 2  -  MISCELANEOUS ERROR CHECKING (CONTINUED)
C
      WRITE (IPRT, 2010)
      N = 100
      LAGMAX = 40
      INDEX1 = 0
      INDEX2 = 0
      ICCOV = 0
      JCCOV = 0
      INLPPC = 0
      JNLPPC = 0
      ICSPC2 = 300
      IPHAS = 300
      LACOV = 101
      LYFFT = -11
      NW = 2
      LAGS(1) = 0
      LAGS(2) = 100
      NF = 202
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 3
      ISPCF = 101
      LDSTAK = 0
C
      WRITE(IPRT, 1003)
      CALL BFSS(Y1, Y2, N, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
      WRITE(IPRT, 1019)
      CALL BFSF (YFFT1, YFFT2, N, LYFFT, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
      WRITE(IPRT, 1020)
      CALL BFSFS(YFFT1, YFFT2, N, LYFFT, LDSTAK, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ)
      WRITE (IPRT, 1002) IERR
C
      WRITE(IPRT, 1006)
      CALL BFSMS(Y1, YMISS1, Y2, YMISS2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
      WRITE (IPRT, 1008)
      CALL BFSVS (CCOV, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS,
     +   FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
      WRITE (IPRT, 1022)
      CALL BFSMVS (CCOV, NLPPC, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   INLPPC, JNLPPC, NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2, ICSPC2,
     +   PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C        TEST 3  -  LDSTAK TOO SMALL
C
      WRITE (IPRT, 2030)
      N = 100
      INDEX1 = 2
      INDEX2 = 1
      ICCOV = 101
      JCCOV = 2
      INLPPC = 101
      JNLPPC = 2
      ICSPC2 = 300
      IPHAS = 300
      LAGMAX = 99
      LACOV = 101
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 26
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 1
      ISPCF = 101
      LDSTAK = 0
C
      WRITE(IPRT, 1003)
      CALL BFSS(Y1, Y2, N, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
      WRITE(IPRT, 1019)
      CALL BFSF (YFFT1, YFFT2, N, LYFFT, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
      WRITE(IPRT, 1020)
      CALL BFSFS(YFFT1, YFFT2, N, LYFFT, LDSTAK, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ)
      WRITE (IPRT, 1002) IERR
C
      WRITE(IPRT, 1006)
      CALL BFSMS(Y1, YMISS1, Y2, YMISS2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
      WRITE (IPRT, 1008)
      CALL BFSVS (CCOV, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS,
     +   FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
      WRITE (IPRT, 1022)
      CALL BFSMVS (CCOV, NLPPC, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   INLPPC, JNLPPC, NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2, ICSPC2,
     +   PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C        TEST 4  -  ALL DATA AND COVARIANCES MISSING
C
      WRITE (IPRT, 2040)
      N = 100
      LAGMAX = 99
      ICSPC2 = 300
      IPHAS = 300
      LACOV = 101
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 26
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 1
      ISPCF = 101
      LDSTAK = LDS
      CALL SETRV(YFFT1, N, YMISS1)
      CALL SETRV(YFFT2, N, YMISS2)
      CALL SETRV(CCOV, 404, 0.0D0)
      CALL SETIV(NLPPC, 404, 0)
C
      WRITE(IPRT, 1005)
      CALL BFSM (YFFT1, YMISS1, YFFT2, YMISS2, N)
      WRITE (IPRT, 1002) IERR
C
      WRITE(IPRT, 1006)
      CALL BFSMS(YFFT1, YMISS1, YFFT2, YMISS2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
      WRITE (IPRT, 1021)
      CALL BFSMV(CCOV, NLPPC, INDEX1, INDEX2, N, LAGMAX, ICCOV, JCCOV,
     +   INLPPC, JNLPPC)
      WRITE (IPRT, 1002) IERR
C
      WRITE (IPRT, 1022)
      CALL BFSMVS (CCOV, NLPPC, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   INLPPC, JNLPPC, NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2, ICSPC2,
     +   PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C        TEST 5  -  EVERY OTHER VALUE MISSING
C
      WRITE (IPRT, 2050)
      N = 100
      LAGMAX = 99
      ICSPC2 = 300
      IPHAS = 300
      LACOV = 101
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 26
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 1
      ISPCF = 101
      LDSTAK = LDS
      CALL SETRV(YFFT1, N, YMISS1)
      CALL SETRV(YFFT2, N, YMISS2)
      DO 10 I = 1, N, 2
         YFFT1(I) = Y1(I)
         YFFT2(I) = Y2(I)
   10 CONTINUE
C
      WRITE(IPRT, 1005)
      CALL BFSM (YFFT1, YMISS1, YFFT2, YMISS2, N)
      WRITE (IPRT, 1002) IERR
C
      WRITE(IPRT, 1006)
      CALL BFSMS(YFFT1, YMISS1, YFFT2, YMISS2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     CHECK RESULTS FROM VALID CALL
C
      WRITE(IPRT, 2020)
      YMISS = 1.16D0
      N = 100
      LAGMAX = 99
      ICSPC2 = 300
      IPHAS = 300
      LACOV = 101
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 26
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 1
      ISPCF = 101
      LDSTAK = LDS
C
C     TEST OF BFS
C
      WRITE(IPRT, 1001)
      CALL BFS (Y1, Y2, N)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF BFSS
C
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1003)
      CALL BFSS(Y1, Y2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM BFSS
C
      WRITE (IPRT, 1004) (FREQ(I), (CSPC2(I,J), PHAS(I,J),J=1,NW),
     +   I=1,NF)
C
C     TEST OF BFSF
C
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1019)
      CALL DCOPY(N, Y1, 1, YFFT1, 1)
      CALL DCOPY(N, Y2, 1, YFFT2, 1)
      CALL BFSF (YFFT1, YFFT2, N, LYFFT, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF BFSFS
C
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1020)
      CALL DCOPY(N, Y1, 1, YFFT1, 1)
      CALL DCOPY(N, Y2, 1, YFFT2, 1)
      CALL BFSFS(YFFT1, YFFT2, N, LYFFT, LDSTAK, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM BFSFS
C
      WRITE (IPRT, 1004) (FREQ(I), (CSPC2(I,J), PHAS(I,J),J=1,NW),
     +   I=1,NF)
C
C     TEST OF BFSM
C
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1005)
      CALL BFSM (Y1, YMISS1, Y2, YMISS2, N)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF BFSMS
C
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1006)
      CALL BFSMS(Y1, YMISS1, Y2, YMISS2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM BFSMS
C
      WRITE (IPRT, 1004) (FREQ(I), (CSPC2(I,J), PHAS(I,J),J=1,NW),
     +   I=1,NF)
C
C     TEST OF BFSV
C
      WRITE(IPRT, 2020)
      CALL CCFS (YM, N, 2, 150, LAGMAX, CCOV, ICCOV, JCCOV, 0,
     +   LDSTAK)
      WRITE (IPRT, 1007)
      CALL BFSV(CCOV, INDEX1, INDEX2, N, LAGMAX, ICCOV, JCCOV)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF BFSVS
C
      WRITE(IPRT, 2020)
      WRITE (IPRT, 1008)
      CALL BFSVS(CCOV, INDEX1, INDEX2, N, ICCOV, JCCOV, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM BFSVS
C
      WRITE (IPRT, 1004) (FREQ(I), (CSPC2(I,J), PHAS(I,J),J=1,NW),
     +   I=1,NF)
C
C     TEST OF BFSMV
C
      WRITE(IPRT, 2020)
      CALL CCFMS (YM, YMMISS, N, 2, 150, LAGMAX, CCOV, CMISS, ICCOV,
     +  JCCOV, NLPPC, INLPPC, JNLPPC, 0, LDSTAK)
      WRITE (IPRT, 1021)
      CALL BFSMV(CCOV, NLPPC, INDEX1, INDEX2, N, LAGMAX, ICCOV,
     +  JCCOV, INLPPC, JNLPPC)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF BFSMVS
C
      WRITE(IPRT, 2020)
      WRITE (IPRT, 1022)
      CALL BFSMVS(CCOV, NLPPC, INDEX1, INDEX2, N, ICCOV,
     +  JCCOV, INLPPC, JNLPPC, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +  CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM BFSMVS
C
      WRITE (IPRT, 1004) (FREQ(I), (CSPC2(I,J), PHAS(I,J),J=1,NW),
     +   I=1,NF)
C
C     MINIMUM PROBLEM SIZE
C
      YMISS = 1.16D0
      N = 17
      LAGMAX = 1
      ICSPC2 = 1
      IPHAS = 1
      LACOV = 101
      LYFFT = 400
      NW = 1
      LAGS(1) = 1
      LAGS(2) = 16
      NF = 1
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 1
      ISPCF = 101
      LDSTAK = LDS
C
C     TEST OF BFS
C
      WRITE(IPRT, 2060)
      WRITE(IPRT, 1001)
      CALL BFS(Y1, Y2, N)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF BFSS
C
      WRITE(IPRT, 2060)
      WRITE(IPRT, 1003)
      CALL BFSS(Y1, Y2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM BFSS
C
      WRITE (IPRT, 1004) (FREQ(I), (CSPC2(I,J), PHAS(I,J),J=1,NW),
     +   I=1,NF)
C
C     CHECK HANDLING OF FMIN AND FMAX
C
      YMISS = 1.16D0
      N = 100
      LAGMAX = 99
      ICSPC2 = 300
      IPHAS = 300
      LACOV = 101
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 26
      FMIN = 0.45D0
      FMAX = 0.5D0
      NPRT = 1
      ISPCF = 101
      LDSTAK = LDS
C
C     TEST OF BFSS
C
      WRITE(IPRT, 2070)
      WRITE(IPRT, 1003)
      CALL BFSS(Y1, Y2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM BFSS
C
      WRITE (IPRT, 1004) (FREQ(I), (CSPC2(I,J), PHAS(I,J),J=1,NW),
     +   I=1,NF)
C
C     CHECK RESULTS FOR WHITE NOISE SPECTRUM
C
      YMISS = 1.16D0
      CALL NRAND(YFFT1, N, 12343)
      CALL NRAND(YFFT2, N, 34523)
      N = 100
      LAGMAX = 99
      ICSPC2 = 300
      IPHAS = 300
      LACOV = 101
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 26
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 1
      ISPCF = 101
      LDSTAK = LDS
C
C     TEST OF BFSFS
C
      WRITE(IPRT, 2080)
      WRITE(IPRT, 1003)
      CALL BFSFS(YFFT1, YFFT2, N, LYFFT, LDSTAK, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM BFSS
C
      WRITE (IPRT, 1004) (FREQ(I), (CSPC2(I,J), PHAS(I,J),J=1,NW),
     +   I=1,NF)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1001 FORMAT (12H TEST OF BFS)
 1002 FORMAT (8H IERR IS, I5/)
 1003 FORMAT (13H TEST OF BFSS)
 1004 FORMAT (5(1X, E15.7))
 1005 FORMAT (13H TEST OF BFSM)
 1006 FORMAT (14H TEST OF BFSMS)
 1007 FORMAT (13H TEST OF BFSV)
 1008 FORMAT (14H TEST OF BFSVS)
 1019 FORMAT (13H TEST OF BFSF)
 1020 FORMAT (14H TEST OF BFSFS)
 1021 FORMAT (14H TEST OF BFSMV)
 1022 FORMAT (15H TEST OF BFSMVS)
 2000 FORMAT (32H1CHECK ERROR HANDLING  -  TEST 1)
 2010 FORMAT (32H1CHECK ERROR HANDLING  -  TEST 2)
 2020 FORMAT (14H1VALID PROBLEM)
 2030 FORMAT (14H1LDS TOO SMALL)
 2040 FORMAT (33H1ALL DATA AND COVARIANCES MISSING)
 2050 FORMAT (31H1EVERY OTHER DATA VALUE MISSING)
 2060 FORMAT (21H1MINIMUM PROBLEM SIZE)
 2070 FORMAT (32H1CHECK HANDLING OF FMIN AND FMAX)
 2080 FORMAT (21H1WHITE NOISE SPECTRUM)
      END
*XCCF
      SUBROUTINE XCCF(LDS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST THE TIME SERIES CORRELATION SUBROUTINES
C
C     SERIES Y1 AND Y2 ARE LISTED AS SERIES X1 AND X2 ON PAGE OF 361 OF
C     JENKINS AND WATTS.  CCF FOR SERIES Y1 AND Y2 ARE PLOTTED ON PAGE 3
C     AND LISTED ON PAGE 420.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDS
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   CMISS,Y1MISS,Y2MISS,YMISS0
      INTEGER
     +   ICCOV,INLPPC,IPRT,ITEST,IYM,IYMFFT,JCCOV,JNLPPC,LAGMAX,
     +   LDSTAK,LYFFT,M,N,NLAG,NPRT,NYD
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCOV(30,5,5),Y1(100),Y2(100),YFFT1(150),YFFT2(150),YM(150,5),
     +   YMFFT(150,5),YMMISS(5)
      INTEGER
     +   NLPPC(30,5,5)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CCF,CCFF,CCFFS,CCFM,CCFMS,CCFS,CCFXP,IPRINT,DCOPY,SETRA,
     +   SETRV
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION CCOV(30,5,5)
C        THE CROSS COVARIANCE ARRAY.
C     DOUBLE PRECISION CMISS
C        THE MISSING VALUE CODE FOR THE RETURNED CCVF ESTIMATES
C        (VECTOR CCOV).
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C     INTEGER INLPPC
C        THE FIRST DIMENSION OF THE ARRAY NLPPC.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER ITEST
C        THE NUMBER OF THE TEST BEING PERFORMED
C     INTEGER IYM, IYMFFT
C        THE FIRST DIMENSION OF THE ARRAYS YM AND YMFFT, RESPECTIVELY.
C     INTEGER JCCOV, JNLPPC
C        THE SECOND DIMENSIONS OF THE ARRAYS CCOV AND NLPPC,
C        RESPECTIVELY.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE REQUESTED.
C     INTEGER LDS, LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LYFFT
C        THE LENGTH OF THE ARRAYS USED WHEN THE COMPUTATIONS ARE
C        PERFORMED BY THE FFT.
C     INTEGER M
C        THE NUMBER OF SERIES IN THE MULTIVARIATE TIME SERIES YM.
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NLAG
C        THE NUMBER OF LAGS AT WHICH THE ACVF WAS COMPUTED.
C     INTEGER NLPPC(30,5,5)
C        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
C        USED TO COMPUTE EACH ACVF ESTIMATE.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO OUTPUT IS MADE.
C     INTEGER NYD
C        THE NUMBER OF OBSERVATIONS IN THE SERIES TO BE DIFFERENCED.
C     DOUBLE PRECISION YFFT1(150), YFFT2(150)
C        THE VECTORS USED FOR STORING THE SERIES FOR THE ROUTINES
C        USING THE FFT.
C     DOUBLE PRECISION YM(150,5), YMFFT(150,5)
C        THE ARRAYS USED FOR MULTIVARIATE TIME SERIES.
C     DOUBLE PRECISION YMISS0, YMMISS(5)
C        THE MISSING VALUE CODES FOR SERIES Y AND YM.
C     DOUBLE PRECISION Y1(100), Y1MISS
C        THE FIRST SERIES, AND ITS MISSING VALUE CODE.
C     DOUBLE PRECISION Y2(100), Y2MISS
C        THE SECOND SERIES, AND ITS MISSING VALUE CODE.
C
C
      DATA   Y1(  1),  Y1(  2),  Y1(  3),  Y1(  4),  Y1(  5),  Y1(  6)
     +    /-0.88D0, -0.16D0, -1.87D0, -1.12D0,  1.38D0,  2.13D0/
      DATA   Y1(  7),  Y1(  8),  Y1(  9),  Y1( 10),  Y1( 11),  Y1( 12)
     +    / 2.76D0,  0.56D0, -0.69D0, -1.79D0, -3.82D0, -2.38D0/
      DATA   Y1( 13),  Y1( 14),  Y1( 15),  Y1( 16),  Y1( 17),  Y1( 18)
     +    / 1.00D0,  0.70D0, -0.15D0,  0.98D0,  0.11D0, -0.35D0/
      DATA   Y1( 19),  Y1( 20),  Y1( 21),  Y1( 22),  Y1( 23),  Y1( 24)
     +    /-0.73D0,  0.89D0, -1.63D0, -0.44D0, -1.37D0, -1.71D0/
      DATA   Y1( 25),  Y1( 26),  Y1( 27),  Y1( 28),  Y1( 29),  Y1( 30)
     +    /-1.22D0, -2.00D0, -0.22D0,  0.38D0,  1.31D0,  0.71D0/
      DATA   Y1( 31),  Y1( 32),  Y1( 33),  Y1( 34),  Y1( 35),  Y1( 36)
     +    / 0.32D0,  0.48D0, -1.88D0, -0.94D0, -1.54D0, -0.13D0/
      DATA   Y1( 37),  Y1( 38),  Y1( 39),  Y1( 40),  Y1( 41),  Y1( 42)
     +    / 1.02D0,  0.02D0, -0.77D0,  0.11D0, -0.60D0, -0.52D0/
      DATA   Y1( 43),  Y1( 44),  Y1( 45),  Y1( 46),  Y1( 47),  Y1( 48)
     +    /-0.09D0,  1.23D0,  1.46D0,  0.61D0,  0.42D0,  2.16D0/
      DATA   Y1( 49),  Y1( 50),  Y1( 51),  Y1( 52),  Y1( 53),  Y1( 54)
     +    / 3.18D0,  2.10D0,  0.37D0, -0.24D0,  0.57D0, -0.53D0/
      DATA   Y1( 55),  Y1( 56),  Y1( 57),  Y1( 58),  Y1( 59),  Y1( 60)
     +    / 2.44D0,  1.02D0, -0.53D0, -2.49D0, -2.12D0, -1.04D0/
      DATA   Y1( 61),  Y1( 62),  Y1( 63),  Y1( 64),  Y1( 65),  Y1( 66)
     +    /-0.12D0, -1.88D0, -1.50D0,  1.54D0,  3.33D0,  3.08D0/
      DATA   Y1( 67),  Y1( 68),  Y1( 69),  Y1( 70),  Y1( 71),  Y1( 72)
     +    / 1.71D0,  0.79D0,  1.55D0,  0.89D0, -0.89D0, -1.18D0/
      DATA   Y1( 73),  Y1( 74),  Y1( 75),  Y1( 76),  Y1( 77),  Y1( 78)
     +    / 0.89D0,  1.71D0,  3.05D0,  0.15D0, -1.04D0,  0.12D0/
      DATA   Y1( 79),  Y1( 80),  Y1( 81),  Y1( 82),  Y1( 83),  Y1( 84)
     +    / 0.08D0,  0.11D0, -2.62D0, -1.28D0,  1.07D0,  3.20D0/
      DATA   Y1( 85),  Y1( 86),  Y1( 87),  Y1( 88),  Y1( 89),  Y1( 90)
     +    / 1.92D0,  0.53D0, -1.08D0,  0.49D0, -0.58D0,  0.17D0/
      DATA   Y1( 91),  Y1( 92),  Y1( 93),  Y1( 94),  Y1( 95),  Y1( 96)
     +    / 1.15D0, -0.97D0, -1.63D0,  1.14D0, -0.67D0, -0.88D0/
      DATA   Y1( 97),  Y1( 98),  Y1( 99),  Y1(100)
     +    /-0.07D0,  0.24D0,  0.55D0, -2.16D0/
      DATA   Y2(  1),  Y2(  2),  Y2(  3),  Y2(  4),  Y2(  5),  Y2(  6)
     +    / 0.79D0,  1.12D0, -1.10D0, -2.39D0, -1.75D0, -0.82D0/
      DATA   Y2(  7),  Y2(  8),  Y2(  9),  Y2( 10),  Y2( 11),  Y2( 12)
     +    /-0.36D0,  1.27D0,  1.75D0,  2.44D0,  0.36D0, -2.10D0/
      DATA   Y2( 13),  Y2( 14),  Y2( 15),  Y2( 16),  Y2( 17),  Y2( 18)
     +    /-1.93D0, -1.30D0, -1.75D0, -0.34D0,  0.74D0,  0.49D0/
      DATA   Y2( 19),  Y2( 20),  Y2( 21),  Y2( 22),  Y2( 23),  Y2( 24)
     +    / 0.70D0,  0.71D0,  0.09D0,  0.59D0,  1.54D0,  0.14D0/
      DATA   Y2( 25),  Y2( 26),  Y2( 27),  Y2( 28),  Y2( 29),  Y2( 30)
     +    / 0.55D0, -1.40D0, -2.55D0, -1.66D0, -0.43D0,  0.58D0/
      DATA   Y2( 31),  Y2( 32),  Y2( 33),  Y2( 34),  Y2( 35),  Y2( 36)
     +    / 2.18D0, -0.24D0,  0.58D0, -0.18D0, -1.55D0, -0.64D0/
      DATA   Y2( 37),  Y2( 38),  Y2( 39),  Y2( 40),  Y2( 41),  Y2( 42)
     +    /-1.09D0,  0.90D0, -0.66D0, -0.35D0,  0.48D0,  0.50D0/
      DATA   Y2( 43),  Y2( 44),  Y2( 45),  Y2( 46),  Y2( 47),  Y2( 48)
     +    / 0.05D0, -0.68D0,  0.24D0,  0.58D0, -1.26D0, -0.25D0/
      DATA   Y2( 49),  Y2( 50),  Y2( 51),  Y2( 52),  Y2( 53),  Y2( 54)
     +    / 0.25D0,  2.18D0,  2.96D0,  1.56D0, -0.36D0, -0.59D0/
      DATA   Y2( 55),  Y2( 56),  Y2( 57),  Y2( 58),  Y2( 59),  Y2( 60)
     +    /-0.12D0,  3.03D0,  2.11D0,  0.78D0,  0.89D0, -1.45D0/
      DATA   Y2( 61),  Y2( 62),  Y2( 63),  Y2( 64),  Y2( 65),  Y2( 66)
     +    /-0.36D0, -0.37D0, -1.39D0, -4.19D0, -0.73D0, -0.98D0/
      DATA   Y2( 67),  Y2( 68),  Y2( 69),  Y2( 70),  Y2( 71),  Y2( 72)
     +    / 0.36D0,  0.06D0, -1.94D0, -0.08D0,  0.17D0,  1.00D0/
      DATA   Y2( 73),  Y2( 74),  Y2( 75),  Y2( 76),  Y2( 77),  Y2( 78)
     +    /-0.05D0,  0.43D0,  0.15D0,  2.69D0,  0.57D0,  0.29D0/
      DATA   Y2( 79),  Y2( 80),  Y2( 81),  Y2( 82),  Y2( 83),  Y2( 84)
     +    / 1.10D0,  0.48D0, -1.06D0, -2.28D0, -2.03D0, -0.75D0/
      DATA   Y2( 85),  Y2( 86),  Y2( 87),  Y2( 88),  Y2( 89),  Y2( 90)
     +    / 1.00D0,  1.71D0,  0.58D0,  1.97D0,  0.99D0,  1.94D0/
      DATA   Y2( 91),  Y2( 92),  Y2( 93),  Y2( 94),  Y2( 95),  Y2( 96)
     +    / 2.18D0,  3.14D0,  0.60D0,  0.51D0,  1.35D0,  0.56D0/
      DATA   Y2( 97),  Y2( 98),  Y2( 99),  Y2(100)
     +    / 0.11D0,  0.00D0,  2.34D0,  1.88D0/
C
      CALL IPRINT(IPRT)
      ITEST = 1
      LDSTAK = LDS
C
      N = 100
      LAGMAX = 20
      NLAG = 30
      NPRT = 1
      LYFFT = 150
      ICCOV = 30
      JCCOV = 5
      IYM = 150
      M = 4
      IYMFFT = 150
      INLPPC = 30
      JNLPPC = 5
      NYD = 144
      YMISS0 = 1.16D0
      Y1MISS = 0.89D0
      Y2MISS = 0.89D0
C
C     COPY DATA INTO YM FOR CCFS AND CCFMS
C
      CALL DCOPY(N, Y1, 1, YM(1,1), 1)
      CALL DCOPY(N, Y2, 1, YM(1,2), 1)
      CALL DCOPY(N, Y1, 1, YM(1,3), 1)
      CALL DCOPY(N, Y2, 1, YM(1,4), 1)
      CALL SETRV(YMMISS, 4, YMISS0)
C
C     TEST OF CCF
C
      WRITE (IPRT,1060)
      CALL CCF(Y1, Y2, N)
C
C     PRINT RETURNED RESULTS
C
      CALL CCFXP (.FALSE., LAGMAX, M, CCOV, ICCOV, JCCOV, .FALSE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
C
C     TEST OF CCFS
C
      WRITE (IPRT,1080)
      CALL CCFS(YM, N, M, IYM, LAGMAX, CCOV, ICCOV, JCCOV, NPRT,
     +   LDSTAK)
C
C     PRINT RETURNED RESULTS
C
      CALL CCFXP (.TRUE., LAGMAX, M, CCOV, ICCOV, JCCOV, .FALSE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
C
C     TEST OF CCFM WITHOUT MISSING VALUES
C
      WRITE (IPRT,1070)
      WRITE (IPRT, 1050)
      CALL CCFM(Y1, YMISS0, Y2, YMISS0, N)
C
C     PRINT RETURNED RESULTS
C
      CALL CCFXP (.FALSE., LAGMAX, M, CCOV, ICCOV, JCCOV, .TRUE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
C
C     TEST OF CCFMS WITHOUT MISSING VALUES
C
      WRITE (IPRT,1140)
      WRITE (IPRT, 1050)
      CALL CCFMS(YM, YMMISS, N, M, IYM, LAGMAX, CCOV, CMISS,
     +   ICCOV, JCCOV, NLPPC, INLPPC, JNLPPC, NPRT, LDSTAK)
C
C     PRINT RETURNED RESULTS
C
      CALL CCFXP (.TRUE., LAGMAX, M, CCOV, ICCOV, JCCOV, .TRUE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
C
C     COPY DATA INTO YFFT1, YFFT2 AND YMFFT FOR CCFF AND CCFFS
C
      CALL DCOPY(N, Y1, 1, YFFT1, 1)
      CALL DCOPY(N, Y2, 1, YFFT2, 1)
      CALL DCOPY(N, Y1, 1, YMFFT(1,1), 1)
      CALL DCOPY(N, Y2, 1, YMFFT(1,2), 1)
      CALL DCOPY(N, Y1, 1, YMFFT(1,3), 1)
      CALL DCOPY(N, Y2, 1, YMFFT(1,4), 1)
C
C     TEST OF CCFF
C
      WRITE (IPRT,1100)
      CALL CCFF(YFFT1, YFFT2, N, LYFFT, LDSTAK)
C
C     PRINT RETURNED RESULTS
C
      CALL CCFXP (.FALSE., LAGMAX, M, CCOV, ICCOV, JCCOV, .FALSE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
C
C     TEST OF CCFFS
C
      WRITE (IPRT,1150)
      CALL CCFFS(YMFFT, N, M, IYMFFT, LAGMAX, CCOV,
     +   ICCOV, JCCOV, NPRT, LDSTAK)
C
C     PRINT RETURNED RESULTS
C
      CALL CCFXP (.TRUE., LAGMAX, M, CCOV, ICCOV, JCCOV, .FALSE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
C
C     RESET YMMISS
C
      YMMISS(1) = Y1MISS
      YMMISS(2) = Y2MISS
      YMMISS(3) = Y1MISS
      YMMISS(4) = Y2MISS
C
C     TEST OF CCFM WITH MISSING VALUES
C
      WRITE (IPRT,1070)
      WRITE (IPRT, 1040)
      CALL CCFM(Y1, Y1MISS, Y2, Y2MISS, N)
C
C     PRINT RETURNED RESULTS
C
      CALL CCFXP (.FALSE., LAGMAX, M, CCOV, ICCOV, JCCOV, .TRUE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
C
C     TEST OF CCFMS WITH MISSING VALUES
C
      WRITE (IPRT,1140)
      WRITE (IPRT, 1040)
      CALL CCFMS(YM, YMMISS, N, M, IYM, LAGMAX, CCOV, CMISS,
     +   ICCOV, JCCOV, NLPPC, INLPPC, JNLPPC, NPRT, LDSTAK)
C
C     PRINT RETURNED RESULTS
C
      CALL CCFXP (.TRUE., LAGMAX, M, CCOV, ICCOV, JCCOV, .TRUE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
C
C     TEST PRINT CONTROL
C
      NPRT = 0
C
C     TEST OF CCFS
C
      WRITE (IPRT,1080)
      WRITE (IPRT, 1020)
      CALL CCFS(YM, N, M, LAGMAX, IYM, CCOV, ICCOV, JCCOV, NPRT,
     +   LDSTAK)
C
C     PRINT RETURNED RESULTS
C
      CALL CCFXP (.TRUE., LAGMAX, M, CCOV, ICCOV, JCCOV, .FALSE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
C
C     TEST OF CCFMS WITH MISSING VALUES
C
      WRITE (IPRT,1140)
      WRITE (IPRT, 1040)
      WRITE (IPRT, 1020)
      CALL CCFMS(YM, YMMISS, N, M, IYM, LAGMAX, CCOV, CMISS,
     +   ICCOV, JCCOV, NLPPC, INLPPC, JNLPPC, NPRT, LDSTAK)
C
C     PRINT RETURNED RESULTS
C
      CALL CCFXP (.TRUE., LAGMAX, M, CCOV, ICCOV, JCCOV, .TRUE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
C
C     COPY DATA INTO YMFFT FOR CCFFS
C
      CALL DCOPY(N, Y1, 1, YMFFT(1,1), 1)
      CALL DCOPY(N, Y2, 1, YMFFT(1,2), 1)
      CALL DCOPY(N, Y1, 1, YMFFT(1,3), 1)
      CALL DCOPY(N, Y2, 1, YMFFT(1,4), 1)
C
C     TEST OF CCFFS
C
      WRITE (IPRT,1150)
      WRITE (IPRT, 1020)
      CALL CCFFS(YMFFT, N, M, IYMFFT, LAGMAX, CCOV,
     +   ICCOV, JCCOV, NPRT, LDSTAK)
C
C     PRINT RETURNED RESULTS
C
      CALL CCFXP (.TRUE., LAGMAX, M, CCOV, ICCOV, JCCOV, .FALSE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
C
C     TEST LEAD/LAG MESSAGE
C
      NPRT = 1
C
      CALL SETRA(YMFFT, IYMFFT, M, N, 0.0D0)
      YMFFT(5,1) = 1.0D0
      YMFFT(15,2) = 1.0D0
      YMFFT(5,3) = YMFFT(5,1)
      YMFFT(15,4) = YMFFT(15,2)
C
C     TEST OF CCFFS
C
      WRITE (IPRT,1150)
      WRITE (IPRT, 1020)
      CALL CCFFS(YMFFT, N, M, IYMFFT, LAGMAX, CCOV,
     +   ICCOV, JCCOV, NPRT, LDSTAK)
C
C     PRINT RETURNED RESULTS
C
      CALL CCFXP (.TRUE., LAGMAX, M, CCOV, ICCOV, JCCOV, .FALSE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
C
      GO TO (100, 200, 300, 400), ITEST
C
C     TEST MINIMUM PROBLEM SIZE
C
  100 ITEST = ITEST + 1
      N = 3
      LAGMAX = 1
      LYFFT = 150
      ICCOV = 30
      JCCOV = 5
      IYM = 150
      M = 1
      IYMFFT = 150
      INLPPC = 30
      JNLPPC = 5
      NYD = 144
      YMISS0 = 1.16D0
      Y1MISS = 0.89D0
      Y2MISS = 0.89D0
C
C     TEST ERROR HANDLING
C
  200 ITEST = ITEST + 1
      N = 0
      LAGMAX = 1
      LYFFT = 0
      ICCOV = 0
      JCCOV = 0
      IYM = 0
      M = 0
      IYMFFT = 0
      INLPPC = 0
      JNLPPC = 0
      NYD = 0
C
C     TEST ERROR HANDLING
C
  300 ITEST = ITEST + 1
      N = 100
      LAGMAX = 100
      LYFFT = 0
      ICCOV = 0
      JCCOV = 0
      IYM = 0
      M = 0
      IYMFFT = 0
      INLPPC = 0
      JNLPPC = 0
      NYD = 144
      LDSTAK = 0
C
  400 RETURN
C
C     FORMAT STATEMENTS
C
 1020 FORMAT (18H OUTPUT SUPPRESSED)
 1040 FORMAT (20H WITH MISSING VALUES)
 1050 FORMAT (23H WITHOUT MISSING VALUES)
 1060 FORMAT ('1', 11HTEST OF CCF)
 1070 FORMAT ('1', 12HTEST OF CCFM)
 1080 FORMAT ('1', 12HTEST OF CCFS)
 1100 FORMAT ('1', 12HTEST OF CCFF)
 1140 FORMAT ('1', 13HTEST OF CCFMS)
 1150 FORMAT ('1', 13HTEST OF CCFFS)
      END
*XCORR
      SUBROUTINE XCORR(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS ROUTINE EXERCISES ALL ASPECTS OF THE CORRELATION
C     FAMILY ROUTINES
C
C     WRITTEN BY -
C        LINDA MITCHELL
C        STATISTICAL ENGINEERING DIVISION
C        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT,IVCV,IYM,J,LDSMIN,M,N
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   VCV(4,4),YM(10,4),Z(10,4)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CORR,CORRS,CORRXP,GENR,IPRINT,LDSCMP,MSGX,SETRA
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER I
C         AN INDEX VARIABLE.
C     INTEGER IERR
C        COMMON FLAG INDICATING IF ANY ERRORS WERE DETECTED
C        IF IERR = 0, THEN NO ERRORS WERE FOUND
C     INTEGER IPRT
C        THE OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IVCV
C        THE ROW DIMENSION OF VCV
C     INTEGER IYM
C        THE ROW DIMENSION OF YM
C     INTEGER J
C        AN INDEX VARIABLE.
C     INTEGER LDSMIN
C        THE SMALLEST ACCEPTABLE SIZE OF COMMON AREA CSTAK
C     INTEGER LDSTAK
C        THE SIZE OF THE COMMON AREA CSTAK
C     INTEGER M
C        THE NUMBER OF VARIABLES
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS
C     DOUBLE PRECISION VCV(4,4)
C        THE VARIANCE COVARIANCE MATRIX
C     DOUBLE PRECISION YM(10,4)
C        GENERAL DATA SET, FROM DRAPER AND SMITH
C     DOUBLE PRECISION Z(10,4)
C        TEST OBSERVATION MATRIX
C
C     THIS DATA SET TAKEN FROM
C        APPLIED REGRESSION ANALYSIS
C        DRAPER AND SMITH
C        PAGE 216
C
      DATA     YM(1,1),   YM(1,2),   YM(1,3),   YM(1,4)
     +    /      42.2D0,  11.2D0,  31.9D0, 167.1D0/
      DATA     YM(2,1),   YM(2,2),   YM(2,3),   YM(2,4)
     +    /      48.6D0,  10.6D0,  13.2D0, 174.4D0/
      DATA     YM(3,1),   YM(3,2),   YM(3,3),   YM(3,4)
     +    /      42.6D0,  10.6D0,  28.7D0, 160.8D0/
      DATA     YM(4,1),   YM(4,2),   YM(4,3),   YM(4,4)
     +    /      39.0D0,  10.4D0,  26.1D0, 162.0D0/
      DATA     YM(5,1),   YM(5,2),   YM(5,3),   YM(5,4)
     +    /      34.7D0,   9.3D0,  30.1D0, 140.8D0/
      DATA     YM(6,1),   YM(6,2),   YM(6,3),   YM(6,4)
     +    /      44.5D0,  10.8D0,   8.5D0, 174.6D0/
      DATA     YM(7,1),   YM(7,2),   YM(7,3),   YM(7,4)
     +    /      39.1D0,  10.7D0,  24.3D0, 163.7D0/
      DATA     YM(8,1),   YM(8,2),   YM(8,3),   YM(8,4)
     +    /      40.1D0,  10.0D0,  18.6D0, 174.5D0/
      DATA     YM(9,1),   YM(9,2),   YM(9,3),   YM(9,4)
     +    /      45.9D0,  12.0D0,  20.4D0, 185.7D0/
C
C     DETERMINE OUTPUT UNIT
C
      CALL IPRINT(IPRT)
C
      IVCV = 4
      IYM = 10
      M = 4
      N = 9
      IERR = 0
C
C**** TEST ROUTINES WITH CORRECT CALL STATEMENT *****
C
      WRITE (IPRT,1000)
      WRITE (IPRT,1010)
C
C     TEST CORR
C
      WRITE (IPRT,1020)
      WRITE (IPRT,1060)
      CALL CORR(YM, N, M, IYM, LDSTAK)
      CALL MSGX(0, IPRT)
C
C     TEST CORRS
C
C     PRINTOUT SUPPRESSED
C
      WRITE (IPRT,1030)
      WRITE (IPRT,1040)
      WRITE (IPRT,1060)
      CALL CORRS(YM, N, M, IYM, LDSTAK, 0, VCV, IVCV)
      CALL MSGX(0, IPRT)
C
C     PRINT STORED OUTPUT AND ZERO ARRAYS
C
      CALL CORRXP(M, VCV, IVCV, IPRT)
C
C     WITH PRINTOUT
C
      WRITE (IPRT,1050)
      WRITE (IPRT,1060)
      CALL CORRS(YM, N, M, IYM, LDSTAK, 1, VCV, IVCV)
      CALL MSGX(0, IPRT)
C
C     PRINT STORED OUTPUT
C
      CALL CORRXP(M, VCV, IVCV, IPRT)
C
C**** SPECIAL 2 COLUMN MATRIX ****
C
      WRITE (IPRT,1070)
      WRITE (IPRT,1060)
      CALL CORR(YM, N, 2, IYM, LDSTAK)
      CALL MSGX(0, IPRT)
C
C**** TEST WORK AREA REQUIREMENTS ****
C
C     TEST CORR
C
      CALL LDSCMP(12, 0, MAX(N,M), 0, 0, 0, 'D',
     +   M*M + (MAX(N,M)+M+N*(M+3)+6*M*M), LDSMIN)
      WRITE (IPRT,1090)
      CALL CORR(YM, N, M, IYM, LDSMIN-1)
      CALL MSGX(1, IPRT)
      WRITE (IPRT,1100)
      CALL CORR(YM, N, M, IYM, LDSMIN)
      CALL MSGX(0, IPRT)
C
C     TEST CORRS WITH PRINTOUT
C
      CALL LDSCMP(12, 0, MAX(N,M), 0, 0, 0, 'D',
     +   MAX(N,M)+M+N*(M+3)+6*M*M, LDSMIN)
      WRITE (IPRT,1090)
      CALL CORRS(YM, N, M, IYM, LDSMIN-1, 1, VCV, IVCV)
      CALL MSGX(1, IPRT)
      WRITE (IPRT,1100)
      CALL CORRS(YM, N, M, IYM, LDSMIN, 1, VCV, IVCV)
      CALL CORRXP(M, VCV, IVCV, IPRT)
      CALL MSGX(0, IPRT)
C
C     TEST CORRS WITHOUT PRINTOUT
C
      CALL LDSCMP(12, 0, 0, 0, 0, 0, 'D', 0, LDSMIN)
      WRITE (IPRT,1090)
      CALL CORRS(YM, N, M, IYM, LDSMIN-1, 0, VCV, IVCV)
      CALL MSGX(1, IPRT)
      WRITE (IPRT,1100)
      CALL CORRS(YM, N, M, IYM, LDSMIN, 0, VCV, IVCV)
      CALL CORRXP(M, VCV, IVCV, IPRT)
      CALL MSGX(0, IPRT)
C
C**** NUMBER OF VARIABLES LESS THAN 2 ****
C
      WRITE (IPRT,1110)
C
C     TEST CORR
C
      CALL CORR(YM, N, 1, IYM, LDSTAK)
      CALL MSGX(1, IPRT)
C
C     TEST CORRS
C
      CALL CORRS(YM, N, 1, IYM, LDSTAK, 1, VCV, IVCV)
      CALL MSGX(1, IPRT)
C
C**** NUMBER OF OBSERVATIONS LESS THAN 3 ****
C
      WRITE (IPRT,1120)
C
C     TEST CORR
C
      CALL CORR(YM, 2, 4, IYM, LDSTAK)
      CALL MSGX(1, IPRT)
C
C     TEST CORRS
C
      CALL CORRS(YM, 2, 4, IYM, LDSTAK, 1, VCV, IVCV)
      CALL MSGX(1, IPRT)
C
C**** OBSERVATION MATRIX DIMENSIONED LESS THAN N ****
C
      WRITE (IPRT,1150)
C
C     TEST CORR
C
      CALL CORR(YM, N, M, 8, LDSTAK)
      CALL MSGX(1, IPRT)
C
C     TEST CORRS
C
      CALL CORRS(YM, N, M, 8, LDSTAK, 1, VCV, IVCV)
      CALL MSGX(1, IPRT)
C
C**** VCV MATRIX DIMENSIONED LESS THAN M ****
C
      WRITE (IPRT,1130)
      CALL CORRS(YM, N, M, IYM, LDSTAK, 1, VCV, 2)
      CALL MSGX(1, IPRT)
C
C**** ALL OBSERVATIONS ON A SINGLE VARIABLE EQUAL TO ZERO ****
C
      WRITE (IPRT,1140)
      CALL SETRA(Z, 10, 4, 10, 0.0D0)
      CALL CORR(Z, 9, 4, 10, LDSTAK)
      CALL MSGX(1, IPRT)
      CALL CORRS(Z, 9, 4, 10, LDSTAK, 1, VCV, IVCV)
      CALL CORRXP(M, VCV, IVCV, IPRT)
      CALL MSGX(1, IPRT)
C
      DO 10 I=1,10
         Z(I,1) = I
         Z(I,2) = 0.0D0
   10 CONTINUE
      CALL CORR(Z, 10, 4, 10, LDSTAK)
      CALL MSGX(1, IPRT)
C
C**** ARRAY FILLED WITH A SINGLE VALUE ****
C
      WRITE (IPRT,1160)
      CALL SETRA(Z, 10, 4, 10, 4.0D0)
      CALL CORR(Z, 4, 10, 4, LDSTAK)
      CALL MSGX(1, IPRT)
C
C**** 2 COLUMNS THE SAME ****
C
      DO 20 I=1,3
         CALL GENR(Z(1,I), 5, 5.0D0*I, 5.0D0*I)
   20 CONTINUE
      DO 30 I=1,5
         Z(I,4) = Z(I,3)
   30 CONTINUE
      WRITE (IPRT,1170)
      CALL CORR(Z, 5, 4, 10, LDSTAK)
      CALL MSGX(1, IPRT)
C
C**** 2 COLUMNS INVERSELY RELATED ****
C
      J = 5
      DO 40 I=1,5
         J = J - 1
         Z(J,4) = Z(I,3)
   40 CONTINUE
      WRITE (IPRT,1170)
      CALL CORR(Z, 5, 4, 10, LDSTAK)
      CALL MSGX(1, IPRT)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT('1')
 1010 FORMAT(' ****TEST ROUTINES WITH CORRECT CALL****')
 1020 FORMAT(' TEST OF CORR')
 1030 FORMAT('1TEST OF CORRS')
 1040 FORMAT(' PRINTOUT SUPRESSED.')
 1050 FORMAT('1PRINTOUT NOT SUPRESSED.')
 1060 FORMAT(' DRAPER AND SMITH DATA SET (PAGE 216).')
 1070 FORMAT('1****SPECIAL CASE 2 COLUMN MATRIX****')
 1090 FORMAT('1****TEST WITH INSUFFICIENT WORK AREA****')
 1100 FORMAT('1****TEST WITH EXACTLY THE RIGHT AMOUNT OF WORK AREA****')
 1110 FORMAT('1****NUMBER OF VARIABLES LESS THAN 2****')
 1120 FORMAT(' ****NUMBER OF OBSERVATIONS LESS THAN 3****')
 1130 FORMAT(' ****INADEQUATE SPACE IN STORAGE ARRAYS****')
 1140 FORMAT('1****ALL OBSERVATIONS ON A VARIABLE EQUAL TO ZERO****')
 1150 FORMAT(' ****OBSERVATION MATRIX DIMENSIONED LESS THAN NUMBER',
     +       ' OF OBSERVATIONS DESIGNATED****')
 1160 FORMAT('1****ARRAY CONTAINING A SINGLE VALUE****')
 1170 FORMAT('1****2 COLUMNS RELATED****')
      END
*XDCKLD
      SUBROUTINE XDCKLD(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA
      INTEGER
     +   I,IPRT,IXM,LDSMIN,M,N,NETA,NPAR,NPRT,NROW,NTAU,NTEST
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(10),SCALE(10),XM(200,2)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DCKLS,DCKLS1,DCKLSC,DRV4A,IPRINT,LDSCMP,MDL4
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        *
C     EXTERNAL DRV4A
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL4
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS OF DATA.
C     INTEGER NETA
C        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
C     INTEGER NROW
C        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
C        WHICH THE DERIVATIVE IS TO BE CHECKED.
C     INTEGER NTAU
C        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
C        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
C     INTEGER NTEST
C        THE NUMBER OF THE CURRENT TEST.
C     DOUBLE PRECISION PAR(10)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION SCALE(10)
C        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION XM(200,2)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
      CALL IPRINT(IPRT)
C
C     SET PARAMETER VALUES
C
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
      CALL LDSCMP(5, 0, 2*NPAR+1, 0, 0, 0, 'D',
     +            N*NPAR+NPAR+N, LDSMIN)
C
      IF (LDSMIN.GT.LDSTAK) THEN
         WRITE (IPRT, 1020) LDSMIN
         RETURN
      END IF
C
C     CREATE INDEPENDENT VARIABLE
C
      DELTA = 0.0625D0
      XM(1,1) = 0.0D0
      DO 10 I=2,N
         XM(I,1) = XM(I-1,1) + DELTA
   10 CONTINUE
C
      NTEST = 0
C
C
C
C     CHECK RESULTS FROM VALID CALLS
C
C     SIMPLE EXAMPLE
C
C     CHECK RESULT FOR CORRECTLY COMPUTED DERIVATIVE
C
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1100)
      WRITE (IPRT,1040)
      WRITE (IPRT,1000)
      IERR = -1
      CALL DCKLS(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSMIN)
      WRITE (IPRT,1050) IERR
C
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1100)
      WRITE (IPRT,1040)
      WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROW, NPRT
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSMIN, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROW, NPRT
C
C
      RETURN
C
C     FORMAT STATEMENTS
C
C
 1000 FORMAT (15H TEST OF DCKLS )
 1010 FORMAT (15H TEST OF DCKLSC)
 1020 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1040 FORMAT (15H SIMPLE EXAMPLE)
 1050 FORMAT (29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1060 FORMAT (19H INPUT   -  NETA = , I5, 9H, NTAU = , I5,
     +   13H, SCALE(1) = , G15.8, 9H, NROW = , I5, 9H, NPRT = , I5)
 1100 FORMAT (27H CORRECTLY CODED DERIVATIVE)
 1130 FORMAT (43H1DERIVATIVE CHECKING SUBROUTINE TEST NUMBER, I5/)
 1140 FORMAT (19H OUTPUT  -  NETA = , I5, 9H, NTAU = , I5,
     +   13H, SCALE(1) = , G15.8, 9H, NROW = , I5, 9H, NPRT = , I5//)
      END
*XDCKLE
      SUBROUTINE XDCKLE(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA
      INTEGER
     +   I,IPRT,IXM,LDSMIN,M,N,NETA,NPAR,NPRT,NROW,NTAU,NTEST
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(10),SCALE(10),XM(200,2)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DCKLS,DCKLS1,DCKLSC,DRV4A,DRV4B,IPRINT,LDSCMP,MDL4
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        *
C     EXTERNAL DRV4A, DRV4B
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL4
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS OF DATA.
C     INTEGER NETA
C        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
C     INTEGER NROW
C        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
C        WHICH THE DERIVATIVE IS TO BE CHECKED.
C     INTEGER NTAU
C        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
C        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
C     INTEGER NTEST
C        THE NUMBER OF THE CURRENT TEST.
C     DOUBLE PRECISION PAR(10)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION SCALE(10)
C        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION XM(200,2)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
      CALL IPRINT(IPRT)
C
C     SET PARAMETER VALUES
C
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
      CALL LDSCMP(5, 0, 2*NPAR+1, 0, 0, 0, 'D',
     +            N*NPAR+NPAR+N, LDSMIN)
C
      IF (LDSMIN.LE.LDSTAK) GO TO 5
C
      WRITE (IPRT, 1040) LDSMIN
      RETURN
C
    5 CONTINUE
C
C     CREATE INDEPENDENT VARIABLE
C
      DELTA = 0.0625D0
      XM(1,1) = 0.0D0
      DO 10 I=2,N
         XM(I,1) = XM(I-1,1) + DELTA
   10 CONTINUE
C
      NTEST = 0
C
C     CHECK ERROR HANDLING
C
C        TEST 1  -  MISCELANEOUS ERROR CHECKING
C
      N = -5
      M = -5
      IXM = -10
      NPAR = -10
C
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1020)
      WRITE (IPRT,1000)
      IERR = -1
      CALL DCKLS(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSTAK)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSTAK, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
C
C        TEST 2  -  MISCELANEOUS ERROR CHECKING (CONTINUED)
C
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
      SCALE(2) = 0.0D0
C
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1030)
      WRITE (IPRT,1000)
      IERR = -1
      CALL DCKLS(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSMIN-1)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSMIN-1,
     +   NETA, NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
C
      RETURN
C
C     FORMAT STATEMENTS
C
C
 1000 FORMAT (15H TEST OF DCKLS )
 1010 FORMAT (15H TEST OF DCKLSC)
 1020 FORMAT (32H CHECK ERROR HANDLING  -  TEST 1)
 1030 FORMAT (32H CHECK ERROR HANDLING  -  TEST 2)
 1040 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1050 FORMAT (29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1130 FORMAT (43H1DERIVATIVE CHECKING SUBROUTINE TEST NUMBER, I5)
      END
*XDCKLT
      SUBROUTINE XDCKLT(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA
      INTEGER
     +   I,IPRT,IXM,J,JSTOP,LDSMIN,M,N,NETA,NPAR,NPRT,NROW,NTAU,
     +   NTEST
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(10),SCALE(10),XM(200,2)
      INTEGER
     +   NETTST(6),NROTST(5),NTATST(6)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DCKLS,DCKLS1,DCKLSC,DRV4A,DRV4B,IPRINT,LDSCMP,MDL4,SETRV
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG10
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        *
C     EXTERNAL DRV4A, DRV4B
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER J, JSTOP
C        *
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL4
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS OF DATA.
C     INTEGER NETA
C        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
C     INTEGER NETTST(6)
C        VARIOUS TEST VALUES FOR NETA.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
C     INTEGER NROTST(5)
C        VARIOUS TEST VALUES FOR NROW.
C     INTEGER NROW
C        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
C        WHICH THE DERIVATIVE IS TO BE CHECKED.
C     INTEGER NTATST(6)
C         VARIOUS TEST VALUES FOR NTAU.
C     INTEGER NTAU
C        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
C        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
C     INTEGER NTEST
C        THE NUMBER OF THE CURRENT TEST.
C     DOUBLE PRECISION PAR(10)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION SCALE(10)
C        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION XM(200,2)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
      CALL IPRINT(IPRT)
C
C     SET PARAMETER VALUES
C
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
      CALL LDSCMP(5, 0, 2*NPAR+1, 0, 0, 0, 'D',
     +            N*NPAR+NPAR+N, LDSMIN)
C
      IF (LDSMIN.LE.LDSTAK) GO TO 5
C
      WRITE (IPRT, 1020) LDSMIN
      RETURN
C
    5 CONTINUE
C
C     CREATE INDEPENDENT VARIABLE
C
      DELTA = 0.0625D0
      XM(1,1) = 0.0D0
      DO 10 I=2,N
         XM(I,1) = XM(I-1,1) + DELTA
   10 CONTINUE
C
      NTEST = 0
C
C
C     TEST VARIOUS VALUES OF NETA AND NTAU
C
      SCALE(1) = 0.0D0
C
      NETTST(1) = -1
      NETTST(2) = 0
      NETTST(3) = 1
      NETTST(4) = 2
C
      NETTST(5) = -LOG10(D1MACH(4))
      NETTST(6) = NETTST(5) + 1
C
      NTATST(1) = -1
      NTATST(2) = 0
      NTATST(3) = 1
C
      JSTOP = 3
C
      DO 30 I=1,6
C
         NTATST(4) = NETTST(I)/4
         IF (I.LE.5) THEN
            NTATST(5) = (NETTST(I)-1)/2
            NTATST(6) = NTATST(5) + 1
         END IF
C
         IF (I.EQ.5) JSTOP = 6
C
         DO 20 J=1,JSTOP
C
            NTEST = NTEST + 1
            WRITE (IPRT,1130) NTEST
            WRITE (IPRT,1100)
            WRITE (IPRT,1040)
            WRITE (IPRT,1060) NETTST(I), NTATST(J), SCALE(1), NROW, NPRT
            WRITE (IPRT,1000)
            IERR = -1
            CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSTAK,
     +         NETTST(I), NTATST(J), SCALE, NROW, NPRT)
            WRITE (IPRT,1050) IERR
            WRITE (IPRT,1140) NETTST(I), NTATST(J), SCALE(1), NROW, NPRT
C
   20    CONTINUE
C
   30 CONTINUE
C
C     SUPPRESS OUTPUT
C
      NPRT = 0
C
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1100)
      WRITE (IPRT,1040)
      WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROW, NPRT
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSTAK, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROW, NPRT
C
C     LARGE CALCULATION ERROR PROBLEM
C
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
      PAR(3) = 10.0D0**NTATST(5)
      SCALE(1) = 0.0D0
      NROW = 51
C
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1100)
      WRITE (IPRT,1070)
      WRITE (IPRT,1080)
      WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROW, NPRT
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSTAK, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROW, NPRT
C
C     NEARLY ZERO DERIVATIVE
C
      NROW = 50
C
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1100)
      WRITE (IPRT,1070)
      WRITE (IPRT,1090)
      WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROW, NPRT
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSTAK, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROW, NPRT
C
C     INCORRECTLY CODED DERIVATIVE
C
C     SIMPLE EXAMPLE
C
C     SET PARAMETER VALUES
C
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1110)
      WRITE (IPRT,1040)
      WRITE (IPRT,1000)
      IERR = -1
      CALL DCKLS(XM, N, M, IXM, MDL4, DRV4B, PAR, NPAR, LDSTAK)
      WRITE (IPRT,1050) IERR
C
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1110)
      WRITE (IPRT,1040)
      WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROW, NPRT
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4B, PAR, NPAR, LDSTAK, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROW, NPRT
C
C     SUPPRESS OUTPUT
C
      NPRT = 0
C
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1110)
      WRITE (IPRT,1040)
      WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROW, NPRT
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4B, PAR, NPAR, LDSTAK, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROW, NPRT
C
C     LARGE CALCULATION ERROR PROBLEM
C
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
C
      PAR(3) = 10.0D0**NTATST(5)
      NROW = 26
C
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1110)
      WRITE (IPRT,1070)
      WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROW, NPRT
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4B, PAR, NPAR, LDSTAK, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROW, NPRT
C
      PAR(4) = 0.75D0
      NROW = 1
C
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1110)
      WRITE (IPRT,1070)
      WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROW, NPRT
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4B, PAR, NPAR, LDSTAK, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROW, NPRT
C
C     CHECK VARIOUS VALUES OF NROW
C
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
C
      CALL SETRV(XM(1,1), N, 0.0D0)
      NROTST(1) = -1
      NROTST(2) = 0
      NROTST(3) = 1
      NROTST(4) = N
      NROTST(5) = N + 1
C
      DO 40 I=1,5
C
         NTEST = NTEST + 1
         WRITE (IPRT,1130) NTEST
         WRITE (IPRT,1110)
         WRITE (IPRT,1120)
         WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROTST(I), NPRT
         WRITE (IPRT,1010)
         IERR = -1
         CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4B, PAR, NPAR, LDSTAK,
     +      NETA, NTAU, SCALE, NROTST(I), NPRT)
         WRITE (IPRT,1050) IERR
         WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROTST(I), NPRT
C
   40 CONTINUE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (15H TEST OF DCKLS )
 1010 FORMAT (15H TEST OF DCKLSC)
 1020 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1040 FORMAT (15H SIMPLE EXAMPLE)
 1050 FORMAT (29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1060 FORMAT (19H INPUT   -  NETA = , I5, 9H, NTAU = , I5,
     +   13H, SCALE(1) = , G15.8, 9H, NROW = , I5, 9H, NPRT = , I5)
 1070 FORMAT (32H LARGE CALCULATION ERROR PROBLEM)
 1080 FORMAT (16H ZERO DERIVATIVE)
 1090 FORMAT (23H NEARLY ZERO DERIVATIVE)
 1100 FORMAT (27H CORRECTLY CODED DERIVATIVE)
 1110 FORMAT (' INCORRECTLY CODED DERIVATIVE FOR PARAMETERS 1, 2 AND 4')
 1120 FORMAT (' ALL INDEPENDENT VARIABLES EQUAL TO ZERO')
 1130 FORMAT (43H1DERIVATIVE CHECKING SUBROUTINE TEST NUMBER, I5)
 1140 FORMAT (19H OUTPUT  -  NETA = , I5, 9H, NTAU = , I5,
     +   13H, SCALE(1) = , G15.8, 9H, NROW = , I5, 9H, NPRT = , I5//)
      END
*XDEMOD
      SUBROUTINE XDEMOD(LDS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST THE TIME SERIES
C     COMPLEX DEMODULATION ROUTINES.
C
C     SERIES Y IS THE WOLF SUNSPOT DATA FROM 1700 TO 1960 AS
C     TABULATED BY WALDMEIER
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DEVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDS
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FC,FD
      INTEGER
     +   I,IPRT,ITEST,K,LDSTAK,N,NDEM,NPRT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AMPL(300),PHAS(300),Y(300)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DEMOD,DEMODS,IPRINT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AMPL(300)
C        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FC
C        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
C     DOUBLE PRECISION FD
C        THE DEMODULATION FREQUENCY.
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     INTEGER ITEST
C        THE NUMBER OF THE TEST BEING RUN
C     INTEGER K
C        THE NUMBER OF TERMS IN THE SYMETRIC LINEAR FILTER.
C     INTEGER LDS, LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE INPUT SERIES.
C     INTEGER NDEM
C        THE NUMBER OF VALUES IN THE DEMODULATED SERIES, I. E., IT
C        IS THE NUMBER OF VALUES IN THE AMPLITUDE AND PHASE ARRAYS.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT .EQ. 0 THE PLOT IS SUPPRESSED
C        NPRT .NE. 1 THE PLOT IS PROVIDED
C     DOUBLE PRECISION PHAS(300)
C        THE ARRAY IN WHICH THE PRIMARY PHASE ESTIMATES ARE RETURNED.
C     DOUBLE PRECISION Y(300)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C
      DATA   Y(  1),  Y(  2),  Y(  3),  Y(  4),  Y(  5),  Y(  6)
     +    /     5.0D0, 11.0D0, 16.0D0, 23.0D0, 36.0D0, 58.0D0/
      DATA   Y(  7),  Y(  8),  Y(  9),  Y( 10),  Y( 11),  Y( 12)
     +    /    29.0D0, 20.0D0, 10.0D0,  8.0D0,  3.0D0,  0.0D0/
      DATA   Y( 13),  Y( 14),  Y( 15),  Y( 16),  Y( 17),  Y( 18)
     +    /     0.0D0, 2.0D0, 11.0D0, 27.0D0, 47.0D0, 63.0D0/
      DATA   Y( 19),  Y( 20),  Y( 21),  Y( 22),  Y( 23),  Y( 24)
     +    /    60.0D0, 39.0D0, 28.0D0, 26.0D0, 22.0D0, 11.0D0/
      DATA   Y( 25),  Y( 26),  Y( 27),  Y( 28),  Y( 29),  Y( 30)
     +    /    21.0D0, 40.0D0, 78.0D0,122.0D0,103.0D0, 73.0D0/
      DATA   Y( 31),  Y( 32),  Y( 33),  Y( 34),  Y( 35),  Y( 36)
     +    /    47.0D0, 35.0D0, 11.0D0,  5.0D0, 16.0D0, 34.0D0/
      DATA   Y( 37),  Y( 38),  Y( 39),  Y( 40),  Y( 41),  Y( 42)
     +    /    70.0D0, 81.0D0,111.0D0,101.0D0, 73.0D0, 40.0D0/
      DATA   Y( 43),  Y( 44),  Y( 45),  Y( 46),  Y( 47),  Y( 48)
     +    /    20.0D0, 16.0D0,  5.0D0, 11.0D0, 22.0D0, 40.0D0/
      DATA   Y( 49),  Y( 50),  Y( 51),  Y( 52),  Y( 53),  Y( 54)
     +    /    60.0D0, 80.9D0, 83.4D0, 47.7D0, 47.8D0, 30.7D0/
      DATA   Y( 55),  Y( 56),  Y( 57),  Y( 58),  Y( 59),  Y( 60)
     +    /    12.2D0,  9.6D0, 10.2D0, 32.4D0, 47.6D0, 54.0D0/
      DATA   Y( 61),  Y( 62),  Y( 63),  Y( 64),  Y( 65),  Y( 66)
     +    /    62.9D0, 85.9D0, 61.2D0, 45.1D0, 36.4D0, 20.9D0/
      DATA   Y( 67),  Y( 68),  Y( 69),  Y( 70),  Y( 71),  Y( 72)
     +    /    11.4D0, 37.8D0, 69.8D0,106.1D0,100.8D0, 81.6D0/
      DATA   Y( 73),  Y( 74),  Y( 75),  Y( 76),  Y( 77),  Y( 78)
     +    /    66.5D0, 34.8D0, 30.6D0,  7.0D0, 19.8D0, 92.5D0/
      DATA   Y( 79),  Y( 80),  Y( 81),  Y( 82),  Y( 83),  Y( 84)
     +    /   154.4D0,125.9D0, 84.8D0, 68.1D0, 38.5D0, 22.8D0/
      DATA   Y( 85),  Y( 86),  Y( 87),  Y( 88),  Y( 89),  Y( 90)
     +    /    10.2D0, 24.1D0, 82.9D0,132.0D0,130.9D0,118.1D0/
      DATA   Y( 91),  Y( 92),  Y( 93),  Y( 94),  Y( 95),  Y( 96)
     +    /    89.9D0, 66.6D0, 60.0D0, 46.9D0, 41.0D0, 21.3D0/
      DATA   Y( 97),  Y( 98),  Y( 99),  Y(100),  Y(101),  Y(102)
     +    /    16.0D0,  6.4D0,  4.1D0,  6.8D0, 14.5D0, 34.0D0/
      DATA   Y(103),  Y(104),  Y(105),  Y(106),  Y(107),  Y(108)
     +    /    45.0D0, 43.1D0, 47.5D0, 42.2D0, 28.1D0, 10.1D0/
      DATA   Y(109),  Y(110),  Y(111),  Y(112),  Y(113),  Y(114)
     +    /     8.1D0,  2.5D0,  0.0D0,  1.4D0,  5.0D0, 12.2D0/
      DATA   Y(115),  Y(116),  Y(117),  Y(118),  Y(119),  Y(120)
     +    /    13.9D0, 35.4D0, 45.8D0, 41.1D0, 30.1D0, 23.9D0/
      DATA   Y(121),  Y(122),  Y(123),  Y(124),  Y(125),  Y(126)
     +    /    15.6D0,  6.6D0,  4.0D0,  1.8D0,  8.5D0, 16.6D0/
      DATA   Y(127),  Y(128),  Y(129),  Y(130),  Y(131),  Y(132)
     +    /    36.3D0, 49.6D0, 64.2D0, 67.0D0, 70.9D0, 47.8D0/
      DATA   Y(133),  Y(134),  Y(135),  Y(136),  Y(137),  Y(138)
     +    /    27.5D0,  8.5D0, 13.2D0, 56.9D0,121.5D0,138.3D0/
      DATA   Y(139),  Y(140),  Y(141),  Y(142),  Y(143),  Y(144)
     +    /   103.2D0, 85.7D0, 64.6D0, 36.7D0, 24.2D0, 10.7D0/
      DATA   Y(145),  Y(146),  Y(147),  Y(148),  Y(149),  Y(150)
     +    /    15.0D0, 40.1D0, 61.5D0, 98.5D0,124.7D0, 96.3D0/
      DATA   Y(151),  Y(152),  Y(153),  Y(154),  Y(155),  Y(156)
     +    /    66.6D0, 64.5D0, 54.1D0, 39.0D0, 20.6D0,  6.7D0/
      DATA   Y(157),  Y(158),  Y(159),  Y(160),  Y(161),  Y(162)
     +    /     4.3D0, 22.7D0, 54.8D0, 93.8D0, 95.8D0, 77.2D0/
      DATA   Y(163),  Y(164),  Y(165),  Y(166),  Y(167),  Y(168)
     +    /    59.1D0, 44.0D0, 47.0D0, 30.5D0, 16.3D0,  7.3D0/
      DATA   Y(169),  Y(170),  Y(171),  Y(172),  Y(173),  Y(174)
     +    /    37.6D0, 74.0D0,139.0D0,111.2D0,101.6D0, 66.2D0/
      DATA   Y(175),  Y(176),  Y(177),  Y(178),  Y(179),  Y(180)
     +    /    44.7D0, 17.0D0, 11.3D0, 12.4D0,  3.4D0,  6.0D0/
      DATA   Y(181),  Y(182),  Y(183),  Y(184),  Y(185),  Y(186)
     +    /    32.3D0, 54.3D0, 59.7D0, 63.7D0, 63.5D0, 52.2D0/
      DATA   Y(187),  Y(188),  Y(189),  Y(190),  Y(191),  Y(192)
     +    /    25.4D0, 13.1D0,  6.8D0,  6.3D0,  7.1D0, 35.6D0/
      DATA   Y(193),  Y(194),  Y(195),  Y(196),  Y(197),  Y(198)
     +    /    73.0D0, 85.1D0, 78.0D0, 64.0D0, 41.8D0, 26.2D0/
      DATA   Y(199),  Y(200),  Y(201),  Y(202),  Y(203),  Y(204)
     +    /    26.7D0, 12.1D0,  9.5D0,  2.7D0,  5.0D0, 24.4D0/
      DATA   Y(205),  Y(206),  Y(207),  Y(208),  Y(209),  Y(210)
     +    /    42.0D0, 63.5D0, 53.8D0, 62.0D0, 48.5D0, 43.9D0/
      DATA   Y(211),  Y(212),  Y(213),  Y(214),  Y(215),  Y(216)
     +    /    18.6D0,  5.7D0,  3.6D0,  1.4D0,  9.6D0, 47.4D0/
      DATA   Y(217),  Y(218),  Y(219),  Y(220),  Y(221),  Y(222)
     +    /    57.1D0,103.9D0, 80.6D0, 63.6D0, 37.6D0, 26.1D0/
      DATA   Y(223),  Y(224),  Y(225),  Y(226),  Y(227),  Y(228)
     +    /    14.2D0,  5.8D0, 16.7D0, 44.3D0, 63.9D0, 69.0D0/
      DATA   Y(229),  Y(230),  Y(231),  Y(232),  Y(233),  Y(234)
     +    /    77.8D0, 64.9D0, 35.7D0, 21.2D0, 11.1D0,  5.7D0/
      DATA   Y(235),  Y(236),  Y(237),  Y(238),  Y(239),  Y(240)
     +    /     8.7D0, 36.1D0, 79.7D0,114.4D0,109.6D0, 88.8D0/
      DATA   Y(241),  Y(242),  Y(243),  Y(244),  Y(245),  Y(246)
     +    /    67.8D0, 47.5D0, 30.6D0, 16.3D0,  9.6D0, 33.2D0/
      DATA   Y(247),  Y(248),  Y(249),  Y(250),  Y(251),  Y(252)
     +    /    92.6D0,151.6D0,136.3D0,134.7D0, 83.9D0, 69.4D0/
      DATA   Y(253),  Y(254),  Y(255),  Y(256),  Y(257),  Y(258)
     +    /    31.5D0, 13.9D0,  4.4D0, 38.0D0,141.7D0,190.2D0/
      DATA   Y(259),  Y(260),  Y(261)
     +    /   184.8D0,159.0D0,112.3D0/
C
      CALL IPRINT(IPRT)
      ITEST = 1
      LDSTAK = LDS
C
      N = 261
      NPRT = 1
      FD = 1.0D0/11.0D0
      FC = 1.0D0/22.0D0
      K = 41
C
C     TEST OF DEMOD
C
    5 WRITE (IPRT, 1016)
      CALL DEMOD (Y, N, FD, FC, K, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF DEMODS
C
      WRITE (IPRT, 1017)
      CALL DEMODS (Y, N, FD, FC, K, AMPL, PHAS, NDEM, NPRT, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM DEMODS
C
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (AMPL(I), I = 1, NDEM)
        WRITE (IPRT, 1004) (PHAS(I), I = 1, NDEM)
      END IF
C
      GO TO (100, 200, 300), ITEST
C
C     TEST MINIMUM PROBLEM SPECIFICATIONS
C
  100 ITEST = ITEST + 1
      N = 17
      K = 15
      NPRT = -1
      GO TO 5
C
C     TEST ERROR CONDITIONS
C
  200 ITEST = ITEST + 1
      N = 0
      FD = 0.5D0
      FC = 0.3D0
      K = 1
      GO TO 5
C
  300 RETURN
C
C     FORMAT STATEMENTS
C
 1002 FORMAT (8H IERR IS, I5)
 1004 FORMAT (10F10.5)
 1016 FORMAT ('1', 13HTEST OF DEMOD)
 1017 FORMAT ('1', 14HTEST OF DEMODS)
C
      END
*XDFLT
      SUBROUTINE XDFLT(LDS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST THE TIME SERIES DIGITAL FILTERING AND
C     COMPLEX DEMODULATION ROUTINES.
C
C     SERIES Y IS THE WOLF SUNSPOT DATA FROM 1700 TO 1960 AS
C     TABULATED BY WALDMEIER
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DEVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 26, 1980
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDS
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FC,FMAX,FMIN,YFMISS,YMISS
      INTEGER
     +   I,IAR,IPRT,ITEST,K,LDSTAK,LPHI,N,NF,NFAC,NPRT,NYF,NYS
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FREQ(101),GAIN(101),HHP(50),HLP(50),PHAS(300),PHI(50),Y(300),
     +   YF(300),YS(300)
      INTEGER
     +   IOD(10),ND(10)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ARFLT,DIF,DIFC,DIFM,DIFMC,GFARF,GFARFS,GFSLF,GFSLFS,
     +   HIPASS,HPCOEF,IPRINT,LOPASS,LPCOEF,MAFLT,SAMPLE,SLFLT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FC
C        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MINIMUM AND MAXIMUM FREQUENCY FOR WHICH THE GAIN
C        FUNCTION IS TO BE ESTIMATED.
C     DOUBLE PRECISION FREQ(101)
C        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION
C        HAS BEEN ESTIMATED.
C     DOUBLE PRECISION GAIN(101)
C        THE VECTOR IN WHICH THE GAIN FUNCTION ESTIMATES ARE
C        STORED.
C     DOUBLE PRECISION HHP(50)
C        THE ARRAY IN WHICH THE -IDEAL- HIGH PASS FILTER COEFFICIENTS
C        WILL BE RETURNED.
C     DOUBLE PRECISION HLP(50)
C        THE ARRAY IN WHICH THE INPUT LOW PASS FILTER COEFFICIENTS
C        ARE STORED.
C     INTEGER I
C        AN INDEXING VARIABLE.
C     INTEGER IAR
C        THE NUMBER OF FILTER COEFFICIENTS.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
C     INTEGER IOD(10)
C        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
C     INTEGER IPRT
C        THE UNIT NUMBER USED FOR OUTPUT.
C     INTEGER ITEST
C        THE NUMBER OF THE TEST BEING PERFORMED
C     INTEGER K
C        THE NUMBER OF TERMS IN THE SYMETRIC LINEAR FILTER.
C     INTEGER LDS, LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER LPHI
C        THE LENGTH OF THE VECTOR PHI.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN THE INPUT SERIES.
C     INTEGER ND(10)
C        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE
C        FACTORS ARE TO BE APPLIED.
C     INTEGER NFAC
C        THE NUMBER OF DIFFERENCE FACTORS.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE GAIN FUNCTION
C        IS TO BE ESTIMATED.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT = 1 THE PLOT IS DECIBELS/LINEAR
C        NPRT = 2 THE PLOT IS LOG/LINEAR
C     INTEGER NYF
C        THE NUMBER OF VALUES IN THE FILTERED SERIES.
C     INTEGER NYS
C        THE NUMBER OF VALUES IN THE SAMPLED SERIES.
C     DOUBLE PRECISION PHAS(300)
C        THE ARRAY IN WHICH THE PRIMARY PHASE ESTIMATES ARE RETURNED.
C     DOUBLE PRECISION PHI(50)
C        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
C     DOUBLE PRECISION Y(300)
C        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
C     DOUBLE PRECISION YF(300)
C        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
C     DOUBLE PRECISION YFMISS
C        THE MISSING VALUE CODE USED IN THE FILTERED SERIES.
C     DOUBLE PRECISION YMISS
C        THE MISSING VALUE CODE USED IN THE INPUT TIME SERIES.
C     DOUBLE PRECISION YS(300)
C        THE ARRAY CONTAINING THE SAMPLED SERIES.
C
      DATA   Y(  1),  Y(  2),  Y(  3),  Y(  4),  Y(  5),  Y(  6)
     +    /     5.0D0, 11.0D0, 16.0D0, 23.0D0, 36.0D0, 58.0D0/
      DATA   Y(  7),  Y(  8),  Y(  9),  Y( 10),  Y( 11),  Y( 12)
     +    /    29.0D0, 20.0D0, 10.0D0,  8.0D0,  3.0D0,  0.0D0/
      DATA   Y( 13),  Y( 14),  Y( 15),  Y( 16),  Y( 17),  Y( 18)
     +    /     0.0D0, 2.0D0, 11.0D0, 27.0D0, 47.0D0, 63.0D0/
      DATA   Y( 19),  Y( 20),  Y( 21),  Y( 22),  Y( 23),  Y( 24)
     +    /    60.0D0, 39.0D0, 28.0D0, 26.0D0, 22.0D0, 11.0D0/
      DATA   Y( 25),  Y( 26),  Y( 27),  Y( 28),  Y( 29),  Y( 30)
     +    /    21.0D0, 40.0D0, 78.0D0,122.0D0,103.0D0, 73.0D0/
      DATA   Y( 31),  Y( 32),  Y( 33),  Y( 34),  Y( 35),  Y( 36)
     +    /    47.0D0, 35.0D0, 11.0D0,  5.0D0, 16.0D0, 34.0D0/
      DATA   Y( 37),  Y( 38),  Y( 39),  Y( 40),  Y( 41),  Y( 42)
     +    /    70.0D0, 81.0D0,111.0D0,101.0D0, 73.0D0, 40.0D0/
      DATA   Y( 43),  Y( 44),  Y( 45),  Y( 46),  Y( 47),  Y( 48)
     +    /    20.0D0, 16.0D0,  5.0D0, 11.0D0, 22.0D0, 40.0D0/
      DATA   Y( 49),  Y( 50),  Y( 51),  Y( 52),  Y( 53),  Y( 54)
     +    /    60.0D0, 80.9D0, 83.4D0, 47.7D0, 47.8D0, 30.7D0/
      DATA   Y( 55),  Y( 56),  Y( 57),  Y( 58),  Y( 59),  Y( 60)
     +    /    12.2D0,  9.6D0, 10.2D0, 32.4D0, 47.6D0, 54.0D0/
      DATA   Y( 61),  Y( 62),  Y( 63),  Y( 64),  Y( 65),  Y( 66)
     +    /    62.9D0, 85.9D0, 61.2D0, 45.1D0, 36.4D0, 20.9D0/
      DATA   Y( 67),  Y( 68),  Y( 69),  Y( 70),  Y( 71),  Y( 72)
     +    /    11.4D0, 37.8D0, 69.8D0,106.1D0,100.8D0, 81.6D0/
      DATA   Y( 73),  Y( 74),  Y( 75),  Y( 76),  Y( 77),  Y( 78)
     +    /    66.5D0, 34.8D0, 30.6D0,  7.0D0, 19.8D0, 92.5D0/
      DATA   Y( 79),  Y( 80),  Y( 81),  Y( 82),  Y( 83),  Y( 84)
     +    /   154.4D0,125.9D0, 84.8D0, 68.1D0, 38.5D0, 22.8D0/
      DATA   Y( 85),  Y( 86),  Y( 87),  Y( 88),  Y( 89),  Y( 90)
     +    /    10.2D0, 24.1D0, 82.9D0,132.0D0,130.9D0,118.1D0/
      DATA   Y( 91),  Y( 92),  Y( 93),  Y( 94),  Y( 95),  Y( 96)
     +    /    89.9D0, 66.6D0, 60.0D0, 46.9D0, 41.0D0, 21.3D0/
      DATA   Y( 97),  Y( 98),  Y( 99),  Y(100),  Y(101),  Y(102)
     +    /    16.0D0,  6.4D0,  4.1D0,  6.8D0, 14.5D0, 34.0D0/
      DATA   Y(103),  Y(104),  Y(105),  Y(106),  Y(107),  Y(108)
     +    /    45.0D0, 43.1D0, 47.5D0, 42.2D0, 28.1D0, 10.1D0/
      DATA   Y(109),  Y(110),  Y(111),  Y(112),  Y(113),  Y(114)
     +    /     8.1D0,  2.5D0,  0.0D0,  1.4D0,  5.0D0, 12.2D0/
      DATA   Y(115),  Y(116),  Y(117),  Y(118),  Y(119),  Y(120)
     +    /    13.9D0, 35.4D0, 45.8D0, 41.1D0, 30.1D0, 23.9D0/
      DATA   Y(121),  Y(122),  Y(123),  Y(124),  Y(125),  Y(126)
     +    /    15.6D0,  6.6D0,  4.0D0,  1.8D0,  8.5D0, 16.6D0/
      DATA   Y(127),  Y(128),  Y(129),  Y(130),  Y(131),  Y(132)
     +    /    36.3D0, 49.6D0, 64.2D0, 67.0D0, 70.9D0, 47.8D0/
      DATA   Y(133),  Y(134),  Y(135),  Y(136),  Y(137),  Y(138)
     +    /    27.5D0,  8.5D0, 13.2D0, 56.9D0,121.5D0,138.3D0/
      DATA   Y(139),  Y(140),  Y(141),  Y(142),  Y(143),  Y(144)
     +    /   103.2D0, 85.7D0, 64.6D0, 36.7D0, 24.2D0, 10.7D0/
      DATA   Y(145),  Y(146),  Y(147),  Y(148),  Y(149),  Y(150)
     +    /    15.0D0, 40.1D0, 61.5D0, 98.5D0,124.7D0, 96.3D0/
      DATA   Y(151),  Y(152),  Y(153),  Y(154),  Y(155),  Y(156)
     +    /    66.6D0, 64.5D0, 54.1D0, 39.0D0, 20.6D0,  6.7D0/
      DATA   Y(157),  Y(158),  Y(159),  Y(160),  Y(161),  Y(162)
     +    /     4.3D0, 22.7D0, 54.8D0, 93.8D0, 95.8D0, 77.2D0/
      DATA   Y(163),  Y(164),  Y(165),  Y(166),  Y(167),  Y(168)
     +    /    59.1D0, 44.0D0, 47.0D0, 30.5D0, 16.3D0,  7.3D0/
      DATA   Y(169),  Y(170),  Y(171),  Y(172),  Y(173),  Y(174)
     +    /    37.6D0, 74.0D0,139.0D0,111.2D0,101.6D0, 66.2D0/
      DATA   Y(175),  Y(176),  Y(177),  Y(178),  Y(179),  Y(180)
     +    /    44.7D0, 17.0D0, 11.3D0, 12.4D0,  3.4D0,  6.0D0/
      DATA   Y(181),  Y(182),  Y(183),  Y(184),  Y(185),  Y(186)
     +    /    32.3D0, 54.3D0, 59.7D0, 63.7D0, 63.5D0, 52.2D0/
      DATA   Y(187),  Y(188),  Y(189),  Y(190),  Y(191),  Y(192)
     +    /    25.4D0, 13.1D0,  6.8D0,  6.3D0,  7.1D0, 35.6D0/
      DATA   Y(193),  Y(194),  Y(195),  Y(196),  Y(197),  Y(198)
     +    /    73.0D0, 85.1D0, 78.0D0, 64.0D0, 41.8D0, 26.2D0/
      DATA   Y(199),  Y(200),  Y(201),  Y(202),  Y(203),  Y(204)
     +    /    26.7D0, 12.1D0,  9.5D0,  2.7D0,  5.0D0, 24.4D0/
      DATA   Y(205),  Y(206),  Y(207),  Y(208),  Y(209),  Y(210)
     +    /    42.0D0, 63.5D0, 53.8D0, 62.0D0, 48.5D0, 43.9D0/
      DATA   Y(211),  Y(212),  Y(213),  Y(214),  Y(215),  Y(216)
     +    /    18.6D0,  5.7D0,  3.6D0,  1.4D0,  9.6D0, 47.4D0/
      DATA   Y(217),  Y(218),  Y(219),  Y(220),  Y(221),  Y(222)
     +    /    57.1D0,103.9D0, 80.6D0, 63.6D0, 37.6D0, 26.1D0/
      DATA   Y(223),  Y(224),  Y(225),  Y(226),  Y(227),  Y(228)
     +    /    14.2D0,  5.8D0, 16.7D0, 44.3D0, 63.9D0, 69.0D0/
      DATA   Y(229),  Y(230),  Y(231),  Y(232),  Y(233),  Y(234)
     +    /    77.8D0, 64.9D0, 35.7D0, 21.2D0, 11.1D0,  5.7D0/
      DATA   Y(235),  Y(236),  Y(237),  Y(238),  Y(239),  Y(240)
     +    /     8.7D0, 36.1D0, 79.7D0,114.4D0,109.6D0, 88.8D0/
      DATA   Y(241),  Y(242),  Y(243),  Y(244),  Y(245),  Y(246)
     +    /    67.8D0, 47.5D0, 30.6D0, 16.3D0,  9.6D0, 33.2D0/
      DATA   Y(247),  Y(248),  Y(249),  Y(250),  Y(251),  Y(252)
     +    /    92.6D0,151.6D0,136.3D0,134.7D0, 83.9D0, 69.4D0/
      DATA   Y(253),  Y(254),  Y(255),  Y(256),  Y(257),  Y(258)
     +    /    31.5D0, 13.9D0,  4.4D0, 38.0D0,141.7D0,190.2D0/
      DATA   Y(259),  Y(260),  Y(261)
     +    /   184.8D0,159.0D0,112.3D0/
C
      CALL IPRINT(IPRT)
      ITEST = 1
      LDSTAK = LDS
C
      N = 261
      NPRT = 2
      FC = 1.0D0/22.0D0
      NF = 101
      FMIN = 0.0D0
      FMAX = 0.2D0
      LPHI = 50
      NFAC = 1
      ND(1) = 1
      IOD(1) = 1
      IAR = 1
      PHI(1) = 0.6D0
      K = 41
      YMISS = 11.0D0
C
C     TEST OF LPCOEF
C
   10 WRITE (IPRT, 1001)
      CALL LPCOEF (FC, K, HLP)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM LPCOEF
C
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (HLP(I), I = 1, K)
C
C     TEST OF LOPASS
C
      WRITE (IPRT, 1007)
      CALL LOPASS (Y, N, FC, K, HLP, YF, NYF)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM LOPASS
C
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (HLP(I), I = 1, K)
        WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
      END IF
C
C     TEST OF HIPASS
C
      WRITE (IPRT, 1008)
      CALL HIPASS (Y, N, FC, K, HHP, YF, NYF)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM HIPASS
C
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (HHP(I), I = 1, K)
        WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
      END IF
C
C     TEST OF HPCOEF
C
   20 WRITE (IPRT, 1003)
      CALL HPCOEF (HLP, K, HHP)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM HPCOEF
C
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (HHP(I), I = 1, K)
C
C     TEST OF MAFLT
C
      WRITE (IPRT, 1020)
      CALL MAFLT (Y, N, K, YF, NYF)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM MAFLT
C
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
C
C     TEST OF SLFLT
C
      WRITE (IPRT, 1005)
      CALL SLFLT (Y, N, K, HLP, YF, NYF)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM SLFLT
C
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
C
C     TEST OF SAMPLE
C
      WRITE (IPRT, 1006)
      CALL SAMPLE (YF, N, K, YS, NYS)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM SAMPLE
C
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (YF(I), I = 1, NYS)
C
C     TEST OF ARFLT
C
      WRITE (IPRT, 1009)
      CALL ARFLT (Y, N,  IAR, PHI, YF, NYF)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM ARFLT
C
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
C
C     TEST OF DIF
C
      WRITE (IPRT, 1015)
      CALL DIF (Y, N, YF, NYF)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM DIF
C
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
C
C     TEST OF DIFM
C
      WRITE (IPRT, 1018)
      CALL DIFM (Y, YMISS, N, YF, YFMISS, NYF)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM DIFM
C
      IF (IERR.EQ.0) THEN
         WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
         WRITE (IPRT, 1004) YFMISS
      END IF
C
C     TEST OF GFSLF
C
      WRITE (IPRT, 1011)
      CALL GFSLF (HLP, K)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF GFARF
C
      WRITE (IPRT, 1013)
      CALL GFARF (PHI, IAR)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF DIFC
C
   30 WRITE (IPRT, 1010)
      CALL DIFC (Y, N, NFAC, ND, IOD, IAR, PHI, LPHI, YF, NYF, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM DIFC
C
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (PHI(I), I = 1, K)
        WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
      END IF
C
C     TEST OF DIFMC
C
      WRITE (IPRT, 1019)
      CALL DIFMC (Y, YMISS, N, NFAC, ND, IOD, IAR, PHI, LPHI, YF,
     +   YFMISS, NYF, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM DIFMC
C
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (PHI(I), I = 1, K)
        WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
        WRITE (IPRT, 1004) YFMISS
      END IF
C
C     TEST OF GFSLFS
C
      WRITE (IPRT, 1012)
      CALL GFSLFS (HLP, K, NF, FMIN, FMAX, GAIN, FREQ, NPRT, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM GFSLFS
C
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (GAIN(I), I = 1, NF)
        WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
      END IF
C
C     TEST OF GFARFS
C
      WRITE (IPRT, 1014)
      CALL GFARFS (PHI, IAR, NF, FMIN, FMAX, GAIN, PHAS, FREQ, NPRT,
     +   LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM GFARFS
C
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (GAIN(I), I = 1, NF)
        WRITE (IPRT, 1004) (PHAS(I), I = 1, NF)
        WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
      END IF
C
      GO TO (100, 200, 300, 400), ITEST
C
C     TEST SPECIAL CASES
C
  100 ITEST = ITEST + 1
C
C     TEST OF GFSLFS
C
      FMIN = 0.4D0
      FMAX = 0.1D0
      NPRT = 1
      WRITE (IPRT, 1012)
      CALL GFSLFS (HLP, K, NF, FMIN, FMAX, GAIN, FREQ, NPRT, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM GFSLFS
C
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (GAIN(I), I = 1, NF)
        WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
      END IF
C
C     TEST OF GFARFS
C
      NPRT = -1
      WRITE (IPRT, 1014)
      CALL GFARFS (PHI, IAR, NF, FMIN, FMAX, GAIN, PHAS, FREQ, NPRT,
     +   LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     PRINT STORAGE FROM GFARFS
C
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (GAIN(I), I = 1, NF)
        WRITE (IPRT, 1004) (PHAS(I), I = 1, NF)
        WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
      END IF
C
C     TEST MINIMUM PROBLEM SIZE
C
      N = 3
      K = 1
      NPRT = -1
      IAR = 1
      NF = 1
      GO TO 20
C
C     TEST ERROR CONDITIONS
C
  200 ITEST = ITEST + 1
      N = -5
      FC = 1.0D0
      NF = 0
      LPHI = 0
      NFAC = 1
      ND(1) = -1
      IOD(1) = -1
      IAR = 0
      K = -1
      GO TO 10
C
C     TEST LDSTAK
C
  300 ITEST = ITEST + 1
      N = 261
      NPRT = 2
      FC = 1.0D0/22.0D0
      NF = 101
      FMIN = 0.0D0
      FMAX = 0.2D0
      LPHI = 50
      NFAC = 1
      ND(1) = 1
      IOD(1) = 1
      IAR = 1
      PHI(1) = 0.6D0
      K = 41
      YMISS = 11.0D0
      LDSTAK = 0
      GO TO 30
C
  400 RETURN
C
C     FORMAT STATEMENTS
C
 1001 FORMAT ('1', 14HTEST OF LPCOEF)
 1002 FORMAT (/' IERR IS ', I5)
 1003 FORMAT ('1', 14HTEST OF HPCOEF)
 1004 FORMAT (10E10.3)
 1005 FORMAT ('1', 13HTEST OF SLFLT)
 1006 FORMAT ('1', 14HTEST OF SAMPLE)
 1007 FORMAT ('1', 14HTEST OF LOPASS)
 1008 FORMAT ('1', 14HTEST OF HIPASS)
 1009 FORMAT ('1', 13HTEST OF ARFLT)
 1010 FORMAT ('1', 12HTEST OF DIFC)
 1011 FORMAT ('1', 13HTEST OF GFSLF)
 1012 FORMAT ('1', 14HTEST OF GFSLFS)
 1013 FORMAT ('1', 13HTEST OF GFARF)
 1014 FORMAT ('1', 14HTEST OF GFARFS)
 1015 FORMAT ('1', 11HTEST OF DIF)
 1018 FORMAT ('1', 12HTEST OF DIFM)
 1019 FORMAT ('1', 13HTEST OF DIFMC)
 1020 FORMAT ('1', 13HTEST OF MAFLT)
C
      END
*XHIST
      SUBROUTINE XHIST(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS PROGRAM TESTS FEATURES OF THE HIST FAMILY TO ENSURE THAT
C     ALL ASPECTS OF THE HIST FAMILY ROUTINES WORK CORRECTLY.
C
C     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   YLB,YUB
      INTEGER
     +   I,IPRT,LDSMIN,N,NCELL,NCONST,NPRTOF,NPRTON
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   Y(84),YCONST(10),YLONG(200),YPATH(10)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL HIST,HISTC,IPRINT,LDSCMP,NRAND
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ANINT,LOG10,MIN,NINT,DBLE
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER I
C        A LOOP INDEX.
C     INTEGER IERR
C        FLAG TO INDICATE PRESENCE OF ERROR DETECTED BY PRECEDING
C        STARPAC CALL.  (0 IS OK, 1 IS ERROR)
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT.
C     INTEGER LDSMIN
C        THE MINIMUM AMOUNT OF WORK AREA NEEDED FOR A GIVEN PROBLEM.
C     INTEGER LDSTAK
C        AMOUNT OF WORK AREA.  SIZE OF DSTAK.
C     INTEGER N
C        THE LENGTH OF THE VECTOR Y.
C     INTEGER NCELL
C        THE USER SUPPLIED VALUE FOR THE NUMBER OF CELLS IN THE
C        HISTOGRAM.  IF NCELL IS LESS THAN OR EQUAL TO ZERO, THE
C        NUMBER OF CELLS TO BE USED (NCELLS) WILL BE CALCULATED FROM
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NCONST
C        LENGTH OF THE VECTOR YCONST.
C     INTEGER NPRTOF
C        FLAG FOR NO OUTPUT (EXCEPT ERROR MESSAGES).
C     INTEGER NPRTON
C        FLAG FOR FULL PRINTOUT.
C     DOUBLE PRECISION Y(84)
C        DATA VECTOR FOR TESTS.
C     DOUBLE PRECISION YCONST(10)
C        VECTOR OF CONSTANT DATA.
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
C     DOUBLE PRECISION YLONG(200)
C        LONG VECTOR OF DATA
C     DOUBLE PRECISION YPATH(10)
C        A VECTOR OF Y VALUES DESIGNED TO FORCE DIFFERENT PATHS
C        THROUGH THE SUMMATION ROUTINES.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
C
C     DATA INITIALIZATIONS.
C
      DATA N /84/
      DATA NCONST /10/
      DATA NPRTON /1/
      DATA NPRTOF /0/
      DATA NCELL/10/
      DATA YLB/0.60D0/, YUB/0.63D0/
C
C     DAVIS-HARRISON R.H. DATA, PIKES PEAK.
C
C     THIS IS AN ARBITRARILY CHOSEN DATA SET.
C
      DATA Y( 1), Y( 2), Y( 3), Y( 4)
     +    / 0.6067D0, 0.6087D0, 0.6086D0, 0.6134D0/
      DATA Y( 5), Y( 6), Y( 7)
     +    / 0.6108D0, 0.6138D0, 0.6125D0/
      DATA Y( 8), Y( 9), Y(10), Y(11)
     +    / 0.6122D0, 0.6110D0, 0.6104D0, 0.7213D0/
      DATA Y(12), Y(13), Y(14)
     +    / 0.7078D0, 0.7021D0, 0.7004D0/
      DATA Y(15), Y(16), Y(17), Y(18)
     +    / 0.6981D0, 0.7242D0, 0.7268D0, 0.7418D0/
      DATA Y(19), Y(20), Y(21)
     +    / 0.7407D0, 0.7199D0, 0.6225D0/
      DATA Y(22), Y(23), Y(24), Y(25)
     +    / 0.6254D0, 0.6252D0, 0.6267D0, 0.6218D0/
      DATA Y(26), Y(27), Y(28)
     +    / 0.6178D0, 0.6216D0, 0.6192D0/
      DATA Y(29), Y(30), Y(31), Y(32)
     +    / 0.6191D0, 0.6250D0, 0.6188D0, 0.6233D0/
      DATA Y(33), Y(34), Y(35)
     +    / 0.6225D0, 0.6204D0, 0.6207D0/
      DATA Y(36), Y(37), Y(38), Y(39)
     +    / 0.6168D0, 0.6141D0, 0.6291D0, 0.6231D0/
      DATA Y(40), Y(41), Y(42)
     +    / 0.6222D0, 0.6252D0, 0.6308D0/
      DATA Y(43), Y(44), Y(45), Y(46)
     +    / 0.6376D0, 0.6330D0, 0.6303D0, 0.6301D0/
      DATA Y(47), Y(48), Y(49)
     +    / 0.6390D0, 0.6423D0, 0.6300D0/
      DATA Y(50), Y(51), Y(52), Y(53)
     +    / 0.6260D0, 0.6292D0, 0.6298D0, 0.6290D0/
      DATA Y(54), Y(55), Y(56)
     +    / 0.6262D0, 0.5952D0, 0.5951D0/
      DATA Y(57), Y(58), Y(59), Y(60)
     +    / 0.6314D0, 0.6440D0, 0.6439D0, 0.6326D0/
      DATA Y(61), Y(62), Y(63)
     +    / 0.6392D0, 0.6417D0, 0.6412D0/
      DATA Y(64), Y(65), Y(66), Y(67)
     +    / 0.6530D0, 0.6411D0, 0.6355D0, 0.6344D0/
      DATA Y(68), Y(69), Y(70)
     +    / 0.6623D0, 0.6276D0, 0.6307D0/
      DATA Y(71), Y(72), Y(73), Y(74)
     +    / 0.6354D0, 0.6197D0, 0.6153D0, 0.6340D0/
      DATA Y(75), Y(76), Y(77)
     +    / 0.6338D0, 0.6284D0, 0.6162D0/
      DATA Y(78), Y(79), Y(80), Y(81)
     +    / 0.6252D0, 0.6349D0, 0.6344D0, 0.6361D0/
      DATA Y(82), Y(83), Y(84)
     +    / 0.6373D0, 0.6337D0, 0.6383D0/
C
C     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
C
      CALL IPRINT(IPRT)
C
C     CHECK FOR SUFFICIENT WORK AREA LENGTH.
C
      IF (LDSTAK.LT.300) THEN
        WRITE (IPRT, 1000)
         RETURN
      END IF
C
      DO 20 I=1,NCONST
         YCONST(I) = 1.0D0
   20 CONTINUE
C
C     HEADING.
C
      WRITE (IPRT,1150)
C
C     TEST 1.  CHECK ALL ERROR MESSAGES.
C
      WRITE (IPRT,1160)
C
C     ERROR 1, ZERO OR FEWER ELEMENTS.
C
      WRITE (IPRT,1180)
      CALL HIST(Y, 0, LDSTAK)
      WRITE (IPRT, 1350)
      WRITE (IPRT, 1360) (Y(I), I = 1, N)
      WRITE (IPRT,1170) IERR
      CALL HISTC(Y, 0, NCELL, YLB, YUB, LDSTAK)
      WRITE (IPRT, 1350)
      WRITE (IPRT, 1360) (Y(I), I = 1, N)
      WRITE (IPRT,1170) IERR
C
C     ERROR 2, NOT ENOUGH SPACE IN CSTAK.
C
      WRITE (IPRT,1190)
      CALL LDSCMP(2, 0, N, 0, 0, 0, 'D',
     +            MIN(NINT(5.5+1.5*ANINT(LOG10(DBLE(N)))),25),LDSMIN)
      CALL HIST(Y, N, LDSMIN-1)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1195)
      CALL HIST(Y, N, LDSMIN)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1190)
      CALL LDSCMP(2, 0, N, 0, 0, 0, 'D', NCELL, LDSMIN)
      CALL HISTC(Y, N, NCELL, YLB, YUB, LDSMIN-1)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1195)
      CALL HISTC(Y, N, NCELL, YLB, YUB, LDSMIN)
      WRITE (IPRT,1170) IERR
C
C     CONSTANT Y. (NOT AN ERROR)
C
      WRITE (IPRT,1200)
      CALL HIST(YCONST, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1200)
      CALL HISTC(YCONST, NCONST, NCELL, YLB, YUB, LDSTAK)
      WRITE (IPRT,1170) IERR
C
C     ERROR 4, NO DATA WITHIN USER SUPPLIED LIMITS
C
      WRITE (IPRT, 1110)
      CALL HISTC(Y, N, 0, 4.0D0, 10.0D0, LDSTAK)
      WRITE (IPRT, 1170) IERR
C
C     TEST 2.  MAKE A WORKING RUN OF EACH ROUTINE TO CHECK
C     THE OUTPUT.
C
      WRITE (IPRT,1300)
      WRITE (IPRT,1310)
      CALL HIST(Y, N, LDSTAK)
      WRITE (IPRT, 1350)
      WRITE (IPRT, 1360) (Y(I), I = 1, N)
      WRITE (IPRT,1170) IERR
C
      WRITE (IPRT,1340)
      CALL HISTC(Y, N, NCELL, YLB, YUB, LDSTAK)
      WRITE (IPRT, 1350)
      WRITE (IPRT, 1360) (Y(I), I = 1, N)
      WRITE (IPRT,1170) IERR
C
C     RUN DATA SET 6.7.
C
      DO 90 I=1,10
         YPATH(I) = 0.0D0
   90 CONTINUE
      YPATH(1) = -1.0D0
      YPATH(10) = 1.0D0
      WRITE (IPRT,1130)
      CALL HIST(YPATH, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT, 1130)
      CALL HISTC(YPATH, NCONST, 0, 0.0D0, 0.0D0, LDSTAK)
      WRITE (IPRT, 1130)
      CALL HISTC(YPATH, NCONST, 1, 0.0D0, 0.0D0, LDSTAK)
      WRITE (IPRT, 1130)
      CALL HISTC(YPATH, NCONST, 0, -0.5D0, 0.5D0, LDSTAK)
      WRITE (IPRT, 1130)
      CALL HISTC(YPATH, NCONST, 0, 1.0D0, 4.0D0, LDSTAK)
C
C     RUN DATA SET 6.8
C
      WRITE (IPRT, 1120)
      CALL NRAND (YLONG, 200, 3254767)
      CALL HIST (YLONG, 200, LDSTAK)
      RETURN
C
C     FORMATS
C
 1000 FORMAT ('1THE DIMENSION OF DSTAK AND THE VALUE OF LDSTAK NEEDED'/
     +  ' FOR HISTX MUST EQUAL OR EXCEED 300.  CHANGE DRIVER'/
     +  ' AND RECALL HISTX.')
 1110 FORMAT (41H1TRY NO DATA WITHIN USER SUPPLIED LIMITS.)
 1120 FORMAT (38H1RUN HIST ON 200 PSEUDO-RANDON NUMBERS)
 1130 FORMAT(24H1RUN HIST ON -1, 8*0, 1.)
 1150 FORMAT (48H1TEST RUNS FOR THE HISTOGRAM FAMILY OF ROUTINES.)
 1160 FORMAT(47H TEST 1.  GENERATE ONE OF EACH OF THE POSSIBLE ,
     +   15HERROR MESSAGES.)
 1170 FORMAT(22H THE VALUE OF IERR IS , I4)
 1180 FORMAT(28H TRY ZERO OR FEWER ELEMENTS.)
 1190 FORMAT('1TEST WITH INSUFFICIENT WORK AREA')
 1195 FORMAT(' TEST WITH EXACTLY THE RIGHT AMOUNT OF WORK AREA.')
 1200 FORMAT('1TRY CONSTANT Y. (NOT AN ERROR)')
 1300 FORMAT(52H1TEST 4.  MAKE WORKING RUNS OF ALL ROUTINES TO CHECK,
     +   12H THE OUTPUT.)
 1310 FORMAT(48H1RUN HIST ON THE DAVIS-HARRISON PIKES PEAK DATA.)
 1340 FORMAT(49H1RUN HISTC ON THE DAVIS-HARRISON PIKES PEAK DATA.)
 1350 FORMAT(/48H PRINT THE DATA TO INSURE THE ORIGINAL ORDER HAS,
     +   15H BEEN RESTORED.)
 1360 FORMAT (7F10.5)
      END
*XLLS
      SUBROUTINE XLLS(LDS)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     TEST ROUTINES FOR LINEAR LEAST SQUARES SUBROUTINES.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 29, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDS
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD,SUM,TERM
      INTEGER
     +   I,IPRT,IVCV,IXM,J,LDSMIN,LDSTAK,LPAR,N,NDEG,NPAR,NPRT
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(10),PV(50),RAND(1),RES(50),SDPV(50),SDRES(50),VCV(10,10),
     +   WT(50),X(50,9),XM(50,10),XM1(50,10),Y(50),Y1(50)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL FITSXP,GENR,IPRINT,LDSCMP,LLS,LLSP,LLSPS,LLSPW,LLSPWS,
     +   LLSS,LLSW,LLSWS,NRAND,SETRV
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (XM(1,2),X(1,1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER I
C        AN INDEX.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
C        DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE MATRIX VCV.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE MATRIX X.
C     INTEGER J
C        AN INDEX.
C     INTEGER LDS
C       ..
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LPAR
C        THE ACTUAL LENGTH OF THE PARAMETER ARRAY.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NDEG
C        THE DEGREE OF THE POLYNOMIAL MODEL TO BE FIT.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
C        PRINTED OUTPUT.
C     DOUBLE PRECISION PAR(10)
C        THE PARAMETERS  TO BE ESTIMATED.
C     DOUBLE PRECISION PV(50)
C        THE PREDICTED VALUES.
C     DOUBLE PRECISION RAND(1)
C        *
C     DOUBLE PRECISION RES(50)
C        THE RESIDUALS.
C     DOUBLE PRECISION RSD
C        THE RESIDUAL STANDARD DEVIATION.
C     DOUBLE PRECISION SDPV(50)
C        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
C     DOUBLE PRECISION SDRES(50)
C        THE STANDARDIZED RESIDUALS.
C     DOUBLE PRECISION SUM, TERM
C        *
C     DOUBLE PRECISION VCV(10,10)
C        THE VARIANCE COVARIANCE MATRIX.
C     DOUBLE PRECISION WT(50)
C        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
C     DOUBLE PRECISION X(50,9)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION XM(50,10)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION XM1(50,10)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION Y(50)
C        THE DEPENDENT VARIABLE.
C     DOUBLE PRECISION Y1(50)
C        THE DEPENDENT VARIABLE.
C
C
      DATA      XM(1,1),  XM(1,2),  XM(1,3),  XM(1,4)
     +    /      1.0D0, 42.2D0, 11.2D0, 31.9D0/
      DATA      XM(2,1),  XM(2,2),  XM(2,3),  XM(2,4)
     +    /      1.0D0, 48.6D0, 10.6D0, 13.2D0/
      DATA      XM(3,1),  XM(3,2),  XM(3,3),  XM(3,4)
     +    /      1.0D0, 42.6D0, 10.6D0, 28.7D0/
      DATA      XM(4,1),  XM(4,2),  XM(4,3),  XM(4,4)
     +    /      1.0D0, 39.0D0, 10.4D0, 26.1D0/
      DATA      XM(5,1),  XM(5,2),  XM(5,3),  XM(5,4)
     +    /      1.0D0, 34.7D0,  9.3D0, 30.1D0/
      DATA      XM(6,1),  XM(6,2),  XM(6,3),  XM(6,4)
     +    /      1.0D0, 44.5D0, 10.8D0,  8.5D0/
      DATA      XM(7,1),  XM(7,2),  XM(7,3),  XM(7,4)
     +    /      1.0D0, 39.1D0, 10.7D0, 24.3D0/
      DATA      XM(8,1),  XM(8,2),  XM(8,3),  XM(8,4)
     +    /      1.0D0, 40.1D0, 10.0D0, 18.6D0/
      DATA      XM(9,1),  XM(9,2),  XM(9,3),  XM(9,4)
     +    /      1.0D0, 45.9D0, 12.0D0, 20.4D0/
      DATA         Y(1),     Y(2),     Y(3)
     +    /    167.1D0,174.4D0,160.8D0/
      DATA         Y(4),     Y(5),     Y(6)
     +    /    162.0D0,140.8D0,174.6D0/
      DATA         Y(7),     Y(8),     Y(9)
     +    /    163.7D0,174.5D0,185.7D0/
C
C     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
C
      CALL IPRINT(IPRT)
      N = 9
      NPAR = 4
      NDEG = 3
      NPRT = 2
      LPAR = 10
      IVCV = 10
      IXM = 50
      LDSTAK = LDS
C
      CALL SETRV(WT, N, 1.0D0)
C
C     CHECK ERROR HANDLING
C
C        ERROR 1  -  NON POSITIVE NUMBER OF OBSERVATIONS AND PARAMETER
C                    NUMBER OF PARAMETERS GREATER THAN N
C                    IXM LESS THAN NUMBER OF OBSERVATIONS
C                    IVCV LESS THAN NUMBER OF PARAMETERS
C                    LPAR TOO SMALL
C
      N = -5
      NPAR = 0
      NDEG = -1
      IXM = -10
      LPAR = -1
      IVCV = -10
      NPRT = -1
      WRITE (IPRT,1200)
      WRITE (IPRT,1000)
      CALL LLS(Y, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1020)
      CALL LLSW(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1040)
      CALL LLSP(Y, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1050)
      CALL LLSPS(Y, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1060)
      CALL LLSPW(Y, WT, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1070)
      CALL LLSPWS(Y, WT, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      N = 9
      NPAR = 4
      NDEG = 3
      IXM = 50
      LPAR = -10
      IVCV = 10
C
C        ERROR 2  -  LDS TOO SMALL
C                    LPAR TOO SMALL
C
      LDSTAK = 0
      WRITE (IPRT,1220)
      WRITE (IPRT,1000)
      CALL LLS(Y, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1020)
      CALL LLSW(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1040)
      CALL LLSP(Y, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1050)
      CALL LLSPS(Y, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1060)
      CALL LLSPW(Y, WT, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1070)
      CALL LLSPWS(Y, WT, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      LDSTAK = LDS
      NPRT = 2
      LPAR = 10
C
C        ERROR 3  -  NEGATIVE WEIGHTS
C
      WT(1) = -1.0D0
      WRITE (IPRT,1240)
      WRITE (IPRT,1020)
      CALL LLSW(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1060)
      CALL LLSPW(Y, WT, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1070)
      CALL LLSPWS(Y, WT, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WT(1) = 1.0D0
C
C        ERROR 4  -  TOO FEW POSITIVE WEIGHTS
C
      CALL SETRV(WT(2), N-1, 0.0D0)
      WRITE (IPRT,1250)
      WRITE (IPRT,1020)
      CALL LLSW(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1060)
      CALL LLSPW(Y, WT, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1070)
      CALL LLSPWS(Y, WT, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL SETRV(WT(2), N-1, 1.0D0)
C
C     CHECK RESULTS FROM VALID CALL
C
      WRITE (IPRT,1260)
      WRITE (IPRT,1000)
      CALL LLS(Y, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
      WRITE (IPRT,1260)
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1260)
      WRITE (IPRT,1020)
      CALL LLSW(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
      WRITE (IPRT,1260)
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1260)
      WRITE (IPRT,1040)
      CALL LLSP(Y, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
      WRITE (IPRT,1260)
      WRITE (IPRT,1050)
      CALL LLSPS(Y, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1260)
      WRITE (IPRT,1060)
      CALL LLSPW(Y, WT, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
      WRITE (IPRT,1260)
      WRITE (IPRT,1070)
      CALL LLSPWS(Y, WT, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
C     CHECK RESULTS FROM EXACT FIT
C
      N = NPAR
      NDEG = NPAR-1
C
      WRITE (IPRT,1270)
      WRITE (IPRT,1000)
      CALL LLS(Y, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
      WRITE (IPRT,1270)
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1270)
      WRITE (IPRT,1040)
      CALL LLSP(Y, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
      WRITE (IPRT,1270)
      WRITE (IPRT,1050)
      CALL LLSPS(Y, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
      N = 9
C
      CALL SETRV(WT(NPAR+1), N-NPAR, 0.0D0)
C
      WRITE (IPRT,1270)
      WRITE (IPRT,1020)
      CALL LLSW(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
      WRITE (IPRT,1270)
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1270)
      WRITE (IPRT,1060)
      CALL LLSPW(Y, WT, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
      WRITE (IPRT,1270)
      WRITE (IPRT,1070)
      CALL LLSPWS(Y, WT, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
      CALL SETRV(WT(NPAR+1), N-NPAR, 1.0D0)
C
C     CHECK RESULTS FROM RANK DEFICIENT FIT
C
      DO 10 I = 1, N
         XM(I,5) = XM(I,4)
   10 CONTINUE
      WRITE (IPRT,1280)
      WRITE (IPRT,1000)
      CALL LLS(Y, XM, N, IXM, NPAR+1, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
C
C     CHECK RESULTS FROM A POORLY SCALED PROBLEM.
C
      DO 30 I = 1, N
         Y1(I) = Y(I) * 1.0D-8
         DO 20 J = 1, 4
            XM1(I,J) = XM(I,J)
   20    CONTINUE
         XM1(I,3) = XM1(I,3) * 1.0D+8
   30 CONTINUE
C
      WRITE (IPRT,1290)
      WRITE (IPRT,1000)
      CALL LLS(Y1, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1290)
      WRITE (IPRT,1000)
      CALL LLS(Y, XM1, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1290)
      WRITE (IPRT,1000)
      CALL LLS(Y1, XM1, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
C
C     MINIMUM AMOUNT OF WORK AREA.
C
      CALL LDSCMP(15, 0, 0, 0, 0, 0, 'D',
     +            6*N + NPAR*(N+2*NPAR+5) + 1, LDSMIN)
C
      WRITE (IPRT,1300)
      WRITE (IPRT,1000)
      CALL LLS(Y, XM, N, IXM, NPAR, RES, LDSMIN)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
C
C     CHECK RESULTS FOR WEIGHTED ANALYSIS
C
      NPRT = 1111
      CALL SETRV(WT, N, 100.0D0)
      WRITE (IPRT,1310)
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
      WT(1) = 0.0D0
      WT(5) = 0.0D0
      WT(9) = 0.0D0
C
      WRITE (IPRT,1310)
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      CALL SETRV(WT, N, 100.0D0)
C
      CALL GENR(WT, N, 1.0D0, 1.0D0)
      WRITE (IPRT,1310)
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      CALL SETRV(WT, N, 100.0D0)
C
C     CHECK PRINT CONTROL
C
      NPRT = 1000
      WRITE (IPRT,1320) NPRT
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
      NPRT = 2000
      WRITE (IPRT,1320) NPRT
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
      NPRT = 200
      WRITE (IPRT,1320) NPRT
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
      NPRT = 20
      WRITE (IPRT,1320) NPRT
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
      NPRT = 2
      WRITE (IPRT,1320) NPRT
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
      NPRT = 0
      WRITE (IPRT,1320) NPRT
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
C     CHECK RESULTS FOR N = 2, NPAR = ID+1 = 1
C
      NPRT = 2222
      N = 2
      NPAR = 1
      NDEG = 0
      WRITE (IPRT,1330)
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1330)
      WRITE (IPRT,1070)
      CALL LLSPWS(Y, WT, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
C     CHECK RESULTS FOR N = 1, NPAR = ID+1 = 1
C
      NPRT = 2222
      N = 1
      NPAR = 1
      NDEG = 0
      WRITE (IPRT,1330)
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1330)
      WRITE (IPRT,1070)
      CALL LLSPWS(Y, WT, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      N = 9
      NPAR = 4
      NDEG = 3
C
C
C     ILL-CONDITIONED
C
      DO 40 I = 1, 50
         TERM = 1.0D0
         SUM = 0.0D0
         DO 35 J = 1, 6
            XM1(I,J) = TERM
            SUM = SUM + TERM
            TERM = (I-1)*TERM
   35    CONTINUE
         Y1(I) = SUM
   40 CONTINUE
C
      N = 21
      NPAR = 6
      NDEG = 5
      WRITE (IPRT,1340)
      WRITE (IPRT,1010)
      CALL LLSS(Y1, XM1, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1340)
      WRITE (IPRT,1050)
      CALL LLSPS(Y1, XM1(1,2), N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
      N = 50
      NPAR = 6
      NDEG = 5
      CALL NRAND(RAND, 1, 223)
      DO 50 I = 1, N
         CALL NRAND(RAND, 1, 0)
         Y1(I) = Y1(I) + RAND(1)
   50 CONTINUE
      WRITE (IPRT,1340)
      WRITE (IPRT,1010)
      CALL LLSS(Y1, XM1, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1340)
      WRITE (IPRT,1050)
      CALL LLSPS(Y1, XM1(1,2), N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
      NPRT = 1000
      WRITE (IPRT,1340)
      WRITE (IPRT,1010)
      CALL LLSS(Y1, XM1, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1340)
      WRITE (IPRT,1050)
      CALL LLSPS(Y1, XM1(1,2), N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
      N = 45
      CALL SETRV(WT, N, 1.0D0)
      WRITE (IPRT,1340)
      WRITE (IPRT,1010)
      CALL LLSWS(Y1, WT, XM1, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
      N = 44
      WRITE (IPRT,1340)
      WRITE (IPRT,1010)
      CALL LLSWS(Y1, WT, XM1, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
      N = 41
      WRITE (IPRT,1340)
      WRITE (IPRT,1010)
      CALL LLSWS(Y1, WT, XM1, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
      N = 40
      WRITE (IPRT,1340)
      WRITE (IPRT,1010)
      CALL LLSWS(Y1, WT, XM1, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (' CALL TO LLS   ')
 1010 FORMAT (' CALL TO LLSS  ')
 1020 FORMAT (' CALL TO LLSW  ')
 1030 FORMAT (' CALL TO LLSWS ')
 1040 FORMAT (' CALL TO LLSP  ')
 1050 FORMAT (' CALL TO LLSPS ')
 1060 FORMAT (' CALL TO LLSPW ')
 1070 FORMAT (' CALL TO LLSPWS')
 1200 FORMAT ('1MISCELLANEOUS ERRORS  -  TEST 1')
 1220 FORMAT ('1MISCELLANEOUS ERRORS  -  TEST 2')
 1240 FORMAT ('1NEGATIVE WEIGHTS')
 1250 FORMAT ('1TOO FEW POSITIVE WEIGHTS')
 1260 FORMAT ('1VALID PROBLEM')
 1270 FORMAT ('1ZERO RESIDUAL PROBLEM')
 1280 FORMAT ('1RANK DEFICIENT PROBLEM')
 1290 FORMAT ('1POORLY SCALED PROBLEM')
 1300 FORMAT ('1MINIMUM WORK AREA SIZE')
 1310 FORMAT ('1WEIGHTED ANALYSIS')
 1320 FORMAT ('1CHECK PRINT CONTROL  -  NPRT = ', I5)
 1330 FORMAT ('1CHECK MINIMUM PROBLEM SIZE')
 1340 FORMAT ('1ILL-CONDITIONED PROBLEM')
 1430 FORMAT (//4H RES/ (1X, E22.14))
 1500 FORMAT (/' IERR = ', I5)
C
      END
*XNLSD
      SUBROUTINE XNLSD(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     DEMONSTRATE THE USER CALLABLE ROUTINES IN THE NONLINEAR
C     LEAST SQUARES FAMILY.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IPRT,IVAPRX,IVCV,IXM1,LDSA1,LDSMIN,LDSN1A,LDSN1B,
     +   M1,MIT,N1,NNZW,NPAR1,NPARE,NPRT,NTEST
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR1(10),PV(100),RES(100),SCALE(10),SDPV(100),SDRES(100),
     +   STP(10),VCV(6,6),WT(100),XM1(10,2),Y1(10)
      INTEGER
     +   IFIXED(10)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DRV1A,FITXSP,IPRINT,LDSCMP,MDL1,NL2X,NLS,NLSC,NLSD,NLSDC,
     +   NLSDS,NLSS,NLSW,NLSWC,NLSWD,NLSWDC,NLSWDS,NLSWS,NLSX1,
     +   NLSX2,SETRV
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     EXTERNAL DRV1A
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IDRVCK
C        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
C        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(10)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM1
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LDSA1, LDSN1A, LDSN1B
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK
C        FOR THE ROUTINES WITH ANALYTIC DERIVATIVES AND
C        NUMERICAL DERIVATIVES, RESPECTIVELY.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER M1
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL1
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
C     INTEGER N1
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
C     INTEGER NPAR1
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     INTEGER NTEST
C        THE NUMBER OF THE CURRENT TEST.
C     DOUBLE PRECISION PAR1(10)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION PV(100)
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(100)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     DOUBLE PRECISION SCALE(10)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
C     DOUBLE PRECISION SDPV(100)
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(100)
C        THE STARTING LOCATION IN RSTAK/DSTAK OF THE
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(10)
C        THE RCSTEP SIZE ARRAY.
C     DOUBLE PRECISION VCV(6,6)
C        THE COVARIANCE MATRIX.
C     DOUBLE PRECISION WT(100)
C        THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION XM1(10,2)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y1(10)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     DEFINE CONSTANTS
C
      DATA Y1(1), Y1(2), Y1(3), Y1(4), Y1(5), Y1(6)
     +   /2.138D0, 3.421D0, 3.597D0, 4.340D0, 4.882D0, 5.660D0/
C
      DATA XM1(1,1), XM1(2,1), XM1(3,1), XM1(4,1), XM1(5,1), XM1(6,1)
     +   /1.309D0, 1.471D0, 1.490D0, 1.565D0, 1.611D0, 1.680D0/
C
      CALL IPRINT(IPRT)
C
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
C
      CALL SETRV(WT, N1, 1.0D0)
C
      CALL LDSCMP(6, 0, 60+2*NPAR1, 0, 0, 0,
     +   'D', 94+N1*(3+NPAR1)+NPAR1*(3*NPAR1+35)/2, LDSA1)
      CALL LDSCMP(14, 0, MAX(2*(N1+NPAR1),60+2*NPAR1), 0, 0, 0,
     +   'D', MAX(10*N1,94+N1*(3+NPAR1)+NPAR1*(3*NPAR1+37)/2), LDSN1A)
      CALL LDSCMP(14, 0, 60+2*NPAR1, 0, 0, 0,
     +   'D', 94+N1*(3+NPAR1)+NPAR1*(3*NPAR1+37)/2, LDSN1B)
C
      LDSMIN = MAX(LDSA1, LDSN1A, LDSN1B)
C
      IF (LDSMIN.LE.LDSTAK) GO TO 5
C
      WRITE (IPRT, 1140) LDSMIN
      RETURN
C
    5 CONTINUE
C
      NTEST = 0
C
C
C     **TEST ON NORMAL STATEMENT**
C
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1000)
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLS(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSN1A)
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1010)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSC(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSN1B,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1020)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSS(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSN1B,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1030)
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSW(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSN1A)
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1040)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWC(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSN1B, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1050)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWS(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSN1B, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1060)
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSD(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSA1)
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1070)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSDC(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1080)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSDS(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1090)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWD(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSA1)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1100)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWDC(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1110)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
C
C
C     TEST NL2SOL AND NL2SNO DIRECTLY
C
      WRITE (IPRT,1320)
      CALL NL2X
C
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (14H TEST OF NLS  )
 1010 FORMAT (15H TEST OF NLSC  )
 1020 FORMAT (15H TEST OF NLSS  )
 1030 FORMAT (14H TEST OF NLSW )
 1040 FORMAT (15H TEST OF NLSWC )
 1050 FORMAT (15H TEST OF NLSWS )
 1060 FORMAT (14H TEST OF NLSD )
 1070 FORMAT (15H TEST OF NLSDC )
 1080 FORMAT (15H TEST OF NLSDS )
 1090 FORMAT (14H TEST OF NLSWD)
 1100 FORMAT (15H TEST OF NLSWDC)
 1110 FORMAT (15H TEST OF NLSWDS)
 1120 FORMAT (/29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1130 FORMAT (15H NORMAL PROBLEM)
 1140 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1320 FORMAT (42H1TEST OF NL2SOL AND NL2SNO CALLED DIRECTLY)
 1330 FORMAT (54H1NONLINEAR LEAST SQUARES ESTIMATION SUBROUTINE TEST NU,
     +   4HMBER, I5/)
 1340 FORMAT (24H INPUT   -  IFIXED(1) = , I6, 9X, 11H, STP(1) = ,
     +   G15.8, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8, 10H, STOPP = ,
     +   G15.8/13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I5)
 1350 FORMAT (//24H OUTPUT  -  IFIXED(1) = , I6, 9X, 11H, STP(1) = ,
     +   G15.8, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8, 10H, STOPP = ,
     +   G15.8/13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I5//)
 1360 FORMAT (24H INPUT   -  IFIXED(1) = , I6, 9X, 11H, IDRVCK = ,
     +   I5, 10X, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8,
     +   10H, STOPP = , G15.8/
     +   13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I6)
 1370 FORMAT (//24H OUTPUT  -  IFIXED(1) = , I6, 9X, 11H, IDRVCK = ,
     +   I5, 10X, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8,
     +   10H, STOPP = , G15.8/
     +   13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I5//)
      END
*XNLSE
      SUBROUTINE XNLSE(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     DEMONSTRATE THE USER CALLABLE ROUTINES IN THE NONLINEAR
C     LEAST SQUARES FAMILY.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   I,IDRVCK,IPRT,IVAPRX,IVCV,IXM1,IXM3,LDSA1,LDSMIN,LDSN3A,
     +   M1,M3,MIT,N1,N3,NNZW,NPAR1,NPAR3,NPARE,NPRT,NTEST
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR1(10),PAR3(10),PV(100),RES(100),SCALE(10),SDPV(100),
     +   SDRES(100),STP(10),VCV(6,6),WT(100),XM1(10,2),XM3(101,5),
     +   Y1(10),Y3(100)
      INTEGER
     +   IFIXED(10)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DRV1A,DRV1B,IPRINT,LDSCMP,MDL1,MDL3,NLS,NLSC,NLSD,NLSDC,
     +   NLSDS,NLSS,NLSW,NLSWC,NLSWD,NLSWDC,NLSWDS,NLSWS,NLSX1,
     +   NLSX2,SETRV
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     EXTERNAL DRV1A, DRV1B
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER I
C        AN INDEX VALUE.
C     INTEGER IDRVCK
C        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
C        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(10)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM1, IXM3
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LDSA1, LDSN3A
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK
C        FOR THE ROUTINES WITH ANALYTIC DERIVATIVES AND
C        NUMERICAL DERIVATIVES, RESPECTIVELY.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER M1, M3
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL1, MDL3
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
C     INTEGER N1, N3
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
C     INTEGER NPAR1, NPAR3
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     INTEGER NTEST
C        THE NUMBER OF THE CURRENT TEST.
C     DOUBLE PRECISION PAR1(10), PAR3(10)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION PV(100)
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(100)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     DOUBLE PRECISION SCALE(10)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
C     DOUBLE PRECISION SDPV(100)
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(100)
C        THE STARTING LOCATION IN RSTAK/DSTAK OF THE
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(10)
C        THE RCSTEP SIZE ARRAY.
C     DOUBLE PRECISION VCV(6,6)
C        THE COVARIANCE MATRIX.
C     DOUBLE PRECISION WT(100)
C        THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION XM1(10,2), XM3(101,5)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y1(10), Y3(100)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     DEFINE CONSTANTS
C
      DATA Y1(1), Y1(2), Y1(3), Y1(4), Y1(5), Y1(6)
     +   /2.138D0, 3.421D0, 3.597D0, 4.340D0, 4.882D0, 5.660D0/
C
      DATA XM1(1,1), XM1(2,1), XM1(3,1), XM1(4,1), XM1(5,1), XM1(6,1)
     +   /1.309D0, 1.471D0, 1.490D0, 1.565D0, 1.611D0, 1.680D0/
C
      DATA N3 /50/, M3 /5/, IXM3 /101/, NPAR3 /5/
C
      CALL IPRINT(IPRT)
C
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
C
      CALL SETRV(WT, N3, 1.0D0)
C
      CALL LDSCMP(6, 0, 60+2*NPAR1, 0, 0, 0,
     +   'D', 94+N1*(3+NPAR1)+NPAR1*(3*NPAR1+35)/2, LDSA1)
      CALL LDSCMP(14, 0, MAX(2*(N3+NPAR3),60+2*NPAR3), 0, 0, 0,
     +   'D', MAX(10*N3,94+N3*(3+NPAR3)+NPAR3*(3*NPAR3+37)/2), LDSN3A)
C
      LDSMIN = MAX(LDSA1, LDSN3A)
C
      IF (LDSMIN.LE.LDSTAK) GO TO 5
C
      WRITE (IPRT, 1190) LDSMIN
      RETURN
C
    5 CONTINUE
C
      DO 20 I=1,N3
         XM3(I,1) = 1.0D0
         XM3(I,2) = I
         XM3(I,3) = XM3(I,2)*XM3(I,2)
         XM3(I,4) = XM3(I,3)*XM3(I,2)
         XM3(I,5) = XM3(I,4)*XM3(I,2)
         Y3(I) = XM3(I,1) + XM3(I,2) + XM3(I,3) + XM3(I,4) + XM3(I,5)
   20 CONTINUE
C
      NTEST = 0
C
C
C
C     CHECK ERROR HANDLING
C
C        TEST 1  -  PROBLEM SPECIFICATION
C
      N1 = -5
      M1 = -1
      IXM1 = -10
      NPAR1 = 0
      IVCV = -10
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1140)
C
      WRITE (IPRT,1000)
      CALL NLS(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSTAK)
      WRITE (IPRT,1120) IERR
C
      WRITE (IPRT,1010)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSC(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
C
      NPAR1 = 8
      N1 = 2
      WRITE (IPRT,1020)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSS(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
C
      WRITE (IPRT,1030)
      CALL NLSW(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSTAK)
      WRITE (IPRT,1120) IERR
C
      WRITE (IPRT,1040)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWC(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
C
      WRITE (IPRT,1050)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWS(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
C
      WRITE (IPRT,1060)
      CALL NLSD(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSTAK)
      WRITE (IPRT,1120) IERR
C
      WRITE (IPRT,1070)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSDC(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
C
      N1 = 15
      WRITE (IPRT,1080)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSDS(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
C
      WRITE (IPRT,1090)
      CALL NLSWD(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK)
      WRITE (IPRT,1120) IERR
C
      WRITE (IPRT,1100)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWDC(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
C
      WRITE (IPRT,1110)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
C
C        TEST 2  -  WEIGHTS AND CONTROL VALUES
C
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
C
      WT(N1) = -1.0D0
      STP(1) = 1.0D0
      STP(2) = 0.0D0
      SCALE(1) = 1.0D0
      SCALE(2) = 0.0D0
      DO 30 I=1,NPAR1
         IFIXED(I) = 1
   30 CONTINUE
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1150)
C
      WRITE (IPRT,1050)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWS(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
C
      WRITE (IPRT,1090)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWD(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK)
      CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
C
C
C        TEST 3  -  TOO FEW POSITIVE WEIGHTS
C
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
C
      CALL SETRV(WT(2), N1-1, 0.0D0)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1160)
C
      WRITE (IPRT,1030)
      CALL NLSW(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSTAK)
      WRITE (IPRT,1120) IERR
C
      WRITE (IPRT,1110)
      CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1120) IERR
C
C
C        TEST 4  -  DEFINITE ERROR IN DERIVATIVE
C
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
C
      CALL SETRV(WT, N1, 1.0D0)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1170)
C
      WRITE (IPRT,1060)
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSD(Y1, XM1, N1, M1, IXM1, MDL1, DRV1B, PAR1, NPAR1, RES,
     +   LDSTAK)
      WRITE (IPRT,1120) IERR
C
C
C        TEST 5  -  POSSIBLE ERROR IN DERIVATIVE
C
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
      IDRVCK = 1
      NPRT = 10000
C
      CALL SETRV(WT, N1, 1.0D0)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1180)
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      PAR1(1) = 0.0D0
      WRITE (IPRT,1070)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSDC(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
C
C
C        TEST 6 -  INSUFFICIENT WORK AREA LENGTH
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1230)
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
C
      WRITE (IPRT,1000)
      CALL NLSX1(3, PAR3, NPAR3, PV, SDPV, RES, SDRES, VCV, N3, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLS(Y3, XM3, N3, M3, IXM3, MDL3, PAR3, NPAR3, RES, LDSN3A-1)
      WRITE (IPRT,1120) IERR
C
      WRITE (IPRT,1090)
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N3, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWD(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSA1-1)
      WRITE (IPRT,1120) IERR
C
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (14H TEST OF NLS  )
 1010 FORMAT (15H TEST OF NLSC  )
 1020 FORMAT (15H TEST OF NLSS  )
 1030 FORMAT (14H TEST OF NLSW )
 1040 FORMAT (15H TEST OF NLSWC )
 1050 FORMAT (15H TEST OF NLSWS )
 1060 FORMAT (14H TEST OF NLSD )
 1070 FORMAT (15H TEST OF NLSDC )
 1080 FORMAT (15H TEST OF NLSDS )
 1090 FORMAT (14H TEST OF NLSWD)
 1100 FORMAT (15H TEST OF NLSWDC)
 1110 FORMAT (15H TEST OF NLSWDS)
 1120 FORMAT (/29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1140 FORMAT (46H ERROR HANDLING TEST 1 - PROBLEM SPECIFICATION)
 1150 FORMAT (51H ERROR HANDLING TEST 2 - WEIGHTS AND CONTROL VALUES)
 1160 FORMAT (49H ERROR HANDLING TEST 3 - TOO FEW POSITIVE WEIGHTS)
 1170 FORMAT (53H ERROR HANDLING TEST 4 - DEFINITE ERROR IN DERIVATIVE)
 1180 FORMAT (53H ERROR HANDLING TEST 5 - POSSIBLE ERROR IN DERIVATIVE)
 1190 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1230 FORMAT (' ERROR HANDLING TEST 6 - INSUFFICIENT WORK AREA LENGTH')
 1330 FORMAT (54H1NONLINEAR LEAST SQUARES ESTIMATION SUBROUTINE TEST NU,
     +   4HMBER, I5/)
 1340 FORMAT (24H INPUT   -  IFIXED(1) = , I6, 9X, 11H, STP(1) = ,
     +   G15.8, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8, 10H, STOPP = ,
     +   G15.8/13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I5)
 1350 FORMAT (//24H OUTPUT  -  IFIXED(1) = , I6, 9X, 11H, STP(1) = ,
     +   G15.8, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8, 10H, STOPP = ,
     +   G15.8/13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I5//)
 1360 FORMAT (24H INPUT   -  IFIXED(1) = , I6, 9X, 11H, IDRVCK = ,
     +   I5, 10X, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8,
     +   10H, STOPP = , G15.8/
     +   13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I6)
 1370 FORMAT (//24H OUTPUT  -  IFIXED(1) = , I6, 9X, 11H, IDRVCK = ,
     +   I5, 10X, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8,
     +   10H, STOPP = , G15.8/
     +   13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I5//)
      END
*XNLST
      SUBROUTINE XNLST(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     DEMONSTRATE THE USER CALLABLE ROUTINES IN THE NONLINEAR
C     LEAST SQUARES FAMILY.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   I,IDRVCK,IPRT,IVAPRX,IVCV,IXM1,IXM2,IXM3,LDSA1,LDSMIN,
     +   LDSN1B,M1,M2,M3,MIT,N1,N2,N3,NNZW,NPAR1,NPAR2,NPAR3,NPARE,
     +   NPRT,NTEST
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR1(10),PAR2(10),PAR3(10),PV(100),RES(100),SCALE(10),
     +   SDPV(100),SDRES(100),STOP(8),STP(10),VCV(6,6),WT(100),
     +   XM1(10,2),XM2(10,3),XM3(101,5),Y1(10),Y2(10),Y3(100)
      INTEGER
     +   IFIXED(10),IVCTST(9)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   RMDCON
      EXTERNAL RMDCON
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DRV1A,DRV2,DRV3,FITXSP,IPRINT,LDSCMP,MDL1,MDL2,MDL3,NLSC,
     +   NLSDC,NLSDS,NLSS,NLSWC,NLSWDC,NLSWDS,NLSWS,NLSX1,NLSX2,
     +   SETRV
C
C  INTRINSIC FUNCTIONS
      INTRINSIC MAX
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
C        FIRST ITERATION.
C     EXTERNAL DRV1A, DRV2, DRV3
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER I
C        AN INDEX VALUE.
C     INTEGER IDRVCK
C        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
C        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IFIXED(10)
C        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
C        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
C        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
C        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
C        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IVCTST(9)
C        VARIANCE-COVARIANCE CODE TEST VALUES.
C     INTEGER IVAPRX
C        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
C        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
C        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
C        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
C                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
C        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
C                          *INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(HESSIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
C                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
C                    USING ONLY THE MODEL SUBROUTINE
C        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
C     INTEGER IVCV
C        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
C     INTEGER IXM1, IXM2, IXM3
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
C     INTEGER LDSA1, LDSN1B
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK
C        FOR THE ROUTINES WITH ANALYTIC DERIVATIVES AND
C        NUMERICAL DERIVATIVES, RESPECTIVELY.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER M1, M2, M3
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     INTEGER MIT
C        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
C     EXTERNAL MDL1, MDL2, MDL3
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
C     INTEGER N1, N2, N3
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NPARE
C        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
C     INTEGER NPAR1, NPAR2, NPAR3
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NNZW
C        THE NUMBER OF NON ZERO WEIGHTS.
C     INTEGER NPRT
C        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
C        TO BE PROVIDED.
C     INTEGER NTEST
C        THE NUMBER OF THE CURRENT TEST.
C     DOUBLE PRECISION PAR1(10), PAR2(10), PAR3(10)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION PV(100)
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
C     DOUBLE PRECISION RES(100)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION RSD
C        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
C     DOUBLE PRECISION SCALE(10)
C        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
C        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
C     DOUBLE PRECISION SDPV(100)
C        THE STARTING LOCATION IN RSTAK/DSTAK OF
C        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
C     DOUBLE PRECISION SDRES(100)
C        THE STARTING LOCATION IN RSTAK/DSTAK OF THE
C        THE STANDARD DEVIATIONS OF THE RESIDUALS.
C     DOUBLE PRECISION STOP(8)
C        STOPPING CRITERIA TEST VARIABLE.
C     DOUBLE PRECISION STOPP
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
C        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
C     DOUBLE PRECISION STOPSS
C        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
C        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
C        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
C     DOUBLE PRECISION STP(10)
C        THE RCSTEP SIZE ARRAY.
C     DOUBLE PRECISION VCV(6,6)
C        THE COVARIANCE MATRIX.
C     DOUBLE PRECISION WT(100)
C        THE USER SUPPLIED WEIGHTS.
C     DOUBLE PRECISION XM1(10,2), XM2(10,3), XM3(101,5)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C     DOUBLE PRECISION Y1(10), Y2(10), Y3(100)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     DEFINE CONSTANTS
C
      DATA Y1(1), Y1(2), Y1(3), Y1(4), Y1(5), Y1(6)
     +   /2.138D0, 3.421D0, 3.597D0, 4.340D0, 4.882D0, 5.660D0/
C
      DATA XM1(1,1), XM1(2,1), XM1(3,1), XM1(4,1), XM1(5,1), XM1(6,1)
     +   /1.309D0, 1.471D0, 1.490D0, 1.565D0, 1.611D0, 1.680D0/
C
      DATA N2 /10/, M2 /3/, IXM2 /10/, NPAR2 /3/
C
      DATA N3 /50/, M3 /5/, IXM3 /101/, NPAR3 /5/
C
      CALL IPRINT(IPRT)
C
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
C
      CALL SETRV(WT, N3, 1.0D0)
C
      CALL LDSCMP(6, 0, 60+2*NPAR1, 0, 0, 0,
     +   'D', 94+N1*(3+NPAR1)+NPAR1*(3*NPAR1+35)/2, LDSA1)
      CALL LDSCMP(14, 0, 60+2*NPAR1, 0, 0, 0,
     +   'D', 94+N1*(3+NPAR1)+NPAR1*(3*NPAR1+37)/2, LDSN1B)
      CALL LDSCMP(14, 0, MAX(2*(N3+NPAR3),60+2*NPAR3), 0, 0, 0,
     +   'D', MAX(10*N3,94+N3*(3+NPAR3)+NPAR3*(3*NPAR3+37)/2), LDSMIN)
C
      IF (LDSMIN.LE.LDSTAK) GO TO 5
C
      WRITE (IPRT, 1000) LDSMIN
      RETURN
C
    5 CONTINUE
C
      DO 10 I=1,N2
         Y2(I) = 0.0D0
         XM2(I,1) = I
         XM2(I,2) = I + 0.125D0
         XM2(I,3) = I + 0.25D0
   10 CONTINUE
C
      DO 20 I=1,N3
         XM3(I,1) = 1.0D0
         XM3(I,2) = I
         XM3(I,3) = XM3(I,2)*XM3(I,2)
         XM3(I,4) = XM3(I,3)*XM3(I,2)
         XM3(I,5) = XM3(I,4)*XM3(I,2)
         Y3(I) = XM3(I,1) + XM3(I,2) + XM3(I,3) + XM3(I,4) + XM3(I,5)
   20 CONTINUE
C
      NTEST = 0
C
C
C
C     **TEST CHECKING OF CONTROL CRITERIA**
C
      WRITE (IPRT,1240)
C
      STOP(1) = RMDCON(3)
      STOP(2) = 0.1D0
      STOP(3) = 0.9D0*RMDCON(3)
      STOP(4) = 0.11D0
      STOP(5) = 0.0D0
      STOP(6) = 1.0D0
      STOP(7) = -1.0D0
      STOP(8) = 1.1D0
C
      NPRT = 11000
      MIT = 0
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1250) MIT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      WRITE (IPRT,1100)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP, SCALE(1),
     +   DELTA, IVAPRX, NPRT
      CALL NLSWDC(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP, SCALE(1),
     +   DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
C
      MIT = 1
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1250) MIT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      WRITE (IPRT,1100)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP, SCALE(1),
     +   DELTA, IVAPRX, NPRT
      CALL NLSWDC(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP, SCALE(1),
     +   DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1250) MIT
      CALL NLSX1(2, PAR2, NPAR2, PV, SDPV, RES, SDRES, VCV, N2, IVCV,
     +   NNZW, NPARE, RSD)
      WRITE (IPRT,1050)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWS(Y2, WT, XM2, N2, M2, IXM2, MDL2, PAR2, NPAR2, RES,
     +   LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR2, PV, SDPV, RES, SDRES, VCV, N2, NPAR2, IVCV,
     +   NNZW, NPARE, RSD)
C
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
      DO 40 I=1,4
         NTEST = NTEST + 1
         WRITE (IPRT,1330) NTEST
         WRITE (IPRT,1260) STOP(I)
         CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1,
     +      IVCV, NNZW, NPARE, RSD)
         WRITE (IPRT,1100)
         WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOP(I), STOPP,
     +      SCALE(1), DELTA, IVAPRX, NPRT
         CALL NLSWDC(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1,
     +      NPAR1, RES, LDSTAK, IFIXED, IDRVCK, MIT, STOP(I), STOPP,
     +      SCALE, DELTA, IVAPRX, NPRT)
         WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOP(I), STOPP,
     +      SCALE(1), DELTA, IVAPRX, NPRT
         WRITE (IPRT,1120) IERR
   40 CONTINUE
      DO 50 I=5,8
         NTEST = NTEST + 1
         WRITE (IPRT,1330) NTEST
         WRITE (IPRT,1270) STOP(I)
         CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1,
     +      IVCV, NNZW, NPARE, RSD)
         WRITE (IPRT,1100)
         WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOP(I),
     +      SCALE(1), DELTA, IVAPRX, NPRT
         CALL NLSWDC(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1,
     +      NPAR1, RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOP(I),
     +      SCALE, DELTA, IVAPRX, NPRT)
         WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOP(I),
     +      SCALE(1), DELTA, IVAPRX, NPRT
         WRITE (IPRT,1120) IERR
   50 CONTINUE
      NPRT = 100000
      DO 60 I=1,6
         NTEST = NTEST + 1
         WRITE (IPRT,1330) NTEST
         WRITE (IPRT,1280) NPRT
         CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1,
     +      IVCV, NNZW, NPARE, RSD)
         WRITE (IPRT,1110)
         WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE(1), DELTA, IVAPRX, NPRT
         CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1,
     +      NPAR1, RES, LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE, DELTA, IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV,
     +      SDRES, VCV, IVCV)
         WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE(1), DELTA, IVAPRX, NPRT
         WRITE (IPRT,1120) IERR
         CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +      NNZW, NPARE, RSD)
         NPRT = NPRT/10
   60 CONTINUE
      NPRT = 11000
      DO 70 I=1,2
         NTEST = NTEST + 1
         WRITE (IPRT,1330) NTEST
         WRITE (IPRT,1280) NPRT
         CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1,
     +      IVCV, NNZW, NPARE, RSD)
         WRITE (IPRT,1110)
         WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE(1), DELTA, IVAPRX, NPRT
         CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1,
     +      NPAR1, RES, LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE, DELTA, IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV,
     +      SDRES, VCV, IVCV)
         WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE(1), DELTA, IVAPRX, NPRT
         WRITE (IPRT,1120) IERR
         CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +      NNZW, NPARE, RSD)
         NPRT = 11001
   70 CONTINUE
C
      NPRT = 0
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
C
      WRITE (IPRT,1010)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSC(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSN1B,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
      WRITE (IPRT,1020)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSS(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSN1B,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
      WRITE (IPRT,1040)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWC(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSN1B, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
      WRITE (IPRT,1050)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWS(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSN1B, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
      WRITE (IPRT,1070)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSDC(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
      WRITE (IPRT,1080)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSDS(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
      WRITE (IPRT,1100)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWDC(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
      WRITE (IPRT,1110)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      NPRT = -1
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
      WRITE (IPRT,1110)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
C
C     **TEST PARAMETER HANDLING**
C
      WRITE (IPRT,1190)
C
C     ALL ZERO
C
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
      STP(1) = -1.0D0
      SCALE(1) = -1.0D0
      DELTA = -1.0D0
      NPRT = 11000
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1200)
      CALL NLSX1(4, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      WRITE (IPRT,1010)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSC(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
      CALL NLSX1(4, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1200)
      WRITE (IPRT,1100)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWDC(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
C
C
C     **TEST WITH CONSTANT Y**
C
C     CONSTANT Y=0
C
      NPRT = 21222
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1210)
      CALL NLSX1(2, PAR2, NPAR2, PV, SDPV, RES, SDRES, VCV, N2, IVCV,
     +   NNZW, NPARE, RSD)
      WRITE (IPRT,1050)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWS(Y2, WT, XM2, N2, M2, IXM2, MDL2, PAR2, NPAR2, RES,
     +   LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR2, PV, SDPV, RES, SDRES, VCV, N2, NPAR2, IVCV,
     +   NNZW, NPARE, RSD)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1210)
      WRITE (IPRT,1110)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(2, PAR2, NPAR2, PV, SDPV, RES, SDRES, VCV, N2, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWDS(Y2, WT, XM2, N2, M2, IXM2, MDL2, DRV2, PAR2, NPAR2,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR2, PV, SDPV, RES, SDRES, VCV, N2, NPAR2, IVCV,
     +   NNZW, NPARE, RSD)
C
C     **TEST WITH LINEAR MODEL**
C
      NPRT = 11212
      IVAPRX = 1
C
      DO 80 I=1,NPAR3
         IFIXED(I) = 0
   80 CONTINUE
      IFIXED(1) = 1
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1220)
      WRITE (IPRT,1010)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(3, PAR3, NPAR3, PV, SDPV, RES, SDRES, VCV, N3, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSC(Y3, XM3, N3, M3, IXM3, MDL3, PAR3, NPAR3, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1220)
      NPRT = 11111
      WRITE (IPRT,1070)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(3, PAR3, NPAR3, PV, SDPV, RES, SDRES, VCV, N3, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSDC(Y3, XM3, N3, M3, IXM3, MDL3, DRV3, PAR3, NPAR3, RES,
     +   LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
C
C     **TEST XM**
C
C
C     FIRST COLUMN ZERO
C
      CALL SETRV(Y2, N2, 2.0D0)
      CALL SETRV(XM2(1,1), N2, 0.0D0)
C
      NPRT = 11000
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1310)
      CALL NLSX1(2, PAR2, NPAR2, PV, SDPV, RES, SDRES, VCV, N2, IVCV,
     +   NNZW, NPARE, RSD)
      WRITE (IPRT,1110)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWDS(Y2, WT, XM2, N2, M2, IXM2, MDL2, DRV2, PAR2, NPAR2,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE,
     +   DELTA, IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV,
     +   IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR2, PV, SDPV, RES, SDRES, VCV, N2, NPAR2, IVCV,
     +   NNZW, NPARE, RSD)
C
C     2 COLUMNS ZERO
C
      CALL SETRV(XM2(1,2), N2, 0.0D0)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1300)
      WRITE (IPRT,1110)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(2, PAR2, NPAR2, PV, SDPV, RES, SDRES, VCV, N2, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWDS(Y2, WT, XM2, N2, M2, IXM2, MDL2, DRV2, PAR2, NPAR2,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR2, PV, SDPV, RES, SDRES, VCV, N2, NPAR2, IVCV,
     +   NNZW, NPARE, RSD)
C
C     **TEST VARIANCE-COVARIANCE MATRIX COMPUTATIONS**
C
C
      IVCTST(1) = -1
      IVCTST(2) = 0
      IVCTST(3) = 1
      IVCTST(4) = 2
      IVCTST(5) = 3
      IVCTST(6) = 4
      IVCTST(7) = 5
      IVCTST(8) = 6
      IVCTST(9) = 7
      NPRT = 2
      DO 90 I=1,9
         NTEST = NTEST + 1
         WRITE (IPRT,1330) NTEST
         WRITE (IPRT,1380)
         CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1,
     +      IVCV, NNZW, NPARE, RSD)
         WRITE (IPRT,1110)
         WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE(1), DELTA, IVCTST(I), NPRT
         CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1,
     +      NPAR1, RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE, DELTA, IVCTST(I), NPRT, NNZW, NPARE, RSD, PV, SDPV,
     +      SDRES, VCV, IVCV)
         WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE(1), DELTA, IVCTST(I), NPRT
         WRITE (IPRT,1120) IERR
         CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +      NNZW, NPARE, RSD)
   90 CONTINUE
C
C     **TEST WITH 2 ZERO WEIGHTS**
C
      NPRT = 22222
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1290)
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      WT(3) = 0.0D0
      WT(5) = 0.0D0
      WRITE (IPRT,1110)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
C
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1010 FORMAT (15H TEST OF NLSC  )
 1020 FORMAT (15H TEST OF NLSS  )
 1040 FORMAT (15H TEST OF NLSWC )
 1050 FORMAT (15H TEST OF NLSWS )
 1070 FORMAT (15H TEST OF NLSDC )
 1080 FORMAT (15H TEST OF NLSDS )
 1100 FORMAT (15H TEST OF NLSWDC)
 1110 FORMAT (15H TEST OF NLSWDS)
 1120 FORMAT (/29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1190 FORMAT (28H **TEST PARAMETER HANDLING**)
 1200 FORMAT (20H ALL PARAMETERS ZERO)
 1210 FORMAT (30H **TEST WITH CONSTANT ZERO Y**)
 1220 FORMAT (22H **TEST LINEAR MODEL**)
 1240 FORMAT (26H **TEST CONTROL CRITERIA**)
 1250 FORMAT (34H --MAXIMUM NUMBER OF ITERATIONS = , I5)
 1260 FORMAT (12H --STOPSS = , G14.8)
 1270 FORMAT (11H --STOPP = , G14.8)
 1280 FORMAT (10H --NPRT = , I6)
 1290 FORMAT (29H **TEST WITH 2 ZERO WEIGHTS**)
 1300 FORMAT (19H **2 COLUMNS ZERO**)
 1310 FORMAT (18H **1 COLUMN ZERO**)
 1330 FORMAT (54H1NONLINEAR LEAST SQUARES ESTIMATION SUBROUTINE TEST NU,
     +   4HMBER, I5/)
 1340 FORMAT (24H INPUT   -  IFIXED(1) = , I6, 9X, 11H, STP(1) = ,
     +   G15.8, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8, 10H, STOPP = ,
     +   G15.8/13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I6)
 1350 FORMAT (//24H OUTPUT  -  IFIXED(1) = , I6, 9X, 11H, STP(1) = ,
     +   G15.8, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8, 10H, STOPP = ,
     +   G15.8/13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I6//)
 1360 FORMAT (24H INPUT   -  IFIXED(1) = , I6, 9X, 11H, IDRVCK = ,
     +   I5, 10X, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8,
     +   10H, STOPP = , G15.8/
     +   13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I6)
 1370 FORMAT (//24H OUTPUT  -  IFIXED(1) = , I6, 9X, 11H, IDRVCK = ,
     +   I5, 10X, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8,
     +   10H, STOPP = , G15.8/
     +   13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I6//)
 1380 FORMAT (54H TEST HANDLING OF VARIANCE-COVARIANCE COMPUTATION CODE,
     +   'S')
      END
*XNRAND
      SUBROUTINE XNRAND(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS PROGRAM TESTS FEATURES OF THE NRAND FAMILY TO ENSURE THAT
C     ALL ASPECTS OF THE NRAND FAMILY ROUTINES WORK CORRECTLY.
C
C     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   SIGMA,YMEAN
      INTEGER
     +   I,IPRT,ISEED,N
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   Y(1000)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL HIST,IPRINT,NRAND,NRANDC
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER IERR
C        FLAG TO INDICATE PRESENCE OF ERROR DETECTED BY PRECEDING
C        STARPAC CALL.  (0 IS OK, 1 IS ERROR)
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT.
C     INTEGER ISEED
C        THE SEED FOR THE RANDOM NUMBER GENERATOR.
C     INTEGER LDSTAK
C        AMOUNT OF WORK AREA.  SIZE OF DSTAK.
C     INTEGER N
C        THE LENGTH OF THE VECTOR Y.
C     DOUBLE PRECISION SIGMA
C        THE S.D. OF THE SAMPLE.
C     DOUBLE PRECISION Y(1000)
C        DATA VECTOR FOR TESTS.
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE SAMPLE.
C
C
C     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
C
      CALL IPRINT(IPRT)
C
C     CHECK FOR SUFFICIENT WORK AREA LENGTH.
C
      IF (LDSTAK.LT.1000) THEN
        WRITE (IPRT, 1000)
         RETURN
      END IF
C
C     HEADING.
C
      WRITE (IPRT,1150)
C
C     TEST 1.  CHECK ALL ERROR MESSAGES.
C
      WRITE (IPRT,1160)
C
C     ERROR 1, ZERO OR FEWER ELEMENTS OR NEGATIVE STANDARD DEVIATION.
C
      ISEED = 0
      SIGMA = -1
      N = 0
      YMEAN = 0.0D0
      CALL NRAND(Y, N, ISEED)
      WRITE (IPRT,1170) IERR
      CALL NRANDC(Y, N, ISEED, YMEAN, SIGMA)
      WRITE (IPRT,1170) IERR
C
C     COMPARE RESULTS
C
      ISEED = 334
      N = 10
      YMEAN = 0.0D0
      SIGMA = 1.0D0
C
      WRITE (IPRT, 1120) N, ISEED
      CALL NRAND (Y, N, ISEED)
      WRITE (IPRT, 1100) (Y(I),I=1,N)
C
      ISEED = 333
      WRITE (IPRT, 1130) N, YMEAN, SIGMA, ISEED
      CALL NRANDC (Y, N, ISEED, YMEAN, SIGMA)
      WRITE (IPRT, 1100) (Y(I),I=1,N)
C
      ISEED = 13531
      N = 1000
      YMEAN = 0.0D0
      SIGMA = 1.0D0
C
      WRITE (IPRT, 1120) N, ISEED
      CALL NRAND (Y, N, ISEED)
      CALL HIST (Y, N, LDSTAK)
C
      WRITE (IPRT, 1130) N, YMEAN, SIGMA, ISEED
      CALL NRANDC (Y, N, ISEED, YMEAN, SIGMA)
      CALL HIST (Y, N, LDSTAK)
C
      ISEED = 99999
      N = 1000
      YMEAN = 4.0D0
      SIGMA = 4.0D0
C
      WRITE (IPRT, 1120) N, ISEED
      CALL NRAND (Y, N, ISEED)
      CALL HIST (Y, N, LDSTAK)
C
      WRITE (IPRT, 1130) N, YMEAN, SIGMA, ISEED
      CALL NRANDC (Y, N, ISEED, YMEAN, SIGMA)
      CALL HIST (Y, N, LDSTAK)
C
      RETURN
C
C     FORMATS
C
 1000 FORMAT ('1THE DIMENSION OF DSTAK AND THE VALUE OF LDSTAK NEEDED'/
     +  ' FOR NRANDX MUST EQUAL OR EXCEED 1000.  CHANGE DRIVER'/
     +  ' AND RECALL NRANDX.')
 1100 FORMAT (5E15.8)
 1120 FORMAT ('1GENERATE ', I4,
     +  ' STANDARD NORMAL NUMBERS USING ISEED = ', I5)
 1130 FORMAT ('1GENERATE ', I4,
     +  ' NORMALLY DISTRIBUTED NUMBERS WITH YMEAN = ', F5.2,
     +  ' AND SIGMA = ', F5.2, ' USING ISEED = ', I5)
 1150 FORMAT ('1TEST RUNS FOR THE NRAND FAMILY OF ROUTINES.')
 1160 FORMAT(' TEST 1.  GENERATE EACH OF THE POSSIBLE ',
     +   15HERROR MESSAGES.)
 1170 FORMAT(/22H THE VALUE OF IERR IS , I4//)
      END
*XPGM
      SUBROUTINE XPGM(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST THE TIME SERIES PERIODOGRAM AND TIME SERIES
C     UTILITY SUBROUTINES
C
C     SERIES Y IS THE FIRST 50 VALUES OF THE SERIES LISTED ON PAGE
C     318 OF JENKINS AND WATTS.  THE SPECTRUM OF THIS SERIES IS SHOWN
C     FOR VARIOUS BANDWIDTH ON PAGE 270 OF JENKINS AND WATTS.
C
C     SERIES Z IS THE WOLF SUNSPOT NUMBERS FROM 1700 TO 1960 AS
C     TABULATED BY WALDMEIER.  THE RAW AND SMOOTHED PERIODOGRAMS OF
C     TAPERED SERIES ARE SHOWN ON PAGES 95 AND 176, RESPECTIVELY, OF
C     BLOOMFIELD.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   TAPERP
      INTEGER
     +   I,IEXTND,IPRT,ITEST,LAB,LFREQ,LPER,LPERI,LZFFT,NF,NFFT,NK,
     +   NPRT,NTEMP,NY,NZ
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AB(600),FREQ(300),PER(300),PERF(300),PERI(300),Y(150),
     +   YFFT(400),Z(275),ZFFT(600),ZT(275)
      INTEGER
     +   K(10)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CENTER,FFTLEN,FFTR,IPGM,IPGMP,IPGMPS,IPGMS,IPRINT,MDFLT,
     +   PGM,PGMS,PPL,DCOPY,TAPER
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AB(600)
C        THE VECTOR OF THE NF REAL AND IMAGINARY COMPONENTS OF THE
C        FOURIER COEFFICIENTS.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FREQ(300)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS COMPUTED.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IEXTND
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
C        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
C        USED TO EXTEND THE SERIES.
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ITEST
C        THE NUMBER OF THE TEST SET BEING PERFORMED
C     INTEGER K(10)
C        THE VECTOR OF THE MODIFIED DANIEL FILTER LENGTHS.
C     INTEGER LAB
C        THE LENGTH OF THE VECTOR AB.
C     INTEGER LDSTAK
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LFREQ
C        THE LENGTH OF THE VECTOR FREQ.
C     INTEGER LPER
C        THE LENGTH OF THE VECTOR PER.
C     INTEGER LPERI
C        THE LENGTH OF THE VECTOR PERI.
C     INTEGER LZFFT
C        THE LENGTH OF THE VECTORS YFFT AND ZFFT, RESPECTIVELY..
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NFFT
C        THE EXTENDED SERIES LENGTH.
C     INTEGER NK
C        THE NUMBER OF MODIFIED DANIEL FILTERS TO BE APPLIED.
C     INTEGER NPRT
C        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
C        FOR THE PERIODOGRAM ROUTINES
C        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
C                         PERIODOGRAM ON A LOG-LINEAR SCALE,
C        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
C                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
C        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
C        IF NPRT .EQ.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
C                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
C        IF NPRT .GE.  2, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
C                         PERIODOGRAM ON A LOG-LINEAR SCALE,
C        AND FOR THE INTEGRATED PERIODOGRAM ROUTINES
C        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
C        IF NPRT .NE.  0, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
C                         INTEGRATED PERIODOGRAM
C     INTEGER NTEMP
C        A TEMPORARY STORAGE LOCATION
C     INTEGER NY
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     INTEGER NZ
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Z.
C     DOUBLE PRECISION PER(300)
C        THE SERIES PERIODOGRAM.
C     DOUBLE PRECISION PERF(300)
C        THE FILTERED (SMOOTHED) PERIODOGRAM.
C     DOUBLE PRECISION PERI(300)
C        THE SERIES INTEGRATED PERIODOGRAM.
C     DOUBLE PRECISION TAPERP
C        THE PERCENT OF THE SERIES TO BE TAPERED.
C     DOUBLE PRECISION Y(150)
C         THE ARRAY CONTAINING THE TIME SERIES FROM JENKINS AND WATTS.
C     DOUBLE PRECISION YFFT(400)
C        THE VECTOR OF THE OBSERVED TIME SERIES TO BE ANALYZED USING
C        THE FFT.
C     DOUBLE PRECISION Z(275)
C        THE ARRAY OF THE WOLF SUNSPOT NUMBERS.
C     DOUBLE PRECISION ZFFT(600)
C        THE VECTOR OF THE TAPERED WOLF SUNSPOT NUMBERS TO BE
C        ANALYZED USING THE FFT.
C     DOUBLE PRECISION ZT(275)
C        THE ARRAY OF THE TAPERED SUNSPOT NUMBERS.
C
      DATA   Y(  1),  Y(  2),  Y(  3),  Y(  4),  Y(  5),  Y(  6)
     +    / -.88D0,  -.12D0,  -.89D0, -1.38D0,  -.07D0,  1.03D0/
      DATA   Y(  7),  Y(  8),  Y(  9),  Y( 10),  Y( 11),  Y( 12)
     +    / 2.14D0,   .35D0, -1.10D0, -1.78D0, -2.76D0, -1.77D0/
      DATA   Y( 13),  Y( 14),  Y( 15),  Y( 16),  Y( 17),  Y( 18)
     +    /  .98D0,  1.00D0,  -.70D0, -1.01D0, -1.30D0,  -.85D0/
      DATA   Y( 19),  Y( 20),  Y( 21),  Y( 22),  Y( 23),  Y( 24)
     +    / -.46D0,  1.63D0,   .06D0,  -.17D0, -1.01D0, -1.04D0/
      DATA   Y( 25),  Y( 26),  Y( 27),  Y( 28),  Y( 29),  Y( 30)
     +    / -.66D0, -1.12D0,  -.51D0,  -.71D0,  -.20D0,  -.13D0/
      DATA   Y( 31),  Y( 32),  Y( 33),  Y( 34),  Y( 35),  Y( 36)
     +    /  .14D0,  1.59D0,  -.76D0, -1.08D0, -1.77D0, -1.20D0/
      DATA   Y( 37),  Y( 38),  Y( 39),  Y( 40),  Y( 41),  Y( 42)
     +    /  .45D0,  -.07D0,  -.63D0,  -.35D0,  -.87D0,  -.62D0/
      DATA   Y( 43),  Y( 44),  Y( 45),  Y( 46),  Y( 47),  Y( 48)
     +    /  .28D0,  1.90D0,  2.14D0,  1.05D0,   .31D0,  1.07D0/
      DATA   Y( 49),  Y( 50)
     +    / 2.67D0,  2.44D0/
C
      DATA   Z(  1),  Z(  2),  Z(  3),  Z(  4),  Z(  5),  Z(  6)
     +    /  5.0D0,  11.0D0,  16.0D0,  23.0D0,  36.0D0,  58.0D0/
      DATA   Z(  7),  Z(  8),  Z(  9),  Z( 10),  Z( 11),  Z( 12)
     +    / 29.0D0,  20.0D0,  10.0D0,   8.0D0,   3.0D0,   0.0D0/
      DATA   Z( 13),  Z( 14),  Z( 15),  Z( 16),  Z( 17),  Z( 18)
     +    /  0.0D0,   2.0D0,  11.0D0,  27.0D0,  47.0D0,  63.0D0/
      DATA   Z( 19),  Z( 20),  Z( 21),  Z( 22),  Z( 23),  Z( 24)
     +    / 60.0D0,  39.0D0,  28.0D0,  26.0D0,  22.0D0,  11.0D0/
      DATA   Z( 25),  Z( 26),  Z( 27),  Z( 28),  Z( 29),  Z( 30)
     +    / 21.0D0,  40.0D0,  78.0D0, 122.0D0, 103.0D0,  73.0D0/
      DATA   Z( 31),  Z( 32),  Z( 33),  Z( 34),  Z( 35),  Z( 36)
     +    / 47.0D0,  35.0D0,  11.0D0,   5.0D0,  16.0D0,  34.0D0/
      DATA   Z( 37),  Z( 38),  Z( 39),  Z( 40),  Z( 41),  Z( 42)
     +    / 70.0D0,  81.0D0, 111.0D0, 101.0D0,  73.0D0,  40.0D0/
      DATA   Z( 43),  Z( 44),  Z( 45),  Z( 46),  Z( 47),  Z( 48)
     +    / 20.0D0,  16.0D0,   5.0D0,  11.0D0,  22.0D0,  40.0D0/
      DATA   Z( 49),  Z( 50),  Z( 51),  Z( 52),  Z( 53),  Z( 54)
     +    / 60.0D0,  80.9D0,  83.4D0,  47.7D0,  47.8D0,  30.7D0/
      DATA   Z( 55),  Z( 56),  Z( 57),  Z( 58),  Z( 59),  Z( 60)
     +    / 12.2D0,   9.6D0,  10.2D0,  32.4D0,  47.6D0,  54.0D0/
      DATA   Z( 61),  Z( 62),  Z( 63),  Z( 64),  Z( 65),  Z( 66)
     +    / 62.9D0,  85.9D0,  61.2D0,  45.1D0,  36.4D0,  20.9D0/
      DATA   Z( 67),  Z( 68),  Z( 69),  Z( 70),  Z( 71),  Z( 72)
     +    / 11.4D0,  37.8D0,  69.8D0, 106.1D0, 100.8D0,  81.6D0/
      DATA   Z( 73),  Z( 74),  Z( 75),  Z( 76),  Z( 77),  Z( 78)
     +    / 66.5D0,  34.8D0,  30.6D0,   7.0D0,  19.8D0,  92.5D0/
      DATA   Z( 79),  Z( 80),  Z( 81),  Z( 82),  Z( 83),  Z( 84)
     +    /154.4D0, 125.9D0,  84.8D0,  68.1D0,  38.5D0,  22.8D0/
      DATA   Z( 85),  Z( 86),  Z( 87),  Z( 88),  Z( 89),  Z( 90)
     +    / 10.2D0,  24.1D0,  82.9D0, 132.0D0, 130.9D0, 118.1D0/
      DATA   Z( 91),  Z( 92),  Z( 93),  Z( 94),  Z( 95),  Z( 96)
     +    / 89.9D0,  66.6D0,  60.0D0,  46.9D0,  41.0D0,  21.3D0/
      DATA   Z( 97),  Z( 98),  Z( 99),  Z(100),  Z(101),  Z(102)
     +    / 16.0D0,   6.4D0,   4.1D0,   6.8D0,  14.5D0,  34.0D0/
      DATA   Z(103),  Z(104),  Z(105),  Z(106),  Z(107),  Z(108)
     +    / 45.0D0,  43.1D0,  47.5D0,  42.2D0,  28.1D0,  10.1D0/
      DATA   Z(109),  Z(110),  Z(111),  Z(112),  Z(113),  Z(114)
     +    /  8.1D0,   2.5D0,   0.0D0,   1.4D0,   5.0D0,  12.2D0/
      DATA   Z(115),  Z(116),  Z(117),  Z(118),  Z(119),  Z(120)
     +    / 13.9D0,  35.4D0,  45.8D0,  41.1D0,  30.1D0,  23.9D0/
      DATA   Z(121),  Z(122),  Z(123),  Z(124),  Z(125),  Z(126)
     +    / 15.6D0,   6.6D0,   4.0D0,   1.8D0,   8.5D0,  16.6D0/
      DATA   Z(127),  Z(128),  Z(129),  Z(130),  Z(131),  Z(132)
     +    / 36.3D0,  49.6D0,  64.2D0,  67.0D0,  70.9D0,  47.8D0/
      DATA   Z(133),  Z(134),  Z(135),  Z(136),  Z(137),  Z(138)
     +    / 27.5D0,   8.5D0,  13.2D0,  56.9D0, 121.5D0, 138.3D0/
      DATA   Z(139),  Z(140),  Z(141),  Z(142),  Z(143),  Z(144)
     +    /103.2D0,  85.7D0,  64.6D0,  36.7D0,  24.2D0,  10.7D0/
      DATA   Z(145),  Z(146),  Z(147),  Z(148),  Z(149),  Z(150)
     +    / 15.0D0,  40.1D0,  61.5D0,  98.5D0, 124.7D0,  96.3D0/
      DATA   Z(151),  Z(152),  Z(153),  Z(154),  Z(155),  Z(156)
     +    / 66.6D0,  64.5D0,  54.1D0,  39.0D0,  20.6D0,   6.7D0/
      DATA   Z(157),  Z(158),  Z(159),  Z(160),  Z(161),  Z(162)
     +    /  4.3D0,  22.7D0,  54.8D0,  93.8D0,  95.8D0,  77.2D0/
      DATA   Z(163),  Z(164),  Z(165),  Z(166),  Z(167),  Z(168)
     +    / 59.1D0,  44.0D0,  47.0D0,  30.5D0,  16.3D0,   7.3D0/
      DATA   Z(169),  Z(170),  Z(171),  Z(172),  Z(173),  Z(174)
     +    / 37.6D0,  74.0D0, 139.0D0, 111.2D0, 101.6D0,  66.2D0/
      DATA   Z(175),  Z(176),  Z(177),  Z(178),  Z(179),  Z(180)
     +    / 44.7D0,  17.0D0,  11.3D0,  12.4D0,   3.4D0,   6.0D0/
      DATA   Z(181),  Z(182),  Z(183),  Z(184),  Z(185),  Z(186)
     +    / 32.3D0,  54.3D0,  59.7D0,  63.7D0,  63.5D0,  52.2D0/
      DATA   Z(187),  Z(188),  Z(189),  Z(190),  Z(191),  Z(192)
     +    / 25.4D0,  13.1D0,   6.8D0,   6.3D0,   7.1D0,  35.6D0/
      DATA   Z(193),  Z(194),  Z(195),  Z(196),  Z(197),  Z(198)
     +    / 73.0D0,  85.1D0,  78.0D0,  64.0D0,  41.8D0,  26.2D0/
      DATA   Z(199),  Z(200),  Z(201),  Z(202),  Z(203),  Z(204)
     +    / 26.7D0,  12.1D0,   9.5D0,   2.7D0,   5.0D0,  24.4D0/
      DATA   Z(205),  Z(206),  Z(207),  Z(208),  Z(209),  Z(210)
     +    / 42.0D0,  63.5D0,  53.8D0,  62.0D0,  48.5D0,  43.9D0/
      DATA   Z(211),  Z(212),  Z(213),  Z(214),  Z(215),  Z(216)
     +    / 18.6D0,   5.7D0,   3.6D0,   1.4D0,   9.6D0,  47.4D0/
      DATA   Z(217),  Z(218),  Z(219),  Z(220),  Z(221),  Z(222)
     +    / 57.1D0, 103.9D0,  80.6D0,  63.6D0,  37.6D0,  26.1D0/
      DATA   Z(223),  Z(224),  Z(225),  Z(226),  Z(227),  Z(228)
     +    / 14.2D0,   5.8D0,  16.7D0,  44.3D0,  63.9D0,  69.0D0/
      DATA   Z(229),  Z(230),  Z(231),  Z(232),  Z(233),  Z(234)
     +    / 77.8D0,  64.9D0,  35.7D0,  21.2D0,  11.1D0,   5.7D0/
      DATA   Z(235),  Z(236),  Z(237),  Z(238),  Z(239),  Z(240)
     +    /  8.7D0,  36.1D0,  79.7D0, 114.4D0, 109.6D0,  88.8D0/
      DATA   Z(241),  Z(242),  Z(243),  Z(244),  Z(245),  Z(246)
     +    / 67.8D0,  47.5D0,  30.6D0,  16.3D0,   9.6D0,  33.2D0/
      DATA   Z(247),  Z(248),  Z(249),  Z(250),  Z(251),  Z(252)
     +    / 92.6D0, 151.6D0, 136.3D0, 134.7D0,  83.9D0,  69.4D0/
      DATA   Z(253),  Z(254),  Z(255),  Z(256),  Z(257),  Z(258)
     +    / 31.5D0,  13.9D0,   4.4D0,  38.0D0, 141.7D0, 190.2D0/
      DATA   Z(259),  Z(260),  Z(261)
     +    /184.8D0, 159.0D0, 112.3D0/
C
      ITEST = 1
C
C     MAKE CALLS WITH VALID DATA
C
      NY = 50
      NZ = 261
      NFFT = 514
      NPRT = 2
      LZFFT = 600
      LPER = 514
      LPERI = 514
      TAPERP = 0.10D0
      LFREQ = 300
      IEXTND = 0
      LAB = 600
      NK = 3
      K(1) = 8
      K(2) = 8
      K(3) = 8
C
      CALL IPRINT(IPRT)
C
C     TEST OF CENTER
C
    5 WRITE (IPRT, 1018)
      CALL CENTER (Z, NZ, ZT)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VARIABLES FROM CENTER
C
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (ZT(I), I = 1, NZ)
C
C     TEST OF TAPER
C
      WRITE (IPRT, 1015)
      CALL TAPER (Z, NZ, TAPERP, ZT)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VARIABLES FROM TAPER
C
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (ZT(I), I = 1, NZ)
C
C     TEST OF PGM
C
      WRITE (IPRT, 1013)
      CALL DCOPY (NZ, ZT, 1, ZFFT, 1)
      CALL PGM (ZFFT, NZ, LZFFT, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF FFTLEN
C
      WRITE (IPRT, 1026)
      CALL FFTLEN(NFFT-2, 2, NTEMP)
      WRITE(IPRT, 1002) IERR
C
C     PRINT RETURNED VARIABLES FROM FFTLEN
C
      IF (IERR.EQ.0) WRITE (IPRT, 1027) NTEMP
C
C     TEST OF PGMS
C
      NTEMP = NFFT-1
      WRITE (IPRT, 1025)
      CALL DCOPY (NZ, ZT, 1, ZFFT, 1)
      CALL PGMS (ZFFT, NZ, NTEMP, LZFFT, IEXTND, NF, PER, LPER, FREQ,
     +   LFREQ, -2)
      WRITE (IPRT, 1027) NTEMP
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VARIABLES FROM PGMS
C
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
        WRITE (IPRT, 1004) (PER(I), I = 1, NF)
      END IF
C
C     TEST OF MDFLT
C
      WRITE (IPRT, 1016)
      CALL MDFLT (PER, NF, NK, K, PERF, LDSTAK)
      WRITE (IPRT, 1002) IERR
      IF (IERR.EQ.0) THEN
C
C       PRINT RETURNED VARIABLES FROM MDFLT
C
        WRITE (IPRT, 1004) (PERF(I), I = 1, NF)
C
C       DISPLAY SMOOTHED PERIODOGRAM ON A LOG PLOT
C
        WRITE (IPRT, 1028)
        CALL PPL (PERF, FREQ, NF, 1)
      END IF
C
C     TEST OF IPGMP
C
      WRITE (IPRT, 1029)
      CALL IPGMP (PER, FREQ, NF, NZ, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF IPGMPS
C
      WRITE (IPRT, 1030)
      CALL IPGMPS (PER, FREQ, NF, NZ, LDSTAK, PERI, NPRT)
      WRITE (IPRT, 1002) IERR
      IF (IERR.EQ.0) THEN
C
C     PRINT RETURNED VARIABLES FROM IPGMPS
C
         WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
         WRITE (IPRT, 1004) (PERI(I), I = 1, NF)
      END IF
C
C     TEST OF IPGM
C
      WRITE (IPRT, 1017)
      CALL DCOPY (NZ, ZT, 1, ZFFT, 1)
      CALL IPGM (ZFFT, NZ, LZFFT, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF IPGMS
C
      WRITE (IPRT, 1014)
      CALL DCOPY (NZ, ZT, 1, ZFFT, 1)
      CALL IPGMS (ZFFT, NZ, LZFFT, LDSTAK, NF, PERI, LPERI, FREQ, LFREQ,
     +   NPRT)
      WRITE (IPRT, 1002) IERR
      IF (IERR.EQ.0) THEN
C
C     PRINT RETURNED VARIABLES FROM IPGMS
C
         WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
         WRITE (IPRT, 1004) (PERI(I), I = 1, NF)
      END IF
C
C     TEST OF FFTR (CENTERED DATA - O PERCENT TAPER)
C
      TAPERP = -1.0D0
      WRITE (IPRT, 1031)
      IF (NY.GE.1) CALL TAPER (Y, NY, TAPERP, YFFT)
      CALL FFTR (YFFT, NY, NFFT, IEXTND, NF, AB, LAB)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VARIABLES FROM FFTR
C
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (AB(I), I = 1, NF)
C
      GO TO (10, 20, 30, 40) ITEST
C
C     CHECK MINIMUM PROBLEM SIZE
C
   10 ITEST = ITEST + 1
      NZ = 17
      NY = 17
      GO TO 5
C
C     CHECK VARIOUS OPTIONS
C
   20 ITEST = ITEST + 1
C
C     TEST OF MDFLT (ELEMENTS OF K NOT EVEN)
C
      K(1) = 7
      WRITE (IPRT, 1016)
      CALL MDFLT (PER, NF, NK, K, PERF, LDSTAK)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VARIABLES FROM MDFLT
C
      WRITE (IPRT, 1004) (PERF(I), I = 1, NF)
C
C     TEST OF PGMS (UNCENTERED DATA)
C
      IEXTND = 1
      NPRT = 1
      WRITE (IPRT, 1025)
      CALL DCOPY (NZ, Z, 1, ZFFT, 1)
      CALL PGMS (ZFFT, NZ, NFFT, LZFFT, IEXTND, NF, PER, LPER, FREQ,
     +   LFREQ, NPRT)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VARIABLES FROM PGMS
C
      WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
      WRITE (IPRT, 1004) (PER(I), I = 1, NF)
C
      NPRT = 2
      WRITE (IPRT, 1025)
      CALL DCOPY (NZ, Z, 1, ZFFT, 1)
      CALL PGMS (ZFFT, NZ, NFFT, LZFFT, IEXTND, NF, PER, LPER, FREQ,
     +   LFREQ, NPRT)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VARIABLES FROM PGMS
C
      WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
      WRITE (IPRT, 1004) (PER(I), I = 1, NF)
C
C     TEST OF FFTR (CENTERED DATA - 100 PERCENT TAPER)
C
      TAPERP = 1.1D0
      WRITE (IPRT, 1031)
      CALL TAPER (Y, NY, TAPERP, YFFT)
      CALL FFTR (YFFT, NY, NFFT, IEXTND, NF, AB, LAB)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VARIABLES FROM FFTR
C
      WRITE (IPRT, 1004) (AB(I), I = 1, NF)
C
C     TEST OF FFTR (CENTERED DATA - O PERCENT TAPER)
C
      TAPERP = -1.0D0
      WRITE (IPRT, 1031)
      CALL TAPER (Y, NY, TAPERP, YFFT)
      CALL FFTR (YFFT, NY, NFFT-1, IEXTND, NF, AB, NFFT-2)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VARIABLES FROM FFTR
C
      WRITE (IPRT, 1004) (AB(I), I = 1, NF)
C
C     PERFORM ERROR CHECKING
C
      NY = -1
      NZ = -1
      NFFT = 0
      NPRT = 2
      LZFFT = 0
      LPER = 0
      LPERI = 0
      TAPERP = 0.10D0
      LFREQ = 0
      IEXTND = 0
      LAB = 0
      NK = 0
      K(1) = 0
      K(2) = 0
      K(3) = 0
      GO TO 5
C
C     PERFORM MORE ERROR CHECKING
C
   30 ITEST = ITEST + 1
      NY = 50
      NZ = 261
      NPRT = 2
      LZFFT = 0
      LPER = 0
      LPERI = 0
      TAPERP = 0.10D0
      LFREQ = 0
      IEXTND = 0
      LAB = 0
      NK = 3
      K(1) = 0
      K(2) = 0
      K(3) = 0
      GO TO 5
C
   40 RETURN
C
C     FORMAT STATEMENTS
C
 1002 FORMAT (8H IERR IS, I5)
 1004 FORMAT (3(1X, E16.8))
 1013 FORMAT ('1', 11HTEST OF PGM)
 1014 FORMAT ('1', 13HTEST OF IPGMS)
 1015 FORMAT ('1', 13HTEST OF TAPER)
 1016 FORMAT ('1', 13HTEST OF MDFLT)
 1017 FORMAT ('1', 12HTEST OF IPGM)
 1018 FORMAT ('1', 14HTEST OF CENTER)
 1025 FORMAT ('1', 12HTEST OF PGMS)
 1026 FORMAT ('1', 14HTEST OF FFTLEN)
 1027 FORMAT (/8H NFFT IS, I6)
 1028 FORMAT ('1', 45HDISPLAY OF PERIODOGRAM SMOOTHED WITH MODIFIED,
     +   14H DANIEL FILTER)
 1029 FORMAT ('1', 13HTEST OF IPGMP)
 1030 FORMAT ('1', 14HTEST OF IPGMPS)
 1031 FORMAT ('1', 12HTEST OF FFTR)
      END
*XPP
      SUBROUTINE XPP(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST THE PLOTTING SUBROUTINES
C
C     SERIES Y IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND
C     JENKINS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YMISS,YUB
      INTEGER
     +   ILOG,IPRT,ISIZE,ITEST,IYM,M,NOUT,NY,NYM
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AIR(144),TIME(144),X(144),Y(144),YM(12,12),YMMISS(144)
      INTEGER
     +   ISYM(144)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,MPP,MPPC,MPPL,MPPM,MPPMC,MPPML,PP,PPC,PPL,PPM,
     +   PPMC,PPML,DCOPY,SETRV,SPP,SPPC,SPPL,SPPM,SPPMC,SPPML
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (Y(1),YM(1,1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AIR(144)
C        THE AIRLINE DATA.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(144)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER ITEST
C        THE NUMBER OF THE TEST.
C     INTEGER IYM
C        ACTUAL DIMENSION OF YM IN USERS MAIN PROGRAM
C     INTEGER LDSTAK
C        *
C     INTEGER M
C        THE NUMBER OF VECTORS IN YM
C     INTEGER NOUT
C        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
C        OF THE PLOT ARE TO BE LISTED.
C     INTEGER NY, NYM
C        THE NUMBER OF OBSERVATIONS IN ARRAYS Y AND YM, RESPECTIVELY.
C     DOUBLE PRECISION TIME(144)
C        THE TIME VALUES FOR THE AIRLINE DATA.
C     DOUBLE PRECISION X(144)
C        VECTOR OF OBSERVATIONS FOR X(HORIZONTAL) COORDINATES
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION XMISS
C        THE MISSING VALUE CODE FOR THE X-AXIS.
C     DOUBLE PRECISION XUB
C        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION Y(144)
C        VECTOR OF OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(12,12)
C        MULTIVARIATE OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES.
C     DOUBLE PRECISION YMISS
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YMMISS(144)
C        THE MISSING VALUE CODES FOR EACH COLUMN OF YM.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
      DATA     XMISS,    YMISS
     +    /      7.0D0,    180.0D0/
C
      DATA ISYM(  1),ISYM(  2),ISYM(  3),ISYM(  4),ISYM(  5),ISYM(  6)
     +    /    -5000,     6000,        7,        8,        9,       10/
      DATA ISYM(  7),ISYM(  8),ISYM(  9),ISYM( 10),ISYM( 11),ISYM( 12)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 13),ISYM( 14),ISYM( 15),ISYM( 16),ISYM( 17),ISYM( 18)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 19),ISYM( 20),ISYM( 21),ISYM( 22),ISYM( 23),ISYM( 24)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 25),ISYM( 26),ISYM( 27),ISYM( 28),ISYM( 29),ISYM( 30)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 31),ISYM( 32),ISYM( 33),ISYM( 34),ISYM( 35),ISYM( 36)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 37),ISYM( 38),ISYM( 39),ISYM( 40),ISYM( 41),ISYM( 42)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 43),ISYM( 44),ISYM( 45),ISYM( 46),ISYM( 47),ISYM( 48)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 49),ISYM( 50),ISYM( 51),ISYM( 52),ISYM( 53),ISYM( 54)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 55),ISYM( 56),ISYM( 57),ISYM( 58),ISYM( 59),ISYM( 60)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 61),ISYM( 62),ISYM( 63),ISYM( 64),ISYM( 65),ISYM( 66)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 67),ISYM( 68),ISYM( 69),ISYM( 70),ISYM( 71),ISYM( 72)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 73),ISYM( 74),ISYM( 75),ISYM( 76),ISYM( 77),ISYM( 78)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 79),ISYM( 80),ISYM( 81),ISYM( 82),ISYM( 83),ISYM( 84)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 85),ISYM( 86),ISYM( 87),ISYM( 88),ISYM( 89),ISYM( 90)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 91),ISYM( 92),ISYM( 93),ISYM( 94),ISYM( 95),ISYM( 96)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 97),ISYM( 98),ISYM( 99),ISYM(100),ISYM(101),ISYM(102)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM(103),ISYM(104),ISYM(105),ISYM(106),ISYM(107),ISYM(108)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM(109),ISYM(110),ISYM(111),ISYM(112),ISYM(113),ISYM(114)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM(115),ISYM(116),ISYM(117),ISYM(118),ISYM(119),ISYM(120)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM(121),ISYM(122),ISYM(123),ISYM(124),ISYM(125),ISYM(126)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM(127),ISYM(128),ISYM(129),ISYM(130),ISYM(131),ISYM(132)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM(133),ISYM(134),ISYM(135),ISYM(136),ISYM(137),ISYM(138)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM(139),ISYM(140),ISYM(141),ISYM(142),ISYM(143),ISYM(144)
     +    /       11,       12,       13,       14,       15,       16/
C
      DATA TIME(  1),TIME(  2),TIME(  3),TIME(  4),TIME(  5),TIME(  6)
     +    /   1.0D0,    2.0D0,    3.0D0,    4.0D0,    5.0D0,    6.0D0/
      DATA TIME(  7),TIME(  8),TIME(  9),TIME( 10),TIME( 11),TIME( 12)
     +    /   7.0D0,    8.0D0,    9.0D0,   10.0D0,   11.0D0,   12.0D0/
      DATA TIME( 13),TIME( 14),TIME( 15),TIME( 16),TIME( 17),TIME( 18)
     +    /  13.0D0,   14.0D0,   15.0D0,   16.0D0,   17.0D0,   18.0D0/
      DATA TIME( 19),TIME( 20),TIME( 21),TIME( 22),TIME( 23),TIME( 24)
     +    /  19.0D0,   20.0D0,   21.0D0,   22.0D0,   23.0D0,   24.0D0/
      DATA TIME( 25),TIME( 26),TIME( 27),TIME( 28),TIME( 29),TIME( 30)
     +    /  25.0D0,   26.0D0,   27.0D0,   28.0D0,   29.0D0,   30.0D0/
      DATA TIME( 31),TIME( 32),TIME( 33),TIME( 34),TIME( 35),TIME( 36)
     +    /  31.0D0,   32.0D0,   33.0D0,   34.0D0,   35.0D0,   36.0D0/
      DATA TIME( 37),TIME( 38),TIME( 39),TIME( 40),TIME( 41),TIME( 42)
     +    /  37.0D0,   38.0D0,   39.0D0,   40.0D0,   41.0D0,   42.0D0/
      DATA TIME( 43),TIME( 44),TIME( 45),TIME( 46),TIME( 47),TIME( 48)
     +    /  43.0D0,   44.0D0,   45.0D0,   46.0D0,   47.0D0,   48.0D0/
      DATA TIME( 49),TIME( 50),TIME( 51),TIME( 52),TIME( 53),TIME( 54)
     +    /  49.0D0,   50.0D0,   51.0D0,   52.0D0,   53.0D0,   54.0D0/
      DATA TIME( 55),TIME( 56),TIME( 57),TIME( 58),TIME( 59),TIME( 60)
     +    /  55.0D0,   56.0D0,   57.0D0,   58.0D0,   59.0D0,   60.0D0/
      DATA TIME( 61),TIME( 62),TIME( 63),TIME( 64),TIME( 65),TIME( 66)
     +    /  61.0D0,   62.0D0,   63.0D0,   64.0D0,   65.0D0,   66.0D0/
      DATA TIME( 67),TIME( 68),TIME( 69),TIME( 70),TIME( 71),TIME( 72)
     +    /  67.0D0,   68.0D0,   69.0D0,   70.0D0,   71.0D0,   72.0D0/
      DATA TIME( 73),TIME( 74),TIME( 75),TIME( 76),TIME( 77),TIME( 78)
     +    /  73.0D0,   74.0D0,   75.0D0,   76.0D0,   77.0D0,   78.0D0/
      DATA TIME( 79),TIME( 80),TIME( 81),TIME( 82),TIME( 83),TIME( 84)
     +    /  79.0D0,   80.0D0,   81.0D0,   82.0D0,   83.0D0,   84.0D0/
      DATA TIME( 85),TIME( 86),TIME( 87),TIME( 88),TIME( 89),TIME( 90)
     +    /  85.0D0,   86.0D0,   87.0D0,   88.0D0,   89.0D0,   90.0D0/
      DATA TIME( 91),TIME( 92),TIME( 93),TIME( 94),TIME( 95),TIME( 96)
     +    /  91.0D0,   92.0D0,   93.0D0,   94.0D0,   95.0D0,   96.0D0/
      DATA TIME( 97),TIME( 98),TIME( 99),TIME(100),TIME(101),TIME(102)
     +    /  97.0D0,   98.0D0,   99.0D0,  100.0D0,  101.0D0,  102.0D0/
      DATA TIME(103),TIME(104),TIME(105),TIME(106),TIME(107),TIME(108)
     +    / 103.0D0,  104.0D0,  105.0D0,  106.0D0,  107.0D0,  108.0D0/
      DATA TIME(109),TIME(110),TIME(111),TIME(112),TIME(113),TIME(114)
     +    / 109.0D0,  110.0D0,  111.0D0,  112.0D0,  113.0D0,  114.0D0/
      DATA TIME(115),TIME(116),TIME(117),TIME(118),TIME(119),TIME(120)
     +    / 115.0D0,  116.0D0,  117.0D0,  118.0D0,  119.0D0,  120.0D0/
      DATA TIME(121),TIME(122),TIME(123),TIME(124),TIME(125),TIME(126)
     +    / 121.0D0,  122.0D0,  123.0D0,  124.0D0,  125.0D0,  126.0D0/
      DATA TIME(127),TIME(128),TIME(129),TIME(130),TIME(131),TIME(132)
     +    / 127.0D0,  128.0D0,  129.0D0,  130.0D0,  131.0D0,  132.0D0/
      DATA TIME(133),TIME(134),TIME(135),TIME(136),TIME(137),TIME(138)
     +    / 133.0D0,  134.0D0,  135.0D0,  136.0D0,  137.0D0,  138.0D0/
      DATA TIME(139),TIME(140),TIME(141),TIME(142),TIME(143),TIME(144)
     +    / 139.0D0,  140.0D0,  141.0D0,  142.0D0,  143.0D0,  144.0D0/
C
      DATA  AIR(  1), AIR(  2), AIR(  3), AIR(  4), AIR(  5), AIR(  6)
     +    / 112.0D0,  118.0D0,  132.0D0,  129.0D0,  121.0D0,  135.0D0/
      DATA  AIR(  7), AIR(  8), AIR(  9), AIR( 10), AIR( 11), AIR( 12)
     +    / 148.0D0,  148.0D0,  136.0D0,  119.0D0,  104.0D0,  118.0D0/
      DATA  AIR( 13), AIR( 14), AIR( 15), AIR( 16), AIR( 17), AIR( 18)
     +    / 115.0D0,  126.0D0,  141.0D0,  135.0D0,  125.0D0,  149.0D0/
      DATA  AIR( 19), AIR( 20), AIR( 21), AIR( 22), AIR( 23), AIR( 24)
     +    / 170.0D0,  170.0D0,  158.0D0,  133.0D0,  114.0D0,  140.0D0/
      DATA  AIR( 25), AIR( 26), AIR( 27), AIR( 28), AIR( 29), AIR( 30)
     +    / 145.0D0,  150.0D0,  178.0D0,  163.0D0,  172.0D0,  178.0D0/
      DATA  AIR( 31), AIR( 32), AIR( 33), AIR( 34), AIR( 35), AIR( 36)
     +    / 199.0D0,  199.0D0,  184.0D0,  162.0D0,  146.0D0,  166.0D0/
      DATA  AIR( 37), AIR( 38), AIR( 39), AIR( 40), AIR( 41), AIR( 42)
     +    / 171.0D0,  180.0D0,  193.0D0,  181.0D0,  183.0D0,  218.0D0/
      DATA  AIR( 43), AIR( 44), AIR( 45), AIR( 46), AIR( 47), AIR( 48)
     +    / 230.0D0,  242.0D0,  209.0D0,  191.0D0,  172.0D0,  194.0D0/
      DATA  AIR( 49), AIR( 50), AIR( 51), AIR( 52), AIR( 53), AIR( 54)
     +    / 196.0D0,  196.0D0,  236.0D0,  235.0D0,  229.0D0,  243.0D0/
      DATA  AIR( 55), AIR( 56), AIR( 57), AIR( 58), AIR( 59), AIR( 60)
     +    / 264.0D0,  272.0D0,  237.0D0,  211.0D0,  180.0D0,  201.0D0/
      DATA  AIR( 61), AIR( 62), AIR( 63), AIR( 64), AIR( 65), AIR( 66)
     +    / 204.0D0,  188.0D0,  235.0D0,  227.0D0,  234.0D0,  264.0D0/
      DATA  AIR( 67), AIR( 68), AIR( 69), AIR( 70), AIR( 71), AIR( 72)
     +    / 302.0D0,  293.0D0,  259.0D0,  229.0D0,  203.0D0,  229.0D0/
      DATA  AIR( 73), AIR( 74), AIR( 75), AIR( 76), AIR( 77), AIR( 78)
     +    / 242.0D0,  233.0D0,  267.0D0,  269.0D0,  270.0D0,  315.0D0/
      DATA  AIR( 79), AIR( 80), AIR( 81), AIR( 82), AIR( 83), AIR( 84)
     +    / 364.0D0,  347.0D0,  312.0D0,  274.0D0,  237.0D0,  278.0D0/
      DATA  AIR( 85), AIR( 86), AIR( 87), AIR( 88), AIR( 89), AIR( 90)
     +    / 284.0D0,  277.0D0,  317.0D0,  313.0D0,  318.0D0,  374.0D0/
      DATA  AIR( 91), AIR( 92), AIR( 93), AIR( 94), AIR( 95), AIR( 96)
     +    / 413.0D0,  405.0D0,  355.0D0,  306.0D0,  271.0D0,  306.0D0/
      DATA  AIR( 97), AIR( 98), AIR( 99), AIR(100), AIR(101), AIR(102)
     +    / 315.0D0,  301.0D0,  356.0D0,  348.0D0,  355.0D0,  422.0D0/
      DATA  AIR(103), AIR(104), AIR(105), AIR(106), AIR(107), AIR(108)
     +    / 465.0D0,  467.0D0,  404.0D0,  347.0D0,  305.0D0,  336.0D0/
      DATA  AIR(109), AIR(110), AIR(111), AIR(112), AIR(113), AIR(114)
     +    / 340.0D0,  318.0D0,  362.0D0,  348.0D0,  363.0D0,  435.0D0/
      DATA  AIR(115), AIR(116), AIR(117), AIR(118), AIR(119), AIR(120)
     +    / 491.0D0,  505.0D0,  404.0D0,  359.0D0,  310.0D0,  337.0D0/
      DATA  AIR(121), AIR(122), AIR(123), AIR(124), AIR(125), AIR(126)
     +    / 360.0D0,  342.0D0,  406.0D0,  396.0D0,  420.0D0,  472.0D0/
      DATA  AIR(127), AIR(128), AIR(129), AIR(130), AIR(131), AIR(132)
     +    / 548.0D0,  559.0D0,  463.0D0,  407.0D0,  362.0D0,  405.0D0/
      DATA  AIR(133), AIR(134), AIR(135), AIR(136), AIR(137), AIR(138)
     +    / 417.0D0,  391.0D0,  419.0D0,  461.0D0,  472.0D0,  535.0D0/
      DATA  AIR(139), AIR(140), AIR(141), AIR(142), AIR(143), AIR(144)
     +    / 622.0D0,  606.0D0,  508.0D0,  461.0D0,  390.0D0,  432.0D0/
C
      CALL SETRV(YMMISS, 144, YMISS)
      CALL DCOPY(144, AIR, 1, Y, 1)
      CALL DCOPY(144, TIME, 1, X, 1)
C
C     DEFINE CONSTANTS
C
      CALL IPRINT(IPRT)
C
C     COMMENCE BODY OF ROUTINE
C
      ITEST = 0
C
C     SHORT CALLS
C
      NY = 144
      NYM = 12
      IYM = 12
      M = 12
      ILOG = -1
      ISIZE = -1
      NOUT = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
C
   10 CONTINUE
C
C     TEST OF PP
C
      WRITE(IPRT, 1000)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      CALL PP(Y, X, NY)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF PPM
C
      WRITE(IPRT, 1030)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      CALL PPM(Y, YMISS, X, XMISS, NY)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF SPP
C
      WRITE(IPRT, 1120)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      CALL SPP(Y, X, NY, ISYM)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF SPPM
C
      WRITE(IPRT, 1150)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      CALL SPPM(Y, YMISS, X, XMISS, NY, ISYM)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF MPP
C
      WRITE(IPRT, 1060)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      CALL MPP(YM, X, NYM, M, IYM)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF MPPM
C
      WRITE(IPRT, 1090)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      CALL MPPM(YM, YMMISS, X, XMISS, NYM, M, IYM)
      WRITE (IPRT, 3000) IERR
C
C
C     LOG OPTION CALLS
C
C
   20 CONTINUE
C
C     TEST OF PPL
C
      WRITE(IPRT, 1010)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3040) ILOG
      CALL PPL(Y, X, NY, ILOG)
C
      WRITE (IPRT, 3000) IERR
C
C     TEST OF PPML
C
      WRITE(IPRT, 1040)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3040) ILOG
      CALL PPML(Y, YMISS, X, XMISS, NY, ILOG)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF SPPL
C
      WRITE(IPRT, 1130)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3040) ILOG
      CALL SPPL(Y, X, NY, ISYM, ILOG)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF SPPML
C
      WRITE(IPRT, 1160)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3040) ILOG
      CALL SPPML(Y, YMISS, X, XMISS, NY, ISYM, ILOG)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF MPPL
C
      WRITE(IPRT, 1070)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3040) ILOG
      CALL MPPL(YM, X, NYM, M, IYM, ILOG)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF MPPML
C
      WRITE(IPRT, 1100)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3040) ILOG
      CALL MPPML(YM, YMMISS, X, XMISS, NYM, M, IYM, ILOG)
      WRITE (IPRT, 3000) IERR
C
C
C     TEST OF LONG CALLS
C
C
   30 CONTINUE
C
C     TEST OF PPC
C
      WRITE(IPRT, 1020)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3050) ISIZE, NOUT
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3080) XUB
      CALL PPC(Y, X, NY, ILOG, ISIZE, NOUT, YLB, YUB, XLB, XUB)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF PPMC
C
      WRITE(IPRT, 1050)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3050) ISIZE, NOUT
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3080) XUB
      CALL PPMC(Y, YMISS, X, XMISS, NY, ILOG, ISIZE, NOUT, YLB, YUB,
     +   XLB, XUB)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF SPPC
C
      WRITE(IPRT, 1140)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3050) ISIZE, NOUT
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3080) XUB
      CALL SPPC(Y, X, NY, ISYM, ILOG, ISIZE, NOUT, YLB, YUB, XLB,
     +   XUB)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF SPPMC
C
      WRITE(IPRT, 1170)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3050) ISIZE, NOUT
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3080) XUB
      CALL SPPMC(Y, YMISS, X, XMISS, NY, ISYM, ILOG, ISIZE, NOUT,
     +   YLB, YUB, XLB, XUB)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF MPPC
C
   40 WRITE(IPRT, 1080)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3050) ISIZE, NOUT
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3080) XUB
      CALL MPPC(YM, X, NYM, M, IYM, ILOG, ISIZE, NOUT, YLB, YUB,
     +   XLB, XUB)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF MPPMC
C
   50 WRITE(IPRT, 1110)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3050) ISIZE, NOUT
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3080) XUB
      CALL MPPMC(YM, YMMISS, X, XMISS, NYM, M, IYM, ILOG, ISIZE, NOUT,
     +   YLB, YUB, XLB, XUB)
      WRITE (IPRT, 3000) IERR
C
      ITEST = ITEST + 1
C
      GO TO (110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 300),
     +  ITEST
C
C     TEST VALID OPTIONS
C
  110 ILOG = 0
      ISIZE = 0
      NOUT = 0
      YLB = 100.0D0
      YUB = 700.0D0
      XLB = 4.0D0
      XUB = 16.0D0
      GO TO 20
C
  120 ILOG = 2
      ISIZE = 2
      NOUT = 5
      GO TO 20
C
  130 ILOG = 20
      ISIZE = 20
      NOUT = 55
      YUB = 300.0D0
      GO TO 30
C
  140 ILOG = 22
      ISIZE = 22
      GO TO 40
C
  150 NY = 1
      NYM = 1
      M = 144
      IYM = 1
      X(1) = 10.0D0
      GO TO 40
C
  160 CALL SETRV(Y, 144, 1.0D0)
      CALL SETRV(X, 144, 1.0D0)
      NYM = 6
      IYM = 12
      M = 6
      NY = 36
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      GO TO 30
C
C     TEST ERROR RESPONSE
C
  170 NY = 0
      NYM = 0
      M = 0
      IYM = -1
      GO TO 10
C
  180 NY = 144
      NYM = 12
      M = 12
      IYM = -1
      XLB = -1.0D0
      YLB = -1.0D0
      GO TO 40
C
  190 IYM = 12
      X(1) = 0.0D0
      Y(1) = 0.0D0
      GO TO 50
C
  200 CALL SETRV(X, 144, XMISS)
      CALL SETRV(Y, 144, YMISS)
      XLB = XUB
      YLB = YUB
      GO TO 50
C
  300 CONTINUE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT ('1', 10HTEST OF PP)
 1010 FORMAT ('1', 11HTEST OF PPL)
 1020 FORMAT ('1', 11HTEST OF PPC)
 1030 FORMAT ('1', 11HTEST OF PPM)
 1040 FORMAT ('1', 12HTEST OF PPML)
 1050 FORMAT ('1', 12HTEST OF PPMC)
 1060 FORMAT ('1', 11HTEST OF MPP)
 1070 FORMAT ('1', 12HTEST OF MPPL)
 1080 FORMAT ('1', 12HTEST OF MPPC)
 1090 FORMAT ('1', 12HTEST OF MPPM)
 1100 FORMAT ('1', 13HTEST OF MPPML)
 1110 FORMAT ('1', 13HTEST OF MPPMC)
 1120 FORMAT ('1', 11HTEST OF SPP)
 1130 FORMAT ('1', 12HTEST OF SPPL)
 1140 FORMAT ('1', 12HTEST OF SPPC)
 1150 FORMAT ('1', 12HTEST OF SPPM)
 1160 FORMAT ('1', 13HTEST OF SPPML)
 1170 FORMAT ('1', 13HTEST OF SPPMC)
 3000 FORMAT (/8H IERR = , I4)
 3010 FORMAT (' ', 5X, 10H   N     =, I5)
 3020 FORMAT ('+', 20X, 10H / M     =, I5, 10H / IYM   =, I5)
 3040 FORMAT ('+', 65X, 10H / ILOG  =, I5)
 3050 FORMAT (' ',  5X, 10H   ISIZE =, I5, 10H / NOUT  =, I5)
 3070 FORMAT ('+', 50X, 10H / YLB   =, F10.4, 10H / YUB   =, F10.4,
     +   10H / XLB   =, F10.4)
 3080 FORMAT ('+', 110X, 10H / XUB   =, F10.4)
 3100 FORMAT (' ', 13H TEST NUMBER , I5)
      END
*XSTAT
      SUBROUTINE XSTAT(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS PROGRAM TESTS FEATURES OF THE STAT FAMILY TO ENSURE THAT
C     ALL ASPECTS OF THE STAT FAMILY ROUTINES WORK CORRECTLY.
C
C     WRITTEN BY  -  JOHN E. KOONTZ AND JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  MAY 17, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM,WTEMP,YTEMP1,YTEMPN
      INTEGER
     +   I,IPRT,N,NCONST,NPRTOF,NPRTON
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   STS(53),WT(84),WTALL0(10),WTALL1(84),Y(84),YCONST(10),
     +   YPATH(10)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,STAT,STATS,STATW,STATWS
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FPLM
C        THE FLOATING POINT LARGEST MAGNITUDE.
C     INTEGER I
C        A LOOP INDEX.
C     INTEGER IERR
C        FLAG TO INDICATE PRESENCE OF ERROR DETECTED BY PRECEDING
C        STARPAC CALL.  (0 IS OK, 1 IS ERROR)
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT.
C     INTEGER LDSTAK
C        AMOUNT OF WORK AREA.  SIZE OF DSTAK.
C     INTEGER N
C        THE LENGTH OF THE VECTOR Y.
C     INTEGER NCONST
C        LENGTH OF THE VECTOR YCONST.
C     INTEGER NPRTOF
C        FLAG FOR NO OUTPUT (EXCEPT ERROR MESSAGES).
C     INTEGER NPRTON
C        FLAG FOR FULL PRINTOUT.
C     DOUBLE PRECISION STS(53)
C        VECTOR OF STATISTICS.
C     DOUBLE PRECISION WT(84)
C        WEIGHTS VECTOR.
C     DOUBLE PRECISION WTALL0(10)
C        N VECTOR OF 0 WEIGHTS.
C     DOUBLE PRECISION WTALL1(84)
C        N VECTOR OF 1 WEIGHTS.
C     DOUBLE PRECISION WTEMP
C        TEMPORARY STORAGE FOR ONE OF THE WEIGHTS.
C     DOUBLE PRECISION Y(84)
C        DATA VECTOR FOR TESTS.
C     DOUBLE PRECISION YCONST(10)
C        VECTOR OF CONSTANT DATA.
C     DOUBLE PRECISION YPATH(10)
C        A VECTOR OF Y VALUES DESIGNED TO FORCE DIFFERENT PATHS
C        THROUGH THE SUMMATION ROUTINES.
C     DOUBLE PRECISION YTEMPN, YTEMP1
C        TEMPORARY STORAGE FOR THE FIRST AND LAST Y VALUE.
C
C     DATA INITIALIZATIONS.
C
      DATA N /84/
      DATA NCONST /10/
      DATA NPRTON /1/
      DATA NPRTOF /0/
C
C     DAVIS-HARRISON R.H. DATA, PIKES PEAK.
C
C     THIS IS AN ARBITRARILY CHOSEN DATA SET.
C
      DATA Y( 1), Y( 2), Y( 3), Y( 4)
     +    / 0.6067D0, 0.6087D0, 0.6086D0, 0.6134D0/
      DATA Y( 5), Y( 6), Y( 7)
     +    / 0.6108D0, 0.6138D0, 0.6125D0/
      DATA Y( 8), Y( 9), Y(10), Y(11)
     +    / 0.6122D0, 0.6110D0, 0.6104D0, 0.7213D0/
      DATA Y(12), Y(13), Y(14)
     +    / 0.7078D0, 0.7021D0, 0.7004D0/
      DATA Y(15), Y(16), Y(17), Y(18)
     +    / 0.6981D0, 0.7242D0, 0.7268D0, 0.7418D0/
      DATA Y(19), Y(20), Y(21)
     +    / 0.7407D0, 0.7199D0, 0.6225D0/
      DATA Y(22), Y(23), Y(24), Y(25)
     +    / 0.6254D0, 0.6252D0, 0.6267D0, 0.6218D0/
      DATA Y(26), Y(27), Y(28)
     +    / 0.6178D0, 0.6216D0, 0.6192D0/
      DATA Y(29), Y(30), Y(31), Y(32)
     +    / 0.6191D0, 0.6250D0, 0.6188D0, 0.6233D0/
      DATA Y(33), Y(34), Y(35)
     +    / 0.6225D0, 0.6204D0, 0.6207D0/
      DATA Y(36), Y(37), Y(38), Y(39)
     +    / 0.6168D0, 0.6141D0, 0.6291D0, 0.6231D0/
      DATA Y(40), Y(41), Y(42)
     +    / 0.6222D0, 0.6252D0, 0.6308D0/
      DATA Y(43), Y(44), Y(45), Y(46)
     +    / 0.6376D0, 0.6330D0, 0.6303D0, 0.6301D0/
      DATA Y(47), Y(48), Y(49)
     +    / 0.6390D0, 0.6423D0, 0.6300D0/
      DATA Y(50), Y(51), Y(52), Y(53)
     +    / 0.6260D0, 0.6292D0, 0.6298D0, 0.6290D0/
      DATA Y(54), Y(55), Y(56)
     +    / 0.6262D0, 0.5952D0, 0.5951D0/
      DATA Y(57), Y(58), Y(59), Y(60)
     +    / 0.6314D0, 0.6440D0, 0.6439D0, 0.6326D0/
      DATA Y(61), Y(62), Y(63)
     +    / 0.6392D0, 0.6417D0, 0.6412D0/
      DATA Y(64), Y(65), Y(66), Y(67)
     +    / 0.6530D0, 0.6411D0, 0.6355D0, 0.6344D0/
      DATA Y(68), Y(69), Y(70)
     +    / 0.6623D0, 0.6276D0, 0.6307D0/
      DATA Y(71), Y(72), Y(73), Y(74)
     +    / 0.6354D0, 0.6197D0, 0.6153D0, 0.6340D0/
      DATA Y(75), Y(76), Y(77)
     +    / 0.6338D0, 0.6284D0, 0.6162D0/
      DATA Y(78), Y(79), Y(80), Y(81)
     +    / 0.6252D0, 0.6349D0, 0.6344D0, 0.6361D0/
      DATA Y(82), Y(83), Y(84)
     +    / 0.6373D0, 0.6337D0, 0.6383D0/
      DATA WT( 1), WT( 2), WT( 3), WT( 4), WT( 5), WT( 6), WT( 7)
     +   / 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0/
      DATA WT( 8), WT( 9), WT(10), WT(11), WT(12), WT(13), WT(14)
     +   / 0.5D0, 0.5D0, 0.5D0, 0.0D0, 0.0D0, 0.0D0, 0.0D0/
      DATA WT(15), WT(16), WT(17), WT(18), WT(19), WT(20), WT(21)
     +   / 0.0D0, 0.0D0, 0.0D0, 0.0D0, 0.0D0, 0.0D0, 0.5D0/
      DATA WT(22), WT(23), WT(24), WT(25), WT(26), WT(27), WT(28)
     +   / 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0/
      DATA WT(29), WT(30), WT(31), WT(32), WT(33), WT(34), WT(35)
     +   / 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0/
      DATA WT(36), WT(37), WT(38), WT(39), WT(40), WT(41), WT(42)
     +   / 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0/
      DATA WT(43), WT(44), WT(45), WT(46), WT(47), WT(48), WT(49)
     +   / 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0/
      DATA WT(50), WT(51), WT(52), WT(53), WT(54), WT(55), WT(56)
     +   / 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 0.0D0, 0.0D0/
      DATA WT(57), WT(58), WT(59), WT(60), WT(61), WT(62), WT(63)
     +   / 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0/
      DATA WT(64), WT(65), WT(66), WT(67), WT(68), WT(69), WT(70)
     +   / 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0/
      DATA WT(71), WT(72), WT(73), WT(74), WT(75), WT(76), WT(77)
     +   / 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0/
      DATA WT(78), WT(79), WT(80), WT(81), WT(82), WT(83), WT(84)
     +   / 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0/
C
C     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
C
      CALL IPRINT(IPRT)
C
      FPLM = D1MACH(2)
C
C     SET UP THE WEIGHTS VECTORS.
C
      DO 10 I=1,N
         WTALL1(I) = 1.0D0
   10 CONTINUE
      DO 20 I=1,NCONST
         YCONST(I) = 1.0D0
         WTALL0(I) = 0.0D0
   20 CONTINUE
C
C     HEADING.
C
      WRITE (IPRT,1150)
C
C     TEST 1.  CHECK ALL ERROR MESSAGES.
C
C     ERROR 1, TWO OR FEWER ELEMENTS.
C
      WRITE (IPRT,1180)
      WRITE(IPRT,1230)
      WRITE(IPRT,1240)
      CALL STAT(Y, 2, LDSTAK)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1230)
      WRITE(IPRT,1250)
      CALL STATS(Y, 2, LDSTAK, STS, NPRTON)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1230)
      WRITE(IPRT,1400)
      CALL STATW(Y, WT, 2, LDSTAK)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1230)
      WRITE(IPRT,1410)
      CALL STATWS(Y, WT, 2, LDSTAK, STS, NPRTON)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
C
C     ERROR 2, NOT ENOUGH SPACE IN CSTAK.
C
      WRITE (IPRT,1190)
      WRITE(IPRT,1230)
      WRITE(IPRT,1240)
      CALL STAT(Y, N, N/4)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1230)
      WRITE(IPRT,1250)
      CALL STATS(Y, N, N/4, STS, NPRTON)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1230)
      WRITE(IPRT,1400)
      CALL STATW(Y, WT, N, N/4)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1230)
      WRITE(IPRT,1410)
      CALL STATWS(Y, WT, N, N/4, STS, NPRTON)
      WRITE (IPRT,1170) IERR
C
C     ERROR 4, NEGATIVE WEIGHTS.
C
      WRITE (IPRT,1210)
      WTEMP = WT(2)
      WT(2) = -1.0D0
      WRITE(IPRT,1230)
      WRITE(IPRT,1400)
      CALL STATW(Y, WT, N, LDSTAK)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1230)
      WRITE(IPRT,1410)
      CALL STATWS(Y, WT, N, LDSTAK, STS, NPRTON)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
      WT(2) = WTEMP
C
C     ERROR 5, ALL WEIGHTS ZERO (PLUS CONSTANT Y).
C
      WRITE (IPRT,1220)
      WRITE(IPRT,1230)
      WRITE(IPRT,1400)
      CALL STATW(YCONST, WTALL0, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1230)
      WRITE(IPRT,1410)
      CALL STATWS(YCONST, WTALL0, NCONST, LDSTAK, STS, NPRTON)
      WRITE (IPRT,1170) IERR
C
C     TEST 2.  CHECK FOR READING OUTSIDE OF DATA ARRAY.
C
      WRITE (IPRT,1160)
      YTEMP1 = YCONST(1)
      YCONST(1) = FPLM
      YTEMPN = YCONST(NCONST)
      YCONST(NCONST) = FPLM
      WRITE(IPRT,1440)
      WRITE(IPRT,1240)
      CALL STAT(YCONST(2), NCONST-2, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1440)
      WRITE(IPRT,1250)
      CALL STATS(YCONST(2), NCONST-2, LDSTAK, STS, NPRTON)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1440)
      WRITE(IPRT,1400)
      CALL STATW(YCONST(2), WT, NCONST-2, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1440)
      WRITE(IPRT,1410)
      CALL STATWS(YCONST(2), WT, NCONST-2, LDSTAK, STS, NPRTON)
      WRITE (IPRT,1170) IERR
      YCONST(1) = YTEMP1
      YCONST(NCONST) = YTEMPN
C
C     TEST 3.  CONSTANT Y.
C
      WRITE (IPRT,1200)
      WRITE(IPRT,1440)
      WRITE(IPRT,1240)
      CALL STAT(YCONST, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1440)
      WRITE(IPRT,1250)
      CALL STATS(YCONST, NCONST, LDSTAK, STS, NPRTON)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1440)
      WRITE(IPRT,1400)
      CALL STATW(YCONST, WT, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1440)
      WRITE(IPRT,1410)
      CALL STATWS(YCONST, WT, NCONST, LDSTAK, STS, NPRTON)
      WRITE (IPRT,1170) IERR
C
C     TEST 4.  SEE IF TURNING OFF THE PRINTOUT WORKS.
C
      WRITE (IPRT,1260)
      WRITE (IPRT,1270)
      WRITE(IPRT,1230)
      WRITE(IPRT,1250)
      CALL STATS(Y, N, LDSTAK, STS, NPRTOF)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1280)
      WRITE(IPRT,1230)
      WRITE(IPRT,1410)
      CALL STATWS(Y, WT, N, LDSTAK, STS, NPRTOF)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
C
C     TEST 5.  MAKE A WORKING RUN OF EACH ROUTINE  FIRST WITH
C              N=2 (THE MINIMUN VALID VALUE) AND THEN FOR THE WHOLE
C              DATA SET TO CHECK THE OUTPUT.
C
      WRITE (IPRT,1300)
      WRITE (IPRT,1310)
      WRITE(IPRT,1240)
      CALL STAT(Y, 3, LDSTAK)
      WRITE (IPRT,1310)
      WRITE(IPRT,1240)
      CALL STAT(Y, N, LDSTAK)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
C
      WRITE (IPRT,1320)
      WRITE(IPRT,1400)
      CALL STATW(Y, WT, 3, LDSTAK)
      WRITE (IPRT,1320)
      WRITE(IPRT,1400)
      CALL STATW(Y, WT, N, LDSTAK)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
C
      WRITE (IPRT,1340)
      WRITE(IPRT,1250)
      CALL STATS(Y, 3, LDSTAK, STS, NPRTON)
      WRITE (IPRT,1340)
      WRITE(IPRT,1250)
      CALL STATS(Y, N, LDSTAK, STS, NPRTON)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
C
      WRITE (IPRT,1350)
      WRITE(IPRT,1410)
      CALL STATWS(Y, WT, 3, LDSTAK, STS, NPRTON)
      WRITE (IPRT,1350)
      WRITE(IPRT,1410)
      CALL STATWS(Y, WT, N, LDSTAK, STS, NPRTON)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
C
C     TEST 5.  CHECK RESULTS OF WEIGHTING ALL OBSERVATIONS
C              WITH 1.0D0.  COMPARE WITH STAT EXECUTION.
C
      WRITE (IPRT,1370)
      WRITE(IPRT,1400)
      CALL STATW(Y, WTALL1, N, LDSTAK)
      WRITE (IPRT,1170) IERR
C
C     TEST 6.  CHECK RESULTS OF FORCING DIFFERENCE PATHS THROUGH
C              THE SUMMATION ROUTINES, USING SMALL, SIMPLE DATA SETS.
C
      WRITE (IPRT,1000)
C
C     RUN DATA SET 6.1
C
      DO 30 I=1,10
         YPATH(I) = I
   30 CONTINUE
      WRITE (IPRT,1010)
      WRITE(IPRT,1240)
      CALL STAT(YPATH, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1020)
      WRITE(IPRT,1400)
      CALL STATW(YPATH, WTALL1, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
C
C     RUN DATA SET 6.2
C
      DO 40 I=1,10
         YPATH(I) = -I
   40 CONTINUE
      WRITE (IPRT,1030)
      WRITE(IPRT,1240)
      CALL STAT(YPATH, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1040)
      WRITE(IPRT,1400)
      CALL STATW(YPATH, WTALL1, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
C
C     RUN DATA SET 6.3
C
      DO 50 I=1,10
         YPATH(I) = I-1
   50 CONTINUE
      WRITE (IPRT,1050)
      WRITE(IPRT,1240)
      CALL STAT(YPATH, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1060)
      WRITE(IPRT,1400)
      CALL STATW(YPATH, WTALL1, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
C
C     RUN DATA SET 6.4
C
      DO 60 I=1,10
         YPATH(I) = 1-I
   60 CONTINUE
      WRITE (IPRT,1070)
      WRITE(IPRT,1240)
      CALL STAT(YPATH, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1080)
      WRITE(IPRT,1400)
      CALL STATW(YPATH, WTALL1, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
C
C     RUN DATA SET 6.5
C
      DO 70 I=1,10
         YPATH(I) = I-6
   70 CONTINUE
      WRITE (IPRT,1090)
      WRITE(IPRT,1240)
      CALL STAT(YPATH, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1100)
      WRITE(IPRT,1400)
      CALL STATW(YPATH, WTALL1, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
C
C     RUN DATA SET 6.6
C
      DO 80 I=1,10
         YPATH(I) = I-5
   80 CONTINUE
      WRITE (IPRT,1110)
      WRITE(IPRT,1240)
      CALL STAT(YPATH, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1120)
      WRITE(IPRT,1400)
      CALL STATW(YPATH, WTALL1, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
C
C     RUN DATA SET 6.7
C
      DO 90 I=1,10
         YPATH(I) = 0.0D0
   90 CONTINUE
      YPATH(1) = -5.0D0
      YPATH(10) = 5.0D0
      WRITE (IPRT,1130)
      WRITE(IPRT,1240)
      CALL STAT(YPATH, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1140)
      WRITE(IPRT,1400)
      CALL STATW(YPATH, WTALL1, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
C
C     RUN DATA SET 6.8
C
      DO 100 I=1,10
         YPATH(I) = 0.0D0
  100 CONTINUE
      YPATH(1) = -5.0D0
      WTALL1(1) = 0.0D0
      YPATH(10) = 5.0D0
      WTALL1(10) = 0.0D0
      WRITE (IPRT,1380)
      WRITE(IPRT,1400)
      CALL STATW(YPATH, WTALL1, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      RETURN
C
C     FORMATS
C
 1000 FORMAT(51H1TEST 6.  TRY DIFFERENT PATHS THROUGH THE SUMMATION,
     +   6H CODE.)
 1010 FORMAT('1RUN STAT ON 1, ..., 10.')
 1020 FORMAT('1RUN STATW ON 1, ..., 10.  WEIGHTS ARE ALL 1.')
 1030 FORMAT('1RUN STAT ON -1, ..., -10.')
 1040 FORMAT('1RUN STATW ON -1, ..., -10.  WEIGHTS ARE ALL 1.')
 1050 FORMAT('1RUN STAT ON 0, ..., 9.')
 1060 FORMAT('1RUN STATW ON 0, ..., 9.  WEIGHTS ARE ALL 1.')
 1070 FORMAT('1RUN STAT ON 0, ..., -9.')
 1080 FORMAT('1RUN STATW ON 0, ..., -9.  WEIGHTS ARE ALL 1.')
 1090 FORMAT('1STAT ON -5, ..., 4.')
 1100 FORMAT('1RUN STATW ON -5, ..., 4.  WEIGHTS ARE ALL 1.')
 1110 FORMAT('1RUN STAT ON -4, ..., 5.')
 1120 FORMAT('1RUN STATW ON -4, ..., 5.  WEIGHTS ARE ALL 1.')
 1130 FORMAT('1RUN STAT ON -1, 8*0, 1.')
 1140 FORMAT('1RUN STATW ON -1, 8*0, 1.  WEIGHTS ARE ALL 1.')
 1150 FORMAT('1TEST RUNS FOR THE STATISTICAL ANALYSIS FAMILY ROUTINES.')
 1160 FORMAT('1TEST RUNS TO BE SURE CODE IS NOT READING OUTSIDE',
     +       ' DATA ARRAY.')
 1170 FORMAT(/' THE VALUE OF IERR IS ', I4)
 1180 FORMAT('1TRY TWO OR FEWER ELEMENTS.')
 1190 FORMAT('1TRY INSUFFICIENT WORK AREA.')
 1200 FORMAT('1TRY CONSTANT Y.')
 1210 FORMAT('1TRY NEGATIVE WEIGHTS.')
 1220 FORMAT('1TRY ALL WEIGHTS ZERO (AND CONSTANT Y).')
 1230 FORMAT (///)
 1240 FORMAT (' CALL TO STAT')
 1250 FORMAT (' CALL TO STATS')
 1260 FORMAT(45H1TEST3.  TRY TURNING OFF THE PRINT FOR THOSE ,
     +   24HROUTINES WHICH ALLOW IT.)
 1270 FORMAT(37H TRY TURNING THE PRINT OFF FOR STATS.)
 1280 FORMAT(38H TRY TURNING THE PRINT OFF FOR STATWS.)
 1300 FORMAT(52H1TEST 4.  MAKE WORKING RUNS OF ALL ROUTINES TO CHECK,
     +   16H THE STATISTICS.)
 1310 FORMAT('1RUN STAT ON THE DAVIS-HARRISON PIKES PEAK DATA.')
 1320 FORMAT('1RUN STATW ON THE DAVIS-HARRISON PIKES PEAK DATA.')
 1340 FORMAT('1RUN STATS ON THE DAVIS-HARRISON PIKES PEAK DATA.')
 1350 FORMAT('1RUN STATWS ON THE DAVIS-HARRISON PIKES PEAK DATA.')
 1370 FORMAT('1RUN STATW ON THE DAVIS-HARRISON PIKES PEAK DATA.',
     +  '  WEIGHTS ALL EQUAL TO ONE.  COMPARE TO STAT ABOVE, NOT TO',
     +  ' STATW.')
 1380 FORMAT(42H SERIES WITH NONZERO VALUES WEIGHTED ZERO.)
 1390 FORMAT(/8H DATA = , 10F7.4)
 1400 FORMAT (14H CALL TO STATW)
 1410 FORMAT (15H CALL TO STATWS)
 1440 FORMAT ('1')
      END
*XSTPLD
      SUBROUTINE XSTPLD(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,EXMPT
      INTEGER
     +   I,IPRT,IXM,LDSMIN,M,N,NETA,NPAR,NPRT,NTEST
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(10),SCALE(10),STP(10),XM(200,2)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LDSCMP,LSTVEC,MDL4,STPLS,STPLS1,STPLS2,STPLSC
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        *
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION EXMPT
C        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
C        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
C        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL4
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS OF DATA.
C     INTEGER NETA
C        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
C     INTEGER NTEST
C        THE NUMBER OF THE CURRENT TEST.
C     DOUBLE PRECISION PAR(10)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION SCALE(10)
C        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION STP(10)
C        THE SELECTED STEP SIZES FOR EACH PARAMETER.
C     DOUBLE PRECISION XM(200,2)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
      CALL IPRINT(IPRT)
C
C     SET PARAMETER VALUES
C
      CALL STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
      CALL STPLS2(NPAR, STP)
      CALL LDSCMP(14, 0, 2*(N+NPAR), 0, 0, 0, 'D', 10*N, LDSMIN)
C
      IF (LDSMIN.LE.LDSTAK) GO TO 5
C
      WRITE (IPRT, 1020) LDSMIN
      RETURN
C
    5 CONTINUE
C
C     CREATE INDEPENDENT VARIABLE
C
      DELTA = 0.0625D0
      XM(1,1) = 0.0D0
      DO 10 I=2,N
         XM(I,1) = XM(I-1,1) + DELTA
   10 CONTINUE
C
      NTEST = 0
C
C     CHECK RESULTS FROM VALID CALLS
C
C     SIMPLE EXAMPLE
C
      CALL STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1090) NTEST
      WRITE (IPRT,1040)
      WRITE (IPRT,1000)
      CALL STPLS2(NPAR, STP)
      CALL STPLS(XM, N, M, IXM, MDL4, PAR, NPAR, LDSMIN, STP)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1080)
      CALL LSTVEC(4, STP)
C
      NTEST = NTEST + 1
      WRITE (IPRT,1090) NTEST
      WRITE (IPRT,1040)
      WRITE (IPRT,1060) NETA, EXMPT, SCALE(1), NPRT
      WRITE (IPRT,1010)
      CALL STPLS2(NPAR, STP)
      CALL STPLSC(XM, N, M, IXM, MDL4, PAR, NPAR, LDSMIN, STP, NETA,
     +   EXMPT, SCALE, NPRT)
      WRITE (IPRT,1100) NETA, EXMPT, SCALE(1), NPRT
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1080)
      CALL LSTVEC(4, STP)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (15H TEST OF STPLS )
 1010 FORMAT (15H TEST OF STPLSC)
 1020 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1040 FORMAT (15H SIMPLE EXAMPLE)
 1050 FORMAT (/29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1060 FORMAT (19H INPUT   -  NETA = , I5, 10H, EXMPT = , G15.8,
     +   13H, SCALE(1) = , G15.8, 9H, NPRT = , I5)
 1080 FORMAT (//23H RETURNED VALUES OF STP)
 1090 FORMAT (54H1DERIVATIVE STEP SIZE SELECTION SUBROUTINE TEST NUMBER,
     +   I5)
 1100 FORMAT (//19H OUTPUT  -  NETA = , I5, 10H, EXMPT = , G15.8,
     +   13H, SCALE(1) = , G15.8, 9H, NPRT = , I5//)
      END
*XSTPLE
      SUBROUTINE XSTPLE(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,EXMPT
      INTEGER
     +   I,IPRT,IXM,LDSMIN,M,N,NETA,NPAR,NPRT,NTEST
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(10),SCALE(10),STP(10),XM(200,2)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LDSCMP,MDL4,STPLS,STPLS1,STPLS2,STPLSC
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        *
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION EXMPT
C        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
C        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
C        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL4
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS OF DATA.
C     INTEGER NETA
C        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
C     INTEGER NTEST
C        THE NUMBER OF THE CURRENT TEST.
C     DOUBLE PRECISION PAR(10)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION SCALE(10)
C        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION STP(10)
C        THE SELECTED STEP SIZES FOR EACH PARAMETER.
C     DOUBLE PRECISION XM(200,2)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
      CALL IPRINT(IPRT)
C
C     SET PARAMETER VALUES
C
      CALL STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
      CALL STPLS2(NPAR, STP)
      CALL LDSCMP(14, 0, 2*(N+NPAR), 0, 0, 0, 'D', 10*N, LDSMIN)
C
      IF (LDSMIN.LE.LDSTAK) GO TO 5
C
      WRITE (IPRT, 1040) LDSMIN
      RETURN
C
    5 CONTINUE
C
C     CREATE INDEPENDENT VARIABLE
C
      DELTA = 0.0625D0
      XM(1,1) = 0.0D0
      DO 10 I=2,N
         XM(I,1) = XM(I-1,1) + DELTA
   10 CONTINUE
C
      NTEST = 0
C     CHECK ERROR HANDLING
C
C        TEST 1  -  MISCELANEOUS ERROR CHECKING
C
      N = -5
      M = -5
      IXM = -10
      NPAR = -10
C
C
      NTEST = NTEST + 1
      WRITE (IPRT,1090) NTEST
      WRITE (IPRT,1020)
      WRITE (IPRT,1000)
      IERR = -1
      CALL STPLS(XM, N, M, IXM, MDL4, PAR, NPAR, LDSTAK, STP)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1010)
      IERR = -1
      CALL STPLSC(XM, N, M, IXM, MDL4, PAR, NPAR, LDSTAK, STP, NETA,
     +   EXMPT, SCALE, NPRT)
      WRITE (IPRT,1050) IERR
C
C        TEST 2  -  MISCELANEOUS ERROR CHECKING (CONTINUED)
C
      CALL STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
      SCALE(2) = 0.0D0
C
      NTEST = NTEST + 1
      WRITE (IPRT,1090) NTEST
      WRITE (IPRT,1030)
      WRITE (IPRT,1000)
      IERR = -1
      CALL STPLS(XM, N, M, IXM, MDL4, PAR, NPAR, LDSMIN-1, STP)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1010)
      IERR = -1
      CALL STPLSC(XM, N, M, IXM, MDL4, PAR, NPAR, LDSMIN-1, STP, NETA,
     +   EXMPT, SCALE, NPRT)
      WRITE (IPRT,1050) IERR
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (15H TEST OF STPLS )
 1010 FORMAT (15H TEST OF STPLSC)
 1020 FORMAT (32H CHECK ERROR HANDLING  -  TEST 1)
 1030 FORMAT (32H CHECK ERROR HANDLING  -  TEST 2)
 1040 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1050 FORMAT (/29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1090 FORMAT (54H1DERIVATIVE STEP SIZE SELECTION SUBROUTINE TEST NUMBER,
     +   I5)
      END
*XSTPLT
      SUBROUTINE XSTPLT(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  NOVEMBER 21, 1983
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,EXMPT
      INTEGER
     +   I,IPRT,IXM,LDSMIN,M,N,NETA,NPAR,NPRT,NTEST
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   EXMTST(5),PAR(10),SCALE(10),STP(10),XM(200,2)
      INTEGER
     +   NETTST(6)
C
C  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LDSCMP,LSTVEC,MDL4,STPLS1,STPLS2,STPLSC
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG10
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DELTA
C        *
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION EXMPT
C        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
C        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
C        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
C     DOUBLE PRECISION EXMTST(5)
C        VARIOUS TEST VALUES FOR EXMPT.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL4
C        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
C        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS OF DATA.
C     INTEGER NETA
C        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
C     INTEGER NETTST(6)
C        VARIOUS TEST VALUES FOR NETA.
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     INTEGER NPRT
C        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
C        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
C        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
C     INTEGER NTEST
C        THE NUMBER OF THE CURRENT TEST.
C     DOUBLE PRECISION PAR(10)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION SCALE(10)
C        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
C        THE TYPICAL SIZE OF THE PARAMETERS.
C     DOUBLE PRECISION STP(10)
C        THE SELECTED STEP SIZES FOR EACH PARAMETER.
C     DOUBLE PRECISION XM(200,2)
C        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
C        IS STORED.
C
      CALL IPRINT(IPRT)
C
C     SET PARAMETER VALUES
C
      CALL STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
      CALL STPLS2(NPAR, STP)
      CALL LDSCMP(14, 0, 2*(N+NPAR), 0, 0, 0, 'D', 10*N, LDSMIN)
C
      IF (LDSMIN.LE.LDSTAK) GO TO 5
C
      WRITE (IPRT, 1000) LDSMIN
      RETURN
C
    5 CONTINUE
C
C     CREATE INDEPENDENT VARIABLE
C
      DELTA = 0.0625D0
      XM(1,1) = 0.0D0
      DO 10 I=2,N
         XM(I,1) = XM(I-1,1) + DELTA
   10 CONTINUE
C
      NTEST = 0
C
C
C     TEST VARIOUS VALUES OF EXMPT
C
      CALL STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
      EXMTST(1) = -1.0D0
      EXMTST(2) = 0.0001D0
      EXMTST(3) = 0.5D0
      EXMTST(4) = 1.0D0
      EXMTST(5) = 1.1D0
C
      DO 20 I=1,5
C
         NTEST = NTEST + 1
         WRITE (IPRT,1090) NTEST
         WRITE (IPRT,1040)
         WRITE (IPRT,1060) NETA, EXMTST(I), SCALE(1), NPRT
         WRITE (IPRT,1010)
         CALL STPLS2(NPAR, STP)
         CALL STPLSC(XM, N, M, IXM, MDL4, PAR, NPAR, LDSTAK, STP, NETA,
     +      EXMTST(I), SCALE, NPRT)
         WRITE (IPRT,1100) NETA, EXMTST(I), SCALE(1), NPRT
         WRITE (IPRT,1050) IERR
         WRITE (IPRT,1080)
         CALL LSTVEC(4, STP)
C
   20 CONTINUE
C
C     TEST VARIOUS VALUES OF NETA
C
      NETTST(1) = -1
      NETTST(2) = 0
      NETTST(3) = 1
      NETTST(4) = 2
C
      NETTST(5) = -LOG10(D1MACH(4))
      NETTST(6) = NETTST(5) + 1
C
      SCALE(1) = 0.0D0
C
      DO 30 I=1,6
C
         NTEST = NTEST + 1
         WRITE (IPRT,1090) NTEST
         WRITE (IPRT,1040)
         WRITE (IPRT,1060) NETTST(I), EXMPT, SCALE(1), NPRT
         WRITE (IPRT,1010)
         CALL STPLS2(NPAR, STP)
         CALL STPLSC(XM, N, M, IXM, MDL4, PAR, NPAR, LDSTAK, STP,
     +      NETTST(I), EXMPT, SCALE, NPRT)
         WRITE (IPRT,1100) NETTST(I), EXMPT, SCALE(1), NPRT
         WRITE (IPRT,1050) IERR
         WRITE (IPRT,1080)
         CALL LSTVEC(4, STP)
C
   30 CONTINUE
C
C     SUPPRESS OUTPUT
C
      CALL STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
      NPRT = 0
C
      NTEST = NTEST + 1
      WRITE (IPRT,1090) NTEST
      WRITE (IPRT,1040)
      WRITE (IPRT,1060) NETA, EXMPT, SCALE(1), NPRT
      WRITE (IPRT,1010)
      CALL STPLS2(NPAR, STP)
      CALL STPLSC(XM, N, M, IXM, MDL4, PAR, NPAR, LDSTAK, STP, NETA,
     +   EXMPT, SCALE, NPRT)
      WRITE (IPRT,1100) NETA, EXMPT, SCALE(1), NPRT
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1080)
      CALL LSTVEC(4, STP)
C
C     LARGE CALCULATION ERROR PROBLEM
C
      CALL STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
      PAR(3) = 10.0D0**((NETTST(5)-1)/2)
      SCALE(1) = -1.0D0
C
      NTEST = NTEST + 1
      WRITE (IPRT,1090) NTEST
      WRITE (IPRT,1070)
      WRITE (IPRT,1060) NETA, EXMPT, SCALE(1), NPRT
      WRITE (IPRT,1010)
      CALL STPLS2(NPAR, STP)
      CALL STPLSC(XM, N, M, IXM, MDL4, PAR, NPAR, LDSTAK, STP, NETA,
     +   EXMPT, SCALE, NPRT)
      WRITE (IPRT,1100) NETA, EXMPT, SCALE(1), NPRT
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1080)
      CALL LSTVEC(4, STP)
C
      EXMPT = 0.11D0
      NPRT = 0
C
      NTEST = NTEST + 1
      WRITE (IPRT,1090) NTEST
      WRITE (IPRT,1070)
      WRITE (IPRT,1060) NETA, EXMPT, SCALE(1), NPRT
      WRITE (IPRT,1010)
      CALL STPLS2(NPAR, STP)
      CALL STPLSC(XM, N, M, IXM, MDL4, PAR, NPAR, LDSTAK, STP, NETA,
     +   EXMPT, SCALE, NPRT)
      WRITE (IPRT,1100) NETA, EXMPT, SCALE(1), NPRT
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1080)
      CALL LSTVEC(4, STP)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1010 FORMAT (15H TEST OF STPLSC)
 1040 FORMAT (15H SIMPLE EXAMPLE)
 1050 FORMAT (/29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1060 FORMAT (19H INPUT   -  NETA = , I5, 10H, EXMPT = , G15.8,
     +   13H, SCALE(1) = , G15.8, 9H, NPRT = , I5)
 1070 FORMAT (32H LARGE CALCULATION ERROR PROBLEM)
 1080 FORMAT (//23H RETURNED VALUES OF STP)
 1090 FORMAT (54H1DERIVATIVE STEP SIZE SELECTION SUBROUTINE TEST NUMBER,
     +   I5)
 1100 FORMAT (//19H OUTPUT  -  NETA = , I5, 10H, EXMPT = , G15.8,
     +   13H, SCALE(1) = , G15.8, 9H, NPRT = , I5//)
      END
*XUAS
      SUBROUTINE XUAS(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST THE AUTOREGRESSIVE SPECTRUM ANALYSIS ROUTINES
C
C     SERIES Y IS THE FIRST 50 VALUES OF THE SERIES LISTED ON PAGE
C     318 OF JENKINS AND WATTS.  THE SPECTRUM OF THIS SERIES IS SHOWN
C     FOR VARIOUS BANDWIDTH ON PAGE 270 OF JENKINS AND WATTS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JUNE 10, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FMAX,FMIN,YMISS
      INTEGER
     +   I,IAR,IPRT,LACOV,LAG,LAGMAX,LDS,LYFFT,NF,NPRT,NY
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),FREQ(300),PHI(101),SPCA(101),SPCF(101),Y(150),
     +   YFFT(400)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACFS,IPRINT,DCOPY,SETRV,UAS,UASF,UASFS,UASS,UASV,UASVS
C
C  INTRINSIC FUNCTIONS
      INTRINSIC ABS
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(101)
C        THE AUTOCOVARIANCE VECTOR.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCIES AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(300)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS COMPUTED.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE MODEL TO BE USED.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAG, LAGMAX
C        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
C        AUTOCOVARIANCE BEING COMPUTED AND THE MAXIMUM LAG TO BE USED,
C        RESPECTIVELY.
C     INTEGER LDS
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
C        NPRT = 0 THE PLOT IS SUPPRESSED
C        NPRT > 0 THE PLOT IS LOG/LINEAR
C     INTEGER NY
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     DOUBLE PRECISION PHI(101)
C        THE VECTOR OF THE ORDER IAR AUTOREGRESSIVE MODEL COEFFICIENTS.
C     DOUBLE PRECISION SPCA(101)
C        THE ARRAYS IN WHICH THE AUTOREGRESSIVE SPECTRUM IS STORED
C        FOR EACH LAG WINDOW.
C     DOUBLE PRECISION SPCF(101)
C        THE ARRAYS IN WHICH THE FOURIER SPECTRUM IS STORED
C        FOR EACH LAG WINDOW.
C     DOUBLE PRECISION Y(150)
C         THE ARRAY CONTAINING THE TIME SERIES FROM JENKINS AND WATTS.
C     DOUBLE PRECISION YFFT(400)
C        THE VECTOR OF THE OBSERVED TIME SERIES TO BE ANALYZED USING
C        THE FFT.
C     DOUBLE PRECISION YMISS
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
C        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
C        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
C
C
      DATA   Y(  1), Y(  2), Y(  3), Y(  4), Y(  5), Y(  6)
     +    /-0.88D0, -0.12D0, -0.89D0, -1.38D0, -0.07D0,  1.03D0/
      DATA   Y(  7), Y(  8), Y(  9), Y( 10), Y( 11), Y( 12)
     +    / 2.14D0,  0.35D0, -1.10D0, -1.78D0, -2.76D0, -1.77D0/
      DATA   Y( 13), Y( 14), Y( 15), Y( 16), Y( 17), Y( 18)
     +    / 0.98D0,  1.00D0, -0.70D0, -1.01D0, -1.30D0, -0.85D0/
      DATA   Y( 19), Y( 20), Y( 21), Y( 22), Y( 23), Y( 24)
     +    /-0.46D0,  1.63D0,  0.06D0, -0.17D0, -1.01D0, -1.04D0/
      DATA   Y( 25), Y( 26), Y( 27), Y( 28), Y( 29), Y( 30)
     +    /-0.66D0, -1.12D0, -0.51D0, -0.71D0, -0.20D0, -0.13D0/
      DATA   Y( 31), Y( 32), Y( 33), Y( 34), Y( 35), Y( 36)
     +    / 0.14D0,  1.59D0, -0.76D0, -1.08D0, -1.77D0, -1.20D0/
      DATA   Y( 37), Y( 38), Y( 39), Y( 40), Y( 41), Y( 42)
     +    / 0.45D0, -0.07D0, -0.63D0, -0.35D0, -0.87D0, -0.62D0/
      DATA   Y( 43), Y( 44), Y( 45), Y( 46), Y( 47), Y( 48)
     +    / 0.28D0,  1.90D0,  2.14D0,  1.05D0,  0.31D0,  1.07D0/
      DATA   Y( 49), Y( 50)
     +    / 2.67D0,  2.44D0/
C
C
      CALL IPRINT(IPRT)
C
C     CHECK ERROR HANDLING
C
C        TEST 1  -  MISCELANEOUS ERROR CHECKING
C
      WRITE (IPRT, 2000)
      YMISS = 1.16D0
      LAGMAX = -1
      NY = -10
      LACOV = 101
      LAG = -2
      IAR = -2
      LYFFT = -11
      NF = -5
      FMIN = 0.5D0
      FMAX = 0.0D0
      NPRT = -1
      LDS = 0
      WRITE(IPRT, 1001)
      CALL UAS(Y, NY)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1003)
      CALL UASS(Y, NY, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT,SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1019)
      CALL UASF (YFFT, NY, LYFFT, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1020)
      CALL UASFS(YFFT, NY, LYFFT, LDS, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1007)
      CALL UASV(ACOV, LAGMAX, NY)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1008)
      CALL UASVS(ACOV, LAGMAX, Y, NY, IAR, PHI, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C        TEST 2  -  MISCELANEOUS ERROR CHECKING (CONTINUED)
C
      WRITE (IPRT, 2010)
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 50
      LAG = 101
      IAR = 101
      CALL SETRV(PHI, IAR, 2.0D0)
      CALL SETRV(ACOV, LAGMAX+1, 2.0D0)
      ACOV(1) = 1.0D0
      LYFFT = -11
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 5
      LDS = 0
      WRITE(IPRT, 1003)
      CALL UASS(Y, NY, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1019)
      CALL UASF (YFFT, NY, LYFFT, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1020)
      CALL UASFS(YFFT, NY, LYFFT, LDS, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1007)
      CALL UASV(ACOV, LAGMAX, NY)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1008)
      CALL UASVS(ACOV, LAGMAX, Y, NY, IAR, PHI, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C        TEST 3  -  LDS TOO SMALL
C
      WRITE (IPRT, 2030)
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      LAG = 16
      IAR = 2
      PHI(1) = 1.0D0
      PHI(2) = -0.5D0
      CALL ACFS (Y, NY, LAGMAX, LACOV, ACOV, IAR, PHI, 0, 700)
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 3
      LDS = 0
      WRITE(IPRT, 1003)
      CALL UASS(Y, NY, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1019)
      CALL UASF (YFFT, NY, LYFFT, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1020)
      CALL UASFS(YFFT, NY, LYFFT, LDS, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1008)
      CALL UASVS(ACOV, LAGMAX, Y, NY, IAR, PHI, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C     CHECK RESULTS FROM VALID CALL
C
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      LAG = 16
      IAR = 2
      PHI(1) = 1.0D0
      PHI(2) = -0.5D0
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 2
      LDS = 700
C
C     TEST OF UAS
C
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1001)
      CALL UAS(Y, NY)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF UASS
C
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1003)
      CALL UASS(Y, NY, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM UASS
C
      WRITE (IPRT, 1004) (FREQ(I), SPCA(I), SPCF(I), I=1,NF)
      WRITE (IPRT, 1005) IAR, LAG
      WRITE (IPRT, 1006) (PHI(I), I=1,ABS(IAR))
C
C     TEST OF UASF
C
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1019)
      CALL DCOPY(NY, Y, 1, YFFT, 1)
      CALL UASF (YFFT, NY, LYFFT, LDS)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF UASFS
C
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1020)
      CALL DCOPY(NY, Y, 1, YFFT, 1)
      CALL UASFS(YFFT, NY, LYFFT, LDS, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM UASFS
C
      WRITE (IPRT, 1004) (FREQ(I), SPCA(I), SPCF(I), I=1,NF)
      WRITE (IPRT, 1005) IAR, LAG
      WRITE (IPRT, 1006) (PHI(I), I=1,ABS(IAR))
C
C     TEST OF UASV
C
      WRITE(IPRT, 2020)
      WRITE (IPRT, 1007)
      CALL UASV(ACOV, LAGMAX, NY)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF UASVS
C
      WRITE(IPRT, 2020)
      WRITE (IPRT, 1008)
      CALL UASVS(ACOV, LAGMAX, Y, NY, IAR, PHI, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM UASVS
C
      WRITE (IPRT, 1004) (FREQ(I), SPCA(I), SPCF(I), I=1,NF)
      WRITE (IPRT, 1005) IAR, LAG
      WRITE (IPRT, 1006) (PHI(I), I=1,ABS(IAR))
C
C     MINIMUM PROBLEM SIZE
C
      YMISS = 1.16D0
      NY = 17
      LAGMAX = 1
      LYFFT = 400
      LAG = 1
      IAR = -1
      PHI(1) = 1.0D0
      PHI(2) = -0.5D0
      NF = 1
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 2
      LDS = LDSTAK
C
C     TEST OF UAS
C
      WRITE (IPRT, 2060)
      WRITE(IPRT, 1001)
      CALL UAS(Y, NY)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF UASS
C
      WRITE(IPRT, 2060)
      WRITE(IPRT, 1003)
      CALL UASS(Y, NY, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM UASS
C
      WRITE (IPRT, 1004) (FREQ(I), SPCA(I), SPCF(I), I=1,NF)
      WRITE (IPRT, 1005) IAR, LAG
      WRITE (IPRT, 1006) (PHI(I), I=1,ABS(IAR))
C
C     CHECK HANDLING OF FMIN AND FMAX, AND LAG.EQ.0 AND IAR.EQ.0
C
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      LAG = 0
      IAR = 0
      PHI(1) = 1.0D0
      PHI(2) = -0.5D0
      NF = 51
      FMIN = 0.45D0
      FMAX = 0.5D0
      NPRT = 2
C
C     TEST OF UASS
C
      WRITE(IPRT, 2070)
      WRITE(IPRT, 1003)
      CALL UASS(Y, NY, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM UASS
C
      WRITE (IPRT, 1004) (FREQ(I), SPCA(I), SPCF(I), I=1,NF)
      WRITE (IPRT, 1005) IAR, LAG
      WRITE (IPRT, 1006) (PHI(I), I=1,ABS(IAR))
C
C     WHITE NOISE SPECTRUM
C
      YMISS = 1.16D0
      CALL SETRV(YFFT, NY, 0.0D0)
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      LAG = 16
      IAR = 2
      PHI(1) = 1.0D0
      PHI(2) = -0.5D0
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 2
C
C     TEST OF UASS
C
      WRITE(IPRT, 2080)
      WRITE(IPRT, 1003)
      CALL UASS(YFFT, NY, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM UASS
C
      WRITE (IPRT, 1004) (FREQ(I), SPCA(I), SPCF(I), I=1,NF)
      WRITE (IPRT, 1005) IAR, LAG
      WRITE (IPRT, 1006) (PHI(I), I=1,ABS(IAR))
C
C     SUPPRESS OUTPUT AND
C     CHECK HANDLING OF LAG .LT.0 AND IAR .LT. 0
C
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      LAG = 0
      IAR = 0
      PHI(1) = 1.0D0
      PHI(2) = -0.5D0
      NF = 51
      FMIN = 0.45D0
      FMAX = 0.5D0
      NPRT = 0
C
C     TEST OF UASS
C
      WRITE(IPRT, 2090)
      WRITE(IPRT, 1003)
      CALL UASS(Y, NY, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM UASS
C
      WRITE (IPRT, 1004) (FREQ(I), SPCA(I), SPCF(I), I=1,NF)
      WRITE (IPRT, 1005) IAR, LAG
      WRITE (IPRT, 1006) (PHI(I), I=1,ABS(IAR))
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1001 FORMAT (12H TEST OF UAS)
 1002 FORMAT (/8H IERR IS, I5/)
 1003 FORMAT (13H TEST OF UASS)
 1004 FORMAT (3(1X, E16.8))
 1005 FORMAT (/7H IAR = , I5/7H LAG = , I5)
 1006 FORMAT (/7H PHI = , (1X, 5D21.8))
 1007 FORMAT (13H TEST OF UASV)
 1008 FORMAT (14H TEST OF UASVS)
 1019 FORMAT (13H TEST OF UASF)
 1020 FORMAT (14H TEST OF UASFS)
 2000 FORMAT (32H1CHECK ERROR HANDLING  -  TEST 1)
 2010 FORMAT (32H1CHECK ERROR HANDLING  -  TEST 2)
 2020 FORMAT (14H1VALID PROBLEM)
 2030 FORMAT (14H1LDS TOO SMALL)
 2060 FORMAT (21H1MINIMUM PROBLEM SIZE)
 2070 FORMAT (
     +   59H1CHECK HANDLING OF FMIN AND FMAX, LAG AND IAR EQUAL TO ZERO)
 2080 FORMAT (21H1WHITE NOISE SPECTRUM)
 2090 FORMAT (44H1SUPPRESS OUTPUT, LAG AND IAR LESS THAN ZERO)
      END
*XUFS
      SUBROUTINE XUFS(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST THE FOURIER SPECTRUM ANALYSIS ROUTINES
C
C     SERIES Y IS THE FIRST 50 VALUES OF THE SERIES LISTED ON PAGE
C     318 OF JENKINS AND WATTS.  THE SPECTRUM OF THIS SERIES IS SHOWN
C     FOR VARIOUS BANDWIDTH ON PAGE 270 OF JENKINS AND WATTS.
C
C     SERIES Z IS THE WOLF SUNSPOT NUMBERS FROM 1700 TO 1960 AS
C     TABULATED BY WALDMEIER.  THE RAW AND SMOOTHED PERIODOGRAMS OF
C     TAPERED SERIES ARE SHOWN ON PAGES 95 AND 176, RESPECTIVELY, OF
C     BLOOMFIELD.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 7, 1981
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   AMISS,FMAX,FMIN,YMISS
      INTEGER
     +   I,IAR,IPRT,ISPCF,J,LACOV,LAGMAX,LDS,LYFFT,NF,NPRT,NW,NY
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),FREQ(300),PHI(100),SPCF(101,4),Y(150),YFFT(400)
      INTEGER
     +   LAGS(4),NLPPA(101)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACFMS,ACFS,IPRINT,NRAND,DCOPY,SETRV,UFS,UFSF,UFSFS,UFSM,
     +   UFSMS,UFSMV,UFSMVS,UFSS,UFSV,UFSVS
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION ACOV(101)
C        THE AUTOCOVARIANCE VECTOR.
C     DOUBLE PRECISION AMISS
C         THE MISSING VALUE CODE FOR THE RETURNED ACVF ESTIMATES.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FMAX, FMIN
C        THE MAXIMUM AND MINIMUM FREQUENCIES AT WHICH THE
C        SPECTRUM IS TO BE COMPUTED.
C     DOUBLE PRECISION FREQ(300)
C        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS COMPUTED.
C     INTEGER I
C        AN INDEX VARIABLE
C     INTEGER IAR
C        THE ORDER OF THE AUTOREGRESSIVE MODEL TO BE USED.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
C     INTEGER IPRT
C        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
C     INTEGER ISPCF
C         THE ACTUAL DIMENSION FOR THE SPECTRUM ARRAYS.
C     INTEGER J
C        INDEX VARIABLE.
C     INTEGER LACOV
C        THE LENGTH OF THE VECTOR ACOV.
C     INTEGER LAGMAX
C        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
C        AUTOCOVARIANCE BEING COMPUTED AND THE MAXIMUM LAG TO BE USED,
C        RESPECTIVELY.
C     INTEGER LAGS(4)
C        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
C        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
C     INTEGER LDS
C        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
C     INTEGER LYFFT
C        THE LENGTH OF THE VECTOR YFFT.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
C        TO BE COMPUTED.
C     INTEGER NLPPA(101)
C        THE NUMBERS OF LAGGED PRODUCT PAIRS USED FOR EACH ACVF.
C     INTEGER NPRT
C        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
C        NPRT = 0 THE PLOT IS SUPPRESSED, IF
C        NPRT = 2 THE PLOT IS DECIBELS/LINEAR, IF
C        NPRT = 2 THE PLOT IS LOG/LINEAR, IF
C        NPRT = 3 THE PLOT IS DECIBELS/LOG, AND IF
C        NPRT = 4 THE PLOT IS LOG/LOG.
C     INTEGER NW
C        THE NUMBER OF DIFFERENT LAG WINDOW TRUNCATION POINTS SPECIFIED,
C        AND THEREFORE, THE NUMBER OF PLOTS.
C     INTEGER NY
C        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
C     DOUBLE PRECISION PHI(100)
C        THE VECTOR OF THE ORDER IAR AUTOREGRESSIVE MODEL COEFFICIENTS.
C     DOUBLE PRECISION SPCF(101, 4)
C        THE ARRAYS IN WHICH THE FOURIER SPECTRUM IS STORED
C        FOR EACH LAG WINDOW.
C     DOUBLE PRECISION Y(150)
C         THE ARRAY CONTAINING THE TIME SERIES FROM JENKINS AND WATTS.
C     DOUBLE PRECISION YFFT(400)
C        THE VECTOR OF THE OBSERVED TIME SERIES TO BE ANALYZED USING
C        THE FFT.
C     DOUBLE PRECISION YMISS
C        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
C        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
C        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
C
C
      DATA   Y(  1), Y(  2), Y(  3), Y(  4), Y(  5), Y(  6)
     +    /-0.88D0, -0.12D0, -0.89D0, -1.38D0, -0.07D0,  1.03D0/
      DATA   Y(  7), Y(  8), Y(  9), Y( 10), Y( 11), Y( 12)
     +    / 2.14D0,  0.35D0, -1.10D0, -1.78D0, -2.76D0, -1.77D0/
      DATA   Y( 13), Y( 14), Y( 15), Y( 16), Y( 17), Y( 18)
     +    / 0.98D0,  1.00D0, -0.70D0, -1.01D0, -1.30D0, -0.85D0/
      DATA   Y( 19), Y( 20), Y( 21), Y( 22), Y( 23), Y( 24)
     +    /-0.46D0,  1.63D0,  0.06D0, -0.17D0, -1.01D0, -1.04D0/
      DATA   Y( 25), Y( 26), Y( 27), Y( 28), Y( 29), Y( 30)
     +    /-0.66D0, -1.12D0, -0.51D0, -0.71D0, -0.20D0, -0.13D0/
      DATA   Y( 31), Y( 32), Y( 33), Y( 34), Y( 35), Y( 36)
     +    / 0.14D0,  1.59D0, -0.76D0, -1.08D0, -1.77D0, -1.20D0/
      DATA   Y( 37), Y( 38), Y( 39), Y( 40), Y( 41), Y( 42)
     +    / 0.45D0, -0.07D0, -0.63D0, -0.35D0, -0.87D0, -0.62D0/
      DATA   Y( 43), Y( 44), Y( 45), Y( 46), Y( 47), Y( 48)
     +    / 0.28D0,  1.90D0,  2.14D0,  1.05D0,  0.31D0,  1.07D0/
      DATA   Y( 49), Y( 50)
     +    / 2.67D0,  2.44D0/
C
      CALL IPRINT(IPRT)
C
C     CHECK ERROR HANDLING
C
C        TEST 1  -  MISCELANEOUS ERROR CHECKING
C
      WRITE (IPRT, 2000)
      YMISS = 1.16D0
      LAGMAX = -1
      NY = -10
      LACOV = 101
      LYFFT = -11
      NW = -1
      NF = -5
      FMIN = 0.5D0
      FMAX = 0.0D0
      NPRT = -1
      ISPCF = -20
      LDS = 0
      WRITE(IPRT, 1001)
      CALL UFS (Y, NY)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1003)
      CALL UFSS(Y, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1019)
      CALL UFSF (YFFT, NY, LYFFT, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1020)
      CALL UFSFS(YFFT, NY, LYFFT, LDS, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   SPCF, ISPCF, FREQ)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1005)
      CALL UFSM (Y, YMISS, NY)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1006)
      CALL UFSMS(Y, YMISS, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1007)
      CALL UFSV(ACOV, LAGMAX, NY)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1008)
      CALL UFSVS (ACOV, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1021)
      CALL UFSMV(ACOV, NLPPA, LAGMAX, NY)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1022)
      CALL UFSMVS (ACOV, NLPPA, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C        TEST 2  -  MISCELANEOUS ERROR CHECKING (CONTINUED)
C
      WRITE (IPRT, 2010)
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 55
      LYFFT = -11
      NW = 2
      LAGS(1) = 0
      LAGS(2) = 50
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 3
      ISPCF = 20
      LDS = 0
      WRITE(IPRT, 1003)
      CALL UFSS(Y, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1019)
      CALL UFSF (YFFT, NY, LYFFT, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1020)
      CALL UFSFS(YFFT, NY, LYFFT, LDS, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   SPCF, ISPCF, FREQ)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1006)
      CALL UFSMS(Y, YMISS, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1008)
      CALL UFSVS (ACOV, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1022)
      CALL UFSMVS (ACOV, NLPPA, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C        TEST 3  -  LDS TOO SMALL
C
      WRITE (IPRT, 2030)
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      NW = 2
      LAGS(1) = 0
      LAGS(2) = 50
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 3
      ISPCF = 101
      LDS = 0
      WRITE(IPRT, 1003)
      CALL UFSS(Y, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1019)
      CALL UFSF (YFFT, NY, LYFFT, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1020)
      CALL UFSFS(YFFT, NY, LYFFT, LDS, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   SPCF, ISPCF, FREQ)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1006)
      CALL UFSMS(Y, YMISS, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1008)
      CALL UFSVS (ACOV, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1022)
      CALL UFSMVS (ACOV, NLPPA, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C        TEST 4  -  ALL DATA AND COVARIANCES MISSING
C
      WRITE (IPRT, 2040)
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 3
      ISPCF = 101
      LDS = 700
      CALL SETRV(YFFT, NY, YMISS)
      CALL SETRV(ACOV, LAGMAX, 0.0D0)
      DO 5 I = 1, LAGMAX
         NLPPA(I) = 0
    5 CONTINUE
      WRITE (IPRT, 1005)
      CALL UFSM(YFFT, YMISS, NY)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1006)
      CALL UFSMS(YFFT, YMISS, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1021)
      CALL UFSMV (ACOV, NLPPA, LAGMAX, NY)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1022)
      CALL UFSMVS (ACOV, NLPPA, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C        TEST 5  -  EVERY OTHER VALUE MISSING
C
      WRITE (IPRT, 2050)
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 3
      ISPCF = 101
      LDS = 700
      CALL SETRV(YFFT, NY, YMISS)
      DO 10 I = 1, NY, 2
         YFFT(I) = Y(I)
   10 CONTINUE
      WRITE (IPRT, 1005)
      CALL UFSM(YFFT, YMISS, NY)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1006)
      CALL UFSMS(YFFT, YMISS, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C     CHECK RESULTS FROM VALID CALL
C
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 2
      ISPCF = 101
      LDS = LDSTAK
C
C     TEST OF UFS
C
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1001)
      CALL UFS (Y, NY)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF UFSS
C
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1003)
      CALL UFSS(Y, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM UFSS
C
      WRITE (IPRT, 1004) (FREQ(I), (SPCF(I,J),J=1,NW), I=1,NF)
C
C     TEST OF UFSF
C
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1019)
      CALL DCOPY(NY, Y, 1, YFFT, 1)
      CALL UFSF (YFFT, NY, LYFFT, LDS)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF UFSFS
C
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1020)
      CALL DCOPY(NY, Y, 1, YFFT, 1)
      CALL UFSFS(YFFT, NY, LYFFT, LDS, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   SPCF, ISPCF, FREQ)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM UFSFS
C
      WRITE (IPRT, 1004) (FREQ(I), (SPCF(I,J),J=1,NW), I=1,NF)
C
C     TEST OF UFSM
C
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1005)
      CALL UFSM (Y, YMISS, NY)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF UFSMS
C
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1006)
      CALL UFSMS(Y, YMISS, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM UFSMS
C
      WRITE (IPRT, 1004) (FREQ(I), (SPCF(I,J),J=1,NW), I=1,NF)
C
C     TEST OF UFSV
C
      WRITE(IPRT, 2020)
      CALL ACFS (Y, NY, LAGMAX, LACOV, ACOV, IAR, PHI, 0, LDS)
      WRITE (IPRT, 1007)
      CALL UFSV(ACOV, LAGMAX, NY)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF UFSVS
C
      WRITE(IPRT, 2020)
      WRITE (IPRT, 1008)
      CALL UFSVS (ACOV, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM UFSVS
C
      WRITE (IPRT, 1004) (FREQ(I), (SPCF(I,J),J=1,NW), I=1,NF)
C
C     TEST OF UFSMV
C
      WRITE(IPRT, 2020)
      CALL ACFMS (Y, YMISS, NY, LAGMAX, LACOV, ACOV, AMISS, NLPPA,
     +   0, LDS)
      WRITE (IPRT, 1021)
      CALL UFSMV(ACOV, NLPPA, LAGMAX, NY)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF UFSMVS
C
      WRITE(IPRT, 2020)
      WRITE (IPRT, 1022)
      CALL UFSMVS (ACOV, NLPPA, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM UFSMVS
C
      WRITE (IPRT, 1004) (FREQ(I), (SPCF(I,J),J=1,NW), I=1,NF)
C
C     MINIMUM PROBLEM SIZE
C
      YMISS = 1.16D0
      NY = 17
      LAGMAX = 1
      LYFFT = 400
      NW = 2
      LAGS(1) = 1
      LAGS(2) = 16
      NF = 1
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 2
      ISPCF = 101
      LDS = 700
C
C     TEST OF UFS
C
      WRITE (IPRT, 2060)
      WRITE(IPRT, 1001)
      CALL UFS (Y, NY)
      WRITE (IPRT, 1002) IERR
C
C     TEST OF UFSS
C
      WRITE(IPRT, 2060)
      WRITE(IPRT, 1003)
      CALL UFSS(Y, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM UFSS
C
      WRITE (IPRT, 1004) (FREQ(I), (SPCF(I,J),J=1,NW), I=1,NF)
C
C     CHECK HANDLING OF FMIN AND FMAX
C
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 51
      FMIN = 0.45D0
      FMAX = 0.5D0
      NPRT = 2
      ISPCF = 101
      LDS = 700
C
C     TEST OF UFSS
C
      WRITE(IPRT, 2070)
      WRITE(IPRT, 1003)
      CALL UFSS(Y, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM UFSS
C
      WRITE (IPRT, 1004) (FREQ(I), (SPCF(I,J),J=1,NW), I=1,NF)
C
C     WHITE NOISE SPECTRUM
C
      YMISS = 1.16D0
      CALL NRAND(YFFT, NY, 12345)
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 2
      ISPCF = 101
      LDS = 700
C
C     TEST OF UFSS
C
      WRITE(IPRT, 2080)
      WRITE(IPRT, 1003)
      CALL UFSS(YFFT, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
C
C     PRINT RETURNED VALUES FROM UFSS
C
      WRITE (IPRT, 1004) (FREQ(I), (SPCF(I,J),J=1,NW), I=1,NF)
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1001 FORMAT (12H TEST OF UFS)
 1002 FORMAT (/8H IERR IS, I5/)
 1003 FORMAT (13H TEST OF UFSS)
 1004 FORMAT (3(1X, E16.8))
 1005 FORMAT (13H TEST OF UFSM)
 1006 FORMAT (14H TEST OF UFSMS)
 1007 FORMAT (13H TEST OF UFSV)
 1008 FORMAT (14H TEST OF UFSVS)
 1019 FORMAT (13H TEST OF UFSF)
 1020 FORMAT (14H TEST OF UFSFS)
 1021 FORMAT (14H TEST OF UFSMV)
 1022 FORMAT (15H TEST OF UFSMVS)
 2000 FORMAT (32H1CHECK ERROR HANDLING  -  TEST 1)
 2010 FORMAT (32H1CHECK ERROR HANDLING  -  TEST 2)
 2020 FORMAT (14H1VALID PROBLEM)
 2030 FORMAT (14H1LDS TOO SMALL)
 2040 FORMAT (33H1ALL DATA AND COVARIANCES MISSING)
 2050 FORMAT (31H1EVERY OTHER DATA VALUE MISSING)
 2060 FORMAT (21H1MINIMUM PROBLEM SIZE)
 2070 FORMAT (32H1CHECK HANDLING OF FMIN AND FMAX)
 2080 FORMAT (21H1WHITE NOISE SPECTRUM)
      END
*XVP
      SUBROUTINE XVP(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     ROUTINE TO TEST THE PLOTTING SUBROUTINES
C
C     SERIES Y IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND
C     JENKINS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JANUARY 21, 1982
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YMISS,YUB
      INTEGER
     +   IBAR,ILOG,IPRT,IRLIN,ISIZE,ITEST,IYM,M,NOUT,NS,NY,NYM
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AIR(144),Y(144),YM(12,12),YMMISS(144)
      INTEGER
     +   ISYM(144)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,MVP,MVPC,MVPL,MVPM,MVPMC,MVPML,DCOPY,SETRV,SVP,
     +   SVPC,SVPL,SVPM,SVPMC,SVPML,VP,VPC,VPL,VPM,VPMC,VPML
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (Y(1),YM(1,1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AIR(144)
C        THE AIRLINE DATA.
C     INTEGER IBAR
C        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .NE. 0)
C        OR BARS (IBAR .EQ. 0) ARE TO BE PLOTTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER ILOG
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
C     INTEGER IPRT
C        OUTPUT LOGICAL UNIT NUMBER
C     INTEGER IRLIN
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
C        NO REFERENCE LINE IS TO BE PLOTTED.
C        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
C        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
C        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
C     INTEGER ISIZE
C        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
C        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
C        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
C        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
C     INTEGER ISYM(144)
C        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
C     INTEGER ITEST
C        THE NUMBER OF THE TEST.
C     INTEGER IYM
C        ACTUAL DIMENSION OF YM IN USERS MAIN PROGRAM
C     INTEGER LDSTAK
C        *
C     INTEGER M
C        THE NUMBER OF VECTORS IN YM
C     INTEGER NS
C        THE SAMPLING FREQUENCY,
C        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
C                       = 2, EVERY OTHER POINT IS PLOTTED,
C                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
C     INTEGER NY, NYM
C        THE NUMBER OF OBSERVATIONS IN ARRAYS Y AND YM, RESPECTIVELY.
C     DOUBLE PRECISION XINC
C        THE INCREMENT FOR THE X AXIS.
C     DOUBLE PRECISION XLB
C        THE LOWER BOUND FOR THE X-AXIS.
C     DOUBLE PRECISION Y(144)
C        VECTOR OF OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES
C     DOUBLE PRECISION YLB
C        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C     DOUBLE PRECISION YM(12,12)
C        MULTIVARIATE OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES.
C     DOUBLE PRECISION YMISS
C        THE MISSING VALUE CODE FOR THE Y-AXIS.
C     DOUBLE PRECISION YMMISS(144)
C        THE MISSING VALUE CODES FOR EACH COLUMN OF YM.
C     DOUBLE PRECISION YUB
C        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
C        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
C
C
      DATA YMISS/180.0D0/
C
      DATA ISYM(  1),ISYM(  2),ISYM(  3),ISYM(  4),ISYM(  5),ISYM(  6)
     +    /    -5000,     6000,        7,        8,        9,       10/
      DATA ISYM(  7),ISYM(  8),ISYM(  9),ISYM( 10),ISYM( 11),ISYM( 12)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 13),ISYM( 14),ISYM( 15),ISYM( 16),ISYM( 17),ISYM( 18)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 19),ISYM( 20),ISYM( 21),ISYM( 22),ISYM( 23),ISYM( 24)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 25),ISYM( 26),ISYM( 27),ISYM( 28),ISYM( 29),ISYM( 30)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 31),ISYM( 32),ISYM( 33),ISYM( 34),ISYM( 35),ISYM( 36)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 37),ISYM( 38),ISYM( 39),ISYM( 40),ISYM( 41),ISYM( 42)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 43),ISYM( 44),ISYM( 45),ISYM( 46),ISYM( 47),ISYM( 48)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 49),ISYM( 50),ISYM( 51),ISYM( 52),ISYM( 53),ISYM( 54)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 55),ISYM( 56),ISYM( 57),ISYM( 58),ISYM( 59),ISYM( 60)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 61),ISYM( 62),ISYM( 63),ISYM( 64),ISYM( 65),ISYM( 66)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 67),ISYM( 68),ISYM( 69),ISYM( 70),ISYM( 71),ISYM( 72)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 73),ISYM( 74),ISYM( 75),ISYM( 76),ISYM( 77),ISYM( 78)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 79),ISYM( 80),ISYM( 81),ISYM( 82),ISYM( 83),ISYM( 84)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 85),ISYM( 86),ISYM( 87),ISYM( 88),ISYM( 89),ISYM( 90)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 91),ISYM( 92),ISYM( 93),ISYM( 94),ISYM( 95),ISYM( 96)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 97),ISYM( 98),ISYM( 99),ISYM(100),ISYM(101),ISYM(102)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM(103),ISYM(104),ISYM(105),ISYM(106),ISYM(107),ISYM(108)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM(109),ISYM(110),ISYM(111),ISYM(112),ISYM(113),ISYM(114)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM(115),ISYM(116),ISYM(117),ISYM(118),ISYM(119),ISYM(120)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM(121),ISYM(122),ISYM(123),ISYM(124),ISYM(125),ISYM(126)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM(127),ISYM(128),ISYM(129),ISYM(130),ISYM(131),ISYM(132)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM(133),ISYM(134),ISYM(135),ISYM(136),ISYM(137),ISYM(138)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM(139),ISYM(140),ISYM(141),ISYM(142),ISYM(143),ISYM(144)
     +    /       11,       12,       13,       14,       15,       16/
C
      DATA  AIR(  1), AIR(  2), AIR(  3), AIR(  4), AIR(  5), AIR(  6)
     +    / 112.0D0, 118.0D0, 132.0D0, 129.0D0, 121.0D0, 135.0D0/
      DATA  AIR(  7), AIR(  8), AIR(  9), AIR( 10), AIR( 11), AIR( 12)
     +    / 148.0D0, 148.0D0, 136.0D0, 119.0D0, 104.0D0, 118.0D0/
      DATA  AIR( 13), AIR( 14), AIR( 15), AIR( 16), AIR( 17), AIR( 18)
     +    / 115.0D0, 126.0D0, 141.0D0, 135.0D0, 125.0D0, 149.0D0/
      DATA  AIR( 19), AIR( 20), AIR( 21), AIR( 22), AIR( 23), AIR( 24)
     +    / 170.0D0, 170.0D0, 158.0D0, 133.0D0, 114.0D0, 140.0D0/
      DATA  AIR( 25), AIR( 26), AIR( 27), AIR( 28), AIR( 29), AIR( 30)
     +    / 145.0D0, 150.0D0, 178.0D0, 163.0D0, 172.0D0, 178.0D0/
      DATA  AIR( 31), AIR( 32), AIR( 33), AIR( 34), AIR( 35), AIR( 36)
     +    / 199.0D0, 199.0D0, 184.0D0, 162.0D0, 146.0D0, 166.0D0/
      DATA  AIR( 37), AIR( 38), AIR( 39), AIR( 40), AIR( 41), AIR( 42)
     +    / 171.0D0, 180.0D0, 193.0D0, 181.0D0, 183.0D0, 218.0D0/
      DATA  AIR( 43), AIR( 44), AIR( 45), AIR( 46), AIR( 47), AIR( 48)
     +    / 230.0D0, 242.0D0, 209.0D0, 191.0D0, 172.0D0, 194.0D0/
      DATA  AIR( 49), AIR( 50), AIR( 51), AIR( 52), AIR( 53), AIR( 54)
     +    / 196.0D0, 196.0D0, 236.0D0, 235.0D0, 229.0D0, 243.0D0/
      DATA  AIR( 55), AIR( 56), AIR( 57), AIR( 58), AIR( 59), AIR( 60)
     +    / 264.0D0, 272.0D0, 237.0D0, 211.0D0, 180.0D0, 201.0D0/
      DATA  AIR( 61), AIR( 62), AIR( 63), AIR( 64), AIR( 65), AIR( 66)
     +    / 204.0D0, 188.0D0, 235.0D0, 227.0D0, 234.0D0, 264.0D0/
      DATA  AIR( 67), AIR( 68), AIR( 69), AIR( 70), AIR( 71), AIR( 72)
     +    / 302.0D0, 293.0D0, 259.0D0, 229.0D0, 203.0D0, 229.0D0/
      DATA  AIR( 73), AIR( 74), AIR( 75), AIR( 76), AIR( 77), AIR( 78)
     +    / 242.0D0, 233.0D0, 267.0D0, 269.0D0, 270.0D0, 315.0D0/
      DATA  AIR( 79), AIR( 80), AIR( 81), AIR( 82), AIR( 83), AIR( 84)
     +    / 364.0D0, 347.0D0, 312.0D0, 274.0D0, 237.0D0, 278.0D0/
      DATA  AIR( 85), AIR( 86), AIR( 87), AIR( 88), AIR( 89), AIR( 90)
     +    / 284.0D0, 277.0D0, 317.0D0, 313.0D0, 318.0D0, 374.0D0/
      DATA  AIR( 91), AIR( 92), AIR( 93), AIR( 94), AIR( 95), AIR( 96)
     +    / 413.0D0, 405.0D0, 355.0D0, 306.0D0, 271.0D0, 306.0D0/
      DATA  AIR( 97), AIR( 98), AIR( 99), AIR(100), AIR(101), AIR(102)
     +    / 315.0D0, 301.0D0, 356.0D0, 348.0D0, 355.0D0, 422.0D0/
      DATA  AIR(103), AIR(104), AIR(105), AIR(106), AIR(107), AIR(108)
     +    / 465.0D0, 467.0D0, 404.0D0, 347.0D0, 305.0D0, 336.0D0/
      DATA  AIR(109), AIR(110), AIR(111), AIR(112), AIR(113), AIR(114)
     +    / 340.0D0, 318.0D0, 362.0D0, 348.0D0, 363.0D0, 435.0D0/
      DATA  AIR(115), AIR(116), AIR(117), AIR(118), AIR(119), AIR(120)
     +    / 491.0D0, 505.0D0, 404.0D0, 359.0D0, 310.0D0, 337.0D0/
      DATA  AIR(121), AIR(122), AIR(123), AIR(124), AIR(125), AIR(126)
     +    / 360.0D0, 342.0D0, 406.0D0, 396.0D0, 420.0D0, 472.0D0/
      DATA  AIR(127), AIR(128), AIR(129), AIR(130), AIR(131), AIR(132)
     +    / 548.0D0, 559.0D0, 463.0D0, 407.0D0, 362.0D0, 405.0D0/
      DATA  AIR(133), AIR(134), AIR(135), AIR(136), AIR(137), AIR(138)
     +    / 417.0D0, 391.0D0, 419.0D0, 461.0D0, 472.0D0, 535.0D0/
      DATA  AIR(139), AIR(140), AIR(141), AIR(142), AIR(143), AIR(144)
     +    / 622.0D0, 606.0D0, 508.0D0, 461.0D0, 390.0D0, 432.0D0/
C
      CALL SETRV(YMMISS, 144, YMISS)
      CALL DCOPY(144, AIR, 1, Y, 1)
C
C     DEFINE CONSTANTS
C
      CALL IPRINT(IPRT)
C
C     COMMENCE BODY OF ROUTINE
C
      ITEST = 0
C
C     SHORT CALLS
C
      NY = 144
      NYM = 12
      IYM = 12
      M = 12
      NS = 1
      ILOG = -1
      ISIZE = -1
      ISIZE = -1
      IRLIN = -1
      IBAR = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XINC = 0.0D0
C
   10 CONTINUE
C
C     TEST OF VP
C
      WRITE(IPRT, 2000)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      CALL VP(Y, NY, NS)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF VPM
C
      WRITE(IPRT, 2030)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      CALL VPM (Y, YMISS, NY, NS)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF SVP
C
      WRITE(IPRT, 2120)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      CALL SVP (Y, NY, NS, ISYM)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF SVPM
C
      WRITE(IPRT, 2150)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      CALL SVPM (Y, YMISS, NY, NS, ISYM)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF MVP
C
      WRITE(IPRT, 2060)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3030) NS
      CALL MVP (YM, NYM, M, IYM, NS)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF MVPM
C
      WRITE(IPRT, 2090)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3030) NS
      CALL MVPM (YM, YMMISS, NYM, M, IYM, NS)
      WRITE (IPRT, 3000) IERR
C
C     LOG OPTION CALLS
C
   20 CONTINUE
C
C     TEST OF VPL
C
      WRITE(IPRT, 2010)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      CALL VPL (Y, NY, NS, ILOG)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF VPML
C
      WRITE(IPRT, 2040)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      CALL VPML (Y, YMISS, NY, NS, ILOG)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF SVPL
C
      WRITE(IPRT, 2130)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      CALL SVPL (Y, NY, NS, ISYM, ILOG)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF SVPML
C
      WRITE(IPRT, 2160)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      CALL SVPML (Y, YMISS, NY, NS, ISYM, ILOG)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF MVPL
C
      WRITE(IPRT, 2070)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      CALL MVPL (YM, NYM, M, IYM, NS, ILOG)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF MVPML
C
      WRITE(IPRT, 2100)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      CALL MVPML(YM, YMMISS, NYM, M, IYM, NS, ILOG)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF LONG CALLS
C
   30 CONTINUE
C
C     TEST OF VPC
C
      WRITE(IPRT, 2020)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3060) ISIZE, IRLIN, IBAR
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3090) XINC
      CALL VPC (Y, NY, NS, ILOG, ISIZE, IRLIN, IBAR, YLB,
     +   YUB, XLB, XINC)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF VPMC
C
      WRITE(IPRT, 2050)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3060) ISIZE, IRLIN, IBAR
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3090) XINC
      CALL VPMC (Y, YMISS, NY, NS, ILOG, ISIZE, IRLIN, IBAR, YLB,
     +   YUB, XLB, XINC)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF SVPC
C
      WRITE(IPRT, 2140)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3060) ISIZE, IRLIN, IBAR
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3090) XINC
      CALL SVPC (Y, NY, NS, ISYM, ILOG, ISIZE, IRLIN, IBAR, YLB,
     +   YUB, XLB, XINC)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF SVPMC
C
      WRITE(IPRT, 2170)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3060) ISIZE, IRLIN, IBAR
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3090) XINC
      CALL SVPMC(Y, YMISS, NY, NS, ISYM, ILOG, ISIZE, IRLIN, IBAR,
     +   YLB, YUB, XLB, XINC)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF MVPC
C
   40 WRITE(IPRT, 2080)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3060) ISIZE, IRLIN, IBAR
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3090) XINC
      CALL MVPC(YM, NYM, M, IYM, NS, ILOG, ISIZE, YLB,
     +   YUB, XLB, XINC)
      WRITE (IPRT, 3000) IERR
C
C     TEST OF MVPMC
C
   50 WRITE(IPRT, 2110)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3060) ISIZE, IRLIN, IBAR
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3090) XINC
      CALL MVPMC(YM, YMMISS, NYM, M, IYM, NS, ILOG, ISIZE, YLB,
     +   YUB, XLB, XINC)
      WRITE (IPRT, 3000) IERR
C
      ITEST = ITEST + 1
C
      GO TO (110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 300),
     +  ITEST
C
C     TEST VALID OPTIONS
C
  110 ILOG = 0
      ISIZE = 0
      YLB = 100.0D0
      YUB = 700.0D0
      XLB = 4.0D0
      XINC = 16.0D0
      GO TO 20
C
  120 ILOG = 2
      ISIZE = 2
      NOUT = 5
      XINC = -1.0D0
      GO TO 20
C
  130 ILOG = 20
      ISIZE = 20
      NOUT = 55
      YUB = 300.0D0
      GO TO 30
C
  140 ILOG = 22
      ISIZE = 22
      GO TO 40
C
  150 NY = 1
      NYM = 1
      M = 144
      IYM = 1
      GO TO 40
C
  160 CALL SETRV(Y, 144, 1.0D0)
      NYM = 6
      IYM = 12
      M = 6
      NY = 36
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XINC = 0.0D0
      GO TO 30
C
C     TEST ERROR RESPONSE
C
  170 NY = 0
      NYM = 0
      M = 0
      IYM = -1
      GO TO 10
C
  180 NY = 144
      NYM = 12
      M = 12
      IYM = -1
      XLB = -1.0D0
      YLB = -1.0D0
      GO TO 40
C
  190 IYM = 12
      Y(1) = 0.0D0
      GO TO 50
C
  200 CALL SETRV(Y, 144, YMISS)
      XLB = XINC
      YLB = YUB
      GO TO 50
C
  300 CONTINUE
C
      RETURN
C
C     FORMAT STATEMENTS
C
 2000 FORMAT ('1', 10HTEST OF VP)
 2010 FORMAT ('1', 11HTEST OF VPL)
 2020 FORMAT ('1', 11HTEST OF VPC)
 2030 FORMAT ('1', 11HTEST OF VPM)
 2040 FORMAT ('1', 12HTEST OF VPML)
 2050 FORMAT ('1', 12HTEST OF VPMC)
 2060 FORMAT ('1', 11HTEST OF MVP)
 2070 FORMAT ('1', 12HTEST OF MVPL)
 2080 FORMAT ('1', 12HTEST OF MVPC)
 2090 FORMAT ('1', 12HTEST OF MVPM)
 2100 FORMAT ('1', 13HTEST OF MVPML)
 2110 FORMAT ('1', 13HTEST OF MVPMC)
 2120 FORMAT ('1', 11HTEST OF SVP)
 2130 FORMAT ('1', 12HTEST OF SVPL)
 2140 FORMAT ('1', 12HTEST OF SVPC)
 2150 FORMAT ('1', 12HTEST OF SVPM)
 2160 FORMAT ('1', 13HTEST OF SVPML)
 2170 FORMAT ('1', 13HTEST OF SVPMC)
 3000 FORMAT (/8H IERR = , I4)
 3010 FORMAT (' ', 5X, 10H   N     =, I5)
 3020 FORMAT ('+', 20X, 10H / M     =, I5, 10H / IYM   =, I5)
 3030 FORMAT ('+', 50X, 10H / NS    =, I5)
 3040 FORMAT ('+', 65X, 10H / ILOG  =, I5)
 3060 FORMAT (' ',  5X, '   ISIZE=', I5, ' / IRLIN=', I5,
     +   10H / IBAR  =, I5)
 3070 FORMAT ('+', 50X, 10H / YLB   =, F10.4, 10H / YUB   =, F10.4,
     +   10H / XLB   =, F10.4)
 3090 FORMAT ('+', 110X, 10H / XINC  =, F10.4)
 3100 FORMAT (' ', 13H TEST NUMBER , I5)
      END
*XXCH1
      SUBROUTINE XXCH1(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
C     THE PAGE PLOT AND STATISTICAL ANALYSIS FAMILIES OF ROUTINES.
C
C     DATA SET IS 84 RELATIVE HUMIDITY MEASUREMEMTS FROM PIKES PEAK.
C
C     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  AUGUST 3, 1987
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT,N
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   X(100),Y(100)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PP,STAT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IERR
C        ERROR FLAG
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT.
C     INTEGER LDSTAK
C        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
C     INTEGER N
C        THE LENGTH OF THE VECTOR Y.
C     DOUBLE PRECISION X(100)
C        THE ORDER INDICES OF THE DATA.
C     DOUBLE PRECISION Y(100)
C        DATA VECTOR FOR TESTS.
C
C
      DATA N /84/
C
      DATA Y( 1), Y( 2), Y( 3), Y( 4)
     +    / 0.6067D0, 0.6087D0, 0.6086D0, 0.6134D0/
      DATA Y( 5), Y( 6), Y( 7)
     +    / 0.6108D0, 0.6138D0, 0.6125D0/
      DATA Y( 8), Y( 9), Y(10), Y(11)
     +    / 0.6122D0, 0.6110D0, 0.6104D0, 0.7213D0/
      DATA Y(12), Y(13), Y(14)
     +    / 0.7078D0, 0.7021D0, 0.7004D0/
      DATA Y(15), Y(16), Y(17), Y(18)
     +    / 0.6981D0, 0.7242D0, 0.7268D0, 0.7418D0/
      DATA Y(19), Y(20), Y(21)
     +    / 0.7407D0, 0.7199D0, 0.6225D0/
      DATA Y(22), Y(23), Y(24), Y(25)
     +    / 0.6254D0, 0.6252D0, 0.6267D0, 0.6218D0/
      DATA Y(26), Y(27), Y(28)
     +    / 0.6178D0, 0.6216D0, 0.6192D0/
      DATA Y(29), Y(30), Y(31), Y(32)
     +    / 0.6191D0, 0.6250D0, 0.6188D0, 0.6233D0/
      DATA Y(33), Y(34), Y(35)
     +    / 0.6225D0, 0.6204D0, 0.6207D0/
      DATA Y(36), Y(37), Y(38), Y(39)
     +    / 0.6168D0, 0.6141D0, 0.6291D0, 0.6231D0/
      DATA Y(40), Y(41), Y(42)
     +    / 0.6222D0, 0.6252D0, 0.6308D0/
      DATA Y(43), Y(44), Y(45), Y(46)
     +    / 0.6376D0, 0.6330D0, 0.6303D0, 0.6301D0/
      DATA Y(47), Y(48), Y(49)
     +    / 0.6390D0, 0.6423D0, 0.6300D0/
      DATA Y(50), Y(51), Y(52), Y(53)
     +    / 0.6260D0, 0.6292D0, 0.6298D0, 0.6290D0/
      DATA Y(54), Y(55), Y(56)
     +    / 0.6262D0, 0.5952D0, 0.5951D0/
      DATA Y(57), Y(58), Y(59), Y(60)
     +    / 0.6314D0, 0.6440D0, 0.6439D0, 0.6326D0/
      DATA Y(61), Y(62), Y(63)
     +    / 0.6392D0, 0.6417D0, 0.6412D0/
      DATA Y(64), Y(65), Y(66), Y(67)
     +    / 0.6530D0, 0.6411D0, 0.6355D0, 0.6344D0/
      DATA Y(68), Y(69), Y(70)
     +    / 0.6623D0, 0.6276D0, 0.6307D0/
      DATA Y(71), Y(72), Y(73), Y(74)
     +    / 0.6354D0, 0.6197D0, 0.6153D0, 0.6340D0/
      DATA Y(75), Y(76), Y(77)
     +    / 0.6338D0, 0.6284D0, 0.6162D0/
      DATA Y(78), Y(79), Y(80), Y(81)
     +    / 0.6252D0, 0.6349D0, 0.6344D0, 0.6361D0/
      DATA Y(82), Y(83), Y(84)
     +    / 0.6373D0, 0.6337D0, 0.6383D0/
C
C     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
C
      CALL IPRINT(IPRT)
C
      DO 10 I=1,N
         X(I) = I
   10 CONTINUE
C
C     PRINT HEADING
C
      WRITE (IPRT,1000)
C
C     PERFORM SIMPLE TEST OF PP
C
      WRITE (IPRT,1100)
      CALL PP(Y, X, N)
      WRITE (IPRT,2000) IERR
C
C     PERFORM SIMPLE TEST OF STAT
C
      WRITE (IPRT,1200)
      CALL STAT(Y, N, LDSTAK)
      WRITE (IPRT,2000) IERR
C
      RETURN
C
C     FORMATS
C
 1000 FORMAT ('1*CH1')
 1100 FORMAT (' SIMPLE TEST OF PP')
 1200 FORMAT ('1SIMPLE TEST OF STAT')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
*XXCH2
      SUBROUTINE XXCH2(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
C     THE PAGE PLOT FAMILY OF ROUTINES.
C
C     DATA IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND JENKINS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  JULY 22, 1987
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,IYM,M,N
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AIR(144),X(12),YM(12,12)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,MPP
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (AIR(1),YM(1,1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AIR(144)
C        THE AIRLINE DATA.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT.
C     INTEGER IYM
C        THE EXACT VALUE OF THE FIRST DIMENSION OF THE MATRIX YM.
C     INTEGER LDSTAK
C        A DUMMY VARIABLE FOR THIS TEST SUBPROGRAM.
C     INTEGER M
C        THE NUMBER OF COLUMNS OF DATA IN YM.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN EACH COLUMN OF YM.
C     DOUBLE PRECISION X(12)
C        VECTOR OF OBSERVATIONS FOR X(HORIZONTAL) COORDINATES
C     DOUBLE PRECISION YM(12,12)
C        MULTIVARIATE OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES.
C
C
      DATA    X(  1),   X(  2),   X(  3),   X(  4),   X(  5),   X(  6)
     +    /   1.0D0,    2.0D0,    3.0D0,    4.0D0,    5.0D0,    6.0D0/
      DATA    X(  7),   X(  8),   X(  9),   X( 10),   X( 11),   X( 12)
     +    /   7.0D0,    8.0D0,    9.0D0,   10.0D0,   11.0D0,   12.0D0/
C
      DATA  AIR(  1), AIR(  2), AIR(  3), AIR(  4), AIR(  5), AIR(  6)
     +    / 112.0D0,  118.0D0,  132.0D0,  129.0D0,  121.0D0,  135.0D0/
      DATA  AIR(  7), AIR(  8), AIR(  9), AIR( 10), AIR( 11), AIR( 12)
     +    / 148.0D0,  148.0D0,  136.0D0,  119.0D0,  104.0D0,  118.0D0/
      DATA  AIR( 13), AIR( 14), AIR( 15), AIR( 16), AIR( 17), AIR( 18)
     +    / 115.0D0,  126.0D0,  141.0D0,  135.0D0,  125.0D0,  149.0D0/
      DATA  AIR( 19), AIR( 20), AIR( 21), AIR( 22), AIR( 23), AIR( 24)
     +    / 170.0D0,  170.0D0,  158.0D0,  133.0D0,  114.0D0,  140.0D0/
      DATA  AIR( 25), AIR( 26), AIR( 27), AIR( 28), AIR( 29), AIR( 30)
     +    / 145.0D0,  150.0D0,  178.0D0,  163.0D0,  172.0D0,  178.0D0/
      DATA  AIR( 31), AIR( 32), AIR( 33), AIR( 34), AIR( 35), AIR( 36)
     +    / 199.0D0,  199.0D0,  184.0D0,  162.0D0,  146.0D0,  166.0D0/
      DATA  AIR( 37), AIR( 38), AIR( 39), AIR( 40), AIR( 41), AIR( 42)
     +    / 171.0D0,  180.0D0,  193.0D0,  181.0D0,  183.0D0,  218.0D0/
      DATA  AIR( 43), AIR( 44), AIR( 45), AIR( 46), AIR( 47), AIR( 48)
     +    / 230.0D0,  242.0D0,  209.0D0,  191.0D0,  172.0D0,  194.0D0/
      DATA  AIR( 49), AIR( 50), AIR( 51), AIR( 52), AIR( 53), AIR( 54)
     +    / 196.0D0,  196.0D0,  236.0D0,  235.0D0,  229.0D0,  243.0D0/
      DATA  AIR( 55), AIR( 56), AIR( 57), AIR( 58), AIR( 59), AIR( 60)
     +    / 264.0D0,  272.0D0,  237.0D0,  211.0D0,  180.0D0,  201.0D0/
      DATA  AIR( 61), AIR( 62), AIR( 63), AIR( 64), AIR( 65), AIR( 66)
     +    / 204.0D0,  188.0D0,  235.0D0,  227.0D0,  234.0D0,  264.0D0/
      DATA  AIR( 67), AIR( 68), AIR( 69), AIR( 70), AIR( 71), AIR( 72)
     +    / 302.0D0,  293.0D0,  259.0D0,  229.0D0,  203.0D0,  229.0D0/
      DATA  AIR( 73), AIR( 74), AIR( 75), AIR( 76), AIR( 77), AIR( 78)
     +    / 242.0D0,  233.0D0,  267.0D0,  269.0D0,  270.0D0,  315.0D0/
      DATA  AIR( 79), AIR( 80), AIR( 81), AIR( 82), AIR( 83), AIR( 84)
     +    / 364.0D0,  347.0D0,  312.0D0,  274.0D0,  237.0D0,  278.0D0/
      DATA  AIR( 85), AIR( 86), AIR( 87), AIR( 88), AIR( 89), AIR( 90)
     +    / 284.0D0,  277.0D0,  317.0D0,  313.0D0,  318.0D0,  374.0D0/
      DATA  AIR( 91), AIR( 92), AIR( 93), AIR( 94), AIR( 95), AIR( 96)
     +    / 413.0D0,  405.0D0,  355.0D0,  306.0D0,  271.0D0,  306.0D0/
      DATA  AIR( 97), AIR( 98), AIR( 99), AIR(100), AIR(101), AIR(102)
     +    / 315.0D0,  301.0D0,  356.0D0,  348.0D0,  355.0D0,  422.0D0/
      DATA  AIR(103), AIR(104), AIR(105), AIR(106), AIR(107), AIR(108)
     +    / 465.0D0,  467.0D0,  404.0D0,  347.0D0,  305.0D0,  336.0D0/
      DATA  AIR(109), AIR(110), AIR(111), AIR(112), AIR(113), AIR(114)
     +    / 340.0D0,  318.0D0,  362.0D0,  348.0D0,  363.0D0,  435.0D0/
      DATA  AIR(115), AIR(116), AIR(117), AIR(118), AIR(119), AIR(120)
     +    / 491.0D0,  505.0D0,  404.0D0,  359.0D0,  310.0D0,  337.0D0/
      DATA  AIR(121), AIR(122), AIR(123), AIR(124), AIR(125), AIR(126)
     +    / 360.0D0,  342.0D0,  406.0D0,  396.0D0,  420.0D0,  472.0D0/
      DATA  AIR(127), AIR(128), AIR(129), AIR(130), AIR(131), AIR(132)
     +    / 548.0D0,  559.0D0,  463.0D0,  407.0D0,  362.0D0,  405.0D0/
      DATA  AIR(133), AIR(134), AIR(135), AIR(136), AIR(137), AIR(138)
     +    / 417.0D0,  391.0D0,  419.0D0,  461.0D0,  472.0D0,  535.0D0/
      DATA  AIR(139), AIR(140), AIR(141), AIR(142), AIR(143), AIR(144)
     +    / 622.0D0,  606.0D0,  508.0D0,  461.0D0,  390.0D0,  432.0D0/
C
C     DEFINE CONSTANTS
C
      CALL IPRINT(IPRT)
      IYM = 12
      N = 12
      M = 12
C
C     WRITE HEADER
C
      WRITE(IPRT, 1000)
C
C     RUN SIMPLE TEST OF MPP
C
      WRITE(IPRT, 1100)
      CALL MPP(YM, X, N, M, IYM)
      WRITE (IPRT,2000) IERR
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT ('1*CH2')
 1100 FORMAT (' SIMPLE TEST OF MPP')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
*XXCH3
      SUBROUTINE XXCH3(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
C     THE NORMAL RANDOM NUMBER GENERATOR FAMILY OF ROUTINES.
C
C     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  AUGUST 3, 1987
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   SIGMA,YMEAN
      INTEGER
     +   I,IPRT,ISEED,IYM,M,N
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YM(50,2)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,MVP,NRAND,NRANDC
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IERR
C        FLAG TO INDICATE PRESENCE OF ERROR DETECTED BY PRECEDING
C        STARPAC CALL.  (0 IS OK, 1 IS ERROR)
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT.
C     INTEGER ISEED
C        THE SEED FOR THE RANDOM NUMBER GENERATOR.
C     INTEGER IYM
C        THE EXACT VALUE OF THE FIRST DIMENSION OF ARRAY YM.
C     INTEGER LDSTAK
C        A DUMMY VARIABLE FOR THIS TEST SUBPROGRAM.
C     INTEGER M
C        THE NUMBER OF SETS OF NUMBERS TO BE GENERATED
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS TO BE GENERATED.
C     DOUBLE PRECISION SIGMA
C        THE S.D. OF THE SAMPLE.
C     DOUBLE PRECISION YM(50,2)
C        DATA VECTOR FOR TESTS.
C     DOUBLE PRECISION YMEAN
C        THE MEAN OF THE SAMPLE.
C
C
C     DATA INITIALIZATION
C
      IYM = 50
      ISEED = 531
      N = 50
      M = 2
      YMEAN = 4.0D0
      SIGMA = 0.5D0
C
C     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
C
      CALL IPRINT(IPRT)
C
C     WRITE HEADING
C
      WRITE (IPRT,1000)
C
C     GENERATE STANDARD NORMAL PSEUDO-RANDOM NUMBERS INTO COLUMN 1 OF YM
C
      WRITE (IPRT,1100)
      CALL NRAND(YM(1,1), N, ISEED)
      WRITE (IPRT,2000) IERR
      WRITE (IPRT, 1400) (YM(I,1),I=1,N)
C
C     GENERATE NORMAL PSEUDO-RANDOM NUMBERS
C     WITH MEAN 4.0 AND STANDARD DEVIATION 0.5 INTO COLUMN 2 OF YM
C
      WRITE (IPRT,1200)
      CALL NRANDC(YM(1,2), N, ISEED, YMEAN, SIGMA)
      WRITE (IPRT,2000) IERR
      WRITE (IPRT, 1400) (YM(I,2),I=1,N)
C
C     PLOT RESULTS, SAMPLING EVERY OBSERVATION
C
      WRITE (IPRT,1500)
      CALL MVP (YM, N, M, IYM, 1)
C
      RETURN
C
C     FORMATS
C
 1000 FORMAT ('1*CH3')
 1100 FORMAT (' SIMPLE TEST OF NRAND')
 1200 FORMAT ('1SIMPLE TEST OF NRANDC')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
 1400 FORMAT (/' GENERATED RESULTS = '//(5E15.8))
 1500 FORMAT ('1MVP DISPLAY OF GENERATED RESULTS')
      END
*XXCH4
      SUBROUTINE XXCH4(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
C     THE HISTOGRAM FAMILY OF ROUTINES.
C
C     DATA SET IS FROM PAGE 39 OF MANDEL [1964]
C
C     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  AUGUST 3, 1987
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,N
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   Y(40)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL HIST,IPRINT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        ERROR FLAG
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT.
C     INTEGER LDSTAK
C        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
C     INTEGER N
C        THE LENGTH OF THE VECTOR Y.
C     DOUBLE PRECISION Y(40)
C        DATA VECTOR FOR TESTS.
C
C
C     DATA INITIALIZATIONS.
C
      DATA N /39/
C
      DATA Y( 1), Y( 2), Y( 3), Y( 4)
     +    / 0.4, 0.6, 1.0, 1.0/
      DATA Y( 5), Y( 6), Y( 7), Y( 8)
     +    / 1.0, 0.5, 0.6, 0.7/
      DATA Y( 9), Y(10), Y(11), Y(12)
     +    / 1.0, 0.6, 0.2, 1.9/
      DATA Y(13), Y(14), Y(15), Y(16)
     +    / 0.2, 0.4, 0.0, -0.4/
      DATA Y(17), Y(18), Y(19), Y(20)
     +    / -0.3, 0.0, -0.4, -0.3/
      DATA Y(21), Y(22), Y(23), Y(24)
     +    / 0.1, -0.1, 0.2, -0.5/
      DATA Y(25), Y(26), Y(27), Y(28)
     +    / 0.3, -0.1, 0.2, -0.2/
      DATA Y(29), Y(30), Y(31), Y(32)
     +    / 0.8, 0.5, 0.6, 0.8/
      DATA Y(33), Y(34), Y(35), Y(36)
     +    / 0.7, 0.7, 0.2, 0.5/
      DATA Y(37), Y(38), Y(39)
     +    / 0.7, 0.8, 1.1/
C
C     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
C
      CALL IPRINT(IPRT)
C
C     PRINT HEADING
C
      WRITE (IPRT,1000)
C
C     PERFORM SIMPLE TEST OF HIST
C
      WRITE (IPRT,1100)
      CALL HIST(Y, N, LDSTAK)
      WRITE (IPRT,2000) IERR
C
      RETURN
C
C     FORMATS
C
 1000 FORMAT ('1*CH4')
 1100 FORMAT (' SIMPLE TEST OF HIST')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
*XXCH5
      SUBROUTINE XXCH5(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
C     THE STATISTICAL ANALYSIS FAMILY OF ROUTINES.
C
C     DATA SET IS FROM PAGE 39 OF MANDEL [1964]
C
C     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  AUGUST 3, 1987
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,N
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   Y(40)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,STAT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        ERROR FLAG
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT.
C     INTEGER LDSTAK
C        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
C     INTEGER N
C        THE LENGTH OF THE VECTOR Y.
C     DOUBLE PRECISION Y(40)
C        DATA VECTOR FOR TESTS.
C
C     DATA INITIALIZATIONS.
C
      DATA N /39/
C
      DATA Y( 1), Y( 2), Y( 3), Y( 4)
     +    / 0.4, 0.6, 1.0, 1.0/
      DATA Y( 5), Y( 6), Y( 7), Y( 8)
     +    / 1.0, 0.5, 0.6, 0.7/
      DATA Y( 9), Y(10), Y(11), Y(12)
     +    / 1.0, 0.6, 0.2, 1.9/
      DATA Y(13), Y(14), Y(15), Y(16)
     +    / 0.2, 0.4, 0.0, -0.4/
      DATA Y(17), Y(18), Y(19), Y(20)
     +    / -0.3, 0.0, -0.4, -0.3/
      DATA Y(21), Y(22), Y(23), Y(24)
     +    / 0.1, -0.1, 0.2, -0.5/
      DATA Y(25), Y(26), Y(27), Y(28)
     +    / 0.3, -0.1, 0.2, -0.2/
      DATA Y(29), Y(30), Y(31), Y(32)
     +    / 0.8, 0.5, 0.6, 0.8/
      DATA Y(33), Y(34), Y(35), Y(36)
     +    / 0.7, 0.7, 0.2, 0.5/
      DATA Y(37), Y(38), Y(39)
     +    / 0.7, 0.8, 1.1/
C
C     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
C
      CALL IPRINT(IPRT)
C
C     PRINT HEADING
C
      WRITE (IPRT,1000)
C
C     PERFORM SIMPLE TEST OF STAT
C
      WRITE (IPRT,1100)
      CALL STAT(Y, N, LDSTAK)
      WRITE (IPRT,2000) IERR
C
      RETURN
C
C     FORMATS
C
 1000 FORMAT ('1*CH5')
 1100 FORMAT (' SIMPLE TEST OF STAT')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
*XXCH6
      SUBROUTINE XXCH6(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
C     THE ONEWAY ANALYSIS OF VARIANCE FAMILY OF ROUTINES.
C
C     DATA SET IS FROM PAGES 314-316 OF BRWONLEE [1965].
C
C     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  AUGUST 3, 1987
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,N
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   TAG(20),Y(20)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AOV1,IPRINT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        ERROR FLAG
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT.
C     INTEGER LDSTAK
C        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
C     INTEGER N
C        THE LENGTH OF THE VECTOR Y.
C     DOUBLE PRECISION TAG(20)
C        THE TAG VALUES FOR EACH OBSERVATION
C     DOUBLE PRECISION Y(20)
C        DATA VECTOR FOR TESTS.
C
C
C     DATA INITIALIZATIONS.
C
      DATA N /16/
C
      DATA Y( 1), Y( 2), Y( 3), Y( 4)
     +    / 83.0, 81.0, 76.0, 78.0/
      DATA Y( 5), Y( 6), Y( 7), Y( 8)
     +    / 79.0, 72.0, 61.0, 61.0/
      DATA Y( 9), Y(10), Y(11), Y(12)
     +    / 67.0, 67.0, 64.0, 78.0/
      DATA Y(13), Y(14), Y(15), Y(16)
     +    / 71.0, 75.0, 72.0, 74.0/
C
      DATA TAG( 1), TAG( 2), TAG( 3), TAG( 4)
     +    / 1.0, 1.0, 1.0, 1.0/
      DATA TAG( 5), TAG( 6), TAG( 7), TAG( 8)
     +    / 1.0, 1.0, 2.0, 2.0/
      DATA TAG( 9), TAG(10), TAG(11), TAG(12)
     +    / 2.0, 2.0, 2.0, 3.0/
      DATA TAG(13), TAG(14), TAG(15), TAG(16)
     +    / 3.0, 3.0, 3.0, 3.0/
C
C     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
C
      CALL IPRINT(IPRT)
C
C     PRINT HEADING
C
      WRITE (IPRT,1000)
C
C     PERFORM SIMPLE TEST OF AOV1
C
      WRITE (IPRT,1100)
      CALL AOV1(Y, TAG, N, LDSTAK)
      WRITE (IPRT,2000) IERR
C
      RETURN
C
C     FORMATS
C
 1000 FORMAT ('1*CH6')
 1100 FORMAT (' SIMPLE TEST OF AOV1')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
*XXCH7
      SUBROUTINE XXCH7(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     TEST SUBPROGRAM FOR SIMPLE TEST OF
C     THE CORRELATION ANALYSIS FAMILY OF ROUTINES.
C
C     DATA IS FROM DRAPER AND SMITH [1968], PAGE 216.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  AUGUST 3, 1987
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,IYM,M,N
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YM(10,5)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL CORR,IPRINT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
C        DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT.
C     INTEGER IYM
C        THE FIRST DIMENSION OF THE ARRAY YM.
C     INTEGER LDSTAK
C        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
C     INTEGER M
C        THE NUMBER OF VARIABLES MEASURED FOR EACH OBSERVATION.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     DOUBLE PRECISION YM(10,5)
C        THE OBSERVED MULTIVARIATE DATA.
C
C
      DATA     YM(1,1),   YM(1,2),   YM(1,3),   YM(1,4)
     +    /      42.2D0,  11.2D0,  31.9D0, 167.1D0/
      DATA     YM(2,1),   YM(2,2),   YM(2,3),   YM(2,4)
     +    /      48.6D0,  10.6D0,  13.2D0, 174.4D0/
      DATA     YM(3,1),   YM(3,2),   YM(3,3),   YM(3,4)
     +    /      42.6D0,  10.6D0,  28.7D0, 160.8D0/
      DATA     YM(4,1),   YM(4,2),   YM(4,3),   YM(4,4)
     +    /      39.0D0,  10.4D0,  26.1D0, 162.0D0/
      DATA     YM(5,1),   YM(5,2),   YM(5,3),   YM(5,4)
     +    /      34.7D0,   9.3D0,  30.1D0, 140.8D0/
      DATA     YM(6,1),   YM(6,2),   YM(6,3),   YM(6,4)
     +    /      44.5D0,  10.8D0,   8.5D0, 174.6D0/
      DATA     YM(7,1),   YM(7,2),   YM(7,3),   YM(7,4)
     +    /      39.1D0,  10.7D0,  24.3D0, 163.7D0/
      DATA     YM(8,1),   YM(8,2),   YM(8,3),   YM(8,4)
     +    /      40.1D0,  10.0D0,  18.6D0, 174.5D0/
      DATA     YM(9,1),   YM(9,2),   YM(9,3),   YM(9,4)
     +    /      45.9D0,  12.0D0,  20.4D0, 185.7D0/
C
C
C     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
C
      CALL IPRINT(IPRT)
      IYM = 10
      N = 9
      M = 4
C
C     PRINT HEADER
C
      WRITE (IPRT,1000)
C
C     RUN SIMPLE EXAMPLE OF CORR
C
      WRITE (IPRT,1100)
      CALL CORR(YM, N, M, IYM, LDSTAK)
      WRITE (IPRT,2000) IERR
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT ('1*CH7')
 1100 FORMAT (' SIMPLE TEST OF CORR')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
C
      END
*XXCH8
      SUBROUTINE XXCH8(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     TEST SUBPROGRAM FOR SIMPLE TEST OF
C     THE LINEAR LEAST SQUARES FAMILY OF ROUTINES.
C
C     LLS PROBLEM IS FROM DANIAL AND WOOD [1971], PAGES 61-65.
C
C     LLSP PROBLEM IS FROM MILLER AND FREUND [1977], PAGE 311.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  AUGUST 3, 1987
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,IXM,N1,N2,NDEG,NPAR
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RES(25),X(25),XM(25,5),Y1(25),Y2(25)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLS,LLSP
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
C        DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE MATRIX X.
C     INTEGER LDSTAK
C        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
C     INTEGER NDEG
C        THE DEGREE OF THE POLYNOMIAL MODEL TO BE FIT.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     INTEGER N1, N2
C        THE NUMBER OF OBSERVATIONS IN EACH PROBLEM.
C     DOUBLE PRECISION RES(25)
C        THE RESIDUALS.
C     DOUBLE PRECISION X(25)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION XM(25,5)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION Y1(25), Y2(25)
C        THE DEPENDENT VARIABLE.
C
C
      DATA      XM(1,1),  XM(1,2),  XM(1,3),  XM(1,4)
     +    /      1.0D0, 80.0D0, 27.0D0, 89.0D0/
      DATA      XM(2,1),  XM(2,2),  XM(2,3),  XM(2,4)
     +    /      1.0D0, 80.0D0, 27.0D0, 88.0D0/
      DATA      XM(3,1),  XM(3,2),  XM(3,3),  XM(3,4)
     +    /      1.0D0, 75.0D0, 25.0D0, 90.0D0/
      DATA      XM(4,1),  XM(4,2),  XM(4,3),  XM(4,4)
     +    /      1.0D0, 62.0D0, 24.0D0, 87.0D0/
      DATA      XM(5,1),  XM(5,2),  XM(5,3),  XM(5,4)
     +    /      1.0D0, 62.0D0, 22.0D0, 87.0D0/
      DATA      XM(6,1),  XM(6,2),  XM(6,3),  XM(6,4)
     +    /      1.0D0, 62.0D0, 23.0D0, 87.0D0/
      DATA      XM(7,1),  XM(7,2),  XM(7,3),  XM(7,4)
     +    /      1.0D0, 62.0D0, 24.0D0, 93.0D0/
      DATA      XM(8,1),  XM(8,2),  XM(8,3),  XM(8,4)
     +    /      1.0D0, 62.0D0, 24.0D0, 93.0D0/
      DATA      XM(9,1),  XM(9,2),  XM(9,3),  XM(9,4)
     +    /      1.0D0, 58.0D0, 23.0D0, 87.0D0/
      DATA     XM(10,1), XM(10,2), XM(10,3), XM(10,4)
     +    /      1.0D0, 58.0D0, 18.0D0, 80.0D0/
      DATA     XM(11,1), XM(11,2), XM(11,3), XM(11,4)
     +    /      1.0D0, 58.0D0, 18.0D0, 89.0D0/
      DATA     XM(12,1), XM(12,2), XM(12,3), XM(12,4)
     +    /      1.0D0, 58.0D0, 17.0D0, 88.0D0/
      DATA     XM(13,1), XM(13,2), XM(13,3), XM(13,4)
     +    /      1.0D0, 58.0D0, 18.0D0, 82.0D0/
      DATA     XM(14,1), XM(14,2), XM(14,3), XM(14,4)
     +    /      1.0D0, 58.0D0, 19.0D0, 93.0D0/
      DATA     XM(15,1), XM(15,2), XM(15,3), XM(15,4)
     +    /      1.0D0, 50.0D0, 18.0D0, 89.0D0/
      DATA     XM(16,1), XM(16,2), XM(16,3), XM(16,4)
     +    /      1.0D0, 50.0D0, 18.0D0, 86.0D0/
      DATA     XM(17,1), XM(17,2), XM(17,3), XM(17,4)
     +    /      1.0D0, 50.0D0, 19.0D0, 72.0D0/
      DATA     XM(18,1), XM(18,2), XM(18,3), XM(18,4)
     +    /      1.0D0, 50.0D0, 19.0D0, 79.0D0/
      DATA     XM(19,1), XM(19,2), XM(19,3), XM(19,4)
     +    /      1.0D0, 50.0D0, 20.0D0, 80.0D0/
      DATA     XM(20,1), XM(20,2), XM(20,3), XM(20,4)
     +    /      1.0D0, 56.0D0, 20.0D0, 82.0D0/
      DATA     XM(21,1), XM(21,2), XM(21,3), XM(21,4)
     +    /      1.0D0, 70.0D0, 20.0D0, 91.0D0/
C
      DATA        Y1(1),    Y1(2),    Y1(3)
     +    /     42.0D0, 37.0D0, 37.0D0/
      DATA        Y1(4),    Y1(5),    Y1(6)
     +    /     28.0D0, 18.0D0, 18.0D0/
      DATA        Y1(7),    Y1(8),    Y1(9)
     +    /     19.0D0, 20.0D0, 15.0D0/
      DATA       Y1(10),   Y1(11),   Y1(12)
     +    /     14.0D0, 14.0D0, 13.0D0/
      DATA       Y1(13),   Y1(14),   Y1(15)
     +    /     11.0D0, 12.0D0,  8.0D0/
      DATA       Y1(16),   Y1(17),   Y1(18)
     +    /      7.0D0,  8.0D0,  8.0D0/
      DATA       Y1(19),   Y1(20),   Y1(21)
     +    /      9.0D0, 15.0D0, 15.0D0/
C
      DATA         X(1),     X(2),     X(3)
     +    /      0.0D0,  1.0D0,  2.0D0/
      DATA         X(4),     X(5),     X(6)
     +    /      3.0D0,  4.0D0,  5.0D0/
      DATA         X(7),     X(8),     X(9)
     +    /      6.0D0,  7.0D0,  8.0D0/
C
      DATA        Y2(1),    Y2(2),    Y2(3)
     +    /     12.0D0, 10.5D0, 10.0D0/
      DATA        Y2(4),    Y2(5),    Y2(6)
     +    /      8.0D0,  7.0D0,  8.0D0/
      DATA        Y2(7),    Y2(8),    Y2(9)
     +    /      7.5D0,  8.5D0,  9.0D0/
C
C     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
C
      CALL IPRINT(IPRT)
      IXM = 25
      N1 = 21
      N2 = 9
      NPAR = 4
      NDEG = 2
C
C     PRINT HEADER
C
      WRITE (IPRT,1000)
C
C     RUN SIMPLE EXAMPLE OF LLS
C
      WRITE (IPRT,1100)
      CALL LLS(Y1, XM, N1, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,2000) IERR
C
C     RUN SIMPLE EXAMPLE OF LLSP
C
      WRITE (IPRT,1200)
      CALL LLSP(Y2, X, N2, NDEG, RES, LDSTAK)
      WRITE (IPRT,2000) IERR
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT ('1*CH8')
 1100 FORMAT (' SIMPLE TEST OF LLS')
 1200 FORMAT ('1SIMPLE TEST OF LLSP')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
C
      END
*XXCH9
      SUBROUTINE XXCH9(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     TEST SUBPROGRAM FOR SIMPLE TEST OF
C     THE NONLINEAR LEAST SQUARES FAMILY OF ROUTINES.
C
C     DATA IS FROM DANIAL AND WOOD [1980], PAGES 428-441.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  AUGUST 3, 1987
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   IPRT,IXM,M,N,NPAR
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(5),RES(10),STP(5),XM(10,2),Y(10)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DCKLS,DRV1A,DRV1B,IPRINT,MDL1,NLS,NLSD,STPLS
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     EXTERNAL DRV1A, DRV1B
C        THE NAME OF THE ''USER SUPPLIED'' DERIVATIVE ROUTINES.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER IERR
C        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
C        DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .EQ. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT.
C     INTEGER IXM
C        THE FIRST DIMENSION OF THE MATRIX X.
C     INTEGER LDSTAK
C        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
C     INTEGER M
C        THE NUMBER OF INDEPENDENT VARIABLES.
C     EXTERNAL MDL1
C        THE NAME OF THE ''USER SUPPLIED'' MODEL ROUTINES.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS IN EACH PROBLEM.
C     INTEGER NPAR
C        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
C     DOUBLE PRECISION PAR(5)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION RES(10)
C        THE RESIDUALS.
C     DOUBLE PRECISION STP(5)
C        THE STEP SIZES SELECTED FOR GENERATING FINITE DIFFERENCE
C        DERIVATIVES.
C     DOUBLE PRECISION XM(10,2)
C        THE INDEPENDENT VARIABLE.
C     DOUBLE PRECISION Y(10)
C        THE DEPENDENT VARIABLE.
C
C
      DATA Y(1), Y(2), Y(3), Y(4), Y(5), Y(6)
     +   /2.138D0, 3.421D0, 3.597D0, 4.340D0, 4.882D0, 5.660D0/
C
      DATA XM(1,1), XM(2,1), XM(3,1), XM(4,1), XM(5,1), XM(6,1)
     +   /1.309D0, 1.471D0, 1.490D0, 1.565D0, 1.611D0, 1.680D0/
C
C     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
C
      CALL IPRINT(IPRT)
      IXM = 10
      N = 6
      M = 1
      NPAR = 2
C
C     PRINT HEADER
C
      WRITE (IPRT,1000)
C
C     RUN SIMPLE EXAMPLE OF NLS
C
      WRITE (IPRT,1100)
      PAR(1) = 0.725
      PAR(2) = 4.000
      CALL NLS(Y, XM, N, M, IXM, MDL1, PAR, NPAR, RES, LDSTAK)
      WRITE (IPRT,2000) IERR
C
C     RUN SIMPLE EXAMPLE OF NLSD
C
      WRITE (IPRT,1200)
      PAR(1) = 0.725
      PAR(2) = 4.000
      CALL NLSD(Y, XM, N, M, IXM, MDL1, DRV1A, PAR, NPAR, RES, LDSTAK)
      WRITE (IPRT,2000) IERR
C
C     RUN SIMPLE EXAMPLE OF STPLS
C
      WRITE (IPRT,1300)
      PAR(1) = 0.725
      PAR(2) = 4.000
      CALL STPLS(XM, N, M, IXM, MDL1, PAR, NPAR, LDSTAK, STP)
      WRITE (IPRT,2000) IERR
C
C     RUN SIMPLE EXAMPLE OF DCKLS
C
      WRITE (IPRT,1400)
      PAR(1) = 0.000
      PAR(2) = 4.000
      CALL DCKLS(XM, N, M, IXM, MDL1, DRV1B, PAR, NPAR, LDSTAK)
      WRITE (IPRT,2000) IERR
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT ('1*CH9')
 1100 FORMAT (' SIMPLE TEST OF NLS')
 1200 FORMAT ('1SIMPLE TEST OF NLSD')
 1300 FORMAT ('1SIMPLE TEST OF STPLS')
 1400 FORMAT ('1SIMPLE TEST OF DCKLS')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
C
      END
*XXCH10
      SUBROUTINE XXCH10(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
C     THE HISTOGRAM FAMILY OF ROUTINES.
C
C     DATA IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND JENKINS.
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  AUGUST 3, 1987
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IAR,IPRT,N,NYF
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AIR(144),PHI(5),Y(150),YF(150)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DIF,GFARF,IPRINT,VP
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AIR(144)
C        THE AIRLINE DATA.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IAR
C        THE NUMBER OF COEFFICIENTS IN THE DIFFERENCE FILTER.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT.
C     INTEGER LDSTAK
C        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NYF
C        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES.
C     DOUBLE PRECISION PHI(5)
C        THE FILTER COEFFICIENTS.
C     DOUBLE PRECISION Y(150)
C        THE LOG OF THE AIRLINE DATA.
C     DOUBLE PRECISION YF(150)
C        THE FILTERED DATA.
C
C
      DATA  AIR(  1), AIR(  2), AIR(  3), AIR(  4), AIR(  5), AIR(  6)
     +    / 112.0D0,  118.0D0,  132.0D0,  129.0D0,  121.0D0,  135.0D0/
      DATA  AIR(  7), AIR(  8), AIR(  9), AIR( 10), AIR( 11), AIR( 12)
     +    / 148.0D0,  148.0D0,  136.0D0,  119.0D0,  104.0D0,  118.0D0/
      DATA  AIR( 13), AIR( 14), AIR( 15), AIR( 16), AIR( 17), AIR( 18)
     +    / 115.0D0,  126.0D0,  141.0D0,  135.0D0,  125.0D0,  149.0D0/
      DATA  AIR( 19), AIR( 20), AIR( 21), AIR( 22), AIR( 23), AIR( 24)
     +    / 170.0D0,  170.0D0,  158.0D0,  133.0D0,  114.0D0,  140.0D0/
      DATA  AIR( 25), AIR( 26), AIR( 27), AIR( 28), AIR( 29), AIR( 30)
     +    / 145.0D0,  150.0D0,  178.0D0,  163.0D0,  172.0D0,  178.0D0/
      DATA  AIR( 31), AIR( 32), AIR( 33), AIR( 34), AIR( 35), AIR( 36)
     +    / 199.0D0,  199.0D0,  184.0D0,  162.0D0,  146.0D0,  166.0D0/
      DATA  AIR( 37), AIR( 38), AIR( 39), AIR( 40), AIR( 41), AIR( 42)
     +    / 171.0D0,  180.0D0,  193.0D0,  181.0D0,  183.0D0,  218.0D0/
      DATA  AIR( 43), AIR( 44), AIR( 45), AIR( 46), AIR( 47), AIR( 48)
     +    / 230.0D0,  242.0D0,  209.0D0,  191.0D0,  172.0D0,  194.0D0/
      DATA  AIR( 49), AIR( 50), AIR( 51), AIR( 52), AIR( 53), AIR( 54)
     +    / 196.0D0,  196.0D0,  236.0D0,  235.0D0,  229.0D0,  243.0D0/
      DATA  AIR( 55), AIR( 56), AIR( 57), AIR( 58), AIR( 59), AIR( 60)
     +    / 264.0D0,  272.0D0,  237.0D0,  211.0D0,  180.0D0,  201.0D0/
      DATA  AIR( 61), AIR( 62), AIR( 63), AIR( 64), AIR( 65), AIR( 66)
     +    / 204.0D0,  188.0D0,  235.0D0,  227.0D0,  234.0D0,  264.0D0/
      DATA  AIR( 67), AIR( 68), AIR( 69), AIR( 70), AIR( 71), AIR( 72)
     +    / 302.0D0,  293.0D0,  259.0D0,  229.0D0,  203.0D0,  229.0D0/
      DATA  AIR( 73), AIR( 74), AIR( 75), AIR( 76), AIR( 77), AIR( 78)
     +    / 242.0D0,  233.0D0,  267.0D0,  269.0D0,  270.0D0,  315.0D0/
      DATA  AIR( 79), AIR( 80), AIR( 81), AIR( 82), AIR( 83), AIR( 84)
     +    / 364.0D0,  347.0D0,  312.0D0,  274.0D0,  237.0D0,  278.0D0/
      DATA  AIR( 85), AIR( 86), AIR( 87), AIR( 88), AIR( 89), AIR( 90)
     +    / 284.0D0,  277.0D0,  317.0D0,  313.0D0,  318.0D0,  374.0D0/
      DATA  AIR( 91), AIR( 92), AIR( 93), AIR( 94), AIR( 95), AIR( 96)
     +    / 413.0D0,  405.0D0,  355.0D0,  306.0D0,  271.0D0,  306.0D0/
      DATA  AIR( 97), AIR( 98), AIR( 99), AIR(100), AIR(101), AIR(102)
     +    / 315.0D0,  301.0D0,  356.0D0,  348.0D0,  355.0D0,  422.0D0/
      DATA  AIR(103), AIR(104), AIR(105), AIR(106), AIR(107), AIR(108)
     +    / 465.0D0,  467.0D0,  404.0D0,  347.0D0,  305.0D0,  336.0D0/
      DATA  AIR(109), AIR(110), AIR(111), AIR(112), AIR(113), AIR(114)
     +    / 340.0D0,  318.0D0,  362.0D0,  348.0D0,  363.0D0,  435.0D0/
      DATA  AIR(115), AIR(116), AIR(117), AIR(118), AIR(119), AIR(120)
     +    / 491.0D0,  505.0D0,  404.0D0,  359.0D0,  310.0D0,  337.0D0/
      DATA  AIR(121), AIR(122), AIR(123), AIR(124), AIR(125), AIR(126)
     +    / 360.0D0,  342.0D0,  406.0D0,  396.0D0,  420.0D0,  472.0D0/
      DATA  AIR(127), AIR(128), AIR(129), AIR(130), AIR(131), AIR(132)
     +    / 548.0D0,  559.0D0,  463.0D0,  407.0D0,  362.0D0,  405.0D0/
      DATA  AIR(133), AIR(134), AIR(135), AIR(136), AIR(137), AIR(138)
     +    / 417.0D0,  391.0D0,  419.0D0,  461.0D0,  472.0D0,  535.0D0/
      DATA  AIR(139), AIR(140), AIR(141), AIR(142), AIR(143), AIR(144)
     +    / 622.0D0,  606.0D0,  508.0D0,  461.0D0,  390.0D0,  432.0D0/
C
C     DEFINE CONSTANTS
C
      CALL IPRINT(IPRT)
      N = 144
C
C     TAKE LOG OF DATA
C
      DO 10 I=1,N
         Y(I) = LOG(AIR(I))
   10 CONTINUE
C
C     WRITE HEADER
C
      WRITE(IPRT, 1000)
C
C     RUN SIMPLE TEST OF DIF
C
      WRITE(IPRT, 1100)
      CALL DIF (Y, N, YF, NYF)
      WRITE (IPRT,2000) IERR
C
C     PLOT ORIGINAL SERIES
C
      WRITE(IPRT, 1200)
      CALL VP (Y, N, 1)
      WRITE (IPRT,2000) IERR
C
C     PLOT DIFFERENCED SERIES
C
      WRITE(IPRT, 1300)
      CALL VP (YF, NYF, 1)
      WRITE (IPRT,2000) IERR
C
C     RUN SIMPLE TEST OF GFARF
C
      WRITE(IPRT, 1400)
      PHI(1) = 1.0
      IAR = 1
      CALL GFARF (PHI, IAR)
      WRITE (IPRT,2000) IERR
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT ('1*CH10')
 1100 FORMAT (' SIMPLE TEST OF DIF (NO OUTPUT UNLESS ERROR FOUND)')
 1200 FORMAT ('1PLOT OF ORIGINAL SERIES')
 1300 FORMAT ('1PLOT OF DIFFERENCED SERIES')
 1400 FORMAT ('1SIMPLE TEST OF GFARF')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
*XXCH11
      SUBROUTINE XXCH11(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
C     THE COMPLEX DEMODULATION FAMILY OF ROUTINES.
C
C     DATA IS THE WOLF SUMSPOT NUMBERS FOR THE YEARS 1700 TO 1960 AS
C     TABULATED BY WALDMEIER [1961].
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  AUGUST 3, 1987
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   FC,FD
      INTEGER
     +   IPRT,K,N
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   Y(300)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL DEMOD,IPRINT
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FC
C        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
C     DOUBLE PRECISION FD
C        THE DEMODULATION FREQUENCY.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT.
C     INTEGER K
C        THE NUMBER OF TERMS IN THE SYMETRIC LINEAR FILTER.
C     INTEGER LDSTAK
C        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     DOUBLE PRECISION Y(300)
C        THE LOG OF THE AIRLINE DATA.
C
C
      DATA   Y(  1),  Y(  2),  Y(  3),  Y(  4),  Y(  5),  Y(  6)
     +    /     5.0D0, 11.0D0, 16.0D0, 23.0D0, 36.0D0, 58.0D0/
      DATA   Y(  7),  Y(  8),  Y(  9),  Y( 10),  Y( 11),  Y( 12)
     +    /    29.0D0, 20.0D0, 10.0D0,  8.0D0,  3.0D0,  0.0D0/
      DATA   Y( 13),  Y( 14),  Y( 15),  Y( 16),  Y( 17),  Y( 18)
     +    /     0.0D0, 2.0D0, 11.0D0, 27.0D0, 47.0D0, 63.0D0/
      DATA   Y( 19),  Y( 20),  Y( 21),  Y( 22),  Y( 23),  Y( 24)
     +    /    60.0D0, 39.0D0, 28.0D0, 26.0D0, 22.0D0, 11.0D0/
      DATA   Y( 25),  Y( 26),  Y( 27),  Y( 28),  Y( 29),  Y( 30)
     +    /    21.0D0, 40.0D0, 78.0D0,122.0D0,103.0D0, 73.0D0/
      DATA   Y( 31),  Y( 32),  Y( 33),  Y( 34),  Y( 35),  Y( 36)
     +    /    47.0D0, 35.0D0, 11.0D0,  5.0D0, 16.0D0, 34.0D0/
      DATA   Y( 37),  Y( 38),  Y( 39),  Y( 40),  Y( 41),  Y( 42)
     +    /    70.0D0, 81.0D0,111.0D0,101.0D0, 73.0D0, 40.0D0/
      DATA   Y( 43),  Y( 44),  Y( 45),  Y( 46),  Y( 47),  Y( 48)
     +    /    20.0D0, 16.0D0,  5.0D0, 11.0D0, 22.0D0, 40.0D0/
      DATA   Y( 49),  Y( 50),  Y( 51),  Y( 52),  Y( 53),  Y( 54)
     +    /    60.0D0, 80.9D0, 83.4D0, 47.7D0, 47.8D0, 30.7D0/
      DATA   Y( 55),  Y( 56),  Y( 57),  Y( 58),  Y( 59),  Y( 60)
     +    /    12.2D0,  9.6D0, 10.2D0, 32.4D0, 47.6D0, 54.0D0/
      DATA   Y( 61),  Y( 62),  Y( 63),  Y( 64),  Y( 65),  Y( 66)
     +    /    62.9D0, 85.9D0, 61.2D0, 45.1D0, 36.4D0, 20.9D0/
      DATA   Y( 67),  Y( 68),  Y( 69),  Y( 70),  Y( 71),  Y( 72)
     +    /    11.4D0, 37.8D0, 69.8D0,106.1D0,100.8D0, 81.6D0/
      DATA   Y( 73),  Y( 74),  Y( 75),  Y( 76),  Y( 77),  Y( 78)
     +    /    66.5D0, 34.8D0, 30.6D0,  7.0D0, 19.8D0, 92.5D0/
      DATA   Y( 79),  Y( 80),  Y( 81),  Y( 82),  Y( 83),  Y( 84)
     +    /   154.4D0,125.9D0, 84.8D0, 68.1D0, 38.5D0, 22.8D0/
      DATA   Y( 85),  Y( 86),  Y( 87),  Y( 88),  Y( 89),  Y( 90)
     +    /    10.2D0, 24.1D0, 82.9D0,132.0D0,130.9D0,118.1D0/
      DATA   Y( 91),  Y( 92),  Y( 93),  Y( 94),  Y( 95),  Y( 96)
     +    /    89.9D0, 66.6D0, 60.0D0, 46.9D0, 41.0D0, 21.3D0/
      DATA   Y( 97),  Y( 98),  Y( 99),  Y(100),  Y(101),  Y(102)
     +    /    16.0D0,  6.4D0,  4.1D0,  6.8D0, 14.5D0, 34.0D0/
      DATA   Y(103),  Y(104),  Y(105),  Y(106),  Y(107),  Y(108)
     +    /    45.0D0, 43.1D0, 47.5D0, 42.2D0, 28.1D0, 10.1D0/
      DATA   Y(109),  Y(110),  Y(111),  Y(112),  Y(113),  Y(114)
     +    /     8.1D0,  2.5D0,  0.0D0,  1.4D0,  5.0D0, 12.2D0/
      DATA   Y(115),  Y(116),  Y(117),  Y(118),  Y(119),  Y(120)
     +    /    13.9D0, 35.4D0, 45.8D0, 41.1D0, 30.1D0, 23.9D0/
      DATA   Y(121),  Y(122),  Y(123),  Y(124),  Y(125),  Y(126)
     +    /    15.6D0,  6.6D0,  4.0D0,  1.8D0,  8.5D0, 16.6D0/
      DATA   Y(127),  Y(128),  Y(129),  Y(130),  Y(131),  Y(132)
     +    /    36.3D0, 49.6D0, 64.2D0, 67.0D0, 70.9D0, 47.8D0/
      DATA   Y(133),  Y(134),  Y(135),  Y(136),  Y(137),  Y(138)
     +    /    27.5D0,  8.5D0, 13.2D0, 56.9D0,121.5D0,138.3D0/
      DATA   Y(139),  Y(140),  Y(141),  Y(142),  Y(143),  Y(144)
     +    /   103.2D0, 85.7D0, 64.6D0, 36.7D0, 24.2D0, 10.7D0/
      DATA   Y(145),  Y(146),  Y(147),  Y(148),  Y(149),  Y(150)
     +    /    15.0D0, 40.1D0, 61.5D0, 98.5D0,124.7D0, 96.3D0/
      DATA   Y(151),  Y(152),  Y(153),  Y(154),  Y(155),  Y(156)
     +    /    66.6D0, 64.5D0, 54.1D0, 39.0D0, 20.6D0,  6.7D0/
      DATA   Y(157),  Y(158),  Y(159),  Y(160),  Y(161),  Y(162)
     +    /     4.3D0, 22.7D0, 54.8D0, 93.8D0, 95.8D0, 77.2D0/
      DATA   Y(163),  Y(164),  Y(165),  Y(166),  Y(167),  Y(168)
     +    /    59.1D0, 44.0D0, 47.0D0, 30.5D0, 16.3D0,  7.3D0/
      DATA   Y(169),  Y(170),  Y(171),  Y(172),  Y(173),  Y(174)
     +    /    37.6D0, 74.0D0,139.0D0,111.2D0,101.6D0, 66.2D0/
      DATA   Y(175),  Y(176),  Y(177),  Y(178),  Y(179),  Y(180)
     +    /    44.7D0, 17.0D0, 11.3D0, 12.4D0,  3.4D0,  6.0D0/
      DATA   Y(181),  Y(182),  Y(183),  Y(184),  Y(185),  Y(186)
     +    /    32.3D0, 54.3D0, 59.7D0, 63.7D0, 63.5D0, 52.2D0/
      DATA   Y(187),  Y(188),  Y(189),  Y(190),  Y(191),  Y(192)
     +    /    25.4D0, 13.1D0,  6.8D0,  6.3D0,  7.1D0, 35.6D0/
      DATA   Y(193),  Y(194),  Y(195),  Y(196),  Y(197),  Y(198)
     +    /    73.0D0, 85.1D0, 78.0D0, 64.0D0, 41.8D0, 26.2D0/
      DATA   Y(199),  Y(200),  Y(201),  Y(202),  Y(203),  Y(204)
     +    /    26.7D0, 12.1D0,  9.5D0,  2.7D0,  5.0D0, 24.4D0/
      DATA   Y(205),  Y(206),  Y(207),  Y(208),  Y(209),  Y(210)
     +    /    42.0D0, 63.5D0, 53.8D0, 62.0D0, 48.5D0, 43.9D0/
      DATA   Y(211),  Y(212),  Y(213),  Y(214),  Y(215),  Y(216)
     +    /    18.6D0,  5.7D0,  3.6D0,  1.4D0,  9.6D0, 47.4D0/
      DATA   Y(217),  Y(218),  Y(219),  Y(220),  Y(221),  Y(222)
     +    /    57.1D0,103.9D0, 80.6D0, 63.6D0, 37.6D0, 26.1D0/
      DATA   Y(223),  Y(224),  Y(225),  Y(226),  Y(227),  Y(228)
     +    /    14.2D0,  5.8D0, 16.7D0, 44.3D0, 63.9D0, 69.0D0/
      DATA   Y(229),  Y(230),  Y(231),  Y(232),  Y(233),  Y(234)
     +    /    77.8D0, 64.9D0, 35.7D0, 21.2D0, 11.1D0,  5.7D0/
      DATA   Y(235),  Y(236),  Y(237),  Y(238),  Y(239),  Y(240)
     +    /     8.7D0, 36.1D0, 79.7D0,114.4D0,109.6D0, 88.8D0/
      DATA   Y(241),  Y(242),  Y(243),  Y(244),  Y(245),  Y(246)
     +    /    67.8D0, 47.5D0, 30.6D0, 16.3D0,  9.6D0, 33.2D0/
      DATA   Y(247),  Y(248),  Y(249),  Y(250),  Y(251),  Y(252)
     +    /    92.6D0,151.6D0,136.3D0,134.7D0, 83.9D0, 69.4D0/
      DATA   Y(253),  Y(254),  Y(255),  Y(256),  Y(257),  Y(258)
     +    /    31.5D0, 13.9D0,  4.4D0, 38.0D0,141.7D0,190.2D0/
      DATA   Y(259),  Y(260),  Y(261)
     +    /   184.8D0,159.0D0,112.3D0/
C
C     DEFINE CONSTANTS
C
      CALL IPRINT(IPRT)
      N = 261
      FD = 1.0/11.0
      FC = 1.0/22.0
      K = 41
C
C     WRITE HEADER
C
      WRITE(IPRT, 1000)
C
C     RUN SIMPLE TEST OF DIF
C
      WRITE(IPRT, 1100)
      CALL DEMOD (Y, N, FD, FC, K, LDSTAK)
      WRITE (IPRT,2000) IERR
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT ('1*CH11')
 1100 FORMAT (' SIMPLE TEST OF DEMOD')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
*XXCH12
      SUBROUTINE XXCH12(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
C     THE TIME SERIES CORRELATION AND SPECTRUM ANALYSIS
C     FAMILY OF ROUTINES.
C
C     DATA FOR ACF IS TAKEN FROM P. 362 OF JENKINS AND WATTS [1968]
C     DATA FOR CCF IS TAKEN FROM P. 361 OF JENKINS AND WATTS [1968]
C     DATA FOR UFS IS TAKEN FROM P. 318 OF JENKINS AND WATTS [1968]
C     DATA FOR UAS IS TAKEN FROM P. 318 OF JENKINS AND WATTS [1968]
C     DATA FOR TAPER, PGMS, MDFLT AND PPL IS
C           THE WOLF SUNSPOT NUMBERS FOR THE YEARS 1700 TO 1960 AS
C           TABULATED BY WALDMEIER [1961].
C     DATA FOR BFS IS TAKEN FROM PP. 387-388 OF JENKINS AND WATTS [1968]
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  AUGUST 3, 1987
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      DOUBLE PRECISION
     +   TAPERP
      INTEGER
     +   IEXTND,ILOG,IPRT,LFREQ,LPER,LYFFT,NF,NFFT,NK,NPRT,NY1,NY2,
     +   NY3,NY4,NY5,NY6
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FREQ(300),PER(300),PERF(300),Y1(100),Y2A(100),Y2B(100),
     +   Y3(50),Y4(50),Y5(300),Y6A(100),Y6B(100),YFFT(600)
      INTEGER
     +   KMD(10)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL ACF,BFS,CCF,IPRINT,MDFLT,PGMS,PPL,TAPER,UAS,UFS
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C  EQUIVALENCES
      EQUIVALENCE (Y3(1),Y4(1))
      EQUIVALENCE (Y2A(1),Y6A(1))
      EQUIVALENCE (Y2B(1),Y6B(1))
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     DOUBLE PRECISION FREQ(300)
C        THE FREQUENCIES AT WHICH THE PERIODOGRAM IS COMPUTED.
C     INTEGER IERR
C        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
C        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
C     INTEGER IEXTND
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
C        SERIES MEAN IS TO BE USED TO EXTEND THE SERIES.
C     INTEGER ILOG
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE PLOT IS
C        TO HAVE LOGARITHMIC AXIS OR NOT.
C     INTEGER IPRT
C        LOGICAL OUTPUT UNIT.
C     INTEGER KMD(10)
C        THE VECTOR OF MODIFIED DANIEL FILTER LENGTHS.
C     INTEGER LDSTAK
C        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
C     INTEGER LFREQ
C        THE LENGTH OF VECTOR FREQ.
C     INTEGER LPER
C        THE LENGTH OF VECTOR PER.
C     INTEGER LYFFT
C        THE LENGTH OF VECTOR YFFT.
C     INTEGER NF
C        THE NUMBER OF FREQUENCIES.
C     INTEGER NFFT
C        THE EXTENDED SERIES LENGTH FOR THE FFT.
C     INTEGER NK
C        THE NUMBER OF DANIEL FILTERS TO APPLY.
C     INTEGER NPRT
C        THE PRINT CONTROL VARIABLE.
C     INTEGER NY1, NY2, NY3, NY4, NY5, NY6
C        THE NUMBER OF OBSERVATIONS.
C     DOUBLE PRECISION PER(300)
C        THE PERIODOGRAM.
C     DOUBLE PRECISION PERF(300)
C        THE FILTERED PERIODOGRAM.
C     DOUBLE PRECISION TAPERP
C        THE PERCENTAGE OF THE SERIES TO BE TAPERED.
C     DOUBLE PRECISION YFFT(600)
C        AN ARRAY FOR THE FFT COMPUTATIONS.
C     DOUBLE PRECISION Y1(100)
C        THE DATA FROM PAGE 362 OF JENKINS AND WATTS.
C     DOUBLE PRECISION Y2A(100), Y2B(100)
C        THE DATA FROM PAGE 361 OF JENKINS AND WATTS.
C     DOUBLE PRECISION Y3(50), Y4(50)
C        THE DATA FROM PAGE 318 OF JENKINS AND WATTS.
C     DOUBLE PRECISION Y5(300)
C        THE WOLF SUNSPOT DATA.
C     DOUBLE PRECISION Y6A(100), Y6B(100)
C        THE DATA FROM PAGE 387 AND 388 OF JENKINS AND WATTS.
C
C
      DATA   Y1(  1),  Y1(  2),  Y1(  3),  Y1(  4),  Y1(  5),  Y1(  6)
     +    / -2.07D0, -1.15D0,  0.69D0, -0.46D0, -1.49D0, -0.70D0/
      DATA   Y1(  7),  Y1(  8),  Y1(  9),  Y1( 10),  Y1( 11),  Y1( 12)
     +    / -1.07D0, -0.69D0, -0.68D0,  1.27D0, -1.05D0, -0.05D0/
      DATA   Y1( 13),  Y1( 14),  Y1( 15),  Y1( 16),  Y1( 17),  Y1( 18)
     +    / -0.84D0, -0.62D0, -0.49D0, -1.29D0, -0.49D0, -1.06D0/
      DATA   Y1( 19),  Y1( 20),  Y1( 21),  Y1( 22),  Y1( 23),  Y1( 24)
     +    / -0.38D0, -0.52D0, -0.13D0,  1.30D0, -1.51D0, -0.43D0/
      DATA   Y1( 25),  Y1( 26),  Y1( 27),  Y1( 28),  Y1( 29),  Y1( 30)
     +    / -1.33D0, -0.78D0,  0.31D0, -0.95D0, -0.90D0, -0.30D0/
      DATA   Y1( 31),  Y1( 32),  Y1( 33),  Y1( 34),  Y1( 35),  Y1( 36)
     +    / -1.02D0, -0.53D0,  0.15D0,  1.40D0,  1.22D0,  0.59D0/
      DATA   Y1( 37),  Y1( 38),  Y1( 39),  Y1( 40),  Y1( 41),  Y1( 42)
     +    /  0.70D0,  1.70D0,  2.78D0,  1.98D0,  1.39D0,  1.85D0/
      DATA   Y1( 43),  Y1( 44),  Y1( 45),  Y1( 46),  Y1( 47),  Y1( 48)
     +    /  2.60D0,  0.51D0,  2.77D0,  1.16D0,  1.07D0, -0.48D0/
      DATA   Y1( 49),  Y1( 50),  Y1( 51),  Y1( 52),  Y1( 53),  Y1( 54)
     +    / -0.52D0,  0.37D0,  0.00D0, -1.99D0, -1.75D0,  0.70D0/
      DATA   Y1( 55),  Y1( 56),  Y1( 57),  Y1( 58),  Y1( 59),  Y1( 60)
     +    /  0.73D0,  1.16D0,  0.06D0, -0.02D0,  1.10D0, -0.35D0/
      DATA   Y1( 61),  Y1( 62),  Y1( 63),  Y1( 64),  Y1( 65),  Y1( 66)
     +    / -1.67D0, -1.57D0,  1.16D0,  1.84D0,  3.35D0,  0.40D0/
      DATA   Y1( 67),  Y1( 68),  Y1( 69),  Y1( 70),  Y1( 71),  Y1( 72)
     +    /  0.45D0,  1.30D0,  0.93D0,  1.17D0, -1.74D0, -1.28D0/
      DATA   Y1( 73),  Y1( 74),  Y1( 75),  Y1( 76),  Y1( 77),  Y1( 78)
     +    / -0.07D0,  1.50D0,  0.53D0,  0.20D0, -0.42D0,  1.18D0/
      DATA   Y1( 79),  Y1( 80),  Y1( 81),  Y1( 82),  Y1( 83),  Y1( 84)
     +    /  0.82D0,  1.50D0,  2.92D0,  1.18D0,  1.23D0,  3.16D0/
      DATA   Y1( 85),  Y1( 86),  Y1( 87),  Y1( 88),  Y1( 89),  Y1( 90)
     +    /  0.79D0,  0.68D0,  1.14D0,  1.02D0,  1.02D0, -0.71D0/
      DATA   Y1( 91),  Y1( 92),  Y1( 93),  Y1( 94),  Y1( 95),  Y1( 96)
     +    / -0.17D0, -1.50D0, -0.26D0, -0.38D0,  0.93D0, -0.33D0/
      DATA   Y1( 97),  Y1( 98),  Y1( 99),  Y1(100)
     +    / -1.12D0, -2.95D0, -2.09D0, -1.11D0                    /
C
      DATA  Y2A(  1), Y2A(  2), Y2A(  3), Y2A(  4), Y2A(  5), Y2A(  6)
     +    /-0.88D0, -0.16D0, -1.87D0, -1.12D0,  1.38D0,  2.13D0/
      DATA  Y2A(  7), Y2A(  8), Y2A(  9), Y2A( 10), Y2A( 11), Y2A( 12)
     +    / 2.76D0,  0.56D0, -0.69D0, -1.79D0, -3.82D0, -2.38D0/
      DATA  Y2A( 13), Y2A( 14), Y2A( 15), Y2A( 16), Y2A( 17), Y2A( 18)
     +    / 1.00D0,  0.70D0, -0.15D0,  0.98D0,  0.11D0, -0.35D0/
      DATA  Y2A( 19), Y2A( 20), Y2A( 21), Y2A( 22), Y2A( 23), Y2A( 24)
     +    /-0.73D0,  0.89D0, -1.63D0, -0.44D0, -1.37D0, -1.71D0/
      DATA  Y2A( 25), Y2A( 26), Y2A( 27), Y2A( 28), Y2A( 29), Y2A( 30)
     +    /-1.22D0, -2.00D0, -0.22D0,  0.38D0,  1.31D0,  0.71D0/
      DATA  Y2A( 31), Y2A( 32), Y2A( 33), Y2A( 34), Y2A( 35), Y2A( 36)
     +    / 0.32D0,  0.48D0, -1.88D0, -0.94D0, -1.54D0, -0.13D0/
      DATA  Y2A( 37), Y2A( 38), Y2A( 39), Y2A( 40), Y2A( 41), Y2A( 42)
     +    / 1.02D0,  0.02D0, -0.77D0,  0.11D0, -0.60D0, -0.52D0/
      DATA  Y2A( 43), Y2A( 44), Y2A( 45), Y2A( 46), Y2A( 47), Y2A( 48)
     +    /-0.09D0,  1.23D0,  1.46D0,  0.61D0,  0.42D0,  2.16D0/
      DATA  Y2A( 49), Y2A( 50), Y2A( 51), Y2A( 52), Y2A( 53), Y2A( 54)
     +    / 3.18D0,  2.10D0,  0.37D0, -0.24D0,  0.57D0, -0.53D0/
      DATA  Y2A( 55), Y2A( 56), Y2A( 57), Y2A( 58), Y2A( 59), Y2A( 60)
     +    / 2.44D0,  1.02D0, -0.53D0, -2.49D0, -2.12D0, -1.04D0/
      DATA  Y2A( 61), Y2A( 62), Y2A( 63), Y2A( 64), Y2A( 65), Y2A( 66)
     +    /-0.12D0, -1.88D0, -1.50D0,  1.54D0,  3.33D0,  3.08D0/
      DATA  Y2A( 67), Y2A( 68), Y2A( 69), Y2A( 70), Y2A( 71), Y2A( 72)
     +    / 1.71D0,  0.79D0,  1.55D0,  0.89D0, -0.89D0, -1.18D0/
      DATA  Y2A( 73), Y2A( 74), Y2A( 75), Y2A( 76), Y2A( 77), Y2A( 78)
     +    / 0.89D0,  1.71D0,  3.05D0,  0.15D0, -1.04D0,  0.12D0/
      DATA  Y2A( 79), Y2A( 80), Y2A( 81), Y2A( 82), Y2A( 83), Y2A( 84)
     +    / 0.08D0,  0.11D0, -2.62D0, -1.28D0,  1.07D0,  3.20D0/
      DATA  Y2A( 85), Y2A( 86), Y2A( 87), Y2A( 88), Y2A( 89), Y2A( 90)
     +    / 1.92D0,  0.53D0, -1.08D0,  0.49D0, -0.58D0,  0.17D0/
      DATA  Y2A( 91), Y2A( 92), Y2A( 93), Y2A( 94), Y2A( 95), Y2A( 96)
     +    / 1.15D0, -0.97D0, -1.63D0,  1.14D0, -0.67D0, -0.88D0/
      DATA  Y2A( 97), Y2A( 98), Y2A( 99), Y2A(100)
     +    /-0.07D0,  0.24D0,  0.55D0, -2.16D0/
C
      DATA  Y2B(  1), Y2B(  2), Y2B(  3), Y2B(  4), Y2B(  5), Y2B(  6)
     +    / 0.79D0,  1.12D0, -1.10D0, -2.39D0, -1.75D0, -0.82D0/
      DATA  Y2B(  7), Y2B(  8), Y2B(  9), Y2B( 10), Y2B( 11), Y2B( 12)
     +    /-0.36D0,  1.27D0,  1.75D0,  2.44D0,  0.36D0, -2.10D0/
      DATA  Y2B( 13), Y2B( 14), Y2B( 15), Y2B( 16), Y2B( 17), Y2B( 18)
     +    /-1.93D0, -1.30D0, -1.75D0, -0.34D0,  0.74D0,  0.49D0/
      DATA  Y2B( 19), Y2B( 20), Y2B( 21), Y2B( 22), Y2B( 23), Y2B( 24)
     +    / 0.70D0,  0.71D0,  0.09D0,  0.59D0,  1.54D0,  0.14D0/
      DATA  Y2B( 25), Y2B( 26), Y2B( 27), Y2B( 28), Y2B( 29), Y2B( 30)
     +    / 0.55D0, -1.40D0, -2.55D0, -1.66D0, -0.43D0,  0.58D0/
      DATA  Y2B( 31), Y2B( 32), Y2B( 33), Y2B( 34), Y2B( 35), Y2B( 36)
     +    / 2.18D0, -0.24D0,  0.58D0, -0.18D0, -1.55D0, -0.64D0/
      DATA  Y2B( 37), Y2B( 38), Y2B( 39), Y2B( 40), Y2B( 41), Y2B( 42)
     +    /-1.09D0,  0.90D0, -0.66D0, -0.35D0,  0.48D0,  0.50D0/
      DATA  Y2B( 43), Y2B( 44), Y2B( 45), Y2B( 46), Y2B( 47), Y2B( 48)
     +    / 0.05D0, -0.68D0,  0.24D0,  0.58D0, -1.26D0, -0.25D0/
      DATA  Y2B( 49), Y2B( 50), Y2B( 51), Y2B( 52), Y2B( 53), Y2B( 54)
     +    / 0.25D0,  2.18D0,  2.96D0,  1.56D0, -0.36D0, -0.59D0/
      DATA  Y2B( 55), Y2B( 56), Y2B( 57), Y2B( 58), Y2B( 59), Y2B( 60)
     +    /-0.12D0,  3.03D0,  2.11D0,  0.78D0,  0.89D0, -1.45D0/
      DATA  Y2B( 61), Y2B( 62), Y2B( 63), Y2B( 64), Y2B( 65), Y2B( 66)
     +    /-0.36D0, -0.37D0, -1.39D0, -4.19D0, -0.73D0, -0.98D0/
      DATA  Y2B( 67), Y2B( 68), Y2B( 69), Y2B( 70), Y2B( 71), Y2B( 72)
     +    / 0.36D0,  0.06D0, -1.94D0, -0.08D0,  0.17D0,  1.00D0/
      DATA  Y2B( 73), Y2B( 74), Y2B( 75), Y2B( 76), Y2B( 77), Y2B( 78)
     +    /-0.05D0,  0.43D0,  0.15D0,  2.69D0,  0.57D0,  0.29D0/
      DATA  Y2B( 79), Y2B( 80), Y2B( 81), Y2B( 82), Y2B( 83), Y2B( 84)
     +    / 1.10D0,  0.48D0, -1.06D0, -2.28D0, -2.03D0, -0.75D0/
      DATA  Y2B( 85), Y2B( 86), Y2B( 87), Y2B( 88), Y2B( 89), Y2B( 90)
     +    / 1.00D0,  1.71D0,  0.58D0,  1.97D0,  0.99D0,  1.94D0/
      DATA  Y2B( 91), Y2B( 92), Y2B( 93), Y2B( 94), Y2B( 95), Y2B( 96)
     +    / 2.18D0,  3.14D0,  0.60D0,  0.51D0,  1.35D0,  0.56D0/
      DATA  Y2B( 97), Y2B( 98), Y2B( 99), Y2B(100)
     +    / 0.11D0,  0.00D0,  2.34D0,  1.88D0/
C
      DATA  Y3(  1),Y3(  2),Y3(  3),Y3(  4),Y3(  5),Y3(  6)
     +    /-0.88D0, -0.12D0, -0.89D0, -1.38D0, -0.07D0,  1.03D0/
      DATA  Y3(  7),Y3(  8),Y3(  9),Y3( 10),Y3( 11),Y3( 12)
     +    / 2.14D0,  0.35D0, -1.10D0, -1.78D0, -2.76D0, -1.77D0/
      DATA  Y3( 13),Y3( 14),Y3( 15),Y3( 16),Y3( 17),Y3( 18)
     +    / 0.98D0,  1.00D0, -0.70D0, -1.01D0, -1.30D0, -0.85D0/
      DATA  Y3( 19),Y3( 20),Y3( 21),Y3( 22),Y3( 23),Y3( 24)
     +    /-0.46D0,  1.63D0,  0.06D0, -0.17D0, -1.01D0, -1.04D0/
      DATA  Y3( 25),Y3( 26),Y3( 27),Y3( 28),Y3( 29),Y3( 30)
     +    /-0.66D0, -1.12D0, -0.51D0, -0.71D0, -0.20D0, -0.13D0/
      DATA  Y3( 31),Y3( 32),Y3( 33),Y3( 34),Y3( 35),Y3( 36)
     +    / 0.14D0,  1.59D0, -0.76D0, -1.08D0, -1.77D0, -1.20D0/
      DATA  Y3( 37),Y3( 38),Y3( 39),Y3( 40),Y3( 41),Y3( 42)
     +    / 0.45D0, -0.07D0, -0.63D0, -0.35D0, -0.87D0, -0.62D0/
      DATA  Y3( 43),Y3( 44),Y3( 45),Y3( 46),Y3( 47),Y3( 48)
     +    / 0.28D0,  1.90D0,  2.14D0,  1.05D0,  0.31D0,  1.07D0/
      DATA  Y3( 49),Y3( 50)
     +    / 2.67D0,  2.44D0/
C
      DATA  Y5(  1), Y5(  2), Y5(  3), Y5(  4), Y5(  5), Y5(  6)
     +    /     5.0D0, 11.0D0, 16.0D0, 23.0D0, 36.0D0, 58.0D0/
      DATA  Y5(  7), Y5(  8), Y5(  9), Y5( 10), Y5( 11), Y5( 12)
     +    /    29.0D0, 20.0D0, 10.0D0,  8.0D0,  3.0D0,  0.0D0/
      DATA  Y5( 13), Y5( 14), Y5( 15), Y5( 16), Y5( 17), Y5( 18)
     +    /     0.0D0, 2.0D0, 11.0D0, 27.0D0, 47.0D0, 63.0D0/
      DATA  Y5( 19), Y5( 20), Y5( 21), Y5( 22), Y5( 23), Y5( 24)
     +    /    60.0D0, 39.0D0, 28.0D0, 26.0D0, 22.0D0, 11.0D0/
      DATA  Y5( 25), Y5( 26), Y5( 27), Y5( 28), Y5( 29), Y5( 30)
     +    /    21.0D0, 40.0D0, 78.0D0,122.0D0,103.0D0, 73.0D0/
      DATA  Y5( 31), Y5( 32), Y5( 33), Y5( 34), Y5( 35), Y5( 36)
     +    /    47.0D0, 35.0D0, 11.0D0,  5.0D0, 16.0D0, 34.0D0/
      DATA  Y5( 37), Y5( 38), Y5( 39), Y5( 40), Y5( 41), Y5( 42)
     +    /    70.0D0, 81.0D0,111.0D0,101.0D0, 73.0D0, 40.0D0/
      DATA  Y5( 43), Y5( 44), Y5( 45), Y5( 46), Y5( 47), Y5( 48)
     +    /    20.0D0, 16.0D0,  5.0D0, 11.0D0, 22.0D0, 40.0D0/
      DATA  Y5( 49), Y5( 50), Y5( 51), Y5( 52), Y5( 53), Y5( 54)
     +    /    60.0D0, 80.9D0, 83.4D0, 47.7D0, 47.8D0, 30.7D0/
      DATA  Y5( 55), Y5( 56), Y5( 57), Y5( 58), Y5( 59), Y5( 60)
     +    /    12.2D0,  9.6D0, 10.2D0, 32.4D0, 47.6D0, 54.0D0/
      DATA  Y5( 61), Y5( 62), Y5( 63), Y5( 64), Y5( 65), Y5( 66)
     +    /    62.9D0, 85.9D0, 61.2D0, 45.1D0, 36.4D0, 20.9D0/
      DATA  Y5( 67), Y5( 68), Y5( 69), Y5( 70), Y5( 71), Y5( 72)
     +    /    11.4D0, 37.8D0, 69.8D0,106.1D0,100.8D0, 81.6D0/
      DATA  Y5( 73), Y5( 74), Y5( 75), Y5( 76), Y5( 77), Y5( 78)
     +    /    66.5D0, 34.8D0, 30.6D0,  7.0D0, 19.8D0, 92.5D0/
      DATA  Y5( 79), Y5( 80), Y5( 81), Y5( 82), Y5( 83), Y5( 84)
     +    /   154.4D0,125.9D0, 84.8D0, 68.1D0, 38.5D0, 22.8D0/
      DATA  Y5( 85), Y5( 86), Y5( 87), Y5( 88), Y5( 89), Y5( 90)
     +    /    10.2D0, 24.1D0, 82.9D0,132.0D0,130.9D0,118.1D0/
      DATA  Y5( 91), Y5( 92), Y5( 93), Y5( 94), Y5( 95), Y5( 96)
     +    /    89.9D0, 66.6D0, 60.0D0, 46.9D0, 41.0D0, 21.3D0/
      DATA  Y5( 97), Y5( 98), Y5( 99), Y5(100), Y5(101), Y5(102)
     +    /    16.0D0,  6.4D0,  4.1D0,  6.8D0, 14.5D0, 34.0D0/
      DATA  Y5(103), Y5(104), Y5(105), Y5(106), Y5(107), Y5(108)
     +    /    45.0D0, 43.1D0, 47.5D0, 42.2D0, 28.1D0, 10.1D0/
      DATA  Y5(109), Y5(110), Y5(111), Y5(112), Y5(113), Y5(114)
     +    /     8.1D0,  2.5D0,  0.0D0,  1.4D0,  5.0D0, 12.2D0/
      DATA  Y5(115), Y5(116), Y5(117), Y5(118), Y5(119), Y5(120)
     +    /    13.9D0, 35.4D0, 45.8D0, 41.1D0, 30.1D0, 23.9D0/
      DATA  Y5(121), Y5(122), Y5(123), Y5(124), Y5(125), Y5(126)
     +    /    15.6D0,  6.6D0,  4.0D0,  1.8D0,  8.5D0, 16.6D0/
      DATA  Y5(127), Y5(128), Y5(129), Y5(130), Y5(131), Y5(132)
     +    /    36.3D0, 49.6D0, 64.2D0, 67.0D0, 70.9D0, 47.8D0/
      DATA  Y5(133), Y5(134), Y5(135), Y5(136), Y5(137), Y5(138)
     +    /    27.5D0,  8.5D0, 13.2D0, 56.9D0,121.5D0,138.3D0/
      DATA  Y5(139), Y5(140), Y5(141), Y5(142), Y5(143), Y5(144)
     +    /   103.2D0, 85.7D0, 64.6D0, 36.7D0, 24.2D0, 10.7D0/
      DATA  Y5(145), Y5(146), Y5(147), Y5(148), Y5(149), Y5(150)
     +    /    15.0D0, 40.1D0, 61.5D0, 98.5D0,124.7D0, 96.3D0/
      DATA  Y5(151), Y5(152), Y5(153), Y5(154), Y5(155), Y5(156)
     +    /    66.6D0, 64.5D0, 54.1D0, 39.0D0, 20.6D0,  6.7D0/
      DATA  Y5(157), Y5(158), Y5(159), Y5(160), Y5(161), Y5(162)
     +    /     4.3D0, 22.7D0, 54.8D0, 93.8D0, 95.8D0, 77.2D0/
      DATA  Y5(163), Y5(164), Y5(165), Y5(166), Y5(167), Y5(168)
     +    /    59.1D0, 44.0D0, 47.0D0, 30.5D0, 16.3D0,  7.3D0/
      DATA  Y5(169), Y5(170), Y5(171), Y5(172), Y5(173), Y5(174)
     +    /    37.6D0, 74.0D0,139.0D0,111.2D0,101.6D0, 66.2D0/
      DATA  Y5(175), Y5(176), Y5(177), Y5(178), Y5(179), Y5(180)
     +    /    44.7D0, 17.0D0, 11.3D0, 12.4D0,  3.4D0,  6.0D0/
      DATA  Y5(181), Y5(182), Y5(183), Y5(184), Y5(185), Y5(186)
     +    /    32.3D0, 54.3D0, 59.7D0, 63.7D0, 63.5D0, 52.2D0/
      DATA  Y5(187), Y5(188), Y5(189), Y5(190), Y5(191), Y5(192)
     +    /    25.4D0, 13.1D0,  6.8D0,  6.3D0,  7.1D0, 35.6D0/
      DATA  Y5(193), Y5(194), Y5(195), Y5(196), Y5(197), Y5(198)
     +    /    73.0D0, 85.1D0, 78.0D0, 64.0D0, 41.8D0, 26.2D0/
      DATA  Y5(199), Y5(200), Y5(201), Y5(202), Y5(203), Y5(204)
     +    /    26.7D0, 12.1D0,  9.5D0,  2.7D0,  5.0D0, 24.4D0/
      DATA  Y5(205), Y5(206), Y5(207), Y5(208), Y5(209), Y5(210)
     +    /    42.0D0, 63.5D0, 53.8D0, 62.0D0, 48.5D0, 43.9D0/
      DATA  Y5(211), Y5(212), Y5(213), Y5(214), Y5(215), Y5(216)
     +    /    18.6D0,  5.7D0,  3.6D0,  1.4D0,  9.6D0, 47.4D0/
      DATA  Y5(217), Y5(218), Y5(219), Y5(220), Y5(221), Y5(222)
     +    /    57.1D0,103.9D0, 80.6D0, 63.6D0, 37.6D0, 26.1D0/
      DATA  Y5(223), Y5(224), Y5(225), Y5(226), Y5(227), Y5(228)
     +    /    14.2D0,  5.8D0, 16.7D0, 44.3D0, 63.9D0, 69.0D0/
      DATA  Y5(229), Y5(230), Y5(231), Y5(232), Y5(233), Y5(234)
     +    /    77.8D0, 64.9D0, 35.7D0, 21.2D0, 11.1D0,  5.7D0/
      DATA  Y5(235), Y5(236), Y5(237), Y5(238), Y5(239), Y5(240)
     +    /     8.7D0, 36.1D0, 79.7D0,114.4D0,109.6D0, 88.8D0/
      DATA  Y5(241), Y5(242), Y5(243), Y5(244), Y5(245), Y5(246)
     +    /    67.8D0, 47.5D0, 30.6D0, 16.3D0,  9.6D0, 33.2D0/
      DATA  Y5(247), Y5(248), Y5(249), Y5(250), Y5(251), Y5(252)
     +    /    92.6D0,151.6D0,136.3D0,134.7D0, 83.9D0, 69.4D0/
      DATA  Y5(253), Y5(254), Y5(255), Y5(256), Y5(257), Y5(258)
     +    /    31.5D0, 13.9D0,  4.4D0, 38.0D0,141.7D0,190.2D0/
      DATA  Y5(259), Y5(260), Y5(261)
     +    /   184.8D0,159.0D0,112.3D0/
C
C     DEFINE CONSTANTS
C
      CALL IPRINT(IPRT)
      LPER = 300
      LFREQ = 300
      LYFFT = 600
C
      NY1 = 100
      NY2 = 50
      NY3 = 50
      NY4 = 50
      NY5 = 261
      NY6 = 100
C
      NK = 3
      KMD(1) = 8
      KMD(2) = 8
      KMD(3) = 8
C
      TAPERP = 0.10
C
      NFFT = 514
      IEXTND = 0
      NPRT = -1
C
      ILOG = 1
C
C     WRITE HEADER
C
      WRITE(IPRT, 1000)
C
C     RUN SIMPLE TEST OF ACF
C
      WRITE(IPRT, 1100)
      CALL ACF (Y1, NY1)
      WRITE (IPRT,2000) IERR
C
C     RUN SIMPLE TEST OF CCF
C
      WRITE(IPRT, 1200)
      CALL CCF (Y2A, Y2B, NY2)
      WRITE (IPRT,2000) IERR
C
C     RUN SIMPLE TEST OF UFS
C
      WRITE(IPRT, 1300)
      CALL UFS (Y3, NY3)
      WRITE (IPRT,2000) IERR
C
C     RUN SIMPLE TEST OF UAS
C
      WRITE(IPRT, 1400)
      CALL UAS (Y4, NY4)
      WRITE (IPRT,2000) IERR
C
C     RUN SIMPLE TEST OF TAPER
C
      WRITE(IPRT, 1510)
      CALL TAPER (Y5, NY5, TAPERP, YFFT)
      WRITE (IPRT,2000) IERR
C
C     RUN SIMPLE TEST OF PGMS
C
      WRITE(IPRT, 1520)
      CALL PGMS(YFFT, NY5, NFFT, LYFFT,
     +          IEXTND, NF, PER, LPER, FREQ, LFREQ, NPRT)
      WRITE (IPRT,2000) IERR
C
C     RUN SIMPLE TEST OF MDFLT
C
      WRITE(IPRT, 1530)
      CALL MDFLT (PER, NF, NK, KMD, PERF, LDSTAK)
      WRITE (IPRT,2000) IERR
C
C     DISPLAY RESULTS OF MDFLT
C
      WRITE(IPRT, 1540)
      CALL PPL (PERF, FREQ, NF, ILOG)
      WRITE (IPRT,2000) IERR
C
C     RUN SIMPLE TEST OF BFS
C
      WRITE(IPRT, 1600)
      CALL BFS (Y6A, Y6B, NY6)
      WRITE (IPRT,2000) IERR
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT ('1*CH12')
 1100 FORMAT (' SIMPLE TEST OF ACF')
 1200 FORMAT ('1SIMPLE TEST OF CCF')
 1300 FORMAT ('1SIMPLE TEST OF UFS')
 1400 FORMAT ('1SIMPLE TEST OF UAS')
 1510 FORMAT ('1SIMPLE TEST OF TAPER (NO OUTPUT UNLESS ERROR FOUND)')
 1520 FORMAT ('1SIMPLE TEST OF PGMS')
 1530 FORMAT ('1SIMPLE TEST OF MDFLT (NO OUTPUT UNLESS ERROR FOUND)')
 1540 FORMAT ('1DISPLAY RESULTS OF MDFLT')
 1600 FORMAT ('1SIMPLE TEST OF BFS')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
*XXCH13
      SUBROUTINE XXCH13(LDSTAK)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
C     THE ARIMA MODELING AND FORECASTING FAMILY OF ROUTINES.
C
C     DATA IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND JENKINS.
C
C     WRITTEN BY  -  JANET R. DONALDSON
C                    STATISTICAL ENGINEERING DIVISION
C                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  AUGUST 3, 1987
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
C
C  LOCAL SCALARS
      INTEGER
     +   I,IPRT,N,NFAC,NPAR
C
C  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AIR(200),PAR(10),RES(200),Y(200)
      INTEGER
     +   MSPEC(4,10)
C
C  EXTERNAL SUBROUTINES
      EXTERNAL AIME,AIMF,IPRINT
C
C  INTRINSIC FUNCTIONS
      INTRINSIC LOG
C
C  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     DOUBLE PRECISION AIR(200)
C        THE AIRLINE DATA.
C     DOUBLE PRECISION DSTAK(12)
C        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
C        IF IERR .GE. 1, ERRORS WERE DETECTED.
C     INTEGER IPRT
C        THE UNIT NUMBER FOR PRINTED OUTPUT.
C     INTEGER LDSTAK
C        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
C     INTEGER MSPEC(4,10)
C        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH
C        FACTOR.
C     INTEGER N
C        THE NUMBER OF OBSERVATIONS.
C     INTEGER NFAC
C        THE NUMBER OF FACTORS IN THE MODEL
C     INTEGER NPAR
C        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
C     DOUBLE PRECISION PAR(10)
C        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
C        PARAMETERS ARE STORED.
C     DOUBLE PRECISION RES(200)
C        THE RESIDUALS FROM THE FIT.
C     DOUBLE PRECISION Y(200)
C        THE ARRAY OF THE DEPENDENT VARIABLE.
C
C     DEFINE CONSTANTS
C
      DATA MSPEC(1,1), MSPEC(2,1), MSPEC(3,1), MSPEC(4,1)
     +   /          0,          1,          1,          1/
      DATA MSPEC(1,2), MSPEC(2,2), MSPEC(3,2), MSPEC(4,2)
     +   /          0,          1,          1,         12/
C
      DATA  AIR(  1), AIR(  2), AIR(  3), AIR(  4), AIR(  5), AIR(  6)
     +    / 112.0D0, 118.0D0, 132.0D0, 129.0D0, 121.0D0, 135.0D0/
      DATA  AIR(  7), AIR(  8), AIR(  9), AIR( 10), AIR( 11), AIR( 12)
     +    / 148.0D0, 148.0D0, 136.0D0, 119.0D0, 104.0D0, 118.0D0/
      DATA  AIR( 13), AIR( 14), AIR( 15), AIR( 16), AIR( 17), AIR( 18)
     +    / 115.0D0, 126.0D0, 141.0D0, 135.0D0, 125.0D0, 149.0D0/
      DATA  AIR( 19), AIR( 20), AIR( 21), AIR( 22), AIR( 23), AIR( 24)
     +    / 170.0D0, 170.0D0, 158.0D0, 133.0D0, 114.0D0, 140.0D0/
      DATA  AIR( 25), AIR( 26), AIR( 27), AIR( 28), AIR( 29), AIR( 30)
     +    / 145.0D0, 150.0D0, 178.0D0, 163.0D0, 172.0D0, 178.0D0/
      DATA  AIR( 31), AIR( 32), AIR( 33), AIR( 34), AIR( 35), AIR( 36)
     +    / 199.0D0, 199.0D0, 184.0D0, 162.0D0, 146.0D0, 166.0D0/
      DATA  AIR( 37), AIR( 38), AIR( 39), AIR( 40), AIR( 41), AIR( 42)
     +    / 171.0D0, 180.0D0, 193.0D0, 181.0D0, 183.0D0, 218.0D0/
      DATA  AIR( 43), AIR( 44), AIR( 45), AIR( 46), AIR( 47), AIR( 48)
     +    / 230.0D0, 242.0D0, 209.0D0, 191.0D0, 172.0D0, 194.0D0/
      DATA  AIR( 49), AIR( 50), AIR( 51), AIR( 52), AIR( 53), AIR( 54)
     +    / 196.0D0, 196.0D0, 236.0D0, 235.0D0, 229.0D0, 243.0D0/
      DATA  AIR( 55), AIR( 56), AIR( 57), AIR( 58), AIR( 59), AIR( 60)
     +    / 264.0D0, 272.0D0, 237.0D0, 211.0D0, 180.0D0, 201.0D0/
      DATA  AIR( 61), AIR( 62), AIR( 63), AIR( 64), AIR( 65), AIR( 66)
     +    / 204.0D0, 188.0D0, 235.0D0, 227.0D0, 234.0D0, 264.0D0/
      DATA  AIR( 67), AIR( 68), AIR( 69), AIR( 70), AIR( 71), AIR( 72)
     +    / 302.0D0, 293.0D0, 259.0D0, 229.0D0, 203.0D0, 229.0D0/
      DATA  AIR( 73), AIR( 74), AIR( 75), AIR( 76), AIR( 77), AIR( 78)
     +    / 242.0D0, 233.0D0, 267.0D0, 269.0D0, 270.0D0, 315.0D0/
      DATA  AIR( 79), AIR( 80), AIR( 81), AIR( 82), AIR( 83), AIR( 84)
     +    / 364.0D0, 347.0D0, 312.0D0, 274.0D0, 237.0D0, 278.0D0/
      DATA  AIR( 85), AIR( 86), AIR( 87), AIR( 88), AIR( 89), AIR( 90)
     +    / 284.0D0, 277.0D0, 317.0D0, 313.0D0, 318.0D0, 374.0D0/
      DATA  AIR( 91), AIR( 92), AIR( 93), AIR( 94), AIR( 95), AIR( 96)
     +    / 413.0D0, 405.0D0, 355.0D0, 306.0D0, 271.0D0, 306.0D0/
      DATA  AIR( 97), AIR( 98), AIR( 99), AIR(100), AIR(101), AIR(102)
     +    / 315.0D0, 301.0D0, 356.0D0, 348.0D0, 355.0D0, 422.0D0/
      DATA  AIR(103), AIR(104), AIR(105), AIR(106), AIR(107), AIR(108)
     +    / 465.0D0, 467.0D0, 404.0D0, 347.0D0, 305.0D0, 336.0D0/
      DATA  AIR(109), AIR(110), AIR(111), AIR(112), AIR(113), AIR(114)
     +    / 340.0D0, 318.0D0, 362.0D0, 348.0D0, 363.0D0, 435.0D0/
      DATA  AIR(115), AIR(116), AIR(117), AIR(118), AIR(119), AIR(120)
     +    / 491.0D0, 505.0D0, 404.0D0, 359.0D0, 310.0D0, 337.0D0/
      DATA  AIR(121), AIR(122), AIR(123), AIR(124), AIR(125), AIR(126)
     +    / 360.0D0, 342.0D0, 406.0D0, 396.0D0, 420.0D0, 472.0D0/
      DATA  AIR(127), AIR(128), AIR(129), AIR(130), AIR(131), AIR(132)
     +    / 548.0D0, 559.0D0, 463.0D0, 407.0D0, 362.0D0, 405.0D0/
      DATA  AIR(133), AIR(134), AIR(135), AIR(136), AIR(137), AIR(138)
     +    / 417.0D0, 391.0D0, 419.0D0, 461.0D0, 472.0D0, 535.0D0/
      DATA  AIR(139), AIR(140), AIR(141), AIR(142), AIR(143), AIR(144)
     +    / 622.0D0, 606.0D0, 508.0D0, 461.0D0, 390.0D0, 432.0D0/
C
      CALL IPRINT(IPRT)
C
      NFAC = 2
      N = 144
C
      NPAR = 3
      PAR(1) = 0.000
      PAR(2) = 0.395
      PAR(3) = 0.615
C
      DO 10 I = 1, N
        Y(I) = LOG(AIR(I))
   10 CONTINUE
C
C     RUN SIMPLE TEST OF AIME
C
      WRITE (IPRT,1000)
      WRITE (IPRT,1100)
      CALL AIME (Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK)
      WRITE (IPRT,2000) IERR
C
C     RUN SIMPLE TEST OF AIMF
C
      WRITE (IPRT,1200)
      CALL AIMF (Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK)
      WRITE (IPRT,2000) IERR
C
      RETURN
C
C     FORMAT STATEMENTS
C
 1000 FORMAT ('1*CH13')
 1100 FORMAT (' SIMPLE TEST OF AIME')
 1200 FORMAT ('1SIMPLE TEST OF AIMF')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
