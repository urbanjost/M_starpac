!NL2SOL
      subroutine nl2sol(n, p, x, calcr, calcj, iv, v, uiparm, urparm,
     &                  ufparm)
!
!  ***  MINIMIZE NONLINEAR SUM OF SQUARES USING ANALYTIC JACOBIAN  ***
!  ***  (NL2SOL VERSION 2.2)  ***
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer n,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: urparm(*),v(*),x(p)
      integer iv(*),uiparm(*)
!
!  SUBROUTINE ARGUMENTS
      external calcj,calcr,ufparm
!
!  LOCAL SCALARS
      integer d,d1,j,j1,nf,nfcall,nfgcal,r,r1,toobig
      logical strted
!
!  EXTERNAL SUBROUTINES
      external itsmry,nl2itr
!
!
!     INTEGER N, P, IV(1), UIPARM(1)
!     REAL(KIND=WP) :: X(P), V(1), URPARM(1)
!     DIMENSION IV(60+P),  V(93 + N*P + 3*N + P*(3*P+33)/2)
!     DIMENSION UIPARM(*), URPARM(*)
!     EXTERNAL CALCR, CALCJ, UFPARM
!
!  ***  PURPOSE  ***
!
!        GIVEN A P-VECTOR X OF PARAMETERS, CALCR COMPUTES AN N-VECTOR
!     R = R(X) OF RESIDUALS CORRESPONDING TO X.  (R(X) PROBABLY ARISES
!     FROM A NONLINEAR MODEL INVOLVING P PARAMETERS AND N OBSERVATIONS.)
!     THIS ROUTINE INTERACTS WITH NL2ITR TO SEEK A PARAMETER VECTOR X
!     THAT MINIMIZES THE SUM OF THE SQUARES OF (THE COMPONENTS OF) R(X),
!     I.E., THAT MINIMIZES THE SUM-OF-SQUARES FUNCTION
!     F(X) = (R(X)**T) * R(X) / 2.  R(X) IS ASSUMED TO BE A TWICE CONTINUOUSLY
!     DIFFERENTIABLE FUNCTION OF X.
!
!--------------------------  PARAMETER USAGE  --------------------------
!
! N........ (INPUT) THE NUMBER OF OBSERVATIONS, I.E., THE NUMBER OF
!                  COMPONENTS IN R(X).  N MUST BE .GE. P.
! P........ (INPUT) THE NUMBER OF PARAMETERS (COMPONENTS IN X).  P MUST
!                  BE POSITIVE.
! X........ (INPUT/OUTPUT).  ON INPUT, X IS AN INITIAL GUESS AT THE
!                  DESIRED PARAMETER ESTIMATE.  ON OUTPUT, X CONTAINS
!                  THE BEST PARAMETER ESTIMATE FOUND.
! CALCR.... (INPUT) A SUBROUTINE WHICH, GIVEN X, COMPUTES R(X).  CALCR
!                  MUST BE DECLARED EXTERNAL IN THE CALLING PROGRAM.
!                  IT IS INVOKED BY
!                       CALL CALCR(N,P,X,NF,R,UIPARM,URPARM,UFPARM)
!                  WHEN CALCR IS CALLED, NF IS THE INVOCATION COUNT
!                  FOR CALCR.  IT IS INCLUDED FOR POSSIBLE USE WITH
!                  CALCJ.  IF X IS OUT OF BOUNDS (E.G. IF IT WOULD
!                  CAUSE OVERFLOW IN COMPUTING R(X)), THEN CALCR SHOULD
!                  SET NF TO 0.  THIS WILL CAUSE A SHORTER STEP TO BE
!                  ATTEMPTED.  THE OTHER PARAMETERS ARE AS DESCRIBED
!                  ABOVE AND BELOW.  CALCR SHOULD NOT CHANGE N, P, OR X.
! CALCJ.... (INPUT) A SUBROUTINE WHICH, GIVEN X, COMPUTES THE JACOBIAN
!                  MATRIX J OF R AT X, I.E., THE N BY P MATRIX WHOSE
!                  (I,K) ENTRY IS THE PARTIAL DERIVATIVE OF THE I-TH
!                  COMPONENT OF R WITH RESPECT TO X(K).  CALCJ MUST BE
!                  DECLARED EXTERNAL IN THE CALLING PROGRAM.  IT IS
!                  INVOKED BY
!                       CALL CALCJ(N,P,X,NF,J,UIPARM,URPARM,UFPARM)
!                  NF IS THE INVOCATION COUNT FOR CALCR AT THE TIME
!                  R(X) WAS EVALUATED.  THE X PASSED TO CALCJ IS
!                  USUALLY THE ONE PASSED TO CALCR ON EITHER ITS MOST
!                  RECENT INVOCATION OR THE ONE PRIOR TO IT.  IF CALCR
!                  SAVES INTERMEDIATE RESULTS FOR USE BY CALCJ, THEN IT
!                  IS POSSIBLE TO TELL FROM NF WHETHER THEY ARE VALID
!                  FOR THE CURRENT X (OR WHICH COPY IS VALID IF TWO
!                  COPIES ARE KEPT).  IF J CANNOT BE COMPUTED AT X,
!                  THEN CALCJ SHOULD SET NF TO 0.  IN THIS CASE, NL2SOL
!                  WILL RETURN WITH IV(1) = 15.  THE OTHER PARAMETERS
!                  TO CALCJ ARE AS DESCRIBED ABOVE AND BELOW.  CALCJ
!                  SHOULD NOT CHANGE N, P, OR X.
! IV....... (INPUT/OUTPUT) AN INTEGER VALUE ARRAY OF LENGTH AT LEAST
!                  60 + P THAT HELPS CONTROL THE NL2SOL ALGORITHM AND
!                  THAT IS USED TO STORE VARIOUS INTERMEDIATE QUANTITIES.
!                  OF PARTICULAR INTEREST ARE THE INITIALIZATION/
!                  RETURN CODE IV(1) AND THE ENTRIES IN IV THAT CONTROL
!                  PRINTING AND LIMIT THE NUMBER OF ITERATIONS AND FUNCTION
!                  EVALUATIONS.  SEE THE SECTION ON IV INPUT
!                  VALUES BELOW.
! V........ (INPUT/OUTPUT) A FLOATING-POINT VALUE ARRAY OF LENGTH AT
!                  LEAST 93 + N*P + 3*N + P*(3*P+33) THAT HELPS CONTROL
!                  THE NL2SOL ALGORITHM AND THAT IS USED TO STORE
!                  VARIOUS INTERMEDIATE QUANTITIES.  OF PARTICULAR INTEREST
!                  ARE THE ENTRIES IN V THAT LIMIT THE LENGTH OF
!                  THE FIRST STEP ATTEMPTED (LMAX0), SPECIFY CONVERGENCE
!                  TOLERANCES (AFCTOL, RFCTOL, XCTOL, XFTOL),
!                  AND HELP CHOOSE THE STEP SIZE USED IN COMPUTING THE
!                  COVARIANCE MATRIX (DELTA0).  SEE THE SECTION ON
!                  (SELECTED) V INPUT VALUES BELOW.
! UIPARM... (INPUT) USER INTEGER PARAMETER ARRAY PASSED WITHOUT CHANGE
!                  TO CALCR AND CALCJ.
! URPARM... (INPUT) USER FLOATING-POINT PARAMETER ARRAY PASSED WITHOUT
!                  CHANGE TO CALCR AND CALCJ.
! UFPARM... (INPUT) USER EXTERNAL SUBROUTINE OR FUNCTION PASSED WITHOUT
!                  CHANGE TO CALCR AND CALCJ.
!
!  ***  IV INPUT VALUES (FROM SUBROUTINE DFAULT)  ***
!
! IV(1)...  ON INPUT, IV(1) SHOULD HAVE A VALUE BETWEEN 0 AND 12......
!             0 AND 12 MEAN THIS IS A FRESH START.  0 MEANS THAT
!             DFAULT(IV, V) IS TO BE CALLED TO PROVIDE ALL DEFAULT
!             VALUES TO IV AND V.  12 (THE VALUE THAT DFAULT ASSIGNS TO
!             IV(1)) MEANS THE CALLER HAS ALREADY CALLED DFAULT(IV, V)
!             AND HAS POSSIBLY CHANGED SOME IV AND/OR V ENTRIES TO NON-
!             DEFAULT VALUES.  DEFAULT = 12.
! IV(COVPRT)... IV(14) = 1 MEANS PRINT A COVARIANCE MATRIX AT THE SOLUTION.
!             (THIS MATRIX IS COMPUTED JUST BEFORE A RETURN WITH
!             IV(1) = 3, 4, 5, 6.)
!             IV(COVPRT) = 0 MEANS SKIP THIS PRINTING.  DEFAULT = 1.
! IV(COVREQ)... IV(15) = NONZERO MEANS COMPUTE A COVARIANCE MATRIX
!             JUST BEFORE A RETURN WITH IV(1) = 3, 4, 5, 6.  IN
!             THIS CASE, AN APPROXIMATE COVARIANCE MATRIX IS OBTAINED
!             IN ONE OF SEVERAL WAYS.  LET K = ABS(IV(COVREQ)) AND LET
!             SCALE = 2*F(X)/MAX(1,N-P),  WHERE 2*F(X) IS THE RESIDUAL
!             SUM OF SQUARES.  IF K = 1 OR 2, THEN A FINITE-DIFFERENCE
!             HESSIAN APPROXIMATION H IS OBTAINED.  IF H IS POSITIVE
!             DEFINITE (OR, FOR K = 3, IF THE JACOBIAN MATRIX J AT X
!             IS NONSINGULAR), THEN ONE OF THE FOLLOWING IS COMPUTED...
!                  K = 1....  SCALE * H**-1 * (J**T * J) * H**-1.
!                  K = 2....  SCALE * H**-1.
!                  K = 3....  SCALE * (J**T * J)**-1.
!             (J**T IS THE TRANSPOSE OF J, WHILE **-1 MEANS INVERSE.)
!             IF IV(COVREQ) IS POSITIVE, THEN BOTH FUNCTION AND GRADIENT
!             VALUES (CALLS ON CALCR AND CALCJ) ARE USED IN COMPUTING
!             H (WITH STEP SIZES DETERMINED USING V(DELTA0) --
!             SEE BELOW), WHILE IF IV(COVREQ) IS NEGATIVE, THEN ONLY
!             FUNCTION VALUES (CALLS ON CALCR) ARE USED (WITH STEP
!             SIZES DETERMINED USING V(DLTFDC) -- SEE BELOW).  IF
!             IV(COVREQ) = 0, THEN NO ATTEMPT IS MADE TO COMPUTE A
!             COVARIANCE MATRIX (UNLESS IV(COVPRT) = 1, IN WHICH CASE
!             IV(COVREQ) = 1 IS ASSUMED).  SEE IV(COVMAT) BELOW.
!             DEFAULT = 1.
! IV(DTYPE).... IV(16) TELLS HOW THE SCALE VECTOR D (SEE REF. 1) SHOULD
!             BE CHOSEN.  IV(DTYPE) .GE. 1 MEANS CHOOSE D AS DESCRIBED
!             BELOW WITH V(DFAC).  IV(DTYPE) .LE. 0 MEANS THE CALLER
!             HAS CHOSEN D AND HAS STORED IT IN V STARTING AT
!             V(94 + 2*N + P*(3*P + 31)/2).  DEFAULT = 1.
! IV(INITS).... IV(25) TELLS HOW THE S MATRIX (SEE REF. 1) SHOULD BE
!             INITIALIZED.  0 MEANS INITIALIZE S TO 0 (AND START WITH
!             THE GAUSS-NEWTON MODEL).  1 AND 2 MEAN THAT THE CALLER
!             HAS STORED THE LOWER TRIANGLE OF THE INITIAL S ROWWISE IN
!             V STARTING AT V(87+2*P).  IV(INITS) = 1 MEANS START WITH
!             THE GAUSS-NEWTON MODEL, WHILE IV(INITS) = 2 MEANS START
!             WITH THE AUGMENTED MODEL (SEE REF. 1).  DEFAULT = 0.
! IV(MXFCAL)... IV(17) GIVES THE MAXIMUM NUMBER OF FUNCTION EVALUATIONS
!             (CALLS ON CALCR, EXCLUDING THOSE USED TO COMPUTE THE
!             COVARIANCE MATRIX) ALLOWED.  IF THIS NUMBER DOES NOT SUFFICE,
!             THEN NL2SOL RETURNS WITH IV(1) = 9.  DEFAULT = 200.
! IV(MXITER)... IV(18) GIVES THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!             IT ALSO INDIRECTLY LIMITS THE NUMBER OF GRADIENT EVALUATIONS
!             (CALLS ON CALCJ, EXCLUDING THOSE USED TO COMPUTE
!             THE COVARIANCE MATRIX) TO IV(MXITER) + 1.  IF IV(MXITER)
!             ITERATIONS DO NOT SUFFICE, THEN NL2SOL RETURNS WITH
!             IV(1) = 10.  DEFAULT = 150.
! IV(OUTLEV)... IV(19) CONTROLS THE NUMBER AND LENGTH OF ITERATION SUMMARY
!             LINES PRINTED (BY ITSMRY).  IV(OUTLEV) = 0 MEANS DO
!             NOT PRINT ANY SUMMARY LINES.  OTHERWISE, PRINT A SUMMARY
!             LINE AFTER EACH ABS(IV(OUTLEV)) ITERATIONS.  IF IV(OUTLEV)
!             IS POSITIVE, THEN SUMMARY LINES OF LENGTH 117 (PLUS CARRIAGE
!             CONTROL) ARE PRINTED, INCLUDING THE FOLLOWING...  THE
!             ITERATION AND FUNCTION EVALUATION COUNTS, CURRENT FUNCTION
!             VALUE (V(F) = HALF THE SUM OF SQUARES), RELATIVE
!             DIFFERENCE IN FUNCTION VALUES ACHIEVED BY THE LATEST STEP
!             (I.E., RELDF = (F0-V(F))/F0, WHERE F0 IS THE FUNCTION
!             VALUE FROM THE PREVIOUS ITERATION), THE RELATIVE FUNCTION
!             REDUCTION PREDICTED FOR THE STEP JUST TAKEN (I.E.,
!             PRELDF = V(PREDUC) / F0, WHERE V(PREDUC) IS DESCRIBED
!             BELOW), THE SCALED RELATIVE CHANGE IN X (SEE V(RELDX)
!             BELOW), THE MODELS USED IN THE CURRENT ITERATION (G =
!             GAUSS-NEWTON, S=AUGMENTED), THE MARQUARDT PARAMETER
!             STPPAR USED IN COMPUTING THE LAST STEP, THE SIZING FACTOR
!             USED IN UPDATING S, THE 2-NORM OF THE SCALE VECTOR D
!             TIMES THE STEP JUST TAKEN (SEE REF. 1), AND NPRELDF, I.E.,
!             V(NREDUC)/F0, WHERE V(NREDUC) IS DESCRIBED BELOW -- IF
!             NPRELDF IS POSITIVE, THEN IT IS THE RELATIVE FUNCTION
!             REDUCTION PREDICTED FOR A NEWTON STEP (ONE WITH
!             STPPAR = 0).  IF NPRELDF IS ZERO, EITHER THE GRADIENT
!             VANISHES (AS DOES PRELDF) OR ELSE THE AUGMENTED MODEL
!             IS BEING USED AND ITS HESSIAN IS INDEFINITE (WITH PRELDF
!             POSITIVE).  IF NPRELDF IS NEGATIVE, THEN IT IS THE NEGATIVE
!             OF THE RELATIVE FUNCTION REDUCTION PREDICTED FOR A STEP
!             COMPUTED WITH STEP BOUND V(LMAX0) FOR USE IN TESTING FOR
!             SINGULAR CONVERGENCE.
!                  IF IV(OUTLEV) IS NEGATIVE, THEN LINES OF MAXIMUM
!             LENGTH 79 (OR 55 IS IV(COVPRT) = 0) ARE PRINTED, INCLUDING
!             ONLY THE FIRST 6 ITEMS LISTED ABOVE (THROUGH RELDX).
!             DEFAULT = 1.
! IV(PARPRT)... IV(20) = 1 MEANS PRINT ANY NONDEFAULT V VALUES ON A
!             FRESH START OR ANY CHANGED V VALUES ON A RESTART.
!             IV(PARPRT) = 0 MEANS SKIP THIS PRINTING.  DEFAULT = 1.
! IV(PRUNIT)... IV(21) IS THE OUTPUT UNIT NUMBER ON WHICH ALL PRINTING
!             IS DONE.  IV(PRUNIT) = 0 MEANS SUPPRESS ALL PRINTING.
!             (SETTING IV(PRUNIT) TO 0 IS THE ONLY WAY TO SUPPRESS THE
!             ONE-LINE TERMINATION REASON MESSAGE PRINTED BY ITSMRY.)
!             DEFAULT = STANDARD OUTPUT UNIT (UNIT 6 ON MOST SYSTEMS).
! IV(SOLPRT)... IV(22) = 1 MEANS PRINT OUT THE VALUE OF X RETURNED (AS
!             WELL AS THE CORRESPONDING GRADIENT AND SCALE VECTOR D).
!             IV(SOLPRT) = 0 MEANS SKIP THIS PRINTING.  DEFAULT = 1.
! IV(STATPR)... IV(23) = 1 MEANS PRINT SUMMARY STATISTICS UPON RETURNING.
!             THESE CONSIST OF THE FUNCTION VALUE (HALF THE SUM
!             OF SQUARES) AT X, V(RELDX) (SEE BELOW), THE NUMBER OF
!             FUNCTION AND GRADIENT EVALUATIONS (CALLS ON CALCR AND
!             CALCJ RESPECTIVELY, EXCLUDING ANY CALLS USED TO COMPUTE
!             THE COVARIANCE), THE RELATIVE FUNCTION REDUCTIONS PREDICTED
!             FOR THE LAST STEP TAKEN AND FOR A NEWTON STEP (OR PERHAPS
!             A STEP BOUNDED BY V(LMAX0) -- SEE THE DESCRIPTIONS
!             OF PRELDF AND NPRELDF UNDER IV(OUTLEV) ABOVE), AND (IF AN
!             ATTEMPT WAS MADE TO COMPUTE THE COVARIANCE) THE NUMBER OF
!             CALLS ON CALCR AND CALCJ USED IN TRYING TO COMPUTE THE
!             COVARIANCE.  IV(STATPR) = 0 MEANS SKIP THIS PRINTING.
!             DEFAULT = 1.
! IV(X0PRT).... IV(24) = 1 MEANS PRINT THE INITIAL X AND SCALE VECTOR D
!             (ON A FRESH START ONLY).  IV(X0PRT) = 0 MEANS SKIP THIS
!             PRINTING.  DEFAULT = 1.
!
!  ***  (SELECTED) IV OUTPUT VALUES  ***
!
! IV(1)........ ON OUTPUT, IV(1) IS A RETURN CODE....
!             3 = X-CONVERGENCE.  THE SCALED RELATIVE DIFFERENCE BETWEEN
!                  THE CURRENT PARAMETER VECTOR X AND A LOCALLY
!                  OPTIMAL PARAMETER VECTOR IS VERY LIKELY AT MOST
!                  V(XCTOL).
!             4 = RELATIVE FUNCTION CONVERGENCE.  THE RELATIVE DIFFERENCE
!                  BETWEEN THE CURRENT FUNCTION VALUE AND ITS LOCALLY
!                  OPTIMAL VALUE IS VERY LIKELY AT MOST V(RFCTOL).
!             5 = BOTH X- AND RELATIVE FUNCTION CONVERGENCE (I.E., THE
!                  CONDITIONS FOR IV(1) = 3 AND IV(1) = 4 BOTH HOLD).
!             6 = ABSOLUTE FUNCTION CONVERGENCE.  THE CURRENT FUNCTION
!                  VALUE IS AT MOST V(AFCTOL) IN ABSOLUTE VALUE.
!             7 = SINGULAR CONVERGENCE.  THE HESSIAN NEAR THE CURRENT
!                  ITERATE APPEARS TO BE SINGULAR OR NEARLY SO, AND A
!                  STEP OF LENGTH AT MOST V(LMAX0) IS UNLIKELY TO YIELD
!                  A RELATIVE FUNCTION DECREASE OF MORE THAN V(RFCTOL).
!             8 = FALSE CONVERGENCE.  THE ITERATES APPEAR TO BE CONVERGING
!                  TO A NONCRITICAL POINT.  THIS MAY MEAN THAT THE
!                  CONVERGENCE TOLERANCES (V(AFCTOL), V(RFCTOL),
!                  V(XCTOL)) ARE TOO SMALL FOR THE ACCURACY TO WHICH
!                  THE FUNCTION AND GRADIENT ARE BEING COMPUTED, THAT
!                  THERE IS AN ERROR IN COMPUTING THE GRADIENT, OR THAT
!                  THE FUNCTION OR GRADIENT IS DISCONTINUOUS NEAR X.
!             9 = FUNCTION EVALUATION LIMIT REACHED WITHOUT OTHER CONVERGENCE
!                  (SEE IV(MXFCAL)).
!            10 = ITERATION LIMIT REACHED WITHOUT OTHER CONVERGENCE
!                  (SEE IV(MXITER)).
!            11 = STOPX RETURNED .TRUE. (EXTERNAL INTERUPT).  SEE THE
!                  USAGE NOTES BELOW.
!            13 = F(X) CANNOT BE COMPUTED AT THE INITIAL X.
!            14 = BAD PARAMETERS PASSED TO ASSESS (WHICH SHOULD NOT
!                  OCCUR).
!            15 = THE JACOBIAN COULD NOT BE COMPUTED AT X (SEE CALCJ
!                  ABOVE).
!            16 = N OR P (OR PARAMETER NN TO NL2ITR) OUT OF RANGE --
!                  P .LE. 0 OR N .LT. P OR NN .LT. N.
!            17 = RESTART ATTEMPTED WITH N OR P (OR PAR. NN TO NL2ITR)
!                  CHANGED.
!            18 = IV(INITS) IS OUT OF RANGE.
!            19...45 = V(IV(1)-18) IS OUT OF RANGE.
!            50 = IV(1) WAS OUT OF RANGE.
!            87...(86+P) = JTOL(IV(1)-86) (I.E., V(IV(1)) IS NOT
!                  POSITIVE (SEE V(DFAC) BELOW).
! IV(COVMAT)... IV(26) TELLS WHETHER A COVARIANCE MATRIX WAS COMPUTED.
!             IF (IV(COVMAT) IS POSITIVE, THEN THE LOWER TRIANGLE OF
!             THE COVARIANCE MATRIX IS STORED ROWWISE IN V STARTING AT
!             V(IV(COVMAT)).  IF IV(COVMAT) = 0, THEN NO ATTEMPT WAS
!             MADE TO COMPUTE THE COVARIANCE.  IF IV(COVMAT) = -1,
!             THEN THE FINITE-DIFFERENCE HESSIAN WAS INDEFINITE.  AND
!             AND IF IV(COVMAT) = -2, THEN A SUCCESSFUL FINITE-DIFFERENCING
!             STEP COULD NOT BE FOUND FOR SOME COMPONENT OF X
!             (I.E., CALCR SET NF TO 0 FOR EACH OF TWO TRIAL STEPS).
!             NOTE THAT IV(COVMAT) IS RESET TO 0 AFTER EACH SUCCESSFUL
!             STEP, SO IF SUCH A STEP IS TAKEN AFTER A RESTART, THEN
!             THE COVARIANCE MATRIX WILL BE RECOMPUTED.
! IV(D)........ IV(27) IS THE STARTING SUBSCRIPT IN V OF THE CURRENT
!             SCALE VECTOR D.
! IV(G)........ IV(28) IS THE STARTING SUBSCRIPT IN V OF THE CURRENT
!             LEAST-SQUARES GRADIENT VECTOR (J**T)*R.
! IV(NFCALL)... IV(6) IS THE NUMBER OF CALLS SO FAR MADE ON CALCR (I.E.,
!             FUNCTION EVALUATIONS, INCLUDING THOSE USED IN COMPUTING
!             THE COVARIANCE).
! IV(NFCOV).... IV(40) IS THE NUMBER OF CALLS MADE ON CALCR WHEN
!             TRYING TO COMPUTE COVARIANCE MATRICES.
! IV(NGCALL)... IV(30) IS THE NUMBER OF GRADIENT EVALUATIONS (CALLS ON
!             CALCJ) SO FAR DONE (INCLUDING THOSE USED FOR COMPUTING
!             THE COVARIANCE).
! IV(NGCOV).... IV(41) IS THE NUMBER OF CALLS MADE ON CALCJ WHEN
!             TRYING TO COMPUTE COVARIANCE MATRICES.
! IV(NITER).... IV(31) IS THE NUMBER OF ITERATIONS PERFORMED.
! IV(R)........ IV(50) IS THE STARTING SUBSCRIPT IN V OF THE RESIDUAL
!             VECTOR R CORRESPONDING TO X.
!
!  ***  (SELECTED) V INPUT VALUES (FROM SUBROUTINE DFAULT)  ***
!
! V(AFCTOL)... V(31) IS THE ABSOLUTE FUNCTION CONVERGENCE TOLERANCE.
!             IF NL2SOL FINDS A POINT WHERE THE FUNCTION VALUE (HALF
!             THE SUM OF SQUARES) IS LESS THAN V(AFCTOL), AND IF NL2SOL
!             DOES NOT RETURN WITH IV(1) = 3, 4, OR 5, THEN IT RETURNS
!             WITH IV(1) = 6.  DEFAULT = MAX(10**-20, MACHEP**2), WHERE
!             MACHEP IS THE UNIT ROUNDOFF.
! V(DELTA0)... V(44) IS A FACTOR USED IN CHOOSING THE FINITE-DIFFERENCE
!             STEP SIZE USED IN COMPUTING THE COVARIANCE MATRIX WHEN
!             IV(COVREQ) = 1 OR 2.  FOR COMPONENT I, STEP SIZE
!                  V(DELTA0) * MAX(ABS(X(I)), 1/D(I)) * SIGN(X(I))
!             IS USED, WHERE D IS THE CURRENT SCALE VECTOR (SEE REF. 1).
!             (IF THIS STEP RESULTS IN CALCR SETTING NF TO 0, THEN -0.5
!             TIMES THIS STEP IS ALSO TRIED.)  DEFAULT = MACHEP**0.5,
!             WHERE MACHEP IS THE UNIT ROUNDOFF.
! V(DFAC)..... V(41) AND THE D0 AND JTOL ARRAYS (SEE V(D0INIT) AND
!             V(JTINIT)) ARE USED IN UPDATING THE SCALE VECTOR D WHEN
!             IV(DTYPE) .GT. 0.  (D IS INITIALIZED ACCORDING TO
!             V(DINIT).)  LET D1(I) =
!               MAX(SQRT(JCNORM(I)**2 + MAX(S(I,I),0)), V(DFAC)*D(I)),
!             WHERE JCNORM(I) IS THE 2-NORM OF THE I-TH COLUMN OF THE
!             CURRENT JACOBIAN MATRIX AND S IS THE S MATRIX OF REF. 1.
!             IF IV(DTYPE) = 1, THEN D(I) IS SET TO D1(I) UNLESS
!             D1(I) .LT. JTOL(I), IN WHICH CASE D(I) IS SET TO
!                                MAX(D0(I), JTOL(I)).
!             IF IV(DTYPE) .GE. 2, THEN D IS UPDATED DURING THE FIRST
!             ITERATION AS FOR IV(DTYPE) = 1 (AFTER ANY INITIALIZATION
!             DUE TO V(DINIT)) AND IS LEFT UNCHANGED THEREAFTER.
!             DEFAULT = 0.6.
! V(DINIT).... V(38), IF NONNEGATIVE, IS THE VALUE TO WHICH THE SCALE
!             VECTOR D IS INITIALIZED.  DEFAULT = 0.
! V(DLTFDC)... V(40) HELPS CHOOSE THE STEP SIZE USED WHEN COMPUTING THE
!             COVARIANCE MATRIX WHEN IV(COVREQ) = -1 OR -2.  FOR
!             DIFFERENCES INVOLVING X(I), THE STEP SIZE FIRST TRIED IS
!                       V(DLTFDC) * MAX(ABS(X(I)), 1/D(I)),
!             WHERE D IS THE CURRENT SCALE VECTOR (SEE REF. 1).  (IF
!             THIS STEP IS TOO BIG THE FIRST TIME IT IS TRIED, I.E., IF
!             CALCR SETS NF TO 0, THEN -0.5 TIMES THIS STEP IS ALSO
!             TRIED.)  DEFAULT = MACHEP**(1/3), WHERE MACHEP IS THE
!             UNIT ROUNDOFF.
! V(D0INIT)... V(37), IF POSITIVE, IS THE VALUE TO WHICH ALL COMPONENTS
!             OF THE D0 VECTOR (SEE V(DFAC)) ARE INITIALIZED.  IF
!             V(DFAC) = 0, THEN IT IS ASSUMED THAT THE CALLER HAS
!             STORED D0 IN V STARTING AT V(P+87).  DEFAULT = 1.0.
! V(JTINIT)... V(39), IF POSITIVE, IS THE VALUE TO WHICH ALL COMPONENTS
!             OF THE JTOL ARRAY (SEE V(DFAC)) ARE INITIALIZED.  IF
!             V(JTINIT) = 0, THEN IT IS ASSUMED THAT THE CALLER HAS
!             STORED JTOL IN V STARTING AT V(87).  DEFAULT = 10**-6.
! V(LMAX0).... V(35) GIVES THE MAXIMUM 2-NORM ALLOWED FOR D TIMES THE
!             VERY FIRST STEP THAT NL2SOL ATTEMPTS.  IT IS ALSO USED
!             IN TESTING FOR SINGULAR CONVERGENCE -- IF THE FUNCTION
!             REDUCTION PREDICTED FOR A STEP OF LENGTH BOUNDED BY
!             V(LMAX0) IS AT MOST V(RFCTOL) * ABS(F0), WHERE  F0  IS
!             THE FUNCTION VALUE AT THE START OF THE CURRENT ITERATION,
!             AND IF NL2SOL DOES NOT RETURN WITH IV(1) = 3, 4, 5, OR 6,
!             THEN IT RETURNS WITH IV(1) = 7.    DEFAULT = 100.
! V(RFCTOL)... V(32) IS THE RELATIVE FUNCTION CONVERGENCE TOLERANCE.
!             IF THE CURRENT MODEL PREDICTS A MAXIMUM POSSIBLE FUNCTION
!             REDUCTION (SEE V(NREDUC)) OF AT MOST V(RFCTOL)*ABS(F0) AT
!             THE START OF THE CURRENT ITERATION, WHERE  F0  IS THE
!             THEN CURRENT FUNCTION VALUE, AND IF THE LAST STEP ATTEMPTED
!             ACHIEVED NO MORE THAN TWICE THE PREDICTED FUNCTION
!             DECREASE, THEN NL2SOL RETURNS WITH IV(1) = 4 (OR 5).
!             DEFAULT = MAX(10**-10, MACHEP**(2/3)), WHERE MACHEP IS
!             THE UNIT ROUNDOFF.
! V(TUNER1)... V(26) HELPS DECIDE WHEN TO CHECK FOR FALSE CONVERGENCE
!             AND TO CONSIDER SWITCHING MODELS.  THIS IS DONE IF THE
!             ACTUAL FUNCTION DECREASE FROM THE CURRENT STEP IS NO MORE
!             THAN V(TUNER1) TIMES ITS PREDICTED VALUE.  DEFAULT = 0.1.
! V(XCTOL).... V(33) IS THE X-CONVERGENCE TOLERANCE.  IF A NEWTON STEP
!             (SEE V(NREDUC)) IS TRIED THAT HAS V(RELDX) .LE. V(XCTOL)
!             AND IF THIS STEP YIELDS AT MOST TWICE THE PREDICTED FUNCTION
!             DECREASE, THEN NL2SOL RETURNS WITH IV(1) = 3 (OR 5).
!             (SEE THE DESCRIPTION OF V(RELDX) BELOW.)
!             DEFAULT = MACHEP**0.5, WHERE MACHEP IS THE UNIT ROUNDOFF.
! V(XFTOL).... V(34) IS THE FALSE CONVERGENCE TOLERANCE.  IF A STEP IS
!             TRIED THAT GIVES NO MORE THAN V(TUNER1) TIMES THE PREDICTED
!             FUNCTION DECREASE AND THAT HAS V(RELDX) .LE. V(XFTOL),
!             AND IF NL2SOL DOES NOT RETURN WITH IV(1) = 3, 4, 5, 6, OR
!             7, THEN IT RETURNS WITH IV(1) = 8.  (SEE THE DESCRIPTION
!             OF V(RELDX) BELOW.)  DEFAULT = 100*MACHEP, WHERE
!             MACHEP IS THE UNIT ROUNDOFF.
! V(*)........ DFAULT SUPPLIES TO V A NUMBER OF TUNING CONSTANTS, WITH
!             WHICH IT SHOULD ORDINARILY BE UNNECESSARY TO TINKER.  SEE
!             VERSION 2.2 OF THE NL2SOL USAGE SUMMARY (WHICH IS AN
!             APPENDIX TO REF. 1).
!
!  ***  (SELECTED) V OUTPUT VALUES  ***
!
! V(DGNORM)... V(1) IS THE 2-NORM OF (D**-1)*G, WHERE G IS THE MOST RECENTLY
!             COMPUTED GRADIENT AND D IS THE CORRESPONDING SCALE
!             VECTOR.
! V(DSTNRM)... V(2) IS THE 2-NORM OF D*STEP, WHERE STEP IS THE MOST RECENTLY
!             COMPUTED STEP AND D IS THE CURRENT SCALE VECTOR.
! V(F)........ V(10) IS THE CURRENT FUNCTION VALUE (HALF THE SUM OF
!             SQUARES).
! V(F0)....... V(13) IS THE FUNCTION VALUE AT THE START OF THE CURRENT
!             ITERATION.
! V(NREDUC)... V(6), IF POSITIVE, IS THE MAXIMUM FUNCTION REDUCTION
!             POSSIBLE ACCORDING TO THE CURRENT MODEL, I.E., THE FUNCTION
!             REDUCTION PREDICTED FOR A NEWTON STEP (I.E.,
!             STEP = -H**-1 * G,  WHERE  G = (J**T) * R  IS THE CURRENT
!             GRADIENT AND H IS THE CURRENT HESSIAN APPROXIMATION --
!             H = (J**T)*J  FOR THE GAUSS-NEWTON MODEL AND
!             H = (J**T)*J + S  FOR THE AUGMENTED MODEL).
!                  V(NREDUC) = ZERO MEANS H IS NOT POSITIVE DEFINITE.
!                  IF V(NREDUC) IS NEGATIVE, THEN IT IS THE NEGATIVE OF
!             THE FUNCTION REDUCTION PREDICTED FOR A STEP COMPUTED WITH
!             A STEP BOUND OF V(LMAX0) FOR USE IN TESTING FOR SINGULAR
!             CONVERGENCE.
! V(PREDUC)... V(7) IS THE FUNCTION REDUCTION PREDICTED (BY THE CURRENT
!             QUADRATIC MODEL) FOR THE CURRENT STEP.  THIS (DIVIDED BY
!             V(F0)) IS USED IN TESTING FOR RELATIVE FUNCTION
!             CONVERGENCE.
! V(RELDX).... V(17) IS THE SCALED RELATIVE CHANGE IN X CAUSED BY THE
!             CURRENT STEP, COMPUTED AS
!                  MAX(ABS(D(I)*(X(I)-X0(I)), 1 .LE. I .LE. P) /
!                     MAX(D(I)*(ABS(X(I))+ABS(X0(I))), 1 .LE. I .LE. P),
!             WHERE X = X0 + STEP.
!
!-------------------------------  NOTES  -------------------------------
!
!  ***  ALGORITHM NOTES  ***
!
!     SEE REF. 1 FOR A DESCRIPTION OF THE ALGORITHM USED.
!     ON PROBLEMS WHICH ARE NATURALLY WELL SCALED, BETTER PERFORMANCE
!     MAY BE OBTAINED BY SETTING V(D0INIT) = 1.0 AND IV(DTYPE) = 0,
!     WHICH WILL CAUSE THE SCALE VECTOR D TO BE SET TO ALL ONES.
!
!  ***  USAGE NOTES  ***
!
!        AFTER A RETURN WITH IV(1) .LE. 11, IT IS POSSIBLE TO RESTART,
!     I.E., TO CHANGE SOME OF THE IV AND V INPUT VALUES DESCRIBED ABOVE
!     AND CONTINUE THE ALGORITHM FROM THE POINT WHERE IT WAS INTERRUPTED.
!     IV(1) SHOULD NOT BE CHANGED, NOR SHOULD ANY ENTRIES OF IV
!     AND V OTHER THAN THE INPUT VALUES (THOSE SUPPLIED BY DFAULT).
!        THOSE WHO DO NOT WISH TO WRITE A CALCJ WHICH COMPUTES THE JACOBIAN
!     MATRIX ANALYTICALLY SHOULD CALL NL2SNO RATHER THAN NL2SOL.
!     NL2SNO USES FINITE DIFFERENCES TO COMPUTE AN APPROXIMATE JACOBIAN.
!        THOSE WHO WOULD PREFER TO PROVIDE R AND J (THE RESIDUAL AND
!     JACOBIAN) BY REVERSE COMMUNICATION RATHER THAN BY WRITING SUBROUTINES
!     CALCR AND CALCJ MAY CALL ON NL2ITR DIRECTLY.  SEE THE COMMENTS
!     AT THE BEGINNING OF NL2ITR.
!        THOSE WHO USE NL2SOL INTERACTIVELY MAY WISH TO SUPPLY THEIR
!     OWN STOPX FUNCTION, WHICH SHOULD RETURN .TRUE. IF THE BREAK KEY
!     HAS BEEN PRESSED SINCE STOPX WAS LAST INVOKED.  THIS MAKES IT POSSIBLE
!     TO EXTERNALLY INTERRUPT NL2SOL (WHICH WILL RETURN WITH
!     IV(1) = 11 IF STOPX RETURNS .TRUE.).
!        STORAGE FOR J IS ALLOCATED AT THE END OF V.  THUS THE CALLER
!     MAY MAKE V LONGER THAN SPECIFIED ABOVE AND MAY ALLOW CALCJ TO USE
!     ELEMENTS OF J BEYOND THE FIRST N*P AS SCRATCH STORAGE.
!
!  ***  PORTABILITY NOTES  ***
!
!        THE NL2SOL DISTRIBUTION TAPE CONTAINS BOTH SINGLE- AND DOUBLE-
!     PRECISION VERSIONS OF THE NL2SOL SOURCE CODE, SO IT SHOULD BE
!     UNNECESSARY TO CHANGE PRECISIONS.
!        ONLY THE FUNCTIONS IMDCON AND RMDCON CONTAIN MACHINE-DEPENDENT
!     CONSTANTS.  TO CHANGE FROM ONE MACHINE TO ANOTHER, IT SHOULD
!     SUFFICE TO CHANGE THE (FEW) RELEVANT LINES IN THESE FUNCTIONS.
!
!  ***  REFERENCES  ***
!
! 1.  DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1980), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, SUBMITTED TO ACM TRANS.
!             MATH. SOFTWARE.
!
!  ***  GENERAL  ***
!
!     CODED BY DAVID M. GAY (WINTER 1979 - WINTER 1980).
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!     MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989, AND
!     MCS-7906671.
!
!----------------------------  DECLARATIONS  ---------------------------
!
!     EXTERNAL ITSMRY, NL2ITR
! ITSMRY... PRINTS ITERATION SUMMARY AND INFO ABOUT INITIAL AND FINAL X.
! NL2ITR... REVERSE-COMMUNICATION ROUTINE THAT CARRIES OUT NL2SOL ALGORITHM.
!
!     LOGICAL STRTED
!     INTEGER D1, J1, NF, R1
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER D, J, NFCALL, NFGCAL, R, TOOBIG
!
!  ***  IV SUBSCRIPT VALUES  ***
!
      data nfcall/6/, nfgcal/7/, toobig/2/
!
!  ***  V SUBSCRIPT VALUES  ***
!
      data d/27/, j/33/, r/50/
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
      d1 = 94 + 2*n + p*(3*p + 31)/2
      iv(d) = d1
      r1 = d1 + p
      iv(r) = r1
      j1 = r1 + n
      iv(j) = j1
      strted = .true.
      if (iv(1) .ne. 0 .and. iv(1) .ne. 12) go to 40
         strted = .false.
         iv(nfcall) = 1
         iv(nfgcal) = 1
!
 10   nf = iv(nfcall)
      call calcr(n, p, x, nf, v(r1), uiparm, urparm, ufparm)
      if (strted) go to 20
         if (nf .gt. 0) go to 30
              iv(1) = 13
              go to 60
!
 20   if (nf .le. 0) iv(toobig) = 1
      go to 40
!
 30   call calcj(n, p, x, iv(nfgcal), v(j1), uiparm, urparm, ufparm)
      if (iv(nfgcal) .eq. 0) go to 50
      strted = .true.
!
 40   call nl2itr(v(d1), iv, v(j1), n, n, p, v(r1), v, x)
      if (iv(1) - 2) 10, 30, 999
!
 50   iv(1) = 15
 60   call itsmry(v(d1), iv, p, v, x)
!
 999  return
!  ***  LAST CARD OF NL2SOL FOLLOWS  ***
      end
