!LSVMIN
      real(kind=wp) function lsvmin(p, l, x, y)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  ESTIMATE SMALLEST SING. VALUE OF PACKED LOWER TRIANG. MATRIX L
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     &   p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     &   l(1),x(p),y(p)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     &   b,half,one,psj,r9973,sminus,splus,t,xminus,xplus,zero
      integer
     &   i,ii,ix,j,j0,ji,jj,jjj,jm1,pplus1
!
!  EXTERNAL FUNCTIONS
!      real(kind=wp) ::
!     &   v2norm
!      external v2norm
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,mod
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER P
!     REAL(KIND=WP) :: L(1), X(P), Y(P)
!     DIMENSION L(P*(P+1)/2)
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  ***  PURPOSE  ***
!
!     THIS FUNCTION RETURNS A GOOD OVER-ESTIMATE OF THE SMALLEST
!     SINGULAR VALUE OF THE PACKED LOWER TRIANGULAR MATRIX L.
!
!  ***  PARAMETER DESCRIPTION  ***
!
!  P (IN)  = THE ORDER OF L.  L IS A  P X P  LOWER TRIANGULAR MATRIX.
!  L (IN)  = ARRAY HOLDING THE ELEMENTS OF  L  IN ROW ORDER, I.E.
!             L(1,1), L(2,1), L(2,2), L(3,1), L(3,2), L(3,3), ETC.
!  X (OUT) IF LSVMIN RETURNS A POSITIVE VALUE, THEN X IS A NORMALIZED
!             APPROXIMATE LEFT SINGULAR VECTOR CORRESPONDING TO THE
!             SMALLEST SINGULAR VALUE.  THIS APPROXIMATION MAY BE VERY
!             CRUDE.  IF LSVMIN RETURNS ZERO, THEN SOME COMPONENTS OF X
!             ARE ZERO AND THE REST RETAIN THEIR INPUT VALUES.
!  Y (OUT) IF LSVMIN RETURNS A POSITIVE VALUE, THEN Y = (L**-1)*X IS AN
!             UNNORMALIZED APPROXIMATE RIGHT SINGULAR VECTOR CORRESPOND-
!             ING TO THE SMALLEST SINGULAR VALUE.  THIS APPROXIMATION
!             MAY BE CRUDE.  IF LSVMIN RETURNS ZERO, THEN Y RETAINS ITS
!             INPUT VALUE.  THE CALLER MAY PASS THE SAME VECTOR FOR X
!             AND Y (NONSTANDARD FORTRAN USAGE), IN WHICH CASE Y OVER-
!             WRITES X (FOR NONZERO LSVMIN RETURNS).
!
!  ***  APPLICATION AND USAGE RESTRICTIONS  ***
!
!     THERE ARE NO USAGE RESTRICTIONS.
!
!  ***  ALGORITHM NOTES  ***
!
!     THE ALGORITHM IS BASED ON (1), WITH THE ADDITIONAL PROVISION THAT
!     LSVMIN = 0 IS RETURNED IF THE SMALLEST DIAGONAL ELEMENT OF L
!     (IN MAGNITUDE) IS NOT MORE THAN THE UNIT ROUNDOFF TIMES THE
!     LARGEST.  THE ALGORITHM USES A RANDOM NUMBER GENERATOR PROPOSED
!     IN (4), WHICH PASSES THE SPECTRAL TEST WITH FLYING COLORS -- SEE
!     (2) AND (3).
!
!  ***  SUBROUTINES AND FUNCTIONS CALLED  ***
!
!        V2NORM - FUNCTION, RETURNS THE 2-NORM OF A VECTOR.
!
!  ***  REFERENCES  ***
!
!     (1) CLINE, A., MOLER, C., STEWART, G., AND WILKINSON, J.H.(1977),
!         AN ESTIMATE FOR THE CONDITION NUMBER OF A MATRIX, REPORT
!         TM-310, APPLIED MATH. DIV., ARGONNE NATIONAL LABORATORY.
!
!     (2) HOAGLIN, D.C. (1976), THEORETICAL PROPERTIES OF CONGRUENTIAL
!         RANDOM-NUMBER GENERATORS --  AN EMPIRICAL VIEW,
!         MEMORANDUM NS-340, DEPT. OF STATISTICS, HARVARD UNIV.
!
!     (3) KNUTH, D.E. (1969), THE ART OF COMPUTER PROGRAMMING, VOL. 2
!         (SEMINUMERICAL ALGORITHMS), ADDISON-WESLEY, READING, MASS.
!
!     (4) SMITH, C.S. (1971), MULTIPLICATIVE PSEUDO-RANDOM NUMBER
!         GENERATORS WITH PRIME MODULUS, J. ASSOC. COMPUT. MACH. 18,
!         PP. 586-593.
!
!  ***  HISTORY  ***
!
!     DESIGNED AND CODED BY DAVID M GAY (WINTER 1977/SUMMER 1978).
!
!  ***  GENERAL  ***
!
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!     MCS-7600324, DCR75-10143, 76-14311DSS, AND MCS76-11989.
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER I, II, IX, J, JI, JJ, JJJ, JM1, J0, PPLUS1
!     REAL(KIND=WP) :: B, PSJ, SMINUS, SPLUS, T, XMINUS, XPLUS
!
!  ***  CONSTANTS  ***
!
!     REAL(KIND=WP) :: HALF, ONE, R9973, ZERO
!
!/
!  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***
!
!     EXTERNAL V2NORM
!     REAL(KIND=WP) :: V2NORM
!
      data ix/2/
      data half/0.5_wp/, one/1.0_wp/, r9973/9973.0_wp/, zero/0.0_wp/
!
!  ***  BODY  ***
!
!  ***  FIRST CHECK WHETHER TO RETURN LSVMIN = 0 AND INITIALIZE X  ***
!
      ii = 0
      do 10 i = 1, p
         x(i) = zero
         ii = ii + i
         if (l(ii) .eq. zero) go to 300
 10      continue
      if (mod(ix, 9973) .eq. 0) ix = 2
      pplus1 = p + 1
!
!  ***  SOLVE (L**T)*X = B, WHERE THE COMPONENTS OF B HAVE RANDOMLY
!  ***  CHOSEN MAGNITUDES IN (.5,1) WITH SIGNS CHOSEN TO MAKE X LARGE.
!
!     DO J = P TO 1 BY -1...
      do 100 jjj = 1, p
         j = pplus1 - jjj
!       ***  DETERMINE X(J) IN THIS ITERATION. NOTE FOR I = 1,2,...,J
!       ***  THAT X(I) HOLDS THE CURRENT PARTIAL SUM FOR ROW I.
         ix = mod(3432*ix, 9973)
         b = half*(one + ix/r9973)
         xplus = (b - x(j))
         xminus = (-b - x(j))
         splus = abs(xplus)
         sminus = abs(xminus)
         jm1 = j - 1
         j0 = j*jm1/2
         jj = j0 + j
         xplus = xplus/l(jj)
         xminus = xminus/l(jj)
         if (jm1 .eq. 0) go to 30
         do 20 i = 1, jm1
              ji = j0 + i
              splus = splus + abs(x(i) + l(ji)*xplus)
              sminus = sminus + abs(x(i) + l(ji)*xminus)
 20           continue
 30      if (sminus .gt. splus) xplus = xminus
         x(j) = xplus
!       ***  UPDATE PARTIAL SUMS  ***
         if (jm1 .eq. 0) go to 100
         do 40 i = 1, jm1
              ji = j0 + i
              x(i) = x(i) + l(ji)*xplus
 40           continue
 100     continue
!
!  ***  NORMALIZE X  ***
!
      t = one/v2norm(p, x)
      do 110 i = 1, p
 110     x(i) = t*x(i)
!
!  ***  SOLVE L*Y = X AND RETURN SVMIN = 1/TWONORM(Y)  ***
!
      do 200 j = 1, p
         psj = zero
         jm1 = j - 1
         j0 = j*jm1/2
         if (jm1 .eq. 0) go to 130
         do 120 i = 1, jm1
              ji = j0 + i
              psj = psj + l(ji)*y(i)
 120          continue
 130     jj = j0 + j
         y(j) = (x(j) - psj)/l(jj)
 200     continue
!
      lsvmin = one/v2norm(p, y)
      go to 999
!
 300  lsvmin = zero
 999  return
      end function lsvmin
