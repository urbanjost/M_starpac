!QRFACT
      subroutine qrfact(nm,m,n,qr,alpha,ipivot,ierr,nopivk,sum)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  COMPUTE THE QR DECOMPOSITION OF THE MATRIX STORED IN QR  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   ierr,m,n,nm,nopivk
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   alpha(n),qr(nm,n),sum(n)
      integer
     +   ipivot(n)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   alphak,beta,one,p01,p99,qrkk,qrkmax,rktol,rktol1,sigma,sumj,
     +   temp,ufeta,zero
      integer
     +   i,j,jbar,k,k1,minum,mk1
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
      real(kind=wp) ::
     +   dotprd,v2norm
      external dotprd,v2norm
!
!  EXTERNAL SUBROUTINES
      external vaxpy,vscopy
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,min,sqrt
!
!     *****PARAMETERS.
!     INTEGER NM,M,N,IPIVOT(N),IERR,NOPIVK
!     REAL(KIND=WP) :: QR(NM,N),ALPHA(N),SUM(N)
!     *****LOCAL VARIABLES.
!     INTEGER I,J,JBAR,K,K1,MINUM,MK1
!     REAL(KIND=WP) :: ALPHAK,BETA,QRKK,QRKMAX,SIGMA,TEMP,UFETA,RKTOL,
!    1        RKTOL1,SUMJ
!     *****FUNCTIONS.
!/+
!     INTEGER MIN
!     REAL(KIND=WP) ::             ABS,SQRT
!/
!     EXTERNAL DOTPRD, VAXPY, VSCOPY, V2NORM
!     REAL(KIND=WP) :: DOTPRD, V2NORM
! DOTPRD... RETURNS INNER PRODUCT OF TWO VECTORS.
! RMDCON... RETURNS MACHINE-DEPENDENT CONSTANTS.
! VAXPY... COMPUTES SCALAR TIMES ONE VECTOR PLUS ANOTHER.
! VSCOPY... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.
! V2NORM... RETURNS THE 2-NORM OF A VECTOR.
!
!     *****CONSTANTS.
!     REAL(KIND=WP) :: ONE, P01, P99, ZERO
      data one/1.0_wp/, p01/0.01_wp/, p99/0.99_wp/, zero/0.0_wp/
!
!
!     ==================================================================
!
!
!     *****PURPOSE.
!
!     THIS SUBROUTINE DOES A QR-DECOMPOSITION ON THE M X N MATRIX QR,
!        WITH AN OPTIONALLY MODIFIED COLUMN PIVOTING, AND RETURNS THE
!        UPPER TRIANGULAR R-MATRIX, AS WELL AS THE ORTHOGONAL VECTORS
!        USED IN THE TRANSFORMATIONS.
!
!     *****PARAMETER DESCRIPTION.
!     ON INPUT.
!
!        NM MUST BE SET TO THE ROW DIMENSION OF THE TWO DIMENSIONAL
!             ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
!             DIMENSION STATEMENT.
!
!        M MUST BE SET TO THE NUMBER OF ROWS IN THE MATRIX.
!
!        N MUST BE SET TO THE NUMBER OF COLUMNS IN THE MATRIX.
!
!        QR CONTAINS THE REAL RECTANGULAR MATRIX TO BE DECOMPOSED.
!
!     NOPIVK IS USED TO CONTROL PIVOTTING.  COLUMNS 1 THROUGH
!        NOPIVK WILL REMAIN FIXED IN POSITION.
!
!        SUM IS USED FOR TEMPORARY STORAGE FOR THE SUBROUTINE.
!
!     ON OUTPUT.
!
!        QR CONTAINS THE NON-DIAGONAL ELEMENTS OF THE R-MATRIX
!             IN THE STRICT UPPER TRIANGLE. THE VECTORS U, WHICH
!             DEFINE THE HOUSEHOLDER TRANSFORMATIONS   I - U*U-TRANSP,
!             ARE IN THE COLUMNS OF THE LOWER TRIANGLE. THESE VECTORS U
!             ARE SCALED SO THAT THE SQUARE OF THEIR 2-NORM IS 2.0.
!
!        ALPHA CONTAINS THE DIAGONAL ELEMENTS OF THE R-MATRIX.
!
!        IPIVOT REFLECTS THE COLUMN PIVOTING PERFORMED ON THE INPUT
!             MATRIX TO ACCOMPLISH THE DECOMPOSITION. THE J-TH
!             ELEMENT OF IPIVOT GIVES THE COLUMN OF THE ORIGINAL
!             MATRIX WHICH WAS PIVOTED INTO COLUMN J DURING THE
!             DECOMPOSITION.
!
!        IERR IS SET TO.
!             0 FOR NORMAL RETURN,
!             K IF NO NON-ZERO PIVOT COULD BE FOUND FOR THE K-TH
!                  TRANSFORMATION, OR
!             -K FOR AN ERROR EXIT ON THE K-TH THANSFORMATION.
!             IF AN ERROR EXIT WAS TAKEN, THE FIRST (K - 1)
!             TRANSFORMATIONS ARE CORRECT.
!
!
!     *****APPLICATIONS AND USAGE RESTRICTIONS.
!     THIS MAY BE USED WHEN SOLVING LINEAR LEAST-SQUARES PROBLEMS --
!     SEE SUBROUTINE QR1 OF ROSEPACK.  IT IS CALLED FOR THIS PURPOSE
!     BY LLSQST IN THE NL2SOL (NONLINEAR LEAST-SQUARES) PACKAGE.
!
!     *****ALGORITHM NOTES.
!     THIS VERSION OF QRFACT TRIES TO ELIMINATE THE OCCURRENCE OF
!     UNDERFLOWS DURING THE ACCUMULATION OF INNER PRODUCTS.  RKTOL1
!     IS CHOSEN BELOW SO AS TO INSURE THAT DISCARDED TERMS HAVE NO
!     EFFECT ON THE COMPUTED TWO-NORMS.
!
!     ADAPTED FROM THE ALGOL ROUTINE SOLVE (1).
!
!     *****REFERENCES.
!     (1)     BUSINGER,P. AND GOLUB,G.H., LINEAR LEAST SQUARES
!     SOLUTIONS BY HOUSHOLDER TRANSFORMATIONS, IN WILKINSON,J.H.
!     AND REINSCH,C.(EDS.), HANDBOOK FOR AUTOMATIC COMPUTATION,
!     VOLUME II. LINEAR ALGEBRA, SPRINGER-VERLAG, 111-118 (1971).
!     PREPUBLISHED IN NUMER.MATH. 7, 269-276 (1965).
!
!     *****HISTORY.
!     THIS AMOUNTS TO THE SUBROUTINE QR1 OF ROSEPACK WITH RKTOL1 USED
!     IN PLACE OF RKTOL BELOW, WITH V2NORM USED TO INITIALIZE (AND
!     SOMETIMES UPDATE) THE SUM ARRAY, AND WITH CALLS ON DOTPRD AND
!     VAXPY IN PLACE OF SOME LOOPS.
!
!     *****GENERAL.
!
!     DEVELOPMENT OF THIS PROGRAM SUPPORTED IN PART BY
!     NATIONAL SCIENCE FOUNDATION GRANT GJ-1154X3 AND
!     NATIONAL SCIENCE FOUNDATION GRANT DCR75-08802
!     TO NATIONAL BUREAU OF ECONOMIC RESEARCH, INC.
!
!
!
!     =================================================================
!     =================================================================
!
!
!     ==========  UFETA IS THE SMALLEST POSITIVE FLOATING POINT NUMBER
!        S.T. UFETA AND -UFETA CAN BOTH BE REPRESENTED.
!
!     ==========  RKTOL IS THE SQUARE ROOT OF THE RELATIVE PRECISION
!        OF FLOATING POINT ARITHMETIC (MACHEP).
      data rktol/0.0_wp/, ufeta/0.0_wp/
!     *****BODY OF PROGRAM.
      if (ufeta .gt. zero) go to 10
         ufeta = rmdcon(1,typ=0.0_wp)
         rktol = rmdcon(4,typ=0.0_wp)
   10 ierr = 0
      rktol1 = p01 * rktol
!
      do 20 j=1,n
         sum(j) = v2norm(m, qr(1,j))
         ipivot(j) = j
   20 continue
!
      minum = min(m,n)
!
      do 120 k=1,minum
         mk1 = m - k + 1
!        ==========K-TH HOUSEHOLDER TRANSFORMATION==========
         sigma = zero
         jbar = 0
!        ==========FIND LARGEST COLUMN SUM==========
      if (k .le. nopivk) go to 50
         do 30 j=k,n
              if (sigma .ge. sum(j))  go to 30
              sigma = sum(j)
              jbar = j
   30    continue
!
         if (jbar .eq. 0)  go to 220
         if (jbar .eq. k)  go to 50
!        ==========COLUMN INTERCHANGE==========
         i = ipivot(k)
         ipivot(k) = ipivot(jbar)
         ipivot(jbar) = i
         sum(jbar) = sum(k)
         sum(k) = sigma
!
         do 40 i=1,m
              sigma = qr(i,k)
              qr(i,k) = qr(i,jbar)
              qr(i,jbar) = sigma
   40    continue
!        ==========END OF COLUMN INTERCHANGE==========
   50    continue
!        ==========  SECOND INNER PRODUCT  ==========
         qrkmax = zero
!
         do 60 i=k,m
              if (abs( qr(i,k) ) .gt. qrkmax)  qrkmax = abs( qr(i,k) )
   60    continue
!
         if (qrkmax .lt. ufeta)  go to 210
         alphak = v2norm(mk1, qr(k,k)) / qrkmax
         sigma = alphak**2
!
!        ==========  END SECOND INNER PRODUCT  ==========
         qrkk = qr(k,k)
         if (qrkk .ge. zero)  alphak = -alphak
         alpha(k) = alphak * qrkmax
         beta = qrkmax * sqrt(sigma - (qrkk*alphak/qrkmax) )
         qr(k,k) = qrkk - alpha(k)
         do 65 i=k,m
   65         qr(i,k) =  qr(i,k) / beta
         k1 = k + 1
         if (k1 .gt. n) go to 120
!
         do 110 j = k1, n
              temp = -dotprd(mk1, qr(k,k), qr(k,j))
!
!             ***  SET QR(I,J) = QR(I,J) + TEMP*QR(I,K), I = K,...,M.
!
              call vaxpy(mk1, qr(k,j), temp, qr(k,k), qr(k,j))
!
              if (k1 .gt. m) go to 110
              sumj = sum(j)
              if (sumj .lt. ufeta) go to 110
              temp = abs(qr(k,j)/sumj)
              if (temp .lt. rktol1) go to 110
              if (temp .ge. p99) go to 90
                   sum(j) = sumj * sqrt(one - temp**2)
                   go to 110
   90         sum(j) = v2norm(m-k, qr(k1,j))
  110    continue
!        ==========END OF K-TH HOUSEHOLDER TRANSFORMATION==========
  120 continue
!
      go to 999
!     ==========ERROR EXIT ON K-TH TRANSFORMATION==========
  210 ierr = -k
      go to 230
!     ==========NO NON-ZERO ACCEPTABLE PIVOT FOUND==========
  220 ierr = k
  230 do 240 i = k, n
         alpha(i) = zero
         if (i .gt. k) call vscopy(i-k, qr(k,i), zero)
 240     continue
!     ==========RETURN TO CALLER==========
  999 return

      end subroutine qrfact
