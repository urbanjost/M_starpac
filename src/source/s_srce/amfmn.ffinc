!AMFMN
     subroutine amfmn (par, pv, y, npar, n, nfac, mspect,&
    &  pardf, npardf, t, temp, parar, parma, mbo, mbol, n1, n2, nprt,&
    &  save, nfcst, nfcsto, ifcsto, fcst, ifcst, fcstsd, f,&
     &  fsd, nparar, nparma)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN ROUTINE FOR COMPUTING AND PRINTING THE ARIMA
!     FORECASTS
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
    &   ifcst,mbo,mbol,n,n1,n2,nfac,nfcst,nfcsto,npar,nparar,&
     &   npardf,nparma,nprt
     logical&
     &   save
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   f(*),fcst(ifcst,*),fcstsd(*),fsd(*),par(:),parar(*),pardf(*),&
     &   parma(*),pv(n1:n2),t(*),temp(*),y(*)
     integer&
     &   ifcsto(*),mspect(nfac,4)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   const,pmu,rsd,rss,t975,wsum,wsumt
     integer&
     &   i,i1,idf,if,ifc,iflag,ifo,ifomin,iprt,j,k,nt
     logical&
     &   page
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   PPFT,SDOT
!      EXTERNAL PPFT,SDOT
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AMFHDR,AMFOUT,AMLST,DCOEF,IPRINT,MDLTS2,MODSUM,MULTBP
!
!  INTRINSIC FUNCTIONS
      intrinsic min,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CONST
!        THE CONSTANT TERM IN THE MODEL, MODELING EITHER THE SERIES
!        MEAN OR A DETERMINISTIC TREND.
!     REAL F(NFCST)
!        THE FORECASTS.
!     REAL FCST(IFCST,NFCSTO)
!        THE STORAGE ARRAY FOR THE FORECASTS.
!     REAL FCSTSD(NFCST)
!        THE STORAGE ARRAY FOR THE STANDARD DEVIATIONS OF THE FORECASTS.
!     REAL FSD(NFCST)
!        THE STANDARD DEVIATIONS OF THE FORECASTS.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IF
!        AN INDEX VARIABLE.
!     INTEGER IFCST
!        THE FIRST DIMENSION OF THE ARRAY FCST.
!     INTEGER IFCSTO(NFCSTO)
!        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
!     INTEGER IFLAG
!        AN INDICATOR VARIABLE DESIGNATING WHETHER THE BACK FORECASTS
!        WERE ESSENTIALLY ZERO (IFLAG=0) OR NOT (IFLAG=1).
!     INTEGER IFO
!        THE INDEX OF THE ORIGIN BEING USED.
!     INTEGER IFOMIN
!        THE SMALLEST ORIGIN USED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER I1
!        AN INDEX VALUE.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBOL
!        THE MAXIMUM BACK ORDER ON THE LEFT
!     INTEGER MSPECT(NFAC,4)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFCST
!        THE NUMBER OF FORECASTS.
!     INTEGER NFCSTO
!        THE NUMBER OF THE ORIGINS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NT
!        THE NUMBER OF PARAMETERS IN T, WHERE NT = MBOL
!     INTEGER N1
!        THE LOWER BOUND FOR PV.
!     INTEGER N2
!        THE UPPER BOUND FOR PV.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PARAR(MBO)
!        THE AUTOREGRESSIVE PARAMETERS
!     REAL PARDF(NPARDF)
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS.
!     REAL PARMA(MBO)
!        THE MOVING AVERAGE PARAMETERS
!     REAL PMU
!        THE VALUE OF MU, I.E., THE TREND OR MEAN.
!     REAL PV(N1:N2)
!        THE PREDICTED VALUE OF THE FIT.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     REAL RSS
!        THE RESIDUAL SUM OF SQUARES.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL T(2*MBO)
!        A TEMPORARY WORK VECTOR.
!     REAL TEMP(MBO)
!        A TEMPORARY WORK VECTOR
!     REAL T975
!        THE VALUE OF THE 97.5 PERCENT POINT FUNCTION FOR THE
!        T DISTRIBUTION.
!     REAL WSUM
!        THE SUM OF THE WEIGHTS SQUARED, USED TO COMPUTE THE
!        STANDARD DEVIATION OF THE FORECAST.
!     REAL WSUMT
!        A TEMPORARY STORAGE LOCATION FOR WSUM.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
      call iprint (iprt)
!
!     COMPUTE DIFFERENCING PARAMETERS
!
      call dcoef (nfac, mspect(1,2), mspect(1,4), npardf, pardf, mbo, t)
!
!     COMPUTE RESIDUALS, GIVEN VALUES OF PARAMETERS
!
     call mdlts2 (par, pv, y, npar, n, nfac, mspect, pmu,&
     &  pardf, npardf, t, temp, parar, parma, mbo, n1, n2, iflag)
      idf = n - npardf - npar
      rss = sdot(n, pv(1), 1, pv(1), 1)
      rsd = sqrt(rss / idf)
!
!     PRINT INITIAL SUMMARY
!
      page = .false.
      if (nprt.eq.0) go to 10
      call amfhdr(page, .true., 2)
      call modsum(nfac, mspect)
!AMLST(iamhd,PAR(*),npar,nfac,MSPECT(nfac,4),n,VCVL(*),lvcvl,SCALE(*),lscale,STPT(*),lstpt,IFIXD(*),rss,rsd,npardf,npare,idf)
! This call uses PAR over and over, messed up. Added int() function to can even build for now
      write(*,*)'BAD CALL OF AMLST'
     call amlst(2, par, npar, nfac, mspect, n, par, npar, par,&
     &  npar, par, npar, int(par), rss, rsd, npardf, npar, idf)
      page = .true.
!
   10 continue
!
!     COMBINE PARDF AND PARAR INTO T
!
      nt = nparar + npardf
      call multbp(parar, nparar, pardf, npardf, t, nt, mbo)
!
!     COMPUTE CONSTANT
!
      const = 0.0e0
      if (pmu.ne.0.0e0) then
        if (nparar.ge.1) then
          do 20 j = 1, nparar
            const = const - parar(j)
   20     continue
        end if
        const = (1.0e0 + const) * pmu
      end if
!
!     FIND LOWEST ORIGIN
!
      ifomin = ifcsto(1)
      do 30 ifo = 1, nfcsto
        ifomin = min(ifomin, ifcsto(ifo))
   30 continue
!
!     SET TEMP TO BACKFORECAST OF Y IF NECESSARY
!
      if ((mbol.ge.1) .and. (ifomin.lt.mbol)) then
        i1 = ifomin-mbol+1
        do 60 i = 0, i1, -1
          k = 1-i
          temp(k) = const
          do 40 j = 1, mbol
            if (i+j.le.n) then
              if (i+j.ge.1) then
                temp(k) = temp(k) + t(j)*y(i+j)
              else
                temp(k) = temp(k) + t(j)*temp(mbol-i-j)
              end if
            end if
   40     continue
          if (nparma.ge.1) then
            do 50 j =1, nparma
              if (i+j.le.n) temp(k) = temp(k) - parma(j)*pv(i+j)
   50       continue
          end if
   60   continue
      end if
!
!      COMPUTE WEIGHTS FOR COMPUTING STANDARD DEVIATIONS OF THE FORECAST
!
      do 65 j = 1, nfcst
        fsd(j) = 0.0e0
        if (mbol.ge.1) then
          do 64 i = 1, mbol
            if (j-i.ge.1) then
              fsd(j) = fsd(j) + t(i)*fsd(j-i)
            else
              if (j-i.eq.0) fsd(j) = fsd(j) + t(i)
            end if
   64     continue
        end if
        if (j.le.nparma) fsd(j) = fsd(j) - parma(j)
   65 continue
!
!     COMPUTE STANDARD DEVIATIONS OF FORECASTS
!
      wsum = 1.0e0
      do 66 i = 1, nfcst
        wsumt =wsum
        wsum = wsum + fsd(i)*fsd(i)
        fsd(i) = sqrt(wsumt)*rsd
   66 continue
!
!     SET PERCENT POINT VALUE FOR 95 PERCENT CONFIDENCE LIMITS
!
      t975 = ppft(0.975e0, n-npar)
!
!     COMPUTE FORECASTS FOR EACH ORIGIN
!
      do 100 ifo = 1, nfcsto
        ifc = ifcsto(ifo)
        if ((ifc.lt.1) .or. (ifc.gt.n)) ifc = n
        do 90 if = 1, nfcst
          f(if) = const
          if (mbol.ge.1) then
            do 70 j = 1, mbol
              k = if + ifc-j
              if (k.le.0) then
                f(if) = f(if) + t(j)*temp(1-k)
              else
                if (k.le.ifc) then
                  f(if) = f(if) + t(j)*y(k)
                else
                  f(if) = f(if) + t(j)*f(if-j)
                end if
              end if
   70       continue
          end if
          if (nparma.ge.1) then
            do 80 j = 1, nparma
              k = if + ifc - j
              if (k.le.ifc) f(if) = f(if) - parma(j)*pv(k)
   80       continue
          end if
          if (save) fcst(if,ifo) = f(if)
   90   continue
!
!     PRINT RESULTS FROM THIS ORIGIN
!
       if (nprt.ne.0)&
    &    call amfout(f, fsd, n, nfcst, ifcsto, ifo, nfcsto, y, t975,&
     &    page)
!
  100 continue
!
      return
!
      end
