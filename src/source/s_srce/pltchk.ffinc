!PLTCHK
     subroutine pltchk (ym, ymmiss, x, xmiss, n, m, iym, multi,&
     &   ilog, ylb, yub, xlb, xub, nmsub, miss, xcheck)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS PLOT FAMILY ROUTINE CHECKS FOR ERRORS IN THE PARAMETER LISTS
!     OF THE MULTIPLE PLOT ROUTINES
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   xlb,xmiss,xub,ylb,yub
     integer&
     &   ilog,iym,m,n
     logical&
     &   miss,multi,xcheck
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),ym(*),ymmiss(*)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   nv
     logical&
     &   err01,err02,err03,err04,err05,err06,err07,err08,err09,head
!
!  LOCAL ARRAYS
     integer&
     &   ilogxy(2)
     character&
    &   liym(8)*1,lm(8)*1,ln(8)*1,lone(8)*1,lx(8)*1,lxlb(8)*1,&
     &   lxub(8)*1,ly(8)*1,lylb(8)*1,lym(8)*1,lyub(8)*1
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL EISGE,ERAGT,ERAGTM,ERSGT,ERVGT,ERVGTM,PRTCNT
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05, ERR06, ERR07, ERR08,
!    1   ERR09
!        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        THE COMMON VARIABLE USED AS AN ERROR FLAG
!        IF = 0 THEN NO ERORRS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER ILOGXY(2)
!        ...
!     INTEGER IYM
!        ACTUAL ROW DIMENSION OF YM DECLARED IN USERS MAIN PROGRAM
!     CHARACTER*1 LIYM(8), LM(8), LN(8), LONE(8), LX(8), LXLB(8),
!    *  LXUB(8), LY(8), LYLB(8), LYM(8), LYUB(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE INPUT PARAMETERS(S)
!        CHECKED FOR ERRORS.
!     INTEGER M
!        THE NUMBER OF VECTORS IN YM
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        AN INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS AN M PREFIX (TRUE) OR NOT (FALSE).
!     INTEGER N
!        THE LENGTH OF THE VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND IN THE X AND Y AXIS ARRAYS.
!     REAL(KIND=WP) :: X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     LOGICAL XCHECK
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER X-AXIS VALUES
!        ARE TO BE CHECKED (XCHECK = .TRUE.) OR NOT (XCHECK = .FALSE.)
!     REAL(KIND=WP) :: XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL(KIND=WP) :: XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL(KIND=WP) :: XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL(KIND=WP) :: YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL(KIND=WP) :: YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES.
!     REAL(KIND=WP) :: YMMISS(M)
!        THE MISSING VALUE CODE FOR EACH COLUMN OF YM.
!     REAL(KIND=WP) :: YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &   liym(1),   liym(2),   liym(3),   liym(4),   liym(5),   liym(6)&
     & /     'I',       'Y',       'M',       ' ',       ' ',       ' '/
     data liym(7), liym(8)&
     &   /     ' ',     ' '/
     data&
    &     lm(1),     lm(2),     lm(3),     lm(4),     lm(5),     lm(6)&
     & /     'M',       ' ',       ' ',       ' ',       ' ',       ' '/
     data   lm(7),   lm(8)&
     &   /     ' ',     ' '/
     data&
    &     ln(1),     ln(2),     ln(3),     ln(4),     ln(5),     ln(6)&
     & /     'N',       ' ',       ' ',       ' ',       ' ',       ' '/
     data   ln(7),   ln(8)&
     &   /     ' ',     ' '/
     data   lone(1),  lone(2),  lone(3),  lone(4),  lone(5),  lone(6),&
     &       lone(7),  lone(8)/'O', 'N', 'E', ' ', ' ', ' ', ' ', ' '/
     data&
    &     lx(1),     lx(2),     lx(3),     lx(4),     lx(5),     lx(6)&
     & /     'X',       ' ',       ' ',       ' ',       ' ',       ' '/
     data   lx(7),   lx(8)&
     &   /     ' ',     ' '/
     data&
    &   lxlb(1),   lxlb(2),   lxlb(3),   lxlb(4),   lxlb(5),   lxlb(6)&
     & /     'X',       'L',       'B',       ' ',       ' ',       ' '/
     data lxlb(7), lxlb(8)&
     &   /     ' ',     ' '/
     data&
    &   lxub(1),   lxub(2),   lxub(3),   lxub(4),   lxub(5),   lxub(6)&
     & /     'X',       'U',       'B',       ' ',       ' ',       ' '/
     data lxub(7), lxub(8)&
     &   /     ' ',     ' '/
     data&
    &     ly(1),     ly(2),     ly(3),     ly(4),     ly(5),     ly(6)&
     & /     'Y',       ' ',       ' ',       ' ',       ' ',       ' '/
     data   ly(7),   ly(8)&
     &   /     ' ',     ' '/
     data&
    &   lylb(1),   lylb(2),   lylb(3),   lylb(4),   lylb(5),   lylb(6)&
     & /     'Y',       'L',       'B',       ' ',       ' ',       ' '/
     data lylb(7), lylb(8)&
     &   /     ' ',     ' '/
     data&
    &    lym(1),    lym(2),    lym(3),    lym(4),    lym(5),    lym(6)&
     & /     'Y',       'M',       ' ',       ' ',       ' ',       ' '/
     data  lym(7),  lym(8)&
     &   /     ' ',     ' '/
     data&
    &   lyub(1),   lyub(2),   lyub(3),   lyub(4),   lyub(5),   lyub(6)&
     & /     'Y',       'U',       'B',       ' ',       ' ',       ' '/
     data lyub(7), lyub(8)&
     &   /     ' ',     ' '/
!
!     COMMENCE BODY OF ROUTINE
!
      ierr = 0
      head = .true.
!
!     NUMBER OF POINTS MUST BE AT LEAST 1
!
      call eisge(nmsub, ln, n, 1, 2, head, err01, lone)
!
!     THERE MUST BE AT LEAST 1 COLUMN OF VECTORS
!
      call eisge(nmsub, lm, m, 1, 2, head, err02, lone)
!
!     THE ACTUAL LENGTH OF YM MUST EQUAL OR EXCEED THE NUMBER OF
!     OBSERVATIONS
!
      err03 = .true.
     if (.not.err01)&
     &   call eisge(nmsub, liym, iym, n, 3, head, err03, ln)
!
!     IF THIS IS A LOG PLOT CHECK FOR NON-POSITIVE VALUES IN DATA
!
      if (err01 .or. err02 .or. err03) ierr = 1
      if (ilog .le. 0) return
!
      err04 = .false.
      err05 = .false.
      err06 = .false.
      err07 = .false.
      err08 = .false.
      err09 = .false.
!
      call prtcnt (max(0,ilog),2,ilogxy)
      if ((ilogxy(1).ne.0) .and. xcheck) then
        if (.not.err01) then
!
!         IF X AXIS IS LOG SCALE, CHECK FOR NEGATIVE X AXIS VALUES
!
          if (miss) then
           call ervgtm(nmsub, lx, x, xmiss, n, 0.0_wp, 0, head, 1,&
     &        nv, err04, lx)
          else
           call ervgt(nmsub, lx, x, n, 0.0_wp, 0, head, 1, nv, err04,&
     &        lx)
          end if
        end if
!
        if (xlb.lt.xub) then
!
!         CHECK FOR NEGATIVE PLOT BOUNDS
!
          call ersgt(nmsub, lxlb, xlb, 0.0_wp, 1, head, err05, lxlb)
          call ersgt(nmsub, lxub, xub, 0.0_wp, 1, head, err06, lxub)
        end if
      end if
      if (ilogxy(2).ne.0) then
        if ((.not.err01) .and. (.not.err02) .and. (.not.err03)) then
!
!         IF Y AYIS IS LOG SCALE, CHECK FOR NEGATIVE Y AYIS VALUES
!
          if (miss) then
            if (multi) then
             call eragtm(nmsub, lym, ym, ymmiss, n, m, iym, 0.0_wp, 0,&
     &           head, 1, nv, err04, lym)
            else
             call ervgtm(nmsub, ly, ym, ymmiss(1), n, 0.0_wp, 0, head,&
     &           1, nv, err04, ly)
            end if
          else
            if (multi) then
             call eragt(nmsub, lym, ym, n, m, iym, 0.0_wp, 0, head,&
     &           1, nv, err04, lym)
            else
             call ervgt(nmsub, ly, ym, n, 0.0_wp, 0, head, 1,&
     &           nv, err04, ly)
            end if
          end if
        end if
!
        if (ylb.lt.yub) then
!
!         CHECK FOR NEGATIVE PLOT BOUNDS
!
          call ersgt(nmsub, lylb, ylb, 0.0_wp, 1, head, err05, lylb)
          call ersgt(nmsub, lyub, yub, 0.0_wp, 1, head, err06, lyub)
        end if
      end if
!
     if (err04 .or. err05 .or. err06 .or. err07 .or. err08 .or. err09)&
     &   ierr = 1
!
      return
!
      end
