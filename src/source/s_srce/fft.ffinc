!FFT
      subroutine fft(a, b, ntot, n, nspan, isn)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  MULTIVARIATE COMPLEX FOURIER TRANSFORM, COMPUTED IN PLACE
!    USING MIXED-RADIX FAST FOURIER TRANSFORM ALGORITHM.
!  BY R. C. SINGLETON, STANFORD RESEARCH INSTITUTE, OCT. 1968
!  ARRAYS A AND B ORIGINALLY HOLD THE REAL AND IMAGINARY
!    COMPONENTS OF THE DATA, AND RETURN THE REAL AND
!    IMAGINARY COMPONENTS OF THE RESULTING FOURIER COEFFICIENTS.
!  MULTIVARIATE DATA IS INDEXED ACCORDING TO THE FORTRAN
!    ARRAY ELEMENT SUCCESSOR FUNCTION, WITHOUT LIMIT
!    ON THE NUMBER OF IMPLIED MULTIPLE SUBSCRIPTS.
!    THE SUBROUTINE IS CALLED ONCE FOR EACH VARIATE.
!    THE CALLS FOR A MULTIVARIATE TRANSFORM MAY BE IN ANY ORDER.
!  NTOT IS THE TOTAL NUMBER OF COMPLEX DATA VALUES.
!  N IS THE DIMENSION OF THE CURRENT VARIABLE.
!  NSPAN/N IS THE SPACING OF CONSECUTIVE DATA VALUES
!    WHILE INDEXING THE CURRENT VARIABLE.
!  THE SIGN OF ISN DETERMINES THE SIGN OF THE COMPLEX
!    EXPONENTIAL, AND THE MAGNITUDE OF ISN IS NORMALLY ONE.
!  A TRI-VARIATE TRANSFORM WITH A(N1,N2,N3), B(N1,N2,N3)
!    IS COMPUTED BY
!      CALL FFT(A,B,N1*N2*N3,N1,N1,1)
!      CALL FFT(A,B,N1*N2*N3,N2,N1*N2,1)
!      CALL FFT(A,B,N1*N2*N3,N3,N1*N2*N3,1)
!  FOR A SINGLE-VARIATE TRANSFORM,
!    NTOT = N = NSPAN = (NUMBER OF COMPLEX DATA VALUES), F.G.
!      CALL FFT(A,B,N,N,N,1)
!  THE DATA MAY ALTERNATIVELY BE STORED IN A SINGLE COMPLEX
!    ARRAY A, THEN THE MAGNITUDE OF ISN CHANGED TO TWO TO
!    GIVE THE CORRECT INDEXING INCREMENT AND A(2) USED TO
!    PASS THE INITIAL ADDRESS FOR THE SEQUENCE OF IMAGINARY
!    VALUES, E.G.
!      CALL FFT(A,A(2),NTOT,N,NSPAN,2)
!  ARRAYS AT(MAXF), CK(MAXF), BT(MAXF), SK(MAXF), AND NP(MAXP)
!    ARE USED FOR TEMPORARY STORAGE.  IF THE AVAILABEL STORAGE
!    IS INSUFFICIENT, THE PROGRAM IS TERMINATED BY A STOP.
!    MAXF MUST BE .GE. THE MAXIMUM PRIME FACTOR OF N.
!    MAXP MUST BE .GT. THE NUMBER OF PRIME FACTORS OF N.
!
!     NB. THE ABOVE DESCRIPTION OF MAXP APPEARS TO BE INCORRECT.
!         MAXP SEEMS TO BE THE MAXIMUM SIZE OF THE SQUARE FREE
!         PORTION K OF N.
!
!    IN ADDITION, IF THE SQUARE-FREE PORTION K OF N HAS TWO OR
!    MORE PRIME FACTORS, THEN MAXP MUST BE .GE. K-1.
!     DIMENSION A(1), B(1)
!  ARRAY STORAGE IN NFAC FOR A MAXIMUM OF 11 FACTORS OF N.
!  IF N HAS MORE THAN ONE SQUARE-FREE FACTOR, THE PRODUCT OF THE
!    SQUARE-FREE FACTORS MUST BE .LE. 210
!     DIMENSION NFAC(11), NP(209)
!  ARRAY STORAGE FOR MAXIMUM PRIME FACTOR OF 23
!     DIMENSION AT(23), CK(23), BT(23), SK(23)
!
!
!  VARIABLE DECLARATIONS
!
!  PARAMETERS
     integer&
     &   maxf1
      parameter (maxf1=23)
     integer&
     &   maxp1
      parameter (maxp1=209)
!
!  SCALAR ARGUMENTS
     integer&
     &   isn,n,nspan,ntot
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   a(*),b(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   aa,aj,ajm,ajp,ak,akm,akp,bb,bj,bjm,bjp,bk,bkm,bkp,c1,c2,c3,&
     &   c72,cd,rad,radf,s1,s120,s2,s3,s72,sd
     integer&
    &   i,ii,inc,iprt,j,jc,jf,jj,k,k1,k2,k3,k4,kk,ks,kspan,kspnn,&
     &   kt,m,maxf,maxp,nn,nt
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   at(maxf1),bt(maxf1),ck(maxf1),sk(maxf1)
     integer&
     &   nfac(11),np(maxp1)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic atan,cos,mod,sin,sqrt
!
!  EQUIVALENCES
      equivalence (i,ii)
!
!  THE FOLLOWING TWO CONSTANTS SHOULD AGREE WITH THE ARRAY DIMENSIONS.
      maxf = maxf1
      maxp = maxp1
      if (n.lt.2) return
!
!  INITIALIZE VARIABLES
!
      c1 = 0
      c2 = 0
      c3 = 0
      s1 = 0
      s2 = 0
      s3 = 0
      k1 = 0
      k2 = 0
      k3 = 0
      k4 = 0
!
      inc = isn
      rad = 8.0e0*atan(1.0e0)
      s72 = rad/5.0e0
      c72 = cos(s72)
      s72 = sin(s72)
      s120 = sqrt(0.75e0)
      if (isn.ge.0) go to 10
      s72 = -s72
      s120 = -s120
      rad = -rad
      inc = -inc
   10 nt = inc*ntot
      ks = inc*nspan
      kspan = ks
      nn = nt - inc
      jc = ks/n
      radf = rad*jc*0.5e0
      i = 0
      jf = 0
!  DETERMINE THE FACTORS OF N
      m = 0
      k = n
      go to 30
   20 m = m + 1
      nfac(m) = 4
      k = k/16
   30 if (k-(k/16)*16.eq.0) go to 20
      j = 3
      jj = 9
      go to 50
   40 m = m + 1
      nfac(m) = j
      k = k/jj
   50 if (mod(k,jj).eq.0) go to 40
      j = j + 2
      jj = j**2
      if (jj.le.k) go to 50
      if (k.gt.4) go to 60
      kt = m
      nfac(m+1) = k
      if (k.ne.1) m = m + 1
      go to 100
   60 if (k-(k/4)*4.ne.0) go to 70
      m = m + 1
      nfac(m) = 2
      k = k/4
   70 kt = m
      j = 2
   80 if (mod(k,j).ne.0) go to 90
      m = m + 1
      nfac(m) = j
      k = k/j
   90 j = ((j+1)/2)*2 + 1
      if (j.le.k) go to 80
  100 if (kt.eq.0) go to 120
      j = kt
  110 m = m + 1
      nfac(m) = nfac(j)
      j = j - 1
      if (j.ne.0) go to 110
!  COMPUTE FOURIER TRANSFORM
  120 sd = radf/kspan
      cd = 2.0e0*sin(sd)**2
      sd = sin(sd+sd)
      kk = 1
      i = i + 1
      if (nfac(i).ne.2) go to 170
!  TRANSFORM FOR FACTOR OF 2 (INCLUDING ROTATION FACTOR)
      kspan = kspan/2
      k1 = kspan + 2
  130 k2 = kk + kspan
      ak = a(k2)
      bk = b(k2)
      a(k2) = a(kk) - ak
      b(k2) = b(kk) - bk
      a(kk) = a(kk) + ak
      b(kk) = b(kk) + bk
      kk = k2 + kspan
      if (kk.le.nn) go to 130
      kk = kk - nn
      if (kk.le.jc) go to 130
      if (kk.gt.kspan) go to 360
  140 c1 = 1.0e0 - cd
      s1 = sd
  150 k2 = kk + kspan
      ak = a(kk) - a(k2)
      bk = b(kk) - b(k2)
      a(kk) = a(kk) + a(k2)
      b(kk) = b(kk) + b(k2)
      a(k2) = c1*ak - s1*bk
      b(k2) = s1*ak + c1*bk
      kk = k2 + kspan
      if (kk.lt.nt) go to 150
      k2 = kk - nt
      c1 = -c1
      kk = k1 - k2
      if (kk.gt.k2) go to 150
      ak = c1 - (cd*c1+sd*s1)
      s1 = (sd*c1-cd*s1) + s1
!  THE FOLLOWING THREE STATEMENTS COMPENSATE FOR TRUNCATION ERROR
      c1 = 0.5_wp/(ak**2+s1**2) + 0.5e0
      s1 = c1*s1
      c1 = c1*ak
      kk = kk + jc
      if (kk.lt.k2) go to 150
      k1 = k1 + inc + inc
      kk = (k1-kspan)/2 + jc
      if (kk.le.jc+jc) go to 140
      go to 120
!  TRANSFORM FOR FACTOR OF 3 (OPTIONAL CODE)
  160 k1 = kk + kspan
      k2 = k1 + kspan
      ak = a(kk)
      bk = b(kk)
      aj = a(k1) + a(k2)
      bj = b(k1) + b(k2)
      a(kk) = ak + aj
      b(kk) = bk + bj
      ak = -0.5e0*aj + ak
      bk = -0.5e0*bj + bk
      aj = (a(k1)-a(k2))*s120
      bj = (b(k1)-b(k2))*s120
      a(k1) = ak - bj
      b(k1) = bk + aj
      a(k2) = ak + bj
      b(k2) = bk - aj
      kk = k2 + kspan
      if (kk.lt.nn) go to 160
      kk = kk - nn
      if (kk.le.kspan) go to 160
      go to 320
!  TRANSFORM FOR FACTOR OF 4
  170 if (nfac(i).ne.4) go to 260
      kspnn = kspan
      kspan = kspan/4
  180 c1 = 1.0e0
      s1 = 0
  190 k1 = kk + kspan
      k2 = k1 + kspan
      k3 = k2 + kspan
      akp = a(kk) + a(k2)
      akm = a(kk) - a(k2)
      ajp = a(k1) + a(k3)
      ajm = a(k1) - a(k3)
      a(kk) = akp + ajp
      ajp = akp - ajp
      bkp = b(kk) + b(k2)
      bkm = b(kk) - b(k2)
      bjp = b(k1) + b(k3)
      bjm = b(k1) - b(k3)
      b(kk) = bkp + bjp
      bjp = bkp - bjp
      if (isn.lt.0) go to 220
      akp = akm - bjm
      akm = akm + bjm
      bkp = bkm + ajm
      bkm = bkm - ajm
      if (s1.eq.0.0e0) go to 230
  200 a(k1) = akp*c1 - bkp*s1
      b(k1) = akp*s1 + bkp*c1
      a(k2) = ajp*c2 - bjp*s2
      b(k2) = ajp*s2 + bjp*c2
      a(k3) = akm*c3 - bkm*s3
      b(k3) = akm*s3 + bkm*c3
      kk = k3 + kspan
      if (kk.le.nt) go to 190
  210 c2 = c1 - (cd*c1+sd*s1)
      s1 = (sd*c1-cd*s1) + s1
      c1 = 0.5_wp/(c2**2+s1**2) + 0.5e0
      s1 = c1*s1
      c1 = c1*c2
      c2 = c1**2 - s1**2
      s2 = 2.0e0*c1*s1
      c3 = c2*c1 - s2*s1
      s3 = c2*s1 + s2*c1
      kk = kk - nt + jc
      if (kk.le.kspan) go to 190
      kk = kk - kspan + inc
      if (kk.le.jc) go to 180
      if (kspan.eq.jc) go to 360
      go to 120
  220 akp = akm + bjm
      akm = akm - bjm
      bkp = bkm - ajm
      bkm = bkm + ajm
      if (s1.ne.0.0e0) go to 200
  230 a(k1) = akp
      b(k1) = bkp
      a(k2) = ajp
      b(k2) = bjp
      a(k3) = akm
      b(k3) = bkm
      kk = k3 + kspan
      if (kk.le.nt) go to 190
      go to 210
!  TRANSFORM FOR FACTOR OF 5 (OPTIONAL CODE)
  240 c2 = c72**2 - s72**2
      s2 = 2.0e0*c72*s72
  250 k1 = kk + kspan
      k2 = k1 + kspan
      k3 = k2 + kspan
      k4 = k3 + kspan
      akp = a(k1) + a(k4)
      akm = a(k1) - a(k4)
      bkp = b(k1) + b(k4)
      bkm = b(k1) - b(k4)
      ajp = a(k2) + a(k3)
      ajm = a(k2) - a(k3)
      bjp = b(k2) + b(k3)
      bjm = b(k2) - b(k3)
      aa = a(kk)
      bb = b(kk)
      a(kk) = aa + akp + ajp
      b(kk) = bb + bkp + bjp
      ak = akp*c72 + ajp*c2 + aa
      bk = bkp*c72 + bjp*c2 + bb
      aj = akm*s72 + ajm*s2
      bj = bkm*s72 + bjm*s2
      a(k1) = ak - bj
      a(k4) = ak + bj
      b(k1) = bk + aj
      b(k4) = bk - aj
      ak = akp*c2 + ajp*c72 + aa
      bk = bkp*c2 + bjp*c72 + bb
      aj = akm*s2 - ajm*s72
      bj = bkm*s2 - bjm*s72
      a(k2) = ak - bj
      a(k3) = ak + bj
      b(k2) = bk + aj
      b(k3) = bk - aj
      kk = k4 + kspan
      if (kk.lt.nn) go to 250
      kk = kk - nn
      if (kk.le.kspan) go to 250
      go to 320
!  TRANSFORM FOR ODD FACTORS
  260 k = nfac(i)
      kspnn = kspan
      kspan = kspan/k
      if (k.eq.3) go to 160
      if (k.eq.5) go to 240
      if (k.eq.jf) go to 280
      jf = k
      s1 = rad/k
      c1 = cos(s1)
      s1 = sin(s1)
      if (jf.gt.maxf) go to 590
      ck(jf) = 1.0e0
      sk(jf) = 0.0e0
      j = 1
  270 ck(j) = ck(k)*c1 + sk(k)*s1
      sk(j) = ck(k)*s1 - sk(k)*c1
      k = k - 1
      ck(k) = ck(j)
      sk(k) = -sk(j)
      j = j + 1
      if (j.lt.k) go to 270
  280 k1 = kk
      k2 = kk + kspnn
      aa = a(kk)
      bb = b(kk)
      ak = aa
      bk = bb
      j = 1
      k1 = k1 + kspan
  290 k2 = k2 - kspan
      j = j + 1
      at(j) = a(k1) + a(k2)
      ak = at(j) + ak
      bt(j) = b(k1) + b(k2)
      bk = bt(j) + bk
      j = j + 1
      at(j) = a(k1) - a(k2)
      bt(j) = b(k1) - b(k2)
      k1 = k1 + kspan
      if (k1.lt.k2) go to 290
      a(kk) = ak
      b(kk) = bk
      k1 = kk
      k2 = kk + kspnn
      j = 1
  300 k1 = k1 + kspan
      k2 = k2 - kspan
      jj = j
      ak = aa
      bk = bb
      aj = 0.0e0
      bj = 0.0e0
      k = 1
  310 k = k + 1
      ak = at(k)*ck(jj) + ak
      bk = bt(k)*ck(jj) + bk
      k = k + 1
      aj = at(k)*sk(jj) + aj
      bj = bt(k)*sk(jj) + bj
      jj = jj + j
      if (jj.gt.jf) jj = jj - jf
      if (k.lt.jf) go to 310
      k = jf - j
      a(k1) = ak - bj
      b(k1) = bk + aj
      a(k2) = ak + bj
      b(k2) = bk - aj
      j = j + 1
      if (j.lt.k) go to 300
      kk = kk + kspnn
      if (kk.le.nn) go to 280
      kk = kk - nn
      if (kk.le.kspan) go to 280
!  MULTIPLY BY ROTATION FACTOR (EXCEPT FOR FACTORS OF 2 AND 4)
  320 if (i.eq.m) go to 360
      kk = jc + 1
  330 c2 = 1.0e0 - cd
      s1 = sd
  340 c1 = c2
      s2 = s1
      kk = kk + kspan
  350 ak = a(kk)
      a(kk) = c2*ak - s2*b(kk)
      b(kk) = s2*ak + c2*b(kk)
      kk = kk + kspnn
      if (kk.le.nt) go to 350
      ak = s1*s2
      s2 = s1*c2 + c1*s2
      c2 = c1*c2 - ak
      kk = kk - nt + kspan
      if (kk.le.kspnn) go to 350
      c2 = c1 - (cd*c1+sd*s1)
      s1 = s1 + (sd*c1-cd*s1)
      c1 = 0.5_wp/(c2**2+s1**2) + 0.5e0
      s1 = c1*s1
      c2 = c1*c2
      kk = kk - kspnn + jc
      if (kk.le.kspan) go to 340
      kk = kk - kspan + jc + inc
      if (kk.le.jc+jc) go to 330
      go to 120
!  PERMUTE THE RESULTS TO NORMAL ORDER--- DONE IN TWO STAGES
!  PERMUTATION FOR SQUARE FACTORS OF N
  360 np(1) = ks
      if (kt.eq.0) go to 450
      k = kt + kt + 1
      if (m.lt.k) k = k - 1
      j = 1
      np(k+1) = jc
  370 np(j+1) = np(j)/nfac(j)
      np(k) = np(k+1)*nfac(j)
      j = j + 1
      k = k - 1
      if (j.lt.k) go to 370
      k3 = np(k+1)
      kspan = np(2)
      kk = jc + 1
      k2 = kspan + 1
      j = 1
      if (n.ne.ntot) go to 410
!  PERMUTATION FOR SINGLE-VARIATE TRANSFORM (OPTIONAL CODE)
  380 ak = a(kk)
      a(kk) = a(k2)
      a(k2) = ak
      bk = b(kk)
      b(kk) = b(k2)
      b(k2) = bk
      kk = kk + inc
      k2 = kspan + k2
      if (k2.lt.ks) go to 380
  390 k2 = k2 - np(j)
      j = j + 1
      k2 = np(j+1) + k2
      if (k2.gt.np(j)) go to 390
      j = 1
  400 if (kk.lt.k2) go to 380
      kk = kk + inc
      k2 = kspan + k2
      if (k2.lt.ks) go to 400
      if (kk.lt.ks) go to 390
      jc = k3
      go to 450
!  PERMUTATION FOR MULTIVARIATE TRANSFORM
  410 k = kk + jc
  420 ak = a(kk)
      a(kk) = a(k2)
      a(k2) = ak
      bk = b(kk)
      b(kk) = b(k2)
      b(k2) = bk
      kk = kk + inc
      k2 = k2 + inc
      if (kk.lt.k) go to 420
      kk = kk + ks - jc
      k2 = k2 + ks - jc
      if (kk.lt.nt) go to 410
      k2 = k2 - nt + kspan
      kk = kk - nt + jc
      if (k2.lt.ks) go to 410
  430 k2 = k2 - np(j)
      j = j + 1
      k2 = np(j+1) + k2
      if (k2.gt.np(j)) go to 430
      j = 1
  440 if (kk.lt.k2) go to 410
      kk = kk + jc
      k2 = kspan + k2
      if (k2.lt.ks) go to 440
      if (kk.lt.ks) go to 430
      jc = k3
  450 if (2*kt+1.ge.m) return
      kspnn = np(kt+1)
!  PERMUTATION FOR SQUARE-FREE FACTORS OF N
      j = m - kt
      nfac(j+1) = 1
  460 nfac(j) = nfac(j)*nfac(j+1)
      j = j - 1
      if (j.ne.kt) go to 460
      kt = kt + 1
      nn = nfac(kt) - 1
      if (nn.gt.maxp) go to 590
      jj = 0
      j = 0
      go to 490
  470 jj = jj - k2
      k2 = kk
      k = k + 1
      kk = nfac(k)
  480 jj = kk + jj
      if (jj.ge.k2) go to 470
      np(j) = jj
  490 k2 = nfac(kt)
      k = kt + 1
      kk = nfac(k)
      j = j + 1
      if (j.le.nn) go to 480
!  DETERMINE THE PERMUTATION CYCLES OF LENGTH GREATER THAN 1
      j = 0
      go to 510
  500 k = kk
      kk = np(k)
      np(k) = -kk
      if (kk.ne.j) go to 500
      k3 = kk
  510 j = j + 1
      kk = np(j)
      if (kk.lt.0) go to 510
      if (kk.ne.j) go to 500
      np(j) = -j
      if (j.ne.nn) go to 510
      maxf = inc*maxf
!  REORDER A AND B, FOLLOWING THE PERMUTATION CYCLES
      go to 580
  520 j = j - 1
      if (np(j).lt.0) go to 520
      jj = jc
  530 kspan = jj
      if (jj.gt.maxf) kspan = maxf
      jj = jj - kspan
      k = np(j)
      kk = jc*k + ii + jj
      k1 = kk + kspan
      k2 = 0
  540 k2 = k2 + 1
      at(k2) = a(k1)
      bt(k2) = b(k1)
      k1 = k1 - inc
      if (k1.ne.kk) go to 540
  550 k1 = kk + kspan
      k2 = k1 - jc*(k+np(k))
      k = -np(k)
  560 a(k1) = a(k2)
      b(k1) = b(k2)
      k1 = k1 - inc
      k2 = k2 - inc
      if (k1.ne.kk) go to 560
      kk = k2
      if (k.ne.j) go to 550
      k1 = kk + kspan
      k2 = 0
  570 k2 = k2 + 1
      a(k1) = at(k2)
      b(k1) = bt(k2)
      k1 = k1 - inc
      if (k1.ne.kk) go to 570
      if (jj.ne.0) go to 530
      if (j.ne.1) go to 520
  580 j = k3 + 1
      nt = nt - kspnn
      ii = nt - inc + 1
      if (nt.ge.0) go to 520
      return
!  ERROR FINISH, INSUFFICIENT ARRAY STORAGE
  590 isn = 0
      call iprint(iprt)
      write(iprt, 1000)
!
!     NB.  THE FOLLOWING STOP SHOULD BE CHANGED TO A RETURN WHEN
!          THE TIME SERIES ROUTINES ARE MODIFIED FOR STARPAC.
!
      stop
!
!     FORMAT STATEMENTS
!
1000 format (' ', 17('*')/18h * error message */1x, 17('*')//&
    &   45h array bounds exceeded within subroutine fft./&
    &   44h please bring this error to the attention of/&
    &   22h    janet r. donaldson/&
    &   16h    303-497-5114/&
     &   16h    fts 320-5114)
      end
