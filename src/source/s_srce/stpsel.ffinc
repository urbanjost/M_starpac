!STPSEL
     subroutine stpsel(xm, n, m, ixm, mdl, par, npar,&
    &   nexmpt, stp, nfail, ifail, j, eta3, reltol, abstol, tauabs,&
     &   stplow, stpmid, stpup, itemp, fd, fdlast, fdsave, pv, pvnew)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE SELECTS NEW STEP SIZES UNITL EITHER
!     THE NUMBER OF OBSERVATIONS AT WHICH THE SELECTION CRITERIA
!     IS NOT MET DOES NOT EXCEED NEXMPT OR UNTIL NO FURTHER
!     IMPROVEMENT CAN BE MADE.
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   abstol,eta3,reltol,stp,stplow,stpmid,stpup,tauabs
     integer&
     &   ixm,j,m,n,nexmpt,nfail,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   fd(n),fdlast(n),fdsave(n),par(npar),pv(n),pvnew(n),xm(ixm,m)
     integer&
     &   ifail(n),itemp(n)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  SCALARS IN COMMON
     real(kind=wp) ::&
     &   q
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   factor,stp1,stp2,stpnew,temp
     integer&
     &   ncount
     logical&
     &   fail,first,forwrd,hicurv,succes
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL ABSCOM,CMPFD,ICOPY,RELCOM,STPADJ
!
!  INTRINSIC FUNCTIONS
      intrinsic abs
!
!  COMMON BLOCKS
      common /notopt/q
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ABSTOL
!        THE ABSOLUTE AGREEMENT TOLERANCE.
!     REAL ETA3
!        THE CUBE ROOT OF THE RELATIVE NOISE IN THE MODEL
!     REAL FACTOR
!        A FACTOR USED IN COMPUTING THE STEP SIZE.
!     LOGICAL FAIL
!        THE VARIABLE USED TO INDICATE WHETHER A STEP SIZE
!        CANNOT BE SELECTED WHICH WILL SUCCESSFULLY MEET THE CRITERIA.
!     REAL FD(N)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!     REAL FDLAST(N)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!        COMPUTED WITH THE MOST RECENT STEP SIZE SELECTED.
!     REAL FDSAVE(N)
!        A VECTOR USED TO SAVE THE BEST OF THE
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATIONS TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!     LOGICAL FIRST
!        THE VARIABLE USED TO INDICATE WHETHER THIS STEP SIZE
!        IS BEING USED FOR THE FIRST TIME OR WHETHER IT HAS BEEN
!        PREVIOUSLY ADJUSTED.
!     LOGICAL FORWRD
!        THE VARIABLE USED TO INDICATE THE DIRECTION OF CHANGE IN
!        THE STEP SIZE.
!     LOGICAL HICURV
!        THE VARIABLE USED TO INDICATE WHETHER THE MODEL HAS
!        HIGH CURVATURE.
!     INTEGER IFAIL(N)
!        AN INDICATOR VECTOR USED TO DESIGNATE THOSE OBSERVATIONS
!        FOR WHICH THE STEP SIZE DOES NOT MEET THE CRITERIA.
!     INTEGER ITEMP(N)
!        A TEMPORARY VECTOR USED FOR STORING PAST VALUES OF ITEMP.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NCOUNT
!        THE NUMBER OF OBSERVATIONS AT WHICH THE NEW STEP SIZE DOES
!        SATISFY THE CRITERIA.
!     INTEGER NEXMPT
!        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
!        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
!        SIZE STILL BE CONSIDERED OK.
!     INTEGER NFAIL
!        A VECTOR CONTAINING FOR EACH OBSERVATION THE NUMBER OF
!        OBSERVATIONS FOR WHICH THE STEP SIZE DID NOT MEET THE CRITERIA.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL PVNEW(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCD.
!     REAL Q
!        A DUMMY VARIABLE WHICH IS USED, ALONG WITH COMMON NOTOPT (NO
!        OPTIMIZATION), TO COMPUTE THE STEP SIZE.
!     REAL STP
!        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FORWARD
!        DIFFERENCE APPROXIMATION TO THE DERIVATIVE.
!     REAL STPLOW
!        THE LOWER LIMIT ON THE STEP SIZE.
!     REAL STPMID
!        THE MIDPOINT OF THE ACCEPTABLE RANGE OF THE STEP SIZE.
!     REAL STPNEW
!        THE VALUE OF THE NEW STEP SIZE BEING TESTED.
!     REAL STPUP
!        THE UPPER LIMIT ON THE STEP SIZE.
!     REAL STP1, STP2
!        TEMPORARY STORAGE LOCATIONS FOR STEP SIZES.
!     LOGICAL SUCCES
!        THE VARIABLE USED TO INDICATE WHETHER THE STEP SIZE
!        SUCCESSFULLY MEETS THE CRITERIA USED TO SELECT THE STEP
!        SIZES.
!     REAL RELTOL
!        THE RELATIVE AGREEMENT TOLERANCE.
!     REAL TAUABS
!        THE ABSOLUTE AGREEMENT TOLERANCE.
!     REAL TEMP
!        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
!        PARAMETER IS STORED.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      call scopy(n, fd, 1, fdsave, 1)
!
      factor = 10.0e0
      if (abs(stp) .gt. stpmid) factor = 0.1e0
!
      stpnew = stp * factor
      stp1 = stpnew
      stp2 = stpnew
!
      q = stpnew + par(j)
      stpnew = q - par(j)
!
      first = .true.
      forwrd = .true.
      succes = .false.
      fail = .false.
!
      nfail = n + 1
!
!     REPEAT FOLLOWING UNTIL (SUCCES) OR (FAIL)
!
   10 continue
!
      call scopy(n, fd, 1, fdlast, 1)
!
      temp = par(j)
      par(j) = temp + stpnew
!
      call mdl(par, npar, xm, n, m, ixm, pvnew)
!
      par(j) = temp
!
      call cmpfd(n, stpnew, pvnew, pv, fd)
!
      call relcom(n, fd, fdlast, reltol, abstol, ncount, itemp)
!
      if (ncount.le.nexmpt) then
            succes = .true.
            nfail = ncount
            call icopy(n, itemp, 1, ifail, 1)
           if (abs(abs(stpnew) - stpmid) .gt.&
     &         abs(abs(stpnew/factor) - stpmid)) then
                  stp = stpnew / factor
            else
                  stp = stpnew
            end if
      else
            if (ncount.lt.nfail) then
                  nfail = ncount
                  stp1 = stpnew
                  stp2 = stpnew / factor
                  call icopy(n, itemp, 1, ifail, 1)
            end if
            if (first) then
                  first = .false.
                  call abscom(n, fd, fdlast, tauabs, ncount)
                  if (ncount.le.nexmpt) then
                         hicurv = .true.
                  else
                         hicurv = .false.
                  end if
            end if
            stpnew = stpnew * factor
            q = stpnew + par(j)
            stpnew = q - par(j)
           if ((factor.gt.1.0e0 .and. abs(stpnew).gt.stpup) .or.&
     &          (factor.lt.1.0e0 .and. abs(stpnew).lt.stplow)) then
                  if (forwrd) then
                        forwrd = .false.
                        factor = 1.0e0 / factor
                        stpnew = stp * factor
                        q = stpnew + par(j)
                        stpnew = q - par(j)
                        call scopy(n, fdsave, 1, fd, 1)
                        stplow = stplow * (eta3)
                        stpup = stpup / (eta3)
                  else
                        fail = .true.
                  end if
            end if
      end if
!
      if (.not.(succes.or.fail)) go to 10
!
      if (succes .and. forwrd) then
           call stpadj(xm, n, m, ixm, mdl, par, npar,&
    &         nexmpt, stp, nfail, ifail, j, reltol, abstol, stplow,&
     &         stpmid, stpup, itemp, fd, fdlast, pv, pvnew)
            return
      else
            if (succes) then
                  return
            else
!                 IF (HICURV) NFAIL = -NFAIL
!
                  if (abs(stp1).lt.abs(stp2)) then
                        stp = stp1
                        return
                  else
                        stp = stp2
                        return
                  end if
            end if
      end if
!
      end
