!DBETAI
      double precision function dbetai (x, pin, qin)
! JULY 1977 EDITION.  W. FULLERTON, C3, LOS ALAMOS SCIENTIFIC LAB.
! BASED ON BOSTEN AND BATTISTE, REMARK ON ALGORITHM 179, COMM. ACM,
! V 17, P 156, (1974).
!
!             INPUT ARGUMENTS --
! X      UPPER LIMIT OF INTEGRATION.  X MUST BE IN (0,1) INCLUSIVE.
! P      FIRST BETA DISTRIBUTION PARAMETER.  P MUST BE GT 0.0.
! Q      SECOND BETA DISTRIBUTION PARAMETER.  Q MUST BE GT 0.0.
! BETAI  THE INCOMPLETE BETA FUNCTION RATIO IS THE PROBABILITY THAT A
!        RANDOM VARIABLE FROM A BETA DISTRIBUTION HAVING PARAMETERS
!        P AND Q WILL BE LESS THAN OR EQUAL TO X.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      double precision pin,qin,x
!
!  LOCAL SCALARS
     double precision alneps,alnsml,c,eps,fac1,fac2,finsum,p,ps,q,sml,&
     &   term,xb,y
      real p1
      integer i,ib,n
!
!  EXTERNAL FUNCTIONS
!      DOUBLE PRECISION D1MACH,DLBETA
!       EXTERNAL D1MACH,DLBETA
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL XERROR
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,dble,exp,float,int,log,max,min,sngl
!
      data             eps, alneps, sml, alnsml / 4*0.0d0 /
!
      if (eps.ne.0.0d0) go to 10
      eps = d1mach(3)
      alneps = log (eps)
      sml = d1mach(1)
      alnsml = log (sml)
!
10   if (x.lt.0.d0 .or. x.gt.1.d0) call xerror (&
     &  'DBETAI  X IS NOT IN THE RANGE (0,1)', 35, 1, 2)
     if (pin.le.0.d0 .or. qin.le.0.d0) call xerror (&
     &  'DBETAI  P AND/OR Q IS LE ZERO', 29, 2, 2)
!
      y = x
      p = pin
      q = qin
      if (q.le.p .and. x.lt.0.8d0) go to 20
      if (x.lt.0.2d0) go to 20
      y = 1.0d0 - y
      p = qin
      q = pin
!
 20   if ((p+q)*y/(p+1.d0).lt.eps) go to 80
!
! EVALUATE THE INFINITE SUM FIRST.  TERM WILL EQUAL
! Y**P/BETA(PS,P) * (1.-PS)-SUB-I * Y**I / FAC(I) .
!
      ps = q - int(q)
      if (ps.eq.0.d0) ps = 1.0d0
      xb = p*log(y) - dlbeta(ps,p) - log(p)
      dbetai = 0.0d0
      if (xb.ge.alnsml) then
         dbetai = exp(xb)
         fac2 = 1.0
         if (ps.ne.1.0d0) then
            fac1 = 1.0
            n = max(alneps/log(y), 4.0d0)
            do 30 i=1,n
               if ((i-ps.eq.0.0d0) .or. (fac1.eq.0.0d0)) then
                  fac1 = 0.0d0
               else
                 if (log(abs(fac1)) + log(abs(i-ps)) + log(y) -&
     &                log(dble(i)) .lt. alnsml) then
                     fac1 = 0.0d0
                  else
                     fac1 = fac1 * (i-ps)*y/i
                  end if
               end if
               fac2 = fac2 + fac1*p/(p+i)
 30         continue
         end if
         dbetai = dbetai*fac2
      end if
!
! NOW EVALUATE THE FINITE SUM, MAYBE.
!
      if (q.le.1.0d0) go to 70
!
      xb = p*log(y) + q*log(1.0d0-y) - dlbeta(p,q) - log(q)
      ib = max(sngl(xb/alnsml), 0.0)
      term = exp (xb - dble(float(ib))*alnsml )
      c = 1.0d0/(1.d0-y)
      p1 = q*c/(p+q-1.d0)
!
      finsum = 0.0d0
      n = q
      if (q.eq.dble(float(n))) n = n - 1
      do 50 i=1,n
        if (p1.le.1.0d0 .and. term/eps.le.finsum) go to 60
        if (q-i+1.0d0 .eq. 0.0d0) then
          term = 0.0d0
        else
         if (log(abs(q-i+1.0d0)) + log(abs(c)) + log(abs(term)) -&
     &        log(abs(p+q-i)) .lt. alnsml) then
            term = 0.0d0
          else
            term = (q-i+1.0d0)*c*term/(p+q-i)
          end if
        end if
!
        if (term.gt.1.0d0) ib = ib - 1
        if (term.gt.1.0d0) term = term*sml
!
        if (ib.eq.0) finsum = finsum + term
 50   continue
!
 60   dbetai = dbetai + finsum
 70   if (y.ne.x .or. p.ne.pin) dbetai = 1.0d0 - dbetai
      dbetai = max (min (dbetai, 1.0d0), 0.0d0)
      return
!
 80   dbetai = 0.0d0
      xb = p*log(max(y,sml)) - log(p) - dlbeta(p,q)
      if (xb.gt.alnsml .and. y.ne.0.0d0) dbetai = exp(xb)
      if (y.ne.x .or. p.ne.pin) dbetai = 1.0d0 - dbetai
!
      return
      end
