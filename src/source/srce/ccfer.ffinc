!CCFER
      SUBROUTINE CCFER(NMSUB, N, LAGMAX, LDSTAK, LDSMIN, ICCOV, JCCOV,
     &  INLPPC, JNLPPC, M, LYFFT, NFFT, IYM, IYMFFT, ISFFT, ISLONG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE ERROR CHECKING ROUTINE FOR THE CCF FAMILY
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     &   ICCOV,INLPPC,IYM,IYMFFT,JCCOV,JNLPPC,LAGMAX,LDSMIN,LDSTAK,
     &   LYFFT,M,N,NFFT
      LOGICAL
     &   ISFFT,ISLONG
!
!  ARRAY ARGUMENTS
      CHARACTER
     &   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     &   IERR
!
!  LOCAL SCALARS
      INTEGER
     &   I
      LOGICAL
     &   HEAD
!
!  LOCAL ARRAYS
      LOGICAL
     &   ERR(15)
      CHARACTER
     &   LICCOV(8)*1,LINLPP(8)*1,LIYM(8)*1,LIYMFF(8)*1,
     &   LJCCOV(8)*1,LJNLPP(8)*1,LLAGMX(8)*1,LLDS(8)*1,
     &   LLGMX1(8)*1,LLYFFT(8)*1,LM(8)*1,LN(8)*1,LNFFT(8)*1,
     &   LNM1(8)*1,LONE(8)*1,LTHREE(8)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR(15)
!        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     LOGICAL ISLONG
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
!     INTEGER IYM, IYMFFT
!        THE FIRST DIMENSION OF THE ARRAYS YM AND YMFFT, RESPECTIVELY.
!     INTEGER JCCOV, JNLPPC
!        THE SECOND DIMENSIONS OF THE ARRAYS CCOV AND NLPPC,
!        RESPECTIVELY.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LICCOV(8), LINLPP(8), LIYM(8), LIYMFF(8), LJCCOV(8),
!    *  LJNLPP(8), LLAGMX(8), LLDS(8), LLGMX1(8), LLYFFT(8),
!    *  LM(8), LN(8), LNFFT(8), LNM1(8), LONE(8), LTHREE(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER M
!        THE NUMBER OF SERIES BEING ANALYZED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!
!     SET UP NAME ARRAYS
!
      DATA
     & LICCOV(1), LICCOV(2), LICCOV(3), LICCOV(4), LICCOV(5),
     & LICCOV(6), LICCOV(7), LICCOV(8) /'I','C','C','O','V',' ',' ',' '/
      DATA
     & LINLPP(1), LINLPP(2), LINLPP(3), LINLPP(4), LINLPP(5),
     & LINLPP(6), LINLPP(7), LINLPP(8) /'I','N','L','P','P','C',' ',' '/
      DATA
     & LIYM(1), LIYM(2), LIYM(3), LIYM(4), LIYM(5),
     & LIYM(6), LIYM(7), LIYM(8) /'I','Y','M',' ',' ',' ',' ',' '/
      DATA
     & LIYMFF(1), LIYMFF(2), LIYMFF(3), LIYMFF(4), LIYMFF(5),
     & LIYMFF(6), LIYMFF(7), LIYMFF(8) /'I','Y','M','F','F','T',' ',' '/
      DATA
     & LJCCOV(1), LJCCOV(2), LJCCOV(3), LJCCOV(4), LJCCOV(5),
     & LJCCOV(6), LJCCOV(7), LJCCOV(8) /'J','C','C','O','V',' ',' ',' '/
      DATA
     & LJNLPP(1), LJNLPP(2), LJNLPP(3), LJNLPP(4), LJNLPP(5),
     & LJNLPP(6), LJNLPP(7), LJNLPP(8) /'J','N','L','P','P','C',' ',' '/
      DATA
     & LLAGMX(1), LLAGMX(2), LLAGMX(3), LLAGMX(4), LLAGMX(5),
     & LLAGMX(6), LLAGMX(7), LLAGMX(8) /'L','A','G','M','A','X',' ',' '/
      DATA
     & LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     & LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA
     & LLGMX1(1), LLGMX1(2), LLGMX1(3), LLGMX1(4), LLGMX1(5),
     & LLGMX1(6), LLGMX1(7), LLGMX1(8) /'L','A','G','M','A','X','+','1'/
      DATA
     & LLYFFT(1), LLYFFT(2), LLYFFT(3), LLYFFT(4), LLYFFT(5),
     & LLYFFT(6), LLYFFT(7), LLYFFT(8) /'L','Y','F','F','T',' ',' ',' '/
      DATA
     & LM(1), LM(2), LM(3), LM(4), LM(5),
     & LM(6), LM(7), LM(8) /'M',' ',' ',' ',' ',' ',' ',' '/
      DATA
     & LN(1), LN(2), LN(3), LN(4), LN(5),
     & LN(6), LN(7), LN(8) /'N',' ',' ',' ',' ',' ',' ',' '/
      DATA
     & LNM1(1), LNM1(2), LNM1(3), LNM1(4), LNM1(5),
     & LNM1(6), LNM1(7), LNM1(8) /'(','N','-','1',')',' ',' ',' '/
      DATA
     & LNFFT(1), LNFFT(2), LNFFT(3), LNFFT(4), LNFFT(5),
     & LNFFT(6), LNFFT(7), LNFFT(8) /'N','F','F','T',' ',' ',' ',' '/
      DATA
     & LONE(1), LONE(2), LONE(3), LONE(4), LONE(5),
     & LONE(6), LONE(7), LONE(8) /'O','N','E',' ',' ',' ',' ',' '/
      DATA
     & LTHREE(1), LTHREE(2), LTHREE(3), LTHREE(4), LTHREE(5),
     & LTHREE(6), LTHREE(7), LTHREE(8) /'T','H','R','E','E',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
      DO 10 I = 1, 15
        ERR(I) = .FALSE.
   10 CONTINUE
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 3, 2, HEAD, ERR(1), LTHREE)
!
      CALL EISGE(NMSUB, LM, M, 1, 2, HEAD, ERR(2), LONE)
!
      IF (.NOT.ERR(1)) THEN
!
        CALL EISII(NMSUB, LLAGMX, LAGMAX, 1, N-1, 1, HEAD, ERR(3), LONE,
     &    LNM1)
!
        IF (ISFFT) THEN
          IF (ISLONG) THEN
            CALL EISGE(NMSUB, LIYMFF, IYMFFT, NFFT, 3, HEAD, ERR(4),
     &        LNFFT)
          ELSE
            CALL EISGE(NMSUB, LLYFFT, LYFFT, NFFT, 3, HEAD, ERR(4),
     &        LNFFT)
          END IF
        ELSE
          CALL EISGE(NMSUB, LIYM, IYM, N, 3, HEAD, ERR(4), LN)
        END IF
!
        IF (.NOT.ERR(3)) THEN
!
          IF (ISLONG) THEN
            CALL EISGE(NMSUB, LICCOV, ICCOV, LAGMAX+1, 3, HEAD, ERR(5),
     &        LLGMX1)
            CALL EISGE(NMSUB, LJCCOV, JCCOV, M, 3, HEAD, ERR(6),
     &        LLGMX1)
            CALL EISGE(NMSUB, LINLPP, INLPPC, LAGMAX+1, 3, HEAD, ERR(7),
     &        LLGMX1)
            CALL EISGE(NMSUB, LJNLPP, JNLPPC, M, 3, HEAD, ERR(8),
     &        LLGMX1)
          END IF
!
          CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR(9), LLDS)
!
        END IF
      END IF
!
      DO 20 I = 1, 15
        IF (ERR(I)) IERR = 1
   20 CONTINUE
!
      RETURN
!
      END
