!DTRDI
      subroutine dtrdi(t,ldt,n,det,job,info)
!
!     DTRDI COMPUTES THE DETERMINANT AND INVERSE OF A DOUBLE PRECISION
!     TRIANGULAR MATRIX.
!
!     ON ENTRY
!
!        T       DOUBLE PRECISION(LDT,N)
!                T CONTAINS THE TRIANGULAR MATRIX. THE ZERO
!                ELEMENTS OF THE MATRIX ARE NOT REFERENCED, AND
!                THE CORRESPONDING ELEMENTS OF THE ARRAY CAN BE
!                USED TO STORE OTHER INFORMATION.
!
!        LDT     INTEGER
!                LDT IS THE LEADING DIMENSION OF THE ARRAY T.
!
!        N       INTEGER
!                N IS THE ORDER OF THE SYSTEM.
!
!        JOB     INTEGER
!                = 010       NO DET, INVERSE OF LOWER TRIANGULAR.
!                = 011       NO DET, INVERSE OF UPPER TRIANGULAR.
!                = 100       DET, NO INVERSE.
!                = 110       DET, INVERSE OF LOWER TRIANGULAR.
!                = 111       DET, INVERSE OF UPPER TRIANGULAR.
!
!     ON RETURN
!
!        T       INVERSE OF ORIGINAL MATRIX IF REQUESTED.
!                OTHERWISE UNCHANGED.
!
!        DET     DOUBLE PRECISION(2)
!                DETERMINANT OF ORIGINAL MATRIX IF REQUESTED.
!                OTHERWISE NOT REFERENCED.
!                DETERMINANT = DET(1) * 10.0**DET(2)
!                WITH  1.0 .LE. DABS(DET(1)) .LT. 10.0
!                OR  DET(1) .EQ. 0.0 .
!
!        INFO    INTEGER
!                INFO CONTAINS ZERO IF THE SYSTEM IS NONSINGULAR
!                AND THE INVERSE IS REQUESTED.
!                OTHERWISE INFO CONTAINS THE INDEX OF
!                A ZERO DIAGONAL ELEMENT OF T.
!
!
!     LINPACK. THIS VERSION DATED 08/14/78 .
!     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
!
!     SUBROUTINES AND FUNCTIONS
!
!     BLAS DAXPY,DSCAL
!     FORTRAN DABS,MOD
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer info,job,ldt,n
!
!  ARRAY ARGUMENTS
      double precision det(2),t(ldt,*)
!
!  LOCAL SCALARS
      double precision temp,ten
      integer i,j,k,kb,km1,kp1
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL DAXPY,DSCAL
!
!  INTRINSIC FUNCTIONS
      intrinsic dabs,mod
!
!
!     BEGIN BLOCK PERMITTING ...EXITS TO 180
!
!        COMPUTE DETERMINANT
!
         if (job/100 .eq. 0) go to 70
            det(1) = 1.0d0
            det(2) = 0.0d0
            ten = 10.0d0
            do 50 i = 1, n
               det(1) = t(i,i)*det(1)
!           ...EXIT
               if (det(1) .eq. 0.0d0) go to 60
   10          if (dabs(det(1)) .ge. 1.0d0) go to 20
                  det(1) = ten*det(1)
                  det(2) = det(2) - 1.0d0
               go to 10
   20          continue
   30          if (dabs(det(1)) .lt. ten) go to 40
                  det(1) = det(1)/ten
                  det(2) = det(2) + 1.0d0
               go to 30
   40          continue
   50       continue
   60       continue
   70    continue
!
!        COMPUTE INVERSE OF UPPER TRIANGULAR
!
         if (mod(job/10,10) .eq. 0) go to 170
            if (mod(job,10) .eq. 0) go to 120
!              BEGIN BLOCK PERMITTING ...EXITS TO 110
                  do 100 k = 1, n
                     info = k
!              ......EXIT
                     if (t(k,k) .eq. 0.0d0) go to 110
                     t(k,k) = 1.0d0/t(k,k)
                     temp = -t(k,k)
                     call dscal(k-1,temp,t(1,k),1)
                     kp1 = k + 1
                     if (n .lt. kp1) go to 90
                     do 80 j = kp1, n
                        temp = t(k,j)
                        t(k,j) = 0.0d0
                        call daxpy(k,temp,t(1,k),1,t(1,j),1)
   80                continue
   90                continue
  100             continue
                  info = 0
  110          continue
            go to 160
  120       continue
!
!              COMPUTE INVERSE OF LOWER TRIANGULAR
!
               do 150 kb = 1, n
                  k = n + 1 - kb
                  info = k
!     ............EXIT
                  if (t(k,k) .eq. 0.0d0) go to 180
                  t(k,k) = 1.0d0/t(k,k)
                  temp = -t(k,k)
                  if (k .ne. n) call dscal(n-k,temp,t(k+1,k),1)
                  km1 = k - 1
                  if (km1 .lt. 1) go to 140
                  do 130 j = 1, km1
                     temp = t(k,j)
                     t(k,j) = 0.0d0
                     call daxpy(n-k+1,temp,t(k,k),1,t(k,j),1)
  130             continue
  140             continue
  150          continue
               info = 0
  160       continue
  170    continue
  180 continue
      return
      end
