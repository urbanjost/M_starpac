!DSIDI
      subroutine dsidi(a,lda,n,kpvt,det,inert,work,job)
!
!     DSIDI COMPUTES THE DETERMINANT, INERTIA AND INVERSE
!     OF A DOUBLE PRECISION SYMMETRIC MATRIX USING THE FACTORS FROM
!     DSIFA.
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer job,lda,n
!
!  ARRAY ARGUMENTS
      double precision a(lda,*),det(2),work(*)
      integer inert(3),kpvt(*)
!
!  LOCAL SCALARS
      double precision ak,akkp1,akp1,d,t,temp,ten
      integer j,jb,k,km1,ks,kstep
      logical nodet,noert,noinv
!
!  EXTERNAL FUNCTIONS
!      DOUBLE PRECISION DDOT
!       EXTERNAL DDOT
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL DAXPY,DCOPY,DSWAP
!
!  INTRINSIC FUNCTIONS
      intrinsic dabs,iabs,mod
!
!
!     ON ENTRY
!
!        A       DOUBLE PRECISION(LDA,N)
!                THE OUTPUT FROM DSIFA.
!
!        LDA     INTEGER
!                THE LEADING DIMENSION OF THE ARRAY A.
!
!        N       INTEGER
!                THE ORDER OF THE MATRIX A.
!
!        KPVT    INTEGER(N)
!                THE PIVOT VECTOR FROM DSIFA.
!
!        WORK    DOUBLE PRECISION(N)
!                WORK VECTOR.  CONTENTS DESTROYED.
!
!        JOB     INTEGER
!                JOB HAS THE DECIMAL EXPANSION  ABC  WHERE
!                   IF  C .NE. 0, THE INVERSE IS COMPUTED,
!                   IF  B .NE. 0, THE DETERMINANT IS COMPUTED,
!                   IF  A .NE. 0, THE INERTIA IS COMPUTED.
!
!                FOR EXAMPLE, JOB = 111  GIVES ALL THREE.
!
!     ON RETURN
!
!        VARIABLES NOT REQUESTED BY JOB ARE NOT USED.
!
!        A      CONTAINS THE UPPER TRIANGLE OF THE INVERSE OF
!               THE ORIGINAL MATRIX.  THE STRICT LOWER TRIANGLE
!               IS NEVER REFERENCED.
!
!        DET    DOUBLE PRECISION(2)
!               DETERMINANT OF ORIGINAL MATRIX.
!               DETERMINANT = DET(1) * 10.0**DET(2)
!               WITH 1.0 .LE. DABS(DET(1)) .LT. 10.0
!               OR DET(1) = 0.0.
!
!        INERT  INTEGER(3)
!               THE INERTIA OF THE ORIGINAL MATRIX.
!               INERT(1)  =  NUMBER OF POSITIVE EIGENVALUES.
!               INERT(2)  =  NUMBER OF NEGATIVE EIGENVALUES.
!               INERT(3)  =  NUMBER OF ZERO EIGENVALUES.
!
!     ERROR CONDITION
!
!        A DIVISION BY ZERO MAY OCCUR IF THE INVERSE IS REQUESTED
!        AND  DSICO  HAS SET RCOND .EQ. 0.0
!        OR  DSIFA  HAS SET  INFO .NE. 0 .
!
!     LINPACK. THIS VERSION DATED 08/14/78 .
!     JAMES BUNCH, UNIV. CALIF. SAN DIEGO, ARGONNE NAT. LAB
!
!     SUBROUTINES AND FUNCTIONS
!
!     BLAS DAXPY,DCOPY,DDOT,DSWAP
!     FORTRAN DABS,IABS,MOD
!
!
      ten = 10.0d0
!
      noinv = mod(job,10) .eq. 0
      nodet = mod(job,100)/10 .eq. 0
      noert = mod(job,1000)/100 .eq. 0
!
      if (nodet .and. noert) go to 140
         if (noert) go to 10
            inert(1) = 0
            inert(2) = 0
            inert(3) = 0
   10    continue
         if (nodet) go to 20
            det(1) = 1.0d0
            det(2) = 0.0d0
   20    continue
         t = 0.0d0
         do 130 k = 1, n
            d = a(k,k)
!
!           CHECK IF 1 BY 1
!
            if (kpvt(k) .gt. 0) go to 50
!
!              2 BY 2 BLOCK
!              USE DET (D  S)  =  (D/T * C - T) * T  ,  T = DABS(S)
!                      (S  C)
!              TO AVOID UNDERFLOW/OVERFLOW TROUBLES.
!              TAKE TWO PASSES THROUGH SCALING.  USE  T  FOR FLAG.
!
               if (t .ne. 0.0d0) go to 30
                  t = dabs(a(k,k+1))
                  d = (d/t)*a(k+1,k+1) - t
               go to 40
   30          continue
                  d = t
                  t = 0.0d0
   40          continue
   50       continue
!
            if (noert) go to 60
               if (d .gt. 0.0d0) inert(1) = inert(1) + 1
               if (d .lt. 0.0d0) inert(2) = inert(2) + 1
               if (d .eq. 0.0d0) inert(3) = inert(3) + 1
   60       continue
!
            if (nodet) go to 120
               det(1) = d*det(1)
               if (det(1) .eq. 0.0d0) go to 110
   70             if (dabs(det(1)) .ge. 1.0d0) go to 80
                     det(1) = ten*det(1)
                     det(2) = det(2) - 1.0d0
                  go to 70
   80             continue
   90             if (dabs(det(1)) .lt. ten) go to 100
                     det(1) = det(1)/ten
                     det(2) = det(2) + 1.0d0
                  go to 90
  100             continue
  110          continue
  120       continue
  130    continue
  140 continue
!
!     COMPUTE INVERSE(A)
!
      if (noinv) go to 270
         k = 1
  150    if (k .gt. n) go to 260
            km1 = k - 1
            if (kpvt(k) .lt. 0) go to 180
!
!              1 BY 1
!
               a(k,k) = 1.0d0/a(k,k)
               if (km1 .lt. 1) go to 170
                  call dcopy(km1,a(1,k),1,work,1)
                  do 160 j = 1, km1
                     a(j,k) = ddot(j,a(1,j),1,work,1)
                     call daxpy(j-1,work(j),a(1,j),1,a(1,k),1)
  160             continue
                  a(k,k) = a(k,k) + ddot(km1,work,1,a(1,k),1)
  170          continue
               kstep = 1
            go to 220
  180       continue
!
!              2 BY 2
!
               t = dabs(a(k,k+1))
               ak = a(k,k)/t
               akp1 = a(k+1,k+1)/t
               akkp1 = a(k,k+1)/t
               d = t*(ak*akp1 - 1.0d0)
               a(k,k) = akp1/d
               a(k+1,k+1) = ak/d
               a(k,k+1) = -akkp1/d
               if (km1 .lt. 1) go to 210
                  call dcopy(km1,a(1,k+1),1,work,1)
                  do 190 j = 1, km1
                     a(j,k+1) = ddot(j,a(1,j),1,work,1)
                     call daxpy(j-1,work(j),a(1,j),1,a(1,k+1),1)
  190             continue
                  a(k+1,k+1) = a(k+1,k+1) + ddot(km1,work,1,a(1,k+1),1)
                  a(k,k+1) = a(k,k+1) + ddot(km1,a(1,k),1,a(1,k+1),1)
                  call dcopy(km1,a(1,k),1,work,1)
                  do 200 j = 1, km1
                     a(j,k) = ddot(j,a(1,j),1,work,1)
                     call daxpy(j-1,work(j),a(1,j),1,a(1,k),1)
  200             continue
                  a(k,k) = a(k,k) + ddot(km1,work,1,a(1,k),1)
  210          continue
               kstep = 2
  220       continue
!
!           SWAP
!
            ks = iabs(kpvt(k))
            if (ks .eq. k) go to 250
               call dswap(ks,a(1,ks),1,a(1,k),1)
               do 230 jb = ks, k
                  j = k + ks - jb
                  temp = a(j,k)
                  a(j,k) = a(ks,j)
                  a(ks,j) = temp
  230          continue
               if (kstep .eq. 1) go to 240
                  temp = a(ks,k+1)
                  a(ks,k+1) = a(k,k+1)
                  a(k,k+1) = temp
  240          continue
  250       continue
            k = k + kstep
         go to 150
  260    continue
  270 continue
      return
      end
