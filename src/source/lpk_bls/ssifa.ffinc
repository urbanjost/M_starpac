!SSIFA
      subroutine ssifa(a,lda,n,kpvt,info)
!
!     LATEST REVISION  -  JANUARY 24, 1990
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer info,lda,n
!
!  ARRAY ARGUMENTS
      real a(lda,*)
      integer kpvt(*)
!
!  LOCAL SCALARS
     real absakk,ak,akm1,alpha,bk,bkm1,colmax,denom,mulk,mulkm1,rowmax,&
     &   t
      integer imax,imaxp1,j,jj,jmax,k,km1,km2,kstep
      logical swap
!
!  EXTERNAL FUNCTIONS
!      INTEGER ISAMAX
!       EXTERNAL ISAMAX
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL SAXPY,SSWAP
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,amax1,sqrt
!
!
!     SSIFA FACTORS A REAL SYMMETRIC MATRIX BY ELIMINATION
!     WITH SYMMETRIC PIVOTING.
!
!     TO SOLVE  A*X = B , FOLLOW SSIFA BY SSISL.
!     TO COMPUTE  INVERSE(A)*C , FOLLOW SSIFA BY SSISL.
!     TO COMPUTE  DETERMINANT(A) , FOLLOW SSIFA BY SSIDI.
!     TO COMPUTE  INERTIA(A) , FOLLOW SSIFA BY SSIDI.
!     TO COMPUTE  INVERSE(A) , FOLLOW SSIFA BY SSIDI.
!
!     ON ENTRY
!
!        A       REAL(LDA,N)
!                THE SYMMETRIC MATRIX TO BE FACTORED.
!                ONLY THE DIAGONAL AND UPPER TRIANGLE ARE USED.
!
!        LDA     INTEGER
!                THE LEADING DIMENSION OF THE ARRAY  A .
!
!        N       INTEGER
!                THE ORDER OF THE MATRIX  A .
!
!     ON RETURN
!
!        A       A BLOCK DIAGONAL MATRIX AND THE MULTIPLIERS WHICH
!                WERE USED TO OBTAIN IT.
!                THE FACTORIZATION CAN BE WRITTEN  A = U*D*TRANS(U)
!                WHERE  U  IS A PRODUCT OF PERMUTATION AND UNIT
!                UPPER TRIANGULAR MATRICES , TRANS(U) IS THE
!                TRANSPOSE OF  U , AND  D  IS BLOCK DIAGONAL
!                WITH 1 BY 1 AND 2 BY 2 BLOCKS.
!
!        KPVT    INTEGER(N)
!                AN INTEGER VECTOR OF PIVOT INDICES.
!
!        INFO    INTEGER
!                = 0  NORMAL VALUE.
!                = K  IF THE K-TH PIVOT BLOCK IS SINGULAR. THIS IS
!                     NOT AN ERROR CONDITION FOR THIS SUBROUTINE,
!                     BUT IT DOES INDICATE THAT SSISL OR SSIDI MAY
!                     DIVIDE BY ZERO IF CALLED.
!
!     LINPACK. THIS VERSION DATED 08/14/78 .
!     JAMES BUNCH, UNIV. CALIF. SAN DIEGO, ARGONNE NAT. LAB.
!
!     SUBROUTINES AND FUNCTIONS
!
!     BLAS SAXPY,SSWAP,ISAMAX
!     FORTRAN ABS,AMAX1,SQRT
!
!
!     INITIALIZE
!
!     ALPHA IS USED IN CHOOSING PIVOT BLOCK SIZE.
      alpha = (1.0e0 + sqrt(17.0e0))/8.0e0
!
      info = 0
!
!     MAIN LOOP ON K, WHICH GOES FROM N TO 1.
!
      k = n
   10 continue
!
!        LEAVE THE LOOP IF K=0 OR K=1.
!
!     ...EXIT
         if (k .eq. 0) go to 200
         if (k .gt. 1) go to 20
            kpvt(1) = 1
            if (a(1,1) .eq. 0.0e0) info = 1
!     ......EXIT
            go to 200
   20    continue
!
!        THIS SECTION OF CODE DETERMINES THE KIND OF
!        ELIMINATION TO BE PERFORMED.  WHEN IT IS COMPLETED,
!        KSTEP WILL BE SET TO THE SIZE OF THE PIVOT BLOCK, AND
!        SWAP WILL BE SET TO .TRUE. IF AN INTERCHANGE IS
!        REQUIRED.
!
         km1 = k - 1
         absakk = abs(a(k,k))
!
!        DETERMINE THE LARGEST OFF-DIAGONAL ELEMENT IN
!        COLUMN K.
!
         imax = isamax(k-1,a(1,k),1)
         colmax = abs(a(imax,k))
         if (absakk .lt. alpha*colmax) go to 30
            kstep = 1
            swap = .false.
         go to 90
   30    continue
!
!           DETERMINE THE LARGEST OFF-DIAGONAL ELEMENT IN
!           ROW IMAX.
!
            rowmax = 0.0e0
            imaxp1 = imax + 1
            do 40 j = imaxp1, k
               rowmax = amax1(rowmax,abs(a(imax,j)))
   40       continue
            if (imax .eq. 1) go to 50
               jmax = isamax(imax-1,a(1,imax),1)
               rowmax = amax1(rowmax,abs(a(jmax,imax)))
   50       continue
            if (abs(a(imax,imax)) .lt. alpha*rowmax) go to 60
               kstep = 1
               swap = .true.
            go to 80
   60       continue
            if (absakk .lt. alpha*colmax*(colmax/rowmax)) go to 70
               kstep = 1
               swap = .false.
            go to 80
   70       continue
               kstep = 2
               swap = imax .ne. km1
   80       continue
   90    continue
         if (amax1(absakk,colmax) .ne. 0.0e0) go to 100
!
!           COLUMN K IS ZERO.  SET INFO AND ITERATE THE LOOP.
!
            kpvt(k) = k
            info = k
         go to 190
  100    continue
         if (kstep .eq. 2) go to 140
!
!           1 X 1 PIVOT BLOCK.
!
            if (.not.swap) go to 120
!
!              PERFORM AN INTERCHANGE.
!
               call sswap(imax,a(1,imax),1,a(1,k),1)
               do 110 jj = imax, k
                  j = k + imax - jj
                  t = a(j,k)
                  a(j,k) = a(imax,j)
                  a(imax,j) = t
  110          continue
  120       continue
!
!           PERFORM THE ELIMINATION.
!
            do 130 jj = 1, km1
               j = k - jj
               mulk = -a(j,k)/a(k,k)
               t = mulk
               call saxpy(j,t,a(1,k),1,a(1,j),1)
               a(j,k) = mulk
  130       continue
!
!           SET THE PIVOT ARRAY.
!
            kpvt(k) = k
            if (swap) kpvt(k) = imax
         go to 190
  140    continue
!
!           2 X 2 PIVOT BLOCK.
!
            if (.not.swap) go to 160
!
!              PERFORM AN INTERCHANGE.
!
               call sswap(imax,a(1,imax),1,a(1,k-1),1)
               do 150 jj = imax, km1
                  j = km1 + imax - jj
                  t = a(j,k-1)
                  a(j,k-1) = a(imax,j)
                  a(imax,j) = t
  150          continue
               t = a(k-1,k)
               a(k-1,k) = a(imax,k)
               a(imax,k) = t
  160       continue
!
!           PERFORM THE ELIMINATION.
!
            km2 = k - 2
            if (km2 .eq. 0) go to 180
               ak = a(k,k)/a(k-1,k)
               akm1 = a(k-1,k-1)/a(k-1,k)
               denom = 1.0e0 - ak*akm1
               do 170 jj = 1, km2
                  j = km1 - jj
                  bk = a(j,k)/a(k-1,k)
                  bkm1 = a(j,k-1)/a(k-1,k)
                  mulk = (akm1*bk - bkm1)/denom
                  mulkm1 = (ak*bkm1 - bk)/denom
                  t = mulk
                  call saxpy(j,t,a(1,k),1,a(1,j),1)
                  t = mulkm1
                  call saxpy(j,t,a(1,k-1),1,a(1,j),1)
                  a(j,k) = mulk
                  a(j,k-1) = mulkm1
  170          continue
  180       continue
!
!           SET THE PIVOT ARRAY.
!
            kpvt(k) = 1 - k
            if (swap) kpvt(k) = -imax
            kpvt(k-1) = kpvt(k)
  190    continue
         k = k - kstep
      go to 10
  200 continue
      return
      end
