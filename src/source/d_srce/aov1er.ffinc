!AOV1ER
      SUBROUTINE AOV1ER(Y, TAG, N, IGSTAT, NZTAGS, NG, LDSTAK, NMSUB,
     +   INDEX, ISAOV1, NALL0)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE DOES PRELIMINARY CHECKING FOR ERRORS IN THE INPUT
!     PARAMETERS OF THE ONEWAY FAMILY.
!
!     WRITTEN BY -
!        LINDA L. MITCHELL AND JANET R. DONALDSON
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IGSTAT,INDEX,ISAOV1,LDSTAK,N,NALL0,NG,NZTAGS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   TAG(*),Y(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT,J,LDSMIN,NV
      LOGICAL
     +   ERROR,HEAD
!
!  LOCAL ARRAYS
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   LIGSTA(8)*1,LLDS(8)*1,LN(8)*1,LNG(8)*1,LTAG(8)*1,
     +   LTWO(8)*1,LZERO(8)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,ERVGT,GENI,IPRINT,LDSCMP,SRTIRR,SRTRRI,
     +   STKCLR,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERROR
!        SET TRUE IF THE ERROR CHECKING ROUTINE FOUND ANY ERRORS
!     LOGICAL HEAD
!        INDICATES WHETHER HEADING NEEDS TO BE PRINTED
!        TRUE - YES, NEEDS TO BE PRINTED
!        FALSE - NO, HAS BEEN PRINTED
!     INTEGER I
!        *
!     INTEGER IERR
!        IF IERR .NE. 0, THEN ERRORS WHERE FOUND IN THE PARAMETERS
!     INTEGER IGSTAT
!        *
!     INTEGER INDEX
!        THE STARTING LOCATION IN THE STACH AREA OF THE INDEX FOR
!        THE SORTED TAGS.
!     INTEGER IPRT
!        THE OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISAOV1
!        AN INDICATOR VARIABLE USED FOR THE COMPUTATION OF WORK
!        SPACE.  IF ISAOV1 = 0, THE CALLING ROUTINE IS AOV1S.  IF
!        ISAOV1 = 1, THE CALLING ROUTINE IS AOV1.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER J
!        *
!     INTEGER LDSMIN
!        THE MINIMUM SIZE ALLOWED FOR THE STACK
!     INTEGER LDSTAK
!        SIZE OF STACK ALLOCATED IN THE USERS MAIN PROGRAM
!     CHARACTER*1 LIGSTA(8), LLDS(8), LN(8), LNG(8), LTAG(8),
!    *   LTWO(8), LZERO(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE VARIABLE(S) CHECKED
!        ERRORS
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NALL0
!        OUTPUT PARAMETER.  NUMBER OF STACK ALLOCATIONS AFTER
!        STACK IS INITIALIZED.
!     INTEGER NG
!        *
!     CHARACTER*1 NMSUB(6)
!        NAME OF THE CALLING SUBROUTINE
!     INTEGER NV
!        THE NUMBER OF VALUES LESS THAN OR EQUAL TO ZERO.
!     INTEGER NZTAGS
!        THE NUMBER OF POSITIVE NON-ZERO TAGS, TO BE DETERMINED BY
!        THIS ROUTINE
!     DOUBLE PRECISION TAG(N)
!        THE VECTOR OF TAGS.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR OF OBSERVATIONS.
!
      DATA  LIGSTA(1),LIGSTA(2),LIGSTA(3),LIGSTA(4),LIGSTA(5),LIGSTA(6),
     +      LIGSTA(7),LIGSTA(8)
     +     / 'I', 'G', 'S', 'T', 'A', 'T', ' ', ' '/
      DATA   LLDS(1),  LLDS(2),  LLDS(3),  LLDS(4),  LLDS(5),  LLDS(6),
     +       LLDS(7),  LLDS(8)
     +     / 'L', 'D', 'S', 'T', 'A', 'K', ' ', ' '/
      DATA     LN(1),    LN(2),    LN(3),    LN(4),    LN(5),    LN(6),
     +         LN(7),    LN(8)
     +     / 'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA    LNG(1),   LNG(2),   LNG(3),   LNG(4),   LNG(5),   LNG(6),
     +        LNG(7),   LNG(8)
     +     / 'N', 'G', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA   LTAG(1),  LTAG(2),  LTAG(3),  LTAG(4),  LTAG(5),  LTAG(6),
     +       LTAG(7),  LTAG(8)
     +     / 'T', 'A', 'G', ' ', ' ', ' ', ' ', ' '/
      DATA   LTWO(1),  LTWO(2),  LTWO(3),  LTWO(4),  LTWO(5),  LTWO(6),
     +       LTWO(7),  LTWO(8)
     +     / 'T', 'W', 'O', ' ', ' ', ' ', ' ', ' '/
      DATA  LZERO(1), LZERO(2), LZERO(3), LZERO(4), LZERO(5), LZERO(6),
     +      LZERO(7), LZERO(8)
     +     / 'Z', 'E', 'R', 'O', ' ', ' ', ' ', ' '/
!
!     COMMENCE BODY OF ROUTINE
!
      IERR = 0
      HEAD = .TRUE.
!
!     SET UP OUTPUT UNIT
      CALL IPRINT(IPRT)
!
!     BEGIN ERROR CHECKING.
!
!     NUMBER OF OBSERVATIONS LESS THAN 2
!
      CALL EISGE(NMSUB, LN, N, 2, 2, HEAD, ERROR, LTWO)
      IF (ERROR) GO TO 50
!
!     NUMBER OF NON-ZERO TAGS LESS THAN 2
!
      CALL ERVGT(NMSUB, LTAG, TAG, N, 0.0D0, (N-2), HEAD, 7, NV, ERROR,
     +   LZERO)
      IF (ERROR) GO TO 50
!
      NZTAGS = N - NV
!
!     STACK MUST BE LARGE ENOUGH FOR A VECTOR OF LENGTH N TO CONTINUE
!
      CALL LDSCMP(1, 0, N, 0, 0, 0, 'D', 0, LDSMIN)
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR, LLDS)
      IF (ERROR) WRITE(IPRT, 1000)
      IF (ERROR) GO TO 50
!
!     INITIALIZE STACK AND NALL0
!
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
!
      INDEX = STKGET(N,2)
!
!     SORT TAG VECTOR CARRYING ALONG INDEX TO ORIGINAL ORDER AND THE
!     VECTOR OF OBSERVATIONS
!
      CALL GENI(ISTAK(INDEX), N, 1, 1)
      CALL SRTIRR(ISTAK(INDEX), Y, N, TAG)
!
!     COUNT THE NUMBER OF DIFFERENT TAG VALUES
!
      J = N - NZTAGS + 2
      NG = 1
      DO 10 I=J,N
         IF (TAG(I).GT.TAG(I-1)) NG = NG + 1
   10 CONTINUE
!
!     LESS THAN 2 DIFFERENT TAG GROUPS
!
      CALL EISII(NMSUB, LNG, NG, 2, NZTAGS-1, 3, HEAD, ERROR,
     +  LTWO, LN)
      IF (ERROR) GO TO 40
!
!     CHECK THAT DIMENSION OF STATISTICS MATRIX IS SUFFICIENT
!
      CALL EISGE(NMSUB, LIGSTA, IGSTAT, NG, 3, HEAD, ERROR, LNG)
      IF (ERROR) GO TO 40
!
!     COMPUTE AND CHECK FOR SUFFICIENT STACK
!
      CALL LDSCMP(11, 0, N+NZTAGS, 0, 0, 0,
     +            'D', ISAOV1*4*NG+4*NG+NZTAGS, LDSMIN)
!
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR, LLDS)
      IF (.NOT.ERROR) RETURN
!
   40 CONTINUE
!
!     REORDER DATA
!
      CALL SRTRRI(TAG, Y, N, ISTAK(INDEX))
!
!     CLEAR STACK, IN CASE WHERE ERROR FOLLOWS ALLOCATION OF STACK.
!
      CALL STKCLR (NALL0)
!
   50 CONTINUE
      IERR = 1
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/' NOTE.  THE VALUE OF LDSTAK MENTIONED ABOVE IS THE',
     +  ' MINIMUM NECESSARY'/
     +  ' TO CONTINUE CHECKING FOR ERRORS AND',
     +  ' TO CALCULATE THE CORRECT VALUE'/
     +  ' OF LDSTAK.  THE CORRECT',
     +  ' VALUE WILL BE LARGER.  CONSULT THE DOCUMENTATION'/
     +  ' FOR THE FORMULAS USED TO CALCULATE LDSTAK.')
      END
