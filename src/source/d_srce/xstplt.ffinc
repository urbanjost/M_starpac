!XSTPLT
      subroutine xstplt(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      real(kind=wp) :: dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,exmpt
     integer&
     &   i,iprt,ixm,ldsmin,m,n,neta,npar,nprt,ntest
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   exmtst(5),par(10),scale(10),stp(10),xm(200,2)
     integer&
     &   nettst(6)
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   D1MACH
!      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LDSCMP,LSTVEC,MDL4,STPLS1,STPLS2,STPLSC
!
!  INTRINSIC FUNCTIONS
      intrinsic log10
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL(KIND=WP) :: DELTA
!        *
!     REAL(KIND=WP) :: DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL(KIND=WP) :: EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     REAL(KIND=WP) :: EXMTST(5)
!        VARIOUS TEST VALUES FOR EXMPT.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL4
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NETTST(6)
!        VARIOUS TEST VALUES FOR NETA.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     REAL(KIND=WP) :: PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL(KIND=WP) :: SCALE(10)
!        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL(KIND=WP) :: STP(10)
!        THE SELECTED STEP SIZES FOR EACH PARAMETER.
!     REAL(KIND=WP) :: XM(200,2)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      call iprint(iprt)
!
!     SET PARAMETER VALUES
!
      call stpls1(n, m, ixm, par, npar, neta, exmpt, scale, nprt)
      call stpls2(npar, stp)
      call ldscmp(14, 0, 2*(n+npar), 0, 0, 0, 'D', 10*n, ldsmin)
!
      if (ldsmin.le.ldstak) go to 5
!
      write (iprt, 1000) ldsmin
      return
!
    5 continue
!
!     CREATE INDEPENDENT VARIABLE
!
      delta = 0.0625_wp
      xm(1,1) = 0.0_wp
      do 10 i=2,n
         xm(i,1) = xm(i-1,1) + delta
   10 continue
!
      ntest = 0
!
!
!     TEST VARIOUS VALUES OF EXMPT
!
      call stpls1(n, m, ixm, par, npar, neta, exmpt, scale, nprt)
      exmtst(1) = -1.0_wp
      exmtst(2) = 0.0001_wp
      exmtst(3) = 0.5_wp
      exmtst(4) = 1.0_wp
      exmtst(5) = 1.1_wp
!
      do 20 i=1,5
!
         ntest = ntest + 1
         write (iprt,1090) ntest
         write (iprt,1040)
         write (iprt,1060) neta, exmtst(i), scale(1), nprt
         write (iprt,1010)
         call stpls2(npar, stp)
        call stplsc(xm, n, m, ixm, mdl4, par, npar, ldstak, stp, neta,&
     &      exmtst(i), scale, nprt)
         write (iprt,1100) neta, exmtst(i), scale(1), nprt
         write (iprt,1050) ierr
         write (iprt,1080)
         call lstvec(4, stp)
!
   20 continue
!
!     TEST VARIOUS VALUES OF NETA
!
      nettst(1) = -1
      nettst(2) = 0
      nettst(3) = 1
      nettst(4) = 2
!
      nettst(5) = -log10(d1mach(4))
      nettst(6) = nettst(5) + 1
!
      scale(1) = 0.0_wp
!
      do 30 i=1,6
!
         ntest = ntest + 1
         write (iprt,1090) ntest
         write (iprt,1040)
         write (iprt,1060) nettst(i), exmpt, scale(1), nprt
         write (iprt,1010)
         call stpls2(npar, stp)
        call stplsc(xm, n, m, ixm, mdl4, par, npar, ldstak, stp,&
     &      nettst(i), exmpt, scale, nprt)
         write (iprt,1100) nettst(i), exmpt, scale(1), nprt
         write (iprt,1050) ierr
         write (iprt,1080)
         call lstvec(4, stp)
!
   30 continue
!
!     SUPPRESS OUTPUT
!
      call stpls1(n, m, ixm, par, npar, neta, exmpt, scale, nprt)
      nprt = 0
!
      ntest = ntest + 1
      write (iprt,1090) ntest
      write (iprt,1040)
      write (iprt,1060) neta, exmpt, scale(1), nprt
      write (iprt,1010)
      call stpls2(npar, stp)
     call stplsc(xm, n, m, ixm, mdl4, par, npar, ldstak, stp, neta,&
     &   exmpt, scale, nprt)
      write (iprt,1100) neta, exmpt, scale(1), nprt
      write (iprt,1050) ierr
      write (iprt,1080)
      call lstvec(4, stp)
!
!     LARGE CALCULATION ERROR PROBLEM
!
      call stpls1(n, m, ixm, par, npar, neta, exmpt, scale, nprt)
      par(3) = 10.0_wp**((nettst(5)-1)/2)
      scale(1) = -1.0_wp
!
      ntest = ntest + 1
      write (iprt,1090) ntest
      write (iprt,1070)
      write (iprt,1060) neta, exmpt, scale(1), nprt
      write (iprt,1010)
      call stpls2(npar, stp)
     call stplsc(xm, n, m, ixm, mdl4, par, npar, ldstak, stp, neta,&
     &   exmpt, scale, nprt)
      write (iprt,1100) neta, exmpt, scale(1), nprt
      write (iprt,1050) ierr
      write (iprt,1080)
      call lstvec(4, stp)
!
      exmpt = 0.11_wp
      nprt = 0
!
      ntest = ntest + 1
      write (iprt,1090) ntest
      write (iprt,1070)
      write (iprt,1060) neta, exmpt, scale(1), nprt
      write (iprt,1010)
      call stpls2(npar, stp)
     call stplsc(xm, n, m, ixm, mdl4, par, npar, ldstak, stp, neta,&
     &   exmpt, scale, nprt)
      write (iprt,1100) neta, exmpt, scale(1), nprt
      write (iprt,1050) ierr
      write (iprt,1080)
      call lstvec(4, stp)
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (45h1 *** ldstak must be greater than or equal to , i6)
 1010 format (15h test of stplsc)
 1040 format (15h simple example)
1050 format (/29h ***** returned results *****, 5x, 15h (-1 indicates ,&
     &   39hvalue not changed by called subroutine)//9h ierr is , i3)
1060 format (19h input   -  neta = , i5, 10h, exmpt = , g15.8,&
     &   13h, scale(1) = , g15.8, 9h, nprt = , i5)
 1070 format (32h large calculation error problem)
 1080 format (//23h returned values of stp)
1090 format (54h1derivative step size selection subroutine test number,&
     &   i5)
1100 format (//19h output  -  neta = , i5, 10h, exmpt = , g15.8,&
     &   13h, scale(1) = , g15.8, 9h, nprt = , i5//)
      end
