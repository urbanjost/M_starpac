*CCFER
      SUBROUTINE CCFER(NMSUB, N, LAGMAX, LDSTAK, LDSMIN, ICCOV, JCCOV,
     +  INLPPC, JNLPPC, M, LYFFT, NFFT, IYM, IYMFFT, ISFFT, ISLONG)
C
C     LATEST REVISION  -  03/15/90  (JRD)
C
C     THIS IS THE ERROR CHECKING ROUTINE FOR THE CCF FAMILY
C
C     WRITTEN BY - JANET R. DONALDSON
C                  STATISTICAL ENGINEERING DIVISION
C                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
C
C     CREATION DATE  -  DECEMBER 2, 1985
C
C
C  VARIABLE DECLARATIONS
C
C  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,INLPPC,IYM,IYMFFT,JCCOV,JNLPPC,LAGMAX,LDSMIN,LDSTAK,
     +   LYFFT,M,N,NFFT
      LOGICAL
     +   ISFFT,ISLONG
C
C  ARRAY ARGUMENTS
      CHARACTER
     +   NMSUB(6)*1
C
C  SCALARS IN COMMON
      INTEGER
     +   IERR
C
C  LOCAL SCALARS
      INTEGER
     +   I
      LOGICAL
     +   HEAD
C
C  LOCAL ARRAYS
      LOGICAL
     +   ERR(15)
      CHARACTER
     +   LICCOV(8)*1,LINLPP(8)*1,LIYM(8)*1,LIYMFF(8)*1,
     +   LJCCOV(8)*1,LJNLPP(8)*1,LLAGMX(8)*1,LLDS(8)*1,
     +   LLGMX1(8)*1,LLYFFT(8)*1,LM(8)*1,LN(8)*1,LNFFT(8)*1,
     +   LNM1(8)*1,LONE(8)*1,LTHREE(8)*1
C
C  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII
C
C  COMMON BLOCKS
      COMMON /ERRCHK/IERR
C
C     VARIABLE DEFINITIONS (ALPHABETICALLY)
C
C     LOGICAL ERR(15)
C        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
C        (FALSE).
C     LOGICAL HEAD
C        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
C        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
C        OF HEAD WILL BE CHANGED TO FALSE.
C     INTEGER I
C        AN INDEX VARIABLE.
C     INTEGER ICCOV
C        THE FIRST DIMENSION OF THE ARRAY CCOV.
C     INTEGER IERR
C        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
C        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
C        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
C     INTEGER INLPPC
C        THE FIRST DIMENSION OF THE ARRAY NLPPC.
C     LOGICAL ISFFT
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
C     LOGICAL ISLONG
C        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
C        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
C     INTEGER IYM, IYMFFT
C        THE FIRST DIMENSION OF THE ARRAYS YM AND YMFFT, RESPECTIVELY.
C     INTEGER JCCOV, JNLPPC
C        THE SECOND DIMENSIONS OF THE ARRAYS CCOV AND NLPPC,
C        RESPECTIVELY.
C     INTEGER LAGMAX
C        THE MAXIMUM LAG VALUE REQUESTED.
C     INTEGER LDSMIN
C        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
C     INTEGER LDSTAK
C        THE LENGTH OF THE ARRAY DSTAK.
C     CHARACTER*1 LICCOV(8), LINLPP(8), LIYM(8), LIYMFF(8), LJCCOV(8),
C    *  LJNLPP(8), LLAGMX(8), LLDS(8), LLGMX1(8), LLYFFT(8),
C    *  LM(8), LN(8), LNFFT(8), LNM1(8), LONE(8), LTHREE(8)
C        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
C        CHECKED FOR ERRORS.
C     INTEGER M
C        THE NUMBER OF SERIES BEING ANALYZED
C     INTEGER N
C        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
C     INTEGER NFFT
C        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
C     CHARACTER*1 NMSUB(6)
C        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
C        SUBROUTINE.
C
C     SET UP NAME ARRAYS
C
      DATA
     + LICCOV(1), LICCOV(2), LICCOV(3), LICCOV(4), LICCOV(5),
     + LICCOV(6), LICCOV(7), LICCOV(8) /'I','C','C','O','V',' ',' ',' '/
      DATA
     + LINLPP(1), LINLPP(2), LINLPP(3), LINLPP(4), LINLPP(5),
     + LINLPP(6), LINLPP(7), LINLPP(8) /'I','N','L','P','P','C',' ',' '/
      DATA
     + LIYM(1), LIYM(2), LIYM(3), LIYM(4), LIYM(5),
     + LIYM(6), LIYM(7), LIYM(8) /'I','Y','M',' ',' ',' ',' ',' '/
      DATA
     + LIYMFF(1), LIYMFF(2), LIYMFF(3), LIYMFF(4), LIYMFF(5),
     + LIYMFF(6), LIYMFF(7), LIYMFF(8) /'I','Y','M','F','F','T',' ',' '/
      DATA
     + LJCCOV(1), LJCCOV(2), LJCCOV(3), LJCCOV(4), LJCCOV(5),
     + LJCCOV(6), LJCCOV(7), LJCCOV(8) /'J','C','C','O','V',' ',' ',' '/
      DATA
     + LJNLPP(1), LJNLPP(2), LJNLPP(3), LJNLPP(4), LJNLPP(5),
     + LJNLPP(6), LJNLPP(7), LJNLPP(8) /'J','N','L','P','P','C',' ',' '/
      DATA
     + LLAGMX(1), LLAGMX(2), LLAGMX(3), LLAGMX(4), LLAGMX(5),
     + LLAGMX(6), LLAGMX(7), LLAGMX(8) /'L','A','G','M','A','X',' ',' '/
      DATA
     + LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     + LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA
     + LLGMX1(1), LLGMX1(2), LLGMX1(3), LLGMX1(4), LLGMX1(5),
     + LLGMX1(6), LLGMX1(7), LLGMX1(8) /'L','A','G','M','A','X','+','1'/
      DATA
     + LLYFFT(1), LLYFFT(2), LLYFFT(3), LLYFFT(4), LLYFFT(5),
     + LLYFFT(6), LLYFFT(7), LLYFFT(8) /'L','Y','F','F','T',' ',' ',' '/
      DATA
     + LM(1), LM(2), LM(3), LM(4), LM(5),
     + LM(6), LM(7), LM(8) /'M',' ',' ',' ',' ',' ',' ',' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5),
     + LN(6), LN(7), LN(8) /'N',' ',' ',' ',' ',' ',' ',' '/
      DATA
     + LNM1(1), LNM1(2), LNM1(3), LNM1(4), LNM1(5),
     + LNM1(6), LNM1(7), LNM1(8) /'(','N','-','1',')',' ',' ',' '/
      DATA
     + LNFFT(1), LNFFT(2), LNFFT(3), LNFFT(4), LNFFT(5),
     + LNFFT(6), LNFFT(7), LNFFT(8) /'N','F','F','T',' ',' ',' ',' '/
      DATA
     + LONE(1), LONE(2), LONE(3), LONE(4), LONE(5),
     + LONE(6), LONE(7), LONE(8) /'O','N','E',' ',' ',' ',' ',' '/
      DATA
     + LTHREE(1), LTHREE(2), LTHREE(3), LTHREE(4), LTHREE(5),
     + LTHREE(6), LTHREE(7), LTHREE(8) /'T','H','R','E','E',' ',' ',' '/
C
C     SET UP FOR ERROR CHECKING
C
      IERR = 0
      HEAD = .TRUE.
      DO 10 I = 1, 15
        ERR(I) = .FALSE.
   10 CONTINUE
C
C     CALL ERROR CHECKING ROUTINES
C
      CALL EISGE(NMSUB, LN, N, 3, 2, HEAD, ERR(1), LTHREE)
C
      CALL EISGE(NMSUB, LM, M, 1, 2, HEAD, ERR(2), LONE)
C
      IF (.NOT.ERR(1)) THEN
C
        CALL EISII(NMSUB, LLAGMX, LAGMAX, 1, N-1, 1, HEAD, ERR(3), LONE,
     +    LNM1)
C
        IF (ISFFT) THEN
          IF (ISLONG) THEN
            CALL EISGE(NMSUB, LIYMFF, IYMFFT, NFFT, 3, HEAD, ERR(4),
     +        LNFFT)
          ELSE
            CALL EISGE(NMSUB, LLYFFT, LYFFT, NFFT, 3, HEAD, ERR(4),
     +        LNFFT)
          END IF
        ELSE
          CALL EISGE(NMSUB, LIYM, IYM, N, 3, HEAD, ERR(4), LN)
        END IF
C
        IF (.NOT.ERR(3)) THEN
C
          IF (ISLONG) THEN
            CALL EISGE(NMSUB, LICCOV, ICCOV, LAGMAX+1, 3, HEAD, ERR(5),
     +        LLGMX1)
            CALL EISGE(NMSUB, LJCCOV, JCCOV, M, 3, HEAD, ERR(6),
     +        LLGMX1)
            CALL EISGE(NMSUB, LINLPP, INLPPC, LAGMAX+1, 3, HEAD, ERR(7),
     +        LLGMX1)
            CALL EISGE(NMSUB, LJNLPP, JNLPPC, M, 3, HEAD, ERR(8),
     +        LLGMX1)
          END IF
C
          CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR(9), LLDS)
C
        END IF
      END IF
C
      DO 20 I = 1, 15
        IF (ERR(I)) IERR = 1
   20 CONTINUE
C
      RETURN
C
      END
