      module M_starpac_d
      implicit none
      private
      integer,parameter :: wp=kind(0.0d0)

      private ::  mach
      private ::  randu
      private ::  correr

      public  ::  nl2itr,  qapply,  livmul,  lsqrt,   linvrt
      public  ::  vscopy,  lmstep,  qrfact,  nl2sno
      public  ::  madr,    v2norm,  itsmry,  dotprd,  vcopy
      public  ::  parchk,  assess,  nl2x,    covclc
      public  ::  rmdcon,  lsvmin,  madj,    vaxpy,   rptmul,  slvmul
      public  ::  ltsqar,  litvmu,  gqtstp,  dupdat
      public  ::  dfault,  reldst,  slupdt,  nl2sol

      public  ::  amecnt,  gfsest,  vpm,     mdl1,    stpamo,  nlinit
      public  ::  amfmn,   acffs,   uasdv,   pgms,    llcntp
      public  ::  ufsout,  setrv,   nlout,   matprf
      public  ::  sumwts,  cdff,    lpcoef,  stpsel,  aoslst,  xxch9
      public  ::  arcoef,  llsps,   gfout,   vpcnt,   acfm
      public  ::  mppml,   xlls,    vpmc,    demord,  polar,   xvp
      public  ::  cdfnml,  aov1mn,  dckout,  stpcnt
      public  ::  gfarf,   uaser,   drv3,    bfsv,    mvpm,    nlsupk
      public  ::  fltar,   nlsc,    chirho,  xaimt,   ufsmv,   nrand
      public  ::  ersgt,   amean,   xstplt,  bfsdrv,  vpc,     lstvcf
      public  ::  ccf,     xpp,     nlswdc,  spcck,   ipgms,   acvff
      public  ::  uasfs,   acvf,    nlism,   nlsw,    pp
      public  ::  fftr,    bfsmvs,  xxch10,  dckdrv,  drv4a,   drv4b
      public  ::  ccvf,    pplmt,   sumts,   stat,    dotcm
      public  ::  mvpc,    acflst,  pgm,     histc,   xxch3,   dcoef
      public  ::  ppm,     sumds,   corrmn,  xxch13
      public  ::  xdcklt,  ppmn,    setra,   mpp,     center
      public  ::  ppl,     gfarfs,  svpl,    cpymss,  fitext
      public  ::  nlfin,   dckfpa,  uasest,  dif,     demods
      public  ::  pgmmn,   sppm,    pltchk,  bfsvs,   amestp,  nlswd
      public  ::  demout,  amdrv,   ranko,   ufsmvs,  bfs,     mppl
      public  ::  taper,   amlst1,  erslf,   acfmnf,  aimf,    realtr
      public  ::  amedrv,  getpi,   fitxsp,  sumwss,  ervgt
      public  ::  aov1xp,  ccfxp,   gfaest,  xuas,    mvpl
      public  ::  ersge,   xaov1,   mdl4,    slflt
      public  ::  cdft,    acvfm,   xccf,    statws,  nlsd,    fltma
      public  ::  ccfmnf,  lpflt,   dcklsc,  hstmn,   ufsms
      public  ::  ppfchs,  oanova,  ppff,    aimx1,   stat2w,  xdflt
      public  ::  amfcnt,  mppm,    ervgtm,  ppfnml,  ameism,  arflt
      public  ::  multbp,  vcvotf,  ppmc,    bfsfs,   lopass
      public  ::  stpdrv,  xacf,    ccfout,  amefin
      public  ::  gfslf,   sppltd,  mvpml,   setfrq,  ccfmn
      public  ::  ipgdv,   dckmn,   acfms,   amept2
      public  ::  amlst,   xstat
      public  ::  spp,     nlitrp,  adjlmt,  xxch7,   ller,    mvp
      public  ::  stat2,   ipgm,    repck,   mdflt,   llsp
      public  ::  xxch8,   sumid,   ufsest,  erslfs,  uas,     uasout
      public  ::  mgs,     ufsdrv,  acf,     xdemod,  ufs,     xnlsd
      public  ::  bfsf,    loglmt,  uascft,  amemn
      public  ::  drv2,    llspws,  lls,     llsws
      public  ::  ipgmp,   xstpld,  extend,  uass,    uasvar
      public  ::  sppml,   ccfs,    aime,    uasvs,   acfmn,   ervii
      public  ::  fltarm,  relcom,  ccffs,   ccvff,   xbfs
      public  ::  obssm2,  amfout,  cmpfd,   xxch2,   xxch1
      public  ::  ipgmps,  nrandc,  acfsdm,  stpout
      public  ::  bfss,    fft,     dcker,   obssum,  ufsf,    xstple
      public  ::  srtrri,  nlcmp,   stater,  ccvfm,   mppmc
      public  ::  nlmn,    vpml,    ppcnt,   fltsl,   sumwds,  bfsmn
      public  ::  bfsms,   srtirr,  xnrand,  uasf,    eragt
      public  ::  llss,    svpc,    stats,   ppml,    xufs,    nlcnt
      public  ::  amept1,  fitpt1,  difm,    stper,   nlsdc
      public  ::  xnlst,   ameanm,  etamdl,  nls,     nlcntn,  mdlts3
      public  ::  bfsm,    ufss,    ccfsdm,  xpgm
      public  ::  difmc,   gmean,   matprt,  accdig,  svpm
      public  ::  ccfsd,   aimec,   llsw,    stpls2
      public  ::  nlss,    corrs,   randn,   hist,    pgmest,  ccflst
      public  ::  mdlts2,  corrxp,  mppc,    acfmnm,  xxch11,  demdrv
      public  ::  difc,    nlspk,   acff,    ersii,   stat1
      public  ::  mdlts1,  acfd,    dckcnt,  aov1s,   ccff
      public  ::  pgord,   pgout,   xdckle,  drv,     aos
      public  ::  ppc,     svp,     dckls,   acfs,    nlsds,   difser
      public  ::  dckcrv,  hipass,  ipgord,  mvpmc,   sppltl
      public  ::  vcvout,  xnlse,   lstvec,  acfout,  sppmc,   xaimd
      public  ::  ufsv,    nlswds,  ccfmnm,  svpmc,   nldrvn,  vpmn
      public  ::  mdl2,    xxch12,  aimes,   stat1w,  statw,   dckzro
      public  ::  axpby,   uasv,    vphead,  stplsc,  sppc,    sumidw
      public  ::  ufsmn,   drv1a,   sumss,   nlswc,   llcnt
      public  ::  dotc,    xxch5,   ameout,  mdl3,    hster,   fltmd
      public  ::  genr,    srtir,   nlsws,   ufspcv,  ppft,    ccfms
      public  ::  hpflt,   cdfchi,  ufsm,    ipgmn,   drv1b
      public  ::  abscom,  aov1er,  sumot,   demod,   aov1,    nlsx1
      public  ::  ervwt,   dfbw,    cpyasf,  srtri,   dckls1,  llspw
      public  ::  parzen,  sumbs,   fftct
      public  ::  xcorr,   demodu,  aimfs,   maflt,   nler
      public  ::  gfslfs,  stpadj,  xhist,   ccfm,    vplmt,   ameer
      public  ::  nldrva,  smply,   llcntg,  sppltc,  pltplx
      public  ::  corr,    vp,      fitsxp,  ufslag,  llsmn
      public  ::  hpcoef,  xxch4,   eragtm,  sppl,    acfsd
      public  ::  ufsvs,   cntr,    gford,   fitpt2,  svpml,   mvchk
      public  ::  stpls1,  stpmn,   sample,  ervgtp,  stpls,   ipgout
      public  ::  ersei,   xdckld,  setrow,  bfsmv,   nlsx2,   nlcnta
      public  ::  xxch6,   ufsfs,   uasord,  ersie
      public  ::  dfbwm,   vpl,     bfslag,  eragtp

      contains
      function mach(i)
!*****************************************************************************80
! CAN REPLACE THIS WITH AN ARRAY OF CONSTANTS OR DIRECT CALLS
!*****************************************************************************80
!
!! MACH returns double precision real machine constants.
!
!  Discussion:
!
!    Assuming that the internal representation of a double precision real
!    number is in base B, with T the number of base-B digits in the mantissa,
!    and EMIN the smallest possible exponent and EMAX the largest possible
!    exponent, then
!
!      MACH(1) = B**(EMIN-1), the smallest positive magnitude.
!      MACH(2) = B**EMAX*(1-B**(-T)), the largest magnitude.
!      MACH(3) = B**(-T), the smallest relative spacing.
!      MACH(4) = B**(1-T), the largest relative spacing.
!      MACH(5) = log10(B).
!
!  Modified:
!
!    24 April 2007
!    14 May   2022
!
!  Author:
!
!    Phyllis Fox, Andrew Hall, Norman Schryer
!    John S. Urban
!
!  Reference:
!
!    Phyllis Fox, Andrew Hall, Norman Schryer,
!    Algorithm 528:
!    Framework for a Portable Library,
!    ACM Transactions on Mathematical Software,
!    Volume 4, Number 2, June 1978, page 176-188.
!
!  Parameters:
!
!    Input, integer I, chooses the parameter to be returned.
!    1 <= I <= 5.
!
!    Output, real ( kind = wp ) MACH, the value of the chosen parameter.
!
!===============================================================================
! intrinsics
! exponent     -  Exponent function
! fraction     -  Fractional part of the model representation
! nearest      -  Nearest representable number
! rrspacing    -  Reciprocal of the relative spacing
! scale        -  Scale a real value
! set_exponent -  Set the exponent of the model
!
! spacing      -  Smallest distance between two numbers of a given type
! digits       -  Significant digits function
! epsilon      -  Epsilon function
! maxexponent  -  Maximum exponent of a real kind
! minexponent  -  Minimum exponent of a real kind
! precision    -  Decimal precision of a real kind
! radix        -  Base of a model number
! range        -  Decimal exponent range of a real kind
! tiny         -  Smallest positive number of a real kind
! huge         -  Largest number of a kind
!====================================================================================================================================
      implicit none
      integer,parameter       :: b = radix(0.0_wp)
      integer,parameter       :: t = digits (0.0_wp )
      real(kind=wp),parameter :: emin=minexponent(0.0_wp)
      real(kind=wp),parameter :: emax=maxexponent(0.0_wp)
      real ( kind = wp ) mach
      integer i

      select case(i)
      case(1); mach = tiny(0.0_wp)               ! B**(EMIN-1), the smallest positive magnitude.
      case(2); mach = huge(0.0_wp)               ! B**EMAX*(1-B**(-T)), the largest magnitude.
                                                 ! calculating this by formula could cause overflow without using a larger type
      case(3); mach = real(b,kind=wp)**(-t)      ! B**(-T), the smallest relative spacing.
      case(4); mach = epsilon(0.0_wp)            ! B**(1-T), the largest relative spacing.
      case(5); mach = log10(real(b,kind=wp))     ! log10(B).
      case default
         write ( *, '(a)' ) ' '
         write ( *, '(a)' ) 'MACH - Fatal error!'
         write ( *, '(a)' ) '  The input argument I is out of bounds.'
         write ( *, '(a)' ) '  Legal values satisfy 1 <= I <= 5.'
         write ( *, '(a,i12)' ) '  I = ', i
         mach = 0.0d+00
         stop
      end select

      end function mach

!AMECNT
      SUBROUTINE AMECNT(Y, WT, LWT, XM, N, M, IXM, MDL, NLDRV, APRXDV,
     +   DRV, PAR, NPAR, RES, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS,
     +   STOPP, SCALE, LSCALE, DELTA, IVAPRX, RSD, PV, LPV, SDPV,
     +   LSDPV, SDRES, LSDRES, VCV, IVCV, WEIGHT, SAVE, NNZW, NPARE,
     +   NLHDR, PAGE, WIDE, IPTOUT, NDIGIT, HLFRPT, NRESTS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION :: DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IVAPRX,IVCV,IXM,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,LWT,M,
     +   MIT,N,NDIGIT,NNZW,NPAR,NPARE,NRESTS
      LOGICAL :: APRXDV,HLFRPT,PAGE,SAVE,WEIGHT,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),STP(*),
     +   VCV(IVCV,*),WT(*),XM(IXM,*),Y(*)
      INTEGER :: IFIXED(*),IPTOUT(5)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL,NLDRV,NLHDR
!
!  SCALARS IN COMMON
      INTEGER :: IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   D,IFIXD,IFP,IIWORK,IRWORK,IWORK,LVCVL,NALL0,PARE,PVI,
     +   RESTS,RWORK,SDPVI,SDRESI,VCVL
!
!  LOCAL ARRAYS
      DOUBLE PRECISION :: RSTAK(12)
      INTEGER :: ISTAK(12)
!
!  EXTERNAL FUNCTIONS
      INTEGER,EXTERNAL :: STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMEMN,CPYASF,CPYVII,DCOPY,SETIV,STKCLR
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     INTEGER D
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE ARRAY IN WHICH THE NUMERICAL DERIVATIVES WITH RESPECT TO
!        EACH PARAMETER ARE STORED.
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD
!        THE STARTING LOCATION IN ISTAK OF
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF IFIXED(I).EQ
!        THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IIWORK
!        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
!     INTEGER IPTOUT(5)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER IRWORK
!        THE DIMENSION OF THE DOUBLE PRECISION WORK VECTOR RWORK.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IWORK
!        THE STARTING LOCATION IN ISTAK OF
!        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LVCVL
!        THE LENGTH OF THE VECTOR CONTAINING
!        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        NUMBER OF ALLOCATIONS ON ENTRY.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     EXTERNAL NLDRV
!        THE NAME OF THE ROUTINE WHICH CALCULATES THE DERIVATIVES.
!     EXTERNAL NLHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARE
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE CURRENT ESTIMATES OF THE PARAMETERS, BUT ONLY
!        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
!     DOUBLE PRECISION PV(LPV)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     INTEGER PVI
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE PREDICTED VALUES.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     INTEGER RESTS
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE RESIDUALS FROM THE ARIMA MODEL.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER RWORK
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE DOUBLE PRECISION WORK VECTOR USED BY THE NL2 SUBROUTINES.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(LSCALE)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(LSDPV)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     INTEGER SDPVI
!        THE STARTING LOCATION IN RWORK OF
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(LSDRES)
!        THE STANDARDIZED RESIDUALS.
!     INTEGER SDRESI
!        THE STARTING LOCATION IN RWORK OF THE
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(LSTP)
!        THE STEP SIZE ARRAY.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE VARIANCE-COVARIANCE MATRIX.
!     INTEGER VCVL
!        THE STARTING LOCATION IN RWORK OF
!        THE VARIANCE-COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET VARIOUS PROGRAM VALUES
!
      NALL0 = STKST(1)
!
      IFP = 4
!
      IERR = 0
!
!     SUBDIVIDE WORK AREA FOR LEAST SQUARES ANALYSIS
!
      IIWORK = NPARE + 60
      IRWORK = 94 + 2*NRESTS + NPARE*(3*NPARE+33)/2
!
      IFIXD = STKGET(NPAR,2)
      IWORK = STKGET(IIWORK,2)
!
      D = STKGET(NRESTS*NPAR,IFP)
      PARE = STKGET(NPARE,IFP)
      RESTS = STKGET(NRESTS,IFP)
      PVI = RESTS
      RWORK = STKGET(IRWORK,IFP)
!
      IF (IERR.EQ.1) RETURN
!
!     SET VALUES FOR IFIXD
!
      IF (IFIXED(1).GE.0) CALL CPYVII(NPAR, IFIXED, 1, ISTAK(IFIXD), 1)
      IF (IFIXED(1).LT.0) CALL SETIV(ISTAK(IFIXD), NPAR, 0)
!
      CALL AMEMN(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, NRESTS,
     +   APRXDV, ISTAK(IFIXD), PAR, RSTAK(PARE), NPAR, RES, PAGE,
     +   WIDE, HLFRPT, STP, LSTP, MIT, STOPSS, STOPP, SCALE, LSCALE,
     +   DELTA, IVAPRX, IPTOUT, NDIGIT, RSD, RSTAK(RESTS), SDPVI,
     +   SDRESI, VCVL, LVCVL, RSTAK(D), ISTAK(IWORK), IIWORK,
     +   RSTAK(RWORK), IRWORK, NLHDR, NPARE, RSTAK(PVI))
!
      IF (.NOT.SAVE) GO TO 10
!
      SDPVI = RWORK + SDPVI - 1
      SDRESI = RWORK + SDRESI - 1
      VCVL = RWORK + VCVL - 1
!
      CALL DCOPY(N, RSTAK(PVI), 1, PV, 1)
      CALL DCOPY(N, RSTAK(SDPVI), 1, SDPV, 1)
      CALL DCOPY(N, RSTAK(SDRESI), 1, SDRES, 1)
      CALL CPYASF(NPARE, RSTAK(VCVL), LVCVL, VCV, IVCV)
!
   10 CALL STKCLR(NALL0)
!
      RETURN
!
      END
!GFSEST
      SUBROUTINE GFSEST (H, K, NF, FREQ, GAIN, DELTA)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE GAIN FUNCTION OF AN INPUT SYMMETRIC
!     LINEAR FILTER AT THE FREQUENCIES SPECIFIED IN FREQ USING THE
!     TRANSFORM ALGORITHM SHOWN ON PAGE 311 OF JENKINS AND WATTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA
      INTEGER
     +   K,NF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),GAIN(NF),H(K)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   C,PI,V0,V1,V2
      INTEGER
     +   I,J,KHALF,KMID
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,COS
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION C
!        A VALUE USED TO COMPUTE THE GAIN FUNCTION.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL OF THE ORIGINAL SERIES.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO BE
!        ESTIMATED.
!     DOUBLE PRECISION GAIN(NF)
!        THE ARRAY IN WHICH THE GAIN FUNCTION ESTIMATES ARE RETURNED.
!     DOUBLE PRECISION H(K)
!        THE SYMMETRIC LINEAR FILTER WEIGHTS.
!     INTEGER I, J
!        INDEX VARIABLES.
!     INTEGER K
!        THE NUMBER OF TERMS IN THE SYMMETRIC LINEAR FILTER.
!     INTEGER KHALF, KMID
!        HALF THE FILTER LENGTH, AND THE MIDPOINT OF THE FILTER,
!        RESPECTIVELY.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE GAIN FUNCTION ESTIMATES
!        ARE TO BE ESTIMATED.
!     DOUBLE PRECISION PI
!        THE VALUE OF PI.
!     DOUBLE PRECISION V0, V1, V2
!        CONSTANTS USED FOR COMPUTING THE GAIN FUNCTION ESTIMATES.
!
      CALL GETPI(PI)
!
!        COMPUTE GAIN FUNCTION ESTIMATES AND THEIR CONFIDENCE LIMITS.
!
      KMID = (K+1) / 2
      KHALF = KMID - 1
!
      DO 30 I = 1, NF
         C = COS(2.0D0 * PI * FREQ(I))
         V0 = 0.0D0
         V1 = 0.0D0
         DO 20 J = 1, KHALF
            V2 = 2.0D0 * C * V1 - V0 + H(J)
            V0 = V1
            V1 = V2
   20    CONTINUE
         GAIN(I) = ABS(DELTA * (H(KMID) + 2.0D0 * (V1 * C - V0)))
   30 CONTINUE
      RETURN
      END
!VPM
      SUBROUTINE VPM(YM, YMMISS, N, NS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(1)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IPRT,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  ' ',       'V',       'P',       'M',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      M = 1
      IYM = N
      MULTI = .FALSE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 0
      ISIZE = -1
      MISS = .TRUE.
      LISYM = 1
      IRLIN = -1
      IBAR = 0
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL VPM (Y, YMISS, N, NS)')
      END
!MDL1
      SUBROUTINE MDL1(PAR, NPAR, XM, N, M, IXM, PV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     MODEL FUNCTION FOR NLS EXERCISER
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PV(N),XM(IXM,M)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION PAR(NPAR)
!        MODEL PARAMETERS
!     INTEGER I
!        ROW INDEX
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     INTEGER M
!        NUMBER OF VARIABLES
!     INTEGER N
!        NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        NUMBER OF PARAMETERS
!     DOUBLE PRECISION PV(N)
!        PREDICTED VALUES
!     DOUBLE PRECISION XM(IXM,M)
!        INDEPENDENT VARIABLES
!
      DO 10 I=1,N
         PV(I) = PAR(1)*XM(I,1)**PAR(2)
   10 CONTINUE
      RETURN
      END
!STPAMO
      SUBROUTINE STPAMO(HEAD, N, EXM, NEXMPT, NETA, J, PAR, NPAR, STP,
     +   NFAIL, IFAIL, SCALE, LSCALE, HDR, PAGE, WIDE, ISUBHD, NPRT,
     +   PRTFXD, IFIXD)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS A DUMMY ROUTINE FOR THE ARIMA ESTIMATION ROUTINES
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   EXM
      INTEGER
     +   ISUBHD,J,LSCALE,N,NETA,NEXMPT,NPAR,NPRT
      LOGICAL
     +   HEAD,PAGE,PRTFXD,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),SCALE(LSCALE),STP(NPAR)
      INTEGER
     +   IFAIL(N),IFIXD(NPAR),NFAIL(NPAR)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL HDR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION EXM
!        THE PROPORTION OF OBSERVATIONS ACTUALLY USED FOR WHICH THE
!        COMPUTED NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE
!        EXEMPTED FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     EXTERNAL HDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IFAIL(N)
!        THE ARRAY OF INDICATOR VARIABLES DESIGNATING WHETHER
!        THE STEP SIZE SELECTED WAS SATISFACTORY FOR A GIVEN
!        OBSERVATION AND PARAMETER.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXD(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXD(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER ISUBHD
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NEXMPT
!        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
!        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
!        SIZE STILL BE CONSIDERED OK.
!     INTEGER NFAIL(NPAR)
!        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP
!        SIZE DOES NOT MEET THE CRITERIA.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE OUTPUT
!        IS TO BEGIN ON A NEW PAGE.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
!        PARAMETERS ARE STORED.
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION STP(NPAR)
!        THE SELECTED STEP SIZE.
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!
      RETURN
!
      END
!NLINIT
      SUBROUTINE NLINIT (N, IFIXD, PAR, NPAR, PARE, NPARE, MIT,
     +   STOPSS, STOPP, SCALE, LSCALE, DELTA, IVAPRX, APRXDV, IVCVPT,
     +   IWORK, IIWORK, RWORK, IRWORK, SCL)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PERFORMS INITIALIZATION FOR THE NONLINEAR
!     LEAST SQUARES ROUTINES.
!
!     REFERENCES
!
!     DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1979), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, (BEING REVISED).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,STOPP,STOPSS
      INTEGER
     +   IIWORK,IRWORK,IVAPRX,IVCVPT,LSCALE,MIT,N,NPAR,NPARE,SCL
      LOGICAL
     +   APRXDV
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PARE(NPAR),RWORK(IRWORK),SCALE(LSCALE)
      INTEGER
     +   IFIXD(NPAR),IWORK(IIWORK)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   AFCTOL,CNVCOD,COVPRT,COVREQ,DINIT,DTYPE,ISCL,J,LMAX0,
     +   MXFCAL,MXITER,NITER,OUTLEV,PRUNIT,RFCTOL,SCLJ,SOLPRT,
     +   STATPR,X0PRT,XCTOL
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DFAULT,NLSPK
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,IABS,MAX
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER AFCTOL
!        THE LOCATION IN RWORK OF THE ABSOLUTE CONVERGENCE TOLERANCE.
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     INTEGER CNVCOD
!        A VALUE USED TO CONTROL THE PRINTING OF ITERATION REPORTS.
!     INTEGER COVPRT
!        THE LOCATION IN IWORK OF THE VARIABLE USED TO INDICATE WHETHER
!        THE COVARIANCE MATRIX IS TO BE PRINTED BY THE NL2 CODE, WHERE
!        IWORK(COVPRT) = 0 INDICATES IT IS NOT.
!     INTEGER COVREQ
!        THE LOCATION IN IWORK OF THE VARIABLE USED TO INDICATE HOW
!        THE COVARIANCE MATRIX IS TO BE COMPUTED BY THE NL2 CODE, WHERE
!        IWORK(COVREQ) = 3 INDICATES THE COVARIANCE MATRIX IS TO BE COMP
!        AS THE RESIDUAL VARIANCE TIMES THE INVERSE OF THE JACOBIAN MATR
!        TRANSPOSED TIMES THE JACOBIAN MATRIX .
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     INTEGER DINIT
!        THE LOCATION IN IWORK OF THE VALUE USED TO INDICATE
!        WHETHER OR NOT USER SUPPLIED SCALE VALUES ARE TO BE
!        USED, WHERE THE (NL2) DEFAULT VALUE OF RWORK(DINIT) = 0.0D0
!        INIDCATES NO, AND THE VALUE RWORK(DINIT) = -1.0D0 INDICATES
!        YES.
!     INTEGER DTYPE
!        THE LOCATION IN IWORK OF THE VALUE INDICATING WHETHER THE
!        SCALE VALUES HAVE BEEN SUPPLIED BY THE USER (IWORK(DTYPE) .LE.
!        OR THE DEFAULT VALUES ARE TO BE USED (IWORK(DTYPE) .GT. 0).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IIWORK
!        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
!     INTEGER IRWORK
!        THE DIMENSION OF THE DOUBLE PRECISION WORK VECTOR RWORK.
!     INTEGER ISCL
!        THE LOCATION IN IWORK INDICATING THE STARTING LOCATION IN
!         RWORK OF THE SCALE VECTOR.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCVPT
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
!        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
!        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)
!        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                       *INVERSE(HESSIAN)
!     INTEGER IWORK(IIWORK)
!        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER LMAX0
!        THE LOCATION IN RWORK OF THE VALUE INDICATING THE
!        MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER MXFCAL
!        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
!        MAXIMUM NUMBER OF FUNCTION CALLS ALLOWED, EXCLUDING
!        CALLS NECESSARY TO COMPUTE THE DERIVATIVES AND VARIANCE
!        COVARIANCE MATRIX.
!     INTEGER MXITER
!        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
!        MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NITER
!        THE LOCATION IN IWORK OF THE NUMBER OF THE CURRENT ITERATION.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF UNKNOWN PARAMETERS TO BE OPTIMIZED.
!     INTEGER OUTLEV
!        THE LOCATION IN IWORK OF THE PARAMETER USED TO CONTROL THE
!        PRINTING OF THE ITERATION REPORTS BY NL2.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION PARE(NPAR)
!        THE CURRENT ESTIMATES OF THE UNKNOWN PARAMETERS, BUT ONLY
!        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
!     INTEGER PRUNIT
!        THE LOCATION IN IWORK OF THE PARAMETER USED TO CONTROL
!        THE PRINT UNIT USED BY NL2.  IWORK(PRUNIT) = 0 MEANS
!        DONT PRINT ANYTHING.
!     INTEGER RFCTOL
!        THE LOCATION IN RWORK OF THE RELATIVE FUNCTION CONVERGENCE
!        TOLERANCE.
!     DOUBLE PRECISION RWORK(IRWORK)
!        THE DOUBLE PRECISION WORK VECTOR USED BY THE NL2 SUBROUTINES.
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     INTEGER SCL
!        THE INDEX IN RWORK OF THE 1ST VALUE OF THE USER SUPPLIED SCALE
!        VALUE.
!     INTEGER SCLJ
!        THE INDEX IN RWORK OF THE JTH VALUE OF THE USER SUPPLIED SCALE
!        VALUE.
!     INTEGER SOLPRT
!        THE LOCATION IN IWORK OF THE PARAMETER USED TO CONTROL PRINTING
!        BY NL2 OF THE FINAL SOLUTION.
!     INTEGER STATPR
!        THE LOCATION IN IWORK OF THE PARAMETER USED TO CONTROL PRINTING
!        BY NL2 OF SUMMARY STATISTICS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     INTEGER XCTOL
!        THE LOCATION IN RSTAK/DSTAK OF THE P CONVERGENCE TOLERANCE.
!     INTEGER X0PRT
!         THE LOCATION IN IWORK OF THE PARAMETER USED TO CONTROL PRINTIN
!        BY NL2 OF THE INITIAL PARAMETER AND SCALE VALUES.
!
!     IWORK SUBSCRIPT VALUES
!
      DATA CNVCOD /34/, COVPRT /14/, COVREQ /15/, DINIT /38/, DTYPE
     +   /16/, ISCL /27/, MXFCAL /17/, MXITER /18/,
     +   NITER /31/, OUTLEV /19/, PRUNIT /21/, SOLPRT /22/, STATPR
     +   /23/, X0PRT /24/
!
!     RWORK SUBSCRIPT VALUES
!
      DATA AFCTOL /31/, LMAX0 /35/, RFCTOL /32/, XCTOL /33/
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
!     PACK PARAMETERS INTO PARE
!
      CALL NLSPK(PAR, IFIXD, NPAR, PARE, NPAR)
!
!     SET NL2SOL DEFAULT VALUES
!
      CALL DFAULT(IWORK, RWORK)
!
!     SET NON NL2 DEFAULT VALUES
!
      IWORK(MXITER) = MIT
      IF (MIT.LE.0) IWORK(MXITER) = 21
!
      IWORK(MXFCAL) = 2*IWORK(MXITER)
!
!     SET STOPPING CRITERION
!
      RWORK(AFCTOL) = RMDCON(1,typ=0.0_wp)
      IF ((STOPSS.GE.RMDCON(3,typ=0.0_wp)) .AND. (STOPSS.LE.0.1))
     + RWORK(RFCTOL) = STOPSS
!
      IF ((STOPP.GE.0.0D0) .AND. (STOPP.LE.1.0D0))
     +   RWORK(XCTOL) = STOPP
!
!     SET SCALE VALUES
!
      SCL = 94 + 2*N + NPARE*(3*NPARE+31)/2
      IWORK(ISCL) = SCL
      IF (SCALE(1).GT.0.0D0) GO TO 40
!
      IWORK(DTYPE) = 1
!
!     INITIALIZE SCALE VALUES FOR FIRST ITERATION
!
      SCLJ = SCL - 1
      DO 30 J=1,NPAR
         IF (IFIXD(J).NE.0) GO TO 30
         SCLJ = SCLJ + 1
         IF (PAR(J).EQ.0.0D0) RWORK(SCLJ) = 1.0D0
         IF (PAR(J).NE.0.0D0) RWORK(SCLJ) = 1.0D0/ABS(PAR(J))
   30 CONTINUE
!
      GO TO 60
!
   40 IWORK(DTYPE) = 0
      RWORK(DINIT) = -1.0D0
      SCLJ = SCL - 1
      DO 50 J=1,NPAR
         IF (IFIXD(J).NE.0) GO TO 50
         SCLJ = SCLJ + 1
         RWORK(SCLJ) = 1.0D0/MAX(ABS(SCALE(J)),ABS(PAR(J)))
   50 CONTINUE
!
   60 IF (DELTA.LE.0.0D0) RWORK(LMAX0) = 100.0D0
      IF (DELTA.GT.0.0D0) RWORK(LMAX0) = DELTA
!
!     SET NL2 COVARIANCE COMPUTATION CONTROL PARAMETER
!
      IF ((IVAPRX.LE.1) .OR. (IVAPRX.EQ.4) .OR. (IVAPRX.GE.7))
     +   IWORK(COVREQ) = 3
      IF ((IVAPRX.EQ.2) .OR. (IVAPRX.EQ.5)) IWORK(COVREQ) = 2
      IF ((IVAPRX.EQ.3) .OR. (IVAPRX.EQ.6)) IWORK(COVREQ) = 1
      IF ((IVAPRX.GE.4) .AND. (IVAPRX.LE.6))
     +   IWORK(COVREQ) = -IWORK(COVREQ)
      IF (APRXDV) IWORK(COVREQ) = -IABS(IWORK(COVREQ))
      IF ((IVAPRX.LE.1) .OR. (IVAPRX.EQ.4) .OR. (IVAPRX.GE.7))
     +   IVCVPT = 1
      IF ((IVAPRX.EQ.2) .OR. (IVAPRX.EQ.5)) IVCVPT = 2
      IF ((IVAPRX.EQ.3) .OR. (IVAPRX.EQ.6)) IVCVPT = 3
!
!     INITIALIZE THE ITERATION COUNTER
!
      IWORK(NITER) = 0
!
!     SET NL2 PRINT CONTROL PARAMETERS
!
      IWORK(CNVCOD) = 0
      IWORK(COVPRT) = 0
      IWORK(OUTLEV) = 0
      IWORK(PRUNIT) = 0
      IWORK(SOLPRT) = 0
      IWORK(STATPR) = 0
      IWORK(X0PRT) = 0
!
      RETURN
!
      END
!AMFMN
      SUBROUTINE AMFMN (PAR, PV, Y, NPAR, N, NFAC, MSPECT,
     +  PARDF, NPARDF, T, TEMP, PARAR, PARMA, MBO, MBOL, N1, N2, NPRT,
     +  SAVE, NFCST, NFCSTO, IFCSTO, FCST, IFCST, FCSTSD, F,
     +  FSD, NPARAR, NPARMA)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN ROUTINE FOR COMPUTING AND PRINTING THE ARIMA
!     FORECASTS
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IFCST,MBO,MBOL,N,N1,N2,NFAC,NFCST,NFCSTO,NPAR,NPARAR,
     +   NPARDF,NPARMA,NPRT
      LOGICAL
     +   SAVE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   F(*),FCST(IFCST,*),FCSTSD(*),FSD(*),PAR(*),PARAR(*),PARDF(*),
     +   PARMA(*),PV(N1:N2),T(*),TEMP(*),Y(*)
      INTEGER
     +   IFCSTO(*),MSPECT(NFAC,4)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CONST,PMU,RSD,RSS,T975,WSUM,WSUMT
      INTEGER
     +   I,I1,IDF,IF,IFC,IFLAG,IFO,IFOMIN,IPRT,J,K,NT
      LOGICAL
     +   PAGE
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   PPFT,DDOT
      EXTERNAL PPFT,DDOT
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMFHDR,AMFOUT,AMLST,DCOEF,IPRINT,MDLTS2,MODSUM,MULTBP
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CONST
!        THE CONSTANT TERM IN THE MODEL, MODELING EITHER THE SERIES
!        MEAN OR A DETERMINISTIC TREND.
!     DOUBLE PRECISION F(NFCST)
!        THE FORECASTS.
!     DOUBLE PRECISION FCST(IFCST,NFCSTO)
!        THE STORAGE ARRAY FOR THE FORECASTS.
!     DOUBLE PRECISION FCSTSD(NFCST)
!        THE STORAGE ARRAY FOR THE STANDARD DEVIATIONS OF THE FORECASTS.
!     DOUBLE PRECISION FSD(NFCST)
!        THE STANDARD DEVIATIONS OF THE FORECASTS.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IF
!        AN INDEX VARIABLE.
!     INTEGER IFCST
!        THE FIRST DIMENSION OF THE ARRAY FCST.
!     INTEGER IFCSTO(NFCSTO)
!        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
!     INTEGER IFLAG
!        AN INDICATOR VARIABLE DESIGNATING WHETHER THE BACK FORECASTS
!        WERE ESSENTIALLY ZERO (IFLAG=0) OR NOT (IFLAG=1).
!     INTEGER IFO
!        THE INDEX OF THE ORIGIN BEING USED.
!     INTEGER IFOMIN
!        THE SMALLEST ORIGIN USED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER I1
!        AN INDEX VALUE.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBOL
!        THE MAXIMUM BACK ORDER ON THE LEFT
!     INTEGER MSPECT(NFAC,4)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFCST
!        THE NUMBER OF FORECASTS.
!     INTEGER NFCSTO
!        THE NUMBER OF THE ORIGINS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NT
!        THE NUMBER OF PARAMETERS IN T, WHERE NT = MBOL
!     INTEGER N1
!        THE LOWER BOUND FOR PV.
!     INTEGER N2
!        THE UPPER BOUND FOR PV.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PARAR(MBO)
!        THE AUTOREGRESSIVE PARAMETERS
!     DOUBLE PRECISION PARDF(NPARDF)
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS.
!     DOUBLE PRECISION PARMA(MBO)
!        THE MOVING AVERAGE PARAMETERS
!     DOUBLE PRECISION PMU
!        THE VALUE OF MU, I.E., THE TREND OR MEAN.
!     DOUBLE PRECISION PV(N1:N2)
!        THE PREDICTED VALUE OF THE FIT.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     DOUBLE PRECISION RSS
!        THE RESIDUAL SUM OF SQUARES.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION T(2*MBO)
!        A TEMPORARY WORK VECTOR.
!     DOUBLE PRECISION TEMP(MBO)
!        A TEMPORARY WORK VECTOR
!     DOUBLE PRECISION T975
!        THE VALUE OF THE 97.5 PERCENT POINT FUNCTION FOR THE
!        T DISTRIBUTION.
!     DOUBLE PRECISION WSUM
!        THE SUM OF THE WEIGHTS SQUARED, USED TO COMPUTE THE
!        STANDARD DEVIATION OF THE FORECAST.
!     DOUBLE PRECISION WSUMT
!        A TEMPORARY STORAGE LOCATION FOR WSUM.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
      CALL IPRINT (IPRT)
!
!     COMPUTE DIFFERENCING PARAMETERS
!
      CALL DCOEF (NFAC, MSPECT(1,2), MSPECT(1,4), NPARDF, PARDF, MBO, T)
!
!     COMPUTE RESIDUALS, GIVEN VALUES OF PARAMETERS
!
      CALL MDLTS2 (PAR, PV, Y, NPAR, N, NFAC, MSPECT, PMU,
     +  PARDF, NPARDF, T, TEMP, PARAR, PARMA, MBO, N1, N2, IFLAG)
      IDF = N - NPARDF - NPAR
      RSS = DDOT(N, PV(1), 1, PV(1), 1)
      RSD = SQRT(RSS / IDF)
!
!     PRINT INITIAL SUMMARY
!
      PAGE = .FALSE.
      IF (NPRT.EQ.0) GO TO 10
      CALL AMFHDR(PAGE, .TRUE., 2)
      CALL MODSUM(NFAC, MSPECT)
      CALL AMLST(2, PAR, NPAR, NFAC, MSPECT, N, PAR, NPAR, PAR,
     +  NPAR, PAR, NPAR, PAR, RSS, RSD, NPARDF, NPAR, IDF)
      PAGE = .TRUE.
!
   10 CONTINUE
!
!     COMBINE PARDF AND PARAR INTO T
!
      NT = NPARAR + NPARDF
      CALL MULTBP(PARAR, NPARAR, PARDF, NPARDF, T, NT, MBO)
!
!     COMPUTE CONSTANT
!
      CONST = 0.0D0
      IF (PMU.NE.0.0D0) THEN
        IF (NPARAR.GE.1) THEN
          DO 20 J = 1, NPARAR
            CONST = CONST - PARAR(J)
   20     CONTINUE
        END IF
        CONST = (1.0D0 + CONST) * PMU
      END IF
!
!     FIND LOWEST ORIGIN
!
      IFOMIN = IFCSTO(1)
      DO 30 IFO = 1, NFCSTO
        IFOMIN = MIN(IFOMIN, IFCSTO(IFO))
   30 CONTINUE
!
!     SET TEMP TO BACKFORECAST OF Y IF NECESSARY
!
      IF ((MBOL.GE.1) .AND. (IFOMIN.LT.MBOL)) THEN
        I1 = IFOMIN-MBOL+1
        DO 60 I = 0, I1, -1
          K = 1-I
          TEMP(K) = CONST
          DO 40 J = 1, MBOL
            IF (I+J.LE.N) THEN
              IF (I+J.GE.1) THEN
                TEMP(K) = TEMP(K) + T(J)*Y(I+J)
              ELSE
                TEMP(K) = TEMP(K) + T(J)*TEMP(MBOL-I-J)
              END IF
            END IF
   40     CONTINUE
          IF (NPARMA.GE.1) THEN
            DO 50 J =1, NPARMA
              IF (I+J.LE.N) TEMP(K) = TEMP(K) - PARMA(J)*PV(I+J)
   50       CONTINUE
          END IF
   60   CONTINUE
      END IF
!
!      COMPUTE WEIGHTS FOR COMPUTING STANDARD DEVIATIONS OF THE FORECAST
!
      DO 65 J = 1, NFCST
        FSD(J) = 0.0D0
        IF (MBOL.GE.1) THEN
          DO 64 I = 1, MBOL
            IF (J-I.GE.1) THEN
              FSD(J) = FSD(J) + T(I)*FSD(J-I)
            ELSE
              IF (J-I.EQ.0) FSD(J) = FSD(J) + T(I)
            END IF
   64     CONTINUE
        END IF
        IF (J.LE.NPARMA) FSD(J) = FSD(J) - PARMA(J)
   65 CONTINUE
!
!     COMPUTE STANDARD DEVIATIONS OF FORECASTS
!
      WSUM = 1.0D0
      DO 66 I = 1, NFCST
        WSUMT =WSUM
        WSUM = WSUM + FSD(I)*FSD(I)
        FSD(I) = SQRT(WSUMT)*RSD
   66 CONTINUE
!
!     SET PERCENT POINT VALUE FOR 95 PERCENT CONFIDENCE LIMITS
!
      T975 = PPFT(0.975D0, N-NPAR)
!
!     COMPUTE FORECASTS FOR EACH ORIGIN
!
      DO 100 IFO = 1, NFCSTO
        IFC = IFCSTO(IFO)
        IF ((IFC.LT.1) .OR. (IFC.GT.N)) IFC = N
        DO 90 IF = 1, NFCST
          F(IF) = CONST
          IF (MBOL.GE.1) THEN
            DO 70 J = 1, MBOL
              K = IF + IFC-J
              IF (K.LE.0) THEN
                F(IF) = F(IF) + T(J)*TEMP(1-K)
              ELSE
                IF (K.LE.IFC) THEN
                  F(IF) = F(IF) + T(J)*Y(K)
                ELSE
                  F(IF) = F(IF) + T(J)*F(IF-J)
                END IF
              END IF
   70       CONTINUE
          END IF
          IF (NPARMA.GE.1) THEN
            DO 80 J = 1, NPARMA
              K = IF + IFC - J
              IF (K.LE.IFC) F(IF) = F(IF) - PARMA(J)*PV(K)
   80       CONTINUE
          END IF
          IF (SAVE) FCST(IF,IFO) = F(IF)
   90   CONTINUE
!
!     PRINT RESULTS FROM THIS ORIGIN
!
        IF (NPRT.NE.0)
     +    CALL AMFOUT(F, FSD, N, NFCST, IFCSTO, IFO, NFCSTO, Y, T975,
     +    PAGE)
!
  100 CONTINUE
!
      RETURN
!
      END
!ACFFS
      SUBROUTINE ACFFS (YFFT, N, LYFFT, LDSTAK, LAGMAX, LACOV, ACOV,
     +   IAR, PHI, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
!     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
!     USING A FFT WITH THE COMPUTED ACVF ESTIMATES RETURNED TO THE USERS
!     ROUTINE (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IAR,LACOV,LAGMAX,LDSTAK,LYFFT,N,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),PHI(*),YFFT(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN,YSD
      INTEGER
     +   AIC,FTEST,I,IFP,IPRT,LDSMIN,NALL0,NFAC,NFFT,PRHO,SDRHO,
     +   WORK
      LOGICAL
     +   DIFFER,ISFFT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   IOD(1),ND(1),NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACFER,ACFMNF,ACFOUT,FFTLEN,IPRINT,LDSCMP,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV)
!        THE AUTOCOVARIANCE VECTOR.
!     INTEGER AIC
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE AKAIKES CRITERION FOR EACH ORDER.
!     DOUBLE PRECISION CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     LOGICAL DIFFER
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER FTEST
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE PARTIAL F RATIO AND PROBABILITIES
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!     INTEGER IFP
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE FLOATING
!        POINT VARIABLES ARE SINGLE (IFP=3) OR DOUBLE (IFP=4) PRECISION.
!     INTEGER IOD(1)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     INTEGER ND(1)
!        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
!     INTEGER NDUM(1)
!        A DUMMY DIMENSIONED VARIABLE.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     DOUBLE PRECISION OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
!     DOUBLE PRECISION PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     INTEGER PRHO
!        THE STARTING LOCATION IN THE WORK AREA FOR PRHO.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SDRHO
!        THE STARTING LOCATION IN THE WORK AREA FOR SDRHO.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR WORK.
!     DOUBLE PRECISION YFFT(LYFFT)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YSD
!        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'A',       'C',       'F',       'F',       'S',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      DIFFER = .FALSE.
      NFAC = 1
      ND(1) = 0
      IOD(1) = 0
      ISFFT = .TRUE.
!
!     SET LENGTH OF EXTENDED SERIES
!
      NFFT = 0
      IF ((N.GE.3) .AND. (LAGMAX.GE.1)) CALL FFTLEN(N+LAGMAX, 4, NFFT)
!
      CALL LDSCMP(4, 0, 0, 0, 0, 0, 'D', (4*LAGMAX+1) + NFFT, LDSMIN)
!
      CALL ACFER(NMSUB, N, LAGMAX, LACOV, LDSTAK, LDSMIN,
     +  DIFFER, NFAC, ND, IOD, ISFFT, LYFFT, NFFT)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      IF (IERR.EQ.0) THEN
!
!       SET UP THE WORK AREA.
!
        CALL STKSET(LDSTAK, 4)
        NALL0 = STKST(1)
!
        IFP = 4
!
        WORK = STKGET(NFFT, IFP)
        PRHO = STKGET(LAGMAX, IFP)
        AIC = STKGET(LAGMAX+1, IFP)
        FTEST = STKGET(2*LAGMAX, IFP)
        SDRHO = WORK
!
        IF (IERR.EQ.0) THEN
!
!         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
          CALL ACFMNF (YFFT, N, NFFT, LAGMAX, ACOV(2), RSTAK(SDRHO),
     +       YMEAN, RSTAK(PRHO), RSTAK(AIC), RSTAK(FTEST), PHI,
     +       IAR, OSPVAR, ACOV, LACOV, LAGMAX+1, CHIA, CHIAP,
     +       LYFFT, RSTAK(WORK), NFFT, NPRT)
!
          YSD = SQRT (ACOV(1) * N / (N - 1))
!
!         CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
          IF ((NPRT.NE.0) .OR. (ACOV(1).EQ.0.0D0))
     +       CALL ACFOUT (YMEAN, YSD, N, N, LAGMAX, ACOV(2),
     +       RSTAK(SDRHO),
     +       RSTAK(PRHO), NDUM, RSTAK(AIC), LAGMAX+1, RSTAK(FTEST), IAR,
     +       PHI, OSPVAR, CHIA, CHIAP, LAGMAX, .FALSE., 0.0D0, .FALSE.,
     +       .FALSE., 0, NDUM, NDUM, 0)
!
          IF (NPRT.NE.0) THEN
            DO 50 I = 1, LAGMAX
               ACOV(I+1) = ACOV(I+1) * ACOV(1)
   50       CONTINUE
          END IF
!
        END IF
!
        CALL STKCLR(NALL0)
      END IF
!
      IF (IERR.NE.0) THEN
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL ACFFS (YFFT, N, LYFFT, LDSTAK,'/
     +  '      +            LAGMAX, LACOV, ACOV, IAR, PHI, NPRT)')
      END
!UASDV
      SUBROUTINE UASDV(ACOV, SPCA, SPCF, LSPC, IAR, PHI, NF, FMIN, FMAX,
     +   FREQ, N, LAGMAX, FTEST, AIC, WORK, LACOV, LWORK, DELTA, ISORT,
     +   ISYM, XAXIS, YAXIS, LPCV, ALPHA, LAG, LAIC, LPHI, NPRT, VAR,
     +   WINDOW, NMSUB)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN DRIVER FOR COMPUTING THE AUTOREGRESSIVE
!     (AND FOURIER) SPECTRUMS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,VAR
      INTEGER
     +   IAR,LACOV,LAG,LAGMAX,LAIC,LPCV,LPHI,LSPC,LWORK,N,NF,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(LACOV),AIC(LAIC),FREQ(NF),FTEST(2,LAGMAX),PHI(LPHI),
     +   SPCA(LSPC),SPCF(LSPC),WORK(LWORK),XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISORT(NF),ISYM(LPCV)
      CHARACTER
     +   NMSUB(6)*1
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL WINDOW
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALOW,AUP,BW,DF,SPCAMN,SPCAMX,SPCFMN,SPCFMX,XPLTMN,XPLTMX,
     +   YPLTMN,YPLTMX
      INTEGER
     +   ISPCER,NPTS,NSPCA,NSPCF,NW
      LOGICAL
     +   AICPRT
!
!  LOCAL ARRAYS
      INTEGER
     +   LAGS(1),NLPPA(1)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AOS,SETFRQ,SPCCK,UASCFT,UASEST,UASORD,UASOUT,UFSLAG,UFSMN
!
!  INTRINSIC FUNCTIONS
      INTRINSIC IABS,INT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV)
!        THE AUTOCOVARIANCE COMPUTED FROM THE LAG PRODUCT PAIRS.
!     DOUBLE PRECISION AIC(LAIC)
!        THE ARRAY CONTAINING THE AKAIKES CRITERIA FOR EACH ORDER(?).
!     LOGICAL AICPRT
!        AN INDICATOR VARIABLE USED TO DETERMINE IF THE AKIAKE
!        INFORMATION CRITERIA AND CHI SQUARED STATISTICS SHOULD
!        BE PRINTED.
!     DOUBLE PRECISION ALOW
!        A FACTOR USED TO COMPUTE THE LOWER CONFIDENCE LIMITS.
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION AUP
!        A FACTOR USED TO COMPUTE THE UPPER CONFIDENCE LIMITS.
!     DOUBLE PRECISION BW
!        THE BANDWIDTH.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
!        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     DOUBLE PRECISION FTEST(2,LAGMAX)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER ISORT(NF)
!        AN ARRAY USED FOR SORTING.
!     INTEGER LSPC
!         THE ACTUAL FIRST DIMENSION FOR THE SPECTRUM ARRAYS.
!     INTEGER ISPCER
!        AN ERROR FLAG USED FOR THE SPECTRUM PLOTS.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE COVARIANCE ARRAYS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(1)
!        THE LAG WINDOW TRUNCATION POINT RETURNED FROM UFSLAG.
!     INTEGER LAIC
!        THE LENGTH OF THE ARRAY AIC.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER LWORK
!        THE ACTUAL LENGTH OF THE WORK ARRAY.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
!        ARE TO BE ESTIMATED.
!     INTEGER NLPPA(1)
!        A DUMMY ARRAY
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     INTEGER NSPCA, NSPCF
!        THE NUMBER OF VALID SPECTRUM ESTIMATES FOR THE AUTOREGRESSIVE
!        AND FOURIER SPECTRUMS, RESPECTIVELY.
!     INTEGER NW
!        THE NUMBER OF LAG WINDOW TRUNCATION POINTS SELCTED.
!     DOUBLE PRECISION PHI(LPHI)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     DOUBLE PRECISION SPCA(LSPC)
!        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!     DOUBLE PRECISION SPCAMN, SPCAMX
!        THE MINIMUM AND MAXIMUM AUTOREGRESSIVE SPECTRUM VALUE TO BE
!        PLOTTED.
!     DOUBLE PRECISION SPCF(LSPC)
!        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
!     DOUBLE PRECISION SPCFMN, SPCFMX
!        THE MINIMUM AND MAXIMUM FOURIER SPECTRUM VALUE TO BE PLOTTED.
!     DOUBLE PRECISION VAR
!        THE ONE STEP PREDICTION VARIANCE.
!     EXTERNAL WINDOW
!        THE TYPE OF WINDOW TO BE USED.
!     DOUBLE PRECISION WORK(LWORK)
!        THE WORK ARRAY.
!     DOUBLE PRECISION XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     DOUBLE PRECISION YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
      NW = 1
!
      IF (LAG.LE.0) THEN
!
!     SET THE LAG WINDOW TRUNCATION POINT TO BE USED FOR THE
!     FOURIER SPECTRUM ESTIMATES.
!
         CALL UFSLAG(ACOV, LAGMAX, LAGS, N, NW, NW, LACOV)
         LAG = LAGS(1)/2
      END IF
!
!     SET FREQUENCIES FOR THE SPECTRUM.
!
      CALL SETFRQ(FREQ, NF, 1, FMIN, FMAX, DELTA)
!
!     COMPUTE THE FOURIER SPECTRUM ESTIMATES
!
      CALL UFSMN(ACOV, NLPPA, LAG, DF, NF, FREQ, ALPHA, BW, SPCF,
     +  ALOW, AUP, LACOV, LSPC, WINDOW, WORK, LWORK, N, DELTA,
     +  .FALSE., 1)
!
      AICPRT = .FALSE.
!
      IF (IAR.LT.0) THEN
!
!     USER HAS CHOSEN ORDER.
!     COMPUTE COEFFICIENTS AND VARIANCE USING DURBINS RECURSIVE METHOD.
!
         CALL UASCFT(ACOV, LAGMAX, LACOV, IABS(IAR), PHI, N, VAR)
!
      ELSE IF (IAR.EQ.0) THEN
!
!     SELECT MODEL ORDER AND COMPUTE COEFFICIENTS AND VARIANCE.
!
         AICPRT = .TRUE.
         CALL AOS(N, LAGMAX, ACOV, WORK, IAR, VAR, PHI,
     +            WORK, AIC, FTEST, LACOV, LAIC)
      END IF
!
!     COMPUTE THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!
      CALL UASEST(IABS(IAR), VAR, PHI, NF, FREQ, DELTA, SPCA, LPHI,
     +   LSPC)
!
      IF (NPRT.EQ.0) RETURN
!
!     SET PLOTTING VECTORS.
!
      XPLTMN = FMIN
      XPLTMX = FMAX
!
      YPLTMN = 0.0D0
      YPLTMX = 0.0D0
!
      CALL SPCCK(SPCF, ISORT, NF, SPCFMN, SPCFMX, NSPCF, ISPCER)
      IF (ISPCER.NE.0) GO TO 40
      CALL SPCCK(SPCA, ISORT, NF, SPCAMN, SPCAMX, NSPCA, ISPCER)
      IF (ISPCER.NE.0) GO TO 40
!
      CALL UASORD(SPCF, SPCA, SPCFMN, SPCFMX, SPCAMN, SPCAMX, FREQ, NF,
     +   XAXIS, YAXIS, ISYM, NPTS, LSPC, LPCV, NSPCF, NSPCA, BW, ALOW,
     +   AUP, XPLTMN, XPLTMX, YPLTMN, YPLTMX, NPRT)
!
!     PRINT RESULTS
!
   40 CALL UASOUT(XAXIS, YAXIS, ISYM, NPTS, BW, INT(DF+0.5D0), LAG,
     +   IABS(IAR), PHI, ISPCER, LPCV, XPLTMN, XPLTMX, YPLTMN, YPLTMX,
     +   FTEST, AIC, LAIC, VAR, NPRT, LAGMAX, AICPRT, N, NMSUB)
!
      RETURN
      END
!PGMS
      SUBROUTINE PGMS (YFFT, N, NFFT, LYFFT, IEXTND, NF, PER, LPER,
     +   FREQ, LFREQ, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
!     THE (RAW) PERIODOGRAM OF A SERIES (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IEXTND,LFREQ,LPER,LYFFT,N,NF,NFFT,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),PER(*),YFFT(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,NFFT2
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,HEAD
!
!  LOCAL ARRAYS
      CHARACTER
     +   LLFREQ(8)*1,LLPER(8)*1,LLYFFT(8)*1,LN(8)*1,NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,ENFFT,IPRINT,PGMMN
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION FREQ(LFREQ)
!        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
!        INTEGRATED SPECTRUM VALUES ARE STORED.
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IEXTND
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
!        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
!        USED TO EXTEND THE SERIES.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER LFREQ
!        THE LENGTH OF THE ARRAY FREQ.
!     CHARACTER*1 LLFREQ(8), LLPER(8), LLYFFT(8), LN(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER LPER
!        THE LENGTH OF THE ARRAY PER.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
!     INTEGER NFFT2
!        THE EFFECTIVE SERIES LENGTH ACTUALLY USED.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .EQ.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
!        IF NPRT .GE.  2, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     DOUBLE PRECISION PER(LPER)
!        THE ARRAY IN WHICH THE PERIODOGRAM IS STORED.
!     DOUBLE PRECISION YFFT(LYFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'P',       'G',       'M',       'S',       ' ',       ' '/
      DATA
     + LLFREQ(1), LLFREQ(2), LLFREQ(3), LLFREQ(4), LLFREQ(5),
     +  LLFREQ(6), LLFREQ(7), LLFREQ(8)
     +  /'L','F','R','E','Q',' ',' ',' '/
      DATA
     + LLPER(1), LLPER(2), LLPER(3), LLPER(4), LLPER(5),
     +  LLPER(6), LLPER(7), LLPER(8) /'L','P','E','R',' ',' ',' ',' '/
      DATA
     + LLYFFT(1), LLYFFT(2), LLYFFT(3), LLYFFT(4), LLYFFT(5),
     +  LLYFFT(6), LLYFFT(7), LLYFFT(8)
     +  /'L','Y','F','F','T',' ',' ',' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /'N',' ',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
      IF (ERR01) GO TO 5
!
      CALL ENFFT(NMSUB, NFFT, 2, N, LYFFT, NFFT2, HEAD, ERR02)
      NF = NFFT2/2
!
      CALL EISGE(NMSUB, LLYFFT, LYFFT, NFFT2, 9, HEAD, ERR03, LLYFFT)
!
      CALL EISGE(NMSUB, LLPER, LPER, NF, 9, HEAD, ERR04, LLPER)
!
      CALL EISGE(NMSUB, LLFREQ, LFREQ, NF, 9, HEAD, ERR05, LLFREQ)
!
      IF (ERR02 .OR. ERR03 .OR. ERR04 .OR. ERR05) GO TO 5
      GO TO 10
!
    5 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   10 CONTINUE
!
      CALL PGMMN (YFFT, N, NFFT2, IEXTND, NF, PER, LPER, YFFT, FREQ,
     +   LFREQ, NPRT, NMSUB)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL PGMS (YFFT, N, NFFT, LYFFT,'/
     +  '      +           IEXTND, NF, PER, LPER, FREQ, LFREQ, NPRT)')
      END
!LLCNTP
      SUBROUTINE LLCNTP(Y, WT, LWT, XM, N, NDEG, NPAR, RES, LDSTAK,
     +   NPRT, PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV,
     +   IVCV, NMSUB, WEIGHT, SAVE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR POLYNOMIAL LINEAR LEAST
!     SQUARES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,LDSTAK,LPAR,LPV,LSDPV,LSDRES,LWT,N,NDEG,NPAR,NPRT
      LOGICAL
     +   SAVE,WEIGHT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SDPV(*),SDRES(*),VCV(*),WT(*),XM(*),Y(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IFIT,IXM,M
!
!  EXTERNAL SUBROUTINES
      EXTERNAL LLCNT,LLHDRP
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IFIT
!        THE INDICATOR VALUE DESIGNATING WHETHER THE LLS IS OF A
!        GENERAL MODEL (IFIT=3) OR A POLYNOMIAL MODEL (IFIT=1).
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     EXTERNAL LLHDRP
!        THE NAME OF THE ROUTINE THAT PRODUCED THE HEADING.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDEG
!        THE DEGREE OF THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     DOUBLE PRECISION PAR(LPAR)
!        THE PARAMETERS TO BE ESTIMATED.
!     DOUBLE PRECISION PV(LPV)
!        THE PREDICTED VALUES.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION SDPV(LSDPV)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(LSDRES)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
!     DOUBLE PRECISION XM(N,1)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!
      IFIT = 1
      NPAR = NDEG + 1
      M = 1
      IXM = N
!
      CALL LLCNT(Y, WT, LWT, XM, N, M, IXM, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   LLHDRP, IFIT, NMSUB, WEIGHT, SAVE)
!
      RETURN
!
      END
!UFSOUT
      SUBROUTINE UFSOUT(XAXIS, YAXIS, ISYM, NPTS, BW, IDF, LAG, LAGLST,
     +   NEWPG, ISPCER, LPCV, XPLTMN, XPLTMX, YPLTMN, YPLTMX, ILOG,
     +   PHAS, FREQ, NF, UNIVAR, NMSUB)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES THE FOURIER BIVARIATE SPECTRUM OUTPUT.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   BW,XPLTMN,XPLTMX,YPLTMN,YPLTMX
      INTEGER
     +   IDF,ILOG,ISPCER,LAG,LAGLST,LPCV,NF,NPTS
      LOGICAL
     +   NEWPG,UNIVAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),PHAS(NF),XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISYM(LPCV)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   PI,XMN,XMX,YMN,YMX
      INTEGER
     +   I,IPRT
      LOGICAL
     +   ERROR
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GETPI,IPRINT,PPLMT,PPMN,VERSP
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION BW
!        THE BANDWIDTH.
!     LOGICAL ERROR
!        AN ERROR FLAG
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER IDF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     INTEGER IERR
!        THE ERROR FLAG.
!     INTEGER ILOG
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        ILOG = 0 THE PLOT IS LINEAR/LINEAR, IF
!        ILOG = 1 THE PLOT IS LOG/LINEAR, IF
!        ILOG = 2 THE PLOT IS LINEAR/LOG, AND IF
!        ILOG = 3 THE PLOT IS LOG/LOG.
!     INTEGER IPRT
!        THE LOGICAL UNIT NUMBER FOR THE OUTPUT.
!     INTEGER ISPCER
!        A VARIABLE USED TO DESIGNATE AN ERROR IN THE SPECTRUM
!        VALUES.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT.
!     INTEGER LAGLST
!        THE LAST LAG BEFORE MISSING DATA CAUSED THE ACVF OF EITHER
!        SERIES 1 OR 2 NOT TO BE COMPUTED.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     LOGICAL NEWPG
!        THE LOGICAL VARIABLE USED TO DETERMINE IF OUTPUT
!        WILL BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE.
!     INTEGER NPTS
!        THE NUMBER OF CO-ORDINATES TO BE PLOTTED.
!     DOUBLE PRECISION PHAS(NF)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION PI
!        THE VALUE OF PI.
!     LOGICAL UNIVAR
!        THE LOGICAL VARIABLE USED TO DETERMINE IF THE OUTPUT
!        IS FOR UNIVARIATE (TRUE) OR BIVARIATE (FALSE) SPECTRA.
!     DOUBLE PRECISION XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION XMN, XMX
!        *
!     DOUBLE PRECISION XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     DOUBLE PRECISION YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YMN, YMX
!        *
!     DOUBLE PRECISION YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
!      SET LOGICAL UNIT NUMBER FOR OUTPUT AND SET OUTPUT WIDTH.
!
      CALL IPRINT(IPRT)
!
      CALL GETPI(PI)
!
      IF (NEWPG) WRITE (IPRT,1010)
      IF (ISPCER.LE.1) GO TO 10
      CALL VERSP(.TRUE.)
      WRITE (IPRT,1060) LAGLST, LAG
      RETURN
!
   10 CONTINUE
      CALL VERSP(.TRUE.)
      IF (.NOT.UNIVAR) WRITE (IPRT,1070)
      IF (UNIVAR) WRITE (IPRT,1080)
      WRITE (IPRT,1020) LAG, BW, IDF
      IF (ISPCER.EQ.0) GO TO 20
      WRITE (IPRT,1050)
      GO TO 30
!
   20 CONTINUE
!
!     PRINT PLOTS
!
!     PLOT SQUARED COHERENCY COMPONENT OF SPECTRUM
!
      CALL PPLMT(YAXIS, YAXIS, XAXIS, XAXIS, NPTS, 1, LPCV, YPLTMN,
     +  YPLTMX, YMN, YMX, XPLTMN, XPLTMX, XMN, XMX, ERROR, NMSUB,
     +  .FALSE.)
      IF (.NOT.ERROR)
     +  CALL PPMN(YAXIS, YAXIS, XAXIS, XAXIS, NPTS, 1, LPCV, 1, ISYM,
     +  LPCV, 0, -1, YMN, YMX, XMN, XMX, .FALSE., ILOG)
      IF (XPLTMN.EQ.0.0D0 .AND. XPLTMX.EQ.0.5D0) WRITE (IPRT, 1030)
!
   30 IF (UNIVAR) RETURN
      DO 40 I=1,NF
         XAXIS(I) = FREQ(I)
         XAXIS(NF+I) = FREQ(I)
         YAXIS(I) = PHAS(I)
         IF (PHAS(I).GT.0.0D0) THEN
            YAXIS(NF+I) = PHAS(I) - 2*PI
         ELSE IF (PHAS(I).LT.0.0D0) THEN
            YAXIS(NF+I) = PHAS(I) + 2*PI
         ELSE
            YAXIS(NF+I) = 0.0D0
         END IF
   40 CONTINUE
!
!     PLOT SMOOTHED PHASE COMPONENT OF SPECTRUM
!
      WRITE (IPRT,1010)
      CALL VERSP(.TRUE.)
      WRITE (IPRT,1000)
      WRITE (IPRT,1020) LAG, BW, IDF
      CALL PPLMT(YAXIS, YAXIS, XAXIS, XAXIS, 2*NF, 1, 2*NF, -2*PI, 2*PI,
     +  YMN, YMX, XPLTMN, XPLTMX, XMN, XMX, ERROR, NMSUB, .FALSE.)
      IF (ERROR) THEN
        IERR = 1
      ELSE
        CALL PPMN(YAXIS, YAXIS, XAXIS, XAXIS,
     +            2*NF, 1, 2*NF, 0, ISYM, LPCV,
     +            0, -1, YMN, YMX, XMN, XMX, .FALSE., ILOG)
        IF (XPLTMN.EQ.0.0D0 .AND. XPLTMX.EQ.0.5D0) WRITE (IPRT, 1030)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (50H -- SMOOTHED FOURIER SPECTRUM (PHASE COMPONENT) --)
 1010 FORMAT ('1')
 1020 FORMAT (45H    (PARZEN WINDOW WITH LAG WIND. TRUNC. PT.=, I5, 1X,
     +   5H/ BW=, F6.4, 1X, 6H/ EDF=, I6, ')')
 1030 FORMAT (5H+FREQ/7H PERIOD, 9X, 3HINF, 7X, 3H20., 7X, 3H10., 8X,
     +   6H6.6667, 4X, 2H5., 8X, 2H4., 8X, 6H3.3333, 4X, 6H2.8571, 4X,
     +   3H2.5, 7X, 6H2.2222, 4X, 2H2.)
!1040 FORMAT (5H+FREQ/7H PERIOD, 9X, 3HINF, 7X, 3H10., 7X, 2H5., 8X,
!    *   6H3.3333, 4X, 3H2.5, 7X, 2H2.)
 1050 FORMAT (//39H THE PLOT HAS BEEN SUPRESSED BECAUSE NO/
     +   40H POSITIVE SPECTRUM VALUES WERE COMPUTED.)
 1060 FORMAT (//50H THE LARGEST LAG WINDOW TRUNCATION POINT WHICH CAN/
     +   12H BE USED IS , I5, '.'/34H THE SPECTRUM FOR THE REQUESTED LA,
     +   8HG WINDOW, 10H POINT OF , I5, ','/24H THEREFORE, CANNOT BE CO,
     +   7HMPUTED.)
 1070 FORMAT (48H -- SMOOTHED FOURIER SPECTRUM (SQUARED COHERENCY,
     +   46H COMPONENT) (+), 95 PCT. CONFIDENCE LIMITS (.),
     +   38H AND 95 PCT. SIGNIFICANCE LEVEL (-) --)
 1080 FORMAT (32H -- SMOOTHED FOURIER SPECTRUM --)
      END
!SETRV
      SUBROUTINE SETRV(VECTOR, N, VALUE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SETS THE FIRST N ELEMENTS OF VECTOR
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VALUE
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VECTOR(N)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        *
!     INTEGER N
!        NUMBER OF ELEMENTS TO SET
!     DOUBLE PRECISION VALUE
!        VALUE TO WHICH THE ELEMENTS ARE TO BE SET
!     DOUBLE PRECISION VECTOR(N)
!        VECTOR WHOSE FIRST N ELEMENTS ARE TO BE SET.
!
      DO 10 I=1,N
         VECTOR(I) = VALUE
   10 CONTINUE
!
      RETURN
!
      END
!NLOUT
      SUBROUTINE NLOUT(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, IFIXD,
     +   PAR, NPAR, NPARE, RES, IPTOUT, NDIGIT, PAGE, IDF, COND, RSS,
     +   RSD, YSS, EXACT, PV, SDPV, SDRES, VCVL, LVCVL, IVCVPT, ISKULL,
     +   NLHDR, WIDE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS THE FINAL SUMMARY OUTPUT FROM THE
!     NONLINEAR LEAST SQUARES SUBOUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   COND,RSD,RSS,YSS
      INTEGER
     +   IDF,IVCVPT,IXM,LVCVL,LWT,M,N,NDIGIT,NNZW,NPAR,NPARE
      LOGICAL
     +   EXACT,PAGE,WEIGHT,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PV(N),RES(N),SDPV(N),SDRES(N),VCVL(LVCVL),WT(LWT),
     +   XM(IXM,M),Y(N)
      INTEGER
     +   IFIXD(NPAR),IPTOUT(NDIGIT),ISKULL(10)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL NLHDR
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM,PLL,PUL,RATIO,SDPAR,T
      INTEGER
     +   I,IPK,IPK2,IPRT,ISUBHD
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   PPFT,D1MACH
      EXTERNAL PPFT,D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL FITPT1,FITPT2,IPRINT,NLSKL,VCVOTF
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX,SQRT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION COND
!        THE CONDITION NUMBER OF D.
!     LOGICAL EXACT
!        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
!        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IDF
!        THE DEGREES OF FREEDOM IN THE FIT.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IPK
!        AN INDEX.
!     INTEGER IPK2
!        THE INDEX OF THE "DIAGONAL" ELEMENT OF THE VCV
!        MATRIX.
!     INTEGER IPRT
!        THE LOGICAL UNIT FOR PRINTED OUTPUT.
!     INTEGER IPTOUT(NDIGIT)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER ISKULL(10)
!        AN ERROR MESSAGE INDICATOR VARIABLE.
!     INTEGER ISUBHD
!        AN INTEGER VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IVCVPT
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
!        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
!        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)
!        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                       *INVERSE(HESSIAN)
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LVCVL
!        THE LENGTH OF THE VECTOR CONTAINING
!        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     EXTERNAL NLHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE PARAMETER ESTIMATES.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE OUTPUT
!        IS TO BEGIN ON A NEW PAGE.
!     DOUBLE PRECISION PLL, PUL
!        THE LOWER AND UPPER CONFIDENCE LIMITS FOR A GIVEN PARAMETER.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RATIO
!        THE RATIO OF A GIVEN PARAMETER VALUE TO ITS STANDARD ERROR.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     DOUBLE PRECISION RSS
!        THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION SDPAR
!        THE STANDARD DEVIATION OF A GIVEN PARAMETER VALUE.
!     DOUBLE PRECISION SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION T
!        THE VALUE OF THE 97.5 PERCENT POINT FUNCTION FOR THE
!        T DISTRIBUTION.
!     DOUBLE PRECISION VCVL(LVCVL)
!        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!     DOUBLE PRECISION YSS
!        THE SUM OF SQUARES OF THE DEPENDENT VARIABLE Y.
!
!
      FPLM = D1MACH(2)
!
      CALL IPRINT(IPRT)
!
      IF ((IERR.GE.1) .AND. (IERR.NE.4)) GO TO 60
!
!     TEST FOR EXACT FIT
!
      IF ((IDF.LE.0) .OR. EXACT) GO TO 70
!
!     PRINT ERROR HEADING IF NECESSARY
!
      IF (IERR.EQ.4) CALL NLSKL(ISKULL, PAGE, WIDE, NLHDR)
!
!     PRINT PRIMARY REPORT
!
      IF ((IERR.EQ.0) .AND. (IPTOUT(3).EQ.0)) GO TO 10
      ISUBHD = 0
      CALL NLHDR(PAGE, WIDE, ISUBHD)
      CALL FITPT1(N, M, XM, Y, PV, SDPV, RES, SDRES, WT, IXM, NNZW,
     +   WEIGHT, MAX(1, IPTOUT(3)))
!
!     PRINT STANDARDIZED RESIDUAL PLOTS
!
   10 IF (IPTOUT(4).EQ.0) GO TO 20
      ISUBHD = 0
      CALL NLHDR(PAGE, WIDE, ISUBHD)
!
      CALL FITPT2 (SDRES, PV, WT, N, NNZW, WEIGHT, RES, RSS)
!
!     PRINT THE COVARIANCE AND CORRELATION MATRIX
!
   20 IF ((IERR.EQ.0) .AND. (IPTOUT(5).EQ.0)) RETURN
      ISUBHD = 0
      CALL NLHDR(PAGE, WIDE, ISUBHD)
!
      IF ((IERR.EQ.0) .AND. (IPTOUT(5).LE.1)) GO TO 30
!
      CALL VCVOTF(NPARE, VCVL, LVCVL, .TRUE., NPAR, IFIXD, IVCVPT)
!
!     PRINT ANALYSIS SUMMARY
!
   30 WRITE (IPRT,1000)
      WRITE (IPRT,1010)
!
      T = PPFT(0.975D0,IDF)
      IPK = 0
      DO 50 I=1,NPAR
!
         IF (IFIXD(I).EQ.0) GO TO 40
!
         WRITE (IPRT,1030) I, PAR(I)
         GO TO 50
!
   40    IPK = IPK + 1
         IPK2 = IPK*(IPK-1)/2 + IPK
         RATIO = FPLM
         SDPAR = SQRT(VCVL(IPK2))
         IF (SDPAR.GT.0.0D0) RATIO = PAR(I)/SDPAR
         PLL = PAR(I) - T*SDPAR
         PUL = PAR(I) + T*SDPAR
         WRITE (IPRT,1020) I, PAR(I), SDPAR, RATIO, PLL, PUL
   50 CONTINUE
      WRITE (IPRT,1040) RSS, RSD, NNZW, NPARE, IDF
      WRITE (IPRT,1050) COND
!
      IF (RSS.GT.YSS) WRITE (IPRT,1060)
!
      RETURN
!
!     PRINT OUT ERROR HEADING
!
   60 CALL NLSKL(ISKULL, PAGE, WIDE, NLHDR)
!
      IF (IERR.LE.2) RETURN
!
!     PRINT SECONDARY REPORT
!
   70 CONTINUE
      ISUBHD = 0
      CALL NLHDR(PAGE, WIDE, ISUBHD)
      IF (IERR.NE.0) WRITE (IPRT,1080)
      WRITE (IPRT,1000)
      WRITE (IPRT,1100)
      DO 80 I=1,NPAR
         IF (IFIXD(I).EQ.0) WRITE (IPRT,1110) I, PAR(I)
         IF (IFIXD(I).NE.0) WRITE (IPRT,1120) I, PAR(I)
   80 CONTINUE
      WRITE (IPRT,1040) RSS, RSD, NNZW, NPARE, IDF
      IF (IERR.NE.3) WRITE (IPRT,1050) COND
!
      IF ((IERR.EQ.0) .AND. (.NOT.EXACT) .AND. (IDF.LE.0)) WRITE
     +   (IPRT,1070)
      IF ((IERR.EQ.0) .AND. EXACT) WRITE (IPRT,1090)
!
      IF (IERR.NE.0) GO TO 100
!
      DO 90 I=1,N
         SDRES(I) = 0.0D0
         SDPV(I) = 0.0D0
   90 CONTINUE
!
      RETURN
!
  100 CONTINUE
!
      DO 110 I=1,N
         SDRES(I) = FPLM
         SDPV(I) = FPLM
  110 CONTINUE
!
!     PRINT OUT ERROR EXIT STATISTICS
!
      CALL FITPT1(N, M, XM, Y, PV, SDPV, RES, SDRES, WT, IXM, NNZW,
     +   WEIGHT, MAX(IPTOUT(3),1))
!
!
!     WIPE OUT SDRES VECTOR
!
      DO 120 I=1,N
         SDRES(I) = FPLM
  120 CONTINUE
!
!     WIPE OUT VCV MATRIX
!
      DO 140 I=1,LVCVL
         VCVL(I) = FPLM
  140 CONTINUE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (///33H ESTIMATES FROM LEAST SQUARES FIT/1X, 33('-'))
 1010 FORMAT (//69X, 11HAPPROXIMATE/61X, 28H95 PERCENT CONFIDENCE LIMITS
     +   /1X, 5HINDEX, 2X, 5HFIXED, 3X, 9HPARAMETER, 8X, 9HSD OF PAR,
     +   7X, 5HRATIO, 12X, 5HLOWER, 12X, 5HUPPER/)
 1020 FORMAT (1X, I3, 5X, 3H NO, 2G17.8, 2X, G10.4, 2G17.8)
 1030 FORMAT (1X, I3, 5X, 3HYES, G17.8, 10X, 3H---, 8X, 3H---, 15X,
     +   3H---, 14X, 3H---)
 1040 FORMAT (//31H RESIDUAL SUM OF SQUARES       , 8X, G15.7//6H RESID,
     +   25HUAL STANDARD DEVIATION   , 8X, G15.7/19H BASED ON DEGREES O,
     +   9HF FREEDOM, 5X, I4, 3H - , I3, 3H = , I4)
 1050 FORMAT (/29H APPROXIMATE CONDITION NUMBER, 10X, G15.7)
 1060 FORMAT (52H THE RESIDUAL SUM OF SQUARES AFTER THE LEAST SQUARES,
     +   20H FIT IS GREATER THAN/35H THE SUM OF SQUARES ABOUT THE MEAN ,
     +   19HY OBSERVATION.  THE, 14H MODEL IS LESS/17H REPRESENTATIVE O,
     +   39HF THE DATA THAN A SIMPLE AVERAGE.  DATA, 15H AND MODEL SHOU,
     +   2HLD/48H BE CHECKED TO BE SURE THAT THEY ARE COMPATABLE.)
 1070 FORMAT (/49H THE DEGREES OF FREEDOM FOR THIS PROBLEM IS ZERO.,
     +   54H  STATISTICAL ANALYSIS OF THE RESULTS IS NOT POSSIBLE.)
 1080 FORMAT (//40H THE FOLLOWING SUMMARY SHOULD BE USED TO, 8H ANALYZE,
     +   30H THE ABOVE MENTIONED PROBLEMS.)
 1090 FORMAT (/50H THE LEAST SQUARES FIT OF THE DATA TO THE MODEL IS,
     +   35H EXACT TO WITHIN MACHINE PRECISION./20H STATISTICAL ANALYSI,
     +   33HS OF THE RESULTS IS NOT POSSIBLE.)
 1100 FORMAT (//1X, 5HINDEX, 2X, 5HFIXED, 3X, 9HPARAMETER)
 1110 FORMAT (1X, I3, 5X, 3H NO, G17.8)
 1120 FORMAT (1X, I3, 5X, 3HYES, G17.8)
      END
!MATPRF
      SUBROUTINE MATPRF(X, Y, NC, MODE, CODE, LENGTH, MASK, LMASK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THISROUTINE PRINTS A SQUARE MATRIX STORED IN SYMMETRIC
!     FORM.
!
!     WRITTEN BY - JOHN E. KOONTZ
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!        BASED ON THE JULY 1982 VERSION OF MATPRT, BY LINDA L. MITCHELL.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   CODE,LENGTH,LMASK,MODE,NC
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(LENGTH),Y(LENGTH)
      INTEGER
     +   MASK(LMASK)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   SQXII,SQYII
      INTEGER
     +   I,I0,II,IK,IMASK,IPRT,J,JMASK,K,KI,KK,KM,KMAX,KN,L,NF,
     +   NLINE
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   XLINE(10),YLINE(10)
      INTEGER
     +   INDW(10)
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   INPERL
      EXTERNAL INPERL
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CODE
!        IF 1 -SINGLE PRINTED, X ONLY (Y IS DUMMY ARG)
!           2 -DOUBLE PRINTED LINE, BOTH X AND Y
!     INTEGER I
!        ROW NUMBER
!     INTEGER II
!        THE INDEX OF THE (I,I)TH ELEMENT OF THE VCV MATRIX
!     INTEGER IK
!        THE INDEX OF THE (I,K)TH ELEMENT OF THE VCV MATRIX
!     INTEGER I0
!        THE INDEX OF THE ((I,I)-1)TH ELEMENT OF THE VCV MATRIX
!     INTEGER IMASK
!        INDEX IN MASK FOR LABELLING OF THE ROW DIMENSION.
!     INTEGER INDW(10)
!        A WORK VECTOR FOR THE INDICES TO BE PRINTED FOR THE
!        MATRIX.
!     INTEGER IPRT
!        THE OUTPUT UNIT NUMBER
!     INTEGER J
!        FIRST COLUMN IN THE SET TO BE PRINTED
!     INTEGER JMASK
!        INDEX IN MASK FOR LABELLING OF THE COLUMN DIMENSION.
!     INTEGER K
!        COLUMN NUMBER IN THE POSSIBLE SET OF NF
!     INTEGER KI
!        THE INDEX OF THE (K,I)TH ELEMENT OF THE VCV MATRIX
!     INTEGER KK
!        THE INDEX OF THE (K,K)TH ELEMENT OF THE VCV MATRIX
!     INTEGER KM
!        LAST COLUMN IN THE SET
!        LIMITED TO VALUES OF J-1 PLUS A NUMBER BETWEEN 1 AND
!        NF (INCLUSIVE)
!     INTEGER KMAX
!        INDEX IN INDW OF THE LARGEST INDEX TO BE PRINTED FOR
!        MATRIX.
!     INTEGER KN
!        LAST COLUMN TO PRINT WHEN PRINTING LOWER TRIANGLE
!     INTEGER L
!        FIRST ROW TO PRINT FOR THIS SET
!     INTEGER LMASK
!        LENGTH OF MASK.
!     INTEGER LENGTH
!        LENGTH OF X AND Y
!     INTEGER MASK(LMASK)
!        MASK VECTOR FOR VCV.  THE INDEX OF THE ITH ELEMENT OF
!        MASK EQUAL TO ZERO IS THE LABEL IN THE OUTPUT OF VCV
!        IN OF THE ITH ROW AND ITH COLUMN.
!     INTEGER MODE
!        IF 0, LOWER TRIANGULAR PART PRINTED
!           1, LOWER TRIANGULAR PART IS PRINTED WITH
!              SQUARE ROOTS OF THE DIAGONAL
!           2, LOWER TRIANGLE PRINTED AS CORRELATION MATRIX
!              WITH SQUARE ROOTS ON THE DIAGONAL
!           3, FULL MATRIX PRINTED
!           4, FULL MATRIX PRINTED WITH CORRELATION MATRIX
!              PRINTED BELOW THE DIAGONAL
!     INTEGER NC
!        ROW AND COLUMN DIMENSION OF X
!     INTEGER NF
!        THE NUMBER OF COLUMNS THAT CAN BE PRINTED, GIVEN
!        THE WIDTH IWIDTH OF THE OUTPUT DEVICE.
!     INTEGER NLINE
!        THE NUMBER OF VALUES TO BE PRINTED EACH LINE.
!     DOUBLE PRECISION SQXII, SQYII
!        THE SQUARE ROOT OF THE (I,I)TH ELEMENT OF X AND Y.
!     DOUBLE PRECISION X(LENGTH)
!        INPUT SYMMETRIC ARRAY STORED ROW WISE
!     DOUBLE PRECISION XLINE(10)
!        THE CURRENT VALUES BEING PRINTED FROM ARRAY X.
!     DOUBLE PRECISION Y(LENGTH)
!        ARRAY TO BE PRINTED ON THE SECOND LEVEL IF CODE=2
!     DOUBLE PRECISION YLINE(10)
!        THE CURRENT VALUES BEING PRINTED FROM ARRAY Y.
!
!     BODY OF ROUTINE
!
      CALL IPRINT(IPRT)
!
      NF = INPERL(0)
!
      L = 1
      JMASK = 0
!
!     SELECT INITIAL COLUMN TO PRINT THIS PASS OF THE REPORT
!
      DO 90 J=1,NC,NF
         KN = MIN(NC,J+NF-1)
         KMAX = MIN(NC-J+1,NF)
!
!     GENERATE VECTOR OF COLUMN HEAD LABELS
!
         DO 20 K=1,KMAX
   10       IF (JMASK.GE.LMASK) GO TO 100
            JMASK = JMASK + 1
            IF (MASK(JMASK).NE.0) GO TO 10
            INDW(K) = JMASK
   20    CONTINUE
!
!     PRINT VECTOR OF COLUMN HEAD LABELS
!
         WRITE (IPRT,1000) (INDW(K),K=1,KMAX)
         WRITE (IPRT,1030)
         IF (MODE.LE.2) L = INDW(1)
!
!     PRINT ALL ROWS IN COLUMN RANGE FOR THIS PASS
!
         IMASK = L - 1
         DO 80 I=L,NC
            KM = KN
            IF (MODE.LE.2) KM = J + MIN(I-L,NF-1)
            NLINE = 0
            I0 = I*(I-1)/2
            II = I0 + I
            SQXII = SQRT(X(II))
            IF (CODE.EQ.2) THEN
               SQYII = SQRT(Y(II))
            ELSE
               SQYII = 1.0D0
            END IF
            DO 60 K=J,KM
               NLINE = NLINE + 1
               IF (K.GT.I) GO TO 30
               IK = I0 + K
               XLINE(NLINE) = X(IK)
               IF (CODE.EQ.2) YLINE(NLINE) = Y(IK)
               GO TO 40
   30          KI = K*(K-1)/2 + I
               XLINE(NLINE) = X(KI)
               IF (CODE.EQ.2) YLINE(NLINE) = Y(KI)
   40          IF (((MODE.NE.1) .AND. (MODE.NE.2)) .OR. (I.NE.K)) GO TO
     +            50
               XLINE(NLINE) = SQXII
               IF (CODE.EQ.2) YLINE(NLINE) = SQXII
   50          IF (((MODE.NE.2) .AND. (MODE.NE.4)) .OR. (K.GE.I)) GO TO
     +            60
               KK = K*(K-1)/2 + K
               XLINE(NLINE) = XLINE(NLINE)/(SQXII*SQRT(X(KK)))
               IF (CODE.EQ.2)
     +            YLINE(NLINE) = YLINE(NLINE)/(SQYII*SQRT(Y(KK)))
   60       CONTINUE
   70       IF (IMASK.GE.LMASK) GO TO 100
            IMASK = IMASK + 1
            IF (MASK(IMASK).NE.0) GO TO 70
            WRITE (IPRT,1010) IMASK, (XLINE(K),K=1,NLINE)
            IF (CODE.EQ.2) WRITE (IPRT,1020) (YLINE(K),K=1,NLINE)
            IF (CODE.EQ.2) WRITE (IPRT,1030)
   80    CONTINUE
   90 CONTINUE
      RETURN
!
  100 WRITE (IPRT,1040)
      RETURN
!
!     FORMAT STATEMENTS
!
!
 1000 FORMAT (/' ', 7HCOLUMN , 7(I9, 8X))
 1010 FORMAT (' ', I6, 1X, 7(3X, G14.7))
 1020 FORMAT (' ', 5X, 7(3X, G14.7))
 1030 FORMAT (' ')
 1040 FORMAT (/47H ERROR IN STARPAC.  MATPRF TRIES TO ACCESS MORE,
     +   29H ELEMENTS THAN EXIST IN MASK.)
      END
!SUMWTS
      SUBROUTINE SUMWTS(X, W, N, NNZW, ALPHA, SUMT1, SUMTW1, XTRM,
     +   XTRMW)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO CALCULATE THE WEIGHTED AND UNWEIGHTED MEANS
!     FOR A SORTED VECTOR IN WHICH THE MIDTH ELEMENT IS THE
!     ELEMENT CLOSEST TO ZERO.  USED BY THE STAT FAMILY.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALPHA,SUMT1,SUMTW1,XTRM,XTRMW
      INTEGER
     +   N,NNZW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   W(N),X(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   SUMW
      INTEGER
     +   CURHI,CURLO,I,IREV,ITHI,ITLO,MID,NALPHA,NUM
!
!  EXTERNAL SUBROUTINES
      EXTERNAL SUMBS
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,MIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        INPUT PARAMETER.  THE PERCENTAGE OF POINTS TO TRIM
!        FROM EACH END OF THE ARRAY X FOR THE TRIMMED MEAN.
!     INTEGER CURHI
!        THE UPPER BOUND OF THE CURRENT INTERVAL.
!     INTEGER CURLO
!        THE LOWER BOUND OF THE CURRENT INTERVAL.
!     INTEGER I
!        LOOP PARAMETER.
!     INTEGER IREV
!        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
!        IN THE REVERSE ORDER.
!     INTEGER ITHI
!        THE COMPUTED UPPER BOUND SUCH THAT ALPHA PER
!        CENT OF THE POSITIVELY WEIGHTED POINTS ARE
!        OMITTED.
!     INTEGER ITLO
!        THE COMPUTED LOWER BOUND SUCH THAT ALPHA PER
!        CENT OF THE POSITIVELY WEIGHTED POINTS ARE
!        OMITTED.
!     INTEGER MID
!        THE INDEX OF THE ELEMENT IN X CLOSEST TO ZERO IN VALUE.
!        THE POINT OUT FROM WHICH THE SUMMING IS DONE.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
!     INTEGER NALPHA
!          THE INTEGER WHICH IS ALPHA PER CENT OF N.
!     INTEGER NNZW
!        INPUT PARAMETER.  THE NUMBER OF POSITIVELY WEIGHTED
!        VALUES IN X.
!     INTEGER NUM
!        THE NUMBER OF POINTS OMITTED SO FAR.
!     DOUBLE PRECISION SUMTW1
!        OUTPUT PARAMETER.  THE WEIGHTED SUM OF THE TRIMMED ARRAY
!        X.
!     DOUBLE PRECISION SUMT1
!        OUTPUT PARAMETER.  THE UNWEIGHTED SUM OF THE TRIMMED
!        ARRAY.  ZERO-WEIGHTED ELEMENTS ARE OMITTED.
!     DOUBLE PRECISION SUMW
!        THE SUM OF THE WEIGHTS W(I).
!     DOUBLE PRECISION W(N)
!        INPUT PARAMETER.  THE ARRAY OF WEIGHTS.
!     DOUBLE PRECISION X(N)
!        INPUT PARAMETER.  THE DATA ARRAY X IN WHICH THE SUMS ARE TAKEN.
!     DOUBLE PRECISION XTRM
!        OUTPUT PARAMETER.  THE UNWEIGHTED, TRIMMED MEAN OF X.
!     DOUBLE PRECISION XTRMW
!        OUTPUT PARAMETER.  THE WEIGHTED, TRIMMED MEAN OF X.
!
!     SET UP LIMITS TRIMMING THE NUMBER OF NON-ZERO WEIGHTED
!     VALUES BY ALPHA PER CENT AT EACH END OF THE RANGE OF
!     VALUES.
!
      NALPHA = ALPHA*NNZW
      NUM = 0
      DO 10 I=1,N
         IF (W(I).EQ.0.0D0) GO TO 10
         NUM = NUM + 1
         IF (NUM.EQ.NALPHA+1) GO TO 20
   10 CONTINUE
   20 ITLO = I
      NUM = 0
      DO 30 I=1,N
         IREV = N - I + 1
         IF (W(IREV).EQ.0.0D0) GO TO 30
         NUM = NUM + 1
         IF (NUM.EQ.NALPHA+1) GO TO 40
   30 CONTINUE
   40 ITHI = IREV
      CALL SUMBS(X, N, ITLO, MID, ITHI)
!
!     INITIALIZE SUMMATION VARIABLES.
!
      SUMT1 = 0.0D0
      SUMTW1 = 0.0D0
      SUMW = 0.0D0
      IF (W(MID).EQ.0.0D0) GO TO 50
      SUMT1 = X(MID)
      SUMTW1 = W(MID)*X(MID)
      SUMW = W(MID)
   50 CURLO = MID - 1
      CURHI = MID + 1
!
!     SUM OUTWARDS, BOULDER, COLORADO FROM THE VALUE NEAREST ZERO.  THAT
!     THE LEAST IN MAGNITUDE TO THE GREATEST.
!
   60 IF (CURHI.GT.ITHI .OR. CURLO.LT.ITLO) GO TO 100
      IF (ABS(X(CURHI)).LT.ABS(X(CURLO))) GO TO 80
      IF (W(CURLO).EQ.0.0D0) GO TO 70
      SUMT1 = SUMT1 + X(CURLO)
      SUMTW1 = SUMTW1 + W(CURLO)*X(CURLO)
      SUMW = SUMW + W(CURLO)
   70 CURLO = CURLO - 1
      GO TO 60
   80 IF (W(CURHI).EQ.0.0D0) GO TO 90
      SUMT1 = SUMT1 + X(CURHI)
      SUMTW1 = SUMTW1 + W(CURHI)*X(CURHI)
      SUMW = SUMW + W(CURHI)
   90 CURHI = CURHI + 1
      GO TO 60
!
!     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
!     CENTER ZERO POINT.
!
  100 IF (CURHI.GT.ITHI) GO TO 120
      CURHI = MAX(CURHI,ITLO)
      DO 110 I=CURHI,ITHI
         IF (W(I).EQ.0.0D0) GO TO 110
         SUMT1 = SUMT1 + X(I)
         SUMTW1 = SUMTW1 + W(I)*X(I)
         SUMW = SUMW + W(I)
  110 CONTINUE
  120 IF (CURLO.LT.ITLO) GO TO 140
      CURLO = MIN(CURLO,ITHI)
      DO 130 IREV=ITLO,CURLO
         I = ITLO - IREV + CURLO
         IF (W(I).EQ.0.0D0) GO TO 130
         SUMT1 = SUMT1 + X(I)
         SUMTW1 = SUMTW1 + W(I)*X(I)
         SUMW = SUMW + W(I)
  130 CONTINUE
  140 XTRM = SUMT1/(NNZW-2*NALPHA)
      XTRMW = SUMTW1/SUMW
      RETURN
      END
!CDFF
      DOUBLE PRECISION FUNCTION CDFF(F, DF1, DF2)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION FUNCTION FOR
!     THE F DISTRIBUTION.  THE APPROXIMATION USED DEPENDS ON THE
!     DEGREES OF FREEDOM IN THE NUMERATOR AND DENOMINATOR.
!     1.  IF BOTH DEGREES OF FREEDOM ARE SMALL (LESS THAN 4000),
!         THE CDF IS COMPUTED FROM THE INCOMPLETE BETA FUNCTION
!         USING EQUATION 5.45 OF STATISTICAL COMPUTING, BY KENNEDY AND
!         GENTLE.
!     2.  IF ONE OF THE DEGREES OF FREEDOM IS LARGE (GREATER THAN OR
!         EQUAL TO 4000) AND THE OTHER IS MODERATELY LARGE (GREATER THAN
!         OR EQUAL TO 100), THE CDF IS APPROXIMATED BY A NORMAL DISTRIB-
!         BUTION AS SHOWN IN EQUATION 20 ON PAGE 83 OF DISTRIBUTIONS IN
!         STATISTICS - CONTINUOUS UNIVARIATE DISTRIBUTIONS - 2, BY
!         JOHNSON AND KOTZ.
!     3.  IF ONE OF THE DEGREES OF FREEDOM IS SMALL (LESS THAN 100) AND
!         THE OTHER IS LARGE (EXCEEDING 4000), THE CDF IS APPROXIMATED
!         BY A CHI SQUARED DISTRIBUTION AS SHOWN IN THE THIRD EQUATION
!         ON PAGE 84 OF DISTRIBUTIONS IN STATISTICS - CONTINUOUS
!         UNIVARIATE DISTRIBUTIONS - 2, BY JOHNSON AND KOTZ.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE - DECEMBER 7, 1981
!                     THIS ROUTINE IS MODELED AFTER DATAPAC ROUTINE FCDF.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DF1,DF2,F
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FTRANS
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   DBETAI,CDFCHI,CDFNML
      EXTERNAL DBETAI,CDFCHI,CDFNML
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DF1
!        THE DEGREES OF FREEDOM IN THE NUMERATOR.
!     DOUBLE PRECISION DF2
!        THE DEGREES OF FREEDOM IN THE DENOMINATOR.
!     DOUBLE PRECISION F
!        THE PERCENTAGE POINT FROM THE F DISTRIBUTION.
!     DOUBLE PRECISION FTRANS
!        TRANSFORMS OF THE F PERCENTAGE POINT, USED FOR THE VARIOUS
!        APPROXIMATING DISTRIBUTIONS.
!
!     COMMENCE BODY OF ROUTINE
!
      IF (F.GT.0.0D0) GO TO 5
      CDFF = 0.0D0
      RETURN
!
    5 CONTINUE
!
      IF ((DF1.GT.4000.0D0) .OR. (DF2.GT.4000.0D0)) GO TO 10
!
!     BOTH DEGREES OF FREEDOM ARE LESS THAN OR EQUAL TO 4000.  USE
!     THE INCOMPLETE BETA FUNCTION TO COMPUTE THE F CDF.
!
      FTRANS = DF2 / (DF2 + DF1 * F)
!
      CDFF = 1.0D0 - DBETAI(FTRANS, 0.5D0*DF2, 0.5D0*DF1)
      RETURN
!
   10 IF ((DF1.LE.100.0D0) .OR. (DF2.LE.100.0D0)) GO TO 20
!
!     BOTH DEGREES OF FREEDOM EXCEED 4000.  USE THE NORMAL APPROXIMATION
!     TO COMPUTE THE F CDF.
!
      FTRANS =
     +   (((1.0D0-(2.0D0/(9.0D0*DF2)))*
     +     (F**(1.0D0/3.0D0)))-(1.0D0-(2.0D0/(9.0D0*DF1)))) /
     +   SQRT(((F**(2.0D0/3.0D0))/(4.5D0*DF2))+(2.0D0/(9.0D0*DF1)))
!
      CDFF = CDFNML(FTRANS)
      RETURN
!
   20 IF (DF1.GT.100.0D0) GO TO 30
!
!     THE DEGREES OF FREEDOM IN THE DENOMINATOR EXCEEDS 4000 AND THE
!     DEGREES OF FREEDOM IN NUMERATOR IS LESS THAN OR EQUAL TO 100.
!     USE THE CHI SQUARE APPROXIMATION TO COMPUTE THE F CDF.
!
      FTRANS =
     +   (DF1 + (DF1/DF2)*(0.5D0*DF1-1.0D0))/
     +   ((1.0D0/F)+(DF1/DF2)*0.5D0)
!
      CDFF = CDFCHI(FTRANS, DF1)
!
      RETURN
!
   30 CONTINUE
!
!     THE DEGREES OF FREEDOM IN THE NUMERATOR EXCEEDS 4000 AND THE
!     DEGREES OF FREEDOM IN DENOMINATOR IS LESS THAN OR EQUAL TO 100.
!     USE THE CHI SQUARE APPROXIMATION TO COMPUTE THE F CDF.
!
      FTRANS =
     +   (DF2+(DF2/DF1)*(0.5D0*DF2-1.0D0))/(F+(DF2/DF1)*0.5D0)
!
      CDFF = 1.0D0 - CDFCHI(FTRANS, DF2)
!
      RETURN
!
      END
!LPCOEF
      SUBROUTINE LPCOEF (FC, K, HLP)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES THE K-TERM LEAST SQUARES
!     APPROXIMATION TO AN -IDEAL- LOW PASS FILTER
!     WITH CUTOF FREQUENCY FC.  ITS TRANSFER FUNCTION
!     HAS A TRANSITION BAND OF WIDTH DELTA SURROUNDING FC,
!     WHERE DELTA = 4*PI/K.
!
!     WRITTEN BY  -  PETER BLOOMFIELD
!                    FOURIER ANALYSIS OF TIME SERIES- AN
!                       INTRODUCTION
!                    JOHN WILEY AND SONS, NEW YORK, 1976
!                    PAGE 149
!     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
!                                STATISTICAL ENGINEERING DIVISION
!                                NATIONAL BUREAU OF STANDARDS
!                                BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC
      INTEGER
     +   K
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   HLP(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,HEAD
!
!  LOCAL ARRAYS
      CHARACTER
     +   LFC(8)*1,LK(8)*1,NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISII,ERIODD,ERSII,ERSLFS,IPRINT,LPFLT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03, ERR04
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION FC
!        THE USER SUPPLIED CUTOFF FREQUENCY.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     DOUBLE PRECISION HLP(K)
!        THE ARRAY IN WHICH THE -IDEAL- LOW PASS FILTER COEFFICIENTS
!        WILL BE RETURNED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS TO BE COMPUTED.
!     CHARACTER*1 LFC(8), LK(8)
!        THE ARRAY CONTAINING THE NAMES OF THE VARIABLES FC AND K.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'L',       'P',       'C',       'O',       'E',       'F'/
      DATA
     +  LFC(1), LFC(2), LFC(3), LFC(4), LFC(5), LFC(6), LFC(7), LFC(8)
     + /  'F',   'C',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL ERSII(NMSUB, LFC, FC, 0.0D0, 0.5D0, 2, HEAD, ERR01, LFC, LFC)
!
      CALL EISII(NMSUB, LK, K, 1, K, 2, HEAD, ERR02, LK, LK)
!
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR03)
!
      IF (ERR01 .OR. ERR02 .OR. ERR03) GO TO 10
!
      CALL ERSLFS(NMSUB, FC, K, HEAD, ERR04)
!
      IF (.NOT. ERR04) GO TO 20
!
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   20 CONTINUE
!
      CALL LPFLT (FC, K, HLP)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   31H       CALL LPCOEF (FC, K, HLP))
      END
!STPSEL
      SUBROUTINE STPSEL(XM, N, M, IXM, MDL, PAR, NPAR,
     +   NEXMPT, STP, NFAIL, IFAIL, J, ETA3, RELTOL, ABSTOL, TAUABS,
     +   STPLOW, STPMID, STPUP, ITEMP, FD, FDLAST, FDSAVE, PV, PVNEW)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE SELECTS NEW STEP SIZES UNITL EITHER
!     THE NUMBER OF OBSERVATIONS AT WHICH THE SELECTION CRITERIA
!     IS NOT MET DOES NOT EXCEED NEXMPT OR UNTIL NO FURTHER
!     IMPROVEMENT CAN BE MADE.
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ABSTOL,ETA3,RELTOL,STP,STPLOW,STPMID,STPUP,TAUABS
      INTEGER
     +   IXM,J,M,N,NEXMPT,NFAIL,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FD(N),FDLAST(N),FDSAVE(N),PAR(NPAR),PV(N),PVNEW(N),XM(IXM,M)
      INTEGER
     +   IFAIL(N),ITEMP(N)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  SCALARS IN COMMON
      DOUBLE PRECISION
     +   Q
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FACTOR,STP1,STP2,STPNEW,TEMP
      INTEGER
     +   NCOUNT
      LOGICAL
     +   FAIL,FIRST,FORWRD,HICURV,SUCCES
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ABSCOM,CMPFD,ICOPY,RELCOM,DCOPY,STPADJ
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS
!
!  COMMON BLOCKS
      COMMON /NOTOPT/Q
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ABSTOL
!        THE ABSOLUTE AGREEMENT TOLERANCE.
!     DOUBLE PRECISION ETA3
!        THE CUBE ROOT OF THE RELATIVE NOISE IN THE MODEL
!     DOUBLE PRECISION FACTOR
!        A FACTOR USED IN COMPUTING THE STEP SIZE.
!     LOGICAL FAIL
!        THE VARIABLE USED TO INDICATE WHETHER A STEP SIZE
!        CANNOT BE SELECTED WHICH WILL SUCCESSFULLY MEET THE CRITERIA.
!     DOUBLE PRECISION FD(N)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!     DOUBLE PRECISION FDLAST(N)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!        COMPUTED WITH THE MOST RECENT STEP SIZE SELECTED.
!     DOUBLE PRECISION FDSAVE(N)
!        A VECTOR USED TO SAVE THE BEST OF THE
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATIONS TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!     LOGICAL FIRST
!        THE VARIABLE USED TO INDICATE WHETHER THIS STEP SIZE
!        IS BEING USED FOR THE FIRST TIME OR WHETHER IT HAS BEEN
!        PREVIOUSLY ADJUSTED.
!     LOGICAL FORWRD
!        THE VARIABLE USED TO INDICATE THE DIRECTION OF CHANGE IN
!        THE STEP SIZE.
!     LOGICAL HICURV
!        THE VARIABLE USED TO INDICATE WHETHER THE MODEL HAS
!        HIGH CURVATURE.
!     INTEGER IFAIL(N)
!        AN INDICATOR VECTOR USED TO DESIGNATE THOSE OBSERVATIONS
!        FOR WHICH THE STEP SIZE DOES NOT MEET THE CRITERIA.
!     INTEGER ITEMP(N)
!        A TEMPORARY VECTOR USED FOR STORING PAST VALUES OF ITEMP.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NCOUNT
!        THE NUMBER OF OBSERVATIONS AT WHICH THE NEW STEP SIZE DOES
!        SATISFY THE CRITERIA.
!     INTEGER NEXMPT
!        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
!        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
!        SIZE STILL BE CONSIDERED OK.
!     INTEGER NFAIL
!        A VECTOR CONTAINING FOR EACH OBSERVATION THE NUMBER OF
!        OBSERVATIONS FOR WHICH THE STEP SIZE DID NOT MEET THE CRITERIA.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION PVNEW(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCD.
!     DOUBLE PRECISION Q
!        A DUMMY VARIABLE WHICH IS USED, ALONG WITH COMMON NOTOPT (NO
!        OPTIMIZATION), TO COMPUTE THE STEP SIZE.
!     DOUBLE PRECISION STP
!        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FORWARD
!        DIFFERENCE APPROXIMATION TO THE DERIVATIVE.
!     DOUBLE PRECISION STPLOW
!        THE LOWER LIMIT ON THE STEP SIZE.
!     DOUBLE PRECISION STPMID
!        THE MIDPOINT OF THE ACCEPTABLE RANGE OF THE STEP SIZE.
!     DOUBLE PRECISION STPNEW
!        THE VALUE OF THE NEW STEP SIZE BEING TESTED.
!     DOUBLE PRECISION STPUP
!        THE UPPER LIMIT ON THE STEP SIZE.
!     DOUBLE PRECISION STP1, STP2
!        TEMPORARY STORAGE LOCATIONS FOR STEP SIZES.
!     LOGICAL SUCCES
!        THE VARIABLE USED TO INDICATE WHETHER THE STEP SIZE
!        SUCCESSFULLY MEETS THE CRITERIA USED TO SELECT THE STEP
!        SIZES.
!     DOUBLE PRECISION RELTOL
!        THE RELATIVE AGREEMENT TOLERANCE.
!     DOUBLE PRECISION TAUABS
!        THE ABSOLUTE AGREEMENT TOLERANCE.
!     DOUBLE PRECISION TEMP
!        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
!        PARAMETER IS STORED.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      CALL DCOPY(N, FD, 1, FDSAVE, 1)
!
      FACTOR = 10.0D0
      IF (ABS(STP) .GT. STPMID) FACTOR = 0.1D0
!
      STPNEW = STP * FACTOR
      STP1 = STPNEW
      STP2 = STPNEW
!
      Q = STPNEW + PAR(J)
      STPNEW = Q - PAR(J)
!
      FIRST = .TRUE.
      FORWRD = .TRUE.
      SUCCES = .FALSE.
      FAIL = .FALSE.
!
      NFAIL = N + 1
!
!     REPEAT FOLLOWING UNTIL (SUCCES) OR (FAIL)
!
   10 CONTINUE
!
      CALL DCOPY(N, FD, 1, FDLAST, 1)
!
      TEMP = PAR(J)
      PAR(J) = TEMP + STPNEW
!
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVNEW)
!
      PAR(J) = TEMP
!
      CALL CMPFD(N, STPNEW, PVNEW, PV, FD)
!
      CALL RELCOM(N, FD, FDLAST, RELTOL, ABSTOL, NCOUNT, ITEMP)
!
      IF (NCOUNT.LE.NEXMPT) THEN
            SUCCES = .TRUE.
            NFAIL = NCOUNT
            CALL ICOPY(N, ITEMP, 1, IFAIL, 1)
            IF (ABS(ABS(STPNEW) - STPMID) .GT.
     +         ABS(ABS(STPNEW/FACTOR) - STPMID)) THEN
                  STP = STPNEW / FACTOR
            ELSE
                  STP = STPNEW
            END IF
      ELSE
            IF (NCOUNT.LT.NFAIL) THEN
                  NFAIL = NCOUNT
                  STP1 = STPNEW
                  STP2 = STPNEW / FACTOR
                  CALL ICOPY(N, ITEMP, 1, IFAIL, 1)
            END IF
            IF (FIRST) THEN
                  FIRST = .FALSE.
                  CALL ABSCOM(N, FD, FDLAST, TAUABS, NCOUNT)
                  IF (NCOUNT.LE.NEXMPT) THEN
                         HICURV = .TRUE.
                  ELSE
                         HICURV = .FALSE.
                  END IF
            END IF
            STPNEW = STPNEW * FACTOR
            Q = STPNEW + PAR(J)
            STPNEW = Q - PAR(J)
            IF ((FACTOR.GT.1.0D0 .AND. ABS(STPNEW).GT.STPUP) .OR.
     +          (FACTOR.LT.1.0D0 .AND. ABS(STPNEW).LT.STPLOW)) THEN
                  IF (FORWRD) THEN
                        FORWRD = .FALSE.
                        FACTOR = 1.0D0 / FACTOR
                        STPNEW = STP * FACTOR
                        Q = STPNEW + PAR(J)
                        STPNEW = Q - PAR(J)
                        CALL DCOPY(N, FDSAVE, 1, FD, 1)
                        STPLOW = STPLOW * (ETA3)
                        STPUP = STPUP / (ETA3)
                  ELSE
                        FAIL = .TRUE.
                  END IF
            END IF
      END IF
!
      IF (.NOT.(SUCCES.OR.FAIL)) GO TO 10
!
      IF (SUCCES .AND. FORWRD) THEN
            CALL STPADJ(XM, N, M, IXM, MDL, PAR, NPAR,
     +         NEXMPT, STP, NFAIL, IFAIL, J, RELTOL, ABSTOL, STPLOW,
     +         STPMID, STPUP, ITEMP, FD, FDLAST, PV, PVNEW)
            RETURN
      ELSE
            IF (SUCCES) THEN
                  RETURN
            ELSE
!                 IF (HICURV) NFAIL = -NFAIL
!
                  IF (ABS(STP1).LT.ABS(STP2)) THEN
                        STP = STP1
                        RETURN
                  ELSE
                        STP = STP2
                        RETURN
                  END IF
            END IF
      END IF
!
      END
!AOSLST
      SUBROUTINE AOSLST (PRHO, AIC, FTEST, LAGMAX, LAIC, IAR, PHI,
     +   OSPVAR, IFPRHO, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE LISTS THE AUTOREGRESSIVE MODEL ORDER SELECTION
!     STATISTICS.
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   OSPVAR
      INTEGER
     +   IAR,LAGMAX,LAIC,N
      LOGICAL
     +   IFPRHO
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AIC(*),FTEST(2,*),PHI(*),PRHO(*)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IMAX,IMIN,IPRT,LAG,M,NPERL
      CHARACTER
     +   FMT*160
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AIC(LAIC)
!        THE ARRAY CONTAINING THE AKAIKES INFORMATION CRITERION.
!     CHARACTER*160 FMT
!        THE FORMAT USED.
!     DOUBLE PRECISION FTEST(2, LAGMAX)
!        THE ARRAY CONTAINING THE PARTIAL F RATIO AND ITS PROBABILITY
!        OF BEING EXCEEDED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE MODEL SELECTED.
!     LOGICAL IFPRHO
!        THE LOGICAL VARIABLE USED TO INDICATE IF THE PARTIAL
!        AUTOCORRELATIONS ARE BEING PRINTED.  IF -IFPRHO- IS
!        .FALSE. THE AUTOCORRELATIONA AND THEIR STANDARD ERRORS
!        ARE PRINTED,  IF .TRUE., THE PARTIALS.
!     INTEGER IMAX, IMIN
!        THE INDEX VALUES OF THE FIRST AND LAST OBSERVATION
!        TO BE PRINTED PER LINE
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT
!     INTEGER LAG
!        THE LAG VALUE OF THE AUTOREGRESSIVE ORDER SELECTION STATISTIC
!        BEING PRINTED.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG AT WHICH THE AUTOREGRESSIVE ORDER SELECTION
!        STATISTICS WERE COMPUTED.
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER M
!        AN INDEX VARIABLE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NPERL
!        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
!     DOUBLE PRECISION OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED.
!     DOUBLE PRECISION PHI(LAGMAX)
!        THE AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED ORDER.
!     DOUBLE PRECISION PRHO(LAGMAX)
!        THE ARRAY CONTAINING THE PARTIAL AUTOCORRELATION
!        COEFFICIENTS.
!
      CALL IPRINT(IPRT)
!
      NPERL = 12
      DO 30 I = 1, LAGMAX, NPERL
         IMIN = I
         IMAX = MIN(I + NPERL - 1, LAGMAX)
         WRITE(IPRT, 1000) (LAG, LAG = IMIN, IMAX)
         IF (IFPRHO) WRITE (IPRT, 1001) (PRHO(LAG), LAG = IMIN, IMAX)
!
         IF ((IMAX.EQ.LAGMAX) .AND. (LAGMAX.EQ.(N-1))) THEN
            IF (IMAX-IMIN.GE.1) THEN
               WRITE(FMT, 1002) IMAX-IMIN
            ELSE
               WRITE(FMT, 1003)
            END IF
            WRITE(IPRT, FMT) ' AIC               ',
     +                       (AIC(LAG+1), LAG = IMIN, IMAX-1)
            WRITE(IPRT, FMT) ' F RATIO           ',
     +                       (FTEST(1, LAG), LAG = IMIN, IMAX-1)
            WRITE(IPRT, FMT) ' F PROBABILITY     ',
     +                       (FTEST(2, LAG), LAG = IMIN, IMAX-1)
         ELSE
            WRITE(FMT, 1004) NPERL
            WRITE(IPRT, FMT) ' AIC               ',
     +                       (AIC(LAG+1), LAG = IMIN, IMAX)
            WRITE(IPRT, FMT) ' F RATIO           ',
     +                       (FTEST(1, LAG), LAG = IMIN, IMAX)
            WRITE(IPRT, FMT) ' F PROBABILITY     ',
     +                       (FTEST(2, LAG), LAG = IMIN, IMAX)
         END IF
   30 CONTINUE
!
      IF (LAGMAX.EQ.N-1) WRITE(IPRT, 1009)
!
!     PRINT INFORMATION ON ORDER SELECTED
!
      WRITE (IPRT, 1005) IAR, OSPVAR
!
      IF (IAR .EQ. 0) RETURN
!
      WRITE(IPRT, 1008)
!
      DO 40 I = 1, IAR, NPERL
         IMIN = I
         IMAX = MIN(I + NPERL - 1, IAR)
         WRITE (IPRT, 1006) (M, M = IMIN, IMAX)
         WRITE (IPRT, 1007) (PHI(M), M = IMIN, IMAX)
   40 CONTINUE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/19H LAG               , 12(1X, I6))
 1001 FORMAT( 19H PACF              , 12(2X, F5.2))
 1002 FORMAT('(A19,',I2,'(1X, F6.2), 7H ******)')
 1003 FORMAT('(A19, 7H ******)')
 1004 FORMAT('(A19,',I2,'(1X, F6.2))')
 1005 FORMAT (//
     +   49H ORDER AUTOREGRESSIVE PROCESS SELECTED =         , I6/
     +   51H ONE STEP PREDICTION VARIANCE OF PROCESS SELECTED =, G15.8/)
 1006 FORMAT (/19H COEFFICIENT NUMBER, 12(1X, I6))
 1007 FORMAT ( 19H COEFFICIENT VALUE , 12(1X, F6.4))
 1008 FORMAT (45H YULE-WALKER ESTIMATES OF THE COEFFICIENTS OF,
     +   36H THE AUTOREGRESSIVE PROCESS SELECTED)
 1009 FORMAT (/'****** THIS VALUE CANNOT BE COMPUTED',
     +         ' BECAUSE LAG = N-1'//)
!
      END
!XXCH9
      SUBROUTINE XXCH9(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     TEST SUBPROGRAM FOR SIMPLE TEST OF
!     THE NONLINEAR LEAST SQUARES FAMILY OF ROUTINES.
!
!     DATA IS FROM DANIAL AND WOOD [1980], PAGES 428-441.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,IXM,M,N,NPAR
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(5),RES(10),STP(5),XM(10,2),Y(10)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DCKLS,DRV1A,DRV1B,IPRINT,MDL1,NLS,NLSD,STPLS
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     EXTERNAL DRV1A, DRV1B
!        THE NAME OF THE ''USER SUPPLIED'' DERIVATIVE ROUTINES.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX X.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL1
!        THE NAME OF THE ''USER SUPPLIED'' MODEL ROUTINES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN EACH PROBLEM.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     DOUBLE PRECISION PAR(5)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION RES(10)
!        THE RESIDUALS.
!     DOUBLE PRECISION STP(5)
!        THE STEP SIZES SELECTED FOR GENERATING FINITE DIFFERENCE
!        DERIVATIVES.
!     DOUBLE PRECISION XM(10,2)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION Y(10)
!        THE DEPENDENT VARIABLE.
!
!
      DATA Y(1), Y(2), Y(3), Y(4), Y(5), Y(6)
     +   /2.138D0, 3.421D0, 3.597D0, 4.340D0, 4.882D0, 5.660D0/
!
      DATA XM(1,1), XM(2,1), XM(3,1), XM(4,1), XM(5,1), XM(6,1)
     +   /1.309D0, 1.471D0, 1.490D0, 1.565D0, 1.611D0, 1.680D0/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      CALL IPRINT(IPRT)
      IXM = 10
      N = 6
      M = 1
      NPAR = 2
!
!     PRINT HEADER
!
      WRITE (IPRT,1000)
!
!     RUN SIMPLE EXAMPLE OF NLS
!
      WRITE (IPRT,1100)
      PAR(1) = 0.725
      PAR(2) = 4.000
      CALL NLS(Y, XM, N, M, IXM, MDL1, PAR, NPAR, RES, LDSTAK)
      WRITE (IPRT,2000) IERR
!
!     RUN SIMPLE EXAMPLE OF NLSD
!
      WRITE (IPRT,1200)
      PAR(1) = 0.725
      PAR(2) = 4.000
      CALL NLSD(Y, XM, N, M, IXM, MDL1, DRV1A, PAR, NPAR, RES, LDSTAK)
      WRITE (IPRT,2000) IERR
!
!     RUN SIMPLE EXAMPLE OF STPLS
!
      WRITE (IPRT,1300)
      PAR(1) = 0.725
      PAR(2) = 4.000
      CALL STPLS(XM, N, M, IXM, MDL1, PAR, NPAR, LDSTAK, STP)
      WRITE (IPRT,2000) IERR
!
!     RUN SIMPLE EXAMPLE OF DCKLS
!
      WRITE (IPRT,1400)
      PAR(1) = 0.000
      PAR(2) = 4.000
      CALL DCKLS(XM, N, M, IXM, MDL1, DRV1B, PAR, NPAR, LDSTAK)
      WRITE (IPRT,2000) IERR
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT ('1*CH9')
 1100 FORMAT (' SIMPLE TEST OF NLS')
 1200 FORMAT ('1SIMPLE TEST OF NLSD')
 1300 FORMAT ('1SIMPLE TEST OF STPLS')
 1400 FORMAT ('1SIMPLE TEST OF DCKLS')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
!
      END
!ARCOEF
      SUBROUTINE ARCOEF (ACOV, PHI, RSS, LAG, LAGMAX, ACOV0)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE USES DURBINS RECURSIVE METHOD TO COMPUTE
!     THE AUTOREGRESSIVE COEFFICIENTS OF AN ORDER LAG PROCESS,
!     GIVEN ON INPUT THE COEFFICIENTS OF AN ORDER (LAG-1) PROCESS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ACOV0,RSS
      INTEGER
     +   LAG,LAGMAX
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),PHI(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   SUM1,SUM2,T
      INTEGER
     +   J,L1,L2,LJ
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LAGMAX)
!        THE ARRAY OF ACVF ESTIMATES FOR LAGS ONE TO LAGMAX.
!     DOUBLE PRECISION ACOV0
!        THE ACVF FOR LAG ZERO.
!     INTEGER J, LAG
!        INDEX VARIABLES.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE USED.
!     INTEGER LJ, L2
!        INDEX VARIABLES.
!     DOUBLE PRECISION PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR AN AR
!        PROCESS OF ORDER LAG.
!     DOUBLE PRECISION RSS
!        THE ONE STEP PREDICTION RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION SUM1, SUM2
!        VARIABLES USED IN THE COMPUTATIONS OF THE AUTOREGRESSIVE
!        COEFFICIENTS.
!     DOUBLE PRECISION T
!        A TEMPORARY STORAGE LOCATION.
!
      L1 = LAG - 1
      SUM1 = 0.0D0
      SUM2 = 0.0D0
      DO 10 J = 1, L1
         LJ = LAG - J
         SUM1 = SUM1 + PHI(J) * ACOV(LJ)
         SUM2 = SUM2 + PHI(J) * ACOV(J)
   10 CONTINUE
      PHI(LAG) = (ACOV(LAG) - SUM1) / (ACOV0 - SUM2)
      L2 = LAG / 2
      DO 20 J = 1, L2
         LJ = LAG - J
         T = PHI(J) - PHI(LAG) * PHI(LJ)
         PHI(LJ) = PHI(LJ) - PHI(LAG) * PHI(J)
         PHI(J) = T
   20 CONTINUE
!
      RSS = RSS * (1.0D0 - PHI(LAG)*PHI(LAG))
!
      RETURN
      END
!LLSPS
      SUBROUTINE LLSPS(Y, XM, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CALL FOR POLYNOMIAL MODEL LEAST SQUARES FIT
!     NO WEIGHTS SPECIFIED
!     FULL STORAGE
!     USER CONTROL OF AUTOMATIC PRINTOUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,LDSTAK,LPAR,N,NDEG,NPAR,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SDPV(*),SDRES(*),VCV(*),XM(*),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,LPV,LSDPV,LSDRES,LWT
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   WT(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLCNTP
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDEG
!        THE DEGREE OF THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     DOUBLE PRECISION PAR(LPAR)
!        THE PARAMETERS  TO BE ESTIMATED.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUES.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION SDPV(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(N)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(1)
!        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
!     DOUBLE PRECISION XM(N,1)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'L','L','S','P','S',' '/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      WEIGHT = .FALSE.
      SAVE = .TRUE.
      LPV = N
      LSDPV = N
      LSDRES = N
      LWT = 1
!
      CALL LLCNTP(Y, WT, LWT, XM, N, NDEG, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (//42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL LLSPS (Y, X, N, NDEG, RES, LSDTAK,'/
     +   '      +            NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV,'/
     +   '      +            SDRES, VCV, IVCV)')
      END
!GFOUT
      SUBROUTINE GFOUT (XORD, YORD, NORD, FREQ, PHAS, NF,
     +   NTERM, SYM, XPLTMN, XPLTMX, YPLTMN, YPLTMX, NPRT, IGFERR,
     +   NMSUB)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES THE GAIN FUNCTION PLOTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XPLTMN,XPLTMX,YPLTMN,YPLTMX
      INTEGER
     +   IGFERR,NF,NORD,NPRT,NTERM
      LOGICAL
     +   SYM
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),PHAS(NF),XORD(NORD),YORD(NORD)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   PI,XMN,XMX,YMN,YMX
      INTEGER
     +   ILOG,IPRT
      LOGICAL
     +   ERROR
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GETPI,IPRINT,PPLMT,PPMN,VERSP
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        AN ERROR FLAG.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO
!        BE ESTIMATED.
!     INTEGER IERR
!        THE ERROR FLAG.
!     INTEGER IGFERR
!        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
!        TO HAVE PRODUCED REASONABLE RESULTS.
!     INTEGER ILOG
!        THE VARIABLE CONTROLLING THE PLOT AXIS TYPE (LOG OR LINEAR)
!     INTEGER IPRT
!        THE UNIT NUMBER FOR THE OUTPUT.
!     INTEGER ISYM(1)
!        A DUMMY ARRAY FOR THE CALL TO PPMN.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE GAIN FUNCTION ESTIMATES
!        ARE TO BE COMPUTED.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE.
!     INTEGER NORD
!        THE NUMBER OF ORDINATES TO BE PLOTTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NTERM
!        THE NUMBER OF TERMS IN THE FILTER FOR WHICH THE GAIN
!        FUNCTION WAS COMPUTED.
!     DOUBLE PRECISION PHAS(NF)
!        THE ARRAY IN WHICH THE PHASE OF THE FILTER IS RETURNED.
!     DOUBLE PRECISION PI
!        THE VALUE OF PI.
!     LOGICAL SYM
!        AN INDICATOR VARIABLE USED TO DETERMINE IF THE FILTER WAS
!        SYMMETRIC OR NOT.
!     DOUBLE PRECISION XMN, XMX
!        ...
!     DOUBLE PRECISION XORD(NORD)
!        THE X COORDINATES FOR THE GAIN FUNCTION PLOT
!     DOUBLE PRECISION XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     DOUBLE PRECISION YMN, YMX
!        ...
!     DOUBLE PRECISION YORD(NORD)
!        THE Y COORDINATES FOR THE GAIN FUNCTION PLOT
!     DOUBLE PRECISION YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
!     SET UNIT NUMBER FOR OUTPUT AND SET OUTPUT WIDTH.
!
      CALL IPRINT (IPRT)
!
      CALL VERSP(.TRUE.)
!
      IF (SYM) WRITE (IPRT, 1000) NTERM
      IF (.NOT. SYM) WRITE (IPRT, 1003) NTERM
!
      IF (IGFERR .EQ. 0) GO TO 5
      WRITE (IPRT, 1004)
      RETURN
!
    5 CONTINUE
!
      IF (NPRT.GE.1) THEN
        ILOG = 1
      ELSE
        ILOG = 0
      END IF
!
!     DETERMINE THE BOUNDS FOR THE X AND Y AXIS AND COMPLETE THE
!     ERROR CHECKING
!
      CALL PPLMT (YORD, YORD, XORD, XORD, NORD, 1, NORD,
     +   YPLTMN, YPLTMX, YMN, YMX, XPLTMN, XPLTMX, XMN, XMX,
     +   ERROR, NMSUB, .FALSE.)
      IF (ERROR) THEN
        IERR = 1
        RETURN
      ELSE
        CALL PPMN (YORD, YORD, XORD, XORD, NORD, 1, NORD, 0, ISYM, 1, 0,
     +   0, YMN, YMX, XMN, XMX, .FALSE., ILOG)
      END IF
!
      IF (XPLTMN .NE. 0.0D0 .OR. XPLTMX .NE. 0.5D0) GO TO 10
!
      WRITE (IPRT, 1002)
!
   10 IF (SYM) RETURN
!
      WRITE (IPRT, 1006)
!
      CALL VERSP(.TRUE.)
!
!     PRINT PHASE PLOT FOR AUTOREGRESSIVE FILTER
!
      CALL GETPI(PI)
!
      WRITE (IPRT, 1005) NTERM
!
      CALL PPLMT (PHAS, PHAS, FREQ, FREQ, NORD, 1, NORD,
     +   -PI, PI, YMN, YMX, XPLTMN, XPLTMX, XMN, XMX,
     +   ERROR, NMSUB, .FALSE.)
      IF (ERROR) THEN
        IERR = 1
        RETURN
      ELSE
        CALL PPMN (PHAS, PHAS, FREQ, FREQ, NORD, 1, NORD, 0, ISYM, 1, 0,
     +   0, YMN, YMX, XMN, XMX, .FALSE., 0)
      END IF
!
      IF (XPLTMN .NE. 0.0D0 .OR. XPLTMX .NE. 0.5D0) RETURN
!
      WRITE (IPRT, 1002)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (18H GAIN FUNCTION OF , I3, 15H TERM SYMMETRIC,
     +   14H LINEAR FILTER)
 1002 FORMAT(5H+FREQ/
     +   7H PERIOD, 9X, 3HINF, 7X, 3H20., 7X, 3H10., 8X, 6H6.6667, 4X,
     +   2H5., 8X, 2H4., 8X, 6H3.3333, 4X, 6H2.8571, 4X, 3H2.5, 7X,
     +   6H2.2222, 4X, 2H2.)
 1003 FORMAT (18H GAIN FUNCTION OF , I3, 21H TERM AUTOREGRESSIVE,,
     +   22H OR DIFFERENCE, FILTER)
 1004 FORMAT (//51H THE PLOT HAS BEEN SUPRESSED BECAUSE FEWER THAN TWO/
     +   45H NON ZERO GAIN FUNCTION VALUES WERE COMPUTED.)
 1005 FORMAT (19H PHASE FUNCTION OF , I3, 21H TERM AUTOREGRESSIVE,,
     +   22H OR DIFFERENCE, FILTER)
 1006 FORMAT ('1')
      END
!VPCNT
      SUBROUTINE VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLING ROUTINE FOR USER CALLED VERTICAL PLOTS
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M,N,NS
      LOGICAL
     +   MISS,MULTI
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(*)
      INTEGER
     +   ISYM(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   YMN,YMX
      INTEGER
     +   NSAMPL
      LOGICAL
     +   ERROR,XCHECK
!
!  EXTERNAL SUBROUTINES
      EXTERNAL PLTCHK,VERSP,VPLMT,VPMN
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MOD
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        A VALUE INDICATING WHETHER AN ERROR WAS DETECTEC (TRUE)
!        OR NOT (FALSE).
!     INTEGER IBAR
!        THE INDICATOR USED TO DESIGNATE WHETHER THE PLOT IS TO BE A
!        BAR GRAPH (IBAR.GE.1) OR NOT (IBAR.LE.0).
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IRLIN
!        THE INDICATOR USED TO DESIGNATE WHETHER THE PLOT WILL HAVE
!        THE LOCATION OF ZERO PLOTTED AS A REFERENCE LINE (IRLIN.EQ.0),
!        THE LOCATION OF THE MEAN PLOTTED AS A REFERENCE LINE (IRLIN.GE.
!        OR NO REFERENCE LINE (IRLIN.LT.0).
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(LISYM)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING, NOT USED IN SOME CASES
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS, NSAMPL
!        THE SAMPLING FREQUENCY.
!     LOGICAL XCHECK
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER X-AXIS VALUES
!        ARE TO BE CHECKED (XCHECK = .TRUE.) OR NOT (XCHECK = .FALSE.)
!     DOUBLE PRECISION XINC
!        THE INCREMENT FOR THE X-AXIS.
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(M)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YMN, YMX
!        THE Y-AYIS LOWER AND UPPER LIMITS ACTUALLY USED.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     COMMENCE BODY OF ROUTINE
!
      XCHECK = .FALSE.
      CALL PLTCHK (YM, YMMISS, YM, YMMISS, N, M, IYM, MULTI,
     +   ILOG, YLB, YUB, XLB, XINC, NMSUB, MISS, XCHECK)
!
      IF (IERR.EQ.0) THEN
!
!       DETERMINE THE BOUNDS FOR THEY AXIS AND COMPLETE ERROR CHECKING
!
        NSAMPL = MAX(1, NS)
        CALL VPLMT (YM, YMMISS, N, M, IYM, YLB, YUB, YMN, YMX,
     +    ERROR, NMSUB, MISS, NSAMPL)
!
        IF (ERROR) THEN
          IERR = 1
        ELSE
!
!       PRINT PLOT
!
        IF (MOD(MAX(0,ISIZE),10).EQ.0) THEN
          CALL VERSP(.TRUE.)
        ELSE
          CALL VERSP(.FALSE.)
        END IF
        CALL VPMN (YM, YMMISS, N, M, IYM, NSAMPL, ISCHCK, ISYM, LISYM,
     +    ISIZE, YMN, YMX, XLB, XINC, MISS, ILOG, IRLIN, IBAR)
!
        END IF
      END IF
!
      RETURN
!
      END
!ACFM
      SUBROUTINE ACFM (Y, YMISS, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
!     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
!     WITH MISSING VALUES (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMISS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN,YSD
      INTEGER
     +   IAR,IPRT,LACOV,LAGLST,LAGMAX,LAIC,LDSMIN,LDSTAK,LYFFT,
     +   NFAC,NFFT,NPRT
      LOGICAL
     +   DIFFER,ISFFT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),AIC(101),FTEST(2,100),PHI(100),PRHO(100),RHO(100),
     +   SDRHO(100),WORK(100)
      INTEGER
     +   IOD(1),ND(1),NDUM(1),NLPPA(101)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACFER,ACFMNM,ACFOUT,IPRINT,SETLAG
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (ACOV(2),RHO(1))
      EQUIVALENCE (WORK(1),SDRHO(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(101)
!        THE AUTOCOVARIANCE VECTOR.
!     DOUBLE PRECISION AIC(101)
!        THE ARRAY CONTAINING THE AKAIKES CRITERION FOR EACH ORDER.
!     DOUBLE PRECISION CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     LOGICAL DIFFER
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
!     DOUBLE PRECISION FTEST(2, 100)
!        THE ARRAY CONTAINING THE PARTIAL F RATIO AND PROBABILITIES
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IOD(1)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGLST
!        THE LAST LAG BEFORE MISSING DATA CAUSED THE ACVF OF THE
!        SERIES NOT TO BE COMPUTED.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        A DUMMY VARIABLE.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER ND(1)
!        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
!     INTEGER NDUM(1)
!        A DUMMY ARRAY.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NLPPA(101)
!        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
!        USED TO COMPUTE EACH ACVF ESTIMATE.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     DOUBLE PRECISION OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
!     DOUBLE PRECISION PHI(100)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     DOUBLE PRECISION PRHO(100)
!        THE ARRAY CONTAINING THE PACF ESTIMATES.
!     DOUBLE PRECISION RHO(100)
!        THE ARRAY CONTAINING THE ACF ESTIMATES.
!     DOUBLE PRECISION SDRHO(100)
!        THE ARRAY CONTAINING THE STANDARD ERRORS OF THE ACF.
!     DOUBLE PRECISION WORK(100)
!        THE ARRAY CONTAINING WORK AREA FOR THE PACF COMPUTATIONS.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER
!        OR NOT AN OBSERVATION IN THE SERIES IS MISSING.
!        IF Y(I) .EQ. YMISS, THE VALUE IS ASSUMED MISSING.
!        IF Y(I) .NE. YMISS, THE VALUE IS ASSUMED NOT MISSING.
!     DOUBLE PRECISION YSD
!        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'A',       'C',       'F',       'M',       ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      LAGMAX = 1
      LACOV = 101
      LAIC = 101
      NPRT = 1
      LDSMIN = 0
      LDSTAK = 0
      DIFFER = .FALSE.
      NFAC = 1
      ND(1) = 0
      IOD(1) = 0
      ISFFT = .FALSE.
      LYFFT = N
      NFFT = N
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL ACFER(NMSUB, N, LAGMAX, LACOV, LDSTAK, LDSMIN,
     +  DIFFER, NFAC, ND, IOD, ISFFT, LYFFT, NFFT)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      IF (IERR.EQ.0) THEN
!
!       SET LARGEST LAG TO BE USED.
!
        CALL SETLAG(N, LAGMAX)
!
!       CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
        CALL ACFMNM (Y, YMISS, N, LAGMAX, RHO, SDRHO, NLPPA, YMEAN,
     +     PRHO, AIC, FTEST, PHI, IAR, OSPVAR, ACOV, LACOV, LAIC, CHIA,
     +     CHIAP, LAGLST, WORK, NPRT)
!
        YSD = ACOV(1)
        IF (LAGLST.GE.0) YSD = SQRT (ACOV(1) * N / (N - 1))
!
!       CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
        CALL ACFOUT (YMEAN, YSD, N, NLPPA(1), LAGMAX, RHO, SDRHO, PRHO,
     +     NLPPA, AIC, LAGMAX+1, FTEST, IAR, PHI, OSPVAR, CHIA, CHIAP,
     +     LAGLST, .TRUE., YMISS, .FALSE., .FALSE., 0, NDUM, NDUM, 0)
      END IF
!
      IF (IERR.NE.0) THEN
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   30H       CALL ACFM (Y, YMISS, N))
      END
!MPPML
      SUBROUTINE MPPML(YM, YMMISS, X, XMISS, N, M, IYM, ILOG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH MULTIPLE Y-AXIS VALUES AND WITH MISSING
!     OBSERVATIONS (LOG OPTION).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   ILOG,IYM,M,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   IPRT,ISCHCK,ISIZE,LISYM,NOUT
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(IYM,M)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(M)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'P',       'P',       'M',       'L',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      MULTI = .TRUE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 2
      ISIZE = -1
      NOUT = 0
      MISS = .TRUE.
      LISYM = 1
!
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL MPPML (YM, YMMISS, X, XMISS, N, M, IYM, ILOG)')
      END
!XLLS
      SUBROUTINE XLLS(LDS,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     TEST ROUTINES FOR LINEAR LEAST SQUARES SUBROUTINES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDS
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD,SUM,TERM
      INTEGER
     +   I,IPRT,IVCV,IXM,J,LDSMIN,LDSTAK,LPAR,N,NDEG,NPAR,NPRT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(10),PV(50),RAND(1),RES(50),SDPV(50),SDRES(50),VCV(10,10),
     +   WT(50),X(50,9),XM(50,10),XM1(50,10),Y(50),Y1(50)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL FITSXP,GENR,IPRINT,LDSCMP,LLS,LLSP,LLSPS,LLSPW,LLSPWS,
     +   LLSS,LLSW,LLSWS,NRAND,SETRV
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (XM(1,2),X(1,1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX X.
!     INTEGER J
!        AN INDEX.
!     INTEGER LDS
!       ..
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE PARAMETER ARRAY.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDEG
!        THE DEGREE OF THE POLYNOMIAL MODEL TO BE FIT.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     DOUBLE PRECISION PAR(10)
!        THE PARAMETERS  TO BE ESTIMATED.
!     DOUBLE PRECISION PV(50)
!        THE PREDICTED VALUES.
!     DOUBLE PRECISION RAND(1)
!        *
!     DOUBLE PRECISION RES(50)
!        THE RESIDUALS.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     DOUBLE PRECISION SDPV(50)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(50)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION SUM, TERM
!        *
!     DOUBLE PRECISION VCV(10,10)
!        THE VARIANCE COVARIANCE MATRIX.
!     DOUBLE PRECISION WT(50)
!        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
!     DOUBLE PRECISION X(50,9)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION XM(50,10)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION XM1(50,10)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION Y(50)
!        THE DEPENDENT VARIABLE.
!     DOUBLE PRECISION Y1(50)
!        THE DEPENDENT VARIABLE.
!
!
      DATA      XM(1,1),  XM(1,2),  XM(1,3),  XM(1,4)
     +    /      1.0D0, 42.2D0, 11.2D0, 31.9D0/
      DATA      XM(2,1),  XM(2,2),  XM(2,3),  XM(2,4)
     +    /      1.0D0, 48.6D0, 10.6D0, 13.2D0/
      DATA      XM(3,1),  XM(3,2),  XM(3,3),  XM(3,4)
     +    /      1.0D0, 42.6D0, 10.6D0, 28.7D0/
      DATA      XM(4,1),  XM(4,2),  XM(4,3),  XM(4,4)
     +    /      1.0D0, 39.0D0, 10.4D0, 26.1D0/
      DATA      XM(5,1),  XM(5,2),  XM(5,3),  XM(5,4)
     +    /      1.0D0, 34.7D0,  9.3D0, 30.1D0/
      DATA      XM(6,1),  XM(6,2),  XM(6,3),  XM(6,4)
     +    /      1.0D0, 44.5D0, 10.8D0,  8.5D0/
      DATA      XM(7,1),  XM(7,2),  XM(7,3),  XM(7,4)
     +    /      1.0D0, 39.1D0, 10.7D0, 24.3D0/
      DATA      XM(8,1),  XM(8,2),  XM(8,3),  XM(8,4)
     +    /      1.0D0, 40.1D0, 10.0D0, 18.6D0/
      DATA      XM(9,1),  XM(9,2),  XM(9,3),  XM(9,4)
     +    /      1.0D0, 45.9D0, 12.0D0, 20.4D0/
      DATA         Y(1),     Y(2),     Y(3)
     +    /    167.1D0,174.4D0,160.8D0/
      DATA         Y(4),     Y(5),     Y(6)
     +    /    162.0D0,140.8D0,174.6D0/
      DATA         Y(7),     Y(8),     Y(9)
     +    /    163.7D0,174.5D0,185.7D0/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      CALL IPRINT(IPRT)
      N = 9
      NPAR = 4
      NDEG = 3
      NPRT = 2
      LPAR = 10
      IVCV = 10
      IXM = 50
      LDSTAK = LDS
!
      CALL SETRV(WT, N, 1.0D0)
!
!     CHECK ERROR HANDLING
!
!        ERROR 1  -  NON POSITIVE NUMBER OF OBSERVATIONS AND PARAMETER
!                    NUMBER OF PARAMETERS GREATER THAN N
!                    IXM LESS THAN NUMBER OF OBSERVATIONS
!                    IVCV LESS THAN NUMBER OF PARAMETERS
!                    LPAR TOO SMALL
!
      N = -5
      NPAR = 0
      NDEG = -1
      IXM = -10
      LPAR = -1
      IVCV = -10
      NPRT = -1
      WRITE (IPRT,1200)
      WRITE (IPRT,1000)
      CALL LLS(Y, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1020)
      CALL LLSW(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1040)
      CALL LLSP(Y, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1050)
      CALL LLSPS(Y, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1060)
      CALL LLSPW(Y, WT, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1070)
      CALL LLSPWS(Y, WT, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      N = 9
      NPAR = 4
      NDEG = 3
      IXM = 50
      LPAR = -10
      IVCV = 10
!
!        ERROR 2  -  LDS TOO SMALL
!                    LPAR TOO SMALL
!
      LDSTAK = 0
      WRITE (IPRT,1220)
      WRITE (IPRT,1000)
      CALL LLS(Y, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1020)
      CALL LLSW(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1040)
      CALL LLSP(Y, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1050)
      CALL LLSPS(Y, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1060)
      CALL LLSPW(Y, WT, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1070)
      CALL LLSPWS(Y, WT, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      LDSTAK = LDS
      NPRT = 2
      LPAR = 10
!
!        ERROR 3  -  NEGATIVE WEIGHTS
!
      WT(1) = -1.0D0
      WRITE (IPRT,1240)
      WRITE (IPRT,1020)
      CALL LLSW(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1060)
      CALL LLSPW(Y, WT, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1070)
      CALL LLSPWS(Y, WT, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WT(1) = 1.0D0
!
!        ERROR 4  -  TOO FEW POSITIVE WEIGHTS
!
      CALL SETRV(WT(2), N-1, 0.0D0)
      WRITE (IPRT,1250)
      WRITE (IPRT,1020)
      CALL LLSW(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1060)
      CALL LLSPW(Y, WT, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1070)
      CALL LLSPWS(Y, WT, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL SETRV(WT(2), N-1, 1.0D0)
!
!     CHECK RESULTS FROM VALID CALL
!
      WRITE (IPRT,1260)
      WRITE (IPRT,1000)
      CALL LLS(Y, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
      WRITE (IPRT,1260)
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1260)
      WRITE (IPRT,1020)
      CALL LLSW(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
      WRITE (IPRT,1260)
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1260)
      WRITE (IPRT,1040)
      CALL LLSP(Y, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
      WRITE (IPRT,1260)
      WRITE (IPRT,1050)
      CALL LLSPS(Y, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1260)
      WRITE (IPRT,1060)
      CALL LLSPW(Y, WT, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
      WRITE (IPRT,1260)
      WRITE (IPRT,1070)
      CALL LLSPWS(Y, WT, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
!     CHECK RESULTS FROM EXACT FIT
!
      N = NPAR
      NDEG = NPAR-1
!
      WRITE (IPRT,1270)
      WRITE (IPRT,1000)
      CALL LLS(Y, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
      WRITE (IPRT,1270)
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1270)
      WRITE (IPRT,1040)
      CALL LLSP(Y, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
      WRITE (IPRT,1270)
      WRITE (IPRT,1050)
      CALL LLSPS(Y, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
      N = 9
!
      CALL SETRV(WT(NPAR+1), N-NPAR, 0.0D0)
!
      WRITE (IPRT,1270)
      WRITE (IPRT,1020)
      CALL LLSW(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
      WRITE (IPRT,1270)
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1270)
      WRITE (IPRT,1060)
      CALL LLSPW(Y, WT, X, N, NDEG, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
      WRITE (IPRT,1270)
      WRITE (IPRT,1070)
      CALL LLSPWS(Y, WT, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
      CALL SETRV(WT(NPAR+1), N-NPAR, 1.0D0)
!
!     CHECK RESULTS FROM RANK DEFICIENT FIT
!
      DO 10 I = 1, N
         XM(I,5) = XM(I,4)
   10 CONTINUE
      WRITE (IPRT,1280)
      WRITE (IPRT,1000)
      CALL LLS(Y, XM, N, IXM, NPAR+1, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
!
!     CHECK RESULTS FROM A POORLY SCALED PROBLEM.
!
      DO 30 I = 1, N
         Y1(I) = Y(I) * 1.0D-8
         DO 20 J = 1, 4
            XM1(I,J) = XM(I,J)
   20    CONTINUE
         XM1(I,3) = XM1(I,3) * 1.0D+8
   30 CONTINUE
!
      WRITE (IPRT,1290)
      WRITE (IPRT,1000)
      CALL LLS(Y1, XM, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1290)
      WRITE (IPRT,1000)
      CALL LLS(Y, XM1, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1290)
      WRITE (IPRT,1000)
      CALL LLS(Y1, XM1, N, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,1500) IERR
!
!     MINIMUM AMOUNT OF WORK AREA.
!
      CALL LDSCMP(15, 0, 0, 0, 0, 0, 'D',
     +            6*N + NPAR*(N+2*NPAR+5) + 1, LDSMIN)
!
      WRITE (IPRT,1300)
      WRITE (IPRT,1000)
      CALL LLS(Y, XM, N, IXM, NPAR, RES, LDSMIN)
      WRITE (IPRT,1500) IERR
      WRITE (IPRT,1430) (RES(I), I = 1, N)
!
!     CHECK RESULTS FOR WEIGHTED ANALYSIS
!
      NPRT = 1111
      CALL SETRV(WT, N, 100.0D0)
      WRITE (IPRT,1310)
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
      WT(1) = 0.0D0
      WT(5) = 0.0D0
      WT(9) = 0.0D0
!
      WRITE (IPRT,1310)
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      CALL SETRV(WT, N, 100.0D0)
!
      CALL GENR(WT, N, 1.0D0, 1.0D0)
      WRITE (IPRT,1310)
      WRITE (IPRT,1030)
      CALL LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV,SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      CALL SETRV(WT, N, 100.0D0)
!
!     CHECK PRINT CONTROL
!
      NPRT = 1000
      WRITE (IPRT,1320) NPRT
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
      NPRT = 2000
      WRITE (IPRT,1320) NPRT
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
      NPRT = 200
      WRITE (IPRT,1320) NPRT
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
      NPRT = 20
      WRITE (IPRT,1320) NPRT
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
      NPRT = 2
      WRITE (IPRT,1320) NPRT
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
      NPRT = 0
      WRITE (IPRT,1320) NPRT
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
!     CHECK RESULTS FOR N = 2, NPAR = ID+1 = 1
!
      NPRT = 2222
      N = 2
      NPAR = 1
      NDEG = 0
      WRITE (IPRT,1330)
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1330)
      WRITE (IPRT,1070)
      CALL LLSPWS(Y, WT, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
!     CHECK RESULTS FOR N = 1, NPAR = ID+1 = 1
!
      NPRT = 2222
      N = 1
      NPAR = 1
      NDEG = 0
      WRITE (IPRT,1330)
      WRITE (IPRT,1010)
      CALL LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1330)
      WRITE (IPRT,1070)
      CALL LLSPWS(Y, WT, X, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      N = 9
      NPAR = 4
      NDEG = 3
!
!
!     ILL-CONDITIONED
!
      DO 40 I = 1, 50
         TERM = 1.0D0
         SUM = 0.0D0
         DO 35 J = 1, 6
            XM1(I,J) = TERM
            SUM = SUM + TERM
            TERM = (I-1)*TERM
   35    CONTINUE
         Y1(I) = SUM
   40 CONTINUE
!
      N = 21
      NPAR = 6
      NDEG = 5
      WRITE (IPRT,1340)
      WRITE (IPRT,1010)
      CALL LLSS(Y1, XM1, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1340)
      WRITE (IPRT,1050)
      CALL LLSPS(Y1, XM1(1,2), N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
      N = 50
      NPAR = 6
      NDEG = 5
      CALL NRAND(RAND, 1, 223)
      DO 50 I = 1, N
         CALL NRAND(RAND, 1, 0)
         Y1(I) = Y1(I) + RAND(1)
   50 CONTINUE
      WRITE (IPRT,1340)
      WRITE (IPRT,1010)
      CALL LLSS(Y1, XM1, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1340)
      WRITE (IPRT,1050)
      CALL LLSPS(Y1, XM1(1,2), N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
      NPRT = 1000
      WRITE (IPRT,1340)
      WRITE (IPRT,1010)
      CALL LLSS(Y1, XM1, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
      WRITE (IPRT,1340)
      WRITE (IPRT,1050)
      CALL LLSPS(Y1, XM1(1,2), N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
      N = 45
      CALL SETRV(WT, N, 1.0D0)
      WRITE (IPRT,1340)
      WRITE (IPRT,1010)
      CALL LLSWS(Y1, WT, XM1, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
      N = 44
      WRITE (IPRT,1340)
      WRITE (IPRT,1010)
      CALL LLSWS(Y1, WT, XM1, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
      N = 41
      WRITE (IPRT,1340)
      WRITE (IPRT,1010)
      CALL LLSWS(Y1, WT, XM1, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
      N = 40
      WRITE (IPRT,1340)
      WRITE (IPRT,1010)
      CALL LLSWS(Y1, WT, XM1, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1500) IERR
      CALL FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV, RSD)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (' CALL TO LLS   ')
 1010 FORMAT (' CALL TO LLSS  ')
 1020 FORMAT (' CALL TO LLSW  ')
 1030 FORMAT (' CALL TO LLSWS ')
 1040 FORMAT (' CALL TO LLSP  ')
 1050 FORMAT (' CALL TO LLSPS ')
 1060 FORMAT (' CALL TO LLSPW ')
 1070 FORMAT (' CALL TO LLSPWS')
 1200 FORMAT ('1MISCELLANEOUS ERRORS  -  TEST 1')
 1220 FORMAT ('1MISCELLANEOUS ERRORS  -  TEST 2')
 1240 FORMAT ('1NEGATIVE WEIGHTS')
 1250 FORMAT ('1TOO FEW POSITIVE WEIGHTS')
 1260 FORMAT ('1VALID PROBLEM')
 1270 FORMAT ('1ZERO RESIDUAL PROBLEM')
 1280 FORMAT ('1RANK DEFICIENT PROBLEM')
 1290 FORMAT ('1POORLY SCALED PROBLEM')
 1300 FORMAT ('1MINIMUM WORK AREA SIZE')
 1310 FORMAT ('1WEIGHTED ANALYSIS')
 1320 FORMAT ('1CHECK PRINT CONTROL  -  NPRT = ', I5)
 1330 FORMAT ('1CHECK MINIMUM PROBLEM SIZE')
 1340 FORMAT ('1ILL-CONDITIONED PROBLEM')
 1430 FORMAT (//4H RES/ (1X, E22.14))
 1500 FORMAT (/' IERR = ', I5)
!
      END
!VPMC
      SUBROUTINE VPMC(YM, YMMISS, N, NS, ILOG, ISIZE,
     +   IRLIN, IBAR, YLB, YUB, XLB, XINC)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IRLIN,ISIZE,N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(1)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,ISCHCK,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  ' ',       'V',       'P',       'M',       'C',       ' '/
!
!     SET DEFAULT VALUES
!
      M = 1
      IYM = N
      MULTI = .FALSE.
      ISCHCK = 0
      MISS = .TRUE.
      LISYM = 1
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL VPMC (Y, YMISS, N, NS, ILOG,'/
     +  '      +           ISIZE, IRLIN, IBAR, YLB, YUB, XLB, XINC)')
      END
!DEMORD
      SUBROUTINE DEMORD (PHAS1, PHAS2, NDEM, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE SETS UP THE DATA FOR THE PHASE PLOTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N,NDEM
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PHAS1(N),PHAS2(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   PI
      INTEGER
     +   I
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES BEING DEMODULATED.
!     INTEGER NDEM
!        THE NUMBER OF VALUES IN THE DEMODULATED SERIES, I.E., IN
!        THE AMPLITUDE AND PHASE ARRAYS.
!     DOUBLE PRECISION PHAS1(N), PHAS2(N)
!        THE ARRAYS CONTAINING THE PRIMARY AND SECONDARY PHASE
!        ESTIMATES, RESPECTIVELY.
!     DOUBLE PRECISION PI
!        THE VALUE OF PI.
!
      CALL GETPI(PI)
!
      DO 10 I = 1, NDEM
         PHAS2(I) = 0.0D0
         IF (PHAS1(I) .GT. 0.0D0) PHAS2(I) = PHAS1(I) - 2.0D0*PI
         IF (PHAS1(I) .LT. 0.0D0) PHAS2(I) = PHAS1(I) + 2.0D0*PI
   10 CONTINUE
!
      RETURN
      END
!POLAR
      SUBROUTINE POLAR (AMPL, PHAS, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE CONVERTS THE PAIR OF SERIES AMPL AND PHAS
!     FROM THE REAL AND IMAGINARY PARTS OF A SERIES OF COMPLEX
!     NUMBERS TO THEIR MAGNITUDES AND PHASES.  THE CONVERSION IS
!     DONE IN PLACE.
!
!     WRITTEN BY  -  PETER BLOOMFIELD
!                    FOURIER ANALSERIESSIS OF TIME SERIES- AN
!                       INTRODUCTION
!                    JOHN WILESERIES AND SONS, NEW SERIESORK, 1976
!                    PAGE 150
!     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
!                                 STATISTICAL ENGINEERING DEVISION
!                                 NATIONAL BUREAU OF STANDARDS
!                                 BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AMPL(N),PHAS(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   PHASE,R
      INTEGER
     +   I
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ATAN2,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AMPL(N)
!        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     DOUBLE PRECISION PHAS(N)
!        THE ARRAY IN WHICH THE PRIMARY PHASE ESTIMATES ARE RETURNED.
!     DOUBLE PRECISION PHASE
!        THE PHASE COMPONENT OF THE DEMODULATED SERIES.
!     DOUBLE PRECISION R
!        THE AMPLITUDE COMPONENT OF THE DEMODULATED SERIES.
!
      DO 10 I = 1, N
         R = SQRT(AMPL(I)*AMPL(I) + PHAS(I)*PHAS(I))
         PHASE = 0.0D0
         IF (R .NE. 0.0D0) PHASE = ATAN2(PHAS(I), AMPL(I))
         AMPL(I) = R
         PHAS(I) = PHASE
   10 CONTINUE
      RETURN
      END
!XVP
      SUBROUTINE XVP(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE PLOTTING SUBROUTINES
!
!     SERIES Y IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND
!     JENKINS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YMISS,YUB
      INTEGER
     +   IBAR,ILOG,IPRT,IRLIN,ISIZE,ITEST,IYM,M,NOUT,NS,NY,NYM
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AIR(144),Y(144),YM(12,12),YMMISS(144)
      INTEGER
     +   ISYM(144)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,MVP,MVPC,MVPL,MVPM,MVPMC,MVPML,DCOPY,SETRV,SVP,
     +   SVPC,SVPL,SVPM,SVPMC,SVPML,VP,VPC,VPL,VPM,VPMC,VPML
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (Y(1),YM(1,1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AIR(144)
!        THE AIRLINE DATA.
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .NE. 0)
!        OR BARS (IBAR .EQ. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(144)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER ITEST
!        THE NUMBER OF THE TEST.
!     INTEGER IYM
!        ACTUAL DIMENSION OF YM IN USERS MAIN PROGRAM
!     INTEGER LDSTAK
!        *
!     INTEGER M
!        THE NUMBER OF VECTORS IN YM
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     INTEGER NY, NYM
!        THE NUMBER OF OBSERVATIONS IN ARRAYS Y AND YM, RESPECTIVELY.
!     DOUBLE PRECISION XINC
!        THE INCREMENT FOR THE X AXIS.
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.
!     DOUBLE PRECISION Y(144)
!        VECTOR OF OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(12,12)
!        MULTIVARIATE OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES.
!     DOUBLE PRECISION YMISS
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YMMISS(144)
!        THE MISSING VALUE CODES FOR EACH COLUMN OF YM.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
      DATA YMISS/180.0D0/
!
      DATA ISYM(  1),ISYM(  2),ISYM(  3),ISYM(  4),ISYM(  5),ISYM(  6)
     +    /    -5000,     6000,        7,        8,        9,       10/
      DATA ISYM(  7),ISYM(  8),ISYM(  9),ISYM( 10),ISYM( 11),ISYM( 12)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 13),ISYM( 14),ISYM( 15),ISYM( 16),ISYM( 17),ISYM( 18)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 19),ISYM( 20),ISYM( 21),ISYM( 22),ISYM( 23),ISYM( 24)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 25),ISYM( 26),ISYM( 27),ISYM( 28),ISYM( 29),ISYM( 30)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 31),ISYM( 32),ISYM( 33),ISYM( 34),ISYM( 35),ISYM( 36)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 37),ISYM( 38),ISYM( 39),ISYM( 40),ISYM( 41),ISYM( 42)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 43),ISYM( 44),ISYM( 45),ISYM( 46),ISYM( 47),ISYM( 48)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 49),ISYM( 50),ISYM( 51),ISYM( 52),ISYM( 53),ISYM( 54)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 55),ISYM( 56),ISYM( 57),ISYM( 58),ISYM( 59),ISYM( 60)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 61),ISYM( 62),ISYM( 63),ISYM( 64),ISYM( 65),ISYM( 66)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 67),ISYM( 68),ISYM( 69),ISYM( 70),ISYM( 71),ISYM( 72)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 73),ISYM( 74),ISYM( 75),ISYM( 76),ISYM( 77),ISYM( 78)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 79),ISYM( 80),ISYM( 81),ISYM( 82),ISYM( 83),ISYM( 84)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 85),ISYM( 86),ISYM( 87),ISYM( 88),ISYM( 89),ISYM( 90)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 91),ISYM( 92),ISYM( 93),ISYM( 94),ISYM( 95),ISYM( 96)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 97),ISYM( 98),ISYM( 99),ISYM(100),ISYM(101),ISYM(102)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM(103),ISYM(104),ISYM(105),ISYM(106),ISYM(107),ISYM(108)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM(109),ISYM(110),ISYM(111),ISYM(112),ISYM(113),ISYM(114)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM(115),ISYM(116),ISYM(117),ISYM(118),ISYM(119),ISYM(120)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM(121),ISYM(122),ISYM(123),ISYM(124),ISYM(125),ISYM(126)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM(127),ISYM(128),ISYM(129),ISYM(130),ISYM(131),ISYM(132)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM(133),ISYM(134),ISYM(135),ISYM(136),ISYM(137),ISYM(138)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM(139),ISYM(140),ISYM(141),ISYM(142),ISYM(143),ISYM(144)
     +    /       11,       12,       13,       14,       15,       16/
!
      DATA  AIR(  1), AIR(  2), AIR(  3), AIR(  4), AIR(  5), AIR(  6)
     +    / 112.0D0, 118.0D0, 132.0D0, 129.0D0, 121.0D0, 135.0D0/
      DATA  AIR(  7), AIR(  8), AIR(  9), AIR( 10), AIR( 11), AIR( 12)
     +    / 148.0D0, 148.0D0, 136.0D0, 119.0D0, 104.0D0, 118.0D0/
      DATA  AIR( 13), AIR( 14), AIR( 15), AIR( 16), AIR( 17), AIR( 18)
     +    / 115.0D0, 126.0D0, 141.0D0, 135.0D0, 125.0D0, 149.0D0/
      DATA  AIR( 19), AIR( 20), AIR( 21), AIR( 22), AIR( 23), AIR( 24)
     +    / 170.0D0, 170.0D0, 158.0D0, 133.0D0, 114.0D0, 140.0D0/
      DATA  AIR( 25), AIR( 26), AIR( 27), AIR( 28), AIR( 29), AIR( 30)
     +    / 145.0D0, 150.0D0, 178.0D0, 163.0D0, 172.0D0, 178.0D0/
      DATA  AIR( 31), AIR( 32), AIR( 33), AIR( 34), AIR( 35), AIR( 36)
     +    / 199.0D0, 199.0D0, 184.0D0, 162.0D0, 146.0D0, 166.0D0/
      DATA  AIR( 37), AIR( 38), AIR( 39), AIR( 40), AIR( 41), AIR( 42)
     +    / 171.0D0, 180.0D0, 193.0D0, 181.0D0, 183.0D0, 218.0D0/
      DATA  AIR( 43), AIR( 44), AIR( 45), AIR( 46), AIR( 47), AIR( 48)
     +    / 230.0D0, 242.0D0, 209.0D0, 191.0D0, 172.0D0, 194.0D0/
      DATA  AIR( 49), AIR( 50), AIR( 51), AIR( 52), AIR( 53), AIR( 54)
     +    / 196.0D0, 196.0D0, 236.0D0, 235.0D0, 229.0D0, 243.0D0/
      DATA  AIR( 55), AIR( 56), AIR( 57), AIR( 58), AIR( 59), AIR( 60)
     +    / 264.0D0, 272.0D0, 237.0D0, 211.0D0, 180.0D0, 201.0D0/
      DATA  AIR( 61), AIR( 62), AIR( 63), AIR( 64), AIR( 65), AIR( 66)
     +    / 204.0D0, 188.0D0, 235.0D0, 227.0D0, 234.0D0, 264.0D0/
      DATA  AIR( 67), AIR( 68), AIR( 69), AIR( 70), AIR( 71), AIR( 72)
     +    / 302.0D0, 293.0D0, 259.0D0, 229.0D0, 203.0D0, 229.0D0/
      DATA  AIR( 73), AIR( 74), AIR( 75), AIR( 76), AIR( 77), AIR( 78)
     +    / 242.0D0, 233.0D0, 267.0D0, 269.0D0, 270.0D0, 315.0D0/
      DATA  AIR( 79), AIR( 80), AIR( 81), AIR( 82), AIR( 83), AIR( 84)
     +    / 364.0D0, 347.0D0, 312.0D0, 274.0D0, 237.0D0, 278.0D0/
      DATA  AIR( 85), AIR( 86), AIR( 87), AIR( 88), AIR( 89), AIR( 90)
     +    / 284.0D0, 277.0D0, 317.0D0, 313.0D0, 318.0D0, 374.0D0/
      DATA  AIR( 91), AIR( 92), AIR( 93), AIR( 94), AIR( 95), AIR( 96)
     +    / 413.0D0, 405.0D0, 355.0D0, 306.0D0, 271.0D0, 306.0D0/
      DATA  AIR( 97), AIR( 98), AIR( 99), AIR(100), AIR(101), AIR(102)
     +    / 315.0D0, 301.0D0, 356.0D0, 348.0D0, 355.0D0, 422.0D0/
      DATA  AIR(103), AIR(104), AIR(105), AIR(106), AIR(107), AIR(108)
     +    / 465.0D0, 467.0D0, 404.0D0, 347.0D0, 305.0D0, 336.0D0/
      DATA  AIR(109), AIR(110), AIR(111), AIR(112), AIR(113), AIR(114)
     +    / 340.0D0, 318.0D0, 362.0D0, 348.0D0, 363.0D0, 435.0D0/
      DATA  AIR(115), AIR(116), AIR(117), AIR(118), AIR(119), AIR(120)
     +    / 491.0D0, 505.0D0, 404.0D0, 359.0D0, 310.0D0, 337.0D0/
      DATA  AIR(121), AIR(122), AIR(123), AIR(124), AIR(125), AIR(126)
     +    / 360.0D0, 342.0D0, 406.0D0, 396.0D0, 420.0D0, 472.0D0/
      DATA  AIR(127), AIR(128), AIR(129), AIR(130), AIR(131), AIR(132)
     +    / 548.0D0, 559.0D0, 463.0D0, 407.0D0, 362.0D0, 405.0D0/
      DATA  AIR(133), AIR(134), AIR(135), AIR(136), AIR(137), AIR(138)
     +    / 417.0D0, 391.0D0, 419.0D0, 461.0D0, 472.0D0, 535.0D0/
      DATA  AIR(139), AIR(140), AIR(141), AIR(142), AIR(143), AIR(144)
     +    / 622.0D0, 606.0D0, 508.0D0, 461.0D0, 390.0D0, 432.0D0/
!
      CALL SETRV(YMMISS, 144, YMISS)
      CALL DCOPY(144, AIR, 1, Y, 1)
!
!     DEFINE CONSTANTS
!
      CALL IPRINT(IPRT)
!
!     COMMENCE BODY OF ROUTINE
!
      ITEST = 0
!
!     SHORT CALLS
!
      NY = 144
      NYM = 12
      IYM = 12
      M = 12
      NS = 1
      ILOG = -1
      ISIZE = -1
      ISIZE = -1
      IRLIN = -1
      IBAR = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XINC = 0.0D0
!
   10 CONTINUE
!
!     TEST OF VP
!
      WRITE(IPRT, 2000)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      CALL VP(Y, NY, NS)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF VPM
!
      WRITE(IPRT, 2030)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      CALL VPM (Y, YMISS, NY, NS)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF SVP
!
      WRITE(IPRT, 2120)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      CALL SVP (Y, NY, NS, ISYM)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF SVPM
!
      WRITE(IPRT, 2150)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      CALL SVPM (Y, YMISS, NY, NS, ISYM)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF MVP
!
      WRITE(IPRT, 2060)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3030) NS
      CALL MVP (YM, NYM, M, IYM, NS)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF MVPM
!
      WRITE(IPRT, 2090)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3030) NS
      CALL MVPM (YM, YMMISS, NYM, M, IYM, NS)
      WRITE (IPRT, 3000) IERR
!
!     LOG OPTION CALLS
!
   20 CONTINUE
!
!     TEST OF VPL
!
      WRITE(IPRT, 2010)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      CALL VPL (Y, NY, NS, ILOG)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF VPML
!
      WRITE(IPRT, 2040)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      CALL VPML (Y, YMISS, NY, NS, ILOG)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF SVPL
!
      WRITE(IPRT, 2130)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      CALL SVPL (Y, NY, NS, ISYM, ILOG)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF SVPML
!
      WRITE(IPRT, 2160)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      CALL SVPML (Y, YMISS, NY, NS, ISYM, ILOG)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF MVPL
!
      WRITE(IPRT, 2070)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      CALL MVPL (YM, NYM, M, IYM, NS, ILOG)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF MVPML
!
      WRITE(IPRT, 2100)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      CALL MVPML(YM, YMMISS, NYM, M, IYM, NS, ILOG)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF LONG CALLS
!
   30 CONTINUE
!
!     TEST OF VPC
!
      WRITE(IPRT, 2020)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3060) ISIZE, IRLIN, IBAR
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3090) XINC
      CALL VPC (Y, NY, NS, ILOG, ISIZE, IRLIN, IBAR, YLB,
     +   YUB, XLB, XINC)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF VPMC
!
      WRITE(IPRT, 2050)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3060) ISIZE, IRLIN, IBAR
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3090) XINC
      CALL VPMC (Y, YMISS, NY, NS, ILOG, ISIZE, IRLIN, IBAR, YLB,
     +   YUB, XLB, XINC)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF SVPC
!
      WRITE(IPRT, 2140)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3060) ISIZE, IRLIN, IBAR
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3090) XINC
      CALL SVPC (Y, NY, NS, ISYM, ILOG, ISIZE, IRLIN, IBAR, YLB,
     +   YUB, XLB, XINC)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF SVPMC
!
      WRITE(IPRT, 2170)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3060) ISIZE, IRLIN, IBAR
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3090) XINC
      CALL SVPMC(Y, YMISS, NY, NS, ISYM, ILOG, ISIZE, IRLIN, IBAR,
     +   YLB, YUB, XLB, XINC)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF MVPC
!
   40 WRITE(IPRT, 2080)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3060) ISIZE, IRLIN, IBAR
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3090) XINC
      CALL MVPC(YM, NYM, M, IYM, NS, ILOG, ISIZE, YLB,
     +   YUB, XLB, XINC)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF MVPMC
!
   50 WRITE(IPRT, 2110)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3030) NS
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3060) ISIZE, IRLIN, IBAR
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3090) XINC
      CALL MVPMC(YM, YMMISS, NYM, M, IYM, NS, ILOG, ISIZE, YLB,
     +   YUB, XLB, XINC)
      WRITE (IPRT, 3000) IERR
!
      ITEST = ITEST + 1
!
      GO TO (110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 300),
     +  ITEST
!
!     TEST VALID OPTIONS
!
  110 ILOG = 0
      ISIZE = 0
      YLB = 100.0D0
      YUB = 700.0D0
      XLB = 4.0D0
      XINC = 16.0D0
      GO TO 20
!
  120 ILOG = 2
      ISIZE = 2
      NOUT = 5
      XINC = -1.0D0
      GO TO 20
!
  130 ILOG = 20
      ISIZE = 20
      NOUT = 55
      YUB = 300.0D0
      GO TO 30
!
  140 ILOG = 22
      ISIZE = 22
      GO TO 40
!
  150 NY = 1
      NYM = 1
      M = 144
      IYM = 1
      GO TO 40
!
  160 CALL SETRV(Y, 144, 1.0D0)
      NYM = 6
      IYM = 12
      M = 6
      NY = 36
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XINC = 0.0D0
      GO TO 30
!
!     TEST ERROR RESPONSE
!
  170 NY = 0
      NYM = 0
      M = 0
      IYM = -1
      GO TO 10
!
  180 NY = 144
      NYM = 12
      M = 12
      IYM = -1
      XLB = -1.0D0
      YLB = -1.0D0
      GO TO 40
!
  190 IYM = 12
      Y(1) = 0.0D0
      GO TO 50
!
  200 CALL SETRV(Y, 144, YMISS)
      XLB = XINC
      YLB = YUB
      GO TO 50
!
  300 CONTINUE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 2000 FORMAT ('1', 10HTEST OF VP)
 2010 FORMAT ('1', 11HTEST OF VPL)
 2020 FORMAT ('1', 11HTEST OF VPC)
 2030 FORMAT ('1', 11HTEST OF VPM)
 2040 FORMAT ('1', 12HTEST OF VPML)
 2050 FORMAT ('1', 12HTEST OF VPMC)
 2060 FORMAT ('1', 11HTEST OF MVP)
 2070 FORMAT ('1', 12HTEST OF MVPL)
 2080 FORMAT ('1', 12HTEST OF MVPC)
 2090 FORMAT ('1', 12HTEST OF MVPM)
 2100 FORMAT ('1', 13HTEST OF MVPML)
 2110 FORMAT ('1', 13HTEST OF MVPMC)
 2120 FORMAT ('1', 11HTEST OF SVP)
 2130 FORMAT ('1', 12HTEST OF SVPL)
 2140 FORMAT ('1', 12HTEST OF SVPC)
 2150 FORMAT ('1', 12HTEST OF SVPM)
 2160 FORMAT ('1', 13HTEST OF SVPML)
 2170 FORMAT ('1', 13HTEST OF SVPMC)
 3000 FORMAT (/8H IERR = , I4)
 3010 FORMAT (' ', 5X, 10H   N     =, I5)
 3020 FORMAT ('+', 20X, 10H / M     =, I5, 10H / IYM   =, I5)
 3030 FORMAT ('+', 50X, 10H / NS    =, I5)
 3040 FORMAT ('+', 65X, 10H / ILOG  =, I5)
 3060 FORMAT (' ',  5X, '   ISIZE=', I5, ' / IRLIN=', I5,
     +   10H / IBAR  =, I5)
 3070 FORMAT ('+', 50X, 10H / YLB   =, F10.4, 10H / YUB   =, F10.4,
     +   10H / XLB   =, F10.4)
 3090 FORMAT ('+', 110X, 10H / XINC  =, F10.4)
 3100 FORMAT (' ', 13H TEST NUMBER , I5)
      END
!CDFNML
      DOUBLE PRECISION FUNCTION CDFNML(X)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE NORMAL CUMULATIVE DISTRIBUTION
!     FUNCTION FROM THE ERROR FUNCTION AS DESCRIBED IN CHAPTER 13
!     OF DISTRIBUTIONS IN STATISTICS - CONTINUOUS UNIVARIATE
!     DISTRIBUTIONS - 1, BY JOHNSON AND KOTZ.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE - DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   X
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   DERF
      EXTERNAL DERF
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION X
!        THE PERCENT POINT FROM THE CHI SQUARED DISTRIBUTION.
!
!     COMMENCE BODY OF ROUTINE
!
      CDFNML = 0.5D0 * (1.0D0 + DERF(X/SQRT(2.0D0)))
!
      RETURN
      END
!AOV1MN
      SUBROUTINE AOV1MN(Y, TAG, N, TVALUE, TSIZE, TMEAN, TSD, NPRT,
     +   INDEX, SRANK, GPMIN, GPMAX, B10, RANKS, ITEMP, NG, NZW)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES A COMPREHENSIVE SET OF RESULTS FOR
!     ANALYSIS OF A ONE-WAY CLASSIFICATION WITH OPTIONAL PRINTED OUTPUT.
!     TAG VALUES CAN BE ANY VALUE WHERE ALL MEASUREMENTS WITH TAG
!     VALUES LESS THAN OR EQUAL TO ZERO ARE EXCLUDED FROM ANALYSIS.
!
!     ORIGINALLY WRITTEN FOR OMNITAB BY -
!       DAVID HOGBEN, STATISTICAL ENGINEERING DIVISION, NBS (10/25/69)
!
!     ADAPTED  BY -
!       JANET R. DONALDSON
!       STATISTICAL ENGINEERING DIVISION
!       NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N,NG,NPRT,NZW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   B10(*),GPMAX(*),GPMIN(*),RANKS(*),SRANK(*),TAG(*),TMEAN(*),
     +   TSD(*),TSIZE(*),TVALUE(*),Y(*)
      INTEGER
     +   INDEX(*),ITEMP(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   AF,BF,BFRAT,BFSIG,BMS,BSS,C,CC,CFKW,DF,DFRAT,DFSIG,DMS,DSS,F,
     +   F1KW,F2KW,FMLC,FMUC,FNZW,FPLM,FSTAT,G1,GM,GR,HSTAT,IBAR,K0,
     +   MF,MKW,Q,RESSQ,RMLC,RMUC,RX,SBMS,SC,SFRAT,SFSIG,SIGKW,SLBF,
     +   SLCC,SMAX,SMIN,SMS,SNC,SOS,SQB,SQMS,SQOM,SQT,SSF,SSS,STMS,
     +   SUM,SWMS,T1,T2,T3,TIES,TMS,TSS,U1,U2,UMLC,UMUC,V1,V2,VKW,VLS,
     +   WMS,WSS,YBMAX,YBMIN,YMAX,YMIN
      INTEGER
     +   I,IPRT,ISZ,J,K,KK,KKK,L,M,M28,M3,M5,NN,NNE1,NZPNTR
      CHARACTER
     +   BLANK*1,HIGH*1,ISD*1,LOW*1,MEAN*1
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   STATS(15)
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFF,PPFF,PPFT,D1MACH
      EXTERNAL CDFF,PPFF,PPFT,D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GENI,IPRINT,RANKO,SRTIR,SRTRI,SRTRRI
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,ANINT,INT,LOG,MAX,MIN,NINT,DBLE,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AF
!        A FOR F
!     DOUBLE PRECISION BF
!        BARTLETT F
!     DOUBLE PRECISION BFRAT
!        BETWEEN GROUPS F RATIO
!     DOUBLE PRECISION BFSIG
!        BETWEEN GROUPS SIGNIFICANCE LEVEL
!     CHARACTER*1 BLANK
!        HOLLERITH BLANK
!     DOUBLE PRECISION BMS
!        BETWEEN MS
!     DOUBLE PRECISION BSS
!        BETWEEN SS
!     DOUBLE PRECISION B10(NG)
!        *
!     DOUBLE PRECISION C
!        INTERMEDIATE RESULT STORAGE
!     DOUBLE PRECISION CC
!        COCHRANS C
!     DOUBLE PRECISION CFKW
!        CORRECTION FACTOR FOR KRUSKAL-WALLIS
!     DOUBLE PRECISION DF
!        D.F.
!     DOUBLE PRECISION DFRAT
!        DEVIATIONS ABOUT LINE F RATIO
!     DOUBLE PRECISION DFSIG
!        DEVIATIONS ABOUT LINE F SIGNIFICANCE LEVEL
!     DOUBLE PRECISION DMS
!        DEVIATIONS ABOUT LINE MS
!     DOUBLE PRECISION DSS
!        DEVIATIONS ABOUT LINE SS
!     DOUBLE PRECISION F
!        BETWEEN MEANS F-TEST
!     DOUBLE PRECISION FMLC
!        FIXED MODEL LOWER CONFIDENCE LIMIT FOR MEAN
!     DOUBLE PRECISION FMUC
!        FIXED MODEL UPPER CONFIDENCE LIMIT FOR MEAN
!     DOUBLE PRECISION FNZW
!        *
!     DOUBLE PRECISION FPLM
!        LARGEST SINGLE PRECISION MAGNITUDE OF MACHINE
!     DOUBLE PRECISION FSTAT
!        F STATISTIC ASSOCIATED WITH KRUSKAL-WALLIS H STATISTIC
!     DOUBLE PRECISION F1KW
!        F1 D.F. FOR KRUSKAL-WALLIS F
!     DOUBLE PRECISION F2KW
!        F2 D.F. FOR KRUSKAL-WALLIS F
!     DOUBLE PRECISION GM
!        GRAND MEAN, MEAN OF ALL OBSERVATIONS WITH POSITIVE
!        NON-ZERO TAGS
!     DOUBLE PRECISION GPMAX(NG)
!        THE VECTOR OF MAXIMUM OBSERVATIONS FOR EACH GROUP
!     DOUBLE PRECISION GPMIN(NG)
!        THE VECTOR OF MINIMUM OBSERVATIONS FOR EACH GROUP
!     DOUBLE PRECISION GR
!        NZW-NG
!     DOUBLE PRECISION G1
!        NG-1
!     CHARACTER*1 HIGH
!        HOLLERITH + (PLUS)
!     DOUBLE PRECISION HSTAT
!        KRUSKAL-WALLIS H STATISTIC, SEE BROWNLEE(1965), PAGE 256
!     INTEGER I
!        INDEX VARIABLE
!     DOUBLE PRECISION IBAR
!        I BAR, ((SUM OF I)/NZW), WHERE I=1,NZW
!     INTEGER INDEX(N)
!        PERMUTATION VECTOR FOR Y AND LATER FOR TMEAN
!     INTEGER IPRT
!        THE OUTPUT LOGICAL UNIT NUMBER
!     CHARACTER*1 ISD
!        CAN CONTAIN FOLLOWING CHARACTERS FOR PRINTING
!        +, -,  (BLANK)
!     INTEGER ISZ
!        INTEGER SIZE OF GROUP
!     INTEGER ITEMP(NZW)
!        TEMPORARY INDEX VECTOR USED IN COMPUTING RANKS
!     INTEGER J
!        AN INDEX VARIABLE
!     INTEGER K
!        INDEX VARIABLE
!     INTEGER KK
!        POINTER TO THE LARGEST OF THE GROUP MEANS
!     INTEGER KKK
!        POINTER TO THE SMALLEST OF THE GROUP MEANS
!     DOUBLE PRECISION K0
!        = NZW - (SNC/NZW)/ G1
!     INTEGER L
!        INDEX VARIABLE
!     CHARACTER*1 LOW
!        HOLLERITH - (MINUS)
!     INTEGER M
!        INDEX VARIABLE
!     CHARACTER*1 MEAN
!        CAN CONTAIN FOLLOWING CHARACTERS FOR PRINTING
!        +, -,  (BLANK)
!     DOUBLE PRECISION MF
!        M FOR F
!     DOUBLE PRECISION MKW
!        M FOR KRUSKAL-WALLIS MEAN
!     INTEGER M28
!        USED IN CREATING BACKWARD LOOP
!     INTEGER M3
!        NG - 2
!     INTEGER M5
!        NZW - 1
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NG
!        THE NUMBER OF GROUPS OF DIFFERENT POSITIVE TAG VALUES
!     INTEGER NN
!        AID IN PRINTING VALUES
!     INTEGER NNE1
!        NUMBER OF GROUPS WITH SIZE NOT EQUAL TO ONE
!     INTEGER NPRT
!        THE VARAIBLE CONTROLLING AUTOMATIC PRINTOUT
!        IF NPRT = 0, PRINTOUT SUPPRESSED
!           OTHERWISE PRINTOUT PROVIDED
!     INTEGER NZPNTR
!        A POINTER TO THE FIRST NON-ZERO TAG IN THE SORTED TAG VECTOR
!     INTEGER NZW
!        THE NUMBER OF OBSERVATIONS WITH POSITIVE, NON-ZERO, TAG VALUES
!     DOUBLE PRECISION Q
!        SIGNIFICANCE LEVEL FROM F-DISTRIBUTION
!     DOUBLE PRECISION RANKS(NZW)
!        THE RANKS OF THE OBSERVATIONS WITH POSITIVE TAG VALUES
!     DOUBLE PRECISION RESSQ
!        RESIDUALS SQUARED
!     DOUBLE PRECISION RMLC
!        RANDOM MODEL LOWER CONFIDENCE LIMIT FOR MEAN
!     DOUBLE PRECISION RMUC
!        RANDOM MODEL UPPER CONFIDENCE LIMIT FOR MEAN
!     DOUBLE PRECISION RX
!        USED IN CALCULATING MANDEL APPROXIMATION
!     DOUBLE PRECISION SBMS
!        SQRT BETWEEN MS
!     DOUBLE PRECISION SC
!        SUM OF N(I) CUBED, WHERE N(I) IS THE SIZE OF GROUP I
!     DOUBLE PRECISION SFRAT
!        SLOPE F RATIO
!     DOUBLE PRECISION SFSIG
!        SLOPE F SIGNIFICANCE LEVEL
!     DOUBLE PRECISION SIGKW
!        SIGNIFICANCE LEVEL FOR KRUSKAL-WALLIS F (OR H)
!     DOUBLE PRECISION SLBF
!        SIGNIFICANCE LEVEL FOR BARLETT F
!     DOUBLE PRECISION SLCC
!        SIGNIFICANCE LEVEL FOR COCHRANS C
!     DOUBLE PRECISION SMAX
!        MAXIMUM OF S(I), WHERE S(I) IS THE STD. DEV. OF GROUP I
!     DOUBLE PRECISION SMIN
!        MINIMUM OF S(I)
!     DOUBLE PRECISION SMS
!        SLOPE MS
!     DOUBLE PRECISION SNC
!        SUM OF N(I) SQUARED
!     DOUBLE PRECISION SOS
!        SUM OF S(I) SQUARED
!     DOUBLE PRECISION SQB
!        SQRT BETWEEN MS / NZW
!     DOUBLE PRECISION SQMS
!        SQRT WITHIN MS / NZW
!     DOUBLE PRECISION SQOM
!        OMEGA HAT SQUARED
!     DOUBLE PRECISION SQT
!        SQRT TOTAL MS / NZW
!     DOUBLE PRECISION SRANK(NG)
!        THE SUM OF THE RANKS FOR THE OBSERVATIONS IN EACH GROUP
!     DOUBLE PRECISION SSF
!        S * SQRT(NG-1) * F
!     DOUBLE PRECISION SSS
!        SLOPE SS
!     DOUBLE PRECISION STATS(15)
!        VECTOR OF STATISTICS
!     DOUBLE PRECISION STMS
!        SQRT TOTAL MS
!     DOUBLE PRECISION SUM
!        INTERMIDIATE VALUE
!     DOUBLE PRECISION SWMS
!        SQRT WITHIN MS
!     DOUBLE PRECISION TAG(N)
!        VECTOR OF CLASSIFICATION VALUES - VALUES LESS THAN OR EQUAL
!        TO ZERO ARE IGNORED FOR ANALYSIS.  ON ENTERING TAG IS
!        SORTED SMALLEST TO LARGEST
!     DOUBLE PRECISION TIES
!        *
!     DOUBLE PRECISION TMEAN(NG)
!        THE MEAN OF EACH OF THE GROUPS
!     DOUBLE PRECISION TMS
!        TOTAL MS
!     DOUBLE PRECISION TSD(NG)
!        THE STANDARD DEVIATIONS OF EACH OF THE GROUPS (NOT THE
!        STANDARD DEVIATIONS OF THE MEANS)
!     DOUBLE PRECISION TSIZE(NG)
!        THE SIZE OF EACH OF THE DIFFERENT GROUPS
!     DOUBLE PRECISION TSS
!        TOTAL SS
!     DOUBLE PRECISION TVALUE(NG)
!        THE DIFFERENT POSITIVE (NON-ZERO) TAG VALUES ANALYZED, ORDERED
!        FROM SMALLEST TO LARGEST
!     DOUBLE PRECISION T1
!        T(.05,NG-1)
!     DOUBLE PRECISION T2
!        T(.05,NG-1)
!     DOUBLE PRECISION T3
!        T(.05,NZW-1)
!     DOUBLE PRECISION UMLC
!        UNGROUPED MODEL LOWER CONFIDENCE LIMIT FOR MEAN
!     DOUBLE PRECISION UMUC
!        UNGROUPED MODEL UPPER CONFIDENCE LIMIT FOR MEAN
!     DOUBLE PRECISION U1, U2
!        USED IN CALCULATING MANDEL APPROXIMATION
!     DOUBLE PRECISION VKW
!        U FOR KRUSKAL-WALLIS F
!     DOUBLE PRECISION VLS
!        LARGEST VARIANCE / SMALLEST VARIANCE
!     DOUBLE PRECISION V1, V2
!        USED IN CALCULATING MANDEL APPROXIMATION
!     DOUBLE PRECISION WMS
!        WITHIN MS
!     DOUBLE PRECISION WSS
!        WITHIN SS
!     DOUBLE PRECISION Y(N)
!        OBSERVATIONS TO BE ANALYZED, SORTED BY TAGS
!        Y(NZPNTR) IS THE FIRST ELEMENT WITH A NON-ZERO TAG
!     DOUBLE PRECISION YBMAX
!        MAXIMUM YBAR(I), WHERE YBAR(I) IS THE MEAN OF GROUP I
!     DOUBLE PRECISION YBMIN
!        MINIMUN YBAR(I)
!     DOUBLE PRECISION YMAX
!        MAXIMUM OBSERVATION
!     DOUBLE PRECISION YMIN
!        MINIMUM OBSERVATION
!
!     MACHINE DEPENDENT VARIABLE - FPLM
!
      DATA BLANK /' '/
      DATA LOW /'-'/
      DATA HIGH /'+'/
!
      CALL IPRINT(IPRT)
      FPLM = D1MACH(2)
      NZPNTR = N - NZW + 1
      FNZW = NZW
!
!     ZERO WORK VECTORS
!
      DO 10 I=1,NG
         TVALUE(I) = 0.0D0
         TSIZE(I) = 0.0D0
         TMEAN(I) = 0.0D0
         TSD(I) = 0.0D0
         SRANK(I) = 0.0D0
         GPMIN(I) = 0.0D0
         GPMAX(I) = 0.0D0
         B10(I) = 0.0D0
   10 CONTINUE
!
      DO 20 I=1,15
         STATS(I) = 0.0D0
   20 CONTINUE
!
      CC = 0.0D0
      F = 0.0D0
      DMS = 0.0D0
      BSS = 0.0D0
      WSS = 0.0D0
      HSTAT = 0.0D0
      MF = 0.0D0
      SC = 0.0D0
      SMAX = 0.0D0
      NNE1 = 0
      SNC = 0.0D0
      SOS = 0.0D0
      SSS = 0.0D0
      SUM = 0.0D0
      TIES = 0.0D0
      TSS = 0.0D0
      SMIN = 0.0D0
      SFRAT = 0.0D0
!
!     BEGIN COMPUTATIONS
!
!     COMPUTE RANKS
!
      CALL RANKO(NZW, Y(NZPNTR), ITEMP, RANKS, TIES)
!
!     INITIALIZE FIRST ELEMENT BEFORE ENTERING LOOP
!
      TVALUE(1) = TAG(NZPNTR)
      SRANK(1) = RANKS(1)
      GPMIN(1) = Y(NZPNTR)
      GPMAX(1) = Y(NZPNTR)
      YMIN = GPMIN(1)
      YMAX = GPMAX(1)
      GM = Y(NZPNTR)
      IBAR = 1.0D0
      TMEAN(1) = Y(NZPNTR)
      TSIZE(1) = 1.0D0
!
!     DETERMINE MEANS AND MAXS, DO SUMMATION PRIOR TO
!     DETERIMING MEANS
!     HERE J IS THE GROUP NUMBER
!
      J = 1
      L = NZPNTR + 1
      DO 50 I=L,N
         IF (TAG(I).EQ.TAG(I-1)) GO TO 40
!
!        NEW TAG GROUP
         J = J + 1
         TVALUE(J) = TAG(I)
         GPMIN(J) = Y(I)
         GPMAX(J) = Y(I)
   40    TSIZE(J) = TSIZE(J) + 1.0D0
         TMEAN(J) = TMEAN(J) + Y(I)
         GM = GM + Y(I)
!
!     UNNECESSARY COMPUTATIONS IF PRINTED OUTPUT IS SUPRESSED
!
         IF (NPRT.EQ.0) GO TO 50
         K = I + 1 - NZPNTR
         SRANK(J) = SRANK(J) + RANKS(K)
         GPMIN(J) = MIN(GPMIN(J),Y(I))
         GPMAX(J) = MAX(GPMAX(J),Y(I))
         YMIN = MIN(YMIN,GPMIN(J))
         YMAX = MAX(YMAX,GPMAX(J))
         IBAR = IBAR + J
   50 CONTINUE
!
!     CALCULATE MEANS
!
      GM = GM/FNZW
      IBAR = IBAR/FNZW
      K = NZPNTR-1
      I = NZPNTR
      DO 70 J=1,NG
         IF (TSIZE(J).GE.2.0D0) THEN
            TMEAN(J) = TMEAN(J)/TSIZE(J)
         ELSE
            TMEAN(J) = TMEAN(J)
         END IF
         K = K + INT(TSIZE(J))
!
!     L GIVES INDEX TO Y VALUE WITHIN GROUP J
!
         DO 60 L=I,K
            RESSQ = (Y(L)-TMEAN(J))*(Y(L)-TMEAN(J))
            TSD(J) = TSD(J) + RESSQ
            IF (NPRT.EQ.0) GO TO 60
            BSS = BSS + (TMEAN(J)-GM)*(TMEAN(J)-GM)
            WSS = WSS + RESSQ
            TSS = TSS + (Y(L)-GM)*(Y(L)-GM)
   60    CONTINUE
         I = K + 1
   70 CONTINUE
!
!     NOW DONE WITH TAG VECTOR, RETURN VECTOR TO INPUT ORDER
!     INDEX IS FREED FOR USE IN OTHER PLACES
!
      CALL SRTRRI(TAG, Y, N, INDEX)
!
!     CHECK FOR PRINTED OUTPUT
!
      IF (NPRT.NE.0) GO TO 90
!
!     COMPUTE STANDARD DEVIATIONS WITHIN EACH GROUP
!
      DO 80 J=1,NG
         TSD(J) = SQRT(TSD(J))
         IF (TSIZE(J).LE.1.0D0) GO TO 80
         TSD(J) = TSD(J)/SQRT(TSIZE(J)-1.0D0)
   80 CONTINUE
!
!     COMPUTATIONS COMPLETE FOR STORED OUTPUT - RETURN IF PRINTED
!     OUTPUT IS SUPRESSED
!
      RETURN
   90 YBMIN = TMEAN(1)
      YBMAX = TMEAN(1)
      SMIN = FPLM
!     HERE I IS THE GROUP NUMBER
      DO 120 I=1,NG
         IF (TSD(I).GT.0.0D0) THEN
            B10(I) = TSIZE(I)*(TSIZE(I)-1.0D0)/TSD(I)
            STATS(1) = STATS(1) + B10(I)*TMEAN(I)
            STATS(2) = STATS(2) + B10(I)
            IF (TSIZE(I).GT.1.0D0) THEN
               TSD(I) = SQRT(TSD(I)/(TSIZE(I)-1.0D0))
            END IF
            MF = MF + (TSIZE(I)-1.0D0)*LOG(TSD(I)*TSD(I))
         END IF
         IF (NINT(TSIZE(I)).GE.2) THEN
            NNE1 = NNE1 + 1
            SMAX = MAX(SMAX,TSD(I))
            SMIN = MIN(SMIN,TSD(I))
            STATS(3) = STATS(3) + 1.0D0/(TSIZE(I)-1.0D0)
         END IF
         SSS = SSS + TSIZE(I)*(I-IBAR)*(TMEAN(I)-GM)
         STATS(4) = STATS(4) + TSIZE(I)*(I-IBAR)*(I-IBAR)
!
!        LOOK FOR SMALLEST AND LARGEST MEANS (YBAR)
!
         YBMIN = MIN(YBMIN,TMEAN(I))
         YBMAX = MAX(YBMAX,TMEAN(I))
!
         HSTAT = HSTAT + SRANK(I)*SRANK(I)/TSIZE(I)
         SUM = SUM + 1.0D0/TSIZE(I)
         STATS(5) = STATS(5) + (TMEAN(I)-GM)*(TMEAN(I)-GM)
         SOS = SOS + TSD(I)*TSD(I)
         SNC = SNC + TSIZE(I)*TSIZE(I)
         SC = SC + TSIZE(I)*TSIZE(I)*TSIZE(I)
  120 CONTINUE
      IF (STATS(2).NE.0.0D0) STATS(1) = STATS(1)/STATS(2)
      IF (STATS(4).NE.0.0D0) SSS = SSS*SSS/STATS(4)
      DSS = BSS - SSS
!
!     DEGREES OF FREEDOM FOR ANOVA
!
      G1 = NG-1
      M3 = NG - 2
      GR = NZW-NG
      M5 = NZW - 1
!
!     MEAN SQUARES
!
      BMS = BSS/G1
      SMS = SSS
      IF (NG.GE.3) DMS = DSS/M3
      WMS = WSS/GR
      TMS = TSS/M5
      IF (WMS.EQ.BMS) THEN
         BFRAT = 1.0D0
         BFSIG = 1.0D0
      ELSE IF (WMS.EQ.0.0D0) THEN
         BFRAT = FPLM
         BFSIG = 0.0D0
      ELSE
         BFRAT = BMS/WMS
         BFSIG = 1.0D0 - CDFF(BFRAT,G1,GR)
      END IF
      IF (WMS.EQ.DMS) THEN
         DFRAT = 1.0D0
         DFSIG = 1.0D0
      ELSE IF (WMS.EQ.0.0D0) THEN
         DFRAT = FPLM
         DFSIG = 0.0D0
      ELSE
         DFRAT = DMS/WMS
         DFSIG = 1.0D0 - CDFF(DFRAT,DBLE(M3),DBLE(NZW-2))
      END IF
      IF (SMS.EQ.DSS+WSS) THEN
         SFRAT = 1.0D0
         SFSIG = 1.0D0
      ELSE IF (DSS+WSS.EQ.0.0D0) THEN
         SFRAT = FPLM
         SFSIG = 0.0D0
      ELSE
         SFRAT = SMS/((DSS+WSS)/(FNZW-2.0D0))
         SFSIG = 1.0D0 - CDFF(SFRAT,1.0D0,GR)
      END IF
!
!     COMPUTE FOR KRUSKAL-WALLIS TEST
!     FOR FORMULAE WITH CLEARER FORM AND NAMES SEE
!     KRAFT AND VAN EEDEN  A NON PARAMETRIC INTRODUCTION TO STATISTICS,
!     PP. 238 - 240
!
      STATS(6) = NZW*(NZW+1)
      HSTAT = (12.0D0*HSTAT/STATS(6)) - (3.0D0*(NZW+1))
      IF (TIES.EQ.NZW*NZW*NZW-NZW) THEN
         CFKW = 0.0D0
         HSTAT = 0.0D0
         MKW = 0.0D0
      ELSE
         CFKW = 1.0D0 - TIES/(NZW*NZW*NZW-NZW)
         HSTAT = HSTAT/CFKW
         MKW = ((NZW*NZW*NZW-SC)/STATS(6))/CFKW
      END IF
      VKW = 2.0D0*G1 -
     +   (0.4D0*(3*NG*M3+NZW*(2*NG*(NG-3)+1)))/STATS(6)
     +   - 6.0D0*SUM/5.0D0
      IF (MKW-HSTAT.GT.0.0D0 .AND.
     +    MKW.NE.0.0D0 .AND. VKW.NE.0.0D0) THEN
         F1KW = (G1*(G1*(MKW-G1)-VKW))/(0.5D0*VKW*MKW)
         F2KW = (MKW-G1)*F1KW/G1
         FSTAT = (HSTAT*(MKW-G1))/(G1*(MKW-HSTAT))
         SIGKW = 1.0D0 - CDFF(FSTAT,ANINT(F1KW),ANINT(F2KW))
      ELSE
         SIGKW = 0.0D0
      END IF
!
!     COMPUTE TOTAL STATISTICS
!
      SWMS = SQRT(WMS)
      SBMS = SQRT(STATS(5)/G1)
      STMS = SQRT(TMS)
      SQMS = SWMS/(SQRT(FNZW))
      SQB = SBMS/(SQRT(DBLE(NG)))
      SQT = STMS/(SQRT(FNZW))
      T1 = PPFT(0.975D0,INT(GR))
      T2 = PPFT(0.975D0,INT(G1))
      T3 = PPFT(0.975D0,M5)
      FMLC = GM - SQMS*T1
      RMLC = GM - SQB*T2
      UMLC = GM - SQT*T3
      FMUC = GM + SQMS*T1
      RMUC = GM + SQB*T2
      UMUC = GM + SQT*T3
!
      SSF = SWMS*SQRT(G1*PPFF(0.95D0,INT(G1),INT(GR)))
!
!     TESTS FOR HOMOGENEITY OF VARIANCES
!
      IF (SMAX*SMAX.EQ.SOS) THEN
         CC = 1.0D0
      ELSE IF (SOS.NE.0.0D0) THEN
         CC = SMAX*SMAX/SOS
      END IF
      STATS(7) = ANINT(FNZW/NG)
      IF ((NNE1.GE.2) .AND. (CC.NE.1.0D0)) THEN
         SLCC = 1.0D0 -
     +          CDFF((NNE1-1)*CC/(1.0D0-CC),STATS(7),
     +          STATS(7)*(NNE1-1))
      ELSE
         SLCC = 1.0D0
      END IF
      SLCC = (NNE1-1)*SLCC
      IF (SLCC.GT.1.0D0) SLCC = 1.0D0
!
      IF (SMIN.EQ.SMAX) THEN
         VLS = 1.0D0
      ELSE
         IF (SMIN.EQ.0.0D0) THEN
            VLS = FPLM
         ELSE
            VLS = (SMAX/SMIN)*(SMAX/SMIN)
         END IF
      END IF
      IF (WMS.GT.0.0D0) MF = GR*LOG(WMS) - MF
      AF = (STATS(3)-(1.0D0/GR))/(3.0D0*G1)
      SLBF = 1.0D0
      IF ((AF.NE.1.0D0) .AND. (NNE1.GE.2)) THEN
         DF = (NNE1+1)/(AF*AF)
         BF = (DF*MF)/((NNE1-1)*(DF/(1.0D0-AF+(2.0D0/DF))-MF))
         IF (BF.LT.0.0D0) BF = 0.0D0
         SLBF = 1.0D0 - CDFF(BF,DBLE(NNE1-1),ANINT(DF))
      ELSE
         BF = FPLM
      END IF
      K0 = (FNZW-(SNC/FNZW))/G1
      SQOM = (BMS-WMS)/K0
!
!     COMPUTATIONS ARE NOW COMPLETE ************************************
!
!     PRINT ANOVA
!
      NN = N - NZW
      WRITE (IPRT,1000) NN
      NN = NG - 1
      WRITE (IPRT,1010) NN, BSS, BMS, BFRAT, BFSIG
      IF (NG.LT.3) GO TO 180
      IF (BFSIG.GE..10) GO TO 180
      NN = 1
      WRITE (IPRT,1020) NN, SSS, SMS, SFRAT, SFSIG
      WRITE (IPRT,1030) M3, DSS, DMS, DFRAT, DFSIG
  180 NN = NZW - NG
      WRITE (IPRT,1040) NN, WSS, WMS
      WRITE (IPRT,1050) M5, TSS
!
!     PRINT KRUSKAL-WALLIS TEST
!
      WRITE (IPRT,1060) HSTAT, SIGKW
!
!     PRINT ESTIMATES
!
      WRITE (IPRT,1070)
      DO 200 I=1,NG
         MEAN = BLANK
         IF (TMEAN(I).LE.YBMIN) MEAN = LOW
         IF (TMEAN(I).GE.YBMAX) MEAN = HIGH
         ISD = BLANK
         IF (TSD(I).LE.SMIN) ISD = LOW
         IF (TSD(I).GE.SMAX) ISD = HIGH
         ISZ = INT(TSIZE(I))
         IF (ISZ.LE.1) THEN
            WRITE (IPRT,1090) TVALUE(I), ISZ, TMEAN(I), MEAN, GPMIN(I),
     +         GPMAX(I), SRANK(I)
         ELSE
            STATS(9) = TSD(I)/SQRT(TSIZE(I))
            STATS(10) = PPFT(0.975D0,ISZ-1)
            STATS(8) = TMEAN(I) - STATS(9)*STATS(10)
            STATS(11) = TMEAN(I) + STATS(9)*STATS(10)
            WRITE (IPRT,1080) TVALUE(I), ISZ, TMEAN(I), MEAN, TSD(I),
     +                        ISD, STATS(9), GPMIN(I), GPMAX(I),
     +                        SRANK(I), STATS(8), STATS(11)
         END IF
  200 CONTINUE
      WRITE (IPRT,1100) NZW, GM, YMIN, YMAX, SWMS, SQMS, FMLC, FMUC,
     +   SBMS, SQB, RMLC, RMUC, STMS, SQT, UMLC, UMUC
      IF (BFSIG.LT.0.10) THEN
!
!     SORT YBAR FOR MULTIPLE COMPARISIONS OF MEANS
!
         CALL GENI(INDEX, NG, 1, 1)
         CALL SRTIR(INDEX, NG, TMEAN)
!
!     COMPUTE AND PRINT FOR MULTIPLE COMPARISIONS
!
         IF (NZW-NG.LT.4) GO TO 270
         WRITE (IPRT,1110)
!
!     NEWMAN-KEULS-HARTLEY
!
         WRITE (IPRT,1120)
         RX = -.283917D0 + 2.63532D0*(GR-1.00123D0)**(-.95862D0)
         U1 = -.314115D0 + 2.38301D0*(GR-1.03428D0)**(-.864005D0)
         U2 = 3.65961D0*U1**2 - 1.00891D0*U1 - 0.166346D0
         J = 1
         M28 = 0
  210    I = NG
  220    IF (I.LE.M28) GO TO 260
         IF (I.EQ.J) GO TO 230
         STATS(14) = ABS(TMEAN(I)-TMEAN(J))
!
!     MANDEL APPROXIMATION TO PERCENT POINT OF STUDENTIZED RANGE
!
         STATS(12) = I-J+1
         C = 2.3849867D0 -
     +       2.9051857D0*(STATS(12)-0.57583164D0)**(-.069648109D0)
         V1 = 1.30153D0 -
     +        1.95073D0*(STATS(12)+.394915D0)**(-.139783D0)
         V2 = 4.72863D0*V1**2 + 0.404271D0*V1 - 0.135104D0
         STATS(13) = 6.15075D0 + 4.441409D0*RX +
     +               6.7514569D0*C + 7.4671282D0*U1*V1 -
     +               0.157537D0*U2*V2
         KK = INDEX(I)
         KKK = INDEX(J)
         STATS(13) = STATS(13)*
     +            SQRT(0.5D0*((1.0D0/TSIZE(KK))+(1.0D0/TSIZE(KKK))))*
     +            SWMS
         IF (STATS(14).LE.STATS(13)) GO TO 230
         I = I - 1
         GO TO 220
  230    IF (J.EQ.1) GO TO 250
         IF (J.GT.M28) GO TO 240
         WRITE (IPRT,1150)
         GO TO 250
  240    WRITE (IPRT,1160)
  250    WRITE (IPRT,1140) (TMEAN(M),M=J,I)
         IF (I.GE.NG) GO TO 270
         M28 = I
  260    J = J + 1
         GO TO 210
!
!     SCHEFFE METHOD
!
  270    WRITE (IPRT,1130)
         J = 1
         M28 = 0
  280    I = NG
  290    IF (I.LE.M28) GO TO 330
         IF (I.EQ.J) GO TO 300
         KK = INDEX(I)
         KKK = INDEX(J)
         STATS(14) = ABS(TMEAN(I)-TMEAN(J))
         STATS(13) = SSF*SQRT((1.0D0/TSIZE(KK))+(1./TSIZE(KKK)))
         IF (STATS(14)-STATS(13).LE.0.0D0) GO TO 300
         I = I - 1
         GO TO 290
  300    IF (J.EQ.1) GO TO 320
         IF (J.GT.M28) GO TO 310
         WRITE (IPRT,1150)
         GO TO 320
  310    WRITE (IPRT,1160)
  320    WRITE (IPRT,1140) (TMEAN(M),M=J,I)
         IF (I.GE.NG) GO TO 340
         M28 = I
  330    J = J + 1
         GO TO 280
!
!     RETURN TAG MEANS TO ORIGINAL ORDER
!
  340    CALL SRTRI(TMEAN, NG, INDEX)
      END IF
!
      IF (NNE1.LE.1) RETURN
      WRITE (IPRT,1170) CC, SLCC, BF, SLBF, VLS
      IF (SLCC.GT.0.1D0 .AND. SLBF.GT.0.1D0) GO TO 390
      DO 360 I=1,NG
         F = F + B10(I)*(TMEAN(I)-STATS(1))*(TMEAN(I)-STATS(1))
         IF (STATS(2).EQ.0.0D0 .OR. TSIZE(I).LE.1.0D0) GO TO 360
         STATS(15) = STATS(15) +
     +               (1.0D0-B10(I)*B10(I)/STATS(2)/STATS(2))/
     +               (TSIZE(I)-1.0D0)
  360 CONTINUE
      IF (STATS(15).EQ.0.0D0) GO TO 370
      STATS(15) = (NG*NG-1.0D0)/(3.0D0*STATS(15))
      IF (NG.LE.1) GO TO 370
      F = (F/G1)/(1.0D0+(2.0D0*M3/(3.0D0*STATS(15))))
      GO TO 380
  370 F = 0.0D0
  380 Q = 1.0D0 - CDFF(F,G1,ANINT(STATS(15)))
      WRITE (IPRT,1180) F, Q
  390 WRITE (IPRT,1190) SQOM
      RETURN
!
!     AUTOMATIC PRINTOUT IS FINISHED
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(54H *GROUP NUMBERS HAVE BEEN ASSIGNED ACCORDING TO TAG VA,
     +   59HLUES GIVEN, WHERE THE SMALLEST TAG GREATER THAN ZERO HAS BE,
     +   14HEN ASSIGNED  */41H *GROUP NUMBER 1, THE NEXT SMALLEST, GROU,
     +   59HP NUMBER 2, ETC.  TAGS LESS THAN OR EQUAL TO ZERO HAVE NOT ,
     +   27HBEEN INCLUDED IN ANALYSIS.*/28H *NUMBER OF VALUES EXCLUDED ,
     +   17HFROM ANALYSIS IS , I4, 77X, 1H*//17X, 6HSOURCE, 14X, 4HD.F.,
     +   4X, 14HSUM OF SQUARES, 5X, 12HMEAN SQUARES, 9X, 7HF RATIO, 4X,
     +   7HF PROB./)
 1010 FORMAT(17X, 14HBETWEEN GROUPS, 5X, I4, 1P2E18.6, 4X, 0PE11.3,
     +   F10.3)
 1020 FORMAT(20X, 5HSLOPE, 14X, I4, 1P2E18.6, 3X, 0PE11.3, F10.3)
 1030 FORMAT(20X, 16HDEVS. ABOUT LINE, 3X, I4, 1P2E18.6, 3X, 0PE11.3,
     +   F10.3)
 1040 FORMAT(17X, 13HWITHIN GROUPS, 6X, I4, 1P2E18.6)
 1050 FORMAT(17X, 5HTOTAL, 14X, I4, 1PE18.6//)
 1060 FORMAT(11X, 49HKRUSKAL-WALLIS RANK TEST FOR DIFFERENCE BETWEEN G,
     +   16HROUP MEANS * H =, E11.3, 10H, F PROB =, F6.3, 10H (APPROX.)
     +   /)
 1070 FORMAT(55X, 9HESTIMATES/96X, 6HSUM OF/5X, 5H TAG , 10X, 3HNO.,
     +   6X, 4HMEAN, 7X, 11HWITHIN S.D., 2X, 12HS.D. OF MEAN, 5X,
     +   7HMINIMUM, 7X, 7HMAXIMUM, 6X, 5HRANKS, 3X, 16H95PCT CONF INT F,
     +   7HOR MEAN/)
 1080 FORMAT(1X, 1PE14.6, I8, E14.5, A1, E13.5, A1, E13.5, 2E14.5,
     +   0PF9.1, 1PE13.5, 3H TO, E12.5)
 1090 FORMAT(1X, 1PE14.6, I8, E14.5, A1, 3X, 23H ESTIMATE NOT AVAILABLE,
     +   ' ', 2E14.5, 0PF9.1, 3X, 25H********** TO ********** )
 1100 FORMAT(/11X, 5HTOTAL, I7, 1PE14.5, 28X, 2E14.5//
     +   17X, 20HFIXED EFFECTS MODEL , 2E14.5, 37X, E13.5, 3H TO, E12.5/
     +   17X, 7HRANDOM ,
     +   13HEFFECTS MODEL, 2E14.5, 37X, E13.5, 3H TO, E12.5/17X,
     +   14HUNGROUPED DATA, 6X, 2E14.5, 37X, E13.5, 3H TO, E12.5/)
 1110 FORMAT(1X, 50HPAIRWISE MULTIPLE COMPARISON OF MEANS.  THE MEANS ,
     +   59HARE PUT IN INCREASING ORDER IN GROUPS SEPARATED BY *****.  ,
     +   11HA MEAN IS  /44H ADJUDGED NON-SIGNIFICANTLY DIFFERENT FROM A,
     +   59HNY MEAN IN THE SAME GROUP AND SIGNIFICANTLY DIFFERENT AT TH,
     +   17HE .05 LEVEL FROM /38H ANY MEAN IN ANOTHER GROUP.  ***** ***,
     +   59H** INDICATES ADJACENT GROUPS HAVE NO COMMON MEAN.          ,
     +   23H                       )
 1120 FORMAT(/3X, 49HNEWMAN-KEULS TECHNIQUE, HARTLEY MODIFICATION. (AP,
     +   40HPROXIMATE IF GROUP NUMBERS ARE UNEQUAL.))
 1130 FORMAT(/3X, 18HSCHEFFE TECHNIQUE.)
 1140 FORMAT(3X, 9(1PE12.5, ','))
 1150 FORMAT(6X, 5H*****)
 1160 FORMAT(3X, 11H***** *****)
 1170 FORMAT(/36H TESTS FOR HOMOGENEITY OF VARIANCES./7X, 9HCOCHRANS ,
     +   35HC = MAX. VARIANCE/SUM(VARIANCES) = , F7.4, 6H, P = , F6.3,
     +   10H (APPROX.)/7X, 17HBARTLETT-BOX F = , F9.3, 6H, P = ,
     +   F6.3/7X, 38HMAXIMUM VARIANCE / MINIMUM VARIANCE = , F14.4)
 1180 FORMAT(7X, 50HAPPROX BETWEEN MEANS F-TEST IN PRESENCE OF HETEROG,
     +   20HENEOUS VARIANCE. F =, F8.3, 5H, P =, F6.3)
 1190 FORMAT(/35H MODEL II - COMPONENTS OF VARIANCE./7X, 10HESTIMATE O,
     +   20HF BETWEEN COMPONENT , 1PE14.6)
      END
!DCKOUT
      SUBROUTINE DCKOUT(XM, IXM, N, M, NROW, NETA, NTAU, NPAR, MSG,
     +   LMSG, PAR, SCALE, LSCALE, HDR, PAGE, WIDE, ISUBHD, PRTFXD,
     +   IFIXD)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRINTS THE RESULTS OF THE DERIVATIVE CHECKING
!     SUBROUTINE
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ISUBHD,IXM,LMSG,LSCALE,M,N,NETA,NPAR,NROW,NTAU
      LOGICAL
     +   PAGE,PRTFXD,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),SCALE(LSCALE),XM(IXM,M)
      INTEGER
     +   IFIXD(NPAR),MSG(LMSG)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL HDR
!
!  LOCAL SCALARS
      INTEGER
     +   I,IMAX,IMIN,INDEX,IPRT,J,K,NPERL
      CHARACTER
     +   BLANK*1
!
!  LOCAL ARRAYS
      LOGICAL
     +   FTNOTE(6)
      CHARACTER
     +   FIXED(3)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL FIXPRT,IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     CHARACTER*1 BLANK
!        THE CHARACTER BLANK.
!     CHARACTER*1 FIXED(3)
!        THE CHARACTERS USED TO LABEL THE PARAMETERS FIXED OR NOT.
!     LOGICAL FTNOTE(6)
!        THE ARRAY WHICH CONTROLS PRINTING OF FOOTNOTES.
!     EXTERNAL HDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXD(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXD(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER IMAX, IMIN
!        THE LARGEST AND SMALLEST INDEX VALUE TO BE PRINTED ON EACH
!        LINE.
!     INTEGER INDEX
!        THE INDEX VALUE TO BE PRINTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED BY
!        ROUTINE HDR.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER LMSG
!        THE LENGTH OF THE VECTOR MSG.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MSG(LMSG)
!        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPERL
!        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        APPROXIMATED DERIVATIVES AND THE USER-SUPPLIED DERIVATIVES.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     LOGICAL WIDE
!       THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!
      DATA BLANK /' '/
!
      CALL IPRINT(IPRT)
!
!     INITIALIZE ARRAY FIXED
!
      DO 10 K=1,3
         FIXED(K) = BLANK
   10 CONTINUE
!
      CALL HDR(PAGE, WIDE, ISUBHD)
!
!     SET UP FOR FOOTNOTES
!
      DO 20 I=1,6
         FTNOTE(I) = .FALSE.
   20 CONTINUE
!
      IF (MSG(1).LE.0) GO TO 40
!
      DO 30 I=1,NPAR
         IF ((MSG(I+1).EQ.0) .OR. (MSG(I+1).EQ.2)) GO TO 30
         K = MSG(I+1) - 2
         IF (K.EQ.-1) K = 5
         FTNOTE(1) = .TRUE.
         FTNOTE(K+1) = .TRUE.
   30 CONTINUE
!
!     PRINT REPORT
!
   40 CONTINUE
!
      WRITE (IPRT,1000)
      IF (FTNOTE(1)) WRITE (IPRT,1040)
      IF (PRTFXD) WRITE (IPRT,1160)
      IF (.NOT.PRTFXD) WRITE (IPRT,1170)
!
      IF (SCALE(1).LE.0.0D0) GO TO 60
!
      DO 50 I=1,NPAR
         IF (PRTFXD) CALL FIXPRT(IFIXD(I), FIXED)
         K = MSG(I+1) - 2
         IF (K.EQ.-1) K = 5
         IF (K.EQ.-2) WRITE (IPRT,1010) I, (FIXED(J),J=1,3), PAR(I),
     +      SCALE(I)
         IF (K.EQ.0) WRITE (IPRT,1020) I, (FIXED(J),J=1,3), PAR(I),
     +      SCALE(I)
         IF (K.GE.1) WRITE (IPRT,1030) I, (FIXED(J),J=1,3), PAR(I),
     +      SCALE(I), K
   50 CONTINUE
      GO TO 80
!
   60 CONTINUE
!
      DO 70 I=1,NPAR
         IF (PRTFXD) CALL FIXPRT(IFIXD(I), FIXED)
         K = MSG(I+1) - 2
         IF (K.EQ.-1) K = 5
         IF (K.EQ.-2) WRITE (IPRT,1180) I, (FIXED(J),J=1,3), PAR(I)
         IF (K.EQ.0) WRITE (IPRT,1190) I, (FIXED(J),J=1,3), PAR(I)
         IF (K.GE.1) WRITE (IPRT,1200) I, (FIXED(J),J=1,3), PAR(I), K
   70 CONTINUE
!
   80 CONTINUE
!
!     PRINT FOOTNOTES
!
      IF (.NOT.FTNOTE(1)) GO TO 90
!
      WRITE (IPRT,1060)
      IF (FTNOTE(2)) WRITE (IPRT,1070)
      IF (FTNOTE(3)) WRITE (IPRT,1080)
      IF (FTNOTE(4)) WRITE (IPRT,1090)
      IF (FTNOTE(5)) WRITE (IPRT,1100)
      IF (FTNOTE(6)) WRITE (IPRT,1050)
!
   90 CONTINUE
!
      WRITE (IPRT,1110) NETA
      WRITE (IPRT,1120) NTAU
!
!     PRINT OUT ROW OF INDEPENDENT VARIABLE WHICH WAS CHECKED.
!
      WRITE (IPRT,1130) NROW
      NPERL = 7
!
      DO 100 I=1,M,NPERL
         IMIN = I
         IMAX = MIN(I+NPERL-1,M)
         WRITE (IPRT,1140) (INDEX,INDEX=IMIN,IMAX)
         WRITE (IPRT,1150) (XM(NROW,INDEX),INDEX=IMIN,IMAX)
  100 CONTINUE
      WRITE (IPRT,1210) N
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (//)
 1010 FORMAT (1X, I3, 5X, 3A1, 2G17.8, 10X, 2HOK)
 1020 FORMAT (1X, I3, 5X, 3A1, 2G17.8, 7X, 9HINCORRECT)
 1030 FORMAT (1X, I3, 5X, 3A1, 2G17.8, 5X, 14HQUESTIONABLE (, I1, ')')
 1040 FORMAT (62X, 1H*)
 1050 FORMAT (/48H  (5) USER-SUPPLIED AND APPROXIMATED DERIVATIVES,
     +   14H DISAGREE, BUT/5X, 37H APPROXIMATED DERIVATIVE IS QUESTIONA,
     +   11HBLE BECAUSE, 6H RATIO/5X, 30H OF RELATIVE CURVATURE TO RELA,
     +   17HTIVE SLOPE IS TOO, 6H HIGH.)
 1060 FORMAT (/53H * NUMBERS IN PARENTHESES REFER TO THE FOLLOWING NOTE,
     +   2HS.)
 1070 FORMAT (/48H  (1) USER-SUPPLIED AND APPROXIMATED DERIVATIVES,
     +   11H AGREE, BUT/5X, 40H BOTH ARE ZERO.  RECHECK AT ANOTHER ROW.)
 1080 FORMAT (/48H  (2) USER-SUPPLIED AND APPROXIMATED DERIVATIVES,
     +   15H MAY AGREE, BUT/5X, 36H USER-SUPPLIED DERIVATIVE IS IDENTIC,
     +   9HALLY ZERO, 17H AND APPROXIMATED/5X, 21H DERIVATIVE IS ONLY A,
     +   18HPPROXIMATELY ZERO., 25H  RECHECK AT ANOTHER ROW.)
 1090 FORMAT (/48H  (3) USER-SUPPLIED AND APPROXIMATED DERIVATIVES,
     +   14H DISAGREE, BUT/5X, 37H USER-SUPPLIED DERIVATIVE IS IDENTICA,
     +   9HLLY ZERO., 12H  RECHECK AT/5X, 13H ANOTHER ROW.)
 1100 FORMAT (/48H  (4) USER-SUPPLIED AND APPROXIMATED DERIVATIVES,
     +   14H DISAGREE, BUT/5X, 37H APPROXIMATED DERIVATIVE IS QUESTIONA,
     +   11HBLE BECAUSE, 13H EITHER RATIO/5X, 22H OF RELATIVE CURVATURE,
     +   25H TO RELATIVE SLOPE IS TOO, 9H HIGH, OR/5X, 13H SCALE(K) IS ,
     +   6HWRONG.)
 1110 FORMAT (/43H NUMBER OF RELIABLE DIGITS IN MODEL RESULTS, 25X,
     +   6H(NETA), 1X, I5)
 1120 FORMAT (/40H NUMBER OF DIGITS IN DERIVATIVE CHECKING, 9H AGREEMEN,
     +   11HT TOLERANCE, 8X, 6H(NTAU), 1X, I5)
 1130 FORMAT (/45H ROW NUMBER AT WHICH DERIVATIVES WERE CHECKED, 23X,
     +   6H(NROW), 1X, I5/42H   -VALUES OF THE INDEPENDENT VARIABLES AT,
     +   9H THIS ROW)
 1140 FORMAT (10X, 5HINDEX, I5, 6I15)
 1150 FORMAT (10X, 5HVALUE, 7(1X, G14.7)/)
 1160 FORMAT (52X, 10HDERIVATIVE/7X, 24HPARAMETER STARTING VALUE, 6X,
     +   5HSCALE, 10X, 10HASSESSMENT/1X, 5HINDEX, 2X, 5HFIXED, 6X,
     +   5H(PAR), 12X, 7H(SCALE)/)
 1170 FORMAT (17X, 9HPARAMETER, 26X, 10HDERIVATIVE/15X, 12HSTARTING VAL,
     +   2HUE, 8X, 5HSCALE, 10X, 10HASSESSMENT/1X, 5HINDEX, 13X,
     +   5H(PAR), 12X, 7H(SCALE)/)
 1180 FORMAT (1X, I3, 5X, 3A1, G17.8, 7X, 7HDEFAULT, 13X, 2HOK)
 1190 FORMAT (1X, I3, 5X, 3A1, G17.8, 7X, 7HDEFAULT, 10X, 9HINCORRECT)
 1200 FORMAT (1X, I3, 5X, 3A1, G17.8, 7X, 7HDEFAULT, 8X, 11HQUESTIONABL,
     +   3HE (, I1, ')')
 1210 FORMAT (/23H NUMBER OF OBSERVATIONS, 48X, 3H(N), 1X, I5)
      END
!STPCNT
      SUBROUTINE STPCNT(XM, N, M, IXM, MDL, PAR, NPAR, STP,
     +   EXMPT, NETA, SCALE, LSCALE, NPRT, HDR, PAGE, WIDE, ISUBHD,
     +   HLFRPT, PRTFXD, IFIXED, LIFIXD)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CONTROLS THE STEP SIZE SELECTION PROCESS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   EXMPT
      INTEGER
     +   ISUBHD,IXM,LIFIXD,LSCALE,M,N,NETA,NPAR,NPRT
      LOGICAL
     +   HLFRPT,PAGE,PRTFXD,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),SCALE(LSCALE),STP(NPAR),XM(IXM,M)
      INTEGER
     +   IFIXED(LIFIXD)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL HDR,MDL
!
!  SCALARS IN COMMON
      DOUBLE PRECISION
     +   Q
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ETA,EXM,FPLRS,SCL,TAU
      INTEGER
     +   CD,FD,FDLAST,FDSAVE,IFAILJ,IFIXD,IFP,ITEMP,J,MXFAIL,NALL0,
     +   NDD,NDGT1,NEXMPT,NFAIL,NFAILJ,PARTMP,PV,PVMCD,PVNEW,PVPCD,
     +   PVSTP,PVTEMP
      LOGICAL
     +   HEAD
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      INTEGER
     +   STKGET,STKST
      EXTERNAL D1MACH,STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CPYVII,ETAMDL,SETIV,STKCLR,STPMN,STPOUT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,INT,LOG10,MAX,MIN
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
      COMMON /NOTOPT/Q
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CD
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE CENTRAL DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION ETA
!        THE RELATIVE NOISE IN THE MODEL
!     DOUBLE PRECISION EXM
!        THE PROPORTION OF OBSERVATIONS ACTUALLY USED FOR WHICH THE
!        COMPUTED NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE
!        EXEMPTED FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     DOUBLE PRECISION EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DRVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     INTEGER FD
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
!     INTEGER FDLAST
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!        FOR THE LAST STEP SIZE TRIED.
!     INTEGER FDSAVE
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!        FOR THE BEST STEP SIZE TRIED SO FAR.
!     DOUBLE PRECISION FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     EXTERNAL HDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE STEP SIZE SELECTION
!        ROUTINE HAS ALREADY PRINTED PART OF THE INITIAL SUMMARY (TRUE)
!        OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFAILJ
!        THE STARTING LOCATION IN ISTAK FOR
!        THE ARRAY OF INDICATOR VARIABLES DESIGNATING WHETHER
!        THE SETP SIZE SELECTED WAS SATISFACOTRY FOR A GIVEN
!        OBSERVATION AND THE JTH PARAMETER.
!     INTEGER IFIXD
!        THE STARTING LOCATION IN ISTAK OF
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER ITEMP
!        THE STARTING LOCATION IN ISTAK FOR
!        A TEMPORARY STORAGE VECTOR.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER LIFIXD
!        THE LENGTH OF THE VECTOR IFIXED.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER MXFAIL
!        THE MAXIMUM NUMBER OF FAILURES FOR ANY PARAMETER.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
!     INTEGER NDD
!        THE NUMBER OF DECIMAL DIGITS CARRIED FOR A DOUBLE PRECISION
!        NUMBERS.
!     INTEGER NDGT1
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL USED, EITHER
!        SET TO THE USER SUPPLIED VALUE OF NETA, OR COMPUTED
!        BY ETAMDL.
!     INTEGER NETA
!        THE USER SUPPLIED NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NEXMPT
!        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
!        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
!        SIZE STILL BE CONSIDERED OK.
!     INTEGER NFAIL
!        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP SIZE
!        FOR THE PARAMETER DOES NOT MEET THE CRITERIA.
!     INTEGER NFAILJ
!        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP SIZE
!        FOR THE JTH PARAMETER DOES NOT MEET THE CRITERIA.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     INTEGER PARTMP
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE MODIFIED MODEL PARAMETERS
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     INTEGER PV
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     INTEGER PVMCD
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     INTEGER PVNEW
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPNEW.
!     INTEGER PVPCD
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCD.
!     INTEGER PVSTP
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STP(J).
!     INTEGER PVTEMP
!        THE STARTING LOCATION IN THE WORK AREA OF
!        A TEMPORY STORAGE LOCATION FOR PREDICTED VALUES BEGINS.
!     DOUBLE PRECISION Q
!        A DUMMY VARIABLE WHICH IS USED, ALONG WITH COMMON NOTOPT (NO
!        OPTIMIZATION), TO COMPUTE THE STEP SIZE.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SCL
!        THE ACTUAL TYPICAL SIZE USED.
!     DOUBLE PRECISION STP(NPAR)
!        THE SELECTED STEP SIZES.
!     DOUBLE PRECISION TAU
!        THE AGREEMENT TOLERANCE.
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
!
      NALL0 = STKST(1)
!
      FPLRS = D1MACH(4)
      IFP = 4
!
!     SET PRINT CONTROLS
!
      HEAD = .TRUE.
!
!     SUBDIVIDE WORK AREA
!
      IFIXD = STKGET(NPAR, 2)
      ITEMP = STKGET(N, 2)
      IFAILJ = STKGET(N, 2)
      NFAIL = STKGET(NPAR, 2)
!
      CD = STKGET(MAX(N,NPAR), IFP)
      FD = STKGET(N, IFP)
      FDLAST = STKGET(N, IFP)
      FDSAVE = STKGET(N, IFP)
      PV = STKGET(N, IFP)
      PVMCD = STKGET(N, IFP)
      PVNEW = STKGET(N, IFP)
      PVPCD = STKGET(N, IFP)
      PVSTP = STKGET(N, IFP)
      PVTEMP = STKGET(N, IFP)
!
      IF (IERR .EQ. 1) RETURN
!
      PARTMP = CD
!
!     SET UP IFIXD
!
      IF (IFIXED(1).LT.0) THEN
         CALL SETIV(ISTAK(IFIXD), NPAR, 0)
      ELSE
         CALL CPYVII(NPAR, IFIXED, 1, ISTAK(IFIXD), 1)
      END IF
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      NDD = INT(-LOG10(FPLRS))
!
      IF ((NETA.GE.2) .AND. (NETA.LE.NDD)) THEN
         ETA = 10.0D0 ** (-NETA)
         NDGT1 = NETA
      ELSE
         CALL ETAMDL(MDL, PAR, NPAR, XM, N, M, IXM, ETA, NDGT1,
     +               RSTAK(PARTMP), RSTAK(PVTEMP), 0)
      END IF
!
      TAU = MIN(ETA ** (0.25D0), 0.01D0)
!
      EXM = EXMPT
      IF ((EXM.LT.0.0D0) .OR. (EXM.GT.1.0D0)) EXM = 0.10D0
      NEXMPT = EXM * N
      IF (EXM .NE. 0.0D0) NEXMPT = MAX(NEXMPT, 1)
!
!     COMPUTE PREDICTED VALUES OF THE MODEL USING THE INPUT PARAMETER
!     ESTIMATES
!
      CALL MDL(PAR, NPAR, XM, N, M, IXM, RSTAK(PV))
!
      MXFAIL = 0
      NFAILJ = NFAIL
!
      DO 120 J = 1, NPAR
         IF (ISTAK(IFIXD-1+J).EQ.0) THEN
            IF (SCALE(1).LE.0.0D0) THEN
               IF (PAR(J).EQ.0.0D0) THEN
                  SCL = 1.0D0
               ELSE
                  SCL = ABS(PAR(J))
               END IF
            ELSE
               SCL = SCALE(J)
            END IF
!
            CALL STPMN(J, XM, N, M, IXM, MDL, PAR, NPAR, NEXMPT,
     +         ETA, TAU, SCL, STP(J), ISTAK(NFAILJ), ISTAK(IFAILJ),
     +         RSTAK(CD), ISTAK(ITEMP), RSTAK(FD), RSTAK(FDLAST),
     +         RSTAK(FDSAVE), RSTAK(PV), RSTAK(PVMCD), RSTAK(PVNEW),
     +         RSTAK(PVPCD), RSTAK(PVSTP), RSTAK(PVTEMP))
!
!     COMPUTE THE MAXIMUM NUMBER OF FAILURES FOR ANY PARAMETER
!
            MXFAIL = MAX(ISTAK(NFAILJ), MXFAIL)
!
         ELSE
            STP(J) = 0.0
         END IF
!
!     PRINT RESULTS IF THEY ARE DESIRED
!
         IF ((NPRT.NE.0) .OR. (MXFAIL.GT.NEXMPT))
     +      CALL STPOUT(HEAD, N, EXM, NEXMPT, NDGT1, J, PAR, NPAR,
     +            STP, ISTAK(NFAIL), ISTAK(IFAILJ), SCALE,  LSCALE, HDR,
     +            PAGE, WIDE, ISUBHD, NPRT, PRTFXD, ISTAK(IFIXD))
         NFAILJ = NFAILJ + 1
  120 CONTINUE
!
      HLFRPT = .FALSE.
      IF ((NPRT.NE.0) .OR. (MXFAIL.GT.NEXMPT)) HLFRPT = .TRUE.
!
      IF (MXFAIL.GT.NEXMPT) IERR = 2
!
      CALL STKCLR(NALL0)
!
      RETURN
!
      END
!GFARF
      SUBROUTINE GFARF (PHI, IAR)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE TO COMPUTE THE GAIN
!     FUNCTION OF AN AUTOREGRESSIVE FILTER (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PHI(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,FMAX,FMIN,YPLTMN,YPLTMX
      INTEGER
     +   IGFERR,IPRT,NF,NORD,NPRT
      LOGICAL
     +   ERR01,HEAD,SYM
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FREQ(101),GAIN(101),PHAS(101),XORD(101),YORD(101)
      INTEGER
     +   ISORT(101)
      CHARACTER
     +   LIAR(8)*1,NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,GFAEST,GFORD,GFOUT,IPRINT,SETFRQ
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     LOGICAL ERR01
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION FMAX, FMIN
!        THE MINIMUM AND MAXIMUM FREQUENCY FOR WHICH THE GAIN
!        FUNCTION IS TO BE ESTIMATED.
!     DOUBLE PRECISION FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        HAS BEEN ESTIMATED.
!     DOUBLE PRECISION GAIN(101)
!        THE VECTOR IN WHICH THE GAIN FUNCTION ESTIMATES ARE
!        STORED.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IGFERR
!        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
!        TO HAVE PRODUCED REASONABLE RESULTS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     CHARACTER*1 LIAR(8)
!        THE ARRAY CONTAINING THE NAME OF THE VARIABLE IAR.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        IS TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NORD
!        THE NUMBER OF VALUES TO BE PLOTTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     DOUBLE PRECISION PHAS(101)
!        THE ARRAY IN WHICH THE PHASE OF THE FILTER IS RETURNED.
!     DOUBLE PRECISION PHI(IAR)
!        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
!     LOGICAL SYM
!        THE VARIABLE USED TO INDICATE WHETHER THE GAIN FUNCTION
!        COMPUTED WAS FOR A SYMMETRIC OR AUTOREGRESSIVE FILTER.
!     DOUBLE PRECISION XORD(101)
!        THE X COORDINATES FOR THE GAIN FUNCTION PLOT
!     DOUBLE PRECISION YORD(101)
!        THE Y COORDINATES FOR THE GAIN FUNCTION PLOT
!     DOUBLE PRECISION YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'G',       'F',       'A',       'R',       'F',       ' '/
      DATA
     +  LIAR(1), LIAR(2), LIAR(3), LIAR(4), LIAR(5), LIAR(6), LIAR(7),
     +  LIAR(8)
     + /  'I',   'A',   'R',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LIAR, IAR, 1, 1, HEAD, ERR01, LIAR)
!
      IF (.NOT. ERR01) GO TO 10
!
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   10 CONTINUE
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      SYM = .FALSE.
!
      NF = 101
!
      FMIN = 0.0D0
      FMAX = 0.5D0
!
      DELTA = 1.0D0
!
      NPRT = -1
!
!     SET FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO BE ESTIMATED
!
      CALL SETFRQ (FREQ, NF, NPRT, FMIN, FMAX, DELTA)
!
!     COMPUTE THE GAIN FUNCTION
!
      CALL GFAEST (PHI, IAR, NF, FREQ, GAIN, PHAS, DELTA)
!
!     SET THE COORDINATES FOR THE PLOT.
!
      CALL GFORD (FREQ, GAIN, ISORT, NF, XORD, YORD, NORD,
     +   YPLTMN, YPLTMX, NPRT, IGFERR)
!
!     PLOT THE RESULTS.
!
      CALL GFOUT (XORD, YORD, NORD, FREQ, PHAS, NF, IAR, SYM, FMIN,
     +   FMAX, YPLTMN, YPLTMX, NPRT, IGFERR, NMSUB)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   28H       CALL GFARF (PHI, IAR))
      END
!UASER
      SUBROUTINE UASER(NMSUB, N, ACOV, IAR, PHI, LAGMAX, LAG, LACOV,
     +   NF, LDSTAK, LDSMIN, LYFFT, NFFT, OPTION)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE ERROR CHECKING ROUTINE FOR THE TIME SERIES
!     FOURIER UNIVARIATE SPECTRUM ANALYSIS ROUTINES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985  (JRD)
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IAR,LACOV,LAG,LAGMAX,LDSMIN,LDSTAK,LYFFT,N,NF,NFFT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),PHI(*)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   I,NV
      LOGICAL
     +   HEAD
!
!  LOCAL ARRAYS
      LOGICAL
     +   ERR(20)
      CHARACTER
     +   L1(8)*1,LACV(8)*1,LACV1M(8)*1,LACV1P(8)*1,LIAR(8)*1,
     +   LLACOV(8)*1,LLAG(8)*1,LLDS(8)*1,LLGMX(8)*1,LLGMX1(8)*1,
     +   LLGMXM(8)*1,LLGMXP(8)*1,LLYFFT(8)*1,LN(8)*1,LNF(8)*1,
     +   LNM1(8)*1,LPHI(8)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,ERVII
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,IABS
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV)
!        THE AUTOCOVARIANCE FUNCTION.
!     LOGICAL ERR(20)
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF ERR01, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     CHARACTER*1 LACV(8), LACV1M(8), LACV1P(8),
!    *   LIAR(8), LLACOV(8), LLAG(8), LLGMX(8), LLGMXM(8),
!    *   LLGMXP(8),  LLGMX1(8), LLDS(8), LN(8), LNF(8), LNM1(8),
!    *   LLYFFT(8), LPHI(8), L1(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE ARGUMENT(S)
!        CHECKED FOR ERRORS.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THE USER CALLED SUBROUTINE.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND WHEN CHECKING VECTOR LAGS.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     DOUBLE PRECISION PHI(IAR)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!
!
!     SET UP NAME ARRAYS
!
      DATA LACV(1), LACV(2), LACV(3), LACV(4), LACV(5), LACV(6),
     +   LACV(7), LACV(8) /'A','C','O','V',' ',' ',' ',' '/
      DATA LACV1M(1), LACV1M(2), LACV1M(3), LACV1M(4), LACV1M(5),
     +   LACV1M(6), LACV1M(7), LACV1M(8) /'-','A','C','O','V','(','1',
     +   ')'/
      DATA LACV1P(1), LACV1P(2), LACV1P(3), LACV1P(4), LACV1P(5),
     +   LACV1P(6), LACV1P(7), LACV1P(8) /'+','A','C','O','V','(','1',
     +   ')'/
      DATA LIAR(1), LIAR(2), LIAR(3), LIAR(4), LIAR(5),
     +   LIAR(6), LIAR(7), LIAR(8) /'I','A','R',' ',' ',' ',' ',
     +   ' '/
      DATA LLACOV(1), LLACOV(2), LLACOV(3), LLACOV(4), LLACOV(5),
     +   LLACOV(6), LLACOV(7), LLACOV(8) /'L','A','C','O','V',' ',' ',
     +   ' '/
      DATA LLAG(1), LLAG(2), LLAG(3), LLAG(4), LLAG(5), LLAG(6),
     +   LLAG(7), LLAG(8) /'L','A','G',' ',' ',' ',' ',' '/
      DATA LLGMX(1), LLGMX(2), LLGMX(3), LLGMX(4), LLGMX(5),
     +   LLGMX(6), LLGMX(7), LLGMX(8) /'L','A','G','M','A','X',' ',
     +   ' '/
      DATA LLGMXM(1), LLGMXM(2), LLGMXM(3), LLGMXM(4), LLGMXM(5),
     +   LLGMXM(6), LLGMXM(7), LLGMXM(8) /'-','L','A','G','M','A','X',
     +   ' '/
      DATA LLGMXP(1), LLGMXP(2), LLGMXP(3), LLGMXP(4), LLGMXP(5),
     +   LLGMXP(6), LLGMXP(7), LLGMXP(8) /'+','L','A','G','M','A','X',
     +   ' '/
      DATA LLGMX1(1), LLGMX1(2), LLGMX1(3), LLGMX1(4), LLGMX1(5),
     +   LLGMX1(6), LLGMX1(7), LLGMX1(8) /'L','A','G','M','A','X','+',
     +   '1'/
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +   LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8) /'N',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LNF(1), LNF(2), LNF(3), LNF(4), LNF(5), LNF(6), LNF(7),
     +   LNF(8) /'N','F',' ',' ',' ',' ',' ',' '/
      DATA LNM1(1), LNM1(2), LNM1(3), LNM1(4), LNM1(5), LNM1(6),
     +   LNM1(7), LNM1(8) /'N','-','1',' ',' ',' ',' ',' '/
      DATA LLYFFT(1), LLYFFT(2), LLYFFT(3), LLYFFT(4), LLYFFT(5),
     +   LLYFFT(6), LLYFFT(7), LLYFFT(8) /'L','Y','F','F','T',' ',' ',
     +   ' '/
      DATA LPHI(1), LPHI(2), LPHI(3), LPHI(4), LPHI(5), LPHI(6),
     +   LPHI(7), LPHI(8) /'P','H','I',' ',' ',' ',' ',' '/
      DATA L1(1), L1(2), L1(3), L1(4), L1(5), L1(6), L1(7), L1(8) /'1',
     +   ' ',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
!
      IERR = 0
      HEAD = .TRUE.
!
      DO 10 I=1,20
         ERR(I) = .FALSE.
   10 CONTINUE
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR(1), LN)
!
      IF ((.NOT.OPTION(3))) GO TO 15
!
      CALL ERVII(NMSUB, LACV, ACOV, LAGMAX+1, -ABS(ACOV(1)),
     +   ABS(ACOV(1)), 0, HEAD, 4, NV, ERR(15), LACV1M, LACV1P)
!
      CALL EISII(NMSUB, LLGMX, LAGMAX, 1, N-1, 1, HEAD, ERR(2),
     +   L1, LNM1)
!
      IF (OPTION(2)) THEN
         CALL EISGE(NMSUB, LLACOV, LACOV, LAGMAX+1, 8, HEAD, ERR(3),
     +   LLGMX1)
      ELSE
         CALL EISGE(NMSUB, LLACOV, LACOV, LAGMAX+1, 7, HEAD, ERR(3),
     +   LLGMX1)
      END IF
!
   15 IF (OPTION(1) .AND. (.NOT.ERR(1)))
     +   CALL EISGE(NMSUB, LLYFFT, LYFFT, NFFT, 9, HEAD, ERR(4),
     +   LLYFFT)
!
      IF (OPTION(1) .AND. (.NOT.OPTION(4)))
     +   CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR(5), LLDS)
!
      IF (OPTION(4)) GO TO 30
!
      DO 20 I=1,15
         IF (ERR(I)) GO TO 50
   20 CONTINUE
!
      RETURN
!
   30 CONTINUE
!
      CALL EISII(NMSUB, LIAR, IAR, -IABS(LAGMAX), IABS(LAGMAX), 1, HEAD,
     +   ERR(6), LLGMXM, LLGMXP)
!
      CALL ERVII(NMSUB, LPHI, PHI, IAR, -1.0D0, 1.0D0, 0, HEAD, 1, NV,
     +   ERR(7), L1, L1)
!
      IF (.NOT.OPTION(3))
     +   CALL EISII(NMSUB, LLGMX, LAGMAX, 1, N-1, 1, HEAD, ERR(2),
     +   L1, LNM1)
!
      CALL EISII(NMSUB, LLAG, LAG, -IABS(LAGMAX), IABS(LAGMAX), 1, HEAD,
     +   ERR(8), LLGMXM, LLGMXP)
!
      CALL EISGE(NMSUB, LNF, NF, 1, 1, HEAD, ERR(9), LNF)
!
      IF (ERR(1) .OR. ERR(2) .OR. ERR(9)) GO TO 50
!
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR(14), LLDS)
!
      DO 40 I=1,15
         IF (ERR(I)) GO TO 50
   40 CONTINUE
!
      RETURN
!
   50 CONTINUE
      IERR = 1
      RETURN
!
      END
!DRV3
      SUBROUTINE DRV3(PAR, NPAR, XM, N, M, IXM, D)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DERIVATIVE FUNCTION FOR NLS FAMILY EXERCISER SUBROUTINE MDL3
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PAR(NPAR),XM(IXM,M)
!
!  LOCAL SCALARS
      INTEGER
     +   I,J
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION PAR(NPAR)
!        MODEL PARAMETERS
!     DOUBLE PRECISION D(N,NPAR)
!        THE FIRST DERIVATIVE WITH RESPECT TO THE ITH PARAMETER
!     INTEGER I
!        ROW MARKER
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLESC
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS
!     DOUBLE PRECISION XM(IXM,M)
!        INDEPENDENT VARIABLE
!
      DO 20 I=1,N
         DO 10 J=1,NPAR
            D(I,J) = XM(I,J)
   10    CONTINUE
   20 CONTINUE
!
      RETURN
!
      END
!BFSV
      SUBROUTINE BFSV(CCOV, INDEX1, INDEX2, N, LAGMAX, ICCOV, JCCOV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
!     FOURIER SPECTRUM ANALYSIS OF SERIES WITH
!     COVARIANCES INPUT RATHER THAN ORIGINAL SERIES
!     (SHORT CALL)
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,INDEX1,INDEX2,JCCOV,LAGMAX,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS1,YMISS2
      INTEGER
     +   ICSPC2,INLPPC,IPHAS,IPRT,JNLPPC,LAGMX1,LAGMXU,LDSMIN,
     +   LDSTAK,LPCV,LW,LY,M,NF,NPRT,NW
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CEVEN(101),CODD(101),CSPC2(101,4),FREQ(101),PHAS(101,4),
     +   SPCF1(101),SPCF2(101),W(101),XAXIS(404),Y1(1),Y2(1),
     +   YAXIS(404)
      INTEGER
     +   ISYM(404),LAGS(4),NLPPC(1,1,1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,IPRINT,PARZEN,SETLAG
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION CCOV(ICCOV,JCCOV,*)
!        THE COVARIANCES.
!     DOUBLE PRECISION CEVEN(101)
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CODD(101)
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CSPC2(101,4)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISYM(404)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC.
!     INTEGER LAGMAX, LAGMXU
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC(1,1,1)
!        A DUMMY ARRAY.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION PHAS(101,4)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION SPCF1(101), SPCF2(101)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     DOUBLE PRECISION W(101)
!        THE WINDOWS.
!     DOUBLE PRECISION XAXIS(404)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YAXIS(404)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YMISS1, YMISS2
!        THE MISSING VALUE CODES
!     DOUBLE PRECISION Y1(1)
!        THE FIRST TIME SERIES.
!     DOUBLE PRECISION Y2(1)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','V',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .TRUE.
      OPTION(4) = .FALSE.
!
      M = 2
!
      INLPPC = 1
      JNLPPC = 1
      ICSPC2 = 101
      IPHAS = 101
!
      LDSTAK = 0
      LDSMIN = 0
!
      NF = 101
      LW = 101
      LY = N
      LPCV = 404
!
!     SET MAXIMUM LAG VALUE USED (LAGMXU)
!     SET NUMBER OF LAG WINDOW TRUCCATION POINTS (NW)
!
      CALL SETLAG(N, LAGMXU)
      LAGMXU = MIN(LAGMXU,LAGMAX)
      NW = 4
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
      CALL BFSDRV(Y1, Y2, YMISS1, YMISS2, CCOV, NLPPC, SPCF1, SPCF2,
     +   NF, FMIN, FMAX, FREQ, N, NW, LAGMXU, LAGS, LAGMX1, W, LW,
     +   DELTA, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS, CODD,
     +   CEVEN, W, LW, NMSUB, LDSMIN, LDSTAK, OPTION, N, INLPPC,
     +   JNLPPC, LY)
!
      IF (IERR.EQ.0) RETURN
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL BFSV(CCOV, INDEX1, INDEX2, N, LAGMAX, ICCOV,',
     +  ' JCCOV)')
      END
!MVPM
      SUBROUTINE MVPM(YM, YMMISS, N, M, IYM, NS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA AND MULTIPLE Y-AXIS VALUES
!     (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IYM,M,N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IPRT,IRLIN,ISCHCK,ISIZE,LISYM
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(M)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'V',       'P',       'M',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      MULTI = .TRUE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 2
      ISIZE = -1
      MISS = .TRUE.
      LISYM = 1
      IRLIN = -1
      IBAR = 0
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL MVPM (YM, YMMISS, N, M, IYM, NS)')
      END
!NLSUPK
      SUBROUTINE NLSUPK(PARE, NPARE, PAR, MASK, NPAR)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE UNPACKS A VECTOR PARE INTO A VECTOR PAR, BY
!     PLACING SUCCEDING ELEMENTS OF PARE INTO ELEMENTS OF PAR
!     WHICH CORRESPOND TO ELEMENTS OF MASK WITH THE VALUE 1.
!     OTHER ELEMENTS OF MASK SHOULD BE 0.  THE NUMBER OF ELEMENTS
!     NPARE IN PARE SHOULD EQUAL THE NUMBER OF ELEMENTS OF
!     MASK WHICH ARE 1.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   NPAR,NPARE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PARE(NPAR)
      INTEGER
     +   MASK(NPAR)
!
!  LOCAL SCALARS
      INTEGER
     +   I,JPK
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER JPK
!        AN INDEX VARIABLE.
!     INTEGER MASK(NPAR)
!        INPUT PARAMETER.  THE MASK GOVERNING THE PACKING OF PAR.
!        ELEMENTS OF MASK ARE 1 IF THE CORRESPONDING ELEMENT OF PAR
!        WAS ELIMINATED IN PARE, 0 IF IT WAS INCLUDED.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     DOUBLE PRECISION PARE(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS BEING OPTIMIZED,
!        NOT INCLUDING THOSE WHOSE VALUES ARE FIXED.
!
!     COMMENCE BODY OF ROUTINE
!
      JPK = 0
      DO 20 I=1,NPAR
         IF (MASK(I).NE.0) GO TO 20
         JPK = JPK + 1
         PAR(I) = PARE(JPK)
   20 CONTINUE
      RETURN
      END
!FLTAR
      SUBROUTINE FLTAR (Y, N, IAR, PHI, YF, NYF)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE FILTERS THE INPUT SERIES Y USING THE IAR TERMS
!     OF THE AUTOREGRESSIVE FILTER PHI, COPYING THE FILTERED SERIES
!     INTO YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IAR,N,NYF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PHI(*),Y(*),YF(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   TEMP
      INTEGER
     +   I,I1,J,K
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IAR
!        THE NUMBER OF FILTER TERMS.
!     INTEGER I1, J, K
!        INDEXING VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     DOUBLE PRECISION PHI(IAR)
!        THE ARRAY IN WHICH THE FILTER COEFFICIENTS ARE STORED.
!     DOUBLE PRECISION TEMP
!        A TEMPORARY STORAGE LOCATION.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
      DO 10 I = 1, N
         YF(I) = Y(I)
   10 CONTINUE
!
      NYF = N - IAR
!
      DO 30 I = 1, NYF
         K = I + IAR
         TEMP = YF(K)
         DO 20 J = 1, IAR
            K = K - 1
            TEMP = TEMP - PHI(J) * YF(K)
   20    CONTINUE
         YF(I) = TEMP
   30 CONTINUE
!
      I1 = NYF + 1
!
      DO 40 I = I1, N
         YF(I) = 0.0D0
   40 CONTINUE
      RETURN
      END
!NLSC
      SUBROUTINE NLSC(Y, XM, N, M, IXM, MDL, PAR, NPAR, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
!     (CONTROL CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,STOPP,STOPSS
      INTEGER
     +   IVAPRX,IXM,LDSTAK,M,MIT,N,NPAR,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),SCALE(*),STP(*),XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,LWT,NNZW,
     +   NPARE
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SDPV(1),SDRES(1),VCV(1,1),WT(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTN
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(NPAR)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(NPAR)
!        THE STEP SIZE ARRAY.
!     DOUBLE PRECISION VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(1)
!        THE DUMMY ARRAY FOR THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','C',' ',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      WEIGHT = .FALSE.
      SAVE = .FALSE.
!
      WT(1) = 1.0D0
      LIFIXD = NPAR
      LPV = 1
      LSCALE = NPAR
      LSTP = NPAR
      LSDPV = 1
      LSDRES = 1
      LWT = 1
      IVCV = 1
!
      CALL NLCNTN(Y, WT, LWT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSC (Y, XM, N, M, IXM, NLSMDL,'/
     +   '      +           PAR, NPAR, RES, LDSTAK,'/
     +   '      +           IFIXED, STP, MIT, STOPSS, STOPP,'/
     +   '      +           SCALE, DELTA, IVAPRX, NPRT)')
      END
!CHIRHO
      SUBROUTINE CHIRHO (RHO, N, NC, CHI, CHIP)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE CHI SQUARED STATISTIC AND ITS
!     PROBABILITY BASED IN A VECTOR OF AUTOCORRELATIONS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CHI,CHIP
      INTEGER
     +   N,NC
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RHO(*)
!
!  LOCAL SCALARS
      INTEGER
     +   LAG
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFCHI
      EXTERNAL CDFCHI
!
!  INTRINSIC FUNCTIONS
      INTRINSIC DBLE
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CHI, CHIP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARE STATISTIC PROBABILITY ARE STORED.
!     INTEGER LAG
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCORRELATION BEING EXAMINED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NC
!        THE NUMBER OF AUTOCORRELATIONS COMPUTED.
!     DOUBLE PRECISION RHO(NC)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
!
      CHI = 0.0D0
      DO 10 LAG = 1, NC
         CHI = CHI + RHO(LAG) * RHO(LAG)
   10 CONTINUE
      CHI = CHI * N
      CHIP = 1.0D0 - CDFCHI(CHI, DBLE(NC))
      RETURN
      END
!XAIMT
      SUBROUTINE XAIMT(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE TIME SERIES MODEL ESTIMATION ROUTINES.
!
!     SERIES Y IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND JENKINS
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   I,IFCST,IPRT,IVAPRX,IVCV,MIT,NFAC,NPAR,NPARE,NPRT,NY
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FCST(50,5),FCSTSD(50),PAR(50),PV(200),RES(200),SCALE(50),
     +   SDPV(200),SDRES(200),STP(50),VCV(10,10),Y(200),YLOG(200),
     +   YT(200)
      INTEGER
     +   IFIXED(50),MSPEC(4,50)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AIME,AIMEC,AIMES,AIMF,AIMFS,IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FCST(50,5)
!        THE FORECASTS.
!     DOUBLE PRECISION FCSTSD(50)
!        THE STANDARD DEVIATIONS OF THE FORECASTS.
!     INTEGER I
!        *
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFCST
!        THE FIRST DIMENSION OF THE ARRAY FCST.
!     INTEGER IFIXED(50)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER MSPEC(4,50)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH
!        FACTOR.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NY
!        THE NUMBER OF OBSERVATIONS.
!     DOUBLE PRECISION PAR(50)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION PV(200)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(200)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     DOUBLE PRECISION SCALE(50)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     DOUBLE PRECISION SDPV(200)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(200)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(50)
!        THE RCSTEP SIZE ARRAY.
!     DOUBLE PRECISION VCV(10,10)
!        THE COVARIANCE MATRIX.
!     DOUBLE PRECISION Y(200),YLOG(200),YT(200)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!
      DATA    Y(  1),   Y(  2),   Y(  3),   Y(  4),   Y(  5),   Y(  6)
     +    / 112.0D0, 118.0D0, 132.0D0, 129.0D0, 121.0D0, 135.0D0/
      DATA    Y(  7),   Y(  8),   Y(  9),   Y( 10),   Y( 11),   Y( 12)
     +    / 148.0D0, 148.0D0, 136.0D0, 119.0D0, 104.0D0, 118.0D0/
      DATA    Y( 13),   Y( 14),   Y( 15),   Y( 16),   Y( 17),   Y( 18)
     +    / 115.0D0, 126.0D0, 141.0D0, 135.0D0, 125.0D0, 149.0D0/
      DATA    Y( 19),   Y( 20),   Y( 21),   Y( 22),   Y( 23),   Y( 24)
     +    / 170.0D0, 170.0D0, 158.0D0, 133.0D0, 114.0D0, 140.0D0/
      DATA    Y( 25),   Y( 26),   Y( 27),   Y( 28),   Y( 29),   Y( 30)
     +    / 145.0D0, 150.0D0, 178.0D0, 163.0D0, 172.0D0, 178.0D0/
      DATA    Y( 31),   Y( 32),   Y( 33),   Y( 34),   Y( 35),   Y( 36)
     +    / 199.0D0, 199.0D0, 184.0D0, 162.0D0, 146.0D0, 166.0D0/
      DATA    Y( 37),   Y( 38),   Y( 39),   Y( 40),   Y( 41),   Y( 42)
     +    / 171.0D0, 180.0D0, 193.0D0, 181.0D0, 183.0D0, 218.0D0/
      DATA    Y( 43),   Y( 44),   Y( 45),   Y( 46),   Y( 47),   Y( 48)
     +    / 230.0D0, 242.0D0, 209.0D0, 191.0D0, 172.0D0, 194.0D0/
      DATA    Y( 49),   Y( 50),   Y( 51),   Y( 52),   Y( 53),   Y( 54)
     +    / 196.0D0, 196.0D0, 236.0D0, 235.0D0, 229.0D0, 243.0D0/
      DATA    Y( 55),   Y( 56),   Y( 57),   Y( 58),   Y( 59),   Y( 60)
     +    / 264.0D0, 272.0D0, 237.0D0, 211.0D0, 180.0D0, 201.0D0/
      DATA    Y( 61),   Y( 62),   Y( 63),   Y( 64),   Y( 65),   Y( 66)
     +    / 204.0D0, 188.0D0, 235.0D0, 227.0D0, 234.0D0, 264.0D0/
      DATA    Y( 67),   Y( 68),   Y( 69),   Y( 70),   Y( 71),   Y( 72)
     +    / 302.0D0, 293.0D0, 259.0D0, 229.0D0, 203.0D0, 229.0D0/
      DATA    Y( 73),   Y( 74),   Y( 75),   Y( 76),   Y( 77),   Y( 78)
     +    / 242.0D0, 233.0D0, 267.0D0, 269.0D0, 270.0D0, 315.0D0/
      DATA    Y( 79),   Y( 80),   Y( 81),   Y( 82),   Y( 83),   Y( 84)
     +    / 364.0D0, 347.0D0, 312.0D0, 274.0D0, 237.0D0, 278.0D0/
      DATA    Y( 85),   Y( 86),   Y( 87),   Y( 88),   Y( 89),   Y( 90)
     +    / 284.0D0, 277.0D0, 317.0D0, 313.0D0, 318.0D0, 374.0D0/
      DATA    Y( 91),   Y( 92),   Y( 93),   Y( 94),   Y( 95),   Y( 96)
     +    / 413.0D0, 405.0D0, 355.0D0, 306.0D0, 271.0D0, 306.0D0/
      DATA    Y( 97),   Y( 98),   Y( 99),   Y(100),   Y(101),   Y(102)
     +    / 315.0D0, 301.0D0, 356.0D0, 348.0D0, 355.0D0, 422.0D0/
      DATA    Y(103),   Y(104),   Y(105),   Y(106),   Y(107),   Y(108)
     +    / 465.0D0, 467.0D0, 404.0D0, 347.0D0, 305.0D0, 336.0D0/
      DATA    Y(109),   Y(110),   Y(111),   Y(112),   Y(113),   Y(114)
     +    / 340.0D0, 318.0D0, 362.0D0, 348.0D0, 363.0D0, 435.0D0/
      DATA    Y(115),   Y(116),   Y(117),   Y(118),   Y(119),   Y(120)
     +    / 491.0D0, 505.0D0, 404.0D0, 359.0D0, 310.0D0, 337.0D0/
      DATA    Y(121),   Y(122),   Y(123),   Y(124),   Y(125),   Y(126)
     +    / 360.0D0, 342.0D0, 406.0D0, 396.0D0, 420.0D0, 472.0D0/
      DATA    Y(127),   Y(128),   Y(129),   Y(130),   Y(131),   Y(132)
     +    / 548.0D0, 559.0D0, 463.0D0, 407.0D0, 362.0D0, 405.0D0/
      DATA    Y(133),   Y(134),   Y(135),   Y(136),   Y(137),   Y(138)
     +    / 417.0D0, 391.0D0, 419.0D0, 461.0D0, 472.0D0, 535.0D0/
      DATA    Y(139),   Y(140),   Y(141),   Y(142),   Y(143),   Y(144)
     +    / 622.0D0, 606.0D0, 508.0D0, 461.0D0, 390.0D0, 432.0D0/
!
      CALL IPRINT(IPRT)
!
!     COMMENCE BODY OF ROUTINE
!
!     TEST AGAINST PUBLISHED RESULTS
!
      NY = 144
      DO 10 I = 1, NY
         YLOG(I) = LOG(Y(I))
   10 CONTINUE
!
      NFAC = 2
      MSPEC(1,1) = 0
      MSPEC(2,1) = 1
      MSPEC(3,1) = 1
      MSPEC(4,1) = 1
!
      MSPEC(1,2) = 0
      MSPEC(2,2) = 1
      MSPEC(3,2) = 1
      MSPEC(4,2) = 12
!
      NPAR = 3
      PAR(1) = 0.0D0
      PAR(2) = 0.40D0
      PAR(3) = 0.60D0
!
      IFIXED(1) = 1
      IFIXED(2) = 0
      IFIXED(3) = 0
!
      STOPSS = -1.0D0
      STOPP = -1.0D0
      SCALE(1) = -1.0D0
      SCALE(2) = 1.0D-7
      SCALE(3) = 1.0D-7
      STP(1) = -1.0D0
      STP(2) = 1.0D-7
      STP(3) = 1.0D-7
      MIT = 0
      NPRT = -1
      DELTA = -1.0D0
      IVAPRX = -1
!
      WRITE(IPRT, 1000)
      CALL AIMEC (YLOG, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES,LDSTAK, IFIXED,STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
!
      WRITE (IPRT, 1005)
      PAR(1) = 0.0D0
      PAR(2) = 0.395D0
      PAR(3) = 0.615D0
      CALL AIMFS (YLOG, NY, MSPEC, NFAC,
     +   PAR, NPAR, LDSTAK, NY/10+1, 1, NY, NPRT, FCST, 50, FCSTSD)
!
      SCALE(1) = 1.0D-7
      SCALE(2) = 1.0D-7
      SCALE(3) = 1.0D-7
!
      NFAC = 2
      MSPEC(1,1) = 0
      MSPEC(2,1) = 1
      MSPEC(3,1) = 1
      MSPEC(4,1) = 1
!
      MSPEC(1,2) = 0
      MSPEC(2,2) = 0
      MSPEC(3,2) = 1
      MSPEC(4,2) = 12
!
      WRITE (IPRT, 1000)
      CALL AIMEC (YLOG, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES,LDSTAK, IFIXED,STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
      NY = 20
      WRITE (IPRT, 1000)
      CALL AIMEC (YLOG, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES,LDSTAK, IFIXED,STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
!
      NFAC = 2
      MSPEC(1,1) = 0
      MSPEC(2,1) = 0
      MSPEC(3,1) = 1
      MSPEC(4,1) = 1
!
      MSPEC(1,2) = 0
      MSPEC(2,2) = 0
      MSPEC(3,2) = 1
      MSPEC(4,2) = 12
!
      NY = 144
      WRITE (IPRT, 1000)
      CALL AIMEC (YLOG, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES,LDSTAK, IFIXED,STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
!
!     EXAMPLE FROM PAGE 212 OF BOX AND JENKINS (1970)
!     N.B. ADD PRINT STATEMENTS TO MDLTS2 TO CHECK COMPUTATIONS
!          AT FIRST CALL AGAINST THOSE LISTED ON PAGE 214.
!
      WRITE(IPRT, 1000)
      NY = 10
      YT(1) = 460.0D0
      YT(2) = 457.0D0
      YT(3) = 452.0D0
      YT(4) = 459.0D0
      YT(5) = 462.0D0
      YT(6) = 459.0D0
      YT(7) = 463.0D0
      YT(8) = 479.0D0
      YT(9) = 493.0D0
      YT(10) = 490.0D0
!
      NFAC = 1
      MSPEC(1,1) = 0
      MSPEC(2,1) = 1
      MSPEC(3,1) = 1
      MSPEC(4,1) = 1
!
      NPAR = 2
      PAR(1) = 0.0D0
      PAR(2) = 0.5D0
!
      IFIXED(1) = 1
      IFIXED(2) = 0
!
      CALL AIMEC (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES,LDSTAK, IFIXED,STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
!
!     EXAMPLE FROM PAGE 216 OF BOX AND JENKINS (1970)
!     N.B. ADD PRINT STATEMENTS TO MDLTS2 TO CHECK COMPUTATIONS
!          AT FIRST CALL AGAINST THOSE LISTED ON PAGE 218.
!
      WRITE(IPRT, 1000)
      NY = 12
      YT(1) = 2.0D0
      YT(2) = 0.8D0
      YT(3) = -0.3D0
      YT(4) = -0.3D0
      YT(5) = -1.9D0
      YT(6) = 0.3D0
      YT(7) = 3.2D0
      YT(8) = 1.6D0
      YT(9) = -0.7D0
      YT(10) = 3.0D0
      YT(11) = 4.3D0
      YT(12) = 1.1D0
!
      NFAC = 1
      MSPEC(1,1) = 1
      MSPEC(2,1) = 0
      MSPEC(3,1) = 1
      MSPEC(4,1) = 1
!
      NPAR = 3
      PAR(1) = 0.3D0
      PAR(2) = 0.0D0
      PAR(3) = 0.7D0
!
      IFIXED(1) = 0
      IFIXED(2) = 1
      IFIXED(3) = 0
!
      CALL AIMEC (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
!
!     TEST ERROR MESSAGES
!
      WRITE (IPRT, 1010)
      NY = 0
      NFAC = 0
      CALL AIME (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK)
      CALL AIMEC (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
      CALL AIMES (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT, NPARE, RSD, PV, SDPV, SDRES, VCV,
     +   IVCV)
      CALL AIMF (Y, NY, MSPEC, NFAC, PAR, NPAR, LDSTAK)
      CALL AIMFS (Y, NY, MSPEC, NFAC,
     +   PAR, NPAR, LDSTAK, NY/10+1, 1, NY, NPRT, FCST, 50, FCSTSD)
!
      NY = 144
      NFAC = 2
      MSPEC(1,1) = -1
      CALL AIME (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK)
      CALL AIMEC (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
      CALL AIMES (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT, NPARE, RSD, PV, SDPV, SDRES, VCV,
     +   IVCV)
      CALL AIMF (Y, NY, MSPEC, NFAC, PAR, NPAR, LDSTAK)
      CALL AIMFS (Y, NY, MSPEC, NFAC,
     +   PAR, NPAR, LDSTAK, NY/10+1, 1, NY, NPRT, FCST, 50, FCSTSD)
      NY = 144
      NFAC = 2
      MSPEC(1,1) = 0
      NPAR = 1
      CALL AIME (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK)
      CALL AIMEC (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
      CALL AIMES (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT, NPARE, RSD, PV, SDPV, SDRES, VCV,
     +   IVCV)
      CALL AIMF (Y, NY, MSPEC, NFAC, PAR, NPAR, LDSTAK)
      CALL AIMFS (Y, NY, MSPEC, NFAC,
     +   PAR, NPAR, LDSTAK, NY/10+1, 1, NY, NPRT, FCST, 50, FCSTSD)
      NY = 144
      NFAC = 2
      MSPEC(1,1) = 0
      NPAR = 3
      DO 20 I = 1, NPAR
        IFIXED(I) = 1
   20 CONTINUE
      IVCV = 0
      IFCST = 0
      CALL AIMEC (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
      CALL AIMES (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT, NPARE, RSD, PV, SDPV, SDRES, VCV,
     +   IVCV)
      CALL AIMFS (Y, NY, MSPEC, NFAC,
     +   PAR, NPAR, LDSTAK, NY/10+1, 1, NY, NPRT, FCST, IFCST, FCSTSD)
      DO 30 I = 1, NPAR
        IFIXED(I) = 1
   30 CONTINUE
      IVCV = 0
      STP(2) = -1.0D0
      SCALE(2) = -1.0D0
      CALL AIMEC (YT, NY, MSPEC, NFAC,
     +   PAR, NPAR, RES, LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP,
     +   SCALE, DELTA, IVAPRX, NPRT)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT ('1TEST OF ARIMA ESTIMATION ROUTINES')
 1005 FORMAT ('1TEST OF ARIMA FORECASTING ROUTINES')
 1010 FORMAT ('1TEST OF ERROR CHECKING FACILITIES')
      END
!UFSMV
      SUBROUTINE UFSMV(ACOV, NLPPA, LAGMAX, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS WITH MISSING DATA AND USER SUPPLIED
!     ACVF VALUES (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LAGMAX,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*)
      INTEGER
     +   NLPPA(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS
      INTEGER
     +   IPRT,ISPCF,LACOV,LDSMIN,LDSTAK,LNLPPA,LPCV,LWORK,LY,NF,
     +   NPRT,NW
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FREQ(101),SPCF(101,4),WORK(101),XAXIS(106),Y(1),YAXIS(106)
      INTEGER
     +   ISORT(101),ISYM(106),LAGS(4)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ECVF,IPRINT,PARZEN,UFSDRV
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LAGMAX+1)
!        THE AUTOCOVARIANCE AT LAG ZERO (BIASED VARIANCE).
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISYM(106)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(LAGMAX+1)
!        THE ARRAY CONTAINING THE NUMBER OF LAG PRODUCT PAIRS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION SPCF(101,4)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     DOUBLE PRECISION WORK(101)
!        THE VECTOR OF LAG WINDOWS.
!     DOUBLE PRECISION XAXIS(106)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION Y(1)
!        A DUMMY ARRAY.
!     DOUBLE PRECISION YAXIS(106)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YMISS
!        A DUMMY VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','M','V',' '/
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(4) = .FALSE.
      OPTION(3) = .TRUE.
      OPTION(2) = .TRUE.
      OPTION(1) = .FALSE.
!
      LDSTAK = 0
      LDSMIN = 0
!
      YMISS = 1.0D0
      LACOV = LAGMAX+1
!
      ISPCF = 101
      LY = 1
      LNLPPA = LACOV
      LPCV = 106
      LWORK = 101
      NF = 101
!
!     SET NUMBER OF LAG WINDOW TRUNCATION POINTS
!
      NW = 4
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!     FOR SERIES WITH MISSING DATA.
!
      CALL UFSDRV(Y, LY, YMISS, ACOV, NLPPA, SPCF, ISPCF, NF, FMIN,
     +   FMAX, FREQ, N, NW, LAGMAX, LAGS, WORK, LACOV, LWORK, DELTA,
     +   ISORT, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, PARZEN, NMSUB,
     +   LDSMIN, LDSTAK, OPTION, LNLPPA, LY)
!
!     CHECK FOR ERRORS
!
      IF (IERR.EQ.0) RETURN
!
      IF (IERR.EQ.2) CALL ECVF(NMSUB)
      IERR = 1
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL UFSMV (ACOV, NLPPA, LAGMAX, N)')
      END
!NRAND
      SUBROUTINE NRAND (Y, N, ISEED)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE GENERATES N NORMALLY DISTRIBUTED PSEUDO-
!     RANDOM NUMBERS WITH ZERO MEAN AND UNIT STANDARD DEVIATION.  THE
!     NUMBERS GENERATED ARE DETERMINED BY ISEED.  THEY ARE RETURNED IN Y
!
!     ORIGIN - CONCEIVED BY DR. PETER TRYON TO FACILITATE USE OF
!          EXISTING RANDOM NUMBER GENERATOR
!
!     WRITTEN BY -
!          JOHN E. KOONTZ AND JANET R. DONALDSON
!          STATISTICAL ENGINEERING DIVISION
!          NATIONAL BUREAU OF STANDARDS
!          BOULDER, COLORADO 80302
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ISEED,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT,ISEEDU
      LOGICAL
     +   ERR01,HEAD
!
!  LOCAL ARRAYS
      CHARACTER
     +   LN(8)*1,LONE(8)*1,NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
!     REAL(TYPE=WP) :: RANDN
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISRNG,IPRINT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!          THE INDEX OF THE COMPUTING LOOP
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THEIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN FOUND.
!     INTEGER IPRT
!        THE STANDARD OUTPUT FILE UNIT NUMBER
!     INTEGER ISEED
!        THE ISEED TO THE RANDOM NUMBER GENERATOR.
!        ISEED MUST LIE BETWEEN 0 AND 2**((MIN(32,I1MACH(8)+1))-1) -1,
!        INCLUSIVE.  IF ISEED IS NOT EQUAL TO 0, ISEED MUST BE ODD.
!     INTEGER ISEEDU
!        THE VALUE OF THE SEED ACTUALLY USED.
!     CHARACTER*1 LN(8), LONE(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE VARIABLES(S) CHECKED
!        FOR ERRORS
!     INTEGER N
!        THE LENGTH OF DATA SET GENERATED
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THIS SUBROUTINE
!     DOUBLE PRECISION Y(N)
!        THE GENERATED RANDOM VALUES.
!
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'N',      'R',      'A',      'N',      'D',      ' '/
      DATA     LN(1),    LN(2),    LN(3),    LN(4),    LN(5),    LN(6),
     +         LN(7),    LN(8)/'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA   LONE(1),  LONE(2),  LONE(3),  LONE(4),  LONE(5),  LONE(6),
     +       LONE(7),  LONE(8)/'O', 'N', 'E', ' ', ' ', ' ', ' ', ' '/
!
      IERR = 0
!
      HEAD = .TRUE.
!
!     CHECK FOR INPUT ERRORS
!
      CALL EISGE(NMSUB, LN, N, 1, 2, HEAD, ERR01, LONE)
      CALL EISRNG(NMSUB, ISEED, ISEEDU, HEAD)
!
      IF (ERR01) THEN
!
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
        IERR = 1
!
      ELSE
!
!     GENERATE THE PSEUDO-RANDOM NUMBERS
!
        Y(1) = RANDN(ISEEDU,typ=0.0_wp)
        DO 20 I=1,N
           Y(I) = RANDN(0,typ=0.0_wp)
   20   CONTINUE
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NRAND(Y, N, ISEED)')
      END
!ERSGT
      SUBROUTINE ERSGT(NMSUB, NMVAR, VAL, VALMN, MSGTYP, HEAD, ERROR,
     +   NMMIN)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THE ROUTINE CHECKS WHETHER THE VALUE   VAL   IS GREATER THAN
!        VALMN   , AND PRINTS A DIAGNOSTIC IF IT IS NOT.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VAL,VALMN
      INTEGER
     +   MSGTYP
      LOGICAL
     +   ERROR,HEAD
!
!  ARRAY ARGUMENTS
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
!        PRINTED, WHERE IF ERROR IS .TRUE. AND
!        MSGTYP = 1 THE INPUT VALUE WAS TOO SMALL BASED
!                   ON LIMITS IMPOSED BY STARPAC
!        MSGTYP = 2 THE INPUT VALUE WAS TOO SMALL BASED ON
!                   LIMITS BASED ON OTHER INPUT ARGUMENTS.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE ARGUMENTS NAME.
!     DOUBLE PRECISION VAL
!        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
!     DOUBLE PRECISION VALMN
!        THE MINIMUM VALUE THE ARGUMENT CAN VALIDLY HAVE.
!
      ERROR = .FALSE.
!
      IF (VAL .GT. VALMN) RETURN
!
      ERROR = .TRUE.
      CALL IPRINT (IPRT)
      CALL EHDR(NMSUB, HEAD)
!
      WRITE (IPRT, 1000) (NMVAR(I),I=1,6), VAL
!
      GO TO (10, 20), MSGTYP
!
   10 WRITE (IPRT, 1010) (NMVAR(I),I=1,6), VALMN
      RETURN
!
   20 WRITE (IPRT, 1020) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/20H THE INPUT VALUE OF , 6A1, 4H IS , G15.8, '.')
 1010 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   22H MUST BE GREATER THAN , G21.14, '.')
 1020 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   22H MUST BE GREATER THAN , 8A1, '.')
!
      END
!AMEAN
      SUBROUTINE AMEAN(Y, N, YMEAN)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE ARITHMETIC MEAN OF A SERIES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMEAN
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   SUMY
      INTEGER
     +   I
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES
!     DOUBLE PRECISION SUMY
!        THE VARIABLE USED TO SUM THE Y VALUES.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
      SUMY = 0.0D0
      DO 10 I = 1, N
         SUMY = SUMY + Y(I)
   10 CONTINUE
      YMEAN = SUMY / N
      RETURN
      END
!XSTPLT
      SUBROUTINE XSTPLT(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,EXMPT
      INTEGER
     +   I,IPRT,IXM,LDSMIN,M,N,NETA,NPAR,NPRT,NTEST
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   EXMTST(5),PAR(10),SCALE(10),STP(10),XM(200,2)
      INTEGER
     +   NETTST(6)
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LDSCMP,LSTVEC,MDL4,STPLS1,STPLS2,STPLSC
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG10
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        *
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     DOUBLE PRECISION EXMTST(5)
!        VARIOUS TEST VALUES FOR EXMPT.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL4
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NETTST(6)
!        VARIOUS TEST VALUES FOR NETA.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     DOUBLE PRECISION PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION SCALE(10)
!        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION STP(10)
!        THE SELECTED STEP SIZES FOR EACH PARAMETER.
!     DOUBLE PRECISION XM(200,2)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      CALL IPRINT(IPRT)
!
!     SET PARAMETER VALUES
!
      CALL STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
      CALL STPLS2(NPAR, STP)
      CALL LDSCMP(14, 0, 2*(N+NPAR), 0, 0, 0, 'D', 10*N, LDSMIN)
!
      IF (LDSMIN.LE.LDSTAK) GO TO 5
!
      WRITE (IPRT, 1000) LDSMIN
      RETURN
!
    5 CONTINUE
!
!     CREATE INDEPENDENT VARIABLE
!
      DELTA = 0.0625D0
      XM(1,1) = 0.0D0
      DO 10 I=2,N
         XM(I,1) = XM(I-1,1) + DELTA
   10 CONTINUE
!
      NTEST = 0
!
!
!     TEST VARIOUS VALUES OF EXMPT
!
      CALL STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
      EXMTST(1) = -1.0D0
      EXMTST(2) = 0.0001D0
      EXMTST(3) = 0.5D0
      EXMTST(4) = 1.0D0
      EXMTST(5) = 1.1D0
!
      DO 20 I=1,5
!
         NTEST = NTEST + 1
         WRITE (IPRT,1090) NTEST
         WRITE (IPRT,1040)
         WRITE (IPRT,1060) NETA, EXMTST(I), SCALE(1), NPRT
         WRITE (IPRT,1010)
         CALL STPLS2(NPAR, STP)
         CALL STPLSC(XM, N, M, IXM, MDL4, PAR, NPAR, LDSTAK, STP, NETA,
     +      EXMTST(I), SCALE, NPRT)
         WRITE (IPRT,1100) NETA, EXMTST(I), SCALE(1), NPRT
         WRITE (IPRT,1050) IERR
         WRITE (IPRT,1080)
         CALL LSTVEC(4, STP)
!
   20 CONTINUE
!
!     TEST VARIOUS VALUES OF NETA
!
      NETTST(1) = -1
      NETTST(2) = 0
      NETTST(3) = 1
      NETTST(4) = 2
!
      NETTST(5) = -LOG10(D1MACH(4))
      NETTST(6) = NETTST(5) + 1
!
      SCALE(1) = 0.0D0
!
      DO 30 I=1,6
!
         NTEST = NTEST + 1
         WRITE (IPRT,1090) NTEST
         WRITE (IPRT,1040)
         WRITE (IPRT,1060) NETTST(I), EXMPT, SCALE(1), NPRT
         WRITE (IPRT,1010)
         CALL STPLS2(NPAR, STP)
         CALL STPLSC(XM, N, M, IXM, MDL4, PAR, NPAR, LDSTAK, STP,
     +      NETTST(I), EXMPT, SCALE, NPRT)
         WRITE (IPRT,1100) NETTST(I), EXMPT, SCALE(1), NPRT
         WRITE (IPRT,1050) IERR
         WRITE (IPRT,1080)
         CALL LSTVEC(4, STP)
!
   30 CONTINUE
!
!     SUPPRESS OUTPUT
!
      CALL STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
      NPRT = 0
!
      NTEST = NTEST + 1
      WRITE (IPRT,1090) NTEST
      WRITE (IPRT,1040)
      WRITE (IPRT,1060) NETA, EXMPT, SCALE(1), NPRT
      WRITE (IPRT,1010)
      CALL STPLS2(NPAR, STP)
      CALL STPLSC(XM, N, M, IXM, MDL4, PAR, NPAR, LDSTAK, STP, NETA,
     +   EXMPT, SCALE, NPRT)
      WRITE (IPRT,1100) NETA, EXMPT, SCALE(1), NPRT
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1080)
      CALL LSTVEC(4, STP)
!
!     LARGE CALCULATION ERROR PROBLEM
!
      CALL STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
      PAR(3) = 10.0D0**((NETTST(5)-1)/2)
      SCALE(1) = -1.0D0
!
      NTEST = NTEST + 1
      WRITE (IPRT,1090) NTEST
      WRITE (IPRT,1070)
      WRITE (IPRT,1060) NETA, EXMPT, SCALE(1), NPRT
      WRITE (IPRT,1010)
      CALL STPLS2(NPAR, STP)
      CALL STPLSC(XM, N, M, IXM, MDL4, PAR, NPAR, LDSTAK, STP, NETA,
     +   EXMPT, SCALE, NPRT)
      WRITE (IPRT,1100) NETA, EXMPT, SCALE(1), NPRT
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1080)
      CALL LSTVEC(4, STP)
!
      EXMPT = 0.11D0
      NPRT = 0
!
      NTEST = NTEST + 1
      WRITE (IPRT,1090) NTEST
      WRITE (IPRT,1070)
      WRITE (IPRT,1060) NETA, EXMPT, SCALE(1), NPRT
      WRITE (IPRT,1010)
      CALL STPLS2(NPAR, STP)
      CALL STPLSC(XM, N, M, IXM, MDL4, PAR, NPAR, LDSTAK, STP, NETA,
     +   EXMPT, SCALE, NPRT)
      WRITE (IPRT,1100) NETA, EXMPT, SCALE(1), NPRT
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1080)
      CALL LSTVEC(4, STP)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1010 FORMAT (15H TEST OF STPLSC)
 1040 FORMAT (15H SIMPLE EXAMPLE)
 1050 FORMAT (/29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1060 FORMAT (19H INPUT   -  NETA = , I5, 10H, EXMPT = , G15.8,
     +   13H, SCALE(1) = , G15.8, 9H, NPRT = , I5)
 1070 FORMAT (32H LARGE CALCULATION ERROR PROBLEM)
 1080 FORMAT (//23H RETURNED VALUES OF STP)
 1090 FORMAT (54H1DERIVATIVE STEP SIZE SELECTION SUBROUTINE TEST NUMBER,
     +   I5)
 1100 FORMAT (//19H OUTPUT  -  NETA = , I5, 10H, EXMPT = , G15.8,
     +   13H, SCALE(1) = , G15.8, 9H, NPRT = , I5//)
      END
!BFSDRV
      SUBROUTINE BFSDRV(Y1, Y2, YMISS1, YMISS2, CCOV, NLPPC, SPCF1,
     +   SPCF2, NF, FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS, LAGMX1,
     +   WORK, LWORK, DELTA, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT,
     +   WINDOW, ICCOV, JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2,
     +   IPHAS, CODD, CEVEN, W, LW, NMSUB, LDSMIN, LDSTAK, OPTION,
     +   NFFT, INLPPC, JNLPPC, LY)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLING ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS .
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS1,YMISS2
      INTEGER
     +   ICCOV,ICSPC2,INDEX1,INDEX2,INLPPC,IPHAS,JCCOV,JNLPPC,
     +   LAGMAX,LAGMX1,LDSMIN,LDSTAK,LPCV,LW,LWORK,LY,M,N,NF,NFFT,
     +   NPRT,NW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(*),CEVEN(*),CODD(*),CSPC2(*),FREQ(*),PHAS(*),SPCF1(*),
     +   SPCF2(*),W(*),WORK(*),XAXIS(*),Y1(*),Y2(*),YAXIS(*)
      INTEGER
     +   ISYM(*),LAGS(*),NLPPC(*)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL WINDOW
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   BW,DF,FMN,FMX,XPLTMN,XPLTMX,YMEAN1,YMEAN2,YPLTMN,YPLTMX
      INTEGER
     +   I,ILOG,ISPCER,J,K,LAG,LAGLST,NFUSED,NPTS,NWUSED
      LOGICAL
     +   NEWPG,UNIVAR
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   LSTLAG
      EXTERNAL LSTLAG
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACVF,ACVFF,ACVFM,BFSER,BFSLAG,BFSMN,CCVF,CCVFF,CCVFM,
     +   DFBW,DFBWM,SETFRQ,UFSEST,UFSOUT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC INT,MAX,MIN
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!  STATEMENT FUNCTIONS
      INTEGER
     +   I3C,I3N
!
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION BW
!        THE BANDWIDTH.
!     DOUBLE PRECISION CCOV(ICCOV,JCCOV,M)
!        THE COVARIANCES.
!     DOUBLE PRECISION CEVEN(LAGMX1)
!        THE SUMS OF THE COVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CODD(LAGMX1)
!        THE DIFFERENCES OF THE COVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CSPC2(ICSPC2,NW)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FMN, FMX
!        *
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER ILOG
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        ILOG = 0 THE PLOT IS LINEAR/LINEAR, IF
!        ILOG = 1 THE PLOT IS LOG/LINEAR, IF
!     INTEGER ISPCER
!        AN ERROR FLAG USED FOR THE SPECTRUM PLOTS.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER I3C
!        STATEMENT FUNCTION FOR FINDING LOCATIONS WITHIN CCOV.
!     INTEGER I3N
!        STATEMENT FUNCTION FOR FINDING LOCATIONS WITHIN NLPPC.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF CCOV
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF NLPPC
!     INTEGER LAG
!        THE LAG WINDWO TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGLST
!        THE LAST LAG BEFORE MISSING DATA CAUSED AN ACVF
!        TO BE UNABLE TO BE COMPUTED.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        THE VALUE LAGMAX+1.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     LOGICAL NEWPG
!        THE LOGICAL VARIABLE USED TO DETERMINE IF OUTPUT
!        WILL BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NFUSED
!        THE NUMBER OF FREQUENCIES ACTUALLY USED.
!     INTEGER NLPPC(INLPPC,JNLPPC,M)
!         THE ARRAY CONTAINING THE NUMBER OF LAG PRODUCT PAIRS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     INTEGER NWUSED
!        THE NUMBER OF DIFFERENT BANDWIDTHS ACTUALLY USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     DOUBLE PRECISION PHAS(IPHAS,NW)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRUM.
!     DOUBLE PRECISION SPCF1(NF), SPCF2(NF)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     LOGICAL UNIVAR
!        THE LOGICAL VARIABLE USED TO DETERMINE IF THE OUTPUT
!        IS FOR UNIVARIATE (TRUE) OR BIVARIATE (FALSE) SPECTRA.
!     DOUBLE PRECISION W(LW)
!        THE VECTOR OF WINDOWS.
!     EXTERNAL WINDOW
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION WORK(LWORK)
!        THE VECTOR OF WORK SPACE.
!     DOUBLE PRECISION XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     DOUBLE PRECISION YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YMEAN1, YMEAN2
!        THE MEAN OF THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YMISS1, YMISS2
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!     DOUBLE PRECISION YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!     DOUBLE PRECISION Y1(N), Y2(N)
!         THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!
!
!  STATEMENT FUNCTION DEFINITIONS
!
      I3C(I,J,K) = I + (J-1)*ICCOV + (K-1)*JCCOV*ICCOV
      I3N(I,J,K) = I + (J-1)*INLPPC + (K-1)*JNLPPC*INLPPC
!
      NFUSED = NF
      IF (OPTION(4)) THEN
        FMN = MAX(FMIN, 0.0D0)
        FMX = MIN(FMAX, 0.5D0)
        IF (FMN.GE.FMX) THEN
          FMN = 0.0D0
          FMX = 0.5D0
        END IF
      ELSE
!
!       SET VARIOUS VALUES FOR SHORT FORMS OF CALL STATEMENT
!
        NPRT = -1
        FMN = 0.0D0
        FMX = 0.5D0
        LAGMX1 = LAGMAX + 1
      END IF
!
!     CHECK FOR ERRORS
!
      CALL BFSER(NMSUB, N, LAGMAX, ICCOV, JCCOV, INLPPC, JNLPPC, M,
     +           INDEX1, INDEX2, ICSPC2, IPHAS, NF, NW, LAGS,
     +           LDSTAK, LDSMIN, LY, NFFT, OPTION)
!
      IF (IERR.EQ.1) RETURN
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      ALPHA = 0.95D0
      DELTA = 1.0D0
!
!     COMPUTE COVARIANCES
!
      LAGLST = LAGMAX
      IF (OPTION(1)) THEN
        CALL ACVFF(Y1, N, NFFT, YMEAN1,
     +             CCOV(I3C(1,INDEX1,INDEX1)),
     +             LAGMAX, ICCOV, N, WORK, NFFT)
        CALL ACVFF(Y2, N, NFFT, YMEAN2,
     +             CCOV(I3C(1,INDEX2,INDEX2)),
     +             LAGMAX, ICCOV, N, WORK, NFFT)
        CALL CCVFF(Y1, Y2, N, NFFT, LAGMAX,
     +             CCOV(I3C(1,INDEX1,INDEX2)),
     +             CCOV(I3C(1,INDEX2,INDEX1)), ICCOV, N, WORK, LWORK)
!
      ELSE
        IF (OPTION(3)) THEN
          IF (OPTION(2)) LAGLST = LSTLAG(NLPPC,LAGMAX,INLPPC)
        ELSE
          IF (OPTION(2)) THEN
            CALL ACVFM(Y1, YMISS1, N, YMEAN1,
     +                 CCOV(I3C(1,INDEX1,INDEX1)),
     +                 LAGMAX, LAGLST, NLPPC, ICCOV)
            CALL ACVFM(Y2, YMISS2, N, YMEAN2,
     +                 CCOV(I3C(1,INDEX2,INDEX2)),
     +                 LAGMAX, LAGLST, NLPPC, ICCOV)
            CALL CCVFM(Y1, YMISS1, Y2, YMISS2, N, LAGMAX, YMEAN1,
     +                 YMEAN2, CCOV(I3C(1,INDEX1,INDEX2)),
     +                 CCOV(I3C(1,INDEX2,INDEX1)), ICCOV,
     +                 NLPPC(I3N(1,INDEX1,INDEX2)),
     +                 NLPPC(I3N(1,INDEX2,INDEX1)))
!
          ELSE
            CALL ACVF(Y1, N, YMEAN1, CCOV(I3C(1,INDEX1,INDEX1)), LAGMAX,
     +                ICCOV)
            CALL ACVF(Y2, N, YMEAN2, CCOV(I3C(1,INDEX2,INDEX2)), LAGMAX,
     +                ICCOV)
            CALL CCVF(Y1, Y2, N, LAGMAX, YMEAN1, YMEAN2,
     +                CCOV(I3C(1,INDEX1,INDEX2)),
     +                CCOV(I3C(1,INDEX2,INDEX1)), ICCOV)
          END IF
        END IF
      END IF
!
      IF (LAGLST.LE.0) THEN
!
!     AN ERROR HAS BEEN DETECTED
!
         IERR = 2
         RETURN
      END IF
!
!     COMPUTE THE VECTOR OF LAG WINDOW TRUNCATION POINTS, ORDERED
!     SMALLEST TO LARGEST.
!
      NWUSED = NW
      IF (.NOT.OPTION(4)) CALL BFSLAG(CCOV, LAGLST, LAGS, N, NW, NWUSED,
     +                                ICCOV, JCCOV, INDEX1, INDEX2)
!
!     BEGIN COMPUTING FOURIER SPECTRUM FOR SERIES
!
      UNIVAR = .FALSE.
!
      ILOG = 0
!
      XPLTMN = FMN
      XPLTMX = FMX
!
      YPLTMN = 0.0D0
      YPLTMX = 1.0D0
!
!     SET FREQUENCIES FOR THE SPECTRUM.
!
      CALL SETFRQ(FREQ, NF, 1, FMN, FMX, DELTA)
!
!     COMPUTE AND PLOT SPECTRUM VALUES.
!
      NEWPG = .FALSE.
!
!     COMPUTE THE EVEN AND ODD CCVF ESTIMATES
!
      CEVEN(1) = CCOV(I3C(1,INDEX1,INDEX2))
      CODD(1) = 0.0D0
      DO 30 I=1,LAGLST
         CEVEN(I+1) = 0.5D0*
     +                (CCOV(I3C(I+1,INDEX1,INDEX2))+
     +                 CCOV(I3C(I+1,INDEX2,INDEX1)))
         CODD(I+1) = 0.5D0*
     +               (CCOV(I3C(I+1,INDEX1,INDEX2))-
     +                CCOV(I3C(I+1,INDEX2,INDEX1)))
   30 CONTINUE
!
      DO 60 I=1,NWUSED
         LAG = LAGS(I)
         IF (LAG.GT.LAGLST) THEN
            ISPCER = 2
            DF = 0.0D0
         ELSE
!
            ISPCER = 0
!
!     COMPUTE THE WINDOW, AND EFFECTIVE DEGREES OF FREEDOM AND
!     BANDWIDTH BASED ON THE WINDOW
!
            CALL WINDOW(LAG, W, LW)
            IF (OPTION(2)) THEN
               CALL DFBWM(N, LAG, W, LW, NLPPC(I3N(1,INDEX1,INDEX2)),
     +                    NLPPC(I3N(1,INDEX2,INDEX1)), INLPPC, DF, BW)
            ELSE
               CALL DFBW(N, LAG, W, LW, DF, BW)
            END IF
!
!     COMPUTE THE SPECTRUM FOR EACH INDIVIDUAL SERIES
!
            CALL UFSEST(CCOV(I3C(1,INDEX1,INDEX1)), W, LAG, SPCF1,
     +                  NFUSED, ICCOV, LAGMAX, NF, FREQ, DELTA)
!
            CALL UFSEST(CCOV(I3C(1,INDEX2,INDEX2)), W, LAG, SPCF2,
     +                  NFUSED, ICCOV, LAGMAX, NF, FREQ, DELTA)
!
            CALL BFSMN(SPCF1, SPCF2, CEVEN, CODD, W, LW, LAG, DF, NPRT,
     +                 NF, CSPC2(1+(I-1)*ICSPC2), PHAS(1+(I-1)*IPHAS),
     +                 FREQ, NPTS, XAXIS,
     +                 YAXIS, ISYM, LPCV, ALPHA, LAGMX1, DELTA)
!
            IF (NPRT.EQ.0) GO TO 60
!
         END IF
         CALL UFSOUT(XAXIS, YAXIS, ISYM, NPTS, BW, INT(DF+0.5D0), LAG,
     +               LAGMAX, NEWPG, ISPCER, NFUSED+5, XPLTMN, XPLTMX,
     +               YPLTMN, YPLTMX, ILOG, PHAS(1+(I-1)*IPHAS), FREQ,
     +               NF, UNIVAR, NMSUB)
!
         NEWPG = .TRUE.
!
   60 CONTINUE
!
      RETURN
!
      END
!VPC
      SUBROUTINE VPC(YM, N, NS, ILOG, ISIZE, IRLIN, IBAR,
     +   YLB, YUB, XLB, XINC)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IRLIN,ISIZE,N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,ISCHCK,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  ' ',       'V',       'P',       'C',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      YMMISS(1) = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      ISCHCK = 0
      MISS = .FALSE.
      LISYM = 1
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL VPC (Y, N, NS, ILOG,'/
     +  '      +          ISIZE, IRLIN, IBAR, YLB, YUB, XLB, XINC)')
      END
!LSTVCF
      SUBROUTINE LSTVCF(N, VEC, LMASK, MASK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS THE FIRST N ELEMENTS OF THE VECTOR
!     VEC.  THE I TH ELEMENT OF VEC IS IDENTIFIED WITH THE INDEX
!     OF THE I TH ZERO ELEMENT OF MASK.
!
!     WRITTEN BY  -  JOHN E. KOONTZ
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!                       PATTERNED AFTER LSTVEC OF JUNE 7, 1982.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LMASK,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VEC(N)
      INTEGER
     +   MASK(LMASK)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IMASK,IMAX,IMIN,INDEX,IPRT,J,JMAX,NPERL
!
!  LOCAL ARRAYS
      INTEGER
     +   INDW(10)
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   INPERL
      EXTERNAL INPERL
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IMASK
!        INDEX IN MASK.
!     INTEGER IMAX, IMIN
!        THE LARGEST AND SMALLEST INDICES IN VEC OF THE ELEMENTS TO BE
!        PRINTED.
!     INTEGER INDEX
!        THE INDEX OF THE VALUE TO BE PRINTED.
!     INTEGER INDW(10)
!        A WORK VECTOR FOR THE INDICES TO BE PRINTED FOR VEC.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER JMAX
!        INDEX IN INDW OF THE LARGEST INDEX TO BE PRINTED FOR VEC.
!     INTEGER LMASK
!        THE LENGTH OF MASK.  LMASK .GE. N.
!     INTEGER MASK(LMASK)
!        MASK VECTOR FOR VEC.  THE INDEX OF THE ITH ELEMENT OF MASK
!        EQUAL TO ZERO IS THE LABEL IN THE OUTPUT OF THE ITH ELEMENT
!        OF VEC.
!     INTEGER N
!        THE NUMBER OF VALUES TO BE PRINTED IN THE INPUT VECTOR.
!     INTEGER NPERL
!        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
!     DOUBLE PRECISION VEC(N)
!        THE VECTOR OF VALUES TO BE PRINTED.
!
      CALL IPRINT(IPRT)
!
      NPERL = INPERL(0)
!        NOTE - INPERL(0) IS ASSUMED TO BE AT MOST 10.0D0  IF GREATER,
!               INCREASE THE DIMENSION OF INDW.
!
!
      IMASK = 0
      DO 30 I = 1, N, NPERL
         IMIN = I
         IMAX = MIN(I+NPERL-1, N)
         JMAX = MIN(N - IMIN + 1, NPERL)
         DO 20 J = 1, JMAX
   10       IF (IMASK .GE. LMASK) GO TO 40
            IMASK = IMASK + 1
            IF (MASK(IMASK) .NE. 0) GO TO 10
            INDW(J) = IMASK
   20    CONTINUE
         WRITE(IPRT, 1010) (INDW(INDEX), INDEX = 1, JMAX)
         WRITE(IPRT, 1020) (VEC(INDEX), INDEX = IMIN, IMAX)
   30 CONTINUE
!
      RETURN
!
   40 WRITE (IPRT, 1030)
      RETURN
!
!     FORMAT STATEMENTS
!
 1010 FORMAT(10X, 5HINDEX, I5, 6I15)
 1020 FORMAT(10X, 5HVALUE, 7(1X, G14.7)/)
 1030 FORMAT (/47H ERROR IN STARPAC.  LSTVEC TRIED TO ACCESS MORE,
     +   29H ELEMENTS THAN EXIST IN MASK.)
!
      END
!CCF
      SUBROUTINE CCF (Y1, Y2, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
!     CORRELATIONS OF TWO TIME SERIES (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y1(*),Y2(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   Y1MEAN,Y1SD,Y2MEAN,Y2SD
      INTEGER
     +   ICCOV,INLPPC,IPRT,IYM,IYMFFT,JCCOV,JNLPPC,LAGMAX,LDSMIN,
     +   LDSTAK,LYFFT,M,NFFT
      LOGICAL
     +   ISFFT,ISLONG
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCOV(101,2,2),RHOC(201),SDRHOC(201)
      INTEGER
     +   NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACVF,CCFER,CCFMN,CCFOUT,IPRINT,SETLAG
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCOV(101, 2, 2)
!        THE CCVF MATRIX.
!     INTEGER ICCOV
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER INLPPC
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
!        IN THE USERS PROGRAM.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     LOGICAL ISLONG
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
!     INTEGER IYM
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YM AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IYMFFT
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JCCOV
!        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
!        IN THE USERS PROGRAM.
!     INTEGER LAGMAX
!        THE NUMBER OF AUTOCORRELATIONS DESIRED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER M
!        THE NUMBER OF SERIES BEING COMPARED, IE THE
!        NUMBER OF COLUMNS OF DATA IN YM.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NDUM(1)
!        A DUMMY DIMENSIONED VARIABLE.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     DOUBLE PRECISION RHOC(201)
!        THE ARRAY CONTAINING THE CCF.
!     DOUBLE PRECISION SDRHOC(201)
!        THE ARRAY CONTAINING THE SD OF THE CCF.
!     DOUBLE PRECISION Y1(N), Y1MEAN, Y1SD
!        THE FIRST SERIES, AND ITS MEAN AND STANDARD DEVIATION.
!     DOUBLE PRECISION Y2(N), Y2MEAN, Y2SD
!        THE SECOND SERIES, AND ITS MEAN AND STANDARD DEVIATION.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'C',       'C',       'F',       ' ',       ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      ICCOV = 101
      INLPPC = 1
      IYM = N
      JCCOV = 2
      JNLPPC = 1
      LDSMIN = 0
      LDSTAK = 0
      LAGMAX = 1
      LYFFT = N + LAGMAX
      IYMFFT = LYFFT
      M = 2
      NFFT = N
      ISFFT = .FALSE.
      ISLONG = .FALSE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL CCFER(NMSUB, N, LAGMAX, LDSTAK, LDSMIN, ICCOV, JCCOV,
     +  INLPPC, JNLPPC, M, LYFFT, NFFT, IYM, IYMFFT, ISFFT, ISLONG)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      IF (IERR.EQ.0) THEN
!
!       SET THE MAXIMUM LAG VALUE TO BE USED.
!
        CALL SETLAG (N, LAGMAX)
!
!       COMPUTE THE SERIES ACVF AND SD
!
        CALL ACVF (Y1, N, Y1MEAN, CCOV(1,1,1), LAGMAX, 101)
        Y1SD = SQRT(CCOV(1,1,1) * N / (N-1))
!
        CALL ACVF (Y2, N, Y2MEAN, CCOV(1,2,2), LAGMAX, 101)
        Y2SD = SQRT(CCOV(1,2,2) * N / (N-1))
!
!       CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
        IF (CCOV(1,1,1)*CCOV(1,2,2) .NE. 0.0D0)
     +    CALL CCFMN (Y1, Y2, N, LAGMAX, 2*LAGMAX+1, CCOV(1,1,1),
     +     CCOV(1,2,2), CCOV(1,1,2), CCOV(1,2,1), 101, Y1MEAN, Y2MEAN,
     +     RHOC, SDRHOC, 1)
!
!       CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
        CALL CCFOUT (1, Y1MEAN, Y1SD, N, N, 2, Y2MEAN, Y2SD, N,
     +     N, LAGMAX, 2*LAGMAX+1, RHOC, SDRHOC, .FALSE., NDUM, NDUM, 1,
     +     0.0D0, 0.0D0, .FALSE.)
      END IF
!
      IF (IERR.NE.0) THEN
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   27H       CALL CCF (Y1, Y2, N))
      END
!XPP
      SUBROUTINE XPP(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE PLOTTING SUBROUTINES
!
!     SERIES Y IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND
!     JENKINS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YMISS,YUB
      INTEGER
     +   ILOG,IPRT,ISIZE,ITEST,IYM,M,NOUT,NY,NYM
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AIR(144),TIME(144),X(144),Y(144),YM(12,12),YMMISS(144)
      INTEGER
     +   ISYM(144)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,MPP,MPPC,MPPL,MPPM,MPPMC,MPPML,PP,PPC,PPL,PPM,
     +   PPMC,PPML,DCOPY,SETRV,SPP,SPPC,SPPL,SPPM,SPPMC,SPPML
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (Y(1),YM(1,1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AIR(144)
!        THE AIRLINE DATA.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(144)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER ITEST
!        THE NUMBER OF THE TEST.
!     INTEGER IYM
!        ACTUAL DIMENSION OF YM IN USERS MAIN PROGRAM
!     INTEGER LDSTAK
!        *
!     INTEGER M
!        THE NUMBER OF VECTORS IN YM
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     INTEGER NY, NYM
!        THE NUMBER OF OBSERVATIONS IN ARRAYS Y AND YM, RESPECTIVELY.
!     DOUBLE PRECISION TIME(144)
!        THE TIME VALUES FOR THE AIRLINE DATA.
!     DOUBLE PRECISION X(144)
!        VECTOR OF OBSERVATIONS FOR X(HORIZONTAL) COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION Y(144)
!        VECTOR OF OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(12,12)
!        MULTIVARIATE OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES.
!     DOUBLE PRECISION YMISS
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YMMISS(144)
!        THE MISSING VALUE CODES FOR EACH COLUMN OF YM.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
      DATA     XMISS,    YMISS
     +    /      7.0D0,    180.0D0/
!
      DATA ISYM(  1),ISYM(  2),ISYM(  3),ISYM(  4),ISYM(  5),ISYM(  6)
     +    /    -5000,     6000,        7,        8,        9,       10/
      DATA ISYM(  7),ISYM(  8),ISYM(  9),ISYM( 10),ISYM( 11),ISYM( 12)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 13),ISYM( 14),ISYM( 15),ISYM( 16),ISYM( 17),ISYM( 18)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 19),ISYM( 20),ISYM( 21),ISYM( 22),ISYM( 23),ISYM( 24)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 25),ISYM( 26),ISYM( 27),ISYM( 28),ISYM( 29),ISYM( 30)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 31),ISYM( 32),ISYM( 33),ISYM( 34),ISYM( 35),ISYM( 36)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 37),ISYM( 38),ISYM( 39),ISYM( 40),ISYM( 41),ISYM( 42)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 43),ISYM( 44),ISYM( 45),ISYM( 46),ISYM( 47),ISYM( 48)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 49),ISYM( 50),ISYM( 51),ISYM( 52),ISYM( 53),ISYM( 54)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 55),ISYM( 56),ISYM( 57),ISYM( 58),ISYM( 59),ISYM( 60)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 61),ISYM( 62),ISYM( 63),ISYM( 64),ISYM( 65),ISYM( 66)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 67),ISYM( 68),ISYM( 69),ISYM( 70),ISYM( 71),ISYM( 72)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 73),ISYM( 74),ISYM( 75),ISYM( 76),ISYM( 77),ISYM( 78)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 79),ISYM( 80),ISYM( 81),ISYM( 82),ISYM( 83),ISYM( 84)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 85),ISYM( 86),ISYM( 87),ISYM( 88),ISYM( 89),ISYM( 90)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM( 91),ISYM( 92),ISYM( 93),ISYM( 94),ISYM( 95),ISYM( 96)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM( 97),ISYM( 98),ISYM( 99),ISYM(100),ISYM(101),ISYM(102)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM(103),ISYM(104),ISYM(105),ISYM(106),ISYM(107),ISYM(108)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM(109),ISYM(110),ISYM(111),ISYM(112),ISYM(113),ISYM(114)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM(115),ISYM(116),ISYM(117),ISYM(118),ISYM(119),ISYM(120)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM(121),ISYM(122),ISYM(123),ISYM(124),ISYM(125),ISYM(126)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM(127),ISYM(128),ISYM(129),ISYM(130),ISYM(131),ISYM(132)
     +    /       11,       12,       13,       14,       15,       16/
      DATA ISYM(133),ISYM(134),ISYM(135),ISYM(136),ISYM(137),ISYM(138)
     +    /        5,        6,        7,        8,        9,       10/
      DATA ISYM(139),ISYM(140),ISYM(141),ISYM(142),ISYM(143),ISYM(144)
     +    /       11,       12,       13,       14,       15,       16/
!
      DATA TIME(  1),TIME(  2),TIME(  3),TIME(  4),TIME(  5),TIME(  6)
     +    /   1.0D0,    2.0D0,    3.0D0,    4.0D0,    5.0D0,    6.0D0/
      DATA TIME(  7),TIME(  8),TIME(  9),TIME( 10),TIME( 11),TIME( 12)
     +    /   7.0D0,    8.0D0,    9.0D0,   10.0D0,   11.0D0,   12.0D0/
      DATA TIME( 13),TIME( 14),TIME( 15),TIME( 16),TIME( 17),TIME( 18)
     +    /  13.0D0,   14.0D0,   15.0D0,   16.0D0,   17.0D0,   18.0D0/
      DATA TIME( 19),TIME( 20),TIME( 21),TIME( 22),TIME( 23),TIME( 24)
     +    /  19.0D0,   20.0D0,   21.0D0,   22.0D0,   23.0D0,   24.0D0/
      DATA TIME( 25),TIME( 26),TIME( 27),TIME( 28),TIME( 29),TIME( 30)
     +    /  25.0D0,   26.0D0,   27.0D0,   28.0D0,   29.0D0,   30.0D0/
      DATA TIME( 31),TIME( 32),TIME( 33),TIME( 34),TIME( 35),TIME( 36)
     +    /  31.0D0,   32.0D0,   33.0D0,   34.0D0,   35.0D0,   36.0D0/
      DATA TIME( 37),TIME( 38),TIME( 39),TIME( 40),TIME( 41),TIME( 42)
     +    /  37.0D0,   38.0D0,   39.0D0,   40.0D0,   41.0D0,   42.0D0/
      DATA TIME( 43),TIME( 44),TIME( 45),TIME( 46),TIME( 47),TIME( 48)
     +    /  43.0D0,   44.0D0,   45.0D0,   46.0D0,   47.0D0,   48.0D0/
      DATA TIME( 49),TIME( 50),TIME( 51),TIME( 52),TIME( 53),TIME( 54)
     +    /  49.0D0,   50.0D0,   51.0D0,   52.0D0,   53.0D0,   54.0D0/
      DATA TIME( 55),TIME( 56),TIME( 57),TIME( 58),TIME( 59),TIME( 60)
     +    /  55.0D0,   56.0D0,   57.0D0,   58.0D0,   59.0D0,   60.0D0/
      DATA TIME( 61),TIME( 62),TIME( 63),TIME( 64),TIME( 65),TIME( 66)
     +    /  61.0D0,   62.0D0,   63.0D0,   64.0D0,   65.0D0,   66.0D0/
      DATA TIME( 67),TIME( 68),TIME( 69),TIME( 70),TIME( 71),TIME( 72)
     +    /  67.0D0,   68.0D0,   69.0D0,   70.0D0,   71.0D0,   72.0D0/
      DATA TIME( 73),TIME( 74),TIME( 75),TIME( 76),TIME( 77),TIME( 78)
     +    /  73.0D0,   74.0D0,   75.0D0,   76.0D0,   77.0D0,   78.0D0/
      DATA TIME( 79),TIME( 80),TIME( 81),TIME( 82),TIME( 83),TIME( 84)
     +    /  79.0D0,   80.0D0,   81.0D0,   82.0D0,   83.0D0,   84.0D0/
      DATA TIME( 85),TIME( 86),TIME( 87),TIME( 88),TIME( 89),TIME( 90)
     +    /  85.0D0,   86.0D0,   87.0D0,   88.0D0,   89.0D0,   90.0D0/
      DATA TIME( 91),TIME( 92),TIME( 93),TIME( 94),TIME( 95),TIME( 96)
     +    /  91.0D0,   92.0D0,   93.0D0,   94.0D0,   95.0D0,   96.0D0/
      DATA TIME( 97),TIME( 98),TIME( 99),TIME(100),TIME(101),TIME(102)
     +    /  97.0D0,   98.0D0,   99.0D0,  100.0D0,  101.0D0,  102.0D0/
      DATA TIME(103),TIME(104),TIME(105),TIME(106),TIME(107),TIME(108)
     +    / 103.0D0,  104.0D0,  105.0D0,  106.0D0,  107.0D0,  108.0D0/
      DATA TIME(109),TIME(110),TIME(111),TIME(112),TIME(113),TIME(114)
     +    / 109.0D0,  110.0D0,  111.0D0,  112.0D0,  113.0D0,  114.0D0/
      DATA TIME(115),TIME(116),TIME(117),TIME(118),TIME(119),TIME(120)
     +    / 115.0D0,  116.0D0,  117.0D0,  118.0D0,  119.0D0,  120.0D0/
      DATA TIME(121),TIME(122),TIME(123),TIME(124),TIME(125),TIME(126)
     +    / 121.0D0,  122.0D0,  123.0D0,  124.0D0,  125.0D0,  126.0D0/
      DATA TIME(127),TIME(128),TIME(129),TIME(130),TIME(131),TIME(132)
     +    / 127.0D0,  128.0D0,  129.0D0,  130.0D0,  131.0D0,  132.0D0/
      DATA TIME(133),TIME(134),TIME(135),TIME(136),TIME(137),TIME(138)
     +    / 133.0D0,  134.0D0,  135.0D0,  136.0D0,  137.0D0,  138.0D0/
      DATA TIME(139),TIME(140),TIME(141),TIME(142),TIME(143),TIME(144)
     +    / 139.0D0,  140.0D0,  141.0D0,  142.0D0,  143.0D0,  144.0D0/
!
      DATA  AIR(  1), AIR(  2), AIR(  3), AIR(  4), AIR(  5), AIR(  6)
     +    / 112.0D0,  118.0D0,  132.0D0,  129.0D0,  121.0D0,  135.0D0/
      DATA  AIR(  7), AIR(  8), AIR(  9), AIR( 10), AIR( 11), AIR( 12)
     +    / 148.0D0,  148.0D0,  136.0D0,  119.0D0,  104.0D0,  118.0D0/
      DATA  AIR( 13), AIR( 14), AIR( 15), AIR( 16), AIR( 17), AIR( 18)
     +    / 115.0D0,  126.0D0,  141.0D0,  135.0D0,  125.0D0,  149.0D0/
      DATA  AIR( 19), AIR( 20), AIR( 21), AIR( 22), AIR( 23), AIR( 24)
     +    / 170.0D0,  170.0D0,  158.0D0,  133.0D0,  114.0D0,  140.0D0/
      DATA  AIR( 25), AIR( 26), AIR( 27), AIR( 28), AIR( 29), AIR( 30)
     +    / 145.0D0,  150.0D0,  178.0D0,  163.0D0,  172.0D0,  178.0D0/
      DATA  AIR( 31), AIR( 32), AIR( 33), AIR( 34), AIR( 35), AIR( 36)
     +    / 199.0D0,  199.0D0,  184.0D0,  162.0D0,  146.0D0,  166.0D0/
      DATA  AIR( 37), AIR( 38), AIR( 39), AIR( 40), AIR( 41), AIR( 42)
     +    / 171.0D0,  180.0D0,  193.0D0,  181.0D0,  183.0D0,  218.0D0/
      DATA  AIR( 43), AIR( 44), AIR( 45), AIR( 46), AIR( 47), AIR( 48)
     +    / 230.0D0,  242.0D0,  209.0D0,  191.0D0,  172.0D0,  194.0D0/
      DATA  AIR( 49), AIR( 50), AIR( 51), AIR( 52), AIR( 53), AIR( 54)
     +    / 196.0D0,  196.0D0,  236.0D0,  235.0D0,  229.0D0,  243.0D0/
      DATA  AIR( 55), AIR( 56), AIR( 57), AIR( 58), AIR( 59), AIR( 60)
     +    / 264.0D0,  272.0D0,  237.0D0,  211.0D0,  180.0D0,  201.0D0/
      DATA  AIR( 61), AIR( 62), AIR( 63), AIR( 64), AIR( 65), AIR( 66)
     +    / 204.0D0,  188.0D0,  235.0D0,  227.0D0,  234.0D0,  264.0D0/
      DATA  AIR( 67), AIR( 68), AIR( 69), AIR( 70), AIR( 71), AIR( 72)
     +    / 302.0D0,  293.0D0,  259.0D0,  229.0D0,  203.0D0,  229.0D0/
      DATA  AIR( 73), AIR( 74), AIR( 75), AIR( 76), AIR( 77), AIR( 78)
     +    / 242.0D0,  233.0D0,  267.0D0,  269.0D0,  270.0D0,  315.0D0/
      DATA  AIR( 79), AIR( 80), AIR( 81), AIR( 82), AIR( 83), AIR( 84)
     +    / 364.0D0,  347.0D0,  312.0D0,  274.0D0,  237.0D0,  278.0D0/
      DATA  AIR( 85), AIR( 86), AIR( 87), AIR( 88), AIR( 89), AIR( 90)
     +    / 284.0D0,  277.0D0,  317.0D0,  313.0D0,  318.0D0,  374.0D0/
      DATA  AIR( 91), AIR( 92), AIR( 93), AIR( 94), AIR( 95), AIR( 96)
     +    / 413.0D0,  405.0D0,  355.0D0,  306.0D0,  271.0D0,  306.0D0/
      DATA  AIR( 97), AIR( 98), AIR( 99), AIR(100), AIR(101), AIR(102)
     +    / 315.0D0,  301.0D0,  356.0D0,  348.0D0,  355.0D0,  422.0D0/
      DATA  AIR(103), AIR(104), AIR(105), AIR(106), AIR(107), AIR(108)
     +    / 465.0D0,  467.0D0,  404.0D0,  347.0D0,  305.0D0,  336.0D0/
      DATA  AIR(109), AIR(110), AIR(111), AIR(112), AIR(113), AIR(114)
     +    / 340.0D0,  318.0D0,  362.0D0,  348.0D0,  363.0D0,  435.0D0/
      DATA  AIR(115), AIR(116), AIR(117), AIR(118), AIR(119), AIR(120)
     +    / 491.0D0,  505.0D0,  404.0D0,  359.0D0,  310.0D0,  337.0D0/
      DATA  AIR(121), AIR(122), AIR(123), AIR(124), AIR(125), AIR(126)
     +    / 360.0D0,  342.0D0,  406.0D0,  396.0D0,  420.0D0,  472.0D0/
      DATA  AIR(127), AIR(128), AIR(129), AIR(130), AIR(131), AIR(132)
     +    / 548.0D0,  559.0D0,  463.0D0,  407.0D0,  362.0D0,  405.0D0/
      DATA  AIR(133), AIR(134), AIR(135), AIR(136), AIR(137), AIR(138)
     +    / 417.0D0,  391.0D0,  419.0D0,  461.0D0,  472.0D0,  535.0D0/
      DATA  AIR(139), AIR(140), AIR(141), AIR(142), AIR(143), AIR(144)
     +    / 622.0D0,  606.0D0,  508.0D0,  461.0D0,  390.0D0,  432.0D0/
!
      CALL SETRV(YMMISS, 144, YMISS)
      CALL DCOPY(144, AIR, 1, Y, 1)
      CALL DCOPY(144, TIME, 1, X, 1)
!
!     DEFINE CONSTANTS
!
      CALL IPRINT(IPRT)
!
!     COMMENCE BODY OF ROUTINE
!
      ITEST = 0
!
!     SHORT CALLS
!
      NY = 144
      NYM = 12
      IYM = 12
      M = 12
      ILOG = -1
      ISIZE = -1
      NOUT = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
!
   10 CONTINUE
!
!     TEST OF PP
!
      WRITE(IPRT, 1000)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      CALL PP(Y, X, NY)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF PPM
!
      WRITE(IPRT, 1030)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      CALL PPM(Y, YMISS, X, XMISS, NY)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF SPP
!
      WRITE(IPRT, 1120)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      CALL SPP(Y, X, NY, ISYM)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF SPPM
!
      WRITE(IPRT, 1150)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      CALL SPPM(Y, YMISS, X, XMISS, NY, ISYM)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF MPP
!
      WRITE(IPRT, 1060)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      CALL MPP(YM, X, NYM, M, IYM)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF MPPM
!
      WRITE(IPRT, 1090)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      CALL MPPM(YM, YMMISS, X, XMISS, NYM, M, IYM)
      WRITE (IPRT, 3000) IERR
!
!
!     LOG OPTION CALLS
!
!
   20 CONTINUE
!
!     TEST OF PPL
!
      WRITE(IPRT, 1010)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3040) ILOG
      CALL PPL(Y, X, NY, ILOG)
!
      WRITE (IPRT, 3000) IERR
!
!     TEST OF PPML
!
      WRITE(IPRT, 1040)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3040) ILOG
      CALL PPML(Y, YMISS, X, XMISS, NY, ILOG)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF SPPL
!
      WRITE(IPRT, 1130)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3040) ILOG
      CALL SPPL(Y, X, NY, ISYM, ILOG)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF SPPML
!
      WRITE(IPRT, 1160)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3040) ILOG
      CALL SPPML(Y, YMISS, X, XMISS, NY, ISYM, ILOG)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF MPPL
!
      WRITE(IPRT, 1070)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3040) ILOG
      CALL MPPL(YM, X, NYM, M, IYM, ILOG)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF MPPML
!
      WRITE(IPRT, 1100)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3040) ILOG
      CALL MPPML(YM, YMMISS, X, XMISS, NYM, M, IYM, ILOG)
      WRITE (IPRT, 3000) IERR
!
!
!     TEST OF LONG CALLS
!
!
   30 CONTINUE
!
!     TEST OF PPC
!
      WRITE(IPRT, 1020)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3050) ISIZE, NOUT
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3080) XUB
      CALL PPC(Y, X, NY, ILOG, ISIZE, NOUT, YLB, YUB, XLB, XUB)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF PPMC
!
      WRITE(IPRT, 1050)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3050) ISIZE, NOUT
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3080) XUB
      CALL PPMC(Y, YMISS, X, XMISS, NY, ILOG, ISIZE, NOUT, YLB, YUB,
     +   XLB, XUB)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF SPPC
!
      WRITE(IPRT, 1140)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3050) ISIZE, NOUT
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3080) XUB
      CALL SPPC(Y, X, NY, ISYM, ILOG, ISIZE, NOUT, YLB, YUB, XLB,
     +   XUB)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF SPPMC
!
      WRITE(IPRT, 1170)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NY
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3050) ISIZE, NOUT
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3080) XUB
      CALL SPPMC(Y, YMISS, X, XMISS, NY, ISYM, ILOG, ISIZE, NOUT,
     +   YLB, YUB, XLB, XUB)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF MPPC
!
   40 WRITE(IPRT, 1080)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3050) ISIZE, NOUT
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3080) XUB
      CALL MPPC(YM, X, NYM, M, IYM, ILOG, ISIZE, NOUT, YLB, YUB,
     +   XLB, XUB)
      WRITE (IPRT, 3000) IERR
!
!     TEST OF MPPMC
!
   50 WRITE(IPRT, 1110)
      WRITE (IPRT, 3100) ITEST
      WRITE (IPRT, 3010) NYM
      WRITE (IPRT, 3020) M, IYM
      WRITE (IPRT, 3040) ILOG
      WRITE (IPRT, 3050) ISIZE, NOUT
      WRITE (IPRT, 3070) YLB, YUB, XLB
      WRITE (IPRT, 3080) XUB
      CALL MPPMC(YM, YMMISS, X, XMISS, NYM, M, IYM, ILOG, ISIZE, NOUT,
     +   YLB, YUB, XLB, XUB)
      WRITE (IPRT, 3000) IERR
!
      ITEST = ITEST + 1
!
      GO TO (110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 300),
     +  ITEST
!
!     TEST VALID OPTIONS
!
  110 ILOG = 0
      ISIZE = 0
      NOUT = 0
      YLB = 100.0D0
      YUB = 700.0D0
      XLB = 4.0D0
      XUB = 16.0D0
      GO TO 20
!
  120 ILOG = 2
      ISIZE = 2
      NOUT = 5
      GO TO 20
!
  130 ILOG = 20
      ISIZE = 20
      NOUT = 55
      YUB = 300.0D0
      GO TO 30
!
  140 ILOG = 22
      ISIZE = 22
      GO TO 40
!
  150 NY = 1
      NYM = 1
      M = 144
      IYM = 1
      X(1) = 10.0D0
      GO TO 40
!
  160 CALL SETRV(Y, 144, 1.0D0)
      CALL SETRV(X, 144, 1.0D0)
      NYM = 6
      IYM = 12
      M = 6
      NY = 36
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      GO TO 30
!
!     TEST ERROR RESPONSE
!
  170 NY = 0
      NYM = 0
      M = 0
      IYM = -1
      GO TO 10
!
  180 NY = 144
      NYM = 12
      M = 12
      IYM = -1
      XLB = -1.0D0
      YLB = -1.0D0
      GO TO 40
!
  190 IYM = 12
      X(1) = 0.0D0
      Y(1) = 0.0D0
      GO TO 50
!
  200 CALL SETRV(X, 144, XMISS)
      CALL SETRV(Y, 144, YMISS)
      XLB = XUB
      YLB = YUB
      GO TO 50
!
  300 CONTINUE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT ('1', 10HTEST OF PP)
 1010 FORMAT ('1', 11HTEST OF PPL)
 1020 FORMAT ('1', 11HTEST OF PPC)
 1030 FORMAT ('1', 11HTEST OF PPM)
 1040 FORMAT ('1', 12HTEST OF PPML)
 1050 FORMAT ('1', 12HTEST OF PPMC)
 1060 FORMAT ('1', 11HTEST OF MPP)
 1070 FORMAT ('1', 12HTEST OF MPPL)
 1080 FORMAT ('1', 12HTEST OF MPPC)
 1090 FORMAT ('1', 12HTEST OF MPPM)
 1100 FORMAT ('1', 13HTEST OF MPPML)
 1110 FORMAT ('1', 13HTEST OF MPPMC)
 1120 FORMAT ('1', 11HTEST OF SPP)
 1130 FORMAT ('1', 12HTEST OF SPPL)
 1140 FORMAT ('1', 12HTEST OF SPPC)
 1150 FORMAT ('1', 12HTEST OF SPPM)
 1160 FORMAT ('1', 13HTEST OF SPPML)
 1170 FORMAT ('1', 13HTEST OF SPPMC)
 3000 FORMAT (/8H IERR = , I4)
 3010 FORMAT (' ', 5X, 10H   N     =, I5)
 3020 FORMAT ('+', 20X, 10H / M     =, I5, 10H / IYM   =, I5)
 3040 FORMAT ('+', 65X, 10H / ILOG  =, I5)
 3050 FORMAT (' ',  5X, 10H   ISIZE =, I5, 10H / NOUT  =, I5)
 3070 FORMAT ('+', 50X, 10H / YLB   =, F10.4, 10H / YUB   =, F10.4,
     +   10H / XLB   =, F10.4)
 3080 FORMAT ('+', 110X, 10H / XUB   =, F10.4)
 3100 FORMAT (' ', 13H TEST NUMBER , I5)
      END
!NLSWDC
      SUBROUTINE NLSWDC(Y, WT, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING ANALYTIC DERIVATIVES, WEIGHTS, AND
!     USER SUPPLIED CONTROL PARAMETERS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IVAPRX,IXM,LDSTAK,M,MIT,N,NPAR,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),SCALE(*),WT(*),XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LWT,NNZW,NPARE
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SDPV(1),SDRES(1),VCV(1,1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTA
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
!        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF IFIXED(I).EQ
!        THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(NPAR)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE-COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(N)
!        THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','W','D','C'/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      WEIGHT = .TRUE.
      SAVE = .FALSE.
!
      LIFIXD = NPAR
      LPV = 1
      LSCALE = NPAR
      LSDPV = 1
      LSDRES = 1
      LWT = N
      IVCV = 1
!
      CALL NLCNTA(Y, WT, LWT, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, IDRVCK, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSWDC (Y, WT, XM, N, M, IXM, NLSMDL, NLSDRV,'/
     +   '      +             PAR, NPAR, RES, LDSTAK,'/
     +   '      +             IFIXED, IDRVCK, MIT, STOPSS, STOPP,'/
     +   '      +             SCALE, DELTA, IVAPRX, NPRT)')
      END
!SPCCK
      SUBROUTINE SPCCK (SPC, ISORT, NF, SPCMN, SPCMX, NSPC, ISPCER)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE ANALYZES THE ORDINATES FOR THE SPECTRAL SEMI LOG
!     PLOTS PRODUCED BY THE ASPC SERIES OF ROUTINES.  Y AXIS VALUES
!     (YORD) MORE THAN 3 POWERS OF TEN LESS THAN THE NEXT LARGER
!     VALUE ARE CONSIDERED INSIGNIFICANT AND ARE CULLED FROM THE
!     ORDINATES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SPCMN,SPCMX
      INTEGER
     +   ISPCER,NF,NSPC
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   SPC(NF)
      INTEGER
     +   ISORT(NF)
!
!  LOCAL SCALARS
      INTEGER
     +   I,K1,K2,LOG1,LOG2
!
!  EXTERNAL SUBROUTINES
      EXTERNAL SRTIR,SRTRI
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG10
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER ISORT(NF)
!        THE ARRAY IN WHICH THE ORDER PERMUTATION FOR THE SORTED
!        DATA IS STORED.
!     INTEGER ISPCER
!        AN INDICATOR VARIABLE USED TO SUPRESS THE SPECTRAL PLOTS
!        WHEN FEWER THAN 1 VALID SPECTRAL VALUES WERE COMPUTED.
!     INTEGER K1, K2
!        INDEX VARIABLES.
!     INTEGER LOG1, LOG2
!        THE ORDER OF THE SPECTRAL ESTIMATES.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
!        ARE TO BE ESTIMATED.
!     INTEGER NSPC
!        THE NUMBER OF VALID SPECTRAL ESTIMATES.
!     DOUBLE PRECISION SPC(NF)
!        THE ARRAY CONTAINING THE SPECTRAL ESTIMATES.
!     DOUBLE PRECISION SPCMN, SPCMX
!        THE MINIMUM AND MAXIMUM SPECTRAL VALUE TO BE PLOTTED.
!
!     ORDER THE SPECTRAL ESTIMATES FROM SMALLEST TO LARGEST.
!
      DO 10 I = 1, NF
         ISORT(I) = I
   10 CONTINUE
      CALL SRTIR (ISORT, NF, SPC)
!
!     DETERMINE SIGINIFICANT VALUES TO BE PLOTTED.
!
      K1 = NF
      K2 = K1
      IF ((SPC(NF) .LE. 0.0D0) .OR. (NF.EQ.1)) GO TO 30
      LOG1 = LOG10(SPC(NF))
      IF (SPC(NF) .LT. 1.0D0) LOG1 = LOG1 - 1
      DO 20 I = 2, NF
         K2 = K1 - 1
         IF (SPC(K2) .LE. 0.0D0) GO TO 30
         LOG2 = LOG10(SPC(K2))
         IF (SPC(K2) .LT. 1.0D0) LOG2 = LOG2 - 1
         IF (LOG1-LOG2 .GE. 3 .AND. NF-K2 .GE. 5) GO TO 30
         LOG1 = LOG2
         K1 = K2
   20 CONTINUE
!
   30 SPCMN = SPC(K1)
      NSPC = NF + 1 - K1
!
      SPCMX = SPC(NF)
!
      CALL SRTRI (SPC, NF, ISORT)
      ISPCER = 0
      IF (NF-K2 .LE. 0) ISPCER = 1
!
      RETURN
      END
!IPGMS
      SUBROUTINE IPGMS (YFFT, N, LYFFT, LDSTAK, NF, PERI, LPERI, FREQ,
     +   LFREQ, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
!     THE INTEGRATED PERIODOGRAM OF A SERIES (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,LFREQ,LPERI,LYFFT,N,NF,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),PERI(*),YFFT(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IEXTND,IPRT,ISYM,LDSMIN,LPCV,NALL0,NFFT,XAXIS,YAXIS
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,HEAD
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   LLDS(8)*1,LLFREQ(8)*1,LLPERI(8)*1,LLYFFT(8)*1,LN(8)*1,
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CNTR,EISGE,IPGDV,IPRINT,LDSCMP,PGMMN,SETESL,STKCLR,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION FREQ(LFREQ)
!        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
!        INTEGRATED SPECTRUM VALUES ARE STORED.
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IEXTND
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
!        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
!        USED TO EXTEND THE SERIES.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LFREQ
!        THE LENGTH OF THE VECTOR FREQ.
!     CHARACTER*1 LLDS(8), LLFREQ(8), LLPERI(8), LLYFFT(8), LN(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LPERI
!        THE LENGTH OF THE VECTOR PERI.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING ALLOCATIONS OF THE STACK AT THE
!        TIME OF THIS CALL.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A PAGE PLOT.
!     DOUBLE PRECISION PERI(LPERI)
!        THE VECTOR IN WHICH THE INTEGRATED PERIODOGRAM IS STORED.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE X AXIS VALUES TO BE PLOTTED ARE STORED.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
!     DOUBLE PRECISION YFFT(LYFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'I',       'P',       'G',       'M',       'S',       ' '/
      DATA
     + LLFREQ(1), LLFREQ(2), LLFREQ(3), LLFREQ(4), LLFREQ(5),
     +  LLFREQ(6), LLFREQ(7), LLFREQ(8)
     +  /'L','F','R','E','Q',' ',' ',' '/
      DATA
     + LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     +  LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA
     + LLPERI(1), LLPERI(2), LLPERI(3), LLPERI(4), LLPERI(5),
     +  LLPERI(6), LLPERI(7), LLPERI(8)
     +  /'L','P','E','R','I',' ',' ',' '/
      DATA
     + LLYFFT(1), LLYFFT(2), LLYFFT(3), LLYFFT(4), LLYFFT(5),
     +  LLYFFT(6), LLYFFT(7), LLYFFT(8)
     +  /'L','Y','F','F','T',' ',' ',' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /'N',' ',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
      IF (ERR01) GO TO 5
!
!     SET LENGTH OF EXTENDED SERIES
!
      CALL SETESL(N, 2, NFFT)
      NF = NFFT/2
!
      CALL EISGE(NMSUB, LLYFFT, LYFFT, NFFT, 9, HEAD, ERR02, LLYFFT)
!
      CALL EISGE(NMSUB, LLPERI, LPERI, NF, 9, HEAD, ERR03, LLPERI)
!
      CALL EISGE(NMSUB, LLFREQ, LFREQ, NF, 9, HEAD, ERR04, LLFREQ)
!
      IF (NPRT .EQ. 0) THEN
        LDSMIN = 0
      ELSE
        CALL LDSCMP(3, 0, NF+103, 0, 0, 0, 'D', 2*NFFT+206, LDSMIN)
      END IF
!
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR05, LLDS)
!
      IF (ERR02 .OR. ERR03 .OR. ERR04 .OR. ERR05) GO TO 5
      GO TO 10
!
    5 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   10 CONTINUE
!
!     SET THE SIZE OF THE WORK AREA
!
      CALL STKSET(LDSTAK, 4)
!
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!
      NALL0 = STKST(1)
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      LPCV = NF + 103
!
!     CENTER THE SERIES
!
      CALL CNTR(YFFT, N, YFFT)
      IEXTND = 0
!
!     SUBDIVIDE THE STACK.
!
      IF (NPRT .EQ. 0) THEN
         ISYM = 1
         XAXIS = 1
         YAXIS = 1
      ELSE
         ISYM = STKGET(LPCV, 2)
         XAXIS = STKGET(LPCV, 4)
         YAXIS = STKGET(LPCV, 4)
      END IF
!
!     COMPUTE THE RAW PERIODOGRAM.
!
      CALL PGMMN (YFFT, N, NFFT, IEXTND, NF, PERI, LPERI, RSTAK(YAXIS),
     +   FREQ, LFREQ, 0, NMSUB)
!
!     CALL THE MAIN DRIVER FOR COMPUTING (AND PLOTTING) THE INTEGRATED
!     PERIODOGRAM.
!
      CALL IPGDV (PERI, NF, N, PERI, FREQ, RSTAK(XAXIS),
     +   RSTAK(YAXIS), ISTAK(ISYM), LPCV, NPRT)
!
      CALL STKCLR(NALL0)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL IPGMS (YFFT, N, LYFFT, LDSTAK,'/
     +  '      +            NF, PERI, LPERI, FREQ, LFREQ, NPRT)')
      END
!ACVFF
      SUBROUTINE ACVFF (YFFT, N, NFFT, YMEAN, ACOV, LAGMAX, LACOV,
     +   LYFFT, WORK, LWORK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE ACVF OF A SERIES USING TWO
!     PASSES OF A FFT.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMEAN
      INTEGER
     +   LACOV,LAGMAX,LWORK,LYFFT,N,NFFT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),WORK(*),YFFT(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FAC
      INTEGER
     +   I,ISN,N1,NF,NFFT2
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN,FFT,FFTCT,REALTR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV)
!        THE ARRAY IN WHICH THE AUTOCOVARIANCES ARE STORED
!     DOUBLE PRECISION FAC
!        A FACTOR USED IN THE COMPUTATIONS.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER ISN
!        AN INDICATOR VARIABLE USED BY THE FFT ROUTINES.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG TO BE USED.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NF
!        THE NUMBER OF FOURIER FREQUENCIES.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NFFT2
!        THE EFFECTIVE NUMBER OF OBSERVATIONS FOR THE FFT TRANSFORM.
!     INTEGER N1
!        THE VALUE N + 1.
!     DOUBLE PRECISION WORK(LWORK)
!        THE WORK AREA FOR THE COMPUTATIONS.
!     DOUBLE PRECISION YFFT(LYFFT)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!     COMPUTE ARITHMETIC MEAN
!
      CALL AMEAN(YFFT, N, YMEAN)
!
!     SUBTRACT THE MEAN FROM THE SERIES
!
      DO 10 I = 1, N
         YFFT(I) = YFFT(I) - YMEAN
   10 CONTINUE
!
!     APPEND ZEROS
!
      N1 = N + 1
!
      DO 20 I = N1, NFFT
         YFFT(I) = 0.0D0
   20 CONTINUE
!
!     COMPUTE AUTOCOVARIANCES.
!
      ISN = 2
      NFFT2 = (NFFT - 2)/ 2
!
      CALL FFT(YFFT(1), YFFT(2), NFFT2, NFFT2, NFFT2, ISN)
      CALL REALTR (YFFT(1), YFFT(2), NFFT2, ISN)
!
      NF = NFFT2 + 1
!
      DO 30 I = 1, NF
         WORK(I) = YFFT(2*I-1)*YFFT(2*I-1) + YFFT(2*I)*YFFT(2*I)
   30 CONTINUE
!
      CALL FFTCT (WORK, NFFT2, LWORK)
!
      FAC = 1.0D0 / (4 * (NFFT - 2) * N)
!
      ACOV(1) = WORK(1) * FAC
!
      DO 40 I = 1, LAGMAX
         ACOV(I+1) = WORK(I+1) * FAC
   40 CONTINUE
!
      RETURN
      END
!UASFS
      SUBROUTINE UASFS (YFFT, N, LYFFT, LDSTAK, IAR, PHI, LAGMAX, LAG,
     +  NF, FMIN, FMAX, NPRT, SPCA, SPCF, FREQ)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
!     SPECTRUM ESTIMATION USING THE FFT (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   IAR,LAG,LAGMAX,LDSTAK,LYFFT,N,NF,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),PHI(*),SPCA(*),SPCF(*),YFFT(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMN,FMX,VAR,YMEAN
      INTEGER
     +   ACOV,AIC,FTEST,IA,IFP,IO,IPRT,ISORT,ISYM,LACOV,LAIC,
     +   LDSMIN,LPCV,LPHI,LSPC,LWORK,NALL0,NFFT,WORK,XAXIS,YAXIS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACVFF,AMEAN,IPRINT,LDSCMP,PARZEN,SETESL,STKCLR,STKSET,
     +   UASDV,UASER,UASVAR
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER ACOV
!        THE STARTING LOCATION IN RSTAK FOR THE ARRAY OF
!        THE AUTOCOVARIANCE ARRAY.
!     INTEGER AIC
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY CONTAINING THE AIC.
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
!        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
!     DOUBLE PRECISION FMN, FMX
!        THE MAXIMUM AND MINIMUM FREQUENCY ACTUALLY USED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     INTEGER FTEST
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IA
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON WHETHER OR NOT THE MODEL ORDER IS TO BE SELECTED OR
!        HAS BEEN PROVIDED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION IN ISTAK FOR
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN ISTAK FOR
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE COVARIANCE ARRAYS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE ARRAY AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER LSPC
!         THE LENGTH OF THE SPECTRUM ARRAYS.
!     INTEGER LWORK
!        THE ACTUAL LENGTH OF THE WORK ARRAY.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS OUTSTANDING WHEN THIS ROUTINE
!        WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
!        ARE TO BE ESTIMATED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE TYPE OF WINDOW TO BE USED.
!     DOUBLE PRECISION PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION SPCA(NF)
!        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!     DOUBLE PRECISION SPCF(NF)
!        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
!     DOUBLE PRECISION VAR
!        THE ONE STEP PREDICTION VARIANCE.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE STACK FOR
!        THE WORK ARRAY.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN RSTAK FOR
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN RSTAK FOR
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YFFT(LYFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'U',       'A',       'S',       'F',       'S',       ' '/
!
      IFP = 4
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(1) = .TRUE.
      OPTION(2) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(4) = .TRUE.
!
!     SET EXTENDED SERIES LENGTH
!
      CALL SETESL(N+LAGMAX, 4, NFFT)
!
      IO = 1
      IF (NPRT .EQ. 0) IO = 0
      IA = 1
      IF (IAR .NE. 0) IA = 0
!
      CALL LDSCMP(7, 0, IO*(2*NF+5), 0, 0, 0, 'D',
     +   LAGMAX+1+NFFT+IA*(3*LAGMAX+1)+IO*(4*NF+10), LDSMIN)
!
      CALL UASER(NMSUB, N, YFFT, IAR, PHI, LAGMAX, LAG, LACOV,
     +   NF, LDSTAK, LDSMIN, LYFFT, NFFT, OPTION)
!
    5 IF (IERR.NE.0) THEN
         IERR = 1
         CALL IPRINT (IPRT)
         WRITE (IPRT, 1000)
         RETURN
      END IF
!
!     SET SIZE OF WORK AREA.
!
      CALL STKSET (LDSTAK, 4)
!
!     SAVE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
!
      NALL0 = STKST(1)
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      LSPC = NF
      LPCV = 2*NF + 5
      LPHI = LAGMAX
      LACOV = LAGMAX + 1
      LWORK = NFFT
!
      FMN = MAX(FMIN, 0.0D0)
      FMX = MIN(FMAX, 0.5D0)
      IF (FMN.GE.FMX) THEN
        FMN = 0.0D0
        FMX = 0.5D0
      END IF
!
      ALPHA = 0.95D0
      DELTA = 1.0D0
!
      IF (IAR.GE.1) THEN
!
!     USER HAS CHOSEN ORDER AND SUPPLIED COEFFICIENTS.
!     COMPUTE RESIDUAL VARIANCE.
!
         CALL AMEAN(YFFT, N, YMEAN)
         CALL UASVAR (YFFT, YMEAN, N, IAR, PHI, VAR)
      END IF
!
!     COMPUTE AUTOCOVARIANCES
!
      ACOV = STKGET(LACOV, IFP)
      WORK = STKGET(LWORK, IFP)
!
      CALL ACVFF (YFFT, N, NFFT, YMEAN, RSTAK(ACOV), LAGMAX, LAGMAX+1,
     +   LYFFT, RSTAK(WORK), NFFT)
!
!     SET UP ADDITIONAL STACK WORK AREA, IF NEEDED.
!
      IF (IAR.EQ.0) THEN
         LAIC = LAGMAX+1
         AIC = STKGET(LAIC, IFP)
         FTEST = STKGET(2*LAGMAX, IFP)
      ELSE
         LAIC = LWORK
         AIC = WORK
         FTEST = WORK
      END IF
      IF (NPRT.NE.0) THEN
         XAXIS = STKGET(LPCV, IFP)
         YAXIS = STKGET(LPCV, IFP)
         ISYM = STKGET(LPCV, 2)
         ISORT = ISYM
      ELSE
         XAXIS = WORK
         YAXIS = WORK
         ISYM = WORK
         ISORT = WORK
      END IF
!
      IF (IERR.EQ.1) GO TO 5
!
!     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
!
      CALL UASDV(RSTAK(ACOV), SPCA, SPCF, LSPC, IAR, PHI, NF, FMN,
     +   FMX, FREQ, N, LAGMAX, RSTAK(FTEST), RSTAK(AIC), RSTAK(WORK),
     +   LACOV, LWORK, DELTA, ISTAK(ISORT), ISTAK(ISYM), RSTAK(XAXIS),
     +   RSTAK(YAXIS), LPCV, ALPHA, LAG, LAIC, LPHI, NPRT, VAR, PARZEN,
     +   NMSUB)
!
      CALL STKCLR(NALL0)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL UASFS (YFFT, N, LYFFT, LDSTAK,'/
     + '      +            IAR, PHI, LAGMAX, LAG, NF, FMIN, FMAX, NPRT'/
     + '      +            SPCA, SPCF, FREQ)')
      END
!ACVF
      SUBROUTINE ACVF (Y, N, YMEAN, ACOV, LAGMAX, LACOV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE AUTOCOVARIANCE FUNCTION OF A SERIES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMEAN
      INTEGER
     +   LACOV,LAGMAX,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),Y(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DOTXY,DOTYY
      INTEGER
     +   LAG,NDOTXY,NDOTYY
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN,DOTC
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV)
!        THE ARRAY IN WHICH THE AUTOCOVARIANCES ARE STORED
!     DOUBLE PRECISION DOTXY, DOTYY
!        THE DOT PRODUCT BETWEEN VECTORS (Y(I) - YMEAN)) AND
!        (Y(LAG) - YMEAN)), AND (Y(I) - YMEAN)) AND (Y(I) - YMEAN)),
!        RESPECTIVELY.
!     INTEGER LACOV
!        THE ACTUAL DIMENSION OF ACOV.
!     INTEGER LAG, LAGMAX
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCOVARIANCE BEING COMPUTED AND THE MAXIMUM LAG TO BE USED,
!        RESPECTIVELY.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NDOTXY, NDOTYY
!        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY AND
!        DOTYY, RESPECTIVELY.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!     COMPUTE ARITHMETIC MEAN
!
      CALL AMEAN(Y, N, YMEAN)
!
!     COMPUTE THE VARIANCE OF THE SERIES Y
!
      CALL DOTC (Y, YMEAN, N, Y, YMEAN, N, DOTYY, NDOTYY)
      ACOV(1) = DOTYY / NDOTYY
!
!     COMPUTE AUTOCOVARIANCES.
!
      DO 10 LAG = 1, LAGMAX
         CALL DOTC (Y, YMEAN, N, Y(LAG+1), YMEAN, N - LAG,
     +       DOTXY, NDOTXY)
         ACOV(LAG + 1) = DOTXY / N
   10 CONTINUE
!
      RETURN
      END
!NLISM
      SUBROUTINE NLISM (NLHDR, PAGE, WIDE, HLFRPT, NPAR, M, N, NNZW,
     +   WEIGHT, IFIXD, PAR, SCALE, IWORK, IIWORK, RWORK, IRWORK, RES,
     +   APRXDV, STP, LSTP, NPARE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS AN INITIAL SUMMARY OF THE STARTING
!     ESTIMATES AND THE CONTROL PARAMETERS FOR THE NONLINEAR
!     LEAST SQUARES SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IIWORK,IRWORK,LSTP,M,N,NNZW,NPAR,NPARE
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,WEIGHT,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),RES(N),RWORK(IRWORK),SCALE(NPAR),STP(LSTP)
      INTEGER
     +   IFIXD(NPAR),IWORK(IIWORK)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL NLHDR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD,RSS
      INTEGER
     +   I,IPRT,ISUBHD,LMAX0,MXFCAL,MXITER,RFCTOL,XCTOL
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   DNRM2
      EXTERNAL DNRM2
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC DBLE,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IIWORK
!        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IRWORK
!        THE DIMENSION OF THE DOUBLE PRECISION WORK VECTOR RWORK.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IWORK(IIWORK)
!        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER LMAX0
!        THE LOCATION IN RWORK OF THE VALUE INDICATING THE
!        MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MXFCAL
!        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
!        MAXIMUM NUMBER OF FUNCTION CALLS ALLOWED, EXCLUDING
!        CALLS NECESSARY TO COMPUTE THE DERIVATIVES AND COVARIANCE
!        MATRIX.
!     INTEGER MXITER
!        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
!        MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     EXTERNAL NLHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        NUMBER OF PARAMETERS ESTIMATED BY ROUTINE.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     INTEGER RFCTOL
!        THE LOCATION IN RWORK OF THE RELATIVE FUNCTION CONVERGENCE
!        TOLERANCE.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION AT THE INITIAL PARAMETER VALUES
!     DOUBLE PRECISION RSS
!        THE RESIDUAL SUM OF SQUARES AT THE INITIAL PARAMETER VALUES
!     DOUBLE PRECISION RWORK(IRWORK)
!        THE DOUBLE PRECISION WORK VECTOR USED BY THE NL2 SUBROUTINES.
!     DOUBLE PRECISION SCALE(NPAR)
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     DOUBLE PRECISION STP(LSTP)
!        THE SELECTED RELATIVE STEP SIZES.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!       THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        FULL WIDTH (TRUE) OR NOT (FALSE).
!     INTEGER XCTOL
!        THE LOCATION IN RSTAK/DSTAK OF THE P CONVERGENCE TOLERANCE.
!
!     IWORK SUBSCRIPT VALUES
!
      DATA MXFCAL/17/, MXITER/18/
!
!     RWORK SUBSCRIPT VALUES
!
      DATA LMAX0/35/, RFCTOL/32/, XCTOL/33/
!
      CALL IPRINT(IPRT)
!
      IF (.NOT.HLFRPT) THEN
!
         ISUBHD = 1
         CALL NLHDR(PAGE, WIDE, ISUBHD)
!
         IF (APRXDV) THEN
            WRITE (IPRT, 1260)
         ELSE
            WRITE (IPRT, 1270)
         END IF
!
         DO 40 I = 1, NPAR
            IF (IFIXD(I).EQ.0) THEN
               IF (SCALE(1).GT.0.0D0) THEN
                  IF (APRXDV) THEN
                     WRITE (IPRT, 1410) I, PAR(I), SCALE(I), STP(I)
                  ELSE
                     WRITE (IPRT, 1410) I, PAR(I), SCALE(I)
                  END IF
               ELSE
                  IF (APRXDV) THEN
                     WRITE (IPRT, 1310) I, PAR(I), STP(I)
                  ELSE
                     WRITE (IPRT, 1310) I, PAR(I)
                  END IF
               END IF
            ELSE
               IF (APRXDV) THEN
                  WRITE (IPRT, 1510) I, PAR(I)
               ELSE
                  WRITE (IPRT, 1610) I, PAR(I)
               END IF
            END IF
   40    CONTINUE
!
         WRITE (IPRT, 1160) N
!
      END IF
!
      IF (WEIGHT) WRITE (IPRT, 1170) NNZW
      WRITE (IPRT, 1180) M
      WRITE(IPRT, 1070) IWORK(MXITER)
      WRITE(IPRT, 1090) IWORK(MXFCAL)
      WRITE(IPRT, 1080)
      WRITE(IPRT, 1100) RWORK(RFCTOL)
      WRITE(IPRT, 1110) RWORK(XCTOL)
      WRITE(IPRT, 1120) RWORK(LMAX0)
!
      RSD = DNRM2(N, RES, 1)
      RSS = RSD * RSD
      IF (NNZW-NPARE.GE.1) RSD = RSD /SQRT(DBLE(NNZW-NPARE))
      WRITE (IPRT, 1200) RSS
      WRITE (IPRT, 1210) RSD
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1070 FORMAT (/37H MAXIMUM NUMBER OF ITERATIONS ALLOWED, 32X, 5H(MIT),
     +   1X, I5)
 1080 FORMAT(/44H CONVERGENCE CRITERION FOR TEST BASED ON THE/)
 1090 FORMAT(/41H MAXIMUM NUMBER OF MODEL SUBROUTINE CALLS,
     +   8H ALLOWED, 26X, I5)
 1100 FORMAT (5X, 39H FORECASTED RELATIVE CHANGE IN RESIDUAL,
     +   15H SUM OF SQUARES, 7X, 8H(STOPSS), 1X, G11.4)
 1110 FORMAT(5X, 49H MAXIMUM SCALED RELATIVE CHANGE IN THE PARAMETERS,
     +   13X, 7H(STOPP), 1X, G11.4)
 1120 FORMAT(//41H MAXIMUM CHANGE ALLOWED IN THE PARAMETERS,
     +   23H AT THE FIRST ITERATION, 3X, 7H(DELTA), 1X, G11.4)
 1160 FORMAT (/23H NUMBER OF OBSERVATIONS, 48X, 3H(N), 1X, I5)
 1170 FORMAT (/41H NUMBER OF NON ZERO WEIGHTED OBSERVATIONS, 27X,
     +   6H(NNZW), 1X, I5)
 1180 FORMAT (/32H NUMBER OF INDEPENDENT VARIABLES, 39X, 3H(M), 1X, I5)
 1200 FORMAT (/44H RESIDUAL SUM OF SQUARES FOR INPUT PARAMETER,
     +   7H VALUES, 24X, G11.4)
 1210 FORMAT (/48H RESIDUAL STANDARD DEVIATION FOR INPUT PARAMETER,
     +   7H VALUES, 14X, 5H(RSD), 1X, G11.4)
 1260 FORMAT (//50X, 13HSTEP SIZE FOR/
     +   50X, 13HAPPROXIMATING/
     +   7X, 24HPARAMETER STARTING VALUE, 6X, 5HSCALE, 10X,
     +   10HDERIVATIVE/
     +   1X, 5HINDEX, 2X, 5HFIXED, 6X, 5H(PAR), 12X, 7H(SCALE), 11X,
     +   5H(STP)/)
 1270 FORMAT (//6X, 25HPARAMETER STARTING VALUES, 5X, 5HSCALE/
     +   1X, 5HINDEX, 2X, 5HFIXED, 6X, 5H(PAR), 11X, 7H(SCALE)/)
 1310 FORMAT (1X, I3, 5X, ' NO', G17.8, 7X, 7HDEFAULT, 3X, G17.8)
 1410 FORMAT (1X, I3, 5X, ' NO', 3G17.8)
 1510 FORMAT (1X, I3, 5X, 'YES', G17.8, 9X, '---', 14X, '---')
 1610 FORMAT (1X, I3, 5X, 'YES', G17.8, 9X, '---')
      END
!NLSW
      SUBROUTINE NLSW(Y, WT, XM, N, M, IXM, MDL, PAR, NPAR, RES, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
!     AND WEIGHTS (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),WT(*),XM(*),Y(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IPRT,IVAPRX,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,LWT,
     +   MIT,NNZW,NPARE,NPRT
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SCALE(1),SDPV(1),SDRES(1),STP(1),VCV(1,1)
      INTEGER
     +   IFIXED(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTN
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(1)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(1)
!        THE STEP SIZE ARRAY.
!     DOUBLE PRECISION VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(N)
!        THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','W',' ',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      WEIGHT = .TRUE.
      SAVE = .FALSE.
!
      STP(1) = -1.0D0
      MIT = -1
      STOPSS = -1.0D0
      STOPP = -1.0D0
      SCALE(1) = -1.0D0
      DELTA = -1.0D0
      NPRT = -1
      IFIXED(1) = -1
      IVAPRX = 0
      LIFIXD = 1
      LPV = 1
      LSTP = 1
      LSCALE = 1
      LSDPV = 1
      LSDRES = 1
      LWT = N
      IVCV = 1
!
      CALL NLCNTN(Y, WT, LWT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSW (Y, WT, XM, N, M, IXM, NLSMDL,'/
     +   '      +           PAR, NPAR, RES, LDSTAK)')
      END
!PP
      SUBROUTINE PP(YM, X, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT (SHORT CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   ILOG,IPRT,ISCHCK,ISIZE,IYM,LISYM,M,NOUT
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'P',       'P',       ' ',       ' ',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      YMMISS(1) = 1.0D0
      XMISS = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 0
      ISIZE = -1
      NOUT = 0
      MISS = .FALSE.
      LISYM = 1
!
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL PP (Y, X, N)')
      END
!FFTR
      SUBROUTINE FFTR (YFFT, N, NFFT, IEXTND, NF, AB, LAB)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
!     THE FOURIER TRANSFORM OF A SERIES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IEXTND,LAB,N,NF,NFFT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AB(*),YFFT(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   YEXTND
      INTEGER
     +   I,IPRT,ISN,N1,NFFT1,NFFT2
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD
!
!  LOCAL ARRAYS
      CHARACTER
     +   LLAB(8)*1,LN(8)*1,NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN,EISGE,ENFFT,FFT,IPRINT,REALTR
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AB(LAB)
!        THE VECTOR OF THE NF REAL AND IMAGINARY COMPONENTS OF THE
!        FOURIER COEFFICIENTS.
!     LOGICAL ERR01, ERR02, ERR03
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IEXTND
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
!        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
!        USED TO EXTEND THE SERIES.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER LAB
!        THE LENGTH OF THE VECTOR AB.
!     CHARACTER*1 LLAB(8), LN(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS.
!     INTEGER N1
!        THE VALUE N+1.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
!     INTEGER NFFT1
!        THE EFFECTIVE SERIES LENGTH ACTUALLY USED.
!     INTEGER NFFT2
!        THE EFFECTIVE LENGTH OF THE SERIES STORED AS A COMPLEX
!        VARIABLE.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     DOUBLE PRECISION YEXTND
!        THE VALUE USED TO EXTEND THE SERIES.
!     DOUBLE PRECISION YFFT(N)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'F',       'F',       'T',       'R',       ' ',       ' '/
      DATA
     +   LLAB(1),   LLAB(2),   LLAB(3),   LLAB(4),   LLAB(5),   LLAB(6)
     + /     'L',       'A',       'B',       ' ',       ' ',       ' '/
      DATA
     +   LLAB(7),   LLAB(8)
     + /     ' ',       ' '/
      DATA
     +     LN(1),     LN(2),     LN(3),     LN(4),     LN(5),     LN(6)
     + /     'N',       ' ',       ' ',       ' ',       ' ',       ' '/
      DATA
     +     LN(7),     LN(8)
     + /     ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
      IF (ERR01) GO TO 5
!
      CALL ENFFT(NMSUB, NFFT, 2, N, LAB, NFFT1, HEAD, ERR02, LN)
      NF = NFFT1/2
!
      CALL EISGE(NMSUB, LLAB, LAB, NFFT1, 9, HEAD, ERR03, LLAB)
!
      IF (ERR02 .OR. ERR03) GO TO 5
      GO TO 10
!
    5 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   10 CONTINUE
!
!     COPY THE INPUT SERIES TO AB, EXTENDING APPROPRIATELY.
!
      YEXTND = 0.0D0
      IF (IEXTND .NE. 0) CALL AMEAN (YFFT, N, YEXTND)
!
      DO 20 I = 1, N
         AB(I) = YFFT(I)
   20 CONTINUE
!
      N1 = N+1
      DO 30 I = N1, NFFT1
         AB(I) = YEXTND
   30 CONTINUE
!
      NFFT2 = (NFFT1-2) / 2
      ISN = 2
!
      CALL FFT (AB(1), AB(2), NFFT2, NFFT2, NFFT2, ISN)
      CALL REALTR (AB(1), AB(2), NFFT2, ISN)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   53H       CALL FFTR (YFFT, N, NFFT, IEXTND, NF, AB, LAB))
      END
!BFSMVS
      SUBROUTINE BFSMVS(CCOV, NLPPC, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   INLPPC, JNLPPC, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
!     FOURIER SPECTRUM ANALYSIS OF SERIES WITH MISSING OBSERVATIONS
!     WITH USER INPUT OF THE COVARIANCES RATHER THAN THE SERIES
!     (LONG CALL)
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   ICCOV,ICSPC2,INDEX1,INDEX2,INLPPC,IPHAS,JCCOV,JNLPPC,
     +   LDSTAK,N,NF,NPRT,NW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(*),CSPC2(*),FREQ(*),PHAS(*)
      INTEGER
     +   LAGS(*),NLPPC(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,YMISS1,YMISS2
      INTEGER
     +   CEVEN,CODD,I,IFP,IO,IPRT,ISYM,LAGMAX,LAGMX1,LDSMIN,LPCV,
     +   LW,LWORK,LY,M,NALL0,SPCF1,SPCF2,W,WORK,XAXIS,YAXIS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12),Y1(1),Y2(1)
      INTEGER
     +   ISTAK(12)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,ECVF,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION CCOV(ICCOV,JCCOV,*)
!        THE COVARIANCES.
!     INTEGER CEVEN
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     INTEGER CODD
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CSPC2(ICSPC2,NW)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC(INLPPC,JNLPPC,*)
!        THE NUMBER OF OBSERVATIONS IN EACH COVARIANCE ESTIMATE
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION PHAS(IPHAS,NW)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SPCF1, SPCF2
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     INTEGER W
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE WINDOWS.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR THE VECTOR WORK.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YMISS1, YMISS2
!        DUMMY VARIABLES.
!     DOUBLE PRECISION Y1(1)
!        THE FIRST TIME SERIES.
!     DOUBLE PRECISION Y2(1)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','M','V','S'/
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(1) = .FALSE.
      OPTION(2) = .TRUE.
      OPTION(3) = .TRUE.
      OPTION(4) = .TRUE.
!
!     SET MAXIMUM LAG VALUE TO BE USED (LAGMAX).
!
      LAGMAX = N - 1
      IF (NW.LE.0) GO TO 20
      LAGMAX = LAGS(1)
      DO 10 I=1,NW
         LAGMAX = MAX(LAGMAX,LAGS(I))
   10 CONTINUE
   20 CONTINUE
      LAGMX1 = LAGMAX + 1
!
      M = 2
!
!     COMPUTE THE MINIMUM ALLOWABLE STACK AREA (LDSMIN)
!
      IO = 1
      IF (NPRT.EQ.0) IO = 0
!
      CALL LDSCMP(8, 0, IO*4*NF, 0, 0, 0, 'D',
     +  7*LAGMAX+7+2*NF+IO*8*NF, LDSMIN)
!
      LY = N
      LPCV = 4*NF
      LW = LAGMAX + 1
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING STACK ALLOCATIONS (NALL0).
!     SET THE STACK ALLOCATION TYPE (IFP)
!
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
!
      IFP = 4
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS
!
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         CEVEN = 1
         CODD = 1
         SPCF1 = 1
         SPCF2 = 1
         W = 1
!
         ISYM = 1
         XAXIS = 1
         YAXIS = 1
      ELSE
         CEVEN = STKGET(LAGMX1,IFP)
         CODD = STKGET(LAGMX1,IFP)
         SPCF1 = STKGET(NF,IFP)
         SPCF2 = STKGET(NF,IFP)
         W = STKGET(LW,IFP)
         IF (NPRT.EQ.0) THEN
            ISYM = W
            XAXIS = W
            YAXIS = W
         ELSE
            ISYM = STKGET(LPCV,2)
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
         END IF
      END IF
!
      WORK = W
      LWORK = LW
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
      CALL BFSDRV(Y1, Y2, YMISS1, YMISS2, CCOV, NLPPC,
     +   RSTAK(SPCF1), RSTAK(SPCF2), NF, FMIN, FMAX, FREQ, N, NW,
     +   LAGMAX, LAGS, LAGMX1, RSTAK(WORK), LWORK, DELTA, ISTAK(ISYM),
     +   RSTAK(XAXIS), RSTAK(YAXIS), LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS,
     +   RSTAK(CODD), RSTAK(CEVEN), RSTAK(W), LW, NMSUB, LDSMIN,
     +   LDSTAK, OPTION, N, INLPPC, JNLPPC, LY)
!
      CALL STKCLR(NALL0)
!
!     CHECK FOR ERRORS
!
      IF (IERR.NE.0) THEN
        IF (IERR.EQ.2) CALL ECVF(NMSUB)
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL BFSMVS(CCOV, NLPPC, INDEX1, INDEX2, N,'/
     +   '      +            ICCOV, JCCOV, INLPPC, JNLPPC,'/
     +   '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +   '      +            CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)')
      END
!XXCH10
      SUBROUTINE XXCH10(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE HISTOGRAM FAMILY OF ROUTINES.
!
!     DATA IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND JENKINS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IAR,IPRT,N,NYF
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AIR(144),PHI(5),Y(150),YF(150)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DIF,GFARF,IPRINT,VP
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AIR(144)
!        THE AIRLINE DATA.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE NUMBER OF COEFFICIENTS IN THE DIFFERENCE FILTER.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES.
!     DOUBLE PRECISION PHI(5)
!        THE FILTER COEFFICIENTS.
!     DOUBLE PRECISION Y(150)
!        THE LOG OF THE AIRLINE DATA.
!     DOUBLE PRECISION YF(150)
!        THE FILTERED DATA.
!
!
      DATA  AIR(  1), AIR(  2), AIR(  3), AIR(  4), AIR(  5), AIR(  6)
     +    / 112.0D0,  118.0D0,  132.0D0,  129.0D0,  121.0D0,  135.0D0/
      DATA  AIR(  7), AIR(  8), AIR(  9), AIR( 10), AIR( 11), AIR( 12)
     +    / 148.0D0,  148.0D0,  136.0D0,  119.0D0,  104.0D0,  118.0D0/
      DATA  AIR( 13), AIR( 14), AIR( 15), AIR( 16), AIR( 17), AIR( 18)
     +    / 115.0D0,  126.0D0,  141.0D0,  135.0D0,  125.0D0,  149.0D0/
      DATA  AIR( 19), AIR( 20), AIR( 21), AIR( 22), AIR( 23), AIR( 24)
     +    / 170.0D0,  170.0D0,  158.0D0,  133.0D0,  114.0D0,  140.0D0/
      DATA  AIR( 25), AIR( 26), AIR( 27), AIR( 28), AIR( 29), AIR( 30)
     +    / 145.0D0,  150.0D0,  178.0D0,  163.0D0,  172.0D0,  178.0D0/
      DATA  AIR( 31), AIR( 32), AIR( 33), AIR( 34), AIR( 35), AIR( 36)
     +    / 199.0D0,  199.0D0,  184.0D0,  162.0D0,  146.0D0,  166.0D0/
      DATA  AIR( 37), AIR( 38), AIR( 39), AIR( 40), AIR( 41), AIR( 42)
     +    / 171.0D0,  180.0D0,  193.0D0,  181.0D0,  183.0D0,  218.0D0/
      DATA  AIR( 43), AIR( 44), AIR( 45), AIR( 46), AIR( 47), AIR( 48)
     +    / 230.0D0,  242.0D0,  209.0D0,  191.0D0,  172.0D0,  194.0D0/
      DATA  AIR( 49), AIR( 50), AIR( 51), AIR( 52), AIR( 53), AIR( 54)
     +    / 196.0D0,  196.0D0,  236.0D0,  235.0D0,  229.0D0,  243.0D0/
      DATA  AIR( 55), AIR( 56), AIR( 57), AIR( 58), AIR( 59), AIR( 60)
     +    / 264.0D0,  272.0D0,  237.0D0,  211.0D0,  180.0D0,  201.0D0/
      DATA  AIR( 61), AIR( 62), AIR( 63), AIR( 64), AIR( 65), AIR( 66)
     +    / 204.0D0,  188.0D0,  235.0D0,  227.0D0,  234.0D0,  264.0D0/
      DATA  AIR( 67), AIR( 68), AIR( 69), AIR( 70), AIR( 71), AIR( 72)
     +    / 302.0D0,  293.0D0,  259.0D0,  229.0D0,  203.0D0,  229.0D0/
      DATA  AIR( 73), AIR( 74), AIR( 75), AIR( 76), AIR( 77), AIR( 78)
     +    / 242.0D0,  233.0D0,  267.0D0,  269.0D0,  270.0D0,  315.0D0/
      DATA  AIR( 79), AIR( 80), AIR( 81), AIR( 82), AIR( 83), AIR( 84)
     +    / 364.0D0,  347.0D0,  312.0D0,  274.0D0,  237.0D0,  278.0D0/
      DATA  AIR( 85), AIR( 86), AIR( 87), AIR( 88), AIR( 89), AIR( 90)
     +    / 284.0D0,  277.0D0,  317.0D0,  313.0D0,  318.0D0,  374.0D0/
      DATA  AIR( 91), AIR( 92), AIR( 93), AIR( 94), AIR( 95), AIR( 96)
     +    / 413.0D0,  405.0D0,  355.0D0,  306.0D0,  271.0D0,  306.0D0/
      DATA  AIR( 97), AIR( 98), AIR( 99), AIR(100), AIR(101), AIR(102)
     +    / 315.0D0,  301.0D0,  356.0D0,  348.0D0,  355.0D0,  422.0D0/
      DATA  AIR(103), AIR(104), AIR(105), AIR(106), AIR(107), AIR(108)
     +    / 465.0D0,  467.0D0,  404.0D0,  347.0D0,  305.0D0,  336.0D0/
      DATA  AIR(109), AIR(110), AIR(111), AIR(112), AIR(113), AIR(114)
     +    / 340.0D0,  318.0D0,  362.0D0,  348.0D0,  363.0D0,  435.0D0/
      DATA  AIR(115), AIR(116), AIR(117), AIR(118), AIR(119), AIR(120)
     +    / 491.0D0,  505.0D0,  404.0D0,  359.0D0,  310.0D0,  337.0D0/
      DATA  AIR(121), AIR(122), AIR(123), AIR(124), AIR(125), AIR(126)
     +    / 360.0D0,  342.0D0,  406.0D0,  396.0D0,  420.0D0,  472.0D0/
      DATA  AIR(127), AIR(128), AIR(129), AIR(130), AIR(131), AIR(132)
     +    / 548.0D0,  559.0D0,  463.0D0,  407.0D0,  362.0D0,  405.0D0/
      DATA  AIR(133), AIR(134), AIR(135), AIR(136), AIR(137), AIR(138)
     +    / 417.0D0,  391.0D0,  419.0D0,  461.0D0,  472.0D0,  535.0D0/
      DATA  AIR(139), AIR(140), AIR(141), AIR(142), AIR(143), AIR(144)
     +    / 622.0D0,  606.0D0,  508.0D0,  461.0D0,  390.0D0,  432.0D0/
!
!     DEFINE CONSTANTS
!
      CALL IPRINT(IPRT)
      N = 144
!
!     TAKE LOG OF DATA
!
      DO 10 I=1,N
         Y(I) = LOG(AIR(I))
   10 CONTINUE
!
!     WRITE HEADER
!
      WRITE(IPRT, 1000)
!
!     RUN SIMPLE TEST OF DIF
!
      WRITE(IPRT, 1100)
      CALL DIF (Y, N, YF, NYF)
      WRITE (IPRT,2000) IERR
!
!     PLOT ORIGINAL SERIES
!
      WRITE(IPRT, 1200)
      CALL VP (Y, N, 1)
      WRITE (IPRT,2000) IERR
!
!     PLOT DIFFERENCED SERIES
!
      WRITE(IPRT, 1300)
      CALL VP (YF, NYF, 1)
      WRITE (IPRT,2000) IERR
!
!     RUN SIMPLE TEST OF GFARF
!
      WRITE(IPRT, 1400)
      PHI(1) = 1.0
      IAR = 1
      CALL GFARF (PHI, IAR)
      WRITE (IPRT,2000) IERR
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT ('1*CH10')
 1100 FORMAT (' SIMPLE TEST OF DIF (NO OUTPUT UNLESS ERROR FOUND)')
 1200 FORMAT ('1PLOT OF ORIGINAL SERIES')
 1300 FORMAT ('1PLOT OF DIFFERENCED SERIES')
 1400 FORMAT ('1SIMPLE TEST OF GFARF')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
!DCKDRV
      SUBROUTINE DCKDRV (NMSUB, LDSTAK, XM, N, M, IXM, MDL,
     +   DRV, PAR, NPAR, NETA, NTAU, SCALE, LSCALE, NROW, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE IS THE DRIVER FOR THE DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,LSCALE,M,N,NETA,NPAR,NPRT,NROW,NTAU
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),SCALE(*),XM(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   ISUBHD,LIFIXD
      LOGICAL
     +   HLFRPT,PAGE,PRTFXD,WIDE
!
!  LOCAL ARRAYS
      INTEGER
     +   IFIXED(1)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DCKCNT,DCKER,DCKHDR,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     EXTERNAL DCKHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE LENGTH OF THE VECTOR IFIXED.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NROW
!        THE USER-SUPPLIED NUMBER OF THE ROW OF THE INDEPENDENT
!        VARIABLE ARRAY AT WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION XM(IXM,M)
!        THE INDEPENDENT VARIABLE ARRAY
!
!
!     CHECK FOR ERRORS IN INPUT PARAMETERS
!
      CALL DCKER(NMSUB, N, M, IXM, NPAR, LDSTAK, SCALE, LSCALE)
!
      IF (IERR.NE.0) RETURN
!
      PAGE = .FALSE.
      WIDE = .TRUE.
      ISUBHD = 0
!
      PRTFXD = .FALSE.
      IFIXED(1) = -1
      LIFIXD = 1
!
      CALL STKSET(LDSTAK, 4)
!
!     PASS CONTROL OF DERIVATIVE CHECKING TO DCKCNT
!
      CALL DCKCNT (XM, N, M, IXM, MDL, DRV, PAR, NPAR, NETA,
     +   NTAU, SCALE, LSCALE, NROW, NPRT, DCKHDR, PAGE, WIDE, ISUBHD,
     +   HLFRPT, PRTFXD, IFIXED, LIFIXD)
!
      RETURN
!
      END
!DRV4A
      SUBROUTINE DRV4A (COEF, NCOEF, XM, N, M, IXM, D)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DERIVATIVE FOR DERIVATIVE CHECKING ROUTINES (CORRECTLY CODED).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NCOEF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   COEF(NCOEF),D(N,NCOEF),XM(IXM,M)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!  INTRINSIC FUNCTIONS
      INTRINSIC EXP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION COEF(NCOEF)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        COEFFICIENTS ARE STORED.
!     DOUBLE PRECISION D(N,NCOEF)
!        THE MATRIX OF FIRST PARTIAL DERIVATIVES (JACOBIAN).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NCOEF
!        THE NUMBER OF UNKNOWN COEFFICIENTS IN THE MODEL.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
!
      DO 10 I = 1, N
         D(I,1) = 1.0D0
         D(I,2) = (COEF(3)*2.0D0*(XM(I,1)-COEF(2))/COEF(4)) *
     +      EXP(-((XM(I,1)-COEF(2))**2)/COEF(4))
         D(I,3) = EXP(-((XM(I,1)-COEF(2))**2)/COEF(4))
         D(I,4) = -COEF(3)*(-((XM(I,1)-COEF(2))**2) /
     +      (COEF(4)**2)) * EXP(-((XM(I,1)-COEF(2))**2)/COEF(4))
   10 CONTINUE
!
      RETURN
!
      END
!DRV4B
      SUBROUTINE DRV4B (COEF, NCOEF, XM, N, M, IXM, D)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DERIVATIVE FOR DERIVATIVE CHECKING ROUTINES (INCORRECTLY CODED).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NCOEF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   COEF(NCOEF),D(N,NCOEF),XM(IXM,M)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!  INTRINSIC FUNCTIONS
      INTRINSIC EXP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION COEF(NCOEF)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        COEFFICIENTS ARE STORED.
!     DOUBLE PRECISION D(N,NCOEF)
!        THE MATRIX OF FIRST PARTIAL DERIVATIVES (JACOBIAN).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NCOEF
!        THE NUMBER OF UNKNOWN COEFFICIENTS IN THE MODEL.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
!
      DO 10 I = 1, N
         D(I,1) = 0.0D0
         D(I,2) = (COEF(3)*2.0D0*(XM(I,1)-COEF(2))/COEF(4)) *
     +      EXP(-((XM(I,1)-COEF(2))**2)/COEF(4))
         D(I,3) = 0.0D0
         D(I,4) = COEF(3)*(-((XM(I,1)-COEF(2))**2) /
     +      (COEF(4)**2)) * EXP(-((XM(I,1)-COEF(2))**2)/COEF(4))
   10 CONTINUE
!
      RETURN
!
      END
!CCVF
      SUBROUTINE CCVF(Y1, Y2, N, LAGMAX, Y1MEAN, Y2MEAN, CCOV12, CCOV21,
     +   ICCOV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE CROSS COVARIANCE FUNCTION
!     BETWEEN TWO SERIES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   Y1MEAN,Y2MEAN
      INTEGER
     +   ICCOV,LAGMAX,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV12(ICCOV),CCOV21(ICCOV),Y1(N),Y2(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DOTXY
      INTEGER
     +   LAG,NDOTXY
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DOTC
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCOV12(ICCOV), CCOV21(ICCOV)
!        THE ARRAYS IN WHICH THE CCVF FOR SERIES 1 LAGGED
!        BEHIND SERIES 2 AND VISA VERSA, RESPECTIVELY, ARE
!        STORED.
!     DOUBLE PRECISION DOTXY
!        VARIOUS CROSS PRUDUCTS BETWEEN SERIES Y1 AND Y2.
!     INTEGER ICCOV
!        THE ROW DIMENSION OF THE ARRAYS CCOV12 AND CCOV21.
!     INTEGER LAG
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCORRELATION BEING COMPUTED.
!     INTEGER LAGMAX
!        THE MAXIMUM NUMBER OF LAGS TO BE USED.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NDOTXY
!        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY.
!     DOUBLE PRECISION Y1(N), Y1MEAN
!        THE FIRST SERIES, AND ITS MEAN.
!     DOUBLE PRECISION Y2(N), Y2MEAN
!        THE SECOND SERIES, AND ITS MEAN.
!
!     COMPUTE THE CROSS COVARIANCES
!
      CALL DOTC ( Y1, Y1MEAN, N, Y2, Y2MEAN, N, DOTXY, NDOTXY)
      CCOV12(1) = DOTXY / N
      CCOV21(1) = CCOV12(1)
!
      DO 10 LAG = 1, LAGMAX
!
         CALL DOTC (Y1, Y1MEAN, N, Y2(LAG + 1), Y2MEAN, N - LAG,
     +       DOTXY, NDOTXY)
         CCOV12(LAG+1) = DOTXY / N
!
         CALL DOTC (Y2, Y2MEAN, N, Y1(LAG + 1), Y1MEAN, N - LAG,
     +       DOTXY, NDOTXY)
         CCOV21(LAG+1) = DOTXY / N
!
   10 CONTINUE
!
      RETURN
      END
!PPLMT
      SUBROUTINE PPLMT (YM, YMMISS, X, XMISS, N, M, IYM, YLB, YUB, YMN,
     +  YMX, XLB, XUB, XMN, XMX, ERROR, NMSUB, MISS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SETS THE PLOT LIMITS FOR PAGE PLOTS
!     WITH MISSING VALUES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XMISS,XMN,XMX,XUB,YLB,YMN,YMX,YUB
      INTEGER
     +   IYM,M,N
      LOGICAL
     +   ERROR,MISS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N),YM(IYM,M),YMMISS(M)
      CHARACTER
     +   NMSUB(6)*1
!
!  LOCAL SCALARS
      INTEGER
     +   I,II,IPRT,J
      LOGICAL
     +   HEAD,SETLMT,SKPROW
!
!  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ADJLMT,EHDR,IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        A VALUE INDICATING WHETHER AN ERROR WAS DETECTED (TRUE)
!        OR NOT (FALSE).
!     LOGICAL HEAD
!        PRINT HEADING (HEAD=TRUE) OR NOT (HEAD=FALSE).
!     INTEGER I, II
!        INDEXING VARIABLES.
!     INTEGER IPRT
!        ...
!     INTEGER IYM
!        ACTUAL ROW DIMENSION OF YM DECLARED IN THE USERS MAIN PROGRAM
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER M
!        THE NUMBER OF VECTORS IN YM
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS .
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     LOGICAL SETLMT
!        AN INDICATOR VARIABLE USED TO DETERMINE IF STARTING VALUES
!        FOR XMN, XMX, YMN, YMX HAVE BEEN FOUND.
!     LOGICAL SKPROW
!        AN INDICATOR VARIABLE USED TO DESIGNATE WHETHER ALL
!        OBSERVATIONS IN A GIVEN ROW OF YM ARE UNUSED (TRUE)
!        OR NOT (FALSE).
!     DOUBLE PRECISION X(N)
!        THE ARRAY CONTAINING THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION XLB
!        THE USER SUPPLIED X-AXIS LOWER BOUND.
!     DOUBLE PRECISION XMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IS MISSING.
!        IF X(I) = XMISS, THE VALUE IS ASSUMED MISSING, OTHERWISE
!        IT IS NOT.
!     DOUBLE PRECISION XMN, XMX
!        THE X-AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
!     DOUBLE PRECISION XUB
!        THE USER SUPPLIED X-AXIS UPPER BOUNDS.
!     DOUBLE PRECISION YLB
!        THE USER SUPPLIED Y-AXIS LOWER BOUND.
!     DOUBLE PRECISION YM(IYM,M)
!        THE ARRAY CONTAINING THE DEPENDENT VARIABLE(S).
!     DOUBLE PRECISION YMMISS(M)
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IS MISSING.
!        IF YM(I,J) = YMMISS(J), THE VALUE IS ASSUMED MISSING, OTHERWISE
!        IT IS NOT.
!     DOUBLE PRECISION YMN, YMX
!        THE Y-AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
!     DOUBLE PRECISION YUB
!        THE USER SUPPLIED Y-AXIS UPPER BOUNDS.
!
      ERROR = .FALSE.
!
      IF ((XLB .LT. XUB) .AND. (YLB .LT. YUB)) THEN
!
!       SET LIMITS TO USER SPECIFIED VALUES
!
        XMN = XLB
        XMX = XUB
        YMN = YLB
        YMX = YUB
!
      ELSE
!
!       SET LIMITS TO RANGE OF VALUES WITHIN ANY USER SPECIFIED VALUES
!
        SETLMT = .FALSE.
        II = 1
!
!       FIND FIRST VALUE TO BE PLOTTED
!
        DO 20 I=1,N
           IF (MISS .AND. MVCHK(X(I),XMISS)) GO TO 20
           IF ((XLB.LT.XUB) .AND. ((X(I).LT.XLB) .OR.
     +        (XUB.LT.X(I)))) GO TO 20
           XMN = X(I)
           XMX = X(I)
           DO 10 J=1,M
              IF (MISS .AND. MVCHK(YM(I,J),YMMISS(J))) GO TO 10
              IF ((YLB.LT.YUB) .AND. ((YM(I,J).LT.YLB) .OR.
     +           (YUB.LT.YM(I,J)))) GO TO 10
              IF (SETLMT) GO TO 5
              YMN = YM(I,J)
              YMX = YM(I,J)
              SETLMT = .TRUE.
              II = I + 1
              GO TO 10
    5         YMN = MIN(YMN, YM(I,J))
              YMX = MAX(YMX, YM(I,J))
   10      CONTINUE
           IF (SETLMT) GO TO 30
   20   CONTINUE
!
   30   IF (II.LE.1) THEN
!
!         NO VALUES TO BE PLOTTED.  PRINT ERROR MESSAGE
!
          ERROR = .TRUE.
          CALL IPRINT(IPRT)
          HEAD = .TRUE.
          CALL EHDR(NMSUB,HEAD)
          IF ((YLB.GE.YUB) .AND. (XLB.GE.XUB)) THEN
            WRITE (IPRT, 1010)
          ELSE
            WRITE (IPRT, 1020)
          END IF
          WRITE (IPRT, 1030)
!
        ELSE
!
!         FIND LIMITS FROM REMAINING VALUES
!
          IF (II.LE.N) THEN
            DO 50 I=II,N
               IF (MISS .AND. MVCHK(X(I),XMISS)) GO TO 50
               IF ((XLB.LT.XUB) .AND. ((X(I).LT.XLB) .OR.
     +            (XUB.LT.X(I)))) GO TO 50
               SKPROW = .TRUE.
               DO 40 J=1,M
                  IF (MISS .AND. MVCHK(YM(I,J),YMMISS(J))) GO TO 40
                  IF ((YLB.LT.YUB) .AND. ((YM(I,J).LT.YLB) .OR.
     +               (YUB.LT.YM(I,J)))) GO TO 40
                  SKPROW = .FALSE.
                  YMN = MIN(YMN, YM(I,J))
                  YMX = MAX(YMX, YM(I,J))
   40          CONTINUE
               IF (SKPROW) GO TO 50
               XMN = MIN(XMN, X(I))
               XMX = MAX(XMX, X(I))
   50       CONTINUE
          END IF
        END IF
!
        IF (YLB.LT.YUB) THEN
!
!       SET Y AXIS LIMITS TO USER SUPPLIED VALUES
!
          YMN = YLB
          YMX = YUB
        ELSE
!
!       ADJUST Y AXIS LIMITS IF EQUAL
!
          IF (YMN .GE. YMX) CALL ADJLMT(YMN, YMX)
        END IF
!
        IF (XLB.LT.XUB) THEN
!
!       SET X AXIS LIMITS TO USER SUPPLIED VALUES
!
          XMN = XLB
          XMX = XUB
        ELSE
!
!         ADJUST X AXIS LIMITS IF EQUAL
!
          IF (XMN .GE. XMX) CALL ADJLMT(XMN, XMX)
!
        END IF
!
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1010 FORMAT (/
     +   44H NO NON-MISSING PLOT COORDINATES WERE FOUND.)
 1020 FORMAT (/
     +   40H NO NON-MISSING VALUES WERE FOUND WITHIN,
     +   26H THE USER SUPPLIED LIMITS.)
 1030 FORMAT (/
     +   30H THE PLOT HAS BEEN SUPPRESSED.)
      END
!SUMTS
      SUBROUTINE SUMTS(X, N, ALPHA, SUMT1, XTRM)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO CALCULATE THE UNWEIGHTED TRIMMED MEAN FOR
!     A SORTED VECTOR IN WHICH THE MIDTH ELEMENT IS THE ELEMENT
!     CLOSEST TO ZERO.  USED BY THE STAT FAMILY.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALPHA,SUMT1,XTRM
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N)
!
!  LOCAL SCALARS
      INTEGER
     +   CURHI,CURLO,I,IREV,ITHI,ITLO,MID,NALPHA
!
!  EXTERNAL SUBROUTINES
      EXTERNAL SUMBS
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,MIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        INPUT PARAMETER.  THE PERCENTAGE OF POINTS TO TRIM
!        FROM EACH END OF THE ARRAY X FOR THE TRIMMED MEAN.
!     INTEGER CURHI
!        THE UPPER BOUND OF THE CURRENT INTERVAL.
!     INTEGER CURLO
!        THE LOWER BOUND OF THE CURRENT INTERVAL.
!     INTEGER I
!        LOOP PARAMETER.
!     INTEGER IREV
!        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
!        IN THE REVERSE ORDER.
!     INTEGER ITHI
!        THE COMPUTED UPPER BOUND SUCH THAT ALPHA PER
!        CENT OF THE POSITIVELY WEIGHTED POINTS ARE
!        OMITTED.
!     INTEGER ITLO
!        THE COMPUTED LOWER BOUND SUCH THAT ALPHA PER
!        CENT OF THE POSITIVELY WEIGHTED POINTS ARE
!        OMITTED.
!     INTEGER MID
!        THE INDEX OF THE ELEMENT IN X CLOSEST TO ZERO IN VALUE.
!        THE POINT OUT FROM WHICH THE SUMMING IS DONE.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
!     INTEGER NALPHA
!        THE INTEGER WHICH IS ALPHA PER CENT OF N.
!     DOUBLE PRECISION SUMT1
!        OUTPUT PARAMETER.  THE UNWEIGHTED SUM OF THE TRIMMED
!        ARRAY.  ZERO-WEIGHTED ELEMENTS ARE OMITTED.
!     DOUBLE PRECISION X(N)
!        INPUT PARAMETER.  THE DATA ARRAY X IN WHICH THE SUMS ARE TAKEN.
!     DOUBLE PRECISION XTRM
!        OUTPUT PARAMETER.  THE UNWEIGHTED, TRIMMED MEAN OF X.
!
!     SET UP LIMITS TRIMMING THE NUMBER OF VALUES AT EACH END
!     BY ALPHA PER CENT.
!
      NALPHA = ALPHA*N
      ITLO = NALPHA + 1
      ITHI = N - NALPHA
      CALL SUMBS(X, N, ITLO, MID, ITHI)
!
!     INITIALIZE SUMMATION VARIABLES.
!
      SUMT1 = X(MID)
      CURLO = MID - 1
      CURHI = MID + 1
!
!     SUM OUTWARDS FROM THE VALUE NEAREST ZERO.  THAT IS, SUM FROM
!     THE LEAST IN MAGNITUDE TO THE GREATEST.
!
   10 IF (CURHI.GT.ITHI .OR. CURLO.LT.ITLO) GO TO 30
      IF (ABS(X(CURHI)).LT.ABS(X(CURLO))) GO TO 20
      SUMT1 = SUMT1 + X(CURLO)
      CURLO = CURLO - 1
      GO TO 10
   20 SUMT1 = SUMT1 + X(CURHI)
      CURHI = CURHI + 1
      GO TO 10
!
!     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
!     CENTER ZERO POINT.
!
   30 IF (CURHI.GT.ITHI) GO TO 50
      CURHI = MAX(CURHI,ITLO)
      DO 40 I=CURHI,ITHI
         SUMT1 = SUMT1 + X(I)
   40 CONTINUE
   50 IF (CURLO.LT.ITLO) GO TO 70
      CURLO = MIN(CURLO,ITHI)
      DO 60 IREV=ITLO,CURLO
         I = ITLO - IREV + CURLO
         SUMT1 = SUMT1 + X(I)
   60 CONTINUE
   70 XTRM = SUMT1/(N-2*NALPHA)
      RETURN
      END
!STAT
      SUBROUTINE STAT(Y, N, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES 53 DIFFERENT STATISTICS FOR A VECTOR
!     Y, WITH NO WEIGHTS SPECIFIED.  ONE PAGE OF AUTOMATIC
!     PRINTOUT IS PRODUCED.
!
!     WRITTEN BY - JANET R. DONALDSON, JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!        (EXTENSIVE REVISION OF OLDER VERSION)
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,SUMD2,SUMD3,SUMD4,SUMDA,SUMDI,SUMT1
      INTEGER
     +   IDP,IINT,IPRT,LSORT,MID,NALL0,NNZW
      LOGICAL
     +   STACK,WTS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   STS(53),WT(1)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GENI,IPRINT,SRTIR,SRTRI,STAT1,STAT2,STATER,STKCLR,STKSET,
     +   SUMBS,SUMDS,SUMID,SUMOT,SUMSS,SUMTS
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        THE PERCENTAGE TO BE TRIMMED OFF EACH END OF Y FOR THE
!        TRIMMED MEANS CALCULATIONS.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDP
!        THE CODE VALUE FOR DOUBLE PRECISION FOR FRAMEWORK.
!     INTEGER IERR
!        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
!        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
!        SOME ERROR EXISTS.
!     INTEGER IINT
!        THE CODE VALUE FOR INTEGER FOR FRAMEWORK
!     INTEGER IPRT
!        THE NUMBER OF THE STANDARD OUTPUT UNIT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
!        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
!     INTEGER LSORT
!        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION
!        VECTOR.
!     INTEGER MID
!        THE INDEX OF THE (AN) ELEMENT OF Y CLOSEST TO ZERO, WHEN
!        Y HAS BEEN SORTED.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
!        WAS CALLED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NNZW
!        NUMBER OF NONZERO WEIGHTS.
!     LOGICAL STACK
!        A FLAG INDICATING WHETHER THIS ROUTINE USES THE STACK (TRUE)
!        OR NOT (FALSE).
!     DOUBLE PRECISION STS(53)
!        THE VECTOR OF THE 53 STATISTICS COMPUTED.
!     DOUBLE PRECISION SUMDA
!        THE SUM OF THE ABSOLUTE DIFFERENCES FROM THE MEAN.
!     DOUBLE PRECISION SUMDI
!        THE SUM OF THE PRODUCTS OF THE INDICES AND THE DIFFERENCES.
!     DOUBLE PRECISION SUMD2
!        THE SUM OF THE SQUARES OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMD3
!        THE SUM OF THE CUBES OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMD4
!        THE SUM OF THE 4TH POWERS OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMT1
!        THE SUM OF THE ALPHA TRIMMED ARRAY Y.
!     DOUBLE PRECISION WT(1)
!        THE DUMMY WEIGHTS VECTOR.
!     LOGICAL WTS
!        A FLAG INDICATING WHETHER THERE ARE WEIGHTS (TRUE)
!        OR NOT (FALSE).
!     DOUBLE PRECISION Y(N)
!        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
!        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
!        TO ITS ORIGINAL ORDER AFTERWARDS.
!
!
!     INITIALIZE NAME VECTORS
!
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'S',      'T',      'A',      'T',      ' ',      ' '/
!
      DATA ALPHA /0.25D0/
      DATA IDP /4/
      DATA IINT /2/
      DATA WTS /.FALSE./
      DATA STACK /.TRUE./
!
!     CHECK FOR ERRORS IN THE INPUT PARAMETERS
!
      CALL STATER(NMSUB, WT, N, LDSTAK, WTS, NNZW, STACK, IERR)
      IF (IERR.NE.0) THEN
!
!     PRINT ERROR MESSAGE.
!
         CALL IPRINT(IPRT)
         WRITE (IPRT,1000)
         RETURN
      END IF
!
!     SET UP FRAMEWORK AREA.
!
      CALL STKSET (LDSTAK, IDP)
      NALL0 = STKST(1)
!
!     SET UP LSORT, THE PERMUTATION VECTOR.
!
      LSORT = STKGET(N,IINT)
      CALL GENI(ISTAK(LSORT), N, 1, 1)
!
!     SORT THE VECTOR Y.
!
      CALL SRTIR(ISTAK(LSORT), N, Y)
!
!     COMPUTE THE STATISTICS WHICH USE A SORTED ARRAY.
!
      CALL STAT1(Y, N, STS(5), STS(34), STS(35), STS(6),
     +   STS(11), 10, 0.0D0, 0.0D0, STS(44))
!
!     CALCULATE SUMS OF THE SORTED ARRAY.
!
      CALL SUMBS(Y, N, 1, MID, N)
      CALL SUMSS(Y, N, 1, MID, N, STS(38), STS(39), STS(42),
     +   STS(3))
      STS(4) = STS(3)
      CALL SUMTS(Y, N, ALPHA, SUMT1, STS(7))
      STS(8) = STS(7)
      CALL SUMDS(Y, N, 1, MID, N, STS(3), SUMDA, SUMD2, SUMD3, SUMD4)
!
!     RESTORE THE VECTOR Y TO ITS ORIGINAL ORDER.
!
      CALL SRTRI(Y, N, ISTAK(LSORT))
!
!     COMPUTE REST OF STATISTICS.
!
      CALL SUMID(Y, N, STS(3), SUMDI)
      CALL STAT2(Y, N, STS, SUMDA, SUMDI, SUMD2, SUMD3, SUMD4)
      CALL SUMOT(STS, N, N, WTS)
!
!     RETURN THE VECTOR LSORT.
!
      CALL STKCLR(NALL0)
      RETURN
!
!     FORMAT STATEMENTS.
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL STAT (Y, N, LDSTAK)')
      END
!DOTCM
      SUBROUTINE DOTCM (Y, YMEAN, YMISS, NY, X, XMEAN, XMISS,
     +   NX, DOTXY, NDOTXY)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE DOT PRODUCT OF TWO
!     SERIES WITH MISSING DATA, CENTERED ABOUT THEIR RESPECTIVE MEANS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DOTXY,XMEAN,XMISS,YMEAN,YMISS
      INTEGER
     +   NDOTXY,NX,NY
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(NX),Y(NY)
!
!  LOCAL SCALARS
      INTEGER
     +   I,M
!
!  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DOTXY
!        THE DOT PRODUCT OF THE SERIES (Y(I) - YMEAN) AND
!        (X(I) - XMEAN).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER M
!        THE SMALLER OF THE NUMBER OF OBSERVATIONS IN X AND Y
!     INTEGER NDOTXY
!        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY
!     INTEGER NX, NY
!        THE NUMBER OF OBSERVATIONS IN SERIES X AND Y, RESPECTIVELY.
!     DOUBLE PRECISION X(NX)
!        THE VECTOR CONTAINING THE SECOND SERIES
!     DOUBLE PRECISION XMEAN
!        THE MEAN OF THE SECOND SERIES.
!     DOUBLE PRECISION XMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF X(I) = XMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!     DOUBLE PRECISION Y(NY)
!        THE VECTOR CONTAINING THE FIRST SERIES
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE FIRST SERIES.
!     DOUBLE PRECISION YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!
      NDOTXY = 0
      DOTXY = 0.0D0
      M = MIN(NY, NX)
      DO 10 I = 1, M
         IF (MVCHK(Y(I), YMISS) .OR. MVCHK(X(I), XMISS)) GO TO 10
         DOTXY = DOTXY + (Y(I) - YMEAN) * (X(I) - XMEAN)
         NDOTXY = NDOTXY + 1
   10 CONTINUE
      RETURN
      END
!MVPC
      SUBROUTINE MVPC(YM, N, M, IYM, NS, ILOG, ISIZE,
     +   YLB, YUB, XLB, XINC)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MULTIPLE Y-AXIS VALUES (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   ILOG,ISIZE,IYM,M,N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IBAR,IPRT,IRLIN,ISCHCK,LISYM
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'V',       'P',       'C',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      MULTI = .TRUE.
      IRLIN = -1
      IBAR = -1
      ISCHCK = 2
      MISS = .FALSE.
      LISYM = 1
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YM, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL MVPC (YM, N, M, IYM, NS, ILOG,'/
     + '      +           ISIZE, YLB, YUB, XLB, XINC)')
      END
!ACFLST
      SUBROUTINE ACFLST (RHO, SDRHO, NLPPA, LAGMAX, IFMISS, CHIA,
     +   NDFCHI, CHIAP)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE ACTUALLY LISTS THE AUTOCORRELATIONS OR
!     PARTIAL AUTOCORRELATIONS AND OTHER PERTINENT INFORMATION.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CHIA,CHIAP
      INTEGER
     +   LAGMAX,NDFCHI
      LOGICAL
     +   IFMISS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RHO(*),SDRHO(*)
      INTEGER
     +   NLPPA(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,IMAX,IMIN,IPRT,LAG,NPERL
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CHIA, CHIAP
!        THE VARIABLES IN CHICH THE CHI SQUARE STATISTIC AND
!        PROBABILITY FOR THE AUTOCORRELATIONS ARE STORED.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     LOGICAL IFMISS
!        THE INDICATOR VARIABLE USED TO DETERMINE
!        WHETHER THE INPUT SERIES HAS MISSING DATA OR NOT.
!     INTEGER IMAX, IMIN
!        THE INDEX VALUES OF THE FIRST AND LAST OBSERVATION
!        TO BE PRINTED PER LINE
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT
!     INTEGER LAG
!        THE LAG VALUE OF THE AUTOCORRELATION OR PARTIAL
!        AUTOCORRELATION BEING PRINTED.
!     INTEGER LAGMAX
!        THE NUMBER OF AUTOCORRELATIONS OR PARTIAL AUTOCORRELATIONS
!        TO BE PRINTED.
!     INTEGER NDFCHI
!        THE DEGREES OF FREEDOM FOR THE CHI SQUARED STATISTIC.
!     INTEGER NLPPA(LAGMAX)
!        THE ARRAY IN WHICH THE NUMBER OF LAGGED PRODUCT PAIRS USED TO
!        COMPUTE EACH AUTOCORRELATION IS STORED
!     INTEGER NPERL
!        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
!     DOUBLE PRECISION RHO(LAGMAX)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED.
!     DOUBLE PRECISION SDRHO(LAGMAX)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!        ARE STORED
!
!
      FPLM = D1MACH(2)
!
      CALL IPRINT(IPRT)
!
      NPERL = 12
      DO 30 I = 1, LAGMAX, NPERL
         IMIN = I
         IMAX = MIN(I + NPERL - 1, LAGMAX)
         WRITE(IPRT, 1000) (LAG, LAG = IMIN, IMAX)
         WRITE(IPRT, 1001) (RHO(LAG), LAG = IMIN, IMAX)
         WRITE(IPRT, 1002) (SDRHO(LAG), LAG = IMIN, IMAX)
         IF (IFMISS) WRITE(IPRT, 1003) (NLPPA(LAG), LAG = IMIN, IMAX)
   30 CONTINUE
!
      IF (SDRHO(LAGMAX) .EQ. FPLM) WRITE(IPRT, 1004) FPLM
!
      WRITE (IPRT, 1005) CHIA, NDFCHI, CHIAP
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/19H LAG               , 12(1X, I6))
 1001 FORMAT( 19H ACF               , 12(2X, F5.2))
 1002 FORMAT( 19H STANDARD ERROR    , 12(2X, F5.2))
 1003 FORMAT( 19H NO. OF OBS. USED  , 12(1X, I6))
 1004 FORMAT(///5X, F5.2, 38H INDICATES VALUE COULD NOT BE COMPUTED,
     +   ' DUE TO MISSING DATA.')
 1005 FORMAT(///33H THE CHI SQUARE TEST STATISTIC OF/
     +   40H THE NULL HYPOTHESIS OF WHITE NOISE    =, G21.4/
     +   40H DEGREES OF FREEDOM                    =, I17/
     +   40H OBSERVED SIGNIFICANCE LEVEL           =, F17.4)
      END
!PGM
      SUBROUTINE PGM (YFFT, N, LYFFT, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
!     THE (RAW) PERIODOGRAM OF A SERIES (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,LYFFT,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YFFT(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   FREQ,IEXTND,IPRT,LDSMIN,NALL0,NF,NFFT,NPRT,YAXIS
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      CHARACTER
     +   LLDS(8)*1,LLYFFT(8)*1,LN(8)*1,NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,IPRINT,LDSCMP,PGMMN,SETESL,STKCLR,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     INTEGER FREQ
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
!        INTEGRATED SPECTRUM VALUES ARE STORED.
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IEXTND
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
!        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
!        USED TO EXTEND THE SERIES.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     CHARACTER*1 LLDS(8), LLYFFT(8), LN(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING ALLOCATIONS OF THE STACK AT THE
!        TIME OF THIS CALL.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .EQ.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
!        IF NPRT .GE.  2, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
!     DOUBLE PRECISION YFFT(LYFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'P',       'G',       'M',       ' ',       ' ',       ' '/
      DATA
     + LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     +  LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA
     + LLYFFT(1), LLYFFT(2), LLYFFT(3), LLYFFT(4), LLYFFT(5),
     +  LLYFFT(6), LLYFFT(7), LLYFFT(8)
     +  /'L','Y','F','F','T',' ',' ',' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /'N',' ',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
      IF (ERR01) GO TO 5
!
!     SET LENGTH OF EXTENDED SERIES
!
      CALL SETESL(N, 2, NFFT)
!
      CALL EISGE(NMSUB, LLYFFT, LYFFT, NFFT, 9, HEAD, ERR02, LLYFFT)
!
      CALL LDSCMP(2, 0, 0, 0, 0, 0, 'D', NFFT, LDSMIN)
!
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 2, HEAD, ERR03, LLDS)
!
      IF (ERR01 .OR. ERR02 .OR. ERR03) GO TO 5
      GO TO 10
!
    5 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   10 CONTINUE
!
!     SET THE SIZE OF THE WORK AREA
!
      CALL STKSET(LDSTAK, 4)
!
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!
      NALL0 = STKST(1)
!
!     SET DEFAULT VALUES
!
      NPRT = -1
      IEXTND = 0
!
!     SUBDIVIDE THE WORK ARRAY
!
      YAXIS = STKGET(NFFT/2, 4)
      FREQ = STKGET(NFFT/2, 4)
      CALL PGMMN (YFFT, N, NFFT, IEXTND, NF, YFFT, LYFFT, RSTAK(YAXIS),
     +   RSTAK(FREQ), NFFT/2, NPRT, NMSUB)
!
      CALL STKCLR(NALL0)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL PGM (YFFT, N, LYFFT, LDSTAK)')
      END
!HISTC
      SUBROUTINE HISTC (Y, N, NCELL, YLB, YUB, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR PRODUCING A HISTOGRAM
!     (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YLB,YUB
      INTEGER
     +   LDSTAK,N,NCELL
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IDP,IFP,IINT,IPRT,LSORT,NALL0,NCELLS,YDIST
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL HSTER,HSTMN,IPRINT,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ANINT,LOG10,MIN,NINT,DBLE
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDP
!        THE CODE VALUE FOR DOUBLE PRECISION FOR FRAMEWORK.
!     INTEGER IERR
!        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
!        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
!        SOME ERROR EXISTS.
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IINT
!        THE CODE VALUE FOR INTEGER FOR FRAMEWORK
!     INTEGER IPRT
!        THE NUMBER OF THE STANDARD OUTPUT UNIT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
!        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
!     INTEGER LSORT
!        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION
!        VECTOR.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
!        WAS CALLED.
!     INTEGER NCELL
!        THE USER SUPPLIED VALUE FOR THE NUMBER OF CELLS IN THE
!        HISTOGRAM.  IF NCELL IS LESS THAN OR EQUAL TO ZERO, THE
!        NUMBER OF CELLS TO BE USED (NCELLS) WILL BE CALCULATED FROM
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NCELLS
!        THE NUMBER OF CELLS IN THE HISTOGRAM.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION Y(N)
!        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
!        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
!        TO ITS ORIGINAL ORDER AFTERWARDS.
!     INTEGER YDIST
!        THE STARTING LOCATION IN RSTAK OF THE DISTRIBUTION VECTOR.
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!
!     INITIALIZE NAME VECTORS
!
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'H',      'I',      'S',      'T',      'C',      ' '/
!
      DATA IDP /4/
      DATA IINT /2/
!
!     COMPUTE NCELLS
!
      IF ((NCELL.LE.0) .AND. (N.GE.1)) THEN
         NCELLS = MIN(NINT(5.5D0+1.5D0*ANINT(LOG10(DBLE(N)))),25)
      ELSE
         NCELLS = NCELL
      END IF
!
!     CHECK FOR ERRORS IN THE INPUT PARAMETERS
!
      CALL HSTER(NMSUB, Y, N, NCELLS, LDSTAK, YLB, YUB, IERR)
      IF (IERR.EQ.0) GO TO 10
!
!     PRINT ERROR MESSAGE.
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     SET UP FRAMEWORK AREA.
!
   10 CALL STKSET (LDSTAK, IDP)
      NALL0 = STKST(1)
!
!     SET UP WORK VECTORS
!
      IFP = 4
!
      LSORT = STKGET(N,IINT)
      YDIST = STKGET(NCELLS,IFP)
!
!     COMPUTE THE HISTOGRAM.
!
      CALL HSTMN(Y, N, NCELLS, YLB, YUB, ISTAK(LSORT), RSTAK(YDIST))
!
!     RETURN THE WORK VECTORS.
!
      CALL STKCLR(NALL0)
      RETURN
!
!     FORMAT STATEMENTS.
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL HISTC (Y, N, NCELL, YLB, YUB, LDSTAK)')
      END
!XXCH3
      SUBROUTINE XXCH3(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE NORMAL RANDOM NUMBER GENERATOR FAMILY OF ROUTINES.
!
!     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   SIGMA,YMEAN
      INTEGER
     +   I,IPRT,ISEED,IYM,M,N
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YM(50,2)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,MVP,NRAND,NRANDC
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        FLAG TO INDICATE PRESENCE OF ERROR DETECTED BY PRECEDING
!        STARPAC CALL.  (0 IS OK, 1 IS ERROR)
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER ISEED
!        THE SEED FOR THE RANDOM NUMBER GENERATOR.
!     INTEGER IYM
!        THE EXACT VALUE OF THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LDSTAK
!        A DUMMY VARIABLE FOR THIS TEST SUBPROGRAM.
!     INTEGER M
!        THE NUMBER OF SETS OF NUMBERS TO BE GENERATED
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS TO BE GENERATED.
!     DOUBLE PRECISION SIGMA
!        THE S.D. OF THE SAMPLE.
!     DOUBLE PRECISION YM(50,2)
!        DATA VECTOR FOR TESTS.
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE SAMPLE.
!
!
!     DATA INITIALIZATION
!
      IYM = 50
      ISEED = 531
      N = 50
      M = 2
      YMEAN = 4.0D0
      SIGMA = 0.5D0
!
!     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
!
      CALL IPRINT(IPRT)
!
!     WRITE HEADING
!
      WRITE (IPRT,1000)
!
!     GENERATE STANDARD NORMAL PSEUDO-RANDOM NUMBERS INTO COLUMN 1 OF YM
!
      WRITE (IPRT,1100)
      CALL NRAND(YM(1,1), N, ISEED)
      WRITE (IPRT,2000) IERR
      WRITE (IPRT, 1400) (YM(I,1),I=1,N)
!
!     GENERATE NORMAL PSEUDO-RANDOM NUMBERS
!     WITH MEAN 4.0 AND STANDARD DEVIATION 0.5 INTO COLUMN 2 OF YM
!
      WRITE (IPRT,1200)
      CALL NRANDC(YM(1,2), N, ISEED, YMEAN, SIGMA)
      WRITE (IPRT,2000) IERR
      WRITE (IPRT, 1400) (YM(I,2),I=1,N)
!
!     PLOT RESULTS, SAMPLING EVERY OBSERVATION
!
      WRITE (IPRT,1500)
      CALL MVP (YM, N, M, IYM, 1)
!
      RETURN
!
!     FORMATS
!
 1000 FORMAT ('1*CH3')
 1100 FORMAT (' SIMPLE TEST OF NRAND')
 1200 FORMAT ('1SIMPLE TEST OF NRANDC')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
 1400 FORMAT (/' GENERATED RESULTS = '//(5E15.8))
 1500 FORMAT ('1MVP DISPLAY OF GENERATED RESULTS')
      END
!DCOEF
      SUBROUTINE DCOEF (NDF, ND, IOD, NPARDF, PARDF, MBO, WORK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE EXPANDS THE DIFFERENCE FILTER SPECIFIED BY NDF,
!     IOD AND ND INTO PARDF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   MBO,NDF,NPARDF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PARDF(*),WORK(*)
      INTEGER
     +   IOD(*),ND(*)
!
!  LOCAL SCALARS
      INTEGER
     +   K,KK,L,NTIMES,NWORK1,NWORK2
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   NCHOSE
      EXTERNAL NCHOSE
!
!  EXTERNAL SUBROUTINES
      EXTERNAL MULTBP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IOD(NDF)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER KK
!        AN INDEX VARIABLE.
!     INTEGER L
!        AN INDEX VARIABLE.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER ND(NDF)
!        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED.
!     INTEGER NDF
!        THE NUMBER OF DIFFERENCE FACTORS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NTIMES
!        THE NUMBER OF TIMES A GIVEN DIFFERENCE FACTOR IS TO BE APPLIED.
!     INTEGER NWORK1
!        THE NUMBER OF TERMS IN THE FIRST COLUMN OF WORK.
!     INTEGER NWORK2
!        THE NUMBER OF TERMS IN THE SECOND COLUMN OF WORK
!     DOUBLE PRECISION PARDF(MBO)
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS.
!     DOUBLE PRECISION WORK(MBO,2)
!        A WORK ARRAY NECESSARY TO EXPAND THE DIFFERENCE FILTER.
!
      NPARDF = 0
!
      DO 30 L = 1, NDF
         IF (ND(L).EQ.0) GO TO 30
         NTIMES = ND(L)
         NWORK1 = IOD(L) * ND(L)
         DO 10 K = 1, NWORK1
            WORK(K) = 0.0D0
   10    CONTINUE
         DO 20 K = 1, NTIMES
            KK = K * IOD(L)
            WORK(KK) = ((-1)**(K+1)) * NCHOSE(NTIMES, K)
   20    CONTINUE
         NWORK2 = NWORK1 + NPARDF
         CALL MULTBP (WORK(1), NWORK1, PARDF, NPARDF, WORK(MBO+1),
     +      NWORK2, MBO)
   30 CONTINUE
      RETURN
      END
!PPM
      SUBROUTINE PPM(YM, YMMISS, X, XMISS, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT FOR DATA WITH MISSING OBSERVATIONS (SHORT CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(1)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   ILOG,IPRT,ISCHCK,ISIZE,IYM,LISYM,M,NOUT
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'P',       'P',       'M',       ' ',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      M = 1
      IYM = N
      MULTI = .FALSE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 0
      ISIZE = -1
      NOUT = 0
      MISS = .TRUE.
      LISYM = 1
!
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL PPM (Y, YMISS, X, XMISS, N)')
      END
!SUMDS
      SUBROUTINE SUMDS(X, N, LO, MID, HI, XMEANW, SUMDA, SUMD2, SUMD3,
     +   SUMD4)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO CALCULATE UNWEIGHTED SUMS OF POWERS OF
!     DIFFERENCES FROM THE WEIGHTED MEAN FOR A SORTED
!     VECTOR IN WHICH THE MIDTH ELEMENT IS THE ELEMENT
!     CLOSEST TO ZERO.  USED BY THE STAT FAMILY.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SUMD2,SUMD3,SUMD4,SUMDA,XMEANW
      INTEGER
     +   HI,LO,MID,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DIFF
      INTEGER
     +   CURHI,CURLO,I,IREV
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CURHI
!        THE UPPER BOUND OF THE CURRENT INTERVAL.
!     INTEGER CURLO
!        THE LOWER BOUND OF THE CURRENT INTERVAL.
!     DOUBLE PRECISION DIFF
!        THE DIFFERENCES BETWEEN X(I) AND XMEANW.
!     INTEGER HI
!        INPUT PARAMETER.  THE UPPER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER I
!        A LOOP PARAMETER.
!     INTEGER IREV
!        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
!        IN THE REVERSE ORDER.
!     INTEGER LO
!        INPUT PARAMETER.  THE LOWER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER MID
!        INPUT PARAMETER.  THE INDEX OF THE ELEMENT IN X CLOSEST TO
!        ZERO IN VALUE.  THE POINT OUT FROM WHICH THE SUMMING IS
!        DONE.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
!     DOUBLE PRECISION SUMDA
!        OUTPUT PARAMETER.  THE SUM OF THE ABSOLUTE VALUES OF THE
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION SUMD2
!        OUTPUT PARAMETER.  THE SUM OF THE SQUARES OF THE
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION SUMD3
!        OUTPUT PARAMETER.  THE SUM OF THE CUBES OF THE
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION SUMD4
!        OUTPUT PARAMETER.  THE SUM OF THE HYPERCUBES OF THE
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION X(N)
!        INPUT PARAMETER.  THE DATA ARRAY X IN WHICH THE SUMS ARE TAKEN.
!     DOUBLE PRECISION XMEANW
!        INPUT PARAMETER.  THE WEIGHTED MEAN OF X.
!
!     INITIALIZE SUMMATION VARIABLES.
!
      DIFF = X(MID) - XMEANW
      SUMDA = ABS(DIFF)
      SUMD2 = DIFF*DIFF
      SUMD3 = DIFF*DIFF*DIFF
      SUMD4 = DIFF*DIFF*DIFF*DIFF
      CURLO = MID - 1
      CURHI = MID + 1
!
!     SUM OUTWARDS FROM THE VALUE NEAREST ZERO.  THAT IS, SUM FROM
!     THE LEAST IN MAGNITUDE TO THE GREATEST.
!
   10 IF (CURHI.GT.HI .OR. CURLO.LT.LO) GO TO 30
      IF (ABS(X(CURHI)).LT.ABS(X(CURLO))) GO TO 20
      DIFF = X(CURLO) - XMEANW
      SUMDA = SUMDA + ABS(DIFF)
      SUMD2 = SUMD2 + DIFF*DIFF
      SUMD3 = SUMD3 + DIFF*DIFF*DIFF
      SUMD4 = SUMD4 + DIFF*DIFF*DIFF*DIFF
      CURLO = CURLO - 1
      GO TO 10
   20 DIFF = X(CURHI) - XMEANW
      SUMDA = SUMDA + ABS(DIFF)
      SUMD2 = SUMD2 + DIFF*DIFF
      SUMD3 = SUMD3 + DIFF*DIFF*DIFF
      SUMD4 = SUMD4 + DIFF*DIFF*DIFF*DIFF
      CURHI = CURHI + 1
      GO TO 10
!
!     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
!     CENTER ZERO POINT.
!
   30 IF (CURHI.GT.HI) GO TO 50
      DO 40 I=CURHI,HI
         DIFF = X(I) - XMEANW
         SUMDA = SUMDA + ABS(DIFF)
         SUMD2 = SUMD2 + DIFF*DIFF
         SUMD3 = SUMD3 + DIFF*DIFF*DIFF
         SUMD4 = SUMD4 + DIFF*DIFF*DIFF*DIFF
   40 CONTINUE
   50 IF (CURLO.LT.LO) GO TO 70
      DO 60 IREV=LO,CURLO
         I = LO - IREV + CURLO
         DIFF = X(I) - XMEANW
         SUMDA = SUMDA + ABS(DIFF)
         SUMD2 = SUMD2 + DIFF*DIFF
         SUMD3 = SUMD3 + DIFF*DIFF*DIFF
         SUMD4 = SUMD4 + DIFF*DIFF*DIFF*DIFF
   60 CONTINUE
   70 RETURN
      END
!CORRMN
      SUBROUTINE CORRMN(YM, N, M, IYM, AVG, SD, T, RANK, SC, PC, SCINV,
     +   IWRK, WRK, SLSC, SLPC, SRCC, QUAD, CIUP, CILO, QF, NPRT,
     +   VCV, IVCV, LIWRK, LWRK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN ROUTINE FOR THE CORRELATION FAMILY, IT WAS
!     ADAPTED FROM THE OMNITAB ROUTINE CORREL. IT DOES A  CORRELATION
!     ANALYSIS OF A MULTIVARIATE RANDOM SAMPLE.
!     THE FOLLOWING TABLES ARE PRODUCED
!        SIMPLE CORRELATION COEFFICIENTS,
!        PARTIAL CORRELATION COEFFICIENTS,
!        AND THEIR SIGINIFICANCE LEVELS,
!        SPEARMAN RANK COEFFICIENTS,
!        QUADRATIC RELATIONSHIP,
!        95 AND 99 PERCENT CONFIDENCE INTERVALS.
!
!     THIS ROUTINE WAS ADAPTED FROM AN OMNITAB ROUTINE.
!
!     ADAPTED BY -
!        JANET R. DONALDSON AND LINDA L. MITCHELL
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IVCV,IYM,LIWRK,LWRK,M,N,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AVG(M),CILO(M,M),CIUP(M,M),PC(M,M),QF(M,M),QUAD(N,3),
     +   RANK(N,M),SC(M,M),SCINV(M,M),SD(M),SLPC(M,M),SLSC(M,M),
     +   SRCC(M,M),T(M),VCV(IVCV,M),WRK(LWRK),YM(IYM,M)
      INTEGER
     +   IWRK(LIWRK)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   B,F,FN3,FPLM,HL1,HL2,SQSUM,SUM,Z,ZZ
      INTEGER
     +   I,IER,IPRT,J,K,K1,K2,NSUM
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   C(3),D(3),RR(3,3),XX(3)
      INTEGER
     +   INERT(3)
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFF,D1MACH
      EXTERNAL CDFF,D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN,CORRHD,DOTC,IPRINT,MATPRT,MGS,RANKO,DSIDI,DSIFA,
     +   VCVOUT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,INT,LOG,MAX,MIN,DBLE,SIGN,SQRT,TANH
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AVG(M)
!                  CONTAINS THE COLUMN AVERAGES OF YM
!     DOUBLE PRECISION B
!                  = (N-1) * N * (N+1) / 6
!     DOUBLE PRECISION C(3)
!                  *
!     DOUBLE PRECISION CILO(M,M)
!                  LOWER CONFIDENCE INTERVAL FOR SC
!     DOUBLE PRECISION CIUP(M,M)
!                  UPPER CONFIDENCE INTERVAL FOR SC
!     DOUBLE PRECISION D(3)
!                  A DUMMY ARRAY.
!     DOUBLE PRECISION F
!                  SQUARE ROOT OF FN3
!     DOUBLE PRECISION FN3
!                  DOUBLE PRECISION REPRESENTATION OF (N-3).
!     DOUBLE PRECISION FPLM
!                  THE FLOATING POINT LARGEST MAGNITUDE
!     DOUBLE PRECISION HL1
!                  *
!     DOUBLE PRECISION HL2
!                  *
!     INTEGER I
!                  AN INDEX VARIABLE
!     INTEGER IER
!                  ERROR FLAG FOR SUBROUTINES CALLED FROM THIS ROUTINE
!     INTEGER IERR
!                  WHEN RETURNED BY THIS ROUTINE, DESGINATES WHETHER ANY
!                  ERRORS WERE DETECTED DURING COMPUTATIONS
!                     IF IERR .EQ. 0, NO ERRORS
!                             .EQ. 1, ERRORS WERE DETECTED
!     INTEGER INERT(3)
!                  THE INERTIA OF THE SIMPLE CORRELATION MATRIX.
!     INTEGER IPRT
!                  THE LOGICAL OUTPUT NUMBER
!     INTEGER IVCV
!                  THE ROW DIMENSION OF VCV SPECIFIED IN THE USERS PROGR
!     INTEGER IWRK(LIWRK)
!                  A WORK VECTOR FOR THE INVERSION ROUTINE
!     INTEGER IYM
!                  THE ROW DIMENSION OF YM SPECIFIED IN THE USERS PROGRA
!     INTEGER J
!                  AN INDEX VARIABLE
!     INTEGER K
!                  AN INDEX VARIABLE
!     INTEGER K1
!                  *
!     INTEGER K2
!                  *
!     INTEGER LIWRK
!                  THE LENGTH OF THE INTEGER WORK VECTOR.
!     INTEGER LWRK
!                  THE LENGTH OF THE DOUBLE PRECISION WORK VECTOR.
!     INTEGER M
!                  THE NUMBER OF VARIABLES (THE COLUMN DIMENSION OF YM)
!     INTEGER N
!                  THE NUMBER OF OBSERVATIONS
!     INTEGER NPRT
!                  THE VARIABLE CONTROLLING THE AUTOMATIC PRINTOUT
!                  NPRT =0, PRINTOUT IS SUPPRESSED
!                  OTHERWISE PRINTOUT IS PROVIDED
!     INTEGER NSUM
!                  THE NUMBER OF OBSERVATIONS IN THE DOT PRODUCT
!     DOUBLE PRECISION PC(M,M)
!                  PARTIAL CORRELATION COEFFICIENTS MATRIX
!     DOUBLE PRECISION QF(M,M)
!                  QUADRATIC FIX MATRIX
!     DOUBLE PRECISION QUAD(N,3)
!                  DOUBLE VERSION OF QF MATRIX
!     DOUBLE PRECISION RANK(N,M)
!                  THE MATRIX CONTAING THE RANKS OF YM
!     DOUBLE PRECISION RR(3,3)
!                  *
!     DOUBLE PRECISION SC(M,M)
!                  SIMPLE CORRELATION COEFFICIENTS MATRIX
!     DOUBLE PRECISION SCINV(M,M)
!                  THE INVERSE MATRIX OF SC
!     DOUBLE PRECISION SD(M)
!                  STANDARD DEVIATION OF THE COMLUMNS OF YM
!     DOUBLE PRECISION SLPC(M,M)
!                  SIGNIFICANCE LEVELS OF PC
!     DOUBLE PRECISION SLSC(M,M)
!                  SIGNIFICANCE LEVELS OF SC
!     DOUBLE PRECISION SQSUM
!                  THE SUM OF SQUARES OF THE ITH COLUMN OF YM
!     DOUBLE PRECISION SRCC(M,M)
!                  SPEARMAN RANK CORRELATION COEFFICIENTS
!     DOUBLE PRECISION SUM
!                  USED IN CALCULATING THE STATISTICS OF YM
!     DOUBLE PRECISION T(M)
!                  USED IN DETERMINING SRCC
!     DOUBLE PRECISION VCV(IVCV,M)
!                  THE VARIANCE COVARIANCE MATRIX.
!     DOUBLE PRECISION WRK(LWRK)
!                  WORK STORAGE
!     DOUBLE PRECISION XX(3)
!                  *
!     DOUBLE PRECISION YM(IYM,M)
!                  THE MATRIX WHOSE COLUMNS EACH CONTAIN ONE OF M SETS
!                  OF N OBSERVATIONS. EACH COLUMN REPRESENTS A DIFFERENT
!                  VARIABLE
!     DOUBLE PRECISION Z
!                  USED IN COMPUTING CONFIDENCE INTERVALS
!     DOUBLE PRECISION ZZ
!                  USED IN DETERMINING CORRELATION COEFFICIENTS
!
      IERR = 0
!
      FPLM = D1MACH(2)
      CALL IPRINT(IPRT)
!
      DO 10 J=1,M
         CALL AMEAN(YM(1,J), N, AVG(J))
   10 CONTINUE
!
!     COMPUTE VARIANCE-COVARIANCE MATRIX
!
      DO 30 J=1,M
         DO 20 I=J,M
            CALL DOTC(YM(1,J), AVG(J), N, YM(1,I), AVG(I), N, SUM, NSUM)
            VCV(J,I) = SUM/(NSUM-1)
            VCV(I,J) = VCV(J,I)
   20    CONTINUE
   30 CONTINUE
!
      IF (NPRT.EQ.0) RETURN
!
!     PRINT VARIANCE-COVARIANCE MATRIX AND SIMPLE CORRELATION
!     COEFFICIENTS
!
      CALL CORRHD(IPRT, M, N)
      CALL VCVOUT(M, VCV, IVCV, .FALSE.)
!
!     COMPUTE STANDARD DEVIATIONS
!
      DO 40 I=1,M
         IF (VCV(I,I).LE.0.0D0) GO TO 90
         SD(I) = SQRT(VCV(I,I))
   40 CONTINUE
!
!     COMPUTE SIMPLE CORRELATION COEFFICIENTS
!
      DO 60 J=1,M
         DO 50 I=J,M
            SC(I,J) = 1.0D0
            SCINV(J,I) = 1.0D0
            IF (I.EQ.J) GO TO 50
            SC(I,J) = VCV(I,J)/SD(I)/SD(J)
            SC(J,I) = SC(I,J)
            SCINV(J,I) = SC(I,J)
   50    CONTINUE
   60 CONTINUE
!
      IF ((M.LE.2) .OR. (N.LE.M)) GO TO 190
!
!     CALCULATE PARTIAL CORRELATION COEFFICIENTS.
!
      CALL DSIFA(SCINV, M, M, IWRK, IER)
      IF (IER.EQ.0) GO TO 100
   90 WRITE (IPRT,1000)
      IERR = 1
      RETURN
  100 CONTINUE
      CALL DSIDI(SCINV, M, M, IWRK, D, INERT, WRK, 1)
      DO 130 J=1,M
         DO 120 I=J,M
            PC(I,J) = 1.0D0
            IF (I.EQ.J) GO TO 120
            ZZ = SCINV(I,I)*SCINV(J,J)
            PC(I,J) = FPLM
            IF (ZZ.LE.0.0D0) GO TO 110
            PC(I,J) = -SCINV(J,I)/SQRT(ZZ)
            IF (ABS(PC(I,J)).GT.1.0D0) PC(I,J) = SIGN(1.0D0,PC(I,J))
  110       PC(J,I) = PC(I,J)
  120    CONTINUE
!
  130 CONTINUE
!
!     COMPUTE SIGNIFICANCE LEVELS OF PARTIAL CORRELATION COEFFICIENTS.
!     NOTE, LOWER TRIANGULAR MATRIX STORED IN SQUARE MATRIX.
!
      DO 180 I=1,M
         DO 170 J=1,I
            IF (PC(I,J).NE.0.0D0) GO TO 140
            SLPC(I,J) = 1.0D0
            GO TO 170
  140       IF (ABS(PC(I,J)).LT.1.0D0) GO TO 150
            SLPC(I,J) = 0.0D0
            GO TO 170
  150       F = PC(I,J)*PC(I,J)
            IF (1.0D0-F.NE.0.0D0) GO TO 160
            SLPC(I,J) = FPLM
            GO TO 170
  160       F = (N-M)*F/(1.0D0-F)
            SLPC(I,J) = 1.0D0 - CDFF(F,1.0D0,DBLE(N-M))
  170    CONTINUE
  180 CONTINUE
!
!     COMPUTE SIGNIFICANCE LEVELS OF SIMPLE CORRELATION COEFFICIENTS
!     NOTE, ONLY LOWER TRIANGULAR STORED IN SQUARE MATRIX.
!
  190 DO 250 I=1,M
         DO 240 J=1,I
            IF (I.NE.J) GO TO 200
            SLSC(I,J) = 0.0D0
            GO TO 240
  200       IF (SC(I,J).NE.0.0D0) GO TO 210
            SLSC(I,J) = 1.0D0
            GO TO 240
  210       IF (ABS(SC(I,J)).LT.1.0D0) GO TO 220
            SLSC(I,J) = 0.0D0
            GO TO 240
  220       F = SC(I,J)*SC(I,J)
            IF (F.NE.1.0D0) GO TO 230
            SLSC(I,J) = FPLM
            GO TO 240
  230       F = (N-2)*F/(1.0D0-F)
            SLSC(I,J) = 1.0D0 - CDFF(F,1.0D0,DBLE(N-2))
  240    CONTINUE
  250 CONTINUE
!
!     PRINT SIGNIFICANCE LEVELS OF SIMPLE CORRELATION COEFFICIENTS,
!     PARTIAL CORRELATION COEFFICIENTS AND SIGNIFICANCE LEVELS
!
      WRITE (IPRT,1020)
      CALL MATPRT(SLSC, SLSC, M, IPRT, 0, 1, M)
      IF ((M.GT.2) .AND. (N.GT.M)) GO TO 260
      WRITE (IPRT,1010)
      GO TO 270
  260 I = M - 2
      WRITE (IPRT,1030) I
      CALL MATPRT(PC, PC, M, IPRT, 0, 1, M)
      WRITE (IPRT,1040)
      CALL MATPRT(SLPC, SLPC, M, IPRT, 0, 1, M)
  270 CONTINUE
!
!     DETERMINE THE RANKS OF THE OBSERVATIONS.
!
      DO 280 I=1,M
         CALL RANKO(N, YM(1,I), IWRK, RANK(1,I), T(I))
         T(I) = T(I) / 12.0D0
  280 CONTINUE
!
!     COMPUTE SPEARMAN RANK CORRELATION COEFFICIENTS.
!     NOTE, LOWER TRIANGULAR MATRIX, STORED IN SQUARE MATRIX.
!
      B = (N-1)*N*(N+1)/6
      DO 330 I=1,M
         DO 320 J=1,I
            SRCC(I,J) = 1.0D0
            IF (I.EQ.J) GO TO 320
            K1 = 2.0D0*T(I) + 0.4D0
            K2 = 2.0D0*T(J) + 0.4D0
            SRCC(I,J) = FPLM
            IF ((INT(B)-K1.LE.0) .OR. (INT(B)-K2.LE.0)) GO TO 320
            SUM = 0.0D0
            DO 310 K=1,N
               ZZ = RANK(K,I) - RANK(K,J)
               SUM = SUM + ZZ*ZZ
  310       CONTINUE
            ZZ = (B - 2.0D0*T(I))*(B - 2.0D0*T(J))
            IF (ZZ.GT.0.0D0) SRCC(I,J) = (B-SUM-T(I)-T(J))/SQRT(ZZ)
  320    CONTINUE
  330 CONTINUE
!
!     PRINT SPEARMAN RANK CORRELATIONS COEFFICIENTS
!
      WRITE (IPRT,1050)
      CALL MATPRT(SRCC, SRCC, M, IPRT, 0, 1, M)
!
      IF (N.GT.3) GO TO 340
      WRITE (IPRT,1060)
      RETURN
!
!     COMPUTE THE SIGNIFICANCE LEVELS OF THE QUADRATIC FIT OVER THE
!     LINEAR FIT.
!
!     THESE CALCULATIONS MAY PRODUCE VARIABLE RESULTS IN VARYING
!     MACHINE/COMPILATION ENVIRONMENTS, IN CASES IN WHICH THE
!     YM MATRIX IS NEAR SINGULAR (ESSENTIALLY SINGULAR BUT THE
!     SINGULARITY IS UNDETECTED BY THE CODE).  THE OBSERVED SYMPTOMS
!     ARE ALTERNATION BETWEEN QF VALUES OF 0.0D0 (FIRST F = LINE
!     PRODUCES ZERO) AND 1.0D0 (FIRST F = LINE PRODUCES APPROX.
!     ZERO, AND NUMERATOR IN SECOND F = LINE IS NONZERO).
!
  340 FN3 = N-3
      DO 410 J=1,M
         DO 400 I=1,M
            IF (I.NE.J) GO TO 350
            QF(I,J) = 1.0D0
            GO TO 400
  350       SQSUM = 0.0D0
            DO 360 K=1,N
              QUAD(K,1) = 1.0D0
               QUAD(K,2) = YM(K,J)
               QUAD(K,3) = YM(K,J)*YM(K,J)
               SQSUM = SQSUM + YM(K,I)*YM(K,I)
               WRK(K) = YM(K,I)
  360       CONTINUE
            CALL MGS(QUAD, WRK, N, 3, XX, C, D, RR, 3, N, IER)
            IF (IER.EQ.0) GO TO 370
            WRITE (IPRT,1090)
            GO TO 420
  370       DO 380 K=1,3
               C(K) = C(K)*SQRT(D(K))
  380       CONTINUE
            F = (SQSUM-C(1)*C(1)-C(2)*C(2)-C(3)*C(3))
            QF(I,J) = 0.0D0
            IF (F.EQ.0.0D0) GO TO 400
            F = (C(3)*C(3)*FN3)/F
            QF(I,J) = 1.0D0
            IF (F.GT.0.0D0) QF(I,J) = 1.0D0 - CDFF(F,1.0D0,FN3)
  400    CONTINUE
  410 CONTINUE
!
!     PRINT THE QUADRATIC FIT MATRIX
!
      J = 2
      K = 1
      I = N - 3
      WRITE (IPRT,1070) I, QF(J,K), J, K
      CALL MATPRT(QF, QF, M, IPRT, 1, 1, M)
!
!     COMPUTE CONFIDENCE LIMITS FOR SIMPLE CORRELATION COEFFICIENTS
!
  420 F = SQRT(FN3)
      HL1 = 2.5758293D0/F
      HL2 = 1.9599640D0/F
      DO 520 J=1,M
         DO 510 I=1,M
            IF (I.NE.J) GO TO 430
            CIUP(I,J) = 99.0D0
            CILO(I,J) = 95.0D0
            GO TO 510
  430       IF (I.LT.J) GO TO 470
!
!           COMPUTE 95 PERCENT INTERVALS.
!
            IF (SC(I,J).GE.1.0D0) GO TO 440
            IF (SC(I,J).GT.-1.0D0) GO TO 450
            Z = -1.0D0
            GO TO 460
  440       Z = 1.0D0
            GO TO 460
  450       Z = 0.5D0*LOG((1.0D0+SC(I,J))/(1.0D0-SC(I,J)))
  460       CIUP(I,J) = MIN(TANH(Z+HL2),1.0D0)
            CILO(I,J) = MAX(TANH(Z-HL2),-1.0D0)
            GO TO 510
!
!           COMPUTE 99 PERCENT INTERVALS.
!
  470       IF (SC(J,I).GE.1.0D0) GO TO 480
            IF (SC(J,I).GT.-1.0D0) GO TO 490
            Z = -1.0D0
            GO TO 500
  480       Z = 1.0D0
            GO TO 500
  490       Z = 0.5D0*LOG((1.0D0+SC(J,I))/(1.0D0-SC(J,I)))
  500       CIUP(I,J) = MIN(TANH(Z+HL1),1.0D0)
            CILO(I,J) = MAX(TANH(Z-HL1),-1.0D0)
  510    CONTINUE
  520 CONTINUE
!
!     PRINT CONFIDENCE LIMITS
!
      WRITE (IPRT,1080)
      CALL MATPRT(CIUP, CILO, M, IPRT, 1, 2, M)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/ 46H COMPUTATION STOPPED DUE TO SINGULAR OR ILL-CO,
     +   28HNDITIONED COVARIANCE MATRIX.)
 1010 FORMAT (//42H THE PARTIAL CORRELATION COEFFICIENTS (AND, 6H SIGNI,
     +   50HFICANCE LEVELS) ARE NOT PRINTED OR DEFINED BECAUSE/6H EITHE,
     +   52HR THE NUMBER OF VECTORS BEING COMPARED IS TWO OR THE,
     +   59H NUMBER OF MEASUREMENTS IS LESS THAN OR EQUAL TO THE NUMBER/
     +   27H OF VECTORS BEING COMPARED.)
 1020 FORMAT (// 44H SIGNIFICANCE LEVELS OF SIMPLE CORRELATION C,
     +   32HOEFFICIENTS (ASSUMING NORMALITY))
 1030 FORMAT (// 38H PARTIAL CORRELATION COEFFICIENTS WITH, I3,
     +   26H REMAINING VARIABLES FIXED)
 1040 FORMAT (// 44H SIGNIFICANCE LEVELS OF PARTIAL CORRELATION ,
     +   33HCOEFFICIENTS (ASSUMING NORMALITY))
 1050 FORMAT (// 44H SPEARMAN RANK CORRELATION COEFFICIENTS (ADJ,
     +   15HUSTED FOR TIES))
 1060 FORMAT (// 44H NONLINEARITY TEST AND APPROXIMATION OF CONF,
     +   39HIDENCE INTERVALS NOT DEFINED FOR N = 3.)
 1070 FORMAT (// 45H SIGNIFICANCE LEVEL OF QUADRATIC FIT OVER LIN,
     +   35HEAR FIT BASED ON F RATIO WITH 1 AND, I5, 15H DEGREES OF FRE,
     +   4HEDOM/14H (FOR EXAMPLE,, F7.4, 19H IS THE SIGNIFICANC,
     +   41HE LEVEL OF THE QUADRATIC TERM WHEN COLUMN, I3, 9H IS FITTE,
     +   11HD TO COLUMN, I3, ')')
 1080 FORMAT (// 44H CONFIDENCE INTERVALS FOR SIMPLE CORRELATION,
     +   43H COEFFICIENTS (USING FISHER TRANSFORMATION)/' 95 PER C',
     +   59HENT LIMITS BELOW DIAGONAL, 99 PER CENT LIMITS ABOVE DIAGONA,
     +   'L')
 1090 FORMAT (/ 46H SIGNIFICANCE LEVELS OF QUADRATIC FIT OVER LIN,
     +   30HEAR FIT HAVE NOT BEEN COMPUTED/' DUE TO SINGULARITY IN',
     +   32H DESIGN MATRIX. CHECK YOUR DATA.)
      END
!XXCH13
      SUBROUTINE XXCH13(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE ARIMA MODELING AND FORECASTING FAMILY OF ROUTINES.
!
!     DATA IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND JENKINS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT,N,NFAC,NPAR
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AIR(200),PAR(10),RES(200),Y(200)
      INTEGER
     +   MSPEC(4,10)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AIME,AIMF,IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AIR(200)
!        THE AIRLINE DATA.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER MSPEC(4,10)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH
!        FACTOR.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     DOUBLE PRECISION PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION RES(200)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION Y(200)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     DEFINE CONSTANTS
!
      DATA MSPEC(1,1), MSPEC(2,1), MSPEC(3,1), MSPEC(4,1)
     +   /          0,          1,          1,          1/
      DATA MSPEC(1,2), MSPEC(2,2), MSPEC(3,2), MSPEC(4,2)
     +   /          0,          1,          1,         12/
!
      DATA  AIR(  1), AIR(  2), AIR(  3), AIR(  4), AIR(  5), AIR(  6)
     +    / 112.0D0, 118.0D0, 132.0D0, 129.0D0, 121.0D0, 135.0D0/
      DATA  AIR(  7), AIR(  8), AIR(  9), AIR( 10), AIR( 11), AIR( 12)
     +    / 148.0D0, 148.0D0, 136.0D0, 119.0D0, 104.0D0, 118.0D0/
      DATA  AIR( 13), AIR( 14), AIR( 15), AIR( 16), AIR( 17), AIR( 18)
     +    / 115.0D0, 126.0D0, 141.0D0, 135.0D0, 125.0D0, 149.0D0/
      DATA  AIR( 19), AIR( 20), AIR( 21), AIR( 22), AIR( 23), AIR( 24)
     +    / 170.0D0, 170.0D0, 158.0D0, 133.0D0, 114.0D0, 140.0D0/
      DATA  AIR( 25), AIR( 26), AIR( 27), AIR( 28), AIR( 29), AIR( 30)
     +    / 145.0D0, 150.0D0, 178.0D0, 163.0D0, 172.0D0, 178.0D0/
      DATA  AIR( 31), AIR( 32), AIR( 33), AIR( 34), AIR( 35), AIR( 36)
     +    / 199.0D0, 199.0D0, 184.0D0, 162.0D0, 146.0D0, 166.0D0/
      DATA  AIR( 37), AIR( 38), AIR( 39), AIR( 40), AIR( 41), AIR( 42)
     +    / 171.0D0, 180.0D0, 193.0D0, 181.0D0, 183.0D0, 218.0D0/
      DATA  AIR( 43), AIR( 44), AIR( 45), AIR( 46), AIR( 47), AIR( 48)
     +    / 230.0D0, 242.0D0, 209.0D0, 191.0D0, 172.0D0, 194.0D0/
      DATA  AIR( 49), AIR( 50), AIR( 51), AIR( 52), AIR( 53), AIR( 54)
     +    / 196.0D0, 196.0D0, 236.0D0, 235.0D0, 229.0D0, 243.0D0/
      DATA  AIR( 55), AIR( 56), AIR( 57), AIR( 58), AIR( 59), AIR( 60)
     +    / 264.0D0, 272.0D0, 237.0D0, 211.0D0, 180.0D0, 201.0D0/
      DATA  AIR( 61), AIR( 62), AIR( 63), AIR( 64), AIR( 65), AIR( 66)
     +    / 204.0D0, 188.0D0, 235.0D0, 227.0D0, 234.0D0, 264.0D0/
      DATA  AIR( 67), AIR( 68), AIR( 69), AIR( 70), AIR( 71), AIR( 72)
     +    / 302.0D0, 293.0D0, 259.0D0, 229.0D0, 203.0D0, 229.0D0/
      DATA  AIR( 73), AIR( 74), AIR( 75), AIR( 76), AIR( 77), AIR( 78)
     +    / 242.0D0, 233.0D0, 267.0D0, 269.0D0, 270.0D0, 315.0D0/
      DATA  AIR( 79), AIR( 80), AIR( 81), AIR( 82), AIR( 83), AIR( 84)
     +    / 364.0D0, 347.0D0, 312.0D0, 274.0D0, 237.0D0, 278.0D0/
      DATA  AIR( 85), AIR( 86), AIR( 87), AIR( 88), AIR( 89), AIR( 90)
     +    / 284.0D0, 277.0D0, 317.0D0, 313.0D0, 318.0D0, 374.0D0/
      DATA  AIR( 91), AIR( 92), AIR( 93), AIR( 94), AIR( 95), AIR( 96)
     +    / 413.0D0, 405.0D0, 355.0D0, 306.0D0, 271.0D0, 306.0D0/
      DATA  AIR( 97), AIR( 98), AIR( 99), AIR(100), AIR(101), AIR(102)
     +    / 315.0D0, 301.0D0, 356.0D0, 348.0D0, 355.0D0, 422.0D0/
      DATA  AIR(103), AIR(104), AIR(105), AIR(106), AIR(107), AIR(108)
     +    / 465.0D0, 467.0D0, 404.0D0, 347.0D0, 305.0D0, 336.0D0/
      DATA  AIR(109), AIR(110), AIR(111), AIR(112), AIR(113), AIR(114)
     +    / 340.0D0, 318.0D0, 362.0D0, 348.0D0, 363.0D0, 435.0D0/
      DATA  AIR(115), AIR(116), AIR(117), AIR(118), AIR(119), AIR(120)
     +    / 491.0D0, 505.0D0, 404.0D0, 359.0D0, 310.0D0, 337.0D0/
      DATA  AIR(121), AIR(122), AIR(123), AIR(124), AIR(125), AIR(126)
     +    / 360.0D0, 342.0D0, 406.0D0, 396.0D0, 420.0D0, 472.0D0/
      DATA  AIR(127), AIR(128), AIR(129), AIR(130), AIR(131), AIR(132)
     +    / 548.0D0, 559.0D0, 463.0D0, 407.0D0, 362.0D0, 405.0D0/
      DATA  AIR(133), AIR(134), AIR(135), AIR(136), AIR(137), AIR(138)
     +    / 417.0D0, 391.0D0, 419.0D0, 461.0D0, 472.0D0, 535.0D0/
      DATA  AIR(139), AIR(140), AIR(141), AIR(142), AIR(143), AIR(144)
     +    / 622.0D0, 606.0D0, 508.0D0, 461.0D0, 390.0D0, 432.0D0/
!
      CALL IPRINT(IPRT)
!
      NFAC = 2
      N = 144
!
      NPAR = 3
      PAR(1) = 0.000
      PAR(2) = 0.395
      PAR(3) = 0.615
!
      DO 10 I = 1, N
        Y(I) = LOG(AIR(I))
   10 CONTINUE
!
!     RUN SIMPLE TEST OF AIME
!
      WRITE (IPRT,1000)
      WRITE (IPRT,1100)
      CALL AIME (Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK)
      WRITE (IPRT,2000) IERR
!
!     RUN SIMPLE TEST OF AIMF
!
      WRITE (IPRT,1200)
      CALL AIMF (Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK)
      WRITE (IPRT,2000) IERR
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT ('1*CH13')
 1100 FORMAT (' SIMPLE TEST OF AIME')
 1200 FORMAT ('1SIMPLE TEST OF AIMF')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
!XDCKLT
      SUBROUTINE XDCKLT(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA
      INTEGER
     +   I,IPRT,IXM,J,JSTOP,LDSMIN,M,N,NETA,NPAR,NPRT,NROW,NTAU,
     +   NTEST
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(10),SCALE(10),XM(200,2)
      INTEGER
     +   NETTST(6),NROTST(5),NTATST(6)
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DCKLS,DCKLS1,DCKLSC,DRV4A,DRV4B,IPRINT,LDSCMP,MDL4,SETRV
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG10
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        *
!     EXTERNAL DRV4A, DRV4B
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER J, JSTOP
!        *
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL4
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NETTST(6)
!        VARIOUS TEST VALUES FOR NETA.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NROTST(5)
!        VARIOUS TEST VALUES FOR NROW.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTATST(6)
!         VARIOUS TEST VALUES FOR NTAU.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     DOUBLE PRECISION PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION SCALE(10)
!        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION XM(200,2)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      CALL IPRINT(IPRT)
!
!     SET PARAMETER VALUES
!
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
      CALL LDSCMP(5, 0, 2*NPAR+1, 0, 0, 0, 'D',
     +            N*NPAR+NPAR+N, LDSMIN)
!
      IF (LDSMIN.LE.LDSTAK) GO TO 5
!
      WRITE (IPRT, 1020) LDSMIN
      RETURN
!
    5 CONTINUE
!
!     CREATE INDEPENDENT VARIABLE
!
      DELTA = 0.0625D0
      XM(1,1) = 0.0D0
      DO 10 I=2,N
         XM(I,1) = XM(I-1,1) + DELTA
   10 CONTINUE
!
      NTEST = 0
!
!
!     TEST VARIOUS VALUES OF NETA AND NTAU
!
      SCALE(1) = 0.0D0
!
      NETTST(1) = -1
      NETTST(2) = 0
      NETTST(3) = 1
      NETTST(4) = 2
!
      NETTST(5) = -LOG10(D1MACH(4))
      NETTST(6) = NETTST(5) + 1
!
      NTATST(1) = -1
      NTATST(2) = 0
      NTATST(3) = 1
!
      JSTOP = 3
!
      DO 30 I=1,6
!
         NTATST(4) = NETTST(I)/4
         IF (I.LE.5) THEN
            NTATST(5) = (NETTST(I)-1)/2
            NTATST(6) = NTATST(5) + 1
         END IF
!
         IF (I.EQ.5) JSTOP = 6
!
         DO 20 J=1,JSTOP
!
            NTEST = NTEST + 1
            WRITE (IPRT,1130) NTEST
            WRITE (IPRT,1100)
            WRITE (IPRT,1040)
            WRITE (IPRT,1060) NETTST(I), NTATST(J), SCALE(1), NROW, NPRT
            WRITE (IPRT,1000)
            IERR = -1
            CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSTAK,
     +         NETTST(I), NTATST(J), SCALE, NROW, NPRT)
            WRITE (IPRT,1050) IERR
            WRITE (IPRT,1140) NETTST(I), NTATST(J), SCALE(1), NROW, NPRT
!
   20    CONTINUE
!
   30 CONTINUE
!
!     SUPPRESS OUTPUT
!
      NPRT = 0
!
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1100)
      WRITE (IPRT,1040)
      WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROW, NPRT
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSTAK, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROW, NPRT
!
!     LARGE CALCULATION ERROR PROBLEM
!
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
      PAR(3) = 10.0D0**NTATST(5)
      SCALE(1) = 0.0D0
      NROW = 51
!
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1100)
      WRITE (IPRT,1070)
      WRITE (IPRT,1080)
      WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROW, NPRT
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSTAK, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROW, NPRT
!
!     NEARLY ZERO DERIVATIVE
!
      NROW = 50
!
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1100)
      WRITE (IPRT,1070)
      WRITE (IPRT,1090)
      WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROW, NPRT
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSTAK, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROW, NPRT
!
!     INCORRECTLY CODED DERIVATIVE
!
!     SIMPLE EXAMPLE
!
!     SET PARAMETER VALUES
!
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1110)
      WRITE (IPRT,1040)
      WRITE (IPRT,1000)
      IERR = -1
      CALL DCKLS(XM, N, M, IXM, MDL4, DRV4B, PAR, NPAR, LDSTAK)
      WRITE (IPRT,1050) IERR
!
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1110)
      WRITE (IPRT,1040)
      WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROW, NPRT
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4B, PAR, NPAR, LDSTAK, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROW, NPRT
!
!     SUPPRESS OUTPUT
!
      NPRT = 0
!
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1110)
      WRITE (IPRT,1040)
      WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROW, NPRT
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4B, PAR, NPAR, LDSTAK, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROW, NPRT
!
!     LARGE CALCULATION ERROR PROBLEM
!
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
!
      PAR(3) = 10.0D0**NTATST(5)
      NROW = 26
!
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1110)
      WRITE (IPRT,1070)
      WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROW, NPRT
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4B, PAR, NPAR, LDSTAK, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROW, NPRT
!
      PAR(4) = 0.75D0
      NROW = 1
!
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1110)
      WRITE (IPRT,1070)
      WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROW, NPRT
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4B, PAR, NPAR, LDSTAK, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROW, NPRT
!
!     CHECK VARIOUS VALUES OF NROW
!
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
!
      CALL SETRV(XM(1,1), N, 0.0D0)
      NROTST(1) = -1
      NROTST(2) = 0
      NROTST(3) = 1
      NROTST(4) = N
      NROTST(5) = N + 1
!
      DO 40 I=1,5
!
         NTEST = NTEST + 1
         WRITE (IPRT,1130) NTEST
         WRITE (IPRT,1110)
         WRITE (IPRT,1120)
         WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROTST(I), NPRT
         WRITE (IPRT,1010)
         IERR = -1
         CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4B, PAR, NPAR, LDSTAK,
     +      NETA, NTAU, SCALE, NROTST(I), NPRT)
         WRITE (IPRT,1050) IERR
         WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROTST(I), NPRT
!
   40 CONTINUE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (15H TEST OF DCKLS )
 1010 FORMAT (15H TEST OF DCKLSC)
 1020 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1040 FORMAT (15H SIMPLE EXAMPLE)
 1050 FORMAT (29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1060 FORMAT (19H INPUT   -  NETA = , I5, 9H, NTAU = , I5,
     +   13H, SCALE(1) = , G15.8, 9H, NROW = , I5, 9H, NPRT = , I5)
 1070 FORMAT (32H LARGE CALCULATION ERROR PROBLEM)
 1080 FORMAT (16H ZERO DERIVATIVE)
 1090 FORMAT (23H NEARLY ZERO DERIVATIVE)
 1100 FORMAT (27H CORRECTLY CODED DERIVATIVE)
 1110 FORMAT (' INCORRECTLY CODED DERIVATIVE FOR PARAMETERS 1, 2 AND 4')
 1120 FORMAT (' ALL INDEPENDENT VARIABLES EQUAL TO ZERO')
 1130 FORMAT (43H1DERIVATIVE CHECKING SUBROUTINE TEST NUMBER, I5)
 1140 FORMAT (19H OUTPUT  -  NETA = , I5, 9H, NTAU = , I5,
     +   13H, SCALE(1) = , G15.8, 9H, NROW = , I5, 9H, NPRT = , I5//)
      END
!PPMN
      SUBROUTINE PPMN (YM, YMMISS, X, XMISS, N, M, IYM, ISCHCK, ISYM,
     +  LISYM, ISIZE, NOUT, YMN, YMX, XMN, XMX, MISS, ILOG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN ROUTINE FOR PAGE PLOTS
!
!     WRITTEN BY  --
!                 JANET R. DONALDSON
!                 STATISTICAL ENGINEERING DIVISION/BOULDER
!                 NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!     INPUT ARGUMENTS - (IN ORDER OF USAGE)
!
!        X  THE N VECTOR OF OBSERVATIONS FOR THE X
!           COORDINATES
!       YM  THE N BY M MATRIX OF OBSERVATIONS FOR THE Y (VERTICAL)
!           COORDINATES
!           THE ITH COLUMN IS PLOTTED USING THE FOLLOWING SYMBOL
!               1 = A    2 = B    3 = C    4 = D
!               5 = E    6 = F    7 = G    8 = H
!               9 = I   10 = J   11 = K   12 = L
!              13 = M   14 = N   15 = O   16 = P
!              17 = Q   18 = R   19 = S   20 = T
!              21 = U   22 = V   23 = W   24 = Y
!              25 (AND ABOVE) = Z
!           THE NUMBERS 1 TO 9 INDICATE MULTIPLE POINTS ON A GIVEN
!           PLOT LOCATION, WHERE THE NUMBER INDICATES HOW MANY POINTS
!           ARE REPRESENTED
!           NOTE THAT  X  IS NOT USED AS A PLOTTING SYMBOL EXCEPT TO
!           INDICATE THAT MORE THAN 9 POINTS FELL ON THE SAME PLOT
!           LOCATION
!        N  THE INTEGER NUMBER OF OBSERVATIONS TO BE PLOTTED (IN EACH
!           COLUMN)
!        M  THE NUMBER OF COLUMNS IN THE YM ARRAY TO BE PLOTTED VERSUS X
!           FOR THE CASE OF A VECTOR YM, M MUST BE EQUAL TO 1
!    IYM  THE ACTUAL INTEGER VALUE OF THE ROW DIMENSION OF THE Y ARRAY
!           WHEN YM IS A VECTOR (M.EQ.1) IYM SHOULD BE SET EQUAL TO N
!   ISCHCK  THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     ISYM  THE N VECTOR OF INTEGERS DETERMINING THE PLOTTING SYMBOLS TO
!           USED FOR THE S SERIES OF PLOTS, WHERE
!               1 = +    2 = .    3 = *    4 = -
!               5 = A    6 = B    7 = C    8 = D
!               9 = E   10 = F   11 = G   12 = H
!              13 = I   14 = J   15 = K   16 = L
!              17 = M   18 = N   19 = O   20 = P
!              21 = Q   22 = R   23 = S   24 = T
!              25 = U   26 = V   27 = W   28 = Y
!              29 (AND ABOVE) = Z
!           THE NUMBERS 1 TO 9 INDICATE MULTIPLE POINTS ON A GIVEN
!           PLOT LOCATION, WHERE THE NUMBER INDICATES HOW MANY POINTS
!           ARE REPRESENTED
!           NOTE THAT  X  IS NOT USED AS A PLOTTING SYMBOL EXCEPT TO
!           INDICATE THAT MORE THAN 9 POINTS FELL ON THE SAME PLOT
!           LOCATION
!    ISIZE  THE INTEGER CODE FOR THE PLOT SIZE, WHERE
!           0 INDICATES A PLOT 100 COL BY 50 ROWS
!           1 INDICATES A PLOT 50 COL BY  50 ROWS
!     NOUT  THE INTEGER VALUE INDICATING HOW MANY OF THE POINTS WHICH
!           FELL OUTSIDE OF THE GRAPH LIMITS ARE TO BE LISTED
!           IF XLB.EQ.XUB AND YLB.EQ.YUB, NOUT SHOULD BE SET TO ZERO
!     XLB  THE MINIMUM VALUE OF X TO BE PLOTTED(IE, THE LOWER BOUND FOR
!           THE X AXIS), WHERE IF XLB=XUB THE ROUTINE WILL DETERMINE
!           THIS VALUE FROM THE MINIMUM VALUE OF THE X VECTOR
!     XUB  THE MAXIMUM VALUE OF X TO BE PLOTTED(IE, THE UPPER BOUND FOR
!           THE X AXIS), WHERE IF XLB=XUB THE ROUTINE WILL DETERMINE
!           THIS VALUE FROM THE MAXIMUM VALUE OF THE X VECTOR
!     YLB  THE MINIMUM VALUE OF Y TO BE PLOTTED(IE, THE LOWER BOUND FOR
!           THE Y AXIS), WHERE IF YLB=YUB THE ROUTINE WILL DETERMINE
!           THIS VALUE FROM THE MINIMUM VALUE OF THE Y VECTOR
!     YUB  THE MAXIMUM VALUE OF Y TO BE PLOTTED(IE, THE UPPER BOUND FOR
!           THE Y AXIS), WHERE IF YLB=YUB THE ROUTINE WILL DETERMINE
!           THIS VALUE FROM THE MAXIMUM VALUE OF THE Y VECTOR
!     ILOG  THE INTEGER INDICATOR VARIABLE USED TO DETERMINE WHETHER
!           THE Y AXIS SCALE IS TO BE LOG OR NOT
!           IF ILOG.EQ.0, THE SCALE IS NOT LOG
!           IF ILOG.NE.0, THE SCALE IS LOG
!
!
!     ADDITIONAL VARIABLES USED - (IN ALPHABETICAL ORDER)
!
!    ALINE  THE VECTOR OF THE CURRENT PLOT LINE
!   ALPHAI  THE PLOT AXIS SYMBOL I
!   AXISCH  THE Y A AXIS SYMBOL TO BE USED FOR THE CURRENT LINE,
!           EITHER I OR -
!   ALPHAX  THE PLOTTING SYMBOL X DESIGNATING MORE THAN 9 POINTS FELL ON
!           A SINGLE PLOTTING LOCATION
!    BLANK  THE PLOTTING SYMBOL BLANK
!     DELX  THE RANGE OF THE X AXIS
!     DELY  THE RANGE OF THE Y AXIS
!   HYPHEN  THE PLOT AXIS SYMBOL -
!       IC  THE COUNT OF THE NUMBER OF VALUES FALLING OUTSIDE OF THE
!           GRAPH BOUNDS
!     ICOL  THE COLUMN LOCATION FOR THE PLOT LINE
!     IOUT  THE MINIMUM OF NOUT OR 50, INDICATING HOW MANY OF THE
!           POINTS WHICH FELL OUTSIDE OF THE GRAPH LIMITS WILL ACTUALLY
!           BE LISTED
!   IPCODE  THE INTEGER CODE, USED IN ERROR CHECKING, WHICH DETERMINES
!           WHICH PLOT ROUTINE HAS BEEN CALLED
!      IPR  THE UNIT NUMBER OF THE PRINTER
!    ITEST  THE INDICATOR VARIABLE FOR WHETHER THE X AXIS LABELS ARE
!           PRINTED IN E OR F FORMAT
!      KSS  AN INTEGER VECTOR USED IN DETERMINING THE PLOT SYMBOL
!           NEEDED
!       NN  THE NUMBER OF Y LABELS TO BE LISTED ON THE LEFT AXIS,
!           (DEPENDENT ON THE GRAPH SIZE)
!   NUMCOL  THE INTEGER VALUE OF THE NUMBER OF COLUMNS IN THE GRAPH
!   NUMLAB  THE INTEGER NUMBER OF X LABELS TO BE LISTED AT THE BOTTOM
!           OF THE GRAPH (DEPENDENT ON GRAPH SIZE)
!   NUMROW  THE INTEGER NUMBER OF ROWS IN THE GRAPH
!      SYM  THE VECTOR OF PLOT SYMBOL ASSIGNMENTS (SEE IS ABOVE)
!     SYM1  THE VECTOR OF INTEGER VALUES USED TO INDICATE MULTIPLE
!           POINTS ON THE SAME PLOT LOCATION
!     TEMP  THE ARRAY OF VALUES TO BE PRINTED WHICH FALL OUTSIDE THE
!           GRAPH LIMITS
!   XLABEL  THE VECTOR OF X AXIS LABELS
!       XMN  THE MINIMUM X VALUE TO BE PLOTTED, COMPUTED FROM DATA OR
!           ASSIGNED BY XLB
!   XWIDTH  THE VALUE OF AN INDIVIDUAL X AXIS GRAPH INTERVAL
!       XMX  THE MAXIMUM X VALUE TO BE PLOTTED, COMPUTED FROM DATA OR
!           ASSIGNED BY XUB
!   YLABEL  THE VALUE OF THE Y AXIS LABEL TO BE PRINTED
!   YLOWER  THE LOWER BOUND FOR Y VALUES TO BE PLOTTED ON THE CURRENT
!           LINE
!       YMN  THE MINIMUM Y VALUE TO BE PLOTTED, COMPUTED FROM DATA OR
!           ASSIGNED BY YLB
!   YUPPER  THE UPPER BOUND FOR Y VALUES TO BE PLOTTED ON THE CURRENT
!           LINE
!   YWIDTH  THE VALUE OF AN INDIVIDUAL Y AXIS GRAPH INTERVAL
!       YMX  THE MAXIMUM Y VALUE TO BE PLOTTED, COMPUTED FROM DATA OR
!           ASSIGNED BY YUB
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XMISS,XMN,XMX,YMN,YMX
      INTEGER
     +   ILOG,ISCHCK,ISIZE,IYM,LISYM,M,N,NOUT
      LOGICAL
     +   MISS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N),YM(IYM,M),YMMISS(M)
      INTEGER
     +   ISYM(LISYM)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELX,DELY,TN,TX,XDMN,XDMX,XWIDTH,XX,YDMN,YDMX,YL,YLOWER,
     +   YUPPER,YWIDTH,YY
      INTEGER
     +   I,IC,ICOL,IK,ILOGX,ILOGY,IOUT,IPRT,IROW,IT,ITEST,J,JCOL,K,
     +   L,NLABLX,NLABLY,NLU,NN,NUMCOL,NUMCP2,NUMROW
      CHARACTER
     +   ALPHAI*1,ALPHAX*1,AXISCH*1,BLANK*1,HYPHEN*1,FMT*4,
     +   XLFMT*205,XLFMT2*205
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   TEMP(50,2),XLABEL(20),YLABEL(20)
      INTEGER
     +   ALINE(105),ILOGXY(2),ISIZXY(2),ISPACE(20),KSS(101)
      CHARACTER
     +   CLINE(105)*1,ITEMP(50)*1,SYM(30)*1,SYM1(9)*1
!
!  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LOGLMT,PRTCNT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,LOG10,MAX,MIN
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER ALINE(105)
!     CHARACTER*1 ALPHAI, ALPHAX
!     CHARACTER*1 AXISCH
!     CHARACTER*1 BLANK
!     CHARACTER*1 CLINE(105)
!     DOUBLE PRECISION DELX, DELY
!     CHARACTER FMT*4
!        THE FORMAT FOR THE X-AXIS LABELS
!     CHARACTER*1 HYPHEN
!     INTEGER I, IC, ICOL, IERR, IK
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER ILOGX
!        THE VALUES OF P AS SPECIFIED BY ILOG.
!     INTEGER ILOGXY(2)
!        THE VALUES OF P AND Q AS SPECIFIED BY ILOG.
!     INTEGER ILOGY
!        THE VALUES OF Q AS SPECIFIED BY ILOG.
!     INTEGER IOUT
!     INTEGER IPRT, IROW
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISIZXY(2)
!     INTEGER ISPACE(20)
!        THE SPACING FOR THE X-AXIS LABELS
!     INTEGER ISYM(LISYM)
!     INTEGER IT
!     CHARACTER*1 ITEMP(50)
!     INTEGER ITEST
!     INTEGER IYM
!     INTEGER J, JCOL
!     INTEGER K
!     INTEGER KSS(101)
!     INTEGER L
!     INTEGER LISYM
!     INTEGER M
!     LOGICAL MISS
!     INTEGER N
!     INTEGER NLABLX, NLABLY, NLU
!     INTEGER NN, NOUT, NUMCOL, NUMCP2, NUMROW
!     CHARACTER*1 SYM(30), SYM1(9)
!     DOUBLE PRECISION TEMP(50, 2)
!     DOUBLE PRECISION TN, TX
!     DOUBLE PRECISION X(N)
!     DOUBLE PRECISION XDMN, XDMX
!        THE X-AXIS DATA LIMITS ACTUALLY USED.
!     DOUBLE PRECISION XLABEL(20)
!        THE X-AXIS LABLES.
!     CHARACTER XLFMT*205, XLFMT2*205
!        THE FORMATS USED TO PRINT THE X-AXIS
!     DOUBLE PRECISION XMISS, XMN, XMX, XWIDTH, XX
!     DOUBLE PRECISION YDMN, YDMX
!        THE Y-AXIS DATA LIMITS ACTUALLY USED.
!     DOUBLE PRECISION YL
!     DOUBLE PRECISION YLABEL(20)
!        THE Y-AXIS LABLES.
!     DOUBLE PRECISION YLOWER
!     DOUBLE PRECISION YM(IYM, M)
!     DOUBLE PRECISION YMMISS(M)
!     DOUBLE PRECISION YMN, YMX, YUPPER, YWIDTH, YY
!
      DATA BLANK/' '/,HYPHEN/'-'/,ALPHAI/'I'/,ALPHAX/'X'/
      DATA SYM( 1)/'+'/,SYM( 2)/'.'/,SYM( 3)/'*'/,SYM( 4)/'-'/,
     +     SYM( 5)/'A'/,SYM( 6)/'B'/,SYM( 7)/'C'/,SYM( 8)/'D'/,
     +     SYM( 9)/'E'/,SYM(10)/'F'/,SYM(11)/'G'/,SYM(12)/'H'/,
     +     SYM(13)/'I'/,SYM(14)/'J'/,SYM(15)/'K'/,SYM(16)/'L'/,
     +     SYM(17)/'M'/,SYM(18)/'N'/,SYM(19)/'O'/,SYM(20)/'P'/,
     +     SYM(21)/'Q'/,SYM(22)/'R'/,SYM(23)/'S'/,SYM(24)/'T'/,
     +     SYM(25)/'U'/,SYM(26)/'V'/,SYM(27)/'W'/,SYM(28)/'Y'/,
     +     SYM(29)/'Z'/,SYM(30)/'Z'/
      DATA SYM1(1)/'1'/,SYM1(2)/'2'/,SYM1(3)/'3'/,SYM1(4)/'4'/,
     +     SYM1(5)/'5'/,SYM1(6)/'6'/,SYM1(7)/'7'/,SYM1(8)/'8'/,
     +     SYM1(9)/'9'/
!
      CALL IPRINT(IPRT)
!
!     DEFINE THE NUMBER OF ROWS AND COLUMNS WITHIN THE PLOT
!
      CALL PRTCNT(MAX(0,ISIZE),2,ISIZXY)
      IF (ISIZXY(1).EQ.0) THEN
        NUMCOL=101
      ELSE
        NUMCOL = 51
      END IF
      IF (ISIZXY(2).EQ.0) THEN
        NUMROW = 51
      ELSE
        NUMROW = 26
      END IF
!
      NUMCP2 = NUMCOL + 2
      NN=(NUMROW-1)/5
!
!     ADJUST FOR LOG PLOTS IF NECESSARY AND FIND AXIS LABELS
!
      CALL PRTCNT (MAX(0,ILOG),2,ILOGXY)
      ILOGX = ILOGXY(1)
      ILOGY = ILOGXY(2)
      CALL LOGLMT (ILOGY, YMN, YMX, YLABEL, NUMROW, 5, DELY, YWIDTH,
     +  NLABLY, YDMN, YDMX)
      CALL LOGLMT (ILOGX, XMN, XMX, XLABEL, NUMCOL, 10, DELX, XWIDTH,
     +  NLABLX, XDMN, XDMX)
!
!     TEST FOR FORMAT FOR Y AXIS LABELS
!
      ITEST=0
      TX=YMX
      TN=YMN
      IF (ILOGY.EQ.0) GO TO 190
      TX=10.0D0**TX
      TN=10.0D0**TN
  190 IF ((TN .GE. 1.0D6 .OR. TN .LE. (-1.0D5)) .OR.
     +   (ABS(TN).GT.0.0D0.AND.ABS(TN).LT.0.001D0)) ITEST=1
      IF ((TX .GE. 1.0D6 .OR. TX .LE. (-1.0D5)) .OR.
     +   (ABS(TX).GT.0.0D0.AND.ABS(TX).LT.0.001D0)) ITEST=1
!
!     BLANK OUT THE PLOT PRINT LINE CLINE
!
      DO 200 ICOL=1,105
         CLINE(ICOL)=BLANK
  200 CONTINUE
!
!     WRITE OUT THE TOP HORIZONTAL AXIS OF THE PLOT
!
      DO 210 ICOL=1,NUMCOL
         CLINE(ICOL)=HYPHEN
  210 CONTINUE
      CLINE(1)=ALPHAI
      IF (ILOGX.EQ.0) THEN
        DO 215 ICOL=11,NUMCOL,10
           CLINE(ICOL)=ALPHAI
  215   CONTINUE
      ELSE
        DO 216 IK = NLABLX, 1, -1
          ICOL = ((LOG10(XLABEL(IK))-XMN)/XWIDTH)+1.5D0
          CLINE(ICOL) = ALPHAI
  216   CONTINUE
      END IF
      CLINE(NUMCOL+1)=HYPHEN
      CLINE(NUMCOL+2)=BLANK
      WRITE (IPRT, 1004) HYPHEN,(CLINE(I),I=1,NUMCOL),HYPHEN
      DO 217 ICOL=1,105
         CLINE(ICOL)=BLANK
  217 CONTINUE
!
!     DETERMINE AND WRITE OUT THE PLOT POSITIONS ONE LINE AT A TIME.
!
      L=-1
      IK=1
      DO 320 IROW=1,NUMROW
         L=L+1
         IF (L.GT.NN) L=1
         DO 235 ICOL=1,NUMCOL
            ALINE(ICOL)=0
            KSS(ICOL)=0
  235    CONTINUE
         YUPPER=YMX+(1.5D0-IROW)*YWIDTH
         YLOWER=YMX+(0.5D0-IROW)*YWIDTH
      DO 255 I = 1, N
!
         IF (MISS .AND. MVCHK(X(I), XMISS)) GO TO 255
!
         IF (ILOGX.EQ.0) THEN
           XX=X(I)
         ELSE
           XX=LOG10(X(I))
         END IF
         DO 250 J=1,M
!
            IF (MISS .AND. MVCHK(YM(I,J), YMMISS(J))) GO TO 250
               IF (ILOGY.EQ.0) THEN
                 YY=YM(I,J)
               ELSE
                 YY=LOG10(YM(I,J))
               END IF
               IF (((YLOWER.LE.YY).AND.(YY.LT.YUPPER)) .AND.
     +             ((YY.GE.YDMN).AND.(YY.LE.YDMX))) THEN
                  IF ((XX.GE.XDMN) .AND. (XX.LE.XDMX)) THEN
                     ICOL=((XX-XMN)/XWIDTH)+1.5D0
                     ALINE(ICOL) = ALINE(ICOL) + 1
!     SIMPLE PLOTTING (PLT)
                     KSS(ICOL)=1
!     SYMBOL PLOTS (SPLT)
                     IF (ISCHCK .EQ. 1) KSS(ICOL) = ISYM(I)
!     MULTIPLE PLOTS (MPLT)
                     IF (ISCHCK .EQ. 2) KSS(ICOL) = J + 4
                     IF (KSS(ICOL).GT.30) KSS(ICOL)=30
                     IF (KSS(ICOL).LT.1) KSS(ICOL)=1
                  END IF
               END IF
  250       CONTINUE
  255    CONTINUE
         DO 290 ICOL=1,NUMCOL
            IF (ALINE(ICOL).EQ.0) THEN
              CLINE(ICOL)=BLANK
            ELSE
              IF (ALINE(ICOL).EQ.1) THEN
                K=KSS(ICOL)
                CLINE(ICOL)=SYM(K)
              ELSE
                IF (ALINE(ICOL).LE.9) THEN
                  CLINE(ICOL)=SYM1(ALINE(ICOL))
                ELSE
                  CLINE(ICOL)=ALPHAX
                END IF
              END IF
            END IF
  290    CONTINUE
         CLINE(NUMCOL+2)=HYPHEN
         AXISCH=HYPHEN
         IF (ILOGY.EQ.0) THEN
           YL = YLABEL(IK)
         ELSE
           YL = LOG10(YLABEL(IK))
         END IF
         IF ((YLOWER.GT.YL) .OR. (YL.GE.YUPPER)) THEN
!
!          PRINT LINE WITHOUT LABEL
!
           CLINE(NUMCP2)=ALPHAI
           WRITE(IPRT, 1008) ALPHAI, (CLINE(ICOL), ICOL=1,NUMCP2)
         ELSE
!
!          PRINT LINE WITH LABEL
!
           IF (ITEST.EQ.0) THEN
             WRITE(IPRT,1006) YLABEL(IK),AXISCH,
     +         (CLINE(ICOL),ICOL=1,NUMCP2)
           ELSE
             WRITE(IPRT,1007) YLABEL(IK),AXISCH,
     +         (CLINE(ICOL),ICOL=1,NUMCP2)
           END IF
           IK=IK+1
         END IF
  320 CONTINUE
!
!     WRITE OUT THE BOTTOM HORIZONTAL AXIS AND THE X AXIS LABELS.
!
      DO 330 ICOL=1,NUMCOL
         CLINE(ICOL)=HYPHEN
  330 CONTINUE
      CLINE(1)=ALPHAI
      IF (ILOGX.EQ.0) THEN
        NLU = NLABLX+1
        DO 340 ICOL=NUMCOL,1,-10
           CLINE(ICOL)=ALPHAI
           NLU = NLU - 1
           ISPACE(NLU) = 1
  340   CONTINUE
      ELSE
        JCOL = 1
        CLINE(JCOL) = ALPHAI
        NLU = NLABLX
        DO 345 IK = NLABLX, 1, -1
          ICOL = ((LOG10(XLABEL(IK))-XMN)/XWIDTH)+1.5
          CLINE(ICOL) = ALPHAI
          IF (ICOL-JCOL.GE.10) THEN
            ISPACE(NLU) = ICOL-JCOL-9
            NLU = NLU - 1
            XLABEL(NLU) = XLABEL(IK)
            JCOL = ICOL
          END IF
  345   CONTINUE
      END IF
      CLINE(NUMCOL+1)=HYPHEN
      CLINE(NUMCOL+2)=BLANK
!
      WRITE(IPRT, 1004) HYPHEN, (CLINE(ICOL), ICOL = 1, NUMCP2)
!
!     CHECK X-AXIS LABELS FOR FORMAT
!
      FMT = 'F9.4'
      DO 350 I=1,NLABLX
        IF (((ABS(XLABEL(I)).GT.0.0D0) .AND. (ABS(XLABEL(I)).LT.0.01D0))
     +      .OR.
     +      ((XLABEL(I).GE.1.0D4) .OR. (XLABEL(I).LE.(-1.0D3)))) THEN
          FMT = 'D9.4'
           GO TO 355
         END IF
  350 CONTINUE
  355 CONTINUE
      WRITE(XLFMT2,1000) NLABLX-NLU
      WRITE(XLFMT,XLFMT2) (FMT, ISPACE(I), I=NLABLX,NLU+1,-1), FMT
      WRITE(IPRT, XLFMT) (XLABEL(I),I=NLABLX,NLU,-1)
!
!     DETERMINE VALUES TO BE LISTED IF OUTSIDE OF AXIS LIMITS.
!
      IC = 0
      IOUT = MIN(NOUT,50)
      IF (IOUT.GE.0) THEN
        DO 180 I = 1, N
!
          IF (MISS .AND. MVCHK(X(I), XMISS)) GO TO 180
!
          IF (ILOGX.EQ.0) THEN
            XX = X(I)
          ELSE
            XX = LOG10(X(I))
          END IF
           DO 175 J=1,M
!
              IF (MISS .AND. MVCHK(YM(I,J), YMMISS(J))) GO TO 175
!
              IF (ILOGY.EQ.0) THEN
                YY = YM(I,J)
              ELSE
                YY = LOG10(YM(I,J))
              END IF
!
              IF (((YDMN .LE. YY) .AND. (YY .LE. YDMX)) .AND.
     +            ((XDMN .LE. XX) .AND. (XX .LE. XDMX))) GO TO 175
!
              IC=IC+1
              IF (IC.GT.IOUT) GO TO 175
              TEMP(IC,1)=X(I)
              TEMP(IC,2)=YM(I,J)
              IT=1
              IF (ISCHCK.EQ.1) IT=ISYM(I)
              IF (ISCHCK.EQ.2) IT=J+4
              IF (IT.LT.1) IT=1
              IF (IT.GT.30) IT=30
              ITEMP(IC) = SYM(IT)
  175      CONTINUE
  180   CONTINUE
      END IF
!
!     CHECK FOR POINTS OUTSIDE OF GRAPH LIMITS AND LIST IF REQUESTED
!     THE TOTAL NUMBER OF POINTS TO BE PLOTTED IS N*M
!
      IF (IC.EQ.0) RETURN
      IF (IOUT .LT. 0) RETURN
      WRITE (IPRT, 1010) IC
      IF (IOUT.LE.0) RETURN
      WRITE (IPRT, 1016)
      IF (IC.LE.IOUT) GO TO 360
      IC=IOUT
      WRITE(IPRT, 1011) IOUT
      GO TO 370
  360 WRITE(IPRT, 1012)
  370 WRITE(IPRT, 1013) (TEMP(I,1), TEMP(I,2), ITEMP(I), I = 1, IC)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT ('(''(14X'',', I2, '('', '', A4, '','', I2, ''X''),',
     +  ''', '', A4, '')'')')
 1004 FORMAT (' ',16X, A1, 105A1)
 1006 FORMAT(4X,F11.4,1X,A1,1X,105A1)
 1007 FORMAT (' ', E14.7, 1X, A1, 1X, 105A1)
 1008 FORMAT (' ', 15X, A1, 1X, 105A1)
 1010 FORMAT(16X,6H**NOTE,I4,43H VALUES FELL OUTSIDE THE SPECIFIED LIMIT
     +S**)
 1011 FORMAT ('1', 15X, 10HTHE FIRST , I3,
     +   35H VALUES OUTSIDE THE PLOT LIMITS ARE/ 22X,
     + 33H X               Y            SYM)
 1012 FORMAT ('1', 15X, 38HTHE VALUES OUTSIDE THE PLOT LIMITS ARE/ 22X,
     + 33H X               Y            SYM)
 1013 FORMAT (15X,2E15.8,9X,A1)
 1016 FORMAT (16X, 22HSEE NEXT PAGE FOR LIST)
!
      END
!SETRA
      SUBROUTINE SETRA(ARRAY, IM, M, N, VALUE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     SETS THE FIRST N ROWS AND M COLUMNS OF THE ARRAY
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VALUE
      INTEGER
     +   IM,M,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ARRAY(IM,M)
!
!  LOCAL SCALARS
      INTEGER
     +   I,J
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ARRAY(IM,M)
!        ARRAY FOR WHICH ELEMENTS WILL BE SET
!     INTEGER I
!        *
!     INTEGER IM
!        ACTUAL FIRST DIMENSION OF ARRAY IN CALLING PROGRAM
!     INTEGER J
!        *
!     INTEGER M
!        NUMBER OF COLUMNS TO SET
!     INTEGER N
!        NUMBER OF ROWS TO SET
!     DOUBLE PRECISION VALUE
!        VALUE TO WHICH THE ELEMENTS ARE TO BE SET
!
!
      DO 20 I=1,N
         DO 10 J=1,M
            ARRAY(I,J) = VALUE
   10    CONTINUE
   20 CONTINUE
      RETURN
      END
!MPP
      SUBROUTINE MPP(YM, X, N, M, IYM)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH MULTIPLE Y-AXIS VALUES (SHORT CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IYM,M,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   ILOG,IPRT,ISCHCK,ISIZE,LISYM,NOUT
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(IYM,M)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'P',       'P',       ' ',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      XMISS = 1.0D0
      MULTI = .TRUE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 2
      ISIZE = -1
      NOUT = 0
      MISS = .FALSE.
      LISYM = 1
!
      CALL PPCNT (YM, YM, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL MPP (YM, X, N, M, IYM)')
      END
!CENTER
      SUBROUTINE CENTER (Y, N, YC)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER ROUTINE FOR CENTERING THE OBSERVED SERIES Y,
!     RETURNING THE CENTERED SERIES IN YC.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*),YC(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,HEAD
!
!  LOCAL ARRAYS
      CHARACTER
     +   LN(8)*1,NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CNTR,EISGE,IPRINT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT NUMBER USED FOR OUTPUT.
!     CHARACTER*1 LN(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YC(N)
!        THE VECTOR IN WHICH THE CENTERED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'C',       'E',       'N',       'T',       'E',       'R'/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /'N',' ',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 2, 1, HEAD, ERR01, LN)
      IF (.NOT. ERR01) GO TO 5
!
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
    5 CONTINUE
!
      CALL CNTR (Y, N, YC)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   29H       CALL CENTER (Y, N, YC))
      END
!PPL
      SUBROUTINE PPL(YM, X, N, ILOG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT (LOG OPTION).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   IPRT,ISCHCK,ISIZE,IYM,LISYM,M,NOUT
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'P',       'P',       'L',       ' ',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      YMMISS(1) = 1.0D0
      XMISS = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 0
      ISIZE = -1
      NOUT = 0
      MISS = .FALSE.
      LISYM = 1
!
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL PPL (Y, X, N, ILOG)')
      END
!GFARFS
      SUBROUTINE GFARFS (PHI, IAR, NF, FMIN, FMAX, GAIN, PHAS, FREQ,
     +   NPRT, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE TO COMPUTE THE GAIN
!     FUNCTION OF AN AUTOREGRESSIVE FILTER (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   IAR,LDSTAK,NF,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),GAIN(*),PHAS(*),PHI(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,FMN,FMX,YPLTMN,YPLTMX
      INTEGER
     +   IGFERR,IO,IPRT,ISORT,LDSMIN,NALL0,NORD,XORD,YORD
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD,SYM
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   LIAR(8)*1,LLDS(8)*1,LNF(8)*1,NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,GFAEST,GFORD,GFOUT,IPRINT,LDSCMP,SETFRQ,STKCLR,
     +   STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03
!        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION FMAX, FMIN
!        THE MINIMUM AND MAXIMUM FREQUENCY FOR WHICH THE GAIN
!        FUNCTION IS TO BE ESTIMATED.
!     DOUBLE PRECISION FMN, FMX
!        THE FREQUENCY RANGE ACTUALLY USED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        HAS BEEN ESTIMATED.
!     DOUBLE PRECISION GAIN(NF)
!        THE VECTOR IN WHICH THE GAIN FUNCTION ESTIMATES ARE
!        STORED.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IGFERR
!        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
!        TO HAVE PRODUCED REASONABLE RESULTS.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION IN ISTAK FOR
!        THE ARRAY USED FOR SORTING.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     CHARACTER*1 LIAR(8), LLDS(8), LNF(8)
!        THE ARRAYS CONTAINING THE NAMES OF CHECKED VARIABLES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        IS TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NORD
!        THE NUMBER OF POINTS TO BE PLOTTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     DOUBLE PRECISION PHAS(NF)
!        THE ARRAY IN WHICH THE PHASE OF THE FILTER IS RETURNED.
!     DOUBLE PRECISION PHI(IAR)
!        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL SYM
!        THE VARIABLE USED TO INDICATE WHETHER THE GAIN FUNCTION
!        COMPUTED WAS FOR A SYMMETRIC OR AUTOREGRESSIVE FILTER.
!     INTEGER XORD
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE X COORDINATES FOR THE GAIN FUNCTION PLOT
!     INTEGER YORD
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE Y COORDINATES FOR THE GAIN FUNCTION PLOT
!     DOUBLE PRECISION YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'G',       'F',       'A',       'R',       'F',       'S'/
      DATA
     +  LIAR(1), LIAR(2), LIAR(3), LIAR(4), LIAR(5), LIAR(6),
     +  LIAR(7), LIAR(8) /'I', 'A', 'R', ' ', ' ', ' ', ' ', ' '/
      DATA
     +  LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6), LLDS(7),
     +  LLDS(8) /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
      DATA
     +  LNF(1), LNF(2), LNF(3), LNF(4), LNF(5), LNF(6), LNF(7), LNF(8)
     + /  'N',   'F',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
      IO = 1
      IF (NPRT .EQ. 0) IO = 0
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LIAR, IAR, 1, 1, HEAD, ERR01, LIAR)
!
      CALL EISGE(NMSUB, LNF, NF, 1, 1, HEAD, ERR02, LNF)
!
      IF (ERR02) GO TO 10
!
      CALL LDSCMP(3*IO, 0, NF, 0, 0, 0, 'D', 2*IO*NF, LDSMIN)
!
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR03, LLDS)
!
      IF (ERR01.OR.ERR02.OR.ERR03) GO TO 10
      GO TO 20
!
   10   IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
        RETURN
!
   20 CONTINUE
!
      IF (NPRT .NE. 0) THEN
        CALL STKSET (LDSTAK, 4)
        NALL0 = STKST(1)
      ELSE
        NALL0 = 0
      END IF
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      SYM = .FALSE.
!
      DELTA = 1.0D0
!
!     SET FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO BE ESTIMATED
!
      FMN = MAX(FMIN, 0.0D0)
      FMX = MIN(FMAX, 0.5D0)
      IF (FMN.GE.FMX) THEN
        FMN = 0.0D0
        FMX = 0.5D0
      END IF
      CALL SETFRQ (FREQ, NF, 2, FMN, FMX, DELTA)
!
!     COMPUTE THE GAIN FUNCTION
!
      CALL GFAEST (PHI, IAR, NF, FREQ, GAIN, PHAS, DELTA)
!
      IF (NPRT .EQ. 0) RETURN
!
!     SET VARIOUS POINTERS FOR THE PLOTTING ARRAYS
!
      XORD = STKGET(NF, 4)
      YORD = STKGET(NF, 4)
!
      ISORT = STKGET(NF, 2)
!
      IF (IERR .EQ. 1) GO TO 10
!
!     PLOT THE RESULTS
!
      CALL GFORD (FREQ, GAIN, ISTAK(ISORT), NF, RSTAK(XORD),
     +   RSTAK(YORD), NORD, YPLTMN, YPLTMX, NPRT, IGFERR)
      CALL GFOUT (RSTAK(XORD), RSTAK(YORD), NORD, FREQ, PHAS, NF,
     +   IAR, SYM, FMN, FMX, YPLTMN, YPLTMX, NPRT, IGFERR, NMSUB)
!
      CALL STKCLR(NALL0)
!
      IF (IERR .EQ. 1) GO TO 10
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL GFARFS (PHI, IAR,'/
     + '      +             NF, FMIN, FMAX, GAIN, PHAS, FREQ, NPRT,',
     + ' LDSTAK)')
      END
!SVPL
      SUBROUTINE SVPL(YM, N, NS, ISYM, ILOG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH USER CONTROL OF THE PLOT SYMBOL USED (LOG PLOT OPTION).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
      INTEGER
     +   ISYM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,IPRT,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'V',       'P',       'L',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      M = 1
      IYM = N
      MULTI = .FALSE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 1
      ISIZE = -1
      MISS = .FALSE.
      LISYM = N
      IRLIN = -1
      IBAR = 0
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YM, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL SVPL (Y, N, NS, ISYM, ILOG)')
      END
!CPYMSS
      SUBROUTINE CPYMSS (N, M, X, IX, Y, IY)
!
!     LATEST REVISION  -  03/15/90  (JRD
!
!     THIS ROUTINE COPIES THE N BY M ELEMENTS OF MATRIX X TO
!     MATRIX Y.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IX,IY,M,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(IX,*),Y(IY,*)
!
!  LOCAL SCALARS
      INTEGER
     +   I,J
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER IX
!        THE FIRST DIMENSION OF THE MATRIX X.
!     INTEGER IY
!        THE FIRST DIMENSION OF THE MATRIX Y.
!     INTEGER J
!        AN INDEX VALUE.
!     INTEGER M
!        THE NUMBER OF COLUMNS OF DATA TO BE COPIED FROM MATRIX X.
!     INTEGER N
!        THE NUMBER OF ROWS OF DATA TO BE COPIED FROM MATRIX X.
!     DOUBLE PRECISION X(IX,M)
!        THE MATRIX TO BE COPIED FROM.
!     DOUBLE PRECISION Y(IY,M)
!        THE MATRIX TO BE COPIED TO.
!
!
      DO 20 J = 1, M
         DO 10 I = 1, N
            Y(I,J) = X(I,J)
   10    CONTINUE
   20 CONTINUE
!
      RETURN
!
      END
!FITEXT
      SUBROUTINE FITEXT(RSS, YSS, EXACT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS WHETHER THE FIT IS EXACT TO MACHINE
!     PRECISION.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSS,YSS
      LOGICAL
     +   EXACT
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLRS,RSSTST
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL EXACT
!        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
!        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     DOUBLE PRECISION RSS
!        THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION RSSTST
!        THE VALUE FOR TESTING WHETHER THE RESIDUAL SUM OF SQUARES
!        IS ZERO (TO WITHIN MACHINE PRECISION).
!     DOUBLE PRECISION YSS
!        THE SUM OF SQUARES OF THE DEPENDENT VARIABLE Y.
!
      FPLRS = D1MACH(4)
!
!     TEST FOR EXACT FIT
!
      EXACT = .FALSE.
      RSSTST = RSS
      IF (YSS.GT.0.0D0) RSSTST = RSSTST / YSS
      RSSTST = SQRT(RSSTST)
      IF (RSSTST.LT.10.0D0*FPLRS) EXACT = .TRUE.
!
      RETURN
!
      END
!NLFIN
      SUBROUTINE NLFIN(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, IFIXD,
     +   PAR, NPAR, NPARE, RES, PAGE, WIDE, IPTOUT, NDIGIT, RSSHLF, RSD,
     +   PV, SDPV, SDRES, RD, VCVL, LVCVL, D, NLHDR, IVCVPT, ISKULL)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPLETES THE ANALYSIS FOR THE NONLINEAR
!     LEAST SQUARES ESTIMATION ROUTINES ONCE THE ESTIMATES
!     HAVE BEEN FOUND.
!
!     REFERENCES
!
!        DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1979), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, (BEING REVISED).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD,RSSHLF
      INTEGER
     +   IVCVPT,IXM,LVCVL,LWT,M,N,NDIGIT,NNZW,NPAR,NPARE
      LOGICAL
     +   PAGE,WEIGHT,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PAR(NPAR),PV(N),RD(NPARE),RES(N),SDPV(N),SDRES(N),
     +   VCVL(LVCVL),WT(LWT),XM(IXM,M),Y(N)
      INTEGER
     +   IFIXD(NPAR),IPTOUT(NDIGIT),ISKULL(10)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL NLHDR
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   COND,RSS,YSS
      INTEGER
     +   IDF
      LOGICAL
     +   EXACT,PRTFSM
!
!  EXTERNAL SUBROUTINES
      EXTERNAL NLCMP,NLOUT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION COND
!        THE CONDITION NUMBER OF D.
!     DOUBLE PRECISION D(N,NPAR)
!        THE DERIVATIVE OF THE MODEL (JACOBIAN).
!     LOGICAL EXACT
!        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
!        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
!     INTEGER IDF
!        THE DEGREES OF FREEDOM IN THE FIT.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) HAVE BEEN HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) HAVE BEEN OPTIMIZED.
!     INTEGER IPTOUT(NDIGIT)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER ISKULL(10)
!        AN ERROR MESSAGE INDICATOR VARIABLE.
!     INTEGER IVCVPT
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
!        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
!        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                       *INVERSE(HESSIAN)
!        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)
!        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LVCVL
!        THE LENGTH OF THE VECTOR CONTAINING
!        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     EXTERNAL NLHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
!        PARAMETERS ARE STORED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     LOGICAL PRTFSM
!        THE VARIABLE USED TO INDICATE WHETHER ANY OF THE SUMMARY
!        INFORMATION IS TO BE PRINTED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RD(NPARE)
!        THE DIAGONAL ELEMENTS OF THE R MATRIX OF THE Q - R
!        FACTORIZATION OF D.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSSHLF
!        HALF THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     DOUBLE PRECISION RSS
!        THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION VCVL(LVCVL)
!        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!     DOUBLE PRECISION YSS
!        THE SUM OF SQUARES OF THE DEPENDENT VARIABLE Y.
!
!
!     COMPUTE RETURNED AND/OR PRINTED VALUES.
!
      CALL NLCMP (Y, WEIGHT, WT, LWT, N, NPAR, NPARE, RES,
     +   D, RD, COND, VCVL, LVCVL, NNZW, IDF, RSSHLF, RSS, RSD, YSS,
     +   EXACT, PV, SDPV, SDRES, ISKULL)
!
      PRTFSM = ((IPTOUT(3).NE.0) .OR. (IPTOUT(4).NE.0) .OR.
     +   (IPTOUT(5).NE.0) .OR. (IERR.NE.0))
!
!     PRINT SUMMARY INFORMATION IF DESIRED OR IF AN ERROR FLAG
!     HAS BEEN SET.
!
      IF (PRTFSM) CALL NLOUT(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM,
     +   IFIXD, PAR, NPAR, NPARE, RES, IPTOUT, NDIGIT, PAGE, IDF, COND,
     +   RSS, RSD, YSS, EXACT, PV, SDPV, SDRES, VCVL, LVCVL, IVCVPT,
     +   ISKULL, NLHDR, WIDE)
      RETURN
!
      END
!DCKFPA
      SUBROUTINE DCKFPA(J, D, PAR, NPAR, ETA, TAU, MDL, XM, N,
     +   NROW, M, IXM, PV, PVTEMP, MSG, LMSG, FD, PARMX, STP, PVPSTP,
     +   CURVE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CHECK WHETHER FINITE PRECISION ARITHMETIC COULD POSSIBLY BE THE
!     PROBLEM
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CURVE,D,ETA,FD,PARMX,PV,PVPSTP,STP,TAU
      INTEGER
     +   IXM,J,LMSG,M,N,NPAR,NROW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PVTEMP(N),XM(IXM,M)
      INTEGER
     +   MSG(LMSG)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   TEMP
      LOGICAL
     +   LARGE
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,SIGN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CURVE
!        A MEASURE OF THE CURVATURE IN THE MODEL.
!     DOUBLE PRECISION D
!        THE SCALAR IN WHICH ROW   NROW   OF THE DERIVATIVE
!        MATRIX WITH RESPECT TO THE JTH UNKNOWN PARAMETER
!        IS STORED.
!     DOUBLE PRECISION ETA
!        THE RELATIVE NOISE IN THE MODEL
!     DOUBLE PRECISION FD
!        THE FORWARD DIFFERENCE QUOTIENT DERIVATIVE WITH RESPECT TO THE
!        JTH PARAMETER
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARTIAL DERIVATIVE BEING EXAMINED.
!     LOGICAL LARGE
!        AN INDICATOR VALUE INDICATING WHETHER THE RECOMMENDED
!        INCREASE IN THE STEP SIZE WOULD BE GREATER THAN PARMX.
!     INTEGER LMSG
!        THE LENGTH OF THE VECTOR MSG.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER MSG(LMSG)
!        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION PARMX
!        THE MAXIMUM OF THE CURRENT PARAMETER ESTIMATE AND THE
!        TYPICAL VALUE OF THAT PARAMETER
!     DOUBLE PRECISION PV
!        THE SCALAR IN WHICH THE PREDICTED VALUE FROM THE MODEL FOR
!        ROW   NROW   IS STORED.
!     DOUBLE PRECISION PVPSTP
!        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
!        BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J) + STP.
!     DOUBLE PRECISION PVTEMP(N)
!        THE VECTOR OF PREDICTED VALUES FROM THE MODEL.
!     DOUBLE PRECISION STP
!        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FINITE DIFFERENC
!        DERIVATIVE
!     DOUBLE PRECISION TAU
!        THE AGREEMENT TOLERANCE.
!     DOUBLE PRECISION TEMP
!        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
!        PARAMETER IS STORED.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
!     CHECK WHETHER FINITE PRECISION COULD BE THE PROBLEM
!
      IF (ABS(STP*(FD-D)) .GE.
     +   10.0D0*ETA*(ABS(PV)+ABS(PVPSTP))) THEN
!
!     DISCREPANCY BETWEEN NUMERICAL AND ANALYTICAL DERIVATIVES CANNOT
!     BE ACCOUNTED FOR BY FINITE PRECISION ARITHMETIC
!
         MSG(1) = 2
         MSG(J+1) = 2
         RETURN
!
      END IF
!
!     FINITE PRECISION ARITHMETIC COULD BE THE PROBLEM.
!
!     TRY A LARGER STEP SIZE
!
      STP = (ETA*(ABS(PV)+ABS(PVPSTP))*SIGN(1.0D0,PAR(J))/
     +   (TAU*ABS(D))+PAR(J)) - PAR(J)
!
      LARGE = .FALSE.
!
      IF (ABS(STP).GT.PARMX) THEN
         STP = PARMX*SIGN(1.0D0,PAR(J))
         LARGE = .TRUE.
      END IF
!
!     CALCULATE NUMERICAL DERIVATIVE USNG NEW, LARGER, STEPSIZE
!
      TEMP = PAR(J)
      PAR(J) = PAR(J) + STP
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVTEMP)
      PAR(J) = TEMP
!
      PVPSTP = PVTEMP(NROW)
!
      FD = (PVPSTP-PV)/STP
!
!     CHECK FOR AGREEMENT
!
      IF ((ABS(FD-D)).LE.2.0D0*TAU*ABS(D)) THEN
!
!     FORWARD DIFFERENCE QUOTIENT AND ANALYTIC DERIVATIVES AGREE FOR
!     THIS STEP SIZE
!
         RETURN
      END IF
!
!     FORWARD DIFFERENCE QUOTIENT AND ANALYTIC DERIVATIVES STILL
!     DISAGREE
!
!     CHECK IF CURVATURE IS THE PROBLEM
!
      IF (ABS(CURVE*STP) .LT. ABS(FD-D) .AND. (.NOT. LARGE)) THEN
!
!        CURVATURE COULDNT BE THE CULPRIT
!
             MSG(1) = 2
             MSG(J+1) = 2
             RETURN
      ELSE
!
!        CURVATURE MAY BE THE CULPRIT
!
             IF (MSG(1).EQ.0) MSG(1) = 1
             IF (LARGE) MSG(J+1) = 6
             IF (.NOT. LARGE) MSG(J+1) = 1
             RETURN
      END IF
!
      END
!UASEST
      SUBROUTINE UASEST (IAR, VAR, PHI, NF, FREQ, DELTA, SPCA, LPHI,
     +   ISPC)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CALCULATES THE AUTOREGRESSIVE SPECTRUM.  IT IS
!        MODELED AFTER SUBROUTINE UASEC BY DICK JONES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,VAR
      INTEGER
     +   IAR,ISPC,LPHI,NF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),PHI(LPHI),SPCA(ISPC)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ARG,EI,ER,EXI,EXR,EXRTMP,PI,TI,TR
      INTEGER
     +   I,J
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
!
!  INTRINSIC FUNCTIONS
      INTRINSIC COS,SIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ARG
!        THE ARGUMENT FOR THE SINE AND COSINE FUNCTIONS USED IN
!        CALCULATIONS OF THE SPECTRUM.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION EI, ER, EXI, EXR, EXRTMP
!        'COMPLEX' VARIABLES USED IN THE COMPUTATIONS.
!     DOUBLE PRECISION FREQ(NF)
!        THE ARRAY CONTAINING THE FREQUENCIES AT WHICH THE SPECTRUM
!        IS TO BE COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER ISPC
!        THE LENGTH OF THE ARRAY SPCA.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER LPHI
!        THE LENGTH OF THE ARRAY PHI.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     DOUBLE PRECISION PHI(LPHI)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     DOUBLE PRECISION PI
!        THE VALUE OF PI.
!     DOUBLE PRECISION SPCA(ISPC)
!        THE ARRAY IN WHICH THE AUTOREGRESSIVE SPECTRUM IS STORED.
!     DOUBLE PRECISION TI, TR
!        A VARIABLE USED IN THE COMPUTATIONS.
!     DOUBLE PRECISION VAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED ORDER (IAR).
!
      CALL GETPI(PI)
!
      DO 20 J=1,NF
         SPCA(J) = DELTA * VAR
         IF (IAR.GE.1) THEN
            IF (DELTA.EQ.1.0D0) THEN
               IF (FREQ(J).EQ.0.0D0) THEN
                  ER = 1.0D0
                  EI = 0.0D0
               ELSE IF (FREQ(J).EQ.0.25D0) THEN
                  ER = 0.0D0
                  EI = 1.0D0
               ELSE IF (FREQ(J).EQ.0.5D0) THEN
                  ER = -1.0D0
                  EI = 0.0D0
               ELSE
                  ARG = 2.0D0 * PI * DELTA * FREQ(J)
                  ER = COS(ARG)
                  EI = SIN(ARG)
               END IF
            ELSE
               ARG = 2.0D0 * PI * DELTA * FREQ(J)
               ER = COS(ARG)
               EI = SIN(ARG)
            END IF
            EXR = 1.0D0
            EXI = 0.0D0
            TR = 1.0D0
            TI = 0.0D0
            DO 10 I=1,IAR
               EXRTMP = EXR*ER - EXI*EI
               EXI = EXR*EI + EXI*ER
               EXR = EXRTMP
               TR = TR - PHI(I) * EXR
               TI = TI - PHI(I) * EXI
   10       CONTINUE
            SPCA(J) = SPCA(J)/(TR*TR + TI*TI)
         END IF
   20 CONTINUE
      RETURN
      END
!DIF
      SUBROUTINE DIF (Y, N, YF, NYF)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PERFORMS A FIRST DIFFERENCE FILTERING OPERATION,
!     RETURNING THE FILTERED SERIES IN YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N,NYF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*),YF(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IAR,IPRT
      LOGICAL
     +   ERR01,HEAD
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PHI(1)
      CHARACTER
     +   LN(8)*1,NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,FLTAR,IPRINT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     CHARACTER*1 LN(8)
!        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES N.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     DOUBLE PRECISION PHI(1)
!        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'D',       'I',       'F',       ' ',       ' ',       ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 3, 1, HEAD, ERR01, LN)
!
!
      IF (.NOT. ERR01) GO TO 10
!
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   10 CONTINUE
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      IAR = 1
      PHI(1) = 1.0D0
!
      CALL FLTAR (Y, N, IAR, PHI, YF, NYF)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   31H       CALL DIF (Y, N, YF, NYF))
      END
!DEMODS
      SUBROUTINE DEMODS (Y, N, FD, FC, K, AMPL, PHAS, NDEM, NPRT,
     +  LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE TO DEMODULATE SERIES
!     Y AT FREQUENCY FD, TO APPLY A LOW PASS FILTER WITH CUTOFF
!     FREQUENCY FC, AND TO EXTRACT THE AMPLITUDE AND PHASE COMPONENTS
!     OF THE RESULTING FILTERED SERIES (LONG CALL).
!
!     WRITTEN BY  -  PETER BLOOMFIELD
!                    FOURIER ANALYSIS OF TIME SERIES- AN
!                       INTRODUCTION
!                    JOHN WILEY AND SONS, NEW YORK, 1976
!                    PAGE 147
!     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
!                                STATISTICAL ENGINEERING DIVISION
!                                NATIONAL BUREAU OF STANDARDS
!                                BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC,FD
      INTEGER
     +   K,LDSTAK,N,NDEM,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AMPL(*),PHAS(*),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   TEMP
      INTEGER
     +   HLP,IO,IPRT,LDSMIN,NALL0,PHASE
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,ERR06,ERR07,HEAD
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      CHARACTER
     +   LFC(8)*1,LFD(8)*1,LK(8)*1,LKIN(8)*1,LLDS(8)*1,LN(8)*1,
     +   LNM1(8)*1,LONE(8)*1,NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DEMDRV,EISGE,EISII,ERIODD,ERSII,ERSLFS,IPRINT,LDSCMP,
     +   DCOPY,STKCLR,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AMPL(N)
!        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05, ERR06, ERR07
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION FC
!        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
!     DOUBLE PRECISION FD
!        THE DEMODULATION FREQUENCY.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER HLP
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE ARRAY IN WHICH THE LOW PASS FILTER COEFFICIENTS ARE
!        STORED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER K
!        THE USER SUPPLIED NUMBER OF TERMS TO BE USED FOR THE LOW
!        PASS FILTER.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LFC(8), LFD(8), LK(8), LKIN(8), LLDS(8), LN(8),
!    *  LNM1(8), LONE(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
!        WAS CALLED.
!     INTEGER NDEM
!        THE NUMBER OF VALUES IN THE DEMODULATED SERIES, I.E., IN
!        THE AMPLITUDE AND PHASE ARRAYS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF NPRT
!        IS ZERO, NO OUTPUT IS GIVEN, OTHERWISE OUTPUT IS PROVIDED.
!     DOUBLE PRECISION PHAS(N)
!        THE ARRAY IN WHICH THE PRIMARY PHASE ESTIMATES ARE RETURNED.
!     INTEGER PHASE
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE ARRAY CONTAINING THE PRIMARY AND SECONDARY PHASE ESTIMATES.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION TEMP
!        A TEMPORARY VARIABLE USED FOR TYPE CONVERSION.
!     DOUBLE PRECISION Y(N)
!        THE INPUT ARRAY CONTAINING THE OBSERVED SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'D',       'E',       'M',       'O',       'D',       'S'/
      DATA
     +  LFC(1), LFC(2), LFC(3), LFC(4), LFC(5), LFC(6), LFC(7), LFC(8)
     + /  'F',   'C',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LFD(1), LFD(2), LFD(3), LFD(4), LFD(5), LFD(6), LFD(7), LFD(8)
     + /  'F',   'D',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LKIN(1), LKIN(2), LKIN(3), LKIN(4), LKIN(5), LKIN(6), LKIN(7),
     +  LKIN(8) /  '(',   '1',   '/',   'K',   ')',   ' ',   ' ',   ' '/
      DATA
     +  LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6), LLDS(7),
     +  LLDS(8) /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LNM1(1), LNM1(2), LNM1(3), LNM1(4), LNM1(5), LNM1(6), LNM1(7),
     +  LNM1(8) /  '(',   'N',   '-',   '1',   ')',   ' ',   ' ',   ' '/
      DATA
     +  LONE(1), LONE(2), LONE(3), LONE(4), LONE(5), LONE(6), LONE(7),
     +  LONE(8) /  'O',   'N',   'E',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     PERFORM ERROR CHECKING ON INPUT DATA.
!
      IERR = 0
      HEAD = .TRUE.
!
      IF (NPRT.EQ.0) THEN
        IO = 0
      ELSE
        IO = 1
      END IF
!
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
!
      CALL ERSII(NMSUB, LFD, FD,
     +           0.0D0, 0.5D0, 2, HEAD, ERR02, LFD, LFD)
!
      ERR03 = .TRUE.
      IF (.NOT. ERR01)
     +  CALL EISII(NMSUB, LK, K, 1, N-1, 1, HEAD, ERR03, LONE, LNM1)
!
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR04)
!
      ERR05 = .TRUE.
      IF ((.NOT. ERR02) .AND. (.NOT. ERR03) .AND. (.NOT. ERR04)) THEN
         TEMP = K
         CALL ERSII(NMSUB, LFC, FC, 1.0D0/TEMP, FD, 1, HEAD, ERR05,
     +              LKIN, LFD)
      END IF
!
      ERR06 = .TRUE.
      IF ((.NOT. ERR03) .AND. (.NOT. ERR04) .AND. (.NOT. ERR05))
     +   CALL ERSLFS(NMSUB, FC, K, HEAD, ERR06)
!
      IF (ERR01 .OR. ERR06) GO TO 10
!
      CALL LDSCMP(2, 0, 0, 0, 0, 0, 'D', K + IO*2*N, LDSMIN)
!
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR07, LLDS)
!
!
      IF (ERR02 .OR. ERR03 .OR. ERR04 .OR. ERR05 .OR. ERR07) GO TO 10
      GO TO 20
!
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   20 CONTINUE
      CALL STKSET (LDSTAK, 4)
      NALL0 = STKST(1)
!
      HLP = STKGET(K, 4)
      IF (NPRT.EQ.0) THEN
         PHASE = 1
      ELSE
         PHASE = STKGET(2*N, 4)
      END IF
!
      IF (IERR .EQ. 1) GO TO 10
!
      IF (NPRT .NE. 0) THEN
!
         CALL DEMDRV(Y, N, FD, FC, K, RSTAK(HLP), AMPL,
     +      RSTAK(PHASE), N, NDEM, NPRT, NMSUB)
         CALL DCOPY(NDEM, RSTAK(PHASE), 1, PHAS, 1)
      ELSE
         CALL DEMDRV(Y, N, FD, FC, K, RSTAK(HLP), AMPL,
     +      PHAS, N, NDEM, NPRT, NMSUB)
      END IF
!
      CALL STKCLR(NALL0)
!
      IF (IERR .EQ. 1) GO TO 10
!
      RETURN
!
!     FORMAT STATEMENT
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL DEMODS (Y, N, FD, FC, K,'/
     +   '      +             AMPL, PHAS, NDEM, NPRT, LDSTAK)')
!
      END
!PGMMN
      SUBROUTINE PGMMN (YFFT, N, NFFT, IEXTND, NF, PER, LPER, YAXIS,
     +   FREQ, LFREQ, NPRT, NMSUB)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS THE MAIN ROUTINE FOR COMPUTING THE RAW PERIODOGRAM.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IEXTND,LFREQ,LPER,N,NF,NFFT,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(LFREQ),PER(LPER),YAXIS(LFREQ),YFFT(NFFT)
      CHARACTER
     +   NMSUB(6)*1
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   YEXTND
      INTEGER
     +   I,N1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN,PGMEST,PGORD,PGOUT,SETFRQ
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION FREQ(LFREQ)
!        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
!        INTEGRATED SPECTRUM VALUES ARE STORED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IEXTND
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
!        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
!        USED TO EXTEND THE SERIES.
!     INTEGER LFREQ
!        THE LENGTH OF THE ARRAY FREQ.
!     INTEGER LPER
!        THE LENGTH OF THE ARRAY PER.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .EQ.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
!        IF NPRT .GE.  2, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!     DOUBLE PRECISION PER(LPER)
!        THE ARRAY IN WHICH THE PERIODOGRAM IS STORED.
!     DOUBLE PRECISION YAXIS(LFREQ)
!        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
!     DOUBLE PRECISION YEXTND
!        THE VALUE USED TO EXTEND THE SERIES.
!     DOUBLE PRECISION YFFT(NFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!
      YEXTND = 0.0D0
      IF (IEXTND .NE. 0) CALL AMEAN (YFFT, N, YEXTND)
!
!     EXTEND THE PERIODOGRAM ARRAY BY ITS MEAN  OR ZERO TO THE
!     EXTENDED LENGTH NFFT.
!
      N1 = N + 1
!
      DO 40 I = N1, NFFT
         YFFT(I) = YEXTND
   40 CONTINUE
!
!     COMPUTE THE PERIODOGRAM.
!
      CALL PGMEST (YFFT, NFFT, NF, 1.0D0, PER, LPER)
!
!     SET FREQUENCIES FOR PERIODOGRAM VALUES
!
      CALL SETFRQ (FREQ, NF, 1, 0.0D0, 0.5D0, 1.0D0)
!
      IF (NPRT .EQ. 0) RETURN
!
!     SET Y CO-ORDINATES FOR PERIODOGRAM PLOT.
!
      CALL PGORD (PER, NF, YAXIS, NPRT)
!
!     PLOT PERIODOGRAM IF OUTPUT NOT SUPPRESSED
!
      CALL PGOUT (YAXIS, FREQ, NF, NPRT, NMSUB)
!
      RETURN
!
      END
!SPPM
      SUBROUTINE SPPM(YM, YMMISS, X, XMISS, N, ISYM)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH USER CONTROL OF PLOT SYMBOLS AND WITH MISSING
!     OBSERVATIONS (SHORT CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(1)
      INTEGER
     +   ISYM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   ILOG,IPRT,ISCHCK,ISIZE,IYM,LISYM,M,NOUT
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'P',       'P',       'M',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      M = 1
      IYM = N
      MULTI = .FALSE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 1
      ISIZE = -1
      NOUT = 0
      MISS = .TRUE.
      LISYM = N
!
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL SPPM (Y, YMISS, X, XMISS, N, ISYM)')
      END
!PLTCHK
      SUBROUTINE PLTCHK (YM, YMMISS, X, XMISS, N, M, IYM, MULTI,
     +   ILOG, YLB, YUB, XLB, XUB, NMSUB, MISS, XCHECK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS PLOT FAMILY ROUTINE CHECKS FOR ERRORS IN THE PARAMETER LISTS
!     OF THE MULTIPLE PLOT ROUTINES
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   ILOG,IYM,M,N
      LOGICAL
     +   MISS,MULTI,XCHECK
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   NV
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,ERR06,ERR07,ERR08,ERR09,HEAD
!
!  LOCAL ARRAYS
      INTEGER
     +   ILOGXY(2)
      CHARACTER
     +   LIYM(8)*1,LM(8)*1,LN(8)*1,LONE(8)*1,LX(8)*1,LXLB(8)*1,
     +   LXUB(8)*1,LY(8)*1,LYLB(8)*1,LYM(8)*1,LYUB(8)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,ERAGT,ERAGTM,ERSGT,ERVGT,ERVGTM,PRTCNT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05, ERR06, ERR07, ERR08,
!    1   ERR09
!        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        THE COMMON VARIABLE USED AS AN ERROR FLAG
!        IF = 0 THEN NO ERORRS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER ILOGXY(2)
!        ...
!     INTEGER IYM
!        ACTUAL ROW DIMENSION OF YM DECLARED IN USERS MAIN PROGRAM
!     CHARACTER*1 LIYM(8), LM(8), LN(8), LONE(8), LX(8), LXLB(8),
!    *  LXUB(8), LY(8), LYLB(8), LYM(8), LYUB(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE INPUT PARAMETERS(S)
!        CHECKED FOR ERRORS.
!     INTEGER M
!        THE NUMBER OF VECTORS IN YM
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        AN INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS AN M PREFIX (TRUE) OR NOT (FALSE).
!     INTEGER N
!        THE LENGTH OF THE VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND IN THE X AND Y AXIS ARRAYS.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     LOGICAL XCHECK
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER X-AXIS VALUES
!        ARE TO BE CHECKED (XCHECK = .TRUE.) OR NOT (XCHECK = .FALSE.)
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES.
!     DOUBLE PRECISION YMMISS(M)
!        THE MISSING VALUE CODE FOR EACH COLUMN OF YM.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +   LIYM(1),   LIYM(2),   LIYM(3),   LIYM(4),   LIYM(5),   LIYM(6)
     + /     'I',       'Y',       'M',       ' ',       ' ',       ' '/
      DATA LIYM(7), LIYM(8)
     +   /     ' ',     ' '/
      DATA
     +     LM(1),     LM(2),     LM(3),     LM(4),     LM(5),     LM(6)
     + /     'M',       ' ',       ' ',       ' ',       ' ',       ' '/
      DATA   LM(7),   LM(8)
     +   /     ' ',     ' '/
      DATA
     +     LN(1),     LN(2),     LN(3),     LN(4),     LN(5),     LN(6)
     + /     'N',       ' ',       ' ',       ' ',       ' ',       ' '/
      DATA   LN(7),   LN(8)
     +   /     ' ',     ' '/
      DATA   LONE(1),  LONE(2),  LONE(3),  LONE(4),  LONE(5),  LONE(6),
     +       LONE(7),  LONE(8)/'O', 'N', 'E', ' ', ' ', ' ', ' ', ' '/
      DATA
     +     LX(1),     LX(2),     LX(3),     LX(4),     LX(5),     LX(6)
     + /     'X',       ' ',       ' ',       ' ',       ' ',       ' '/
      DATA   LX(7),   LX(8)
     +   /     ' ',     ' '/
      DATA
     +   LXLB(1),   LXLB(2),   LXLB(3),   LXLB(4),   LXLB(5),   LXLB(6)
     + /     'X',       'L',       'B',       ' ',       ' ',       ' '/
      DATA LXLB(7), LXLB(8)
     +   /     ' ',     ' '/
      DATA
     +   LXUB(1),   LXUB(2),   LXUB(3),   LXUB(4),   LXUB(5),   LXUB(6)
     + /     'X',       'U',       'B',       ' ',       ' ',       ' '/
      DATA LXUB(7), LXUB(8)
     +   /     ' ',     ' '/
      DATA
     +     LY(1),     LY(2),     LY(3),     LY(4),     LY(5),     LY(6)
     + /     'Y',       ' ',       ' ',       ' ',       ' ',       ' '/
      DATA   LY(7),   LY(8)
     +   /     ' ',     ' '/
      DATA
     +   LYLB(1),   LYLB(2),   LYLB(3),   LYLB(4),   LYLB(5),   LYLB(6)
     + /     'Y',       'L',       'B',       ' ',       ' ',       ' '/
      DATA LYLB(7), LYLB(8)
     +   /     ' ',     ' '/
      DATA
     +    LYM(1),    LYM(2),    LYM(3),    LYM(4),    LYM(5),    LYM(6)
     + /     'Y',       'M',       ' ',       ' ',       ' ',       ' '/
      DATA  LYM(7),  LYM(8)
     +   /     ' ',     ' '/
      DATA
     +   LYUB(1),   LYUB(2),   LYUB(3),   LYUB(4),   LYUB(5),   LYUB(6)
     + /     'Y',       'U',       'B',       ' ',       ' ',       ' '/
      DATA LYUB(7), LYUB(8)
     +   /     ' ',     ' '/
!
!     COMMENCE BODY OF ROUTINE
!
      IERR = 0
      HEAD = .TRUE.
!
!     NUMBER OF POINTS MUST BE AT LEAST 1
!
      CALL EISGE(NMSUB, LN, N, 1, 2, HEAD, ERR01, LONE)
!
!     THERE MUST BE AT LEAST 1 COLUMN OF VECTORS
!
      CALL EISGE(NMSUB, LM, M, 1, 2, HEAD, ERR02, LONE)
!
!     THE ACTUAL LENGTH OF YM MUST EQUAL OR EXCEED THE NUMBER OF
!     OBSERVATIONS
!
      ERR03 = .TRUE.
      IF (.NOT.ERR01)
     +   CALL EISGE(NMSUB, LIYM, IYM, N, 3, HEAD, ERR03, LN)
!
!     IF THIS IS A LOG PLOT CHECK FOR NON-POSITIVE VALUES IN DATA
!
      IF (ERR01 .OR. ERR02 .OR. ERR03) IERR = 1
      IF (ILOG .LE. 0) RETURN
!
      ERR04 = .FALSE.
      ERR05 = .FALSE.
      ERR06 = .FALSE.
      ERR07 = .FALSE.
      ERR08 = .FALSE.
      ERR09 = .FALSE.
!
      CALL PRTCNT (MAX(0,ILOG),2,ILOGXY)
      IF ((ILOGXY(1).NE.0) .AND. XCHECK) THEN
        IF (.NOT.ERR01) THEN
!
!         IF X AXIS IS LOG SCALE, CHECK FOR NEGATIVE X AXIS VALUES
!
          IF (MISS) THEN
            CALL ERVGTM(NMSUB, LX, X, XMISS, N, 0.0D0, 0, HEAD, 1,
     +        NV, ERR04, LX)
          ELSE
            CALL ERVGT(NMSUB, LX, X, N, 0.0D0, 0, HEAD, 1, NV, ERR04,
     +        LX)
          END IF
        END IF
!
        IF (XLB.LT.XUB) THEN
!
!         CHECK FOR NEGATIVE PLOT BOUNDS
!
          CALL ERSGT(NMSUB, LXLB, XLB, 0.0D0, 1, HEAD, ERR05, LXLB)
          CALL ERSGT(NMSUB, LXUB, XUB, 0.0D0, 1, HEAD, ERR06, LXUB)
        END IF
      END IF
      IF (ILOGXY(2).NE.0) THEN
        IF ((.NOT.ERR01) .AND. (.NOT.ERR02) .AND. (.NOT.ERR03)) THEN
!
!         IF Y AYIS IS LOG SCALE, CHECK FOR NEGATIVE Y AYIS VALUES
!
          IF (MISS) THEN
            IF (MULTI) THEN
              CALL ERAGTM(NMSUB, LYM, YM, YMMISS, N, M, IYM, 0.0D0, 0,
     +           HEAD, 1, NV, ERR04, LYM)
            ELSE
              CALL ERVGTM(NMSUB, LY, YM, YMMISS(1), N, 0.0D0, 0, HEAD,
     +           1, NV, ERR04, LY)
            END IF
          ELSE
            IF (MULTI) THEN
              CALL ERAGT(NMSUB, LYM, YM, N, M, IYM, 0.0D0, 0, HEAD,
     +           1, NV, ERR04, LYM)
            ELSE
              CALL ERVGT(NMSUB, LY, YM, N, 0.0D0, 0, HEAD, 1,
     +           NV, ERR04, LY)
            END IF
          END IF
        END IF
!
        IF (YLB.LT.YUB) THEN
!
!         CHECK FOR NEGATIVE PLOT BOUNDS
!
          CALL ERSGT(NMSUB, LYLB, YLB, 0.0D0, 1, HEAD, ERR05, LYLB)
          CALL ERSGT(NMSUB, LYUB, YUB, 0.0D0, 1, HEAD, ERR06, LYUB)
        END IF
      END IF
!
      IF (ERR04 .OR. ERR05 .OR. ERR06 .OR. ERR07 .OR. ERR08 .OR. ERR09)
     +   IERR = 1
!
      RETURN
!
      END
!BFSVS
      SUBROUTINE BFSVS(CCOV, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS,
     +   FREQ, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
!     FOURIER SPECTRUM ANALYSIS OF SERIES WITH
!     USER INPUT OF THE COVARIANCES RATHER THAN THE SERIES
!     (LONG CALL)
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   ICCOV,ICSPC2,INDEX1,INDEX2,IPHAS,JCCOV,LDSTAK,N,NF,NPRT,NW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(*),CSPC2(*),FREQ(*),PHAS(*)
      INTEGER
     +   LAGS(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,YMISS1,YMISS2
      INTEGER
     +   CEVEN,CODD,I,IFP,INLPPC,IO,IPRT,ISYM,JNLPPC,LAGMAX,LAGMX1,
     +   LDSMIN,LPCV,LW,LWORK,LY,M,NALL0,SPCF1,SPCF2,W,WORK,XAXIS,
     +   YAXIS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12),Y1(1),Y2(1)
      INTEGER
     +   ISTAK(12),NLPPC(1,1,1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION CCOV(ICCOV,JCCOV,*)
!        THE COVARIANCES.
!     INTEGER CEVEN
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     INTEGER CODD
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CSPC2(ICSPC2,NW)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC(1,1,1)
!        THE NUMBER OF OBSERVATIONS IN EACH COVARIANCE ESTIMATE
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION PHAS(IPHAS,NW)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SPCF1, SPCF2
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     INTEGER W
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE WINDOWS.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR THE VECTOR WORK.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YMISS1, YMISS2
!        DUMMY VARIABLES.
!     DOUBLE PRECISION Y1(1)
!        THE FIRST TIME SERIES.
!     DOUBLE PRECISION Y2(1)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','V','S',' '/
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .TRUE.
      OPTION(4) = .TRUE.
!
!     SET MAXIMUM LAG VALUE TO BE USED (LAGMAX).
!
      LAGMAX = N - 1
      IF (NW.LE.0) GO TO 20
      LAGMAX = LAGS(1)
      DO 10 I=1,NW
         LAGMAX = MAX(LAGMAX,LAGS(I))
   10 CONTINUE
   20 CONTINUE
      LAGMX1 = LAGMAX + 1
!
      M = 2
!
!     COMPUTE THE MINIMUM ALLOWABLE STACK AREA (LDSMIN)
!
      IO = 1
      IF (NPRT.EQ.0) IO = 0
!
      CALL LDSCMP(8, 0, IO*4*NF, 0, 0, 0, 'D',
     +  3*LAGMAX+3+2*NF+IO*8*NF, LDSMIN)
!
      INLPPC = 1
      JNLPPC = 1
      LY = N
      LPCV = 4*NF
      LW = LAGMAX + 1
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING STACK ALLOCATIONS (NALL0).
!     SET THE STACK ALLOCATION TYPE (IFP)
!
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
!
      IFP = 4
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS
!
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         CEVEN = 1
         CODD = 1
         SPCF1 = 1
         SPCF2 = 1
         W = 1
         ISYM = W
         XAXIS = W
         YAXIS = W
      ELSE
         CEVEN = STKGET(LAGMX1,IFP)
         CODD = STKGET(LAGMX1,IFP)
         SPCF1 = STKGET(NF,IFP)
         SPCF2 = STKGET(NF,IFP)
         W = STKGET(LW,IFP)
         IF (NPRT.EQ.0) THEN
            ISYM = W
            XAXIS = W
            YAXIS = W
         ELSE
            ISYM = STKGET(LPCV,2)
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
         END IF
      END IF
!
      WORK = W
      LWORK = LW
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
      CALL BFSDRV(Y1, Y2, YMISS1, YMISS2, CCOV, NLPPC,
     +   RSTAK(SPCF1), RSTAK(SPCF2), NF, FMIN, FMAX, FREQ, N, NW,
     +   LAGMAX, LAGS, LAGMX1, RSTAK(WORK), LWORK, DELTA, ISTAK(ISYM),
     +   RSTAK(XAXIS), RSTAK(YAXIS), LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS,
     +   RSTAK(CODD), RSTAK(CEVEN), RSTAK(W), LW, NMSUB, LDSMIN,
     +   LDSTAK, OPTION, N, INLPPC, JNLPPC, LY)
!
      CALL STKCLR(NALL0)
!
!     CHECK FOR ERRORS
!
      IF (IERR.EQ.0) RETURN
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL BFSVS(CCOV, INDEX1, INDEX2, N, ICCOV, JCCOV,'/
     + '      +           NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     + '      +           CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)')
      END
!AMESTP
      SUBROUTINE AMESTP(XM, N, M, IXM, MDL, PAR, NPAR, STP,
     +   EXMPT, NETA, SCALE, LSCALE, NPRT, HDR, PAGE, WIDE, ISUBHD,
     +   HLFRPT, PRTFXD, IFIXED, LIFIXD, STPOUT, PVPAD)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CONTROLS THE STEP SIZE SELECTION PROCESS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   EXMPT
      INTEGER
     +   ISUBHD,IXM,LIFIXD,LSCALE,M,N,NETA,NPAR,NPRT,PVPAD
      LOGICAL
     +   HLFRPT,PAGE,PRTFXD,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),SCALE(*),STP(*),XM(IXM,*)
      INTEGER
     +   IFIXED(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL HDR,MDL,STPOUT
!
!  SCALARS IN COMMON
      DOUBLE PRECISION
     +   Q
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ETA,EXM,FPLRS,SCL,TAU
      INTEGER
     +   CD,FD,FDLAST,FDSAVE,IFAILJ,IFIXD,IFP,ITEMP,J,MXFAIL,NALL0,
     +   NDD,NDGT1,NEXMPT,NFAIL,NFAILJ,PARTMP,PV,PVMCD,PVNEW,PVPCD,
     +   PVSTP,PVTEMP
      LOGICAL
     +   HEAD
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      INTEGER
     +   STKGET,STKST
      EXTERNAL D1MACH,STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CPYVII,ETAMDL,SETIV,STKCLR,STPMN
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,INT,LOG10,MAX,MIN
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
      COMMON /NOTOPT/Q
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CD
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE CENTRAL DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION ETA
!        THE RELATIVE NOISE IN THE MODEL.
!     DOUBLE PRECISION EXM
!        THE PROPORTION OF OBSERVATIONS ACTUALLY USED FOR WHICH THE
!        COMPUTED NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE
!        EXEMPTED FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     DOUBLE PRECISION EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     INTEGER FD
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
!     INTEGER FDLAST
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!        FOR THE LAST STEP SIZE TRIED.
!     INTEGER FDSAVE
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!        FOR THE BEST STEP SIZE TRIED SO FAR.
!     DOUBLE PRECISION FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     EXTERNAL HDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFAILJ
!        THE STARTING LOCATION IN ISTAK FOR
!        THE ARRAY OF INDICATOR VARIABLES DESIGNATING WHETHER
!        THE SETP SIZE SELECTED WAS SATISFACOTRY FOR A GIVEN
!        OBSERVATION AND THE JTH PARAMETER.
!     INTEGER IFIXD
!        THE STARTING LOCATION IN /CSTAK/ OF VECTOR IFIXD CONTAINING
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IFP
!        AN INDICATOR FOR THE PRECISION OF THE STACK ALLOCATION TYPE,
!        WHERE IFP=3 INDICATES SINGLE AND IFP=4 INDICATES DOUBLE.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER ITEMP
!        THE STARTING LOCATION IN ISTAK FOR
!        A TEMPORARY STORAGE VECTOR.
!     INTEGER IXM
!        THE FIRST DIMENSION OF MATRIX XM.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER LIFIXD
!        THE DIMENSION OF VECTOR IFIXED.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER MXFAIL
!        THE MAXIMUM NUMBER OF FAILURES FOR ANY PARAMETER.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        NUMBER OF STACK ALLOCATIONS OUTSTANDING.
!     INTEGER NDD
!        THE NUMBER OF DECIMAL DIGITS CARRIED FOR A SINGLE
!        PRECISION DOUBLE PRECISION NUMBER.
!     INTEGER NDGT1
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL USED, EITHER
!        SET TO THE USER SUPPLIED VALUE OF NETA, OR COMPUTED
!        BY ETAMDL.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL RESULTS.
!     INTEGER NEXMPT
!        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
!        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
!        SIZE STILL BE CONSIDERED OK.
!     INTEGER NFAIL
!        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP SIZE
!        FOR THE PARAMETER DOES NOT MEET THE CRITERIA.
!     INTEGER NFAILJ
!        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP SIZE
!        FOR THE JTH PARAMETER DOES NOT MEET THE CRITERIA.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARTMP
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE MODIFIED MODEL PARAMETERS
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     INTEGER PV
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     INTEGER PVMCD
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     INTEGER PVNEW
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPNEW.
!     INTEGER PVPAD
!       ADDITIONAL WORKSPACE NEEDED IN PV FOR THE EVALUATION OF THE
!       MODEL.
!     INTEGER PVPCD
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCD.
!     INTEGER PVSTP
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STP(J).
!     INTEGER PVTEMP
!        THE STARTING LOCATION IN THE WORK AREA OF
!        A TEMPORY STORAGE LOCATION FOR PREDICTED VALUES BEGINS.
!     DOUBLE PRECISION Q
!        A DUMMY VARIABLE WHICH IS USED, ALONG WITH COMMON NOTOPT (NO
!        OPTIMIZATION), TO COMPUTE THE STEP SIZE.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SCL
!        THE ACTUAL TYPICAL SIZE USED.
!     DOUBLE PRECISION STP(NPAR)
!        THE SELECTED STEP SIZES.
!     EXTERNAL STPOUT
!        THE ROUTINE FOR PRINTING THE OUTPUT.
!     DOUBLE PRECISION TAU
!        THE AGREEMENT TOLERANCE.
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!
!
      NALL0 = STKST(1)
!
      FPLRS = D1MACH(4)
      IFP = 4
!
!     SET PRINT CONTROLS
!
      HEAD = .TRUE.
!
!     SUBDIVIDE WORK AREA
!
      IFIXD = STKGET(NPAR, 2)
      ITEMP = STKGET(N, 2)
      IFAILJ = STKGET(N, 2)
      NFAIL = STKGET(NPAR, 2)
!
      CD = STKGET(N, IFP)
      FD = STKGET(N, IFP)
      FDLAST = STKGET(N, IFP)
      FDSAVE = STKGET(N, IFP)
      PV = STKGET(N+PVPAD, IFP)
      PVMCD = STKGET(N+PVPAD, IFP)
      PVNEW = STKGET(N+PVPAD, IFP)
      PVPCD = STKGET(N+PVPAD, IFP)
      PVSTP = STKGET(N+PVPAD, IFP)
      PVTEMP = STKGET(N+PVPAD, IFP)
!
      IF (IERR .EQ. 1) RETURN
!
      PARTMP = CD
!
!     SET UP IFIXD
!
      IF (IFIXED(1).LT.0) CALL SETIV(ISTAK(IFIXD), NPAR, 0)
      IF (IFIXED(1).GE.0) CALL CPYVII(NPAR, IFIXED, 1, ISTAK(IFIXD), 1)
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      NDD = INT(-LOG10(FPLRS))
!
      IF ((NETA .GE. 2) .AND. (NETA .LE. NDD)) THEN
            ETA = 10.0D0 ** (-NETA)
            NDGT1 = NETA
      ELSE
            CALL ETAMDL(MDL, PAR, NPAR, XM, N, M, IXM, ETA, NDGT1,
     +         RSTAK(PARTMP), RSTAK(PVTEMP), 0)
      END IF
!
      TAU = MIN(ETA**0.25D0, 0.01D0)
!
      EXM = EXMPT
      IF ((EXM.LT.0.0D0) .OR. (EXM.GT.1.0D0)) EXM = 0.10D0
      NEXMPT = INT(EXM * N)
      IF (EXM .NE. 0.0D0) NEXMPT = MAX(NEXMPT, 1)
!
!     COMPUTE PREDICTED VALUES OF THE MODEL USING THE INPUT PARAMETER
!     ESTIMATES
!
      CALL MDL(PAR, NPAR, XM, N, M, IXM, RSTAK(PV))
!
      MXFAIL = 0
      NFAILJ = NFAIL
!
      DO 120 J = 1, NPAR
!
         IF (SCALE(1) .LE. 0.0D0) THEN
            IF (PAR(J) .EQ. 0.0D0) THEN
               SCL = 1.0D0
            ELSE
               SCL = ABS(PAR(J))
            END IF
         ELSE
            SCL = SCALE(J)
         END IF
!
         CALL STPMN(J, XM, N, M, IXM, MDL, PAR, NPAR, NEXMPT,
     +      ETA, TAU, SCL, STP(J), ISTAK(NFAILJ), ISTAK(IFAILJ),
     +      RSTAK(CD), ISTAK(ITEMP), RSTAK(FD), RSTAK(FDLAST),
     +      RSTAK(FDSAVE), RSTAK(PV), RSTAK(PVMCD), RSTAK(PVNEW),
     +      RSTAK(PVPCD), RSTAK(PVSTP), RSTAK(PVTEMP))
!
!     COMPUTE THE MAXIMUM NUMBER OF FAILURES FOR ANY PARAMETER
!
         MXFAIL = MAX(ISTAK(NFAILJ), MXFAIL)
!
!     PRINT RESULTS IF THEY ARE DESIRED
!
         IF ((NPRT.NE.0) .OR. (MXFAIL.GT.NEXMPT))
     +      CALL STPOUT(HEAD, N, EXM, NEXMPT, NDGT1, J, PAR, NPAR,
     +         STP, ISTAK(NFAIL), ISTAK(IFAILJ), SCALE,  LSCALE, HDR,
     +         PAGE, WIDE, ISUBHD, NPRT, PRTFXD, ISTAK(IFIXD))
!
         NFAILJ = NFAILJ + 1
!
  120 CONTINUE
!
      HLFRPT = .FALSE.
      IF ((NPRT.NE.0) .OR. (MXFAIL.GT.NEXMPT)) HLFRPT = .TRUE.
!
      IF (MXFAIL.GT.NEXMPT) IERR = 2
!
      CALL STKCLR(NALL0)
!
      RETURN
!
      END
!NLSWD
      SUBROUTINE NLSWD(Y, WT, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING ANALYTIC DERIVATIVES AND WEIGHTS
!     (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),WT(*),XM(*),Y(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IPRT,IVAPRX,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,
     +   LWT,MIT,NNZW,NPARE,NPRT
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SCALE(1),SDPV(1),SDRES(1),VCV(1,1)
      INTEGER
     +   IFIXED(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTA
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE DERIVATIVES WE
!        CHECKED OR NOT.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF IFIXED(I).EQ
!        THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(1)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(N)
!        THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','W','D',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      WEIGHT = .TRUE.
      SAVE = .FALSE.
!
      IDRVCK = 1
      MIT = -1
      STOPSS = -1.0D0
      STOPP = -1.0D0
      SCALE(1) = -1.0D0
      DELTA = -1.0D0
      NPRT = -1
      IFIXED(1) = -1
      IVAPRX = 0
      LIFIXD = 1
      LPV = 1
      LSCALE = 1
      LSDPV = 1
      LSDRES = 1
      LWT = N
      IVCV = 1
!
      CALL NLCNTA(Y, WT, LWT, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, IDRVCK, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSWD (Y, WT, XM, N, M, IXM, NLSMDL, NLSDRV,'/
     +   '      +            PAR, NPAR, RES, LDSTAK)')
      END
!DEMOUT
      SUBROUTINE DEMOUT(FD, FC, K, AMPL, PHASE, IPHASE, NDEM, NMSUB)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRODUCES THE OUTPUT FOR THE TIME SERIES
!     DEMODULATION ROUTINE.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC,FD
      INTEGER
     +   IPHASE,K,NDEM
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AMPL(NDEM),PHASE(IPHASE,2)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   PI,YMN,YMX
      INTEGER
     +   IPRT
      LOGICAL
     +   ERROR
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GETPI,IPRINT,VERSP,VPLMT,VPMN
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AMPL(NDEM)
!        THE ARRAY IN WHICH THE AMPLITUDES OF THE DEMODULATED SERIES
!        ARE STORED.
!     LOGICAL ERROR
!        AN ERROR FLAG
!     DOUBLE PRECISION FC, FD
!        THE CUTOFF FREQUENCY AND THE DEMODULATION FREQUENCY.
!     INTEGER IERR
!        THE ERROR FLAG
!     INTEGER IPHASE
!
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER ISYM(1)
!        A DUMMY ARRAY.
!     INTEGER K
!        THE NUMBER OF TERMS IN THE LOW PASS FILTER USED TO SMOOTH
!        THE DEMODULATED SERIES.
!     INTEGER NDEM
!        THE NUMBER OF VALUES IN THE DEMODULATED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE
!     DOUBLE PRECISION PHASE(IPHASE,2)
!        THE ARRAY CONTAINING THE PRIMARY AND SECONDARY PHASE VALUES.
!     DOUBLE PRECISION PI
!        THE VALUE OF PI.
!     DOUBLE PRECISION YMN, YMX
!
!
      CALL IPRINT(IPRT)
!
      CALL VERSP(.TRUE.)
!
      CALL GETPI(PI)
!
      WRITE (IPRT, 1000) FD, FC, K
!
      WRITE (IPRT, 1001)
      CALL VPLMT(AMPL, AMPL, NDEM, 1, NDEM, 0.0D0, 0.0D0,
     +  YMN, YMX, ERROR, NMSUB, .FALSE., 1)
!
      IF (ERROR) THEN
        IERR = 1
        RETURN
      ELSE
        CALL VPMN(AMPL, AMPL, NDEM, 1, NDEM, 1, 0, ISYM, 1, 0,
     +   YMN, YMX, 1.0D0, 1.0D0, .FALSE., 0, 1, 0)
      END IF
!
      WRITE (IPRT, 1002)
      CALL VERSP(.TRUE.)
      WRITE (IPRT, 1003)
      CALL VPMN(PHASE, PHASE, NDEM, 2, IPHASE, 1, 2, ISYM, 1, 0,
     +   -2.0D0*PI, 2.0D0*PI, 1.0D0, 1.0D0, .FALSE., 0, 0, 0)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/25H TIME SERIES DEMODULATION//
     +   26H DEMODULATION FREQUENCY IS, F10.8/
     +   26H CUTOFF FREQUENCY IS      , F10.8/
     +   38H THE NUMBER OF TERMS IN THE FILTER IS , I5///)
 1001 FORMAT (49H PLOT OF AMPLITUDE OF SMOOTHED DEMODULATED SERIES)
 1002 FORMAT ('1')
 1003 FORMAT (45H PLOT OF PHASE OF SMOOTHED DEMODULATED SERIES)
      END
!AMDRV
      SUBROUTINE AMDRV (MDLTS3, DRV, DONE, IFIXD, PAR, NPAR, XM, N, M,
     +   IXM, NRESTS, RESTS, D, WEIGHT, WT, LWT, STPT, LSTPT, SCL, LSCL)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE NUMERICAL APPROXIMATIONS TO THE
!     DERIVATIVE MATRIX (JACOBIAN).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LSCL,LSTPT,LWT,M,N,NPAR,NRESTS
      LOGICAL
     +   DONE,WEIGHT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(NRESTS,*),PAR(*),RESTS(*),SCL(*),STPT(*),WT(*),XM(IXM,*)
      INTEGER
     +   IFIXD(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDLTS3
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   PJ,STPJ
      INTEGER
     +   I,J,JPK
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,SIGN
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION D(NRESTS,NPAR)
!        THE FIRST DERIVATIVE OF THE MODEL (JACOBIAN).
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     LOGICAL DONE
!        THE VARIABLE USED TO INDICATE WHETHER THIS IS THE FINAL
!        COMPUTATION OF THE JACOBIAN OR NOT.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IXM
!        THE FIRST DIMENSION OF MATRIX XM.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER JPK
!        AN INDEX VARIABLE.
!     INTEGER LSCL
!        THE DIMENSION OF VECTOR SCL.
!     INTEGER LSTPT
!        THE DIMENSION OF VECTOR STPT.
!     INTEGER LWT
!        THE DIMENSION OF VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDLTS3
!        THE STARPAC FORMAT SUBROUTINE FOR COMPUTING THE ARIMA MODEL
!        RESIDUALS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PJ
!        A TEMPORARY LOCATION FOR STORAGE OF THE JTH PARAMETER.
!     DOUBLE PRECISION RESTS(NRESTS)
!        THE RESIDUALS FROM THE ARIMA MODEL.
!     DOUBLE PRECISION SCL(LSCL)
!        THE SCALE VALUES.
!     DOUBLE PRECISION STPT(LSTPT)
!        THE STEP SIZE ARRAY.
!     DOUBLE PRECISION STPJ
!        THE JTH STEP SIZE.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!
!     COMPUTE FINITE-DIFFERENCE JACOBIAN OF THE OPTIMIZED PARAMETERS
!
      JPK = 0
!
      DO 20 J=1,NPAR
!
         IF (IFIXD(J).NE.0) GO TO 20
!
         JPK = JPK + 1
!
         PJ = PAR(J)
         IF (SCL(JPK).NE.0.0D0) THEN
            STPJ = STPT(J)*SIGN(1.0D0,PAR(J))*MAX(ABS(PAR(J)),1.0D0/
     +             ABS(SCL(JPK)))
         ELSE
            IF (PAR(J).NE.0.0D0) THEN
               STPJ = STPT(J)*SIGN(1.0D0,PAR(J))*ABS(PAR(J))
            ELSE
               STPJ = STPT(J)
            END IF
         END IF
!
         STPJ = STPJ + PAR(J)
         STPJ = STPJ - PAR(J)
!
         PAR(J) = PJ + STPJ
         CALL MDLTS3(PAR, NPAR, XM, N, M, IXM, D(1,J))
!
         DO 10 I=1,NRESTS
            D(I,JPK) = (-RESTS(I)+D(I,J))/STPJ
   10    CONTINUE
!
         PAR(J) = PJ
!
   20 CONTINUE
!
      RETURN
!
      END
!RANKO
      SUBROUTINE RANKO(N, Y, H, R, T)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     VERSION  45.0    RANKO    3/ 6/70
!     *****
!     PUTS RANK OF N X"S IN VECTOR R. VECTOR H IS USED FOR STORAGE.
!     X,H AND R MUST BE DIMENSIONED N OR GREATER.
!     STORES CORRECTION FOR TIES IN T = SUM(T-1)*T*(T+1).
!        N.B.  T IS 12 TIMES VALUE COMPUTED BY ORIGINAL OMNITAB ROUTINE.
!     T=0  MEANS NO TIES.
!     WRITTEN BY DAVID HOGBEN, SEL, NBS.   4/9/69.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   T
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   R(N),Y(N)
      INTEGER
     +   H(N)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IJ,J,K,K2
!
!  EXTERNAL SUBROUTINES
      EXTERNAL SRTIR,SRTRI
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER H(N)
!        THE INDICES TO THE HIERARCHY OF R
!     INTEGER I
!        INDEX VARIABLE
!     INTEGER IJ
!        INDEX VARIABLE BASED ON I-J
!     INTEGER J
!        INDEX VARIABLE
!     INTEGER K
!        INDEX VARIABLE
!     INTEGER K2
!          INDEX VARIABLE
!     INTEGER N
!        NUMBER OF OBSERVATIONS
!     DOUBLE PRECISION R(N)
!        FINAL VECTOR CONTAINING RANK
!     DOUBLE PRECISION T
!        12 TIMES THE OMNITAB CORRECTION FOR TIES
!             T = SUM(T-1)*T*(T+1)
!             T = 0 MEANS NO TIES
!     DOUBLE PRECISION Y(N)
!        VECTOR TO BE RANKED
!
!
!     MOVE Y TO R AND PUT I IN H
!
      DO 10 I=1,N
         H(I) = I
         R(I) = Y(I)
   10 CONTINUE
!
!     SORT Y IN R, CARRY ALONG I IN H TO OBTAIN HIERARCHY IN H.
!
      CALL SRTIR(H, N, R)
!
!     REPLACE R(I) BY I*.
!     LET K BE SUCH THAT R(I)=R(I-J+1),J=1,K. THEN I* = I-(K-1)/2.
!
      K = 1
      T = 0
      DO 40 I=2,N
         IF (R(I).EQ.R(I-1)) THEN
            K = K + 1
         ELSE
            DO 30 J=1,K
               IJ = I - J
               R(IJ) = (I-1) - (K-1)/2.0D0
   30       CONTINUE
            T = T + (K-1)*K*(K+1)
            K = 1
         END IF
   40 CONTINUE
      T = T + (K-1)*K*(K+1)
      DO 50 I=1,K
         K2 = N + 1 - I
         R(K2) = N - (K-1)/2.0D0
   50 CONTINUE
!
!     SORT H CARRY ALONG R TO OBTAIN RANKS IN R
!
      CALL SRTRI(R, N, H)
      RETURN
      END
!UFSMVS
      SUBROUTINE UFSMVS(ACOV, NLPPA, LAGMAX, N, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS WITH MISSING DATA (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   ISPCF,LAGMAX,LDSTAK,N,NF,NPRT,NW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),FREQ(*),SPCF(*)
      INTEGER
     +   LAGS(*),NLPPA(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,YMISS
      INTEGER
     +   IFP,IO,IPRT,ISORT,ISYM,LACOV,LDSMIN,LNLPPA,LPCV,LWORK,LY,
     +   NALL0,WORK,XAXIS,YAXIS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12),Y(1)
      INTEGER
     +   ISTAK(12)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ECVF,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UFSDRV
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LAGMAX+1)
!        THE AUTOCOVARIANCES OF THE SERIES.
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE SPECTRUM
!        IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF ERR01, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION FOR THE ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY ISYM.
!     INTEGER LACOV
!        THE LENGTH OF THE ACVF VECTORS.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
!        THIS ROUTINE WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(LAGMAX+1)
!        THE ARRAY CONTAINING THE NUMBER OF LAG PRODUCT PAIRS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION SPCF(ISPCF,NW)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     INTEGER WORK
!        THE STARTING LOCATION IN RSTAK FOR
!        THE WORK VECTOR.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY XAXIS.
!     DOUBLE PRECISION Y(1)
!        A DUMMY ARRAY.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY YAXIS.
!     DOUBLE PRECISION YMISS
!        A DUMMY VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','M','V','S'/
!
!     SET UP
!
      OPTION(4) = .TRUE.
      OPTION(3) = .TRUE.
      OPTION(2) = .TRUE.
      OPTION(1) = .FALSE.
!
!     COMPUTE MINIMUM ALLOWABLE STACK LENGTH
!
      IO = 1
      IF (NPRT.EQ.0) IO = 0
!
      CALL LDSCMP(4, 0, IO*(NF+5), 0, 0, 0, 'D',
     +   LAGMAX+1+IO*(2*NF+10), LDSMIN)
!
      YMISS = 1.0D0
      LACOV = LAGMAX+1
!
      LY = 1
      LNLPPA = LACOV
      LPCV = NF + 5
      LWORK = LAGMAX+1
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!     SET THE STACK ALLOCATION TYPE.
!
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
!
      IFP = 4
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
!
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         WORK = 1
         XAXIS = 1
         YAXIS = 1
         ISYM = 1
         ISORT = 1
      ELSE
         WORK = STKGET(LWORK,IFP)
         IF (NPRT.NE.0) THEN
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
            ISYM = STKGET(LPCV,2)
            ISORT = ISYM
         ELSE
            XAXIS = WORK
            YAXIS = WORK
            ISYM = WORK
            ISORT = ISYM
         END IF
      END IF
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!     FOR SERIES WITH MISSING DATA.
!
      CALL UFSDRV(Y, LY, YMISS, ACOV, NLPPA, SPCF, ISPCF, NF, FMIN,
     +   FMAX, FREQ, N, NW, LAGMAX, LAGS, RSTAK(WORK), LACOV, LWORK,
     +   DELTA, ISTAK(ISORT), ISTAK(ISYM), RSTAK(XAXIS), RSTAK(YAXIS),
     +   LPCV, ALPHA, NPRT, PARZEN, NMSUB, LDSMIN, LDSTAK, OPTION,
     +   LNLPPA, LY)
!
      CALL STKCLR(NALL0)
!
!     CHECK FOR ERRORS
!
      IF (IERR.EQ.0) RETURN
!
      IF (IERR.EQ.2) CALL ECVF(NMSUB)
      IERR = 1
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL UFSMVS (ACOV, NLPPA, LAGMAX, N,'/
     +  '      +             NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +  '      +             SPCF, ISPCF, FREQ, LDSTAK)')
      END
!BFS
      SUBROUTINE BFS(Y1, Y2, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     BIVARIATE SPECTRUM ANALYSIS (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y1(*),Y2(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS1,YMISS2
      INTEGER
     +   ICCOV,ICSPC2,INDEX1,INDEX2,INLPPC,IPHAS,IPRT,JCCOV,JNLPPC,
     +   LAGMAX,LAGMX1,LDSMIN,LDSTAK,LPCV,LW,LY,M,NF,NPRT,NW
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCOV(101,2,2),CEVEN(101),CODD(101),CSPC2(101,4),FREQ(101),
     +   PHAS(101,4),SPCF1(101),SPCF2(101),W(101),XAXIS(404),
     +   YAXIS(404)
      INTEGER
     +   ISYM(404),LAGS(4),NLPPC(1,1,1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,IPRINT,PARZEN,SETLAG
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION CCOV(101,2,2)
!        THE COVARIANCES.
!     DOUBLE PRECISION CEVEN(101)
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CODD(101)
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CSPC2(101,4)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISYM(404)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC(1,1,1)
!        A DUMMY ARRAY.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION PHAS(101,4)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION SPCF1(101), SPCF2(101)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     DOUBLE PRECISION W(101)
!        THE WINDOWS.
!     DOUBLE PRECISION XAXIS(404)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YAXIS(404)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YMISS1, YMISS2
!        DUMMY VARIABLES.
!     DOUBLE PRECISION Y1(N)
!        THE FIRST TIME SERIES.
!     DOUBLE PRECISION Y2(N)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(4) = .FALSE.
!
      ICCOV = 101
      JCCOV = 2
      M = 2
      INDEX1 = 1
      INDEX2 = 2
!
      ICSPC2 = 101
      IPHAS = 101
!
      LDSTAK = 0
      LDSMIN = 0
!
      NF = 101
      YMISS1 = 1.0D0
      YMISS2 = 1.0D0
      INLPPC = 1
      JNLPPC = 1
      LW = 101
      LY = N
      LPCV = 404
!
!     SET MAXIMUM LAG VALUE (LAGMAX)
!     SET NUMBER OF LAG WINDOW TRUCCATION POINTS (NW)
!
      CALL SETLAG(N, LAGMAX)
      NW = 4
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
      CALL BFSDRV(Y1, Y2, YMISS1, YMISS2, CCOV, NLPPC, SPCF1, SPCF2,
     +   NF, FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS, LAGMX1, W, LW,
     +   DELTA, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS, CODD,
     +   CEVEN, W, LW, NMSUB, LDSMIN, LDSTAK, OPTION, N, INLPPC,
     +   JNLPPC, LY)
!
      IF (IERR.EQ.0) RETURN
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL BFS (Y1, Y2, N)')
      END
!MPPL
      SUBROUTINE MPPL(YM, X, N, M, IYM, ILOG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH MULTIPLE Y-AXIS VALUES (LOG OPTION).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,IYM,M,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   IPRT,ISCHCK,ISIZE,LISYM,NOUT
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(IYM,M)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'P',       'P',       'L',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      XMISS = 1.0D0
      MULTI = .TRUE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 2
      ISIZE = -1
      NOUT = 0
      MISS = .FALSE.
      LISYM = 1
!
      CALL PPCNT (YM, YM, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL MPPL (YM, X, N, M, IYM, ILOG)')
      END
!TAPER
      SUBROUTINE TAPER (Y, N, TAPERP, YT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER ROUTINE FOR APPLYING A SPLIT-COSINE-BELL
!     TAPER TO THE (CENTERED) OBSERVED SERIES Y, RETURNING THE TAPERED
!     SERIES IN YT.  THIS ROUTINE IS ADAPTED FROM BLOOMFIELDS
!     ROUTINE TAPER.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   TAPERP
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*),YT(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   PI,WEIGHT
      INTEGER
     +   I,IPRT,J,M
      LOGICAL
     +   ERR01,HEAD
!
!  LOCAL ARRAYS
      CHARACTER
     +   LN(8)*1,NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CENTER,EISGE,GETPI,IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC COS,INT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICARE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT NUMBER USED FOR OUTPUT.
!     INTEGER J
!        AN INDEXING VARIABLE.
!     CHARACTER*1 LN(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER M
!        THE NUMBER OF POINTS AT EACH END OF THE SERIES TO BE
!        TAPERED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     DOUBLE PRECISION PI
!        THE VALUE OF PI.
!     DOUBLE PRECISION TAPERP
!        THE TOTAL PERCENTAGE OF THE DATA TO BE TAPERED.
!     DOUBLE PRECISION WEIGHT
!        THE ITH TAPER WEIGHT.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YT(N)
!        THE VECTOR IN WHICH THE TAPERED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'T',       'A',       'P',       'E',       'R',       ' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /'N',' ',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
      IF (.NOT. ERR01) GO TO 5
!
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
    5 CONTINUE
!
      CALL CENTER (Y, N, YT)
!
      IF ((TAPERP .LE. 0.0D0) .OR. (TAPERP .GT. 1.0D0)) RETURN
!
      CALL GETPI(PI)
!
      M = INT(TAPERP * N + 0.5D0) / 2
      IF (M .EQ. 0) RETURN
!
      DO 20 I = 1, M
         WEIGHT = 0.5D0 - 0.5D0 * COS(PI * (I-0.5D0) / M)
         YT(I) = WEIGHT * YT(I)
         J = N + 1 - I
         YT(J) = WEIGHT * YT(J)
   20 CONTINUE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   36H       CALL TAPER (Y, N, TAPERP, YT))
      END
!AMLST1
      SUBROUTINE AMLST1 (IAMHD, PAR, NPAR, MSPECT, NFAC, VCVL, LVCVL,
     +  SCALE, LSCALE, STPT, LSTPT, IPARMN, IPARMX, LBLTYP, T975, IFIXD)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRINTS THE PARAMETERS FOR THE ARIMA ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   T975
      INTEGER
     +   IAMHD,IPARMN,IPARMX,LBLTYP,LSCALE,LSTPT,LVCVL,NFAC,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),SCALE(*),STPT(*),VCVL(*)
      INTEGER
     +   IFIXD(*),MSPECT(NFAC,4)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM,PLL,PUL,RATIO,SDPAR
      INTEGER
     +   IPRT,J,K,L,LL,LPAR,ORDER
!
!  LOCAL ARRAYS
      CHARACTER
     +   FIXED(3)*1
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL FIXPRT,IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     CHARACTER*1 FIXED(3)
!        THE CHARACTERS USED TO LABEL THE PARAMETERS FIXED OR NOT.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER IAMHD
!        THE INDICATOR VALUE USED TO DESIGNATE THE TYPE OF LIST
!        TO BE GENERATED
!        IF IAMHD=1, THE LIST IS FOR THE INITIAL SUMMARY OF THE
!                    ESTIMATION ROUTINES.
!        IF IAMHD=2, THE LIST IS FOR THE INITIAL REPORT OF THE
!                    FORECASTING ROUTINES.
!        IF IAMHD=3, THE LIST IS FOR THE FINAL REPORT OF THE
!                    ESTIMATION ROUTINES.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IPARMN
!        THE SMALLEST PARAMETER INDEX INCLUDED IN THIS TERM.
!     INTEGER IPARMX
!        THE LARGEST PARAMETER INDEX INCLUDED IN THIS TERM.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER LVCVL
!        THE DIMENSION OF VECTOR VCVL.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER L
!        AN INDEX VARIABLE.
!     INTEGER LBLTYP
!        THE TYPE OF LABLE TO BE PRINTED, WHERE
!        1 INDICATES THE TERM IS AUTOREGRESSIVE AND
!        2 INDICATES THE TERM IS MOVING AVERAGE
!     INTEGER LL
!        AN INDEX VARIABLE.
!     INTEGER LPAR
!        AN INDEX VARIABLE.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER LSTPT
!        THE DIMENSION OF VECTOR STPT.
!     INTEGER MSPECT(NFAC,4)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER ORDER
!        THE ORDER OF B FOR THE PARAMETER BEING PRINTED
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PLL
!        THE LOWER CONFIDENCE LIMIT FOR A GIVEN PARAMETER.
!     DOUBLE PRECISION PUL
!        THE UPPER CONFIDENCE LIMIT FOR A GIVEN PARAMETER.
!     DOUBLE PRECISION RATIO
!        THE RATIO OF A GIVEN PARAMETER VALUE TO ITS STANDARD ERROR.
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPAR
!        THE STANDARD DEVIATION OF A GIVEN PARAMETER VALUE.
!     DOUBLE PRECISION STPT(LSTPT)
!        THE STEP SIZE ARRAY.
!     DOUBLE PRECISION T975
!        THE VALUE OF THE 97.5 PERCENT POINT FUNCTION FOR THE
!        T DISTRIBUTION.
!     DOUBLE PRECISION VCVL(LVCVL)
!        THE LOWER HALF OF THE VARIANCE-COVARIANCE MATRIX, STORED
!        ROW WISE.
!
!
      FPLM = D1MACH(2)
!
      CALL IPRINT(IPRT)
!
!     PRINT NEXT SET OF TERMS
!
      LPAR = 0
      DO 1 J=1,IPARMX
         IF (IFIXD(J).EQ.0) LPAR = LPAR + 1
    1 CONTINUE

      DO 40 J=1,NFAC
        IF ((MSPECT(J,LBLTYP).EQ.0) .AND. (LBLTYP.NE.2)) GO TO 40
        IF (LBLTYP.NE.2) IPARMX = IPARMX + MSPECT(J,LBLTYP)
        IF (LBLTYP.EQ.2) IPARMX = IPARMX + 1
        ORDER = 0
        DO 30 L = IPARMN, IPARMX
          ORDER = ORDER + MSPECT(J,4)
          IF (IAMHD.EQ.2) GO TO 25
          CALL FIXPRT(IFIXD(L), FIXED)
          IF (LBLTYP.EQ.1) WRITE(IPRT, 1000) L, J, ORDER,
     +      (FIXED(K),K=1,3), PAR(L)
          IF (LBLTYP.EQ.2) WRITE(IPRT, 1004) L,
     +      (FIXED(K),K=1,3), PAR(L)
          IF (LBLTYP.EQ.3) WRITE(IPRT, 1005) L, J, ORDER,
     +      (FIXED(K),K=1,3), PAR(L)
            IF (IAMHD.EQ.3) GO TO 10
!
            IF (IFIXD(L).EQ.0) GO TO 5
            WRITE (IPRT, 1007)
            GO TO 10
!
    5       CONTINUE
            IF (SCALE(1).LE.0.0D0) WRITE (IPRT, 1001) STPT(L)
            IF (SCALE(1).GT.0.0D0) WRITE (IPRT, 1002) SCALE(L), STPT(L)
   10     CONTINUE
          IF (IAMHD .EQ. 1) GO TO 30
!
          IF (IFIXD(L).EQ.0) GO TO 20
          WRITE(IPRT, 1006)
          GO TO 30
!
   20     CONTINUE
          LPAR = LPAR + 1
          RATIO = FPLM
          LL = LPAR*(LPAR-1)/2 + LPAR
          IF (VCVL(LL).GT.0.0D0) RATIO = PAR(L)/SQRT(VCVL(LL))
          SDPAR = SQRT(VCVL(LL))
          PLL = PAR(L) - T975*SDPAR
          PUL = PAR(L) + T975*SDPAR
          WRITE(IPRT, 1003) SDPAR, RATIO, PLL, PUL
          GO TO 30
   25     CONTINUE
          IF (LBLTYP.EQ.1) WRITE(IPRT, 1010) L, J, ORDER, PAR(L)
          IF (LBLTYP.EQ.2) WRITE(IPRT, 1014) L, PAR(L)
          IF (LBLTYP.EQ.3) WRITE(IPRT, 1015) L, J, ORDER, PAR(L)
   30   CONTINUE
        IPARMN = IPARMX + 1
   40 CONTINUE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(1X, I5, 2X, 'AR (FACTOR', I2, ')',4X,I5,6X,3A1,E17.8)
 1001 FORMAT ('+', 65X, 7HDEFAULT, E17.8)
 1002 FORMAT ('+', 55X, 2E17.8)
 1003 FORMAT ('+', 55X, 4(2X, E15.8))
 1004 FORMAT(1X, I5, 13X, 'MU', 4X, '  ---' ,6X,3A1,E17.8)
 1005 FORMAT(1X, I5, 2X, 'MA (FACTOR', I2, ')',4X,I5,6X,3A1,E17.8)
 1006 FORMAT('+', 55X, 4(14X, '---'))
 1007 FORMAT('+', 69X, '---', 14X, '---')
 1010 FORMAT(1X, I5, 2X, 'AR (FACTOR', I2, ')',4X,I5,E17.8)
 1014 FORMAT(1X, I5, 13X, 'MU', 4X, '  ---' ,E17.8)
 1015 FORMAT(1X, I5, 2X, 'MA (FACTOR', I2, ')',4X,I5,E17.8)
      END
!ERSLF
      SUBROUTINE ERSLF (NMSUB, NMVAR, K, H, HEAD, ERROR)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PERFORMS ERROR CHECKING FOR THE INPUT
!     VALUES OF A SYMMETRIC LINEAR FILTER.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   K
      LOGICAL
     +   ERROR,HEAD
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   H(*)
      CHARACTER
     +   NMSUB(6)*1,NMVAR(8)*1
!
!  LOCAL SCALARS
      INTEGER
     +   I,IHM,IHP,IPRT,KHALF,KMID,NZERO
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION H(K)
!         THE VECTOR OF FILTER COEFFICIENTS.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IHM, IHP
!        INDEX VARIABLES FOR SYMMETRIC LOCATIONS AROUND THE MIDPOINT
!        OF THE FILTER.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER K
!        THE NUMBER OF TERMS IN THE FILTER.
!     INTEGER KHALF
!        THE VALUE OF THE MIDPOINT OF K MINUS 1.
!     INTEGER KMID
!        THE MIDPOINT OF THE FILTER.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     CHARACTER*1 NMVAR(8)
!        THE ARRAY CONTAINING THE NAME OF THE FILTER COEFFICIENT
!        ARRAY.
!     INTEGER NZERO
!        THE NUMBER OF FILTER COEFFICIENTS EQUAL TO ZERO.
!
      ERROR = .FALSE.
!
      KMID = (K + 1) / 2
      KHALF = KMID - 1
      NZERO = 0
      DO 10 IHM = 1, KHALF
         IHP = K + 1 - IHM
         IF (H(IHM) .EQ. 0.0D0) NZERO = NZERO + 1
         IF (H(IHM)  .EQ.  H(IHP)) GO TO 10
!
         CALL IPRINT(IPRT)
         CALL EHDR(NMSUB, HEAD)
         WRITE (IPRT, 1010) (NMVAR(I), I = 1, 6), (H(I), I = 1, K)
         ERROR = .TRUE.
         RETURN
   10 CONTINUE
!
      IF (H(KMID) .EQ. 0.0D0) NZERO = NZERO + 1
!
      IF (NZERO .LT. KMID) RETURN
!
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
      WRITE (IPRT, 1020) (NMVAR(I), I = 1, 6)
      ERROR = .TRUE.
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1010 FORMAT(/
     +   18H THE INPUT FILTER , 6A1, 24H MUST BE SYMMETRIC.  THE,
     +   30H INPUT FILTER COEFFICIENTS ARE/
     +   5(1X, E15.5))
 1020 FORMAT(/
     +   32H ALL THE FILTER COEFFICIENTS IN , 6A1, 16H ARE IDENTICALLY,
     +   15H EQUAL TO ZERO,/
     +   42H THEREFORE NO FILTERING WILL BE PERFORMED.)
      END
!ACFMNF
      SUBROUTINE ACFMNF (YFFT, N, NFFT, LAGMAX, RHO, SDRHO, YMEAN,
     +   PRHO, AIC, FTEST, PHI, IAR, OSPVAR, ACOV, LACOV, LAIC,
     +   CHIA, CHIAP, LYFFT, WORK, LWORK, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING AUTOCORRELATIONS AND
!     PARTIAL AUTOCORRELATIONS OF A TIME SERIES .
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN
      INTEGER
     +   IAR,LACOV,LAGMAX,LAIC,LWORK,LYFFT,N,NFFT,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),AIC(*),FTEST(2,*),PHI(*),PRHO(*),RHO(*),SDRHO(*),
     +   WORK(*),YFFT(*)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACFSD,ACVFF,AOS,CHIRHO
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV)
!        THE AUTOCOVARIANCE FUNCTION ESTIMATE VECTOR.
!     DOUBLE PRECISION AIC(LAIC)
!        THE AKAIKES INFORMATION CRITERION VECTOR.
!     DOUBLE PRECISION CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     DOUBLE PRECISION FTEST(2, LAGMAX)
!        THE ARRAY IN WHICH THE PARTIAL F RATIOS AND PROBABILITIES
!        ARE STORED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     DOUBLE PRECISION OSPVAR
!        THE ONE STEP PREDICTION VARIANCE.
!     DOUBLE PRECISION PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER (IAR).
!     DOUBLE PRECISION PRHO(LAGMAX)
!        THE ARRAY IN WHICH THE PARTIAL AUTOCORRELATIONS ARE STORED
!     DOUBLE PRECISION RHO(LAGMAX)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
!     DOUBLE PRECISION SDRHO(LAGMAX)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!        ARE STORED
!     DOUBLE PRECISION WORK(LWORK)
!        A WORK ARRAY.
!     DOUBLE PRECISION YFFT(LYFFT)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!     COMPUTE AUTOCOVARIANCESS AND STANDARD DEVIATION OF THE SERIES.
!
      CALL ACVFF(YFFT, N, NFFT, YMEAN, ACOV, LAGMAX, LACOV, LYFFT, WORK,
     +   LWORK)
!
      IF (ACOV(1) .EQ. 0.0D0) RETURN
!
!     COMPUTE PARTIAL AUTOCORRELATIONS AND AUTOREGRESSIVE ORDER
!     SELECTION STATISTICS.
!
      CALL AOS (N, LAGMAX, ACOV, PRHO, IAR, OSPVAR, PHI, WORK,
     +   AIC, FTEST, LACOV, LAIC)
!
      IF (NPRT .EQ. 0) RETURN
!
!     COMPUTE AUTOCORRELATIONS
!
      DO 10 I = 1, LAGMAX
         RHO(I) = ACOV(I+1) / ACOV(1)
   10 CONTINUE
!
!     COMPUTE STANDARD ERROR OF AUTOCORRELATIONS.
!
      CALL ACFSD (RHO, SDRHO, LAGMAX, N)
!
!     COMPUTE CHI STATISTIC BASED ON AUTOCORRELATION VALUES
!
      CALL CHIRHO (RHO, N, LAGMAX, CHIA, CHIAP)
!
      RETURN
      END
!AIMF
      SUBROUTINE AIMF (Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR ARIMA ESTIMATION
!     (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N,NFAC,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),Y(*)
      INTEGER
     +   MSPEC(4,*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IFCST,IPRT,NFCST,NFCSTO,NPRT
      LOGICAL
     +   SAVE
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FCST(1,1),FCSTSD(1)
      INTEGER
     +   IFCSTO(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMFCNT,IPRINT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FCST(1,1)
!        THE STORAGE ARRAY FOR THE FORECASTS.
!     DOUBLE PRECISION FCSTSD(1)
!        THE STORAGE ARRAY FOR THE STANDARD DEVIATIONS OF THE FORECASTS.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFCST
!        THE FIRST DIMENSION OF THE ARRAY FCST.
!     INTEGER IFCSTO(1)
!        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER MSPEC(4,NFAC)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFCST
!        THE NUMBER OF FORECASTS.
!     INTEGER NFCSTO
!        THE NUMBER OF THE ORIGINS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'A','I','M','F',' ',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      SAVE = .FALSE.
!
      NFCST = N/10 + 1
      NFCSTO = 1
      IFCSTO(1) = N
      NPRT = -1
      IFCST = 1
!
      CALL AMFCNT(Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK, NFCST, NFCSTO,
     +   IFCSTO, NPRT, FCST, IFCST, FCSTSD, NMSUB, SAVE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/' THE CORRECT FORM OF THE CALL STATEMENT IS'//
     +     '       CALL AIMF (Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK)')
      END
!REALTR
      SUBROUTINE REALTR(A, B, N, ISN)
!  IF ISN=1, THIS SUBROUTINE COMPLETES THE FOURIER TRANSFORM
!    OF 2*N DATA VALUES, WHERE THE ORIGINAL DATA VALUES ARE
!    STORED ALTERNATELY IN ARRAYS A AND B, AND ARE FIRST
!    TRANSFORMED BY A COMPLEX FOURIER TRANSFORM OF DIMENSION N.
!    THE COSINE COEFFICIENTS ARE IN A(1),A(2),...A(N+1) AND
!    THE SINE COEFFICIENTS ARE IN B(1),B(2),...B(N+1).
!    A TYPICAL CALLING SEQUENCE IS
!      CALL FFT(A,B,N,N,N,1)
!      CALL REALTR(A,B,N,1)
!    THE RESULTS SHOULD BE MULTIPLIED BY 0.5D0/N TO GIVE THE
!    USUAL SCALING OF COEFFICIENTS.
!  IFISN-1, THE INVERSE TRANSFORMATION IS DONE, THE FIRST STEP
!    IN EVALUATING A DOUBLE PRECISION FOURIER SERIES.
!    A TYPICAL CALLING SEQUENCE IS
!      CALL REALTRA(A,B,N,-1)
!      CALL FFT(A,B,N,N,N,-1)
!    THE RESULTS SHOULD BE MULTIPLIED BY 0.5D0 TO GIVE THE USUAL
!    SCALING, AND THE TIME DOMAIN RESULTS ALTERNATE IN ARRAYS A
!    AND B, I.E. A(1),B(1),A(2),B(2),...A(N),B(N).
!  THE DATA MAY ALTERNATIVELY BE STORED IN A SINGLE COMPLEX
!    ARRAY A, THEN THE MAGNITUDE OF ISN CHANGED TO TWO TO
!    GIVE THE CORRECT INDEXING INCREMENT AND A(2) USED TO
!    PASS THE INITIAL ADDRESS FOR THE SEQUENCE OF IMAGINARY
!    VALUES, E.G.
!      CALL FFT(A,A(2),N,N,N,2)
!      CALL REALTR(A,A(2),N,2)
!    IN THIS CASE, THE COSINE AND SINE COEFFICIENTS ALTERNATE IN A.
!  BY R. C. SINGLETON, STANFORD RESEARCH INSTITUTE, OCT. 1968
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ISN,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   A(1),B(1)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   AA,AB,BA,BB,CD,CN,IM,RE,SD,SN
      INTEGER
     +   INC,J,K,NH,NK
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ATAN,IABS,SIN
!
!
!
      INC = IABS(ISN)
      NK = N*INC + 2
      NH = NK/2
      SD = 2.0D0*ATAN(1.0D0)/N
      CD = 2.0D0*SIN(SD)**2
      SD = SIN(SD+SD)
      SN = 0.0D0
      IF (ISN.LT.0) GO TO 30
      CN = 1.0D0
      A(NK-1) = A(1)
      B(NK-1) = B(1)
   10 DO 20 J=1,NH,INC
         K = NK - J
         AA = A(J) + A(K)
         AB = A(J) - A(K)
         BA = B(J) + B(K)
         BB = B(J) - B(K)
         RE = CN*BA + SN*AB
         IM = SN*BA - CN*AB
         B(K) = IM - BB
         B(J) = IM + BB
         A(K) = AA - RE
         A(J) = AA + RE
         AA = CN - (CD*CN+SD*SN)
         SN = (SD*CN-CD*SN) + SN
         CN = 0.5D0/(AA**2+SN**2) + 0.5D0
         SN = CN*SN
         CN = CN*AA
   20 CONTINUE
      RETURN
   30 CN = -1.0D0
      SD = -SD
      GO TO 10
      END
!AMEDRV
      SUBROUTINE AMEDRV(Y, N, MSPEC, NFAC, PAR, NPAR,
     +   RES, LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP,
     +   SCALE, LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV,
     +   SDRES, LSDRES, VCV, IVCV, NMSUB, SAVE, NPARE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IVAPRX,IVCV,LDSTAK,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,
     +   MIT,N,NFAC,NPAR,NPARE,NPRT
      LOGICAL
     +   SAVE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),STP(*),VCV(*),
     +   Y(*)
      INTEGER
     +   IFIXED(*),MSPEC(4,*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR,IFLAG,MBO,MBOL,MSPECT,NFACT,NPARAR,NPARDF,NPARMA,
     +   NRESTS,PARAR,PARDF,PARMA,T,TEMP
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   EXMPT
      INTEGER
     +   IFP,IS,ISUBHD,IXM,LDSMIN,LWT,M,NALL0,NDIGIT,NETA,NNZW,STPT
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,PRTFXD,WEIGHT,WIDE
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12),WT(1)
      INTEGER
     +   IPTOUT(5),ISTAK(12)
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   ICNTI,STKGET,STKST
      EXTERNAL ICNTI,STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMECNT,AMEER,AMEHDR,AMESTP,BACKOP,CPYVII,
     +   DCOEF,DRV,LDSCMP,MDLTS1,MDLTS3,NLDRVN,PRTCNT,DCOPY,
     +   STKCLR,STKSET,STPAMO
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
      COMMON /MDLTSC/MSPECT,NFACT,PARDF,NPARDF,PARAR,NPARAR,PARMA,
     +   NPARMA,MBO,MBOL,T,TEMP,NRESTS,IFLAG
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     EXTERNAL AMEHDR
!        THE ROUTINE USED TO PRINT THE HEADING
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IFLAG
!        ...
!     INTEGER IFP
!        AN INDICATOR FOR THE PRECISION OF THE STACK ALLOCATION TYPE,
!        WHERE IFP=3 INDICATES SINGLE AND IFP=4 INDICATES DOUBLE.
!     INTEGER IPTOUT(5)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER IS
!        A VALUE USED TO DETERMINE THE AMOUNT OF WORK SPACE NEEDED
!        BASED ON WHETHER STEP SIZES ARE INPUT OR ARE TO BE CALCULATED.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE FOR
!        IVAPRX LE 0, VCV = THE DEFAULT OPTION
!        IVAPRX EQ 1, VCV = INVERSE(TRANSPOSE(J)*J)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2, VCV = INVERSE(H)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4, VCV = INVERSE(TRANSPOSE(J)*J)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5, VCV = INVERSE(H)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7, VCV = THE DEFAULT OPTION
!        WITH J REPRESENTING THE JACOBIAN AND H THE HESSIAN.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF MATRIX XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE DIMENSION OF VECTOR IFIXED.
!     INTEGER LPV
!        THE DIMENSION OF VECTOR PV.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER LSDPV
!        THE DIMENSION OF VECTOR SDPV.
!     INTEGER LSDRES
!        THE DIMENSION OF VECTOR SDRES.
!     INTEGER LSTP
!        THE DIMENSION OF VECTOR STP.
!     INTEGER LWT
!        THE DIMENSION OF VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBOL
!        THE MAXIMUM BACK ORDER ON THE LEFT
!     EXTERNAL MDLTS1
!        THE STARPAC FORMAT SUBROUTINE FOR COMPUTING THE ARIMA MODEL
!        PREDICTED VALUES.
!     EXTERNAL MDLTS3
!        THE STARPAC FORMAT SUBROUTINE FOR COMPUTING THE ARIMA MODEL
!        RESIDUALS.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER MSPEC(4,NFAC)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER MSPECT
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        NUMBER OF STACK ALLOCATIONS OUTSTANDING.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL RESULTS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFACT
!        THE NUMBER OF FACTORS IN THE MODEL
!     EXTERNAL NLDRVN
!        THE NAME OF THE ROUTINE WHICH CALCULATES THE DERIVATIVES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARAR
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE AUTOREGRESSIVE PARAMETERS
!     INTEGER PARDF
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
!     INTEGER PARMA
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE MOVING AVERAGE PARAMETERS
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PV(LPV)
!        THE PREDICTED VALUE OF THE FIT.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(LSDPV)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(LSDRES)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(LSTP)
!        THE STEP SIZE ARRAY.
!     EXTERNAL STPAMO
!        THE ROUTINE USED TO PRINT THE OUTPUT FROM THE STEP SIZE SELECTI
!        ROUTINES.
!     INTEGER STPT
!        THE STARTING LOCATION IN /CSTAK/ OF VECTOR STPT CONTAINING
!        THE STEP SIZE ARRAY.
!     INTEGER T
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR.
!     INTEGER TEMP
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE VARIANCE-COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(1)
!        THE USER SUPPLIED WEIGHTS, UNUSED WHEN WEIGHT = FALSE.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!     SET VARIOUS PROGRAM VALUES
!
      WEIGHT = .FALSE.
      WT(1) = 1.0D0
      LWT = 1
!
      HLFRPT = .FALSE.
      APRXDV = .TRUE.
      PRTFXD = .TRUE.
      EXMPT = -1.0D0
      NETA = 0
!
      WIDE = .TRUE.
      PAGE = .FALSE.
!
      NDIGIT = 5
!
!     COMPUTE BACK OPERATORS
!
      CALL BACKOP(MSPEC, NFAC, NPARDF, MBOL, MBO, NPARMA, NPARAR)
      NNZW = N - NPARDF
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      NPARE = NPAR
      IF ((IFIXED(1).GE.0) .AND. (NPAR.GE.1)) NPARE =
     +   ICNTI(IFIXED,NPAR,0)
      IS = 0
      IF (STP(1).LE.0.0D0) IS = 1
!
      CALL LDSCMP(25, 0, MAX(IS*2*(N+NPAR),60+NPAR+NPARE) + 4*NFAC,
     +   0, 0, 0, 'D', 5*MBO +
     +   MAX(IS*(10*N+6*MBO+606),
     +        94+4*(N+MBO+101)+NPARE*(3*NPARE+35)/2),
     +   LDSMIN)
!
      CALL AMEER(NMSUB, N, NPAR, NPARE, LDSTAK,
     +   LDSMIN, STP, LSTP, SCALE, LSCALE, IVCV, SAVE, MSPEC, NFAC)
!
      IF (IERR.NE.0) RETURN
!
      CALL STKSET(LDSTAK, 4)
!
!     SET PRINT CONTROL VALUES
!
      CALL PRTCNT(NPRT, NDIGIT, IPTOUT)
!
!     SUBDIVIDE WORKSPACE FOR STEP SIZES
!
      NALL0 = STKST(1)
!
      IFP = 4
!
      STPT = STKGET(NPAR,IFP)
!
      PARDF = STKGET(MBO, IFP)
      PARAR = STKGET(MBO, IFP)
      PARMA = STKGET(MBO, IFP)
      T = STKGET(2*MBO, IFP)
!
      TEMP = T + MBO
!
      NFACT = NFAC
      MSPECT = STKGET(4*NFAC, 2)
!
!     SET UP FOR MODEL
!
      APRXDV = .TRUE.
      M = 1
      IXM = N
      NRESTS = MBO + 101 + N
!
      CALL CPYVII(NFAC, MSPEC(1,1), 4, ISTAK(MSPECT), 1)
      CALL CPYVII(NFAC, MSPEC(2,1), 4, ISTAK(MSPECT+NFAC), 1)
      CALL CPYVII(NFAC, MSPEC(3,1), 4, ISTAK(MSPECT+2*NFAC), 1)
      CALL CPYVII(NFAC, MSPEC(4,1), 4, ISTAK(MSPECT+3*NFAC), 1)
      CALL DCOEF (NFAC, ISTAK(MSPECT+NFAC), ISTAK(MSPECT+3*NFAC),
     +  NPARDF, RSTAK(PARDF), MBO, RSTAK(T))
!
!     COPY SUPPLIED STEP SIZES TO WORK SPACE
!
      CALL DCOPY(LSTP, STP, 1, RSTAK(STPT), 1)
!
      IF (IERR.NE.0) GO TO 10
!
!     SELECT STEP SIZES, IF DESIRED
!
      ISUBHD = 1
      IF (STP(1).LE.0.0D0) CALL AMESTP(Y, N, M, IXM, MDLTS3, PAR, NPAR,
     +  RSTAK(STPT), EXMPT, NETA, SCALE, LSCALE, IPTOUT(1), AMEHDR,
     +  PAGE, WIDE, ISUBHD, HLFRPT, PRTFXD, IFIXED, LIFIXD, STPAMO,
     +  NRESTS-N)
!
      CALL AMECNT(Y, WT, LWT, Y, N, M, IXM, MDLTS1, NLDRVN, APRXDV, DRV,
     +  PAR, NPAR, RES, IFIXED, LIFIXD, RSTAK(STPT), NPAR, MIT,
     +  STOPSS, STOPP, SCALE, LSCALE, DELTA, IVAPRX, RSD, PV, LPV,
     +  SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV, WEIGHT, SAVE, NNZW,
     +  NPARE, AMEHDR, PAGE, WIDE, IPTOUT, NDIGIT, HLFRPT, NRESTS)
!
   10 CONTINUE
!
      CALL STKCLR(NALL0)
!
      RETURN
!
      END
!GETPI
      SUBROUTINE GETPI(PI)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SETS THE VALUE OF PI.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   PI
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION PI
!        THE VALUE OF PI.
!
      PI = 3.141592653589793238462643383279D0
      RETURN
      END
!FITXSP
      SUBROUTINE FITXSP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV,
     +   NNZW, NPARE, RSD)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     GENERATES REPORTS FOR LEAST SQUARES EXERCISER RETURNED STORAGE
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,N,NNZW,NPAR,NPARE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PV(N),RES(N),SDPV(N),SDRES(N),VCV(IVCV,NPAR)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,MATPRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        INDEX VARIABLE
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT
!     INTEGER IVCV
!        ACTUAL FIRST DIMENSION OF VCV
!     INTEGER N
!        NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        NUMBER OF PARAMETERS
!     INTEGER NPARE
!        NUMBER OF PARAMETERS ESTIMATED BY ROUTINE.
!     INTEGER NNZW
!        NUMBER OF NONZERO WEIGHTS.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ESTIMATED PARAMETERS.
!     DOUBLE PRECISION PV(N)
!        PREDICTED VALUES
!     DOUBLE PRECISION RES(N)
!        RESIDUALS
!     DOUBLE PRECISION RSD
!        RESIDUAL STANDARD DEVIATION
!     DOUBLE PRECISION SDPV(N)
!        STANDARD DEVIATION OF PREDICTED VALUES
!     DOUBLE PRECISION SDRES(N)
!        STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        VARIANCE COVARANCE MATRIX
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      DO 10 I=1,N
         IF (I.LE.NPAR) THEN
            WRITE (IPRT,1010) I,PAR(I),RES(I),PV(I),SDPV(I),SDRES(I)
         ELSE
            WRITE (IPRT,1070) I,RES(I),PV(I),SDPV(I),SDRES(I)
         END IF
   10 CONTINUE
      WRITE (IPRT,1030)
      CALL MATPRT(VCV, VCV, IVCV, IPRT, 1, 1, IVCV)
      WRITE (IPRT,1060) RSD
      WRITE (IPRT,1040) NNZW
      WRITE (IPRT,1050) NPARE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/12X, 3HPAR, 12X, 3HRES, 12X, 2HPV, 13X, 4HSDPV, 12X,
     +   5HSDRES/)
 1010 FORMAT (1X, I5, G14.7, 2X, 4(G14.7, 2X))
 1030 FORMAT (/27H VARIANCE COVARIANCE MATRIX)
 1040 FORMAT (8H NNZW = , I5)
 1050 FORMAT (9H NPARE = , I5)
 1060 FORMAT (/7H RSD = , G14.7)
 1070 FORMAT (1X, I5, 16X, 4(G14.7, 2X))
      END
!SUMWSS
      SUBROUTINE SUMWSS(X, W, N, LO, MID, HI, NNZW, SUM1, SUMW1, SUMW2,
     +   SUMWA, SUMW, XMEAN, XMEANW)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO CALCULATE WEIGHTED AND UNWEIGHTED SUMS OF
!     POWERS AND THE MEAN FOR A SORTED VECTOR IN WHICH THE MID TH
!     ELEMENT IS THE ELEMENT CLOSEST TO ZERO.  USED BY THE STAT
!     FAMILY.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SUM1,SUMW,SUMW1,SUMW2,SUMWA,XMEAN,XMEANW
      INTEGER
     +   HI,LO,MID,N,NNZW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   W(N),X(N)
!
!  LOCAL SCALARS
      INTEGER
     +   CURHI,CURLO,I,IREV
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CURHI
!        THE UPPER BOUND OF THE CURRENT INTERVAL.
!     INTEGER CURLO
!        THE LOWER BOUND OF THE CURRENT INTERVAL.
!     INTEGER HI
!        INPUT PARAMETER.  THE UPPER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER I
!        LOOP PARAMETER.
!     INTEGER IREV
!        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
!        IN THE REVERSE ORDER.
!     INTEGER LO
!        INPUT PARAMETER.  THE LOWER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER MID
!        INPUT PARAMETER.  THE INDEX OF THE ELEMENT IN X CLOSEST TO
!        ZERO IN VALUE.  THE POINT OUT FROM WHICH THE SUMMING IS
!        DONE.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
!     INTEGER NNZW
!        INPUT PARAMETER.  THE NUMBER OF POSITIVELY WEIGHTED VALUES
!        IN X.
!     DOUBLE PRECISION SUMW
!        OUTPUT PARAMETER.  THE SUM OF THE WEIGHTS WT(I).
!     DOUBLE PRECISION SUMWA
!        OUTPUT PARAMETER.  THE WEIGHTED SUM OF THE ABSOLUTE
!        VALUES OF THE ELEMENTS OF X.
!     DOUBLE PRECISION SUMW1
!        OUTPUT PARAMETER.  THE WEIGHTED SUM OF THE ELEMENTS OF
!        X.
!     DOUBLE PRECISION SUMW2
!        OUTPUT PARAMETER.  THE WEIGHTED SUM OF THE SQUARES OF
!        THE ELEMENTS OF X.
!     DOUBLE PRECISION SUM1
!        OUTPUT PARAMETER.  THE UNWEIGHTED SUM OF THE ELEMENTS OF X.
!     DOUBLE PRECISION W(N)
!        INPUT PARAMETER.  THE ARRAY OF WEIGHTS.
!     DOUBLE PRECISION X(N)
!        INPUT PARAMETER.  THE DATA ARRAY X IN WHICH THE SUMS ARE TAKEN.
!     DOUBLE PRECISION XMEAN
!        OUTPUT PARAMETER.  THE UNWEIGHTED MEAN OF X.
!     DOUBLE PRECISION XMEANW
!        OUTPUT PARAMETER.  THE WEIGHTED MEAN OF X.
!
!     INITIALIZE SUMMATION VARIABLES.
!
      SUM1 = 0.0D0
      SUMW1 = 0.0D0
      SUMW2 = 0.0D0
      SUMWA = 0.0D0
      SUMW = 0.0D0
      IF (W(MID).EQ.0.0D0) GO TO 10
      SUM1 = X(MID)
      SUMW1 = W(MID)*X(MID)
      SUMW2 = W(MID)*X(MID)*X(MID)
      SUMWA = W(MID)*ABS(X(MID))
      SUMW = W(MID)
   10 CURLO = MID - 1
      CURHI = MID + 1
!
!     SUM OUTWARDS, FROM THE VALUE NEAREST ZERO.  THAT IS, FROM
!     THE LEAST IN MAGNITUDE TO THE GREATEST.
!
   20 IF (CURHI.GT.HI .OR. CURLO.LT.LO) GO TO 60
      IF (ABS(X(CURHI)).LT.ABS(X(CURLO))) GO TO 40
      IF (W(CURLO).EQ.0.0D0) GO TO 30
      SUM1 = SUM1 + X(CURLO)
      SUMW1 = SUMW1 + W(CURLO)*X(CURLO)
      SUMW2 = SUMW2 + W(CURLO)*X(CURLO)*X(CURLO)
      SUMWA = SUMWA + W(CURLO)*ABS(X(CURLO))
      SUMW = SUMW + W(CURLO)
   30 CURLO = CURLO - 1
      GO TO 20
   40 IF (W(CURHI).EQ.0.0D0) GO TO 50
      SUM1 = SUM1 + X(CURHI)
      SUMW1 = SUMW1 + W(CURHI)*X(CURHI)
      SUMW2 = SUMW2 + W(CURHI)*X(CURHI)*X(CURHI)
      SUMWA = SUMWA + W(CURHI)*ABS(X(CURHI))
      SUMW = SUMW + W(CURHI)
   50 CURHI = CURHI + 1
      GO TO 20
!
!     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
!     CENTER ZERO POINT.
!
   60 IF (CURHI.GT.HI) GO TO 80
      DO 70 I=CURHI,HI
         IF (W(I).EQ.0.0D0) GO TO 70
         SUM1 = SUM1 + X(I)
         SUMW1 = SUMW1 + W(I)*X(I)
         SUMW2 = SUMW2 + W(I)*X(I)*X(I)
         SUMWA = SUMWA + W(I)*ABS(X(I))
         SUMW = SUMW + W(I)
   70 CONTINUE
   80 IF (CURLO.LT.LO) GO TO 100
      DO 90 IREV=LO,CURLO
         I = LO - IREV + CURLO
         IF (W(I).EQ.0.0D0) GO TO 90
         SUM1 = SUM1 + X(I)
         SUMW1 = SUMW1 + W(I)*X(I)
         SUMW2 = SUMW2 + W(I)*X(I)*X(I)
         SUMWA = SUMWA + W(I)*ABS(X(I))
         SUMW = SUMW + W(I)
   90 CONTINUE
  100 XMEAN = SUM1/NNZW
      XMEANW = SUMW1/SUMW
      RETURN
      END
!ERVGT
      SUBROUTINE ERVGT (NMSUB, NMVAR, VEC, N, VECLB, NVMX,
     +   HEAD, MSGTYP, NV, ERROR, NMMIN)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS TO ENSURE THAT NO VALUES, OR ONLY A MAXIMUM
!     OF NVMX, ARE NOT GREATER THAN A SPECIFIED LOWER BOUND VECLB,
!     WITH NAME NMMIN. THE ROUTINE ALTERNATIVELY CHECKS TO MAKE SURE
!     THAT NO VALUES ARE IN VIOLATION OF THIS LOWER BOUND IF THE FIRST
!     VALUE IN THE VECTOR IS NOT.  THE CHECKING OPTION IS SPECIFIED
!     WITH MSGTYP.  IF AN ERROR IS FOUND, THE ERROR IS PRINTED AND
!     AN ERROR FLAG AND THE NUMBER OF VIOLATINS ARE RETURNED.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VECLB
      INTEGER
     +   MSGTYP,N,NV,NVMX
      LOGICAL
     +   ERROR,HEAD
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VEC(*)
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
!
!  LOCAL SCALARS
      INTEGER
     +   I,NVMN
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ERVGTP
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MOD
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        THE VALUE RETURNED FROM THE ERROR CHECKING ROUTINES TO INDICATE
!        WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED (TRUE)
!        OR NOT (FALSE).
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER MSGTYP
!        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
!        IF (MSGTYP.GE.4) THE MESSAGE PRINTED WILL USE NMMIN
!        OTHERWISE IT WILL USE VECLB.
!        IF (MSGTYP = 1 OR 4) NO VIOLATIONS ARE ALLOWED.
!        IF (MSGTYP = 2 OR 5) THE NUMBER OF VIOLATIONS MUST
!                             BE LESS THAN   NVMX   .
!        IF (MSGTYP = 3 OR 6) VIOLATIONS ARE COUNTED ONLY IF THE
!                             THE FIRST ELEMENT IS NOT IN VIOLATION.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE ARGUMENTS NAME.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND.
!     INTEGER NVMN
!        THE SMALLEST NUMBER OF NON-VIOLATIONS ALLOWED.
!     INTEGER NVMX
!        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
!     DOUBLE PRECISION VEC(N)
!        THE VECTOR BEING TESTED.
!     DOUBLE PRECISION VECLB
!        THE VALUE THAT THE VECTOR IS BEING TESTED AGAINST.
!
      ERROR = .FALSE.
!
      IF (N .LE. 0) RETURN
!
!     TEST WHETHER TESTING IS NECESSRY
!
      IF ((MOD(MSGTYP,3) .EQ. 0) .AND. (VEC(1) .LE. VECLB)) RETURN
!
!     CHECK FOR VIOLATIONS
!
      NV = 0
      DO 5 I = 1, N
         IF ((VEC(I).LE.VECLB)) NV = NV + 1
    5 CONTINUE
!
      IF (NV .LE. NVMX) RETURN
!
!     VIOLATIONS FOUND
!
      ERROR = .TRUE.
      NVMN = N - NVMX
      CALL ERVGTP (NMSUB, NMVAR, VECLB, NVMN, NVMX, HEAD, MSGTYP, NV,
     +   NMMIN)
!
      RETURN
!
      END
!AOV1XP
      SUBROUTINE AOV1XP(GSTAT, IGSTAT, NG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     PRINT STORAGE FOR ONEWAY FAMILY EXERCISER
!     AND CLEAR STORAGE VECTORS
!
!     WRITTEN BY -
!        LINDA MITCHELL
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IGSTAT,NG
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   GSTAT(IGSTAT,4)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT,J
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,SETRA
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION GSTAT(IGSTAT,4)
!        THE GROUP STATISTICS.  COLUMNS CORRESPOND TO THE TAG
!        VALUE, SAMPLE SIZE, GROUP MEAN, AND GROUP STANDARD DEVIATION.
!     INTEGER I
!        AN INDEX VALUE
!     INTEGER IGSTAT
!        THE FIRST DIMENSION OF GSTAT.
!     INTEGER IPRT
!        THE OUTPUT LOGICAL UNIT NUMBER
!     INTEGER J, NG
!        *
!
!     COMMENCE BODY OF ROUTINE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      WRITE (IPRT,1010) ((GSTAT(I,J),J=1,4),I=1,NG)
      CALL SETRA(GSTAT, IGSTAT, 4, NG, 0.0D0)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(//21H STORAGE FROM AOV1   //6X, 8HTAGVALUE,
     +   11X, 10H GROUPSIZE, 11X, 10H GROUPMEAN, 13X, 8H GROUPSD/)
 1010 FORMAT(4(1X, G20.14))
      END
!CCFXP
      SUBROUTINE CCFXP (STORE, LAGMAX, M, CCOV, ICCOV, JCCOV, MISS,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO LIST THE COMPUTED RESULTS FROM THE TIME SERIES
!     CROSS CORRELATION ROUTINES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CMISS
      INTEGER
     +   ICCOV,INLPPC,JCCOV,JNLPPC,LAGMAX,M
      LOGICAL
     +   MISS,STORE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(ICCOV,JCCOV,*)
      INTEGER
     +   NLPPC(INLPPC,JNLPPC,*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT,J,K,L,L1,LAG
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCF(16)
!
!  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCF(16)
!        AN ARRAY USED FOR PRINTING THE CCF.
!     DOUBLE PRECISION CCOV(ICCOV,JCCOV,M)
!        THE CROSS COVARIANCE ARRAY.
!     DOUBLE PRECISION CMISS
!        THE MISSING VALUE CODE FOR THE RETURNED CCVF ESTIMATES
!        (VECTOR CCOV).
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER J
!        AN INDEXING VARIABLE.
!     INTEGER JCCOV, JNLPPC
!        THE SECOND DIMENSIONS OF THE ARRAYS CCOV AND NLPPC,
!        RESPECTIVELY.
!     INTEGER K
!        AN INDEXING VARIABLE.
!     INTEGER L1
!        AN INDEX VARIABLE.
!     INTEGER LAG
!        THE LAG VALUE AT WHICH THE DATA IS BEING PRINTED.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER M
!        THE NUMBER OF SERIES IN THE MULTIVARIATE TIME SERIES YM.
!     LOGICAL MISS
!        THE VALUE INDICATING WHETHER THE ANALYSIS INCLUDED MISSING
!        DATA (TRUE) OR NOT (FALSE).
!     INTEGER NLPPC(INLPPC,JNLPPC,M)
!        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
!        USED TO COMPUTE EACH CCVF ESTIMATE.
!     LOGICAL STORE
!        THE VALUE INDICATING WHETHER THE RESULTS WERE RETURNED
!        TO THE USER (TRUE) OR NOT (FALSE).
!
      CALL IPRINT(IPRT)
!
!     PRINT IERR
!
      WRITE (IPRT, 1000) IERR
!
      IF (IERR.NE.0) RETURN
!
!     CHECK FOR STORED RESULTS
!
      IF (.NOT.STORE) RETURN
!
!     PRINT HEADING FOR CCVF
!
      WRITE (IPRT, 1010)
      WRITE (IPRT, 1040) ((J,K, K=1,M), J=1,M)
!
!     PRINT CROSS COVARIANCES
!
      LAG = 0
      WRITE (IPRT, 1060) LAG, ((CCOV(1,J,K), K=1,M), J=1,M)
      DO 10 LAG = 1, LAGMAX
         WRITE (IPRT, 1060) LAG, ((CCOV(LAG+1,J,K), K=1,M), J=1,M)
   10 CONTINUE
!
!     PRINT HEADING FOR CCF
!
      WRITE (IPRT, 1020)
      WRITE (IPRT, 1040) ((J,K, K=1,M), J=1,M)
!
!     PRINT CROSS CORRELATIONS
!
      LAG = 0
      I = 0
      DO 30 J = 1, M
         DO 20 K = 1, M
            I = I + 1
            CCF(I) = CCOV(1,J,K) / SQRT(CCOV(1,J,J)*CCOV(1,K,K))
   20    CONTINUE
   30 CONTINUE
      WRITE (IPRT, 1060) LAG, (CCF(L), L=1,I)
!
      DO 60 LAG = 1, LAGMAX
         I = 0
         DO 50 J = 1, M
            DO 40 K = 1, M
               I = I + 1
               IF (.NOT.MISS) GO TO 35
               CCF(I) = CMISS
               IF (MVCHK(CCOV(LAG+1,J,K),CMISS)) GO TO 40
   35          CCF(I) = CCOV(LAG+1,J,K) / SQRT(CCOV(1,J,J)*CCOV(1,K,K))
   40       CONTINUE
   50    CONTINUE
         WRITE (IPRT, 1060) LAG, (CCF(L1), L1=1,I)
   60 CONTINUE
!
!     CHECK FOR MISSING VALUES
!
      IF (.NOT.MISS) RETURN
!
!     PRINT HEADING FOR NUMBERS OF LAGGED PRODUCT PAIRS
!
      WRITE (IPRT, 1030)
      WRITE (IPRT, 1040) ((J,K, K=1,M), J=1,M)
!
!     PRINT NUMBERS OF LAGGED PRODUCT PAIRS FOR EACH CCVF
!
      LAG = 0
      WRITE (IPRT, 1070) LAG, ((NLPPC(1,J,K), K=1,M), J=1,M)
      DO 70 LAG = 1, LAGMAX
         WRITE (IPRT, 1070) LAG, ((NLPPC(LAG+1,J,K), K=1,M), J=1,M)
   70 CONTINUE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (//8H IERR = , I5)
 1010 FORMAT (// 6X, 6H  CCVF)
 1020 FORMAT (// 6X, 6H   CCF)
 1030 FORMAT (// 6X, 6H NLPPC)
 1040 FORMAT (1X, 3HLAG, 16(5X, I1, ',', I1))
 1060 FORMAT (1X, I3, 16F8.4)
 1070 FORMAT (1X, I3, 16I8)
      END
!GFAEST
      SUBROUTINE GFAEST (PHI, IAR, NF, FREQ, GAIN, PHAS, DELTA)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE GAIN FUNCTION OF AN AUTOREGRESSIVE
!     LINEAR FILTER USING THE ALGORITHM GIVEN ON PAGES 419 AND 420
!     JENKINS AND WATTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA
      INTEGER
     +   IAR,NF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),GAIN(NF),PHAS(NF),PHI(IAR)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ARG,C,PI,S,V0,V1,V2,Z0,Z1,Z2
      INTEGER
     +   I,J,JJ
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ATAN2,COS,SIN,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ARG
!        A VALUE USED TO COMPUTE THE GAIN FUNCTION ESTIMATES.
!     DOUBLE PRECISION C
!        A VALUE USED TO COMPUTE THE GAIN FUNCTION ESTIMATES.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL OF THE ORIGINAL SERIES.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO
!        BE ESTIMATED.
!     DOUBLE PRECISION GAIN(NF)
!        THE ARRAY IN WHICH THE GAIN FUNCTION ESTIMATES ARE RETURNED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER J, JJ
!        INDEX VARIABLES.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE GAIN FUNCTION ESTIMATES
!        ARE TO BE COMPUTED.
!     DOUBLE PRECISION PHAS(NF)
!        THE ARRAY IN WHICH THE PHASE OF THE FILTER IS RETURNED.
!     DOUBLE PRECISION PHI(IAR)
!        THE VECTOR CONTAINING THE AUTOREGRESSIVE FILTER COEFFICIENTS.
!     DOUBLE PRECISION PI
!        THE VALUE OF PI.
!     DOUBLE PRECISION S
!        A VALUE USED TO COMPUTE THE GAIN FUNCTION ESTIMATES.
!     DOUBLE PRECISION V0, V1, V2
!        CONSTANTS USED FOR COMPUTING THE GAIN FUNCTION ESTIMATES.
!     DOUBLE PRECISION Z0, Z1, Z2
!        CONSTANTS USED FOR COMPUTING THE GAIN FUNCTION ESTIMATES.
!
      CALL GETPI(PI)
!
!     COMPUTE GAIN FUNCTION ESTIMATES AND THEIR CONFIDENCE LIMITS.
!
      DO 30 I = 1, NF
         IF (FREQ(I).EQ.0.0D0) THEN
            ARG = 0.0D0
            C = 1.0D0
            S = 0.0D0
         ELSE IF (FREQ(I).EQ.0.25D0) THEN
            ARG = PI/2.0D0
            C = 0.0D0
            S = 1.0D0
         ELSE IF (FREQ(I).EQ.0.5D0) THEN
            ARG = PI
            C = -1.0D0
            S = 0.0D0
         ELSE
            ARG = 2.0D0 * PI * FREQ(I)
            C = COS(ARG)
            S = SIN(ARG)
         END IF
         V0 = 0.0D0
         V1 = 0.0D0
         Z0 = 0.0D0
         Z1 = 0.0D0
!
         JJ = IAR + 1
!
         DO 20 J = 1, IAR
            JJ = JJ -1
!
            V2 = C * V1 - V0 - PHI(JJ)
            V0 = V1
            V1 = V2
!
            Z2 = S * Z1 - Z0 - PHI(JJ)
            Z0 = Z1
            Z1 = Z2
   20    CONTINUE
!
         V2 = DELTA * (1.0D0 + (V1 * C - V0))
!
         Z2 = DELTA * Z1 * S
!
         GAIN(I) = SQRT(V2*V2 + Z2*Z2)
!
         PHAS(I) = -0.5D0 * PI
         IF (Z2.NE.0.0D0 .AND. V2.NE.0.0D0) PHAS(I) = ATAN2(Z2, V2)
!
   30 CONTINUE
!
      RETURN
      END
!XUAS
      SUBROUTINE XUAS(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE AUTOREGRESSIVE SPECTRUM ANALYSIS ROUTINES
!
!     SERIES Y IS THE FIRST 50 VALUES OF THE SERIES LISTED ON PAGE
!     318 OF JENKINS AND WATTS.  THE SPECTRUM OF THIS SERIES IS SHOWN
!     FOR VARIOUS BANDWIDTH ON PAGE 270 OF JENKINS AND WATTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FMAX,FMIN,YMISS
      INTEGER
     +   I,IAR,IPRT,LACOV,LAG,LAGMAX,LDS,LYFFT,NF,NPRT,NY
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),FREQ(300),PHI(101),SPCA(101),SPCF(101),Y(150),
     +   YFFT(400)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACFS,IPRINT,DCOPY,SETRV,UAS,UASF,UASFS,UASS,UASV,UASVS
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(101)
!        THE AUTOCOVARIANCE VECTOR.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCIES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(300)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE MODEL TO BE USED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAG, LAGMAX
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCOVARIANCE BEING COMPUTED AND THE MAXIMUM LAG TO BE USED,
!        RESPECTIVELY.
!     INTEGER LDS
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NY
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     DOUBLE PRECISION PHI(101)
!        THE VECTOR OF THE ORDER IAR AUTOREGRESSIVE MODEL COEFFICIENTS.
!     DOUBLE PRECISION SPCA(101)
!        THE ARRAYS IN WHICH THE AUTOREGRESSIVE SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     DOUBLE PRECISION SPCF(101)
!        THE ARRAYS IN WHICH THE FOURIER SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     DOUBLE PRECISION Y(150)
!         THE ARRAY CONTAINING THE TIME SERIES FROM JENKINS AND WATTS.
!     DOUBLE PRECISION YFFT(400)
!        THE VECTOR OF THE OBSERVED TIME SERIES TO BE ANALYZED USING
!        THE FFT.
!     DOUBLE PRECISION YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!
!
      DATA   Y(  1), Y(  2), Y(  3), Y(  4), Y(  5), Y(  6)
     +    /-0.88D0, -0.12D0, -0.89D0, -1.38D0, -0.07D0,  1.03D0/
      DATA   Y(  7), Y(  8), Y(  9), Y( 10), Y( 11), Y( 12)
     +    / 2.14D0,  0.35D0, -1.10D0, -1.78D0, -2.76D0, -1.77D0/
      DATA   Y( 13), Y( 14), Y( 15), Y( 16), Y( 17), Y( 18)
     +    / 0.98D0,  1.00D0, -0.70D0, -1.01D0, -1.30D0, -0.85D0/
      DATA   Y( 19), Y( 20), Y( 21), Y( 22), Y( 23), Y( 24)
     +    /-0.46D0,  1.63D0,  0.06D0, -0.17D0, -1.01D0, -1.04D0/
      DATA   Y( 25), Y( 26), Y( 27), Y( 28), Y( 29), Y( 30)
     +    /-0.66D0, -1.12D0, -0.51D0, -0.71D0, -0.20D0, -0.13D0/
      DATA   Y( 31), Y( 32), Y( 33), Y( 34), Y( 35), Y( 36)
     +    / 0.14D0,  1.59D0, -0.76D0, -1.08D0, -1.77D0, -1.20D0/
      DATA   Y( 37), Y( 38), Y( 39), Y( 40), Y( 41), Y( 42)
     +    / 0.45D0, -0.07D0, -0.63D0, -0.35D0, -0.87D0, -0.62D0/
      DATA   Y( 43), Y( 44), Y( 45), Y( 46), Y( 47), Y( 48)
     +    / 0.28D0,  1.90D0,  2.14D0,  1.05D0,  0.31D0,  1.07D0/
      DATA   Y( 49), Y( 50)
     +    / 2.67D0,  2.44D0/
!
!
      CALL IPRINT(IPRT)
!
!     CHECK ERROR HANDLING
!
!        TEST 1  -  MISCELANEOUS ERROR CHECKING
!
      WRITE (IPRT, 2000)
      YMISS = 1.16D0
      LAGMAX = -1
      NY = -10
      LACOV = 101
      LAG = -2
      IAR = -2
      LYFFT = -11
      NF = -5
      FMIN = 0.5D0
      FMAX = 0.0D0
      NPRT = -1
      LDS = 0
      WRITE(IPRT, 1001)
      CALL UAS(Y, NY)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1003)
      CALL UASS(Y, NY, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT,SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1019)
      CALL UASF (YFFT, NY, LYFFT, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1020)
      CALL UASFS(YFFT, NY, LYFFT, LDS, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1007)
      CALL UASV(ACOV, LAGMAX, NY)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1008)
      CALL UASVS(ACOV, LAGMAX, Y, NY, IAR, PHI, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!        TEST 2  -  MISCELANEOUS ERROR CHECKING (CONTINUED)
!
      WRITE (IPRT, 2010)
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 50
      LAG = 101
      IAR = 101
      CALL SETRV(PHI, IAR, 2.0D0)
      CALL SETRV(ACOV, LAGMAX+1, 2.0D0)
      ACOV(1) = 1.0D0
      LYFFT = -11
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 5
      LDS = 0
      WRITE(IPRT, 1003)
      CALL UASS(Y, NY, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1019)
      CALL UASF (YFFT, NY, LYFFT, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1020)
      CALL UASFS(YFFT, NY, LYFFT, LDS, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1007)
      CALL UASV(ACOV, LAGMAX, NY)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1008)
      CALL UASVS(ACOV, LAGMAX, Y, NY, IAR, PHI, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!        TEST 3  -  LDS TOO SMALL
!
      WRITE (IPRT, 2030)
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      LAG = 16
      IAR = 2
      PHI(1) = 1.0D0
      PHI(2) = -0.5D0
      CALL ACFS (Y, NY, LAGMAX, LACOV, ACOV, IAR, PHI, 0, 700)
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 3
      LDS = 0
      WRITE(IPRT, 1003)
      CALL UASS(Y, NY, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1019)
      CALL UASF (YFFT, NY, LYFFT, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1020)
      CALL UASFS(YFFT, NY, LYFFT, LDS, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1008)
      CALL UASVS(ACOV, LAGMAX, Y, NY, IAR, PHI, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!     CHECK RESULTS FROM VALID CALL
!
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      LAG = 16
      IAR = 2
      PHI(1) = 1.0D0
      PHI(2) = -0.5D0
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 2
      LDS = 700
!
!     TEST OF UAS
!
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1001)
      CALL UAS(Y, NY)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF UASS
!
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1003)
      CALL UASS(Y, NY, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM UASS
!
      WRITE (IPRT, 1004) (FREQ(I), SPCA(I), SPCF(I), I=1,NF)
      WRITE (IPRT, 1005) IAR, LAG
      WRITE (IPRT, 1006) (PHI(I), I=1,ABS(IAR))
!
!     TEST OF UASF
!
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1019)
      CALL DCOPY(NY, Y, 1, YFFT, 1)
      CALL UASF (YFFT, NY, LYFFT, LDS)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF UASFS
!
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1020)
      CALL DCOPY(NY, Y, 1, YFFT, 1)
      CALL UASFS(YFFT, NY, LYFFT, LDS, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM UASFS
!
      WRITE (IPRT, 1004) (FREQ(I), SPCA(I), SPCF(I), I=1,NF)
      WRITE (IPRT, 1005) IAR, LAG
      WRITE (IPRT, 1006) (PHI(I), I=1,ABS(IAR))
!
!     TEST OF UASV
!
      WRITE(IPRT, 2020)
      WRITE (IPRT, 1007)
      CALL UASV(ACOV, LAGMAX, NY)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF UASVS
!
      WRITE(IPRT, 2020)
      WRITE (IPRT, 1008)
      CALL UASVS(ACOV, LAGMAX, Y, NY, IAR, PHI, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM UASVS
!
      WRITE (IPRT, 1004) (FREQ(I), SPCA(I), SPCF(I), I=1,NF)
      WRITE (IPRT, 1005) IAR, LAG
      WRITE (IPRT, 1006) (PHI(I), I=1,ABS(IAR))
!
!     MINIMUM PROBLEM SIZE
!
      YMISS = 1.16D0
      NY = 17
      LAGMAX = 1
      LYFFT = 400
      LAG = 1
      IAR = -1
      PHI(1) = 1.0D0
      PHI(2) = -0.5D0
      NF = 1
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 2
      LDS = LDSTAK
!
!     TEST OF UAS
!
      WRITE (IPRT, 2060)
      WRITE(IPRT, 1001)
      CALL UAS(Y, NY)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF UASS
!
      WRITE(IPRT, 2060)
      WRITE(IPRT, 1003)
      CALL UASS(Y, NY, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM UASS
!
      WRITE (IPRT, 1004) (FREQ(I), SPCA(I), SPCF(I), I=1,NF)
      WRITE (IPRT, 1005) IAR, LAG
      WRITE (IPRT, 1006) (PHI(I), I=1,ABS(IAR))
!
!     CHECK HANDLING OF FMIN AND FMAX, AND LAG.EQ.0 AND IAR.EQ.0
!
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      LAG = 0
      IAR = 0
      PHI(1) = 1.0D0
      PHI(2) = -0.5D0
      NF = 51
      FMIN = 0.45D0
      FMAX = 0.5D0
      NPRT = 2
!
!     TEST OF UASS
!
      WRITE(IPRT, 2070)
      WRITE(IPRT, 1003)
      CALL UASS(Y, NY, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM UASS
!
      WRITE (IPRT, 1004) (FREQ(I), SPCA(I), SPCF(I), I=1,NF)
      WRITE (IPRT, 1005) IAR, LAG
      WRITE (IPRT, 1006) (PHI(I), I=1,ABS(IAR))
!
!     WHITE NOISE SPECTRUM
!
      YMISS = 1.16D0
      CALL SETRV(YFFT, NY, 0.0D0)
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      LAG = 16
      IAR = 2
      PHI(1) = 1.0D0
      PHI(2) = -0.5D0
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 2
!
!     TEST OF UASS
!
      WRITE(IPRT, 2080)
      WRITE(IPRT, 1003)
      CALL UASS(YFFT, NY, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM UASS
!
      WRITE (IPRT, 1004) (FREQ(I), SPCA(I), SPCF(I), I=1,NF)
      WRITE (IPRT, 1005) IAR, LAG
      WRITE (IPRT, 1006) (PHI(I), I=1,ABS(IAR))
!
!     SUPPRESS OUTPUT AND
!     CHECK HANDLING OF LAG .LT.0 AND IAR .LT. 0
!
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      LAG = 0
      IAR = 0
      PHI(1) = 1.0D0
      PHI(2) = -0.5D0
      NF = 51
      FMIN = 0.45D0
      FMAX = 0.5D0
      NPRT = 0
!
!     TEST OF UASS
!
      WRITE(IPRT, 2090)
      WRITE(IPRT, 1003)
      CALL UASS(Y, NY, IAR, PHI, LAGMAX, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM UASS
!
      WRITE (IPRT, 1004) (FREQ(I), SPCA(I), SPCF(I), I=1,NF)
      WRITE (IPRT, 1005) IAR, LAG
      WRITE (IPRT, 1006) (PHI(I), I=1,ABS(IAR))
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1001 FORMAT (12H TEST OF UAS)
 1002 FORMAT (/8H IERR IS, I5/)
 1003 FORMAT (13H TEST OF UASS)
 1004 FORMAT (3(1X, E16.8))
 1005 FORMAT (/7H IAR = , I5/7H LAG = , I5)
 1006 FORMAT (/7H PHI = , (1X, 5D21.8))
 1007 FORMAT (13H TEST OF UASV)
 1008 FORMAT (14H TEST OF UASVS)
 1019 FORMAT (13H TEST OF UASF)
 1020 FORMAT (14H TEST OF UASFS)
 2000 FORMAT (32H1CHECK ERROR HANDLING  -  TEST 1)
 2010 FORMAT (32H1CHECK ERROR HANDLING  -  TEST 2)
 2020 FORMAT (14H1VALID PROBLEM)
 2030 FORMAT (14H1LDS TOO SMALL)
 2060 FORMAT (21H1MINIMUM PROBLEM SIZE)
 2070 FORMAT (
     +   59H1CHECK HANDLING OF FMIN AND FMAX, LAG AND IAR EQUAL TO ZERO)
 2080 FORMAT (21H1WHITE NOISE SPECTRUM)
 2090 FORMAT (44H1SUPPRESS OUTPUT, LAG AND IAR LESS THAN ZERO)
      END
!MVPL
      SUBROUTINE MVPL(YM, N, M, IYM, NS, ILOG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MULTIPLE Y-AXIS VALUES (LOG PLOT OPTION).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,IYM,M,N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,IPRT,IRLIN,ISCHCK,ISIZE,LISYM
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'V',       'P',       'L',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      MULTI = .TRUE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 2
      ISIZE = -1
      MISS = .FALSE.
      LISYM = 1
      IRLIN = -1
      IBAR = 0
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YM, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL MVPL (YM, N, M, IYM, NS, ILOG)')
      END
!ERSGE
      SUBROUTINE ERSGE(NMSUB, NMVAR, VAL, VALMN, MSGTYP, HEAD, ERROR,
     +   NMMIN)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THE ROUTINE CHECKS WHETHER THE VALUE   VAL   IS GREATER THAN OR
!     EQUAL TO   VALMN   , AND PRINTS A DIAGNOSTIC IF IT IS NOT.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VAL,VALMN
      INTEGER
     +   MSGTYP
      LOGICAL
     +   ERROR,HEAD
!
!  ARRAY ARGUMENTS
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
!        PRINTED, WHERE IF ERROR IS .TRUE. AND
!        MSGTYP = 1 THE INPUT VALUE WAS TOO SMALL BASED
!                   ON LIMITS IMPOSED BY STARPAC
!        MSGTYP = 2 THE INPUT VALUE WAS TOO SMALL BASED ON
!                   LIMITS BASED ON OTHER INPUT ARGUMENTS.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE ARGUMENTS NAME.
!     DOUBLE PRECISION VAL
!        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
!     DOUBLE PRECISION VALMN
!        THE MINIMUM VALUE THE ARGUMENT CAN VALIDLY HAVE.
!
      ERROR = .FALSE.
!
      IF (VAL .GE. VALMN) RETURN
!
      ERROR = .TRUE.
      CALL IPRINT (IPRT)
      CALL EHDR(NMSUB, HEAD)
!
      WRITE (IPRT, 1000) (NMVAR(I),I=1,6), VAL
!
      GO TO (10, 20), MSGTYP
!
!     PRINT MESSAGE FOR VALUE TOO SMALL BASED ON LIMITS IMPOSED
!     BY STARPAC.
!
   10 WRITE (IPRT, 1010) (NMVAR(I),I=1,6), VALMN
      RETURN
!
   20 WRITE (IPRT, 1020) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/20H THE INPUT VALUE OF , 6A1, 4H IS , G15.8, '.')
 1010 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   34H MUST BE GREATER THAN OR EQUAL TO , G21.14, '.')
 1020 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   34H MUST BE GREATER THAN OR EQUAL TO , 8A1, '.')
!
      END
!XAOV1
      SUBROUTINE XAOV1(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE EXCERCISES THE ONEWAY FAMILY ROUTINES.
!
!     WRITTEN BY -
!        LINDA MITCHELL
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FI
      INTEGER
     +   I,IGSTAT,IPRT,LDSMIN,N,NG
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   GSTAT(10,4),TAG(20),Y(20),Z(10),ZTAG(10)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AOV1,AOV1S,AOV1XP,IPRINT,LDSCMP,MSGX,SETRV
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (APHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FI
!        FLOAT OF INDEX I
!     DOUBLE PRECISION GSTAT(10,4)
!        THE GROUP STATISTICS.  COLUMNS CORRESPOND TO THE TAG
!        VALUE, SAMPLE SIZE, GROUP MEAN, AND GROUP STANDARD DEVIATION.
!     INTEGER I
!        INDEX VARIABLE
!     INTEGER IERR
!        COMMON FLAG INDICATING WHETHER OR NOT THERE WERE ANY ERRORS
!     INTEGER IGSTAT
!        THE FIRST DIMENSION OF GSTAT.
!     INTEGER IPRT
!        THE OUTPUT LOGICAL UNIT NUMBER
!     INTEGER LDSMIN
!        THE SMALLEST ACCEPTABLE SIZE OF THE COMMON CSTAK
!     INTEGER LDSTAK
!        THE SIZE OF THE COMMON CSTAK
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NG
!        THE NUMBER OF DIFFERENT GROUPS
!     DOUBLE PRECISION TAG(20)
!        THE TAG VALUES FOR EACH OBSERVATION
!     DOUBLE PRECISION Y(20)
!        THE VECTOR OF OBSERVATIONS
!     DOUBLE PRECISION Z(10)
!        TEST VECTOR
!     DOUBLE PRECISION ZTAG(10)
!        TEST TAG VECTOR
!
      DATA   Y( 1),   Y( 2),   Y( 3),   Y( 4),   Y( 5)
     +   /    61.0D0,    61.0D0,    67.0D0,    67.0D0,    64.0D0/
      DATA   Y( 6),   Y( 7),   Y( 8),   Y( 9),   Y(10)
     +   /    78.0D0,    71.0D0,    75.0D0,    72.0D0,    74.0D0/
      DATA   Y(11),   Y(12),   Y(13),   Y(14),   Y(15)
     +   /    83.0D0,    81.0D0,    76.0D0,    78.0D0,    79.0D0/
      DATA   Y(16),   Y(17)
     +   /    72.0D0,   72.0D0/
!
      DATA TAG( 1), TAG( 2), TAG( 3), TAG( 4), TAG( 5)
     +   /    11.5D0,    11.5D0,    11.5D0,    11.5D0,    11.5D0/
      DATA TAG( 6), TAG( 7), TAG( 8), TAG( 9), TAG(10)
     +   /    12.0D0,    12.0D0,    12.0D0,    12.0D0,    12.0D0/
      DATA TAG(11), TAG(12), TAG(13), TAG(14), TAG(15)
     +   /    11.0D0,    11.0D0,    11.0D0,    11.0D0,    11.0D0/
      DATA TAG(16), TAG(17)
     +   /   -11.0D0,   11.0D0/
!
      CALL IPRINT(IPRT)
!
!     SET VARIOUS DIMENSIONS AND PROGRAM VARIABLES
!
      N = 17
      IGSTAT = 10
!
!**** TEST WITH CORRECT CALL STATEMENTS ****
!
      WRITE (IPRT,1060)
!
!     TEST AOV1
!
      WRITE (IPRT,1000)
      CALL AOV1(Y, TAG, N, LDSTAK)
      CALL MSGX(0, IPRT)
      WRITE (IPRT,1010)
      WRITE (IPRT,1020) (TAG(I),I=1,N)
!
!     TEST OF AOV1S
!
!     PRINTOUT NOT SUPRESSED
!
      WRITE (IPRT,1040)
      WRITE (IPRT,1030)
      CALL AOV1S(Y, TAG, N, LDSTAK, 1, GSTAT, IGSTAT, NG)
      CALL MSGX(0, IPRT)
!
!     PRINT STORAGE AND ZERO VECTORS BEFORE USING AGAIN
!
      CALL AOV1XP(GSTAT, IGSTAT, NG)
!
!     PRINTOUT SUPRESSED
!
      WRITE (IPRT,1050)
      CALL AOV1S(Y, TAG, N, LDSTAK, 0, GSTAT, IGSTAT, NG)
      CALL MSGX(0, IPRT)
!
!     PRINT STORAGE AND ZERO VECTORS BEFORE USING AGAIN
!
      CALL AOV1XP(GSTAT, IGSTAT, NG)
!
!**** NUMBER OF OBSERVATIONS LESS THAN 2 ****
!
      WRITE (IPRT,1090)
      CALL AOV1(Y, TAG, 1, LDSTAK)
      CALL MSGX(1, IPRT)
!
      CALL AOV1S(Y, TAG, -14, LDSTAK, 0, GSTAT, IGSTAT, NG)
      CALL MSGX(1, IPRT)
!
!**** ALL OBSERVATIONS THE SAME VALUE ****
!
      WRITE (IPRT,1100)
      WRITE (IPRT,1000)
      CALL SETRV(Z, 10, 0.0D0)
      CALL AOV1(Z, TAG, 10, LDSTAK)
      CALL MSGX(0, IPRT)
!
      CALL SETRV(Z, 10, 2.0D0)
      WRITE (IPRT,1100)
      WRITE (IPRT,1030)
      CALL AOV1S(Z, TAG, 10, LDSTAK, 1, GSTAT, IGSTAT, NG)
      CALL MSGX(0, IPRT)
!
!**** TEST WORK AREA SIZE HANDLING ****
!
      CALL LDSCMP(11, 0, 33, 0, 0, 0, 'D', 40, LDSMIN)
      WRITE (IPRT,1070)
      WRITE (IPRT,1000)
      CALL AOV1(Y, TAG, N, 1)
      CALL MSGX(1, IPRT)
      WRITE (IPRT,1070)
      WRITE (IPRT,1000)
      CALL AOV1(Y, TAG, N, LDSMIN-1)
      CALL MSGX(1, IPRT)
      WRITE (IPRT,1010)
      WRITE (IPRT,1020) (TAG(I),I=1,N)
      WRITE (IPRT,1080)
      WRITE (IPRT,1000)
      CALL AOV1(Y, TAG, N, LDSMIN)
      CALL MSGX(0, IPRT)
!
      CALL LDSCMP(11, 0, 33, 0, 0, 0, 'D', 28, LDSMIN)
      WRITE (IPRT,1070)
      WRITE (IPRT,1030)
      CALL AOV1S(Y, TAG, N, 1, 0, GSTAT, IGSTAT, NG)
      CALL MSGX(1, IPRT)
      WRITE (IPRT,1070)
      WRITE (IPRT,1030)
      CALL AOV1S(Y, TAG, N, LDSMIN-1, 0, GSTAT, IGSTAT, NG)
      CALL MSGX(1, IPRT)
      WRITE (IPRT,1010)
      WRITE (IPRT,1020) (TAG(I),I=1,N)
      WRITE (IPRT,1080)
      WRITE (IPRT,1030)
      CALL AOV1S(Y, TAG, N, LDSMIN, 1, GSTAT, IGSTAT, NG)
      CALL MSGX(0, IPRT)
!
!**** SAME NUMBER OF GROUPS AS NON-ZERO TAGS ****
!
      WRITE (IPRT,1120)
      DO 20 I=1,10
         FI = I
         ZTAG(I) = FI
         Z(I) = 13.0D0 - FI
   20 CONTINUE
      CALL AOV1(Z, ZTAG, 10, LDSTAK)
      CALL MSGX(1, IPRT)
      CALL AOV1S(Z, ZTAG, 10, LDSTAK, 1, GSTAT, IGSTAT, NG)
      CALL MSGX(1, IPRT)
!
!**** LESS THAN 2 DIFFERENT TAG GROUPS ****
!
      WRITE (IPRT,1130)
      CALL SETRV(ZTAG, 10, 1.0D0)
      CALL AOV1(Z, ZTAG, 10, LDSTAK)
      CALL MSGX(1, IPRT)
      CALL AOV1S(Z, ZTAG, 10, LDSTAK, 1, GSTAT, IGSTAT, NG)
      CALL MSGX(1, IPRT)
!
!**** LESS THAN 2 TAGS ****
!
      CALL SETRV(ZTAG, 9, 0.0D0)
      WRITE (IPRT,1140)
      CALL AOV1(Z, ZTAG, 10, LDSTAK)
      CALL MSGX(1, IPRT)
      CALL AOV1S(Z, ZTAG, 10, LDSTAK, 1, GSTAT, IGSTAT, NG)
      CALL MSGX(1, IPRT)
!
!**** INCORRECT DIMENSION OF GSTAT ****
!
      WRITE (IPRT,1150)
      CALL AOV1S(Y, TAG, N, LDSTAK, 1, GSTAT, 2, NG)
      CALL MSGX(1, IPRT)
!
!**** ALL OBSERVATIONS WITHIN A GROUP SAME VALUE ****
!
      Z(1) = 53.0D0
      ZTAG(1) = 1.0D0
      Z(2) = 62.0D0
      ZTAG(2) = 3.0D0
      Z(3) = 53.0D0
      ZTAG(3) = 1.0D0
      Z(4) = 71.0D0
      ZTAG(4) = 4.0D0
      Z(5) = 89.0D0
      ZTAG(5) = 2.0D0
      Z(6) = 71.0D0
      ZTAG(6) = 4.0D0
      Z(7) = 89.0D0
      ZTAG(7) = 2.0D0
      Z(8) = 62.0D0
      ZTAG(8) = 3.0D0
      Z(9) = 71.0D0
      ZTAG(9) = 4.0D0
      Z(10) = 62.0D0
      ZTAG(10) = 3.0D0
      WRITE (IPRT,1160)
      CALL AOV1(Z, ZTAG, 10, LDSTAK)
      CALL MSGX(0, IPRT)
!
!**** 2 TAGS ****
!
      WRITE (IPRT,1170)
      CALL AOV1(Z, ZTAG, 3, LDSTAK)
      CALL MSGX(0, IPRT)
!
!**** ALL GROUPS(EXCEPT FOR 1) WITH 1 OBSERVATION ****
!
      WRITE (IPRT,1180)
      CALL AOV1(Z, ZTAG, 5, LDSTAK)
      CALL MSGX(0, IPRT)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(' TEST OF AOV1 ')
 1010 FORMAT(' CHECK TO SEE IF TAGS HAVE BEEN CHANGED')
 1020 FORMAT(4F12.6)
 1030 FORMAT(' TEST OF AOV1S ')
 1040 FORMAT('1PRINTOUT NOT SUPRESSED.')
 1050 FORMAT(' PRINTOUT SUPRESSED.')
 1060 FORMAT('1****TEST ROUTINES WITH CORRECT CALL****')
 1070 FORMAT('1****TEST WITH INSUFFICIENT WORK AREA****')
 1080 FORMAT('1****TEST WITH EXACTLY THE RIGHT AMOUNT OF WORK AREA****')
 1090 FORMAT('1****NUMBER OF OBSERVATIONS LESS THAN 2****')
 1100 FORMAT('1****ALL OBSERVATIONS WITH SAME VALUE****')
 1120 FORMAT('1****SAME NUMBER OF GROUPS AS NON-ZERO TAGS****')
 1130 FORMAT(' ****LESS THAN 2 DIFFERENT TAG GROUPS****')
 1140 FORMAT(' ****LESS THAN 2 TAGS****')
 1150 FORMAT('1****INCORRECT DIMENSION OF GSTAT****')
 1160 FORMAT('1****ALL OBSERVATIONS WITHIN A GROUP SAME VALUE****')
 1170 FORMAT('1****TEST WITH 2 TAGS****')
 1180 FORMAT('1****ALL GROUPS EXCEPT FOR 1 WITH 1 OBSERVATION ****')
      END
!MDL4
      SUBROUTINE MDL4 (PAR, NPAR, XM, N, M, IXM, PV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     MODEL ROUTINE FOR STEP SIZE AND DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PV(N),XM(IXM,M)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!  INTRINSIC FUNCTIONS
      INTRINSIC EXP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN COEFFICIENTS IN THE MODEL.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        COEFFICIENTS ARE STORED.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUES FROM THE FIT.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      DO 10 I = 1, N
         PV(I) = PAR(1) + PAR(3)*EXP(-((XM(I,1)-PAR(2))**2)/PAR(4))
   10 CONTINUE
!
      RETURN
!
      END
!SLFLT
      SUBROUTINE SLFLT (Y, N, K, H, YF, NYF)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PERFORMS A SYMMETRIC FILTERING OPERATION
!     ON AN INPUT SERIES Y, RETURNING THE FILTERED SERIES IN YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   K,N,NYF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   H(*),Y(*),YF(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,HEAD
!
!  LOCAL ARRAYS
      CHARACTER
     +   LH(8)*1,LK(8)*1,LN(8)*1,LONE(8)*1,NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,ERIODD,ERSLF,FLTSL,IPRINT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03, ERR04
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION H(K)
!        THE ARRAY OF SYMMETRIC LINEAR FILTER COEFFICIENTS.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS.
!     CHARACTER*1 LH(8), LK(8), LN(8), LONE(8)
!        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES K AND N.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'S',       'L',       'F',       'L',       'T',       ' '/
      DATA
     +  LH(1), LH(2), LH(3), LH(4), LH(5), LH(6), LH(7), LH(8)
     + /  'H',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LONE(1), LONE(2), LONE(3), LONE(4), LONE(5), LONE(6), LONE(7),
     +  LONE(8) /'O', 'N', 'E', ' ', ' ', ' ', ' ', ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 3, 1, HEAD, ERR01, LN)
!
      CALL EISII(NMSUB, LK, K, 1, N, 1, HEAD, ERR02, LONE, LN)
!
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR03)
!
      IF (ERR01 .OR. ERR02 .OR. ERR03) GO TO 10
!
      CALL ERSLF(NMSUB, LH, K, H, HEAD, ERR04)
!
      IF (.NOT. ERR04) GO TO 20
!
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   20 CONTINUE
!
      CALL FLTSL (Y, N, K, H, YF, NYF)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   39H       CALL SLFLT (Y, N, K, H, YF, NYF))
      END
!CDFT
      DOUBLE PRECISION FUNCTION CDFT(X, IDF)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR STUDENT"S T DISTRIBUTION
!              WITH INTEGER DEGREES OF FREEDOM PARAMETER = IDF.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X.
!              THE PROBABILITY DENSITY FUNCTION IS GIVEN
!              IN THE REFERENCES BELOW.
!     INPUT  ARGUMENTS--X      = THE VALUE AT
!                                WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!                                X SHOULD BE NON-NEGATIVE.
!                     --IDF     = THE INTEGER NUMBER OF DEGREES
!                                OF FREEDOM.
!                                IDF SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF FOR THE STUDENT"S T DISTRIBUTION
!             WITH DEGREES OF FREEDOM PARAMETER = IDF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--IDF SHOULD BE A POSITIVE INTEGER VARIABLE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NORCDFC     LANGUAGE--ANSI FOR
!     REFERENCES--NATIONAL BUREAU OF STANDARDS APPLIED MATHMATICS
!                 SERIES 55, 1964, PAGE 948, FORMULAE 26.7.3 AND 26.7.4.
!               --JOHNSON AND KOTZ, CONTIIDFOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 94-129.
!               --FEDERIGHI, EXTENDED TABLES OF THE
!                 PERCENTAGE POINTS OF STUDENT"S
!                 T-DISTRIBUTION, JOURNAL OF THE
!                 AMERICAN STATISTICAL ASSOCIATION,
!                 1959, PAGES 683-688.
!               --OWEN, HANDBOOK OF STATISTICAL TABLES,
!                 1962, PAGES 27-30.
!               --PEARSON AND HARTLEY, BIOMETRIKA TABLES
!                 FOR STATISTICIANS, VOLUME 1, 1954,
!                 PAGES 132-134.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --MAY       1974.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --OCTOBER   1976.
!
!---------------------------------------------------------------------
!
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   X
      INTEGER
     +   IDF
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   B11,B21,B22,B23,B24,B25,B31,B32,B33,B34,B35,B36,B37,C,CSQ,D1,
     +   D11,D3,D5,D7,D9,DCONST,DF,FPSPM,PI,SD,SUM,TERM,TERM1,TERM2,
     +   TERM3,Z
      INTEGER
     +   I,IDFCUT,IEVODD,IMAX,IMIN,IPRT
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFNML,D1MACH
      EXTERNAL CDFNML,D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GETPI,IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,ATAN,EXP,LOG,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION B11, B21, B22, B23, B24, B25
!        CONSTANTS USED IN THE COMPUTATIONS.
!     DOUBLE PRECISION B31, B32, B33, B34, B35, B36, B37
!        CONSTANTS USED IN THE COMPUTATIONS.
!     DOUBLE PRECISION C
!        ...
!     DOUBLE PRECISION CSQ
!        ...
!     DOUBLE PRECISION DCONST
!        ...
!     DOUBLE PRECISION DF
!        THE DEGREES OF FREEDOM.
!     DOUBLE PRECISION D1, D11, D3, D5, D7, D9
!        CONSTANTS USED IN THE COMPUTATIONS.
!     DOUBLE PRECISION FPSPM
!        THE FLOATING POINT SMALLEST POSITIVE MAGNITUDE.
!     INTEGER I
!        AN INDEX.
!     INTEGER IDF
!        THE DEGREES OF FREEDOM.
!     INTEGER IDFCUT
!        ...
!     INTEGER IEVODD
!        ...
!     INTEGER IMAX
!        ...
!     INTEGER IMIN
!        ...
!     INTEGER IPRT
!        THE PRINT UNIT.
!     DOUBLE PRECISION PI
!        PI.
!     DOUBLE PRECISION SD
!        ...
!     DOUBLE PRECISION SUM
!        ...
!     DOUBLE PRECISION TERM, TERM1, TERM2, TERM3
!        ...
!     DOUBLE PRECISION X
!        THE T STATISTIC.
!     DOUBLE PRECISION Z
!        ...
!
      DATA IDFCUT /1000/
      DATA DCONST /0.3989422804D0/
      DATA B11 /0.25D0/
      DATA B21 /96.0D0/
!     DATA B21 /0.01041666666667D0/
      DATA B22, B23, B24, B25 /3.0D0,-7.0D0,-5.0D0,-3.0D0/
      DATA B31 /0.00260416666667D0/
      DATA B32, B33, B34, B35, B36, B37
     +    /1.0D0,-11.0D0,14.0D0,6.0D0,-3.0D0,-15.0D0/
!
!
      CALL GETPI(PI)
      CALL IPRINT(IPRT)
      FPSPM = D1MACH(1)
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF (IDF.LE.0) GO TO 10
      GO TO 20
   10 WRITE (IPRT, 1000)
      WRITE (IPRT, 1010) IDF
      CDFT = 0.0D0
      RETURN
   20 CONTINUE
!
!-----START POINT-----------------------------------------------------
!
      DF = IDF
!
!     IF IDF IS 3 THROUGH 9 AND X IS MORE THAN 3000
!     STANDARD DEVIATIONS BELOW THE MEAN,
!     SET CDFT = 0.0D0 AND RETURN.
!     IF IDF IS 10 OR LARGER AND X IS MORE THAN 150
!     STANDARD DEVIATIONS BELOW THE MEAN,
!     SET CDFT = 0.0D0 AND RETURN.
!     IF IDF IS 3 THROUGH 9 AND X IS MORE THAN 3000
!     STANDARD DEVIATIONS ABOVE THE MEAN,
!     SET CDFT = 1.0D0 AND RETURN.
!     IF IDF IS 10 OR LARGER AND X IS MORE THAN 150
!     STANDARD DEVIATIONS ABOVE THE MEAN,
!     SET CDFT = 1.0D0 AND RETURN.
!
      IF (IDF.LE.2) GO TO 50
      SD = SQRT(DF/(DF-2.0D0))
      Z = X/SD
      IF (IDF.LT.10 .AND. Z.LT.(-3000.0D0)) GO TO 30
      IF (IDF.GE.10 .AND. Z.LT.(-150.0D0)) GO TO 30
      IF (IDF.LT.10 .AND. Z.GT.3000.0D0) GO TO 40
      IF (IDF.GE.10 .AND. Z.GT.150.0D0) GO TO 40
      GO TO 50
   30 CDFT = 0.0D0
      RETURN
   40 CDFT = 1.0D0
      RETURN
   50 CONTINUE
!
!     DISTINGUISH BETWEEN THE SMALL AND MODERATE
!     DEGREES OF FREEDOM CASE VERSUS THE
!     LARGE DEGREES OF FREEDOM CASE
!
      IF (IDF.LT.IDFCUT) GO TO 60
      GO TO 120
!
!     TREAT THE SMALL AND MODERATE DEGREES OF FREEDOM CASE
!     METHOD UTILIZED--EXACT FINITE SUM
!     (SEE AMS 55, PAGE 948, FORMULAE 26.7.3 AND 26.7.4).
!
   60 CONTINUE
      CSQ = DF/(X*X+DF)
      C = SQRT(CSQ)
      IMAX = IDF - 2
      IEVODD = IDF - 2*(IDF/2)
      IF (IEVODD.NE.0) THEN
         IF (IDF.EQ.1) THEN
            SUM = 0.0D0
         ELSE
            SUM = C
         END IF
         TERM = C
         IMIN = 3
      ELSE
         SUM = 1.0D0
         TERM = 1.0D0
         IMIN = 2
      END IF
!
      DO 90 I=IMIN,IMAX,2
         IF (TERM.NE.0.0D0) THEN
            IF (LOG(TERM)+LOG((I-1.0D0)/I)+LOG(CSQ).GE.LOG(FPSPM)) THEN
               TERM = TERM*((I-1.0D0)/I)*CSQ
               SUM = SUM + TERM
            ELSE
               TERM = 0.0D0
            END IF
         END IF
   90 CONTINUE
!
      IF (SUM.EQ.0.0D0 .OR. X.EQ.0.0D0) THEN
         SUM = 0.0D0
      ELSE
         IF (LOG(SUM)+LOG(ABS(X))-0.5*LOG(X*X+DF) .LT. LOG(FPSPM)) THEN
            SUM = 0.0D0
         ELSE
            SUM = SUM*X/SQRT(X*X+DF)
         END IF
      END IF
      IF (IEVODD.EQ.0) GO TO 110
      SUM = (2.0D0/PI)*(ATAN(X/SQRT(DF))+SUM)
  110 CDFT = 0.5D0 + SUM/2.0D0
      RETURN
!
!     TREAT THE LARGE DEGREES OF FREEDOM CASE.
!     METHOD UTILIZED--TRUNCATED ASYMPTOTIC EXPANSION
!     (SEE JOHNSON AND KOTZ, VOLUME 2, PAGE 102, FORMULA 10?
!     SEE FEDERIGHI, PAGE 687).
!
  120 CONTINUE
      D1 = X
      D3 = X**3
      D5 = X**5
      D7 = X**7
      D9 = X**9
      D11 = X**11
      TERM1 = B11*(D3+D1)/DF
!     TERM2 = B21*(B22*D7+B23*D5+B24*D3+B25*D1)/(DF**2)
      TERM2 = (B22*D7+B23*D5+B24*D3+B25*D1)/(DF**2) / B21
      TERM3 = B31*(B32*D11+B33*D9+B34*D7+B35*D5+B36*D3+B37*D1)/(DF**3)
      CDFT = TERM1 + TERM2 + TERM3
      CDFT = CDFNML(X) - (DCONST*(EXP(-X*X/2.0D0)))*CDFT
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (' ', 49H***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO T,
     +   42HHE CDFT   SUBROUTINE IS NON-POSITIVE *****)
 1010 FORMAT (' ', 35H***** THE VALUE OF THE ARGUMENT IS , I8, 6H *****)
      END
!ACVFM
      SUBROUTINE ACVFM (Y, YMISS, N, YMEAN, ACOV, LAGMAX,
     +   LAGLST, NLPPA, LACOV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE AUTOCOVARIANCES WHEN MISSING DATA ARE
!     INVOLVED.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMEAN,YMISS
      INTEGER
     +   LACOV,LAGLST,LAGMAX,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),Y(*)
      INTEGER
     +   NLPPA(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DOTXY,DOTYY,FPLM
      INTEGER
     +   LAG,NDOTXY,NDOTYY,NUSED
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      INTEGER
     +   LSTLAG
      EXTERNAL D1MACH,LSTLAG
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMEANM,DOTCM
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV)
!        THE ARRAY IN WHICH THE AUTOCOVARIANCES ARE STORED
!     DOUBLE PRECISION DOTXY, DOTYY
!        THE DOT PRODUCT BETWEEN VECTORS (Y(I) - YMEAN)) AND
!        (Y(LAG) - YMEAN)), AND (Y(I) - YMEAN)) AND (Y(I) - YMEAN)),
!        RESPECTIVELY.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAG, LAGLST, LAGMAX
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCORRELATION BEING COMPUTED, THE NUMBER OF AUTOCORRELATIONS
!        COMPUTED BEFORE A MISSING AUTOCORRELATION, AND THE NUMBER OF
!        AUTOCORRELATIONS DESIRED, RESPECTIVELY.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NDOTXY, NDOTYY
!        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY AND
!        DOTYY, RESPECTIVELY.
!     INTEGER NLPPA(LACOV)
!        THE ARRAY CONTAINING THE NUMBERS OF LAGGED PRODUCT PAIRS
!        USED TO COMPUTE THE ACVF AT EACH LAG.
!     INTEGER NUSED
!        THE NUMBER OF ACTIVE OBSERVATIONS IN THE SERIES.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!
!
      FPLM = D1MACH(2)
!
!     COMPUTE ARITHMETIC MEAN, WITH MISSING VALUES TAKEN INTO ACCOUNT
!
      CALL AMEANM (Y, YMISS, N, NUSED, YMEAN)
!
!     COMPUTE THE VARIANCE OF THE SERIES Y
!
      CALL DOTCM (Y, YMEAN, YMISS, N, Y, YMEAN, YMISS, N,
     +   DOTYY, NDOTYY)
      NLPPA(1) = NDOTYY
      IF (NLPPA(1).EQ.0) THEN
         LAGLST = 0
      ELSE
         ACOV(1) = DOTYY / NDOTYY
!
!     COMPUTE AUTOCORRELATIONS, WITH MISSING VALUES TAKEN INTO ACCOUNT
!
         DO 10 LAG = 1, LAGMAX
            CALL DOTCM (Y, YMEAN, YMISS, N, Y(LAG+1), YMEAN,
     +         YMISS, N - LAG, DOTXY, NDOTXY)
            NLPPA(LAG + 1) = NDOTXY
            ACOV(LAG + 1) = FPLM
            IF (NLPPA(LAG + 1) .LE. 0) GO TO 10
            ACOV(LAG + 1) = DOTXY * (N-LAG) / (NLPPA(LAG + 1) * N)
   10    CONTINUE
!
!     FIND THE LAST AUTOCORRELATION TO BE COMPUTED BEFORE
!     ONE COULD NOT BE COMPUTED DUE TO MISSING DATA
!
         LAGLST = LSTLAG(NLPPA, LAGMAX, LACOV)
      END IF
      RETURN
      END
!XCCF
      SUBROUTINE XCCF(LDS,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE TIME SERIES CORRELATION SUBROUTINES
!
!     SERIES Y1 AND Y2 ARE LISTED AS SERIES X1 AND X2 ON PAGE OF 361 OF
!     JENKINS AND WATTS.  CCF FOR SERIES Y1 AND Y2 ARE PLOTTED ON PAGE 3
!     AND LISTED ON PAGE 420.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDS
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CMISS,Y1MISS,Y2MISS,YMISS0
      INTEGER
     +   ICCOV,INLPPC,IPRT,ITEST,IYM,IYMFFT,JCCOV,JNLPPC,LAGMAX,
     +   LDSTAK,LYFFT,M,N,NLAG,NPRT,NYD
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCOV(30,5,5),Y1(100),Y2(100),YFFT1(150),YFFT2(150),YM(150,5),
     +   YMFFT(150,5),YMMISS(5)
      INTEGER
     +   NLPPC(30,5,5)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CCF,CCFF,CCFFS,CCFM,CCFMS,CCFS,CCFXP,IPRINT,DCOPY,SETRA,
     +   SETRV
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCOV(30,5,5)
!        THE CROSS COVARIANCE ARRAY.
!     DOUBLE PRECISION CMISS
!        THE MISSING VALUE CODE FOR THE RETURNED CCVF ESTIMATES
!        (VECTOR CCOV).
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER ITEST
!        THE NUMBER OF THE TEST BEING PERFORMED
!     INTEGER IYM, IYMFFT
!        THE FIRST DIMENSION OF THE ARRAYS YM AND YMFFT, RESPECTIVELY.
!     INTEGER JCCOV, JNLPPC
!        THE SECOND DIMENSIONS OF THE ARRAYS CCOV AND NLPPC,
!        RESPECTIVELY.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDS, LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE ARRAYS USED WHEN THE COMPUTATIONS ARE
!        PERFORMED BY THE FFT.
!     INTEGER M
!        THE NUMBER OF SERIES IN THE MULTIVARIATE TIME SERIES YM.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NLAG
!        THE NUMBER OF LAGS AT WHICH THE ACVF WAS COMPUTED.
!     INTEGER NLPPC(30,5,5)
!        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
!        USED TO COMPUTE EACH ACVF ESTIMATE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     INTEGER NYD
!        THE NUMBER OF OBSERVATIONS IN THE SERIES TO BE DIFFERENCED.
!     DOUBLE PRECISION YFFT1(150), YFFT2(150)
!        THE VECTORS USED FOR STORING THE SERIES FOR THE ROUTINES
!        USING THE FFT.
!     DOUBLE PRECISION YM(150,5), YMFFT(150,5)
!        THE ARRAYS USED FOR MULTIVARIATE TIME SERIES.
!     DOUBLE PRECISION YMISS0, YMMISS(5)
!        THE MISSING VALUE CODES FOR SERIES Y AND YM.
!     DOUBLE PRECISION Y1(100), Y1MISS
!        THE FIRST SERIES, AND ITS MISSING VALUE CODE.
!     DOUBLE PRECISION Y2(100), Y2MISS
!        THE SECOND SERIES, AND ITS MISSING VALUE CODE.
!
!
      DATA   Y1(  1),  Y1(  2),  Y1(  3),  Y1(  4),  Y1(  5),  Y1(  6)
     +    /-0.88D0, -0.16D0, -1.87D0, -1.12D0,  1.38D0,  2.13D0/
      DATA   Y1(  7),  Y1(  8),  Y1(  9),  Y1( 10),  Y1( 11),  Y1( 12)
     +    / 2.76D0,  0.56D0, -0.69D0, -1.79D0, -3.82D0, -2.38D0/
      DATA   Y1( 13),  Y1( 14),  Y1( 15),  Y1( 16),  Y1( 17),  Y1( 18)
     +    / 1.00D0,  0.70D0, -0.15D0,  0.98D0,  0.11D0, -0.35D0/
      DATA   Y1( 19),  Y1( 20),  Y1( 21),  Y1( 22),  Y1( 23),  Y1( 24)
     +    /-0.73D0,  0.89D0, -1.63D0, -0.44D0, -1.37D0, -1.71D0/
      DATA   Y1( 25),  Y1( 26),  Y1( 27),  Y1( 28),  Y1( 29),  Y1( 30)
     +    /-1.22D0, -2.00D0, -0.22D0,  0.38D0,  1.31D0,  0.71D0/
      DATA   Y1( 31),  Y1( 32),  Y1( 33),  Y1( 34),  Y1( 35),  Y1( 36)
     +    / 0.32D0,  0.48D0, -1.88D0, -0.94D0, -1.54D0, -0.13D0/
      DATA   Y1( 37),  Y1( 38),  Y1( 39),  Y1( 40),  Y1( 41),  Y1( 42)
     +    / 1.02D0,  0.02D0, -0.77D0,  0.11D0, -0.60D0, -0.52D0/
      DATA   Y1( 43),  Y1( 44),  Y1( 45),  Y1( 46),  Y1( 47),  Y1( 48)
     +    /-0.09D0,  1.23D0,  1.46D0,  0.61D0,  0.42D0,  2.16D0/
      DATA   Y1( 49),  Y1( 50),  Y1( 51),  Y1( 52),  Y1( 53),  Y1( 54)
     +    / 3.18D0,  2.10D0,  0.37D0, -0.24D0,  0.57D0, -0.53D0/
      DATA   Y1( 55),  Y1( 56),  Y1( 57),  Y1( 58),  Y1( 59),  Y1( 60)
     +    / 2.44D0,  1.02D0, -0.53D0, -2.49D0, -2.12D0, -1.04D0/
      DATA   Y1( 61),  Y1( 62),  Y1( 63),  Y1( 64),  Y1( 65),  Y1( 66)
     +    /-0.12D0, -1.88D0, -1.50D0,  1.54D0,  3.33D0,  3.08D0/
      DATA   Y1( 67),  Y1( 68),  Y1( 69),  Y1( 70),  Y1( 71),  Y1( 72)
     +    / 1.71D0,  0.79D0,  1.55D0,  0.89D0, -0.89D0, -1.18D0/
      DATA   Y1( 73),  Y1( 74),  Y1( 75),  Y1( 76),  Y1( 77),  Y1( 78)
     +    / 0.89D0,  1.71D0,  3.05D0,  0.15D0, -1.04D0,  0.12D0/
      DATA   Y1( 79),  Y1( 80),  Y1( 81),  Y1( 82),  Y1( 83),  Y1( 84)
     +    / 0.08D0,  0.11D0, -2.62D0, -1.28D0,  1.07D0,  3.20D0/
      DATA   Y1( 85),  Y1( 86),  Y1( 87),  Y1( 88),  Y1( 89),  Y1( 90)
     +    / 1.92D0,  0.53D0, -1.08D0,  0.49D0, -0.58D0,  0.17D0/
      DATA   Y1( 91),  Y1( 92),  Y1( 93),  Y1( 94),  Y1( 95),  Y1( 96)
     +    / 1.15D0, -0.97D0, -1.63D0,  1.14D0, -0.67D0, -0.88D0/
      DATA   Y1( 97),  Y1( 98),  Y1( 99),  Y1(100)
     +    /-0.07D0,  0.24D0,  0.55D0, -2.16D0/
      DATA   Y2(  1),  Y2(  2),  Y2(  3),  Y2(  4),  Y2(  5),  Y2(  6)
     +    / 0.79D0,  1.12D0, -1.10D0, -2.39D0, -1.75D0, -0.82D0/
      DATA   Y2(  7),  Y2(  8),  Y2(  9),  Y2( 10),  Y2( 11),  Y2( 12)
     +    /-0.36D0,  1.27D0,  1.75D0,  2.44D0,  0.36D0, -2.10D0/
      DATA   Y2( 13),  Y2( 14),  Y2( 15),  Y2( 16),  Y2( 17),  Y2( 18)
     +    /-1.93D0, -1.30D0, -1.75D0, -0.34D0,  0.74D0,  0.49D0/
      DATA   Y2( 19),  Y2( 20),  Y2( 21),  Y2( 22),  Y2( 23),  Y2( 24)
     +    / 0.70D0,  0.71D0,  0.09D0,  0.59D0,  1.54D0,  0.14D0/
      DATA   Y2( 25),  Y2( 26),  Y2( 27),  Y2( 28),  Y2( 29),  Y2( 30)
     +    / 0.55D0, -1.40D0, -2.55D0, -1.66D0, -0.43D0,  0.58D0/
      DATA   Y2( 31),  Y2( 32),  Y2( 33),  Y2( 34),  Y2( 35),  Y2( 36)
     +    / 2.18D0, -0.24D0,  0.58D0, -0.18D0, -1.55D0, -0.64D0/
      DATA   Y2( 37),  Y2( 38),  Y2( 39),  Y2( 40),  Y2( 41),  Y2( 42)
     +    /-1.09D0,  0.90D0, -0.66D0, -0.35D0,  0.48D0,  0.50D0/
      DATA   Y2( 43),  Y2( 44),  Y2( 45),  Y2( 46),  Y2( 47),  Y2( 48)
     +    / 0.05D0, -0.68D0,  0.24D0,  0.58D0, -1.26D0, -0.25D0/
      DATA   Y2( 49),  Y2( 50),  Y2( 51),  Y2( 52),  Y2( 53),  Y2( 54)
     +    / 0.25D0,  2.18D0,  2.96D0,  1.56D0, -0.36D0, -0.59D0/
      DATA   Y2( 55),  Y2( 56),  Y2( 57),  Y2( 58),  Y2( 59),  Y2( 60)
     +    /-0.12D0,  3.03D0,  2.11D0,  0.78D0,  0.89D0, -1.45D0/
      DATA   Y2( 61),  Y2( 62),  Y2( 63),  Y2( 64),  Y2( 65),  Y2( 66)
     +    /-0.36D0, -0.37D0, -1.39D0, -4.19D0, -0.73D0, -0.98D0/
      DATA   Y2( 67),  Y2( 68),  Y2( 69),  Y2( 70),  Y2( 71),  Y2( 72)
     +    / 0.36D0,  0.06D0, -1.94D0, -0.08D0,  0.17D0,  1.00D0/
      DATA   Y2( 73),  Y2( 74),  Y2( 75),  Y2( 76),  Y2( 77),  Y2( 78)
     +    /-0.05D0,  0.43D0,  0.15D0,  2.69D0,  0.57D0,  0.29D0/
      DATA   Y2( 79),  Y2( 80),  Y2( 81),  Y2( 82),  Y2( 83),  Y2( 84)
     +    / 1.10D0,  0.48D0, -1.06D0, -2.28D0, -2.03D0, -0.75D0/
      DATA   Y2( 85),  Y2( 86),  Y2( 87),  Y2( 88),  Y2( 89),  Y2( 90)
     +    / 1.00D0,  1.71D0,  0.58D0,  1.97D0,  0.99D0,  1.94D0/
      DATA   Y2( 91),  Y2( 92),  Y2( 93),  Y2( 94),  Y2( 95),  Y2( 96)
     +    / 2.18D0,  3.14D0,  0.60D0,  0.51D0,  1.35D0,  0.56D0/
      DATA   Y2( 97),  Y2( 98),  Y2( 99),  Y2(100)
     +    / 0.11D0,  0.00D0,  2.34D0,  1.88D0/
!
      CALL IPRINT(IPRT)
      ITEST = 1
      LDSTAK = LDS
!
      N = 100
      LAGMAX = 20
      NLAG = 30
      NPRT = 1
      LYFFT = 150
      ICCOV = 30
      JCCOV = 5
      IYM = 150
      M = 4
      IYMFFT = 150
      INLPPC = 30
      JNLPPC = 5
      NYD = 144
      YMISS0 = 1.16D0
      Y1MISS = 0.89D0
      Y2MISS = 0.89D0
!
!     COPY DATA INTO YM FOR CCFS AND CCFMS
!
      CALL DCOPY(N, Y1, 1, YM(1,1), 1)
      CALL DCOPY(N, Y2, 1, YM(1,2), 1)
      CALL DCOPY(N, Y1, 1, YM(1,3), 1)
      CALL DCOPY(N, Y2, 1, YM(1,4), 1)
      CALL SETRV(YMMISS, 4, YMISS0)
!
!     TEST OF CCF
!
      WRITE (IPRT,1060)
      CALL CCF(Y1, Y2, N)
!
!     PRINT RETURNED RESULTS
!
      CALL CCFXP (.FALSE., LAGMAX, M, CCOV, ICCOV, JCCOV, .FALSE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
!
!     TEST OF CCFS
!
      WRITE (IPRT,1080)
      CALL CCFS(YM, N, M, IYM, LAGMAX, CCOV, ICCOV, JCCOV, NPRT,
     +   LDSTAK)
!
!     PRINT RETURNED RESULTS
!
      CALL CCFXP (.TRUE., LAGMAX, M, CCOV, ICCOV, JCCOV, .FALSE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
!
!     TEST OF CCFM WITHOUT MISSING VALUES
!
      WRITE (IPRT,1070)
      WRITE (IPRT, 1050)
      CALL CCFM(Y1, YMISS0, Y2, YMISS0, N)
!
!     PRINT RETURNED RESULTS
!
      CALL CCFXP (.FALSE., LAGMAX, M, CCOV, ICCOV, JCCOV, .TRUE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
!
!     TEST OF CCFMS WITHOUT MISSING VALUES
!
      WRITE (IPRT,1140)
      WRITE (IPRT, 1050)
      CALL CCFMS(YM, YMMISS, N, M, IYM, LAGMAX, CCOV, CMISS,
     +   ICCOV, JCCOV, NLPPC, INLPPC, JNLPPC, NPRT, LDSTAK)
!
!     PRINT RETURNED RESULTS
!
      CALL CCFXP (.TRUE., LAGMAX, M, CCOV, ICCOV, JCCOV, .TRUE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
!
!     COPY DATA INTO YFFT1, YFFT2 AND YMFFT FOR CCFF AND CCFFS
!
      CALL DCOPY(N, Y1, 1, YFFT1, 1)
      CALL DCOPY(N, Y2, 1, YFFT2, 1)
      CALL DCOPY(N, Y1, 1, YMFFT(1,1), 1)
      CALL DCOPY(N, Y2, 1, YMFFT(1,2), 1)
      CALL DCOPY(N, Y1, 1, YMFFT(1,3), 1)
      CALL DCOPY(N, Y2, 1, YMFFT(1,4), 1)
!
!     TEST OF CCFF
!
      WRITE (IPRT,1100)
      CALL CCFF(YFFT1, YFFT2, N, LYFFT, LDSTAK)
!
!     PRINT RETURNED RESULTS
!
      CALL CCFXP (.FALSE., LAGMAX, M, CCOV, ICCOV, JCCOV, .FALSE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
!
!     TEST OF CCFFS
!
      WRITE (IPRT,1150)
      CALL CCFFS(YMFFT, N, M, IYMFFT, LAGMAX, CCOV,
     +   ICCOV, JCCOV, NPRT, LDSTAK)
!
!     PRINT RETURNED RESULTS
!
      CALL CCFXP (.TRUE., LAGMAX, M, CCOV, ICCOV, JCCOV, .FALSE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
!
!     RESET YMMISS
!
      YMMISS(1) = Y1MISS
      YMMISS(2) = Y2MISS
      YMMISS(3) = Y1MISS
      YMMISS(4) = Y2MISS
!
!     TEST OF CCFM WITH MISSING VALUES
!
      WRITE (IPRT,1070)
      WRITE (IPRT, 1040)
      CALL CCFM(Y1, Y1MISS, Y2, Y2MISS, N)
!
!     PRINT RETURNED RESULTS
!
      CALL CCFXP (.FALSE., LAGMAX, M, CCOV, ICCOV, JCCOV, .TRUE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
!
!     TEST OF CCFMS WITH MISSING VALUES
!
      WRITE (IPRT,1140)
      WRITE (IPRT, 1040)
      CALL CCFMS(YM, YMMISS, N, M, IYM, LAGMAX, CCOV, CMISS,
     +   ICCOV, JCCOV, NLPPC, INLPPC, JNLPPC, NPRT, LDSTAK)
!
!     PRINT RETURNED RESULTS
!
      CALL CCFXP (.TRUE., LAGMAX, M, CCOV, ICCOV, JCCOV, .TRUE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
!
!     TEST PRINT CONTROL
!
      NPRT = 0
!
!     TEST OF CCFS
!
      WRITE (IPRT,1080)
      WRITE (IPRT, 1020)
      CALL CCFS(YM, N, M, LAGMAX, IYM, CCOV, ICCOV, JCCOV, NPRT,
     +   LDSTAK)
!
!     PRINT RETURNED RESULTS
!
      CALL CCFXP (.TRUE., LAGMAX, M, CCOV, ICCOV, JCCOV, .FALSE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
!
!     TEST OF CCFMS WITH MISSING VALUES
!
      WRITE (IPRT,1140)
      WRITE (IPRT, 1040)
      WRITE (IPRT, 1020)
      CALL CCFMS(YM, YMMISS, N, M, IYM, LAGMAX, CCOV, CMISS,
     +   ICCOV, JCCOV, NLPPC, INLPPC, JNLPPC, NPRT, LDSTAK)
!
!     PRINT RETURNED RESULTS
!
      CALL CCFXP (.TRUE., LAGMAX, M, CCOV, ICCOV, JCCOV, .TRUE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
!
!     COPY DATA INTO YMFFT FOR CCFFS
!
      CALL DCOPY(N, Y1, 1, YMFFT(1,1), 1)
      CALL DCOPY(N, Y2, 1, YMFFT(1,2), 1)
      CALL DCOPY(N, Y1, 1, YMFFT(1,3), 1)
      CALL DCOPY(N, Y2, 1, YMFFT(1,4), 1)
!
!     TEST OF CCFFS
!
      WRITE (IPRT,1150)
      WRITE (IPRT, 1020)
      CALL CCFFS(YMFFT, N, M, IYMFFT, LAGMAX, CCOV,
     +   ICCOV, JCCOV, NPRT, LDSTAK)
!
!     PRINT RETURNED RESULTS
!
      CALL CCFXP (.TRUE., LAGMAX, M, CCOV, ICCOV, JCCOV, .FALSE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
!
!     TEST LEAD/LAG MESSAGE
!
      NPRT = 1
!
      CALL SETRA(YMFFT, IYMFFT, M, N, 0.0D0)
      YMFFT(5,1) = 1.0D0
      YMFFT(15,2) = 1.0D0
      YMFFT(5,3) = YMFFT(5,1)
      YMFFT(15,4) = YMFFT(15,2)
!
!     TEST OF CCFFS
!
      WRITE (IPRT,1150)
      WRITE (IPRT, 1020)
      CALL CCFFS(YMFFT, N, M, IYMFFT, LAGMAX, CCOV,
     +   ICCOV, JCCOV, NPRT, LDSTAK)
!
!     PRINT RETURNED RESULTS
!
      CALL CCFXP (.TRUE., LAGMAX, M, CCOV, ICCOV, JCCOV, .FALSE.,
     +   NLPPC,  INLPPC, JNLPPC, CMISS)
!
      GO TO (100, 200, 300, 400), ITEST
!
!     TEST MINIMUM PROBLEM SIZE
!
  100 ITEST = ITEST + 1
      N = 3
      LAGMAX = 1
      LYFFT = 150
      ICCOV = 30
      JCCOV = 5
      IYM = 150
      M = 1
      IYMFFT = 150
      INLPPC = 30
      JNLPPC = 5
      NYD = 144
      YMISS0 = 1.16D0
      Y1MISS = 0.89D0
      Y2MISS = 0.89D0
!
!     TEST ERROR HANDLING
!
  200 ITEST = ITEST + 1
      N = 0
      LAGMAX = 1
      LYFFT = 0
      ICCOV = 0
      JCCOV = 0
      IYM = 0
      M = 0
      IYMFFT = 0
      INLPPC = 0
      JNLPPC = 0
      NYD = 0
!
!     TEST ERROR HANDLING
!
  300 ITEST = ITEST + 1
      N = 100
      LAGMAX = 100
      LYFFT = 0
      ICCOV = 0
      JCCOV = 0
      IYM = 0
      M = 0
      IYMFFT = 0
      INLPPC = 0
      JNLPPC = 0
      NYD = 144
      LDSTAK = 0
!
  400 RETURN
!
!     FORMAT STATEMENTS
!
 1020 FORMAT (18H OUTPUT SUPPRESSED)
 1040 FORMAT (20H WITH MISSING VALUES)
 1050 FORMAT (23H WITHOUT MISSING VALUES)
 1060 FORMAT ('1', 11HTEST OF CCF)
 1070 FORMAT ('1', 12HTEST OF CCFM)
 1080 FORMAT ('1', 12HTEST OF CCFS)
 1100 FORMAT ('1', 12HTEST OF CCFF)
 1140 FORMAT ('1', 13HTEST OF CCFMS)
 1150 FORMAT ('1', 13HTEST OF CCFFS)
      END
!STATWS
      SUBROUTINE STATWS(Y, WT, N, LDSTAK, STS, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES 53 DIFFERENT STATISTICS FOR A VECTOR
!     Y, WITH WEIGHTS SPECIFIED.  ONE PAGE OF AUTOMATIC
!     PRINTOUT IS PRODUCED.
!
!     WRITTEN BY - JANET R. DONALDSON, JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!        (EXTENSIVE REVISION OF OLDER VERSION)
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   STS(53),WT(*),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,SUM1,SUMD2,SUMD3,SUMD4,SUMDA,SUMDI,SUMT1,SUMW,SUMWD2,
     +   SUMWT1
      INTEGER
     +   IDP,IINT,IPRT,LSORT,MID,NALL0,NNZW
      LOGICAL
     +   STACK,WTS
!
!  LOCAL ARRAYS
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GENI,IPRINT,SRTIRR,SRTRRI,STAT1W,STAT2W,STATER,STKCLR,
     +   STKSET,SUMBS,SUMIDW,SUMOT,SUMWDS,SUMWSS,SUMWTS
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        THE PERCENTAGE TO BE TRIMMED FROM EACH END OF THE
!        SORTED ARRAY Y.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDP
!        FRAMEWORK CODE VALUE FOR DOUBLE PRECISION NUMBERS.
!     INTEGER IERR
!        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
!        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
!        SOME ERROR EXISTS.
!     INTEGER IINT
!        THE CODE VALUE FOR INTEGER FOR FRAMEWORK.
!     INTEGER IPRT
!        THE NUMBER OF THE STANDARD OUTPUT UNIT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
!        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
!     INTEGER LSORT
!        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION VECTOR.
!     INTEGER MID
!        THE INDEX OF A ZERO ELEMENT IN THE SORTED Y, OR OF THE
!        ELEMENT CLOSEST TO ZERO.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
!        WAS CALLED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        INPUT PARAMETER.  THE CODE INDICATING WHETHER PRINTOUT
!        IS DESIRED.  0 MEANS NO PRINTOUT, NOT 0 MEANS PRINTOUT.
!     INTEGER NNZW
!        NUMBER OF NONZERO WEIGHTS.
!     LOGICAL STACK
!        A FLAG INDICATING WHETHER THIS ROUTINE USES THE STACK (TRUE)
!        OR NOT (FALSE).
!     DOUBLE PRECISION STS(53)
!        OUTPUT PARAMETER.  THE VECTOR OF THE 53 STATISTICS COMPUTED.
!     DOUBLE PRECISION SUMDA
!        THE SUM OF THE ABSOLUTE DIFFERENCES FROM THE MEAN.
!     DOUBLE PRECISION SUMDI
!        THE SUM OF THE PRODUCTS OF THE INDICES AND THE
!        DIFFERENCES.
!     DOUBLE PRECISION SUMD2
!        THE SUM OF THE SQUARES OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMD3
!        THE SUM OF THE CUBES OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMD4
!        THE SUM OF THE 4TH POWERS OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMT1
!        THE SUM OF THE ALPHA TRIMMED ARRAY Y.
!     DOUBLE PRECISION SUMW
!        THE SUM OF THE WEIGHTS VECTOR WT.
!     DOUBLE PRECISION SUMWD2
!        THE WEIGHTED SUM OF THE SQUARES OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMWT1
!        THE WEIGHTED SUM OF THE ALPHA TRIMMED ARRAY.
!     DOUBLE PRECISION SUM1
!        THE SUM OF THE ELEMENTS OF X.  A DUMMY VARIABLE.
!     DOUBLE PRECISION WT(N)
!        INPUT PARAMETER.  THE WEIGHTS VECTOR.
!     LOGICAL WTS
!        A FLAG INDICATING WHETHER THERE ARE WEIGHTS (TRUE)
!        OR NOT (FALSE).
!     DOUBLE PRECISION Y(N)
!        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
!        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
!        TO ITS ORIGINAL ORDER AFTERWARDS.
!
!
!     INITIALIZE NAME VECTORS
!
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'S',      'T',      'A',      'T',      'W',      'S'/
!
      DATA ALPHA /0.25D0/
      DATA IDP /4/
      DATA IINT /2/
      DATA WTS /.TRUE./
      DATA STACK /.TRUE./
!
!     CHECK FOR ERRORS IN THE INPUT PARAMETERS.
!
      CALL STATER(NMSUB, WT, N, LDSTAK, WTS, NNZW, STACK, IERR)
      IF (IERR.NE.0) THEN
!
!     PRINT ERROR MESSAGE.
!
         CALL IPRINT(IPRT)
         WRITE (IPRT,1000)
         RETURN
      END IF
!
!     SET UP FRAMEWORK AREA.
!
      CALL STKSET (LDSTAK, IDP)
      NALL0 = STKST(1)
!
!     SET UP LSORT, THE PERMUTATION VECTOR.
!
      LSORT = STKGET(N,IINT)
      CALL GENI(ISTAK(LSORT), N, 1, 1)
!
!     SORT THE VECTOR Y CARRYING ALONG THE CONTENTS OF THE VECTOR
!     ISTAK(LSORT).
!
      CALL SRTIRR(ISTAK(LSORT), WT, N, Y)
!
!     COMPUTE THE STATISTICS WHICH USE A SORTED ARRAY.
!
      CALL STAT1W(Y, WT, N, STS(5), STS(34), STS(35), STS(6),
     +   STS(11), 10, 0.0D0, 0.0D0, STS(44), NNZW)
!
!     COMPUTED VARIOUS SUMS IN THE SORTED ARRAY Y.
!
      CALL SUMBS(Y, N, 1, MID, N)
      CALL SUMWSS(Y, WT, N, 1, MID, N, NNZW, SUM1, STS(38), STS(39),
     +   STS(42), SUMW, STS(3), STS(4))
      CALL SUMWTS(Y, WT, N, NNZW, ALPHA, SUMT1, SUMWT1, STS(7),
     +   STS(8))
      CALL SUMWDS(Y, WT, N, 1, MID, N, STS(4), SUMDA, SUMWD2, SUMD2,
     +   SUMD3, SUMD4)
!
!     RESTORE THE VECTOR Y TO ITS ORIGINAL ORDER.
!
      CALL SRTRRI(Y, WT, N, ISTAK(LSORT))
!
!     COMPUTE REST OF STATISTICS.
!
      CALL SUMIDW(Y, WT, N, STS(4), SUMDI)
      CALL STAT2W(Y, WT, N, NNZW, STS, SUMDA, SUMDI, SUMWD2, SUMD2,
     +   SUMD3, SUMD4, SUMW)
      IF (NPRT.NE.0) CALL SUMOT(STS, N, NNZW, WTS)
!
!     RETURN THE VECTOR LSORT.
!
      CALL STKCLR(NALL0)
      RETURN
!
!     FORMAT STATEMENTS.
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL STATWS (Y, WT, N, LDSTAK, STS, NPRT)')
      END
!NLSD
      SUBROUTINE NLSD(Y, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING ANALYTIC DERIVATIVES (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),XM(*),Y(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IPRT,IVAPRX,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,
     +   LWT,MIT,NNZW,NPARE,NPRT
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SCALE(1),SDPV(1),SDRES(1),VCV(1,1),WT(1)
      INTEGER
     +   IFIXED(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTA
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE DERIVATIVES WE
!        CHECKED OR NOT.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(1)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(1)
!        THE DUMMY ARRAY FOR THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','D',' ',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      WEIGHT = .FALSE.
      SAVE = .FALSE.
!
      WT(1) = 1.0D0
      IDRVCK = 1
      MIT = -1
      STOPSS = -1.0D0
      STOPP = -1.0D0
      SCALE(1) = -1.0D0
      DELTA = -1.0D0
      NPRT = -1
      IFIXED(1) = -1
      IVAPRX = 0
      LIFIXD = 1
      LPV = 1
      LSCALE = 1
      LSDPV = 1
      LSDRES = 1
      LWT = 1
      IVCV = 1
!
      CALL NLCNTA(Y, WT, LWT, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, IDRVCK, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSD (Y, XM, N, M, IXM, NLSMDL, NLSDRV,'/
     +   '      +           PAR, NPAR, RES, LDSTAK)')
      END
!FLTMA
      SUBROUTINE FLTMA (Y, N, K, HMA, YF, NYF)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE FILTERS THE INPUT SERIES Y USING THE K TERMS
!     OF H, COPYING THE FILTERED SERIES INTO YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   HMA
      INTEGER
     +   K,N,NYF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(N),YF(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   SUM
      INTEGER
     +   I,I1,II,J
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION HMA
!        THE VALUE OF EACH OF THE SIMPLE MOVING AVERAGE LINEAR FILTER
!        COEFFICIENTS.
!     INTEGER I, II, I1, J
!        INDEXING VARIABLES.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     DOUBLE PRECISION SUM
!        A TEMPORARY LOCATION USED IN COMPUTING THE FILTERED SERIES.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
      DO 10 I = 1, N
         YF(I) = Y(I)
   10 CONTINUE
!
      NYF = N - (K - 1)
!
      DO 30 I = 1, NYF
         II = I - 1
         SUM = 0.0D0
         DO 20 J = 1, K
            II = II + 1
            SUM = SUM + HMA*YF(II)
   20    CONTINUE
         YF(I) = SUM
   30 CONTINUE
!
      I1 = NYF + 1
!
      DO 40 I = I1, N
         YF(I) = 0.0D0
   40 CONTINUE
!
      RETURN
      END
!CCFMNF
      SUBROUTINE CCFMNF (Y1, Y2, N, NFFT, LAGMAX, NCC, CCOV11, CCOV22,
     +   CCOV12, CCOV21, LCCOV, RHOC, SDRHOC, NPRT, LYFFT, WORK, LWORK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING CROSS CORRELATIONS AND
!     THEIR STANDARD ERRORS OF A TIME SERIES USING A FFT.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LAGMAX,LCCOV,LWORK,LYFFT,N,NCC,NFFT,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV11(LCCOV),CCOV12(LCCOV),CCOV21(LCCOV),CCOV22(LCCOV),
     +   RHOC(NCC),SDRHOC(NCC),WORK(LWORK),Y1(LYFFT),Y2(LYFFT)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FAC
      INTEGER
     +   I,I0,IM,IP
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CCFSD,CCVFF
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCOV11(LCCOV)
!        THE ARRAY IN WHICH THE AUTOCOVARIANCE FUNCTION ESTIMATES
!        FOR THE FIRST SERIES IS STORED.
!     DOUBLE PRECISION CCOV12(LCCOV), CCOV21(LCCOV)
!        THE ARRAYS IN WHICH THE CROSS COVARIANCE FUNCTION
!        ESTIMATES FOR THE FIRST SERIES LAGGED BEHIND THE SECOND
!        AND VISA VERSA, ARE STORED.
!     DOUBLE PRECISION CCOV22(LCCOV)
!        THE ARRAY IN WHICH THE AUTOCOVARIANCE FUNCTION ESTIMATES
!        FOR THE SECOND SERIES IS STORED.
!     DOUBLE PRECISION FAC
!        THE INVERSE OF THE SQUARE ROOT OF THE PRODUCT OF THE
!        AUTOCOVARIANCES AT LAG ZERO.
!     INTEGER I
!        THE INDEXING VARIABLE FOR THE LAG VALUE.
!     INTEGER  IM, IP, I0
!        THE LOCATIONS IN THE CCF RELATED ARRAYS
!        OF THE LAG -I, I, AND 0, RESPECTIVELY.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LCCOV
!        THE DIMENSION OF THE COVARANCE ARRAYS.
!     INTEGER LWORK
!        THE DIMENSION OF THE WORK ARRAY.
!     INTEGER LYFFT
!        THE DIMENSION OF THE DATA ARRAYS.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NCC
!        THE NUMBER OF CROSS CORRELATIONS COMPUTED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO CONTROL COMPUTATIONS NEEDED
!        ONLY FOR PRINTED OUTPUT.
!     DOUBLE PRECISION RHOC(NCC)
!        THE ARRAY IN WHICH THE CROSS CORRELATIONS ARE STORED
!     DOUBLE PRECISION SDRHOC(NCC)
!        THE ARRAY CONTAINING THE STD. ERRORS OF THE CROSS CORRELATIONS.
!        ARE STORED.
!     DOUBLE PRECISION WORK(LWORK)
!        THE WORK ARRAY.
!     DOUBLE PRECISION Y1(LYFFT), Y2(LYFFT)
!        THE VECTORS CONTAINING THE OBSERVED SERIES
!
!     COMPUTE THE CROSS CORRELATIONS.
!
      CALL CCVFF (Y1, Y2, N, NFFT, LAGMAX, CCOV12, CCOV21, LCCOV, LYFFT,
     +   WORK, LWORK)
!
      IF (NPRT .EQ. 0 .OR. CCOV11(1)*CCOV22(1) .EQ. 0.0D0) RETURN
!
      FAC = 1.0D0 / SQRT(CCOV11(1) * CCOV22(1))
!
      I0 = LAGMAX + 1
      RHOC(I0) = CCOV12(1) * FAC
      DO 10 I = 1, LAGMAX
         IP = I0 + I
         RHOC(IP) = CCOV12(I+1) * FAC
!
         IM = I0 - I
         RHOC(IM) = CCOV21(I+1) * FAC
   10 CONTINUE
!
!     COMPUTE STANDARD ERROR OF THE CROSSCORRELATIONS.
!
      CALL CCFSD (CCOV11, CCOV22, SDRHOC, LAGMAX, NCC, N, LCCOV)
!
      RETURN
      END
!LPFLT
      SUBROUTINE LPFLT (FC, K, HLP)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE LOPASS FILTER COEFFICIENTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC
      INTEGER
     +   K
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   HLP(K)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ARG,CON,PI,SUM
      INTEGER
     +   I,IHM,IHP,KHALF,KMID
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ARG, CON
!        VARIABLES USED IN THE COMPUTATION OF THE LOW PASS FILTER
!        COEFFICIENTS.
!     DOUBLE PRECISION FC
!        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
!     DOUBLE PRECISION HLP(K)
!        THE ARRAY IN WHICH THE INPUT LOW PASS FILTER COEFFICIENTS
!        ARE STORED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IHM, IHP
!        INDEX VARIABLES FOR SYMMETRIC LOCATIONS AROUND THE MIDPOINT
!        OF THE FILTER.
!     INTEGER K
!        THE NUMBER OF TERMS IN THE FILTER.
!     INTEGER KHALF
!        THE VALUE OF THE MIDPOINT OF K MINUS 1.
!     INTEGER KMID
!        THE MIDPOINT OF THE FILTER.
!     DOUBLE PRECISION PI
!        THE VALUE OF PI.
!     DOUBLE PRECISION SUM
!        A VALUE USED FOR SUMMING.
!
      CALL GETPI(PI)
!
      KMID = (K + 1) / 2
!
      HLP(KMID) = 1.0D0
!
      IF (K .EQ. 1) RETURN
!
      HLP(KMID) = 2.0D0 * FC
      CON = 2.0D0 * PI / K
      SUM = HLP(KMID)
!
      KHALF = (K - 1) / 2
!
      DO 10 I = 1, KHALF
         ARG = I * CON
         IHP = KMID + I
         HLP(IHP) = SIN(I * FC * 2.0D0 * PI) * SIN(ARG) /
     +      (I * PI * ARG)
         IHM = KMID - I
         HLP(IHM) = HLP(IHP)
         SUM = SUM + HLP(IHM) + HLP(IHP)
   10 CONTINUE
      DO 20 I = 1, K
         HLP(I) = HLP(I) / SUM
   20 CONTINUE
      RETURN
      END
!DCKLSC
      SUBROUTINE DCKLSC(XM, N, M, IXM, MDL, DRV, PAR, NPAR, LDSTAK,
     +   NETA, NTAU, SCALE, NROW, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR CHECKING USER SUPPLIED
!     ANALYTIC DERIVATIVES AGAINST NUMERICAL DERIVATIVES
!     FOR THE NONLINEAR LEAST SQUARES ROUTINES (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,M,N,NETA,NPAR,NPRT,NROW,NTAU
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),SCALE(*),XM(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,LSCALE
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DCKDRV,IPRINT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION SCALE(NPAR)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'D','C','K','L','S','C'/
!
      LSCALE = NPAR
!
!     PASS CONTROL OF DERIVATIVE CHECKING TO DCKDRV
!
      CALL DCKDRV(NMSUB, LDSTAK, XM, N, M, IXM, MDL, DRV, PAR, NPAR,
     +   NETA, NTAU, SCALE, LSCALE, NROW, NPRT)
!
      IF (IERR.NE.1) RETURN
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL DCKLSC (XM, N, M, IXM, NLSMDL, NLSDRV,'/
     +   '      +             PAR, NPAR, LDSTAK,'/
     +   '      +             NETA, NTAU, SCALE, NROW, NPRT)')
      END
!HSTMN
      SUBROUTINE HSTMN(Y, N, NCELLS, YLB, YUB, LSORT, YDIST)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN ROUTINE FOR PRODUCING A HISTOGRAM
!
!     ORIGINAL VERSION ADAPTED FROM AN EARLY VERSION OF MINITAB.
!
!     ADAPTED BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YLB,YUB
      INTEGER
     +   N,NCELLS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(N),YDIST(NCELLS)
      INTEGER
     +   LSORT(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,B1SQRT,B2,CFRACT,CFRCTM,CNTMX,FRACT,P,SCALE,SUM1,SUM2,
     +   SUM3,SUMD2,SUMD3,SUMD4,SUMDA,SUMT1,TEMP,WIDTH,XN,XNN,YINTMP,
     +   YMAX,YMDDSD,YMEAN,YMEANT,YMED,YMIDRG,YMIN,YRANGE,YSD,YVAR
      INTEGER
     +   I,IFLAG,IPRT,J,MID,NHIGH,NLOW,NOBS,NUM,NUMS
      CHARACTER
     +   IPLUS*1
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   A(6)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GENI,IPRINT,SRTIR,SRTRI,STAT1,SUMBS,SUMDS,SUMSS,SUMTS,
     +   VERSP
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,INT,MAX,MOD,NINT,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION A(6)
!        A VECTOR USED FOR PRINTING THE HISTOGRAM SCALE.
!     DOUBLE PRECISION ALPHA
!        THE PERCENTAGE TO BE TRIMMED OFF EACH END OF Y FOR THE
!        TRIMMED MEANS CALCULATIONS.
!     DOUBLE PRECISION B1SQRT
!        BETA ONE  -  A MEASURE OF SKEWNESS
!     DOUBLE PRECISION B2
!        BETA TWO  -  A MEASURE OF KURTOSIS
!     DOUBLE PRECISION CFRACT
!        THE CUMULATIVE DISTRIBUTION
!     DOUBLE PRECISION CFRCTM
!        THE REVERSE CUMULATIVE DISTRIBUTION
!     DOUBLE PRECISION CNTMX
!        THE SIZE OF THE LARGEST CELL COUNT
!     DOUBLE PRECISION FRACT
!        THE FRACTION OF THE OBSERVATIONS IN A GIVEN CELL
!     INTEGER I
!        AN INDEX
!     INTEGER IFLAG
!        IF 1, THEN MORE THAN 50 OBS. FELL IN A SINGLE CELL,
!        AND A SCALED HISTOGRAM WILL BE PROVIDED.
!     CHARACTER*1 IPLUS
!        THE CHARACTER +
!     INTEGER IPRT
!        THE NUMBER OF THE STANDARD OUTPUT UNIT.
!     INTEGER J
!        AN INDEX.
!     INTEGER LSORT(N)
!        THE PERMUTATION VECTOR.
!     INTEGER MID
!        THE INDEX OF THE (AN) ELEMENT OF Y CLOSEST TO ZERO, WHEN
!        Y HAS BEEN SORTED.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y.
!     INTEGER NCELLS
!        THE NUMBER OF CELLS IN THE FREQUENCY DISTRIBUTION.
!     INTEGER NHIGH
!        THE INDEX OF THE LARGEST VALUE IN THE SORTED ARRAY
!        TO BE USED IN THE HISTOGRAM
!     INTEGER NLOW
!        THE INDEX OF THE SMALLEST VALUE IN THE SORTED ARRAY
!        TO BE USED IN THE HISTOGRAM
!     INTEGER NOBS
!        THE NUMBER OF OBSERVATIONS ACTUALLY USED IN THE HISTOGRAM
!     INTEGER NUM
!        THE CELL COUNT
!     INTEGER NUMS
!        THE SCALED CELL COUNT
!     DOUBLE PRECISION P
!        A VARIABLE USED TO DETERMINE THE SCALE
!     DOUBLE PRECISION SCALE
!        THE PRINTED INCREMENT ON THE HISTOGRAM SCALE
!     DOUBLE PRECISION SUMDA
!        THE SUM OF THE ABSOLUTE DIFFERENCES FROM THE MEAN.
!     DOUBLE PRECISION SUMD2
!        THE SUM OF THE SQUARES OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMD3
!        THE SUM OF THE CUBES OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMD4
!        THE SUM OF THE 4TH POWERS OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMT1
!        THE SUM OF THE ALPHA TRIMMED ARRAY Y.
!     DOUBLE PRECISION SUM1, SUM2, SUM3
!        VARIOUS SUMS OF THE DATA.
!     DOUBLE PRECISION TEMP
!        A TEMPORARY STORAGE VARIABLE
!     DOUBLE PRECISION WIDTH
!        THE WIDTH OF A CELL
!     DOUBLE PRECISION XN
!        THE FOATING POINT REPRESENTATION OF N
!     DOUBLE PRECISION XNN
!        THE UNROUNDED NUMBER OF PLOTTING POSISTIONS ON A SCALES
!        HISTOGRAM
!     DOUBLE PRECISION Y(N)
!        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
!        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
!        TO ITS ORIGINAL ORDER AFTERWARDS.
!     DOUBLE PRECISION YDIST(NCELLS)
!        THE FREQUENCY DISTRIBUTION USED TO CREATE THE HISTOGRAM.
!     DOUBLE PRECISION YINTMP
!        THE MIDPOINT OF THE ITH CELL
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!     DOUBLE PRECISION YMAX
!        THE HISTOGRAM UPPER BOUND USED
!     DOUBLE PRECISION YMDDSD
!        THE MEAN ABSOLUTE DEVIATION / THE STANDARD DEVIATION
!     DOUBLE PRECISION YMEAN, YMEANT
!        THE MEAN OF THE OBSERVATIONS USED IN THE HISTOGRAM
!     DOUBLE PRECISION YMED
!        THE MEDIAN OF THE OBSERVATIONS USED IN THE HISTOGRAM
!     DOUBLE PRECISION YMIDRG
!        THE MID RANGE OF THE OBSERVATIONS USED IN THE HISTOGRAM
!     DOUBLE PRECISION YMIN
!        THE HISTOGRAM LOWER BOUND USED.
!     DOUBLE PRECISION YRANGE
!        THE RANGE OF THE OBSERVATIONS USED IN THE HISTOGRAM
!     DOUBLE PRECISION YSD
!        THE STANDARD DEVIATION OF THE OBSERVATIONS USED IN THE
!        HISTOGRAM.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!     DOUBLE PRECISION YVAR
!        THE VARIANCE OF THE OBSERVATIONS.
!
      DATA IPLUS /'+'/
      DATA ALPHA/0.25D0/
!
      CALL IPRINT(IPRT)
!
!     SORT DATA
!
      CALL GENI(LSORT, N, 1, 1)
      CALL SRTIR(LSORT, N, Y)
!
!     FIX UPPER AND LOWER BOUNDS.
!
      NLOW = 1
      NHIGH = N
      IF (YLB.EQ.YUB) GO TO 50
!
!     FIND INDEX OF THE FIRST VALUE OF Y .GE. YLB
!
      DO 20 I=1,N
         IF (Y(I).LT.YLB) GO TO 20
         NLOW = I
         GO TO 30
   20 CONTINUE
!
!     FIND INDEX OF THE LAST VALUE OF Y .LE. YUB
!
   30 DO 40 I=1,N
         J = N - I + 1
         IF (Y(J).GT.YUB) GO TO 40
         NHIGH = J
         GO TO 50
   40 CONTINUE
   50 CONTINUE
      XN = NHIGH-NLOW+1
      NOBS = NHIGH - NLOW + 1
!
!     COMPUTE MEDIAN, EXTREMA, MID-RANGE, RANGE AND FREQUENCY
!     DISTRIBUTION FOR NCELLS CELLS
!
      CALL STAT1(Y(NLOW), NOBS, YMED, YMIN, YMAX, YMIDRG, YRANGE,
     +   NCELLS, YLB, YUB, YDIST)
!
      IF (YLB.GE.YUB) GO TO 55
!
      YMIN = YLB
      YMAX = YUB
!
   55 CONTINUE
!
!     COMPUTE MEAN, TRIMMED MEAN, STANDARD DEVIATION,
!     MEAN DEVIATION/STANDARD DEVIATION, BETA ONE, AND BETA TWO
!
      CALL SUMBS(Y, N, NLOW, MID, NHIGH)
      CALL SUMSS(Y, N, NLOW, MID, NHIGH, SUM1, SUM2, SUM3, YMEAN)
      CALL SUMTS(Y(NLOW), NOBS, ALPHA, SUMT1, YMEANT)
      CALL SUMDS(Y, N, NLOW, MID, NHIGH, YMEAN, SUMDA, SUMD2, SUMD3,
     +   SUMD4)
!
      YVAR = 0.0D0
      YSD = 0.0D0
      B1SQRT = 0.0D0
      B2 = 0.0D0
      YMDDSD = 0.0D0
!
      IF ((SUMD2.LE.0.0D0) .OR. (NOBS.LE.1)) GO TO 60
!
      YVAR = SUMD2/(NOBS-1)
      YSD = SQRT(YVAR)
      B1SQRT = ABS((SUMD3/XN)/((SUMD2/XN)**1.5D0))
      B2 = (SUMD4/XN)/((SUMD2/XN)**2)
      YMDDSD = SUMDA/(YSD*NOBS)
!
   60 CONTINUE
!
!     OUTPUT STATISTICS
!
      CALL VERSP(.TRUE.)
      WRITE (IPRT,1070) N, Y(NLOW), Y(NHIGH), YMIN, YMAX
      WRITE (IPRT,1000)
     +   NCELLS, NOBS, YMEANT, Y(NLOW), YSD, Y(NHIGH), YMDDSD,
     +   YMEAN, B1SQRT, YMED, B2
      WRITE (IPRT,1010)
!
!     CHECK FOR MORE THAN 50 VALUES IN INTERVAL AND FIND MAX. VALUE.
!
      IFLAG = 0
      CNTMX = 0.0D0
      DO 80 I=1,NCELLS
         IF (YDIST(I).GT.CNTMX) CNTMX = YDIST(I)
   80 CONTINUE
      IF (NINT(CNTMX).GT.50) IFLAG = 1
!
!     DETERMINE SCALE.
!
      IF (IFLAG.EQ.0) THEN
         SCALE = 1.0D0
      ELSE
         P = CNTMX/XN
         SCALE = 0.05D0
         IF (P.GT.0.25D0) SCALE = 0.1D0
         IF (P.GT.0.5D0) SCALE = 0.2D0
      END IF
!
!     PRINT COLUMN HEADINGS AND HISTOGRAM SCALE.
!
      IF (IFLAG.EQ.0) WRITE (IPRT,1020)
      IF (IFLAG.NE.0) WRITE (IPRT,1080)
      WRITE (IPRT,1090)
      IF (IFLAG.NE.0) GO TO 100
      WRITE (IPRT,1030) (I,I=10,50,10)
      GO TO 120
  100 A(1) = 0.0D0
      DO 110 I=1,5
         A(I+1) = A(I) + SCALE
  110 CONTINUE
      WRITE (IPRT,1040) (A(I),I=1,6)
  120 WRITE (IPRT,1050)
      CFRACT = 0.0D0
      CFRCTM = 1.0D0
      TEMP = 0.0D0
      WIDTH = (YMAX-YMIN)/NCELLS
      YINTMP = YMIN
      YINTMP = YINTMP - WIDTH/2.0D0
      DO 150 I=1,NCELLS
         NUM = INT(YDIST(I)+0.5D0)
         IF (MOD(NCELLS,2).EQ.1 .AND. I.EQ.NCELLS/2+1
     +       .AND. YMIN.EQ.(-YMAX)) THEN
            YINTMP = 0.0D0
         ELSE
            YINTMP = YINTMP + WIDTH
         END IF
         FRACT = YDIST(I)/XN
         CFRACT = CFRACT + FRACT
         CFRCTM = 1.0D0 - TEMP
         TEMP = CFRACT
         IF (NUM.LE.0) THEN
           WRITE (IPRT,1060) YINTMP, CFRACT, CFRCTM, FRACT, NUM
         ELSE
           IF (IFLAG.EQ.0) THEN
             NUMS = NUM
           ELSE
             XNN = FRACT*10.0D0/SCALE
             NUMS = INT(XNN)
             NUMS = MAX(1, NUMS + INT(XNN-NUMS+0.5D0))
           END IF
           WRITE (IPRT,1060) YINTMP, CFRACT, CFRCTM, FRACT,
     +        NUM, (IPLUS,J=1,NUMS)
         END IF
  150 CONTINUE
!
!     RESTORE DATA TO ORIGINAL ORDER
!
      CALL SRTRI(Y, N, LSORT)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/26H NUMBER OF CELLS        = , I15/
     +        26H OBSERVATIONS USED      = , I15, 11X,
     +              22H25 PCT TRIMMED MEAN = , 1PE15.8/
     +        26H MIN. OBSERVATION USED  = , E15.8, 11X,
     +              22HSTANDARD DEVIATION  = , E15.8/
     +        26H MAX. OBSERVATION USED  = , E15.8, 11X,
     +              22HMEAN DEV./STD. DEV. = , E15.8/
     +        26H MEAN VALUE             = , E15.8, 11X,
     +              22HSQRT(BETA ONE)      = , E15.8/
     +        26H MEDIAN VALUE           = , E15.8, 11X,
     +              22HBETA TWO            = , E15.8)
 1010 FORMAT(//44H FOR A NORMAL DISTRIBUTION, THE VALUES (MEAN,
     +   56H DEVIATION/STANDARD DEVIATION), SQRT(BETA ONE), AND BETA,
     +   22H TWO ARE APPROXIMATELY/
     +   ' 0.8, 0.0 AND 3.0, RESPECTIVELY.  TO TEST THE ',
     +   59HNULL HYPOTHESIS OF NORMALITY, SEE TABLES OF CRITICAL VALUES,
     +   13H PP. 207-208,/  22H BIOMETRIKA TABLES FOR,
     +   58H STATISTICIANS, VOL. 1.  SEE PP. 67-68 FOR A DISCUSSION OF,
     +   13H THESE TESTS.)
 1020 FORMAT(///5X,39HINTERVAL     CUM.   1-CUM.   CELL   NO.,19X,
     + 22HNUMBER OF OBSERVATIONS)
 1030 FORMAT('+',47X,1H0,8X,5(I2,8X))
 1040 FORMAT('+',46X,6(F4.2,6X))
 1050 FORMAT(4X,42('-'),2X,'+',5(10H---------+))
 1060 FORMAT(3X,1PE13.6,2X,2(0PF5.3,3X),F5.3,1X,I5,4X,50A1)
 1070 FORMAT (10H HISTOGRAM//
     +        26H NUMBER OF OBSERVATIONS = , I15/
     +        26H MINIMUM OBSERVATION    = , 1PE15.8/
     +        26H MAXIMUM OBSERVATION    = , E15.8//
     +        26H HISTOGRAM LOWER BOUND  = , E15.8/
     +        26H HISTOGRAM UPPER BOUND  = , E15.8)
 1080 FORMAT(///5X,39HINTERVAL     CUM.   1-CUM.   CELL   NO.,23X,
     + 13HCELL FRACTION)
 1090 FORMAT(5X,41HMID POINT   FRACT.  FRACT.  FRACT.  OBS. )
      END
!UFSMS
      SUBROUTINE UFSMS(Y, YMISS, N, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   SPCF, ISPCF, FREQ, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS WITH MISSING DATA (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN,YMISS
      INTEGER
     +   ISPCF,LDSTAK,N,NF,NPRT,NW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),SPCF(*),Y(*)
      INTEGER
     +   LAGS(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA
      INTEGER
     +   ACOV,I,IFP,IO,IPRT,ISORT,ISYM,LACOV,LAGMAX,LDSMIN,LNLPPA,
     +   LPCV,LWORK,LY,NALL0,NLPPA,WORK,XAXIS,YAXIS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ECVF,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UFSDRV
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER ACOV
!        THE STARTING LOCATION IN RSTAK FOR THE ACVF VECTOR.
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE SPECTRUM
!        IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF ERR01, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION FOR THE ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY ISYM.
!     INTEGER LACOV
!        THE LENGTH OF VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
!        THIS ROUTINE WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA
!        THE STARTING LOCATION IN ISTAK FOR THE ARRAY CONTAINING
!        THE NUMBERS OF LAGGED PRODUCT PAIRS USED FOR EACH ACVF.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION SPCF(ISPCF,NW)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY WINDOW.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY XAXIS.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY YAXIS.
!     DOUBLE PRECISION YMISS
!        THE MISSING VALUE CODE FOR THE SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','M','S',' '/
!
!     SET UP
!
      OPTION(4) = .TRUE.
      OPTION(3) = .FALSE.
      OPTION(2) = .TRUE.
      OPTION(1) = .FALSE.
!
!     SET MAXIMUM LAG VALUE TO BE USED.
!
      LAGMAX = N - 1
      IF (NW.LE.0) GO TO 20
      LAGMAX = LAGS(1)
      DO 10 I=1,NW
         LAGMAX = MAX(LAGMAX,LAGS(I))
   10 CONTINUE
   20 CONTINUE
      LACOV = LAGMAX + 1
      LNLPPA = LAGMAX + 1
!
!     COMPUTE MINIMUM ALLOWABLE STACK LENGTH
!
      IO = 1
      IF (NPRT.EQ.0) IO = 0
!
      CALL LDSCMP(6, 0, LAGMAX+1+IO*(NF+5), 0, 0, 0, 'D',
     +   2*LAGMAX+2+IO*(2*NF+10), LDSMIN)
!
      LY = N
      LNLPPA = LACOV
      LPCV = NF + 5
      LWORK = LAGMAX+1
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!     SET THE STACK ALLOCATION TYPE.
!
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
!
      IFP = 4
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
!
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         NLPPA = 1
         ACOV = 1
         WORK = 1
         XAXIS = 1
         YAXIS = 1
         ISYM = 1
         ISORT = 1
      ELSE
         NLPPA = STKGET(LACOV,2)
         ACOV = STKGET(LACOV,IFP)
         WORK = STKGET(LWORK,IFP)
         IF (NPRT.NE.0) THEN
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
            ISYM = STKGET(LPCV,2)
            ISORT = ISYM
         ELSE
            XAXIS = WORK
            YAXIS = WORK
            ISYM = WORK
            ISORT = ISYM
         END IF
      END IF
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!     FOR SERIES WITH MISSING DATA.
!
      CALL UFSDRV(Y, LY, YMISS, RSTAK(ACOV), ISTAK(NLPPA), SPCF, ISPCF,
     +   NF, FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS, RSTAK(WORK), LACOV,
     +   LWORK, DELTA, ISTAK(ISORT), ISTAK(ISYM), RSTAK(XAXIS),
     +   RSTAK(YAXIS), LPCV, ALPHA, NPRT, PARZEN, NMSUB, LDSMIN, LDSTAK,
     +   OPTION, LNLPPA, LY)
!
      CALL STKCLR(NALL0)
!
!     CHECK FOR ERRORS
!
      IF (IERR.EQ.0) RETURN
!
      IF (IERR.EQ.2) CALL ECVF(NMSUB)
      IERR = 1
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL UFSMS (Y, YMISS, N,'/
     +   '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +   '      +            SPCF, ISPCF, FREQ, LDSTAK)')
      END
!PPFCHS
      DOUBLE PRECISION FUNCTION PPFCHS(P, NU)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS FUNCTION IS A VERSION OF DATAPAC SUBROUTINE CHSPPF, WITH
!     MODIFICATIONS TO FACILITATE CONVERSION TO DOUBLE PRECISION
!     AUTOMATICALLY USING THE NAG, INC., CODE APT, AND TO CORRESPOND
!     TO STARPAC CONVENTIONS.
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE CHI-SQUARED DISTRIBUTION
!              WITH INTEGER DEGREES OF FREEDOM PARAMETER = NU.
!              THE CHI-SQUARED DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL NON-NEGATIVE X,
!              AND ITS PROBABILITY DENSITY FUNCTION IS GIVEN
!              IN REFERENCES 2, 3, AND 4 BELOW.
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0D0 (INCLUSIVELY)
!                                AND 1.0D0 (EXCLUSIVELY))
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!                     --NU     = THE INTEGER NUMBER OF DEGREES
!                                OF FREEDOM.
!                                NU SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--PPFCHS = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT FUNCTION .
!             VALUE PPFCHS FOR THE CHI-SQUARED DISTRIBUTION
!             WITH DEGREES OF FREEDOM PARAMETER = NU.
!     PRINTING--DECEMBER 2, 1985  (JRD) UNLESS AN INPUT ARGUMENT ERROR C
!     RESTRICTIONS--NU SHOULD BE A POSITIVE INTEGER VARIABLE.
!                 --P SHOULD BE BETWEEN 0.0D0 (INCLUSIVELY)
!                   AND 1.0D0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE
!     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP, LOG.
!     MODE OF INTERNAL OPERATIONS--DOUBLE PRECISION.
!     LANGUAGE--ANSI FORTRAN.
!     ACCURACY--(ON THE UNIVAC 1108, EXEC 8 SYSTEM AT NBS)
!               COMPARED TO THE KNOWN NU = 2 (EXPONENTIAL)
!               RESULTS, AGREEMENT WAS HAD OUT TO 6 SIGNIFICANT
!               DIGITS FOR ALL TESTED P IN THE RANGE P = .001 TO
!               P = .999.  FOR P = .95 AND SMALLER, THE AGREEMENT
!               WAS EVEN BETTER--7 SIGNIFICANT DIGITS.
!               (NOTE THAT THE TABULATED VALUES GIVEN IN THE WILK,
!               GNANADESIKAN, AND HUYETT REFERENCE BELOW, PAGE 20,
!               ARE IN ERROR FOR AT LEAST THE GAMMA = 1 CASE--
!               THE WORST DETECTED ERROR WAS AGREEMENT TO ONLY 3
!               SIGNIFICANT DIGITS (IN THEIR 8 SIGNIFICANT DIGIT TABLE)
!               FOR P = .999.)
!     REFERENCES--WILK, GNANADESIKAN, AND HUYETT, "PROBABILITY
!                 PLOTS FOR THE GAMMA DISTRIBUTION",
!                 TECHNOMETRICS, 1962, PAGES 1-15,
!                 ESPECIALLY PAGES 3-5.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 257, FORMULA 6.1.41,
!                 AND PAGES 940-943.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 166-206.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 46-51.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE  301-921-2315
!     ORIGINAL VERSION--SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   P
      INTEGER
     +   NU
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   A,AJ,B,C,CUT1,CUT2,CUTOFF,DEN,DX,FP,GAMMA,
     +   PCALC,SUM,TERM,XDEL,XLOWER,XMAX,XMID,XMIN,XMIN0,XUPPER,
     +   Z,Z2,Z3,Z4,Z5
      INTEGER
     +   ICOUNT,ILOOP,IPRT,J,MAXIT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   D(10)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC EXP,LOG
!
!
      DATA C/0.918938533204672741D0/
      DATA D(3),D(4),D(5)
     +  /+0.793650793650793651D-3,
     +   -0.595238095238095238D-3,
     +   +0.8417508417508417151D-3/
      DATA D(6),D(7),D(8),D(9),D(10)
     +  /-0.191752691752691753D-2,
     +   +0.641025641025641025D-2,
     +   -0.2955065359147712418D-1,
     +   +0.179644372368830573D0,
     +   -0.139243221690590111D1/
!
      D(1) = 1.0D0/12.0D0
      D(2) = 1.0D0/360.0D0
!
      CALL IPRINT (IPRT)
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      IF (P.LT.0.0D0 .OR. P.GE.1.0D0) THEN
         WRITE(IPRT,1010)
         WRITE(IPRT,1030) P
         PPFCHS = 0.0D0
         RETURN
      END IF
      IF(NU.LT.1) THEN
         WRITE(IPRT,1020)
         WRITE(IPRT,1040) NU
         PPFCHS = 0.0D0
         RETURN
      END IF
!
!-----START POINT-----------------------------------------------------
!
!     EXPRESS THE CHI-SQUARED DISTRIBUTION PERCENT POINT
!     FUNCTION IN TERMS OF THE EQUIVALENT GAMMA
!     DISTRIBUTION PERCENT POINT FUNCTION,
!     AND THEN EVALUATE THE LATTER.
!
      FP = P
      GAMMA = NU/2.0D0
      MAXIT = 10000
!
!     COMPUTE THE GAMMA FUNCTION USING THE ALGORITHM IN THE
!     NBS APPLIED MATHEMATICS SERIES REFERENCE.
!     THIS GAMMA FUNCTION NEED BE CALCULATED ONLY ONCE.
!     IT IS USED IN THE CALCULATION OF THE CDF BASED ON
!     THE TENTATIVE VALUE OF THE PPFCHS IN THE ITERATION.
!
      Z = GAMMA
      DEN = 1.0D0
  150 IF(Z.LT.10.0D0) THEN
         DEN = DEN*Z
         Z = Z+1.0D0
         GO TO 150
      END IF
      Z2 = Z*Z
      Z3 = Z*Z2
      Z4 = Z2*Z2
      Z5 = Z2*Z3
      A = (Z-0.5D0)*LOG(Z)-Z+C
      B = D(1)/Z + D(2)/Z3 + D(3)/Z5 + D(4)/(Z2*Z5) + D(5)/(Z4*Z5) +
     +    D(6)/(Z*Z5*Z5) + D(7)/(Z3*Z5*Z5) + D(8)/(Z5*Z5*Z5) +
     +    D(9)/(Z2*Z5*Z5*Z5)
!     G = EXP(A+B)/DEN
!
!     DETERMINE LOWER AND UPPER LIMITS ON THE DESIRED 100P
!     PERCENT POINT.
!
      ILOOP = 1
!     XMIN0 = (FP*GAMMA*G)**(1.0D0/GAMMA)
      XMIN0 = EXP((1.0D0/GAMMA)*(LOG(FP)+LOG(GAMMA)+(A+B)-LOG(DEN)))
      XMIN = XMIN0
      XLOWER = XMIN
      XMID = XMIN
      XUPPER = XMIN
      ICOUNT = 1
  350 CONTINUE
      XMAX = ICOUNT*XMIN0
      DX = XMAX
      GO TO 600
  360 IF(PCALC.LT.FP) THEN
         XMIN = XMAX
         ICOUNT = ICOUNT+1
         IF(ICOUNT.LE.30000) GO TO 350
      END IF
      XMID = (XMIN+XMAX)/2.0D0
!
!     NOW ITERATE BY BISECTION UNTIL THE DESIRED ACCURACY IS ACHIEVED.
!
      ILOOP = 2
      XLOWER = XMIN
      XUPPER = XMAX
      ICOUNT = 0
  550 DX = XMID
      GO TO 600
  560 IF(PCALC.NE.FP) THEN
         IF(PCALC.GT.FP) THEN
            XUPPER = XMID
            XMID = (XMID+XLOWER)/2.0D0
         ELSE
            XLOWER = XMID
            XMID = (XMID+XUPPER)/2.0D0
         END IF
         XDEL = XMID-XLOWER
         IF(XDEL.LT.0.0D0)XDEL = -XDEL
         ICOUNT = ICOUNT+1
         IF((XDEL.GE.0.0000000001D0) .AND. (ICOUNT.LE.100)) GO TO 550
      END IF
      PPFCHS = 2.0D0*XMID
      RETURN
!
!********************************************************************
!     THIS SECTION BELOW IS LOGICALLY SEPARATE FROM THE ABOVE.
!     THIS SECTION COMPUTES A CDF VALUE FOR ANY GIVEN TENTATIVE
!     PERCENT POINT X VALUE AS DEFINED IN EITHER OF THE 2
!     ITERATION LOOPS IN THE ABOVE CODE.
!
!     COMPUTE T-SUB-Q AS DEFINED ON PAGE 4 OF THE WILK, GNANADESIKAN,
!     AND HUYETT REFERENCE
!
  600 SUM = 1.0D0/GAMMA
      TERM = 1.0D0/GAMMA
      CUT1 = DX-GAMMA
      CUT2 = DX*10000000000.0D0
      DO 700 J=1,MAXIT
         AJ = J
         TERM = DX*TERM/(GAMMA+AJ)
         SUM = SUM+TERM
         CUTOFF = CUT1+(CUT2*TERM/SUM)
         IF (AJ.GT.CUTOFF) GO TO 750
  700 CONTINUE
      WRITE(IPRT,1050)MAXIT
      WRITE(IPRT,1060)P
      WRITE(IPRT,1070)NU
      WRITE(IPRT,1080)
      PPFCHS = 0.0D0
      RETURN
!
  750 CONTINUE
!     PCALC = (DX**GAMMA)*(EXP(-DX))*SUM/G
      PCALC = EXP(GAMMA*LOG(DX) + LOG(SUM) + LOG(DEN) - DX - A - B)
      IF (ILOOP.EQ.1) GO TO 360
      GO TO 560
!
 1010 FORMAT(' ',115H***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO THE
     + PPFCHS FUNCTION IS OUTSIDE THE ALLOWABLE (0,1  ) INTERVAL *****)
 1020 FORMAT(' ', 91H***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO THE
     + PPFCHS FUNCTION IS NON-POSITIVE *****  )
 1030 FORMAT(' ', 35H***** THE VALUE OF THE ARGUMENT IS ,E15.8,6H *****)
 1040 FORMAT(' ', 35H***** THE VALUE OF THE ARGUMENT IS ,I8   ,6H *****)
 1050 FORMAT(' ',48H*****ERROR IN INTERNAL OPERATIONS IN THE PPFCHS ,
     + 43HFUNCTION--THE NUMBER OF ITERATIONS EXCEEDS ,I7)
 1060 FORMAT(' ',33H     THE INPUT VALUE OF P     IS ,E15.8)
 1070 FORMAT(' ',33H     THE INPUT VALUE OF NU    IS ,I8)
 1080 FORMAT(52H      THE OUTPUT VALUE OF PPFCHS HAS BEEN SET TO 0.0)
!
      END
!OANOVA
      SUBROUTINE OANOVA(YSUM, RED, NPAR, RVAR, NNZW, TEMP, IPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     COMPUTE AND PRINT ANALYSIS OF VARIANCE
!
!     WRITTEN BY DAVID HOGBEN, SEL, NBS.   10/09/69.
!
!     THIS ROUTINE WAS ADAPTED FROM THE OMNITAB ROUTINE OANOVA
!     BY - -
!
!     JANET R. DONALDSON
!     STATISTICAL ENGINEERING DIVISION
!     NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RVAR,YSUM
      INTEGER
     +   IPRT,NNZW,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RED(NPAR),TEMP(NPAR)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ASUM,CR,F1,F2,FPLM,PF1,PF2,RESMS,RESSS,SSU,V1F2,VR
      INTEGER
     +   I,K,NSUA
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFF,D1MACH
      EXTERNAL CDFF,D1MACH
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ASUM
!        *
!     DOUBLE PRECISION CR
!        *
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     DOUBLE PRECISION F1
!        *
!     DOUBLE PRECISION F2
!        *
!     INTEGER I
!        AN INDEX.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER K
!        *
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NSUA
!        *
!     DOUBLE PRECISION PF1
!        *
!     DOUBLE PRECISION PF2
!        *
!     DOUBLE PRECISION RED(NPAR)
!        THE REDUCTION TO THE SUM OF SQUARES DUE TO EACH PARAMETER.
!     DOUBLE PRECISION RESMS
!        *
!     DOUBLE PRECISION RESSS
!        *
!     DOUBLE PRECISION RVAR
!        THE RESIDUAL VARIANCE.
!     DOUBLE PRECISION SSU
!        *
!     DOUBLE PRECISION TEMP(NPAR)
!        A WORK VECTOR.
!     DOUBLE PRECISION VR
!        *
!     DOUBLE PRECISION V1F2
!        *
!     DOUBLE PRECISION YSUM
!        THE SUM OF THE WEIGHTED DEPENDENT VARIABLES SQUARED.
!
!
      FPLM = D1MACH(2)
!
      RESMS = YSUM/NNZW
      NSUA = NNZW
      WRITE (IPRT,1000)
      ASUM = 0.0D0
      VR = NNZW-NPAR
      RESSS = VR*RVAR
      TEMP(NPAR) = RESSS
      IF (NPAR.EQ.1) GO TO 20
      DO 10 I=2,NPAR
         K = NPAR + 2 - I
         TEMP(K-1) = TEMP(K) + RED(K)
   10 CONTINUE
   20 V1F2 = NPAR+1
      SSU = NNZW
      DO 50 I=1,NPAR
         NSUA = NSUA - 1
         ASUM = ASUM + RED(I)
         SSU = SSU - 1.0D0
         CR = ASUM/I
         RESMS = 0.0D0
         IF (SSU.GT.0.0D0) RESMS = TEMP(I)/SSU
         V1F2 = V1F2 - 1.0D0
!
!     NEVER POOL
!
         IF (RVAR.GT.0.0D0) GO TO 30
         F1 = FPLM
         F2 = FPLM
         PF1 = 0.0D0
         PF2 = 0.0D0
         GO TO 40
   30    F1 = RED(I)/RVAR
         PF1 = 1.0D0 - CDFF(F1,1.0D0,VR)
!
!     TEST HIGHER SUB-HYPOTHESES
!
         F2 = (TEMP(I)+RED(I)-RESSS)/V1F2/RVAR
         PF2 = 1.0D0 - CDFF(F2,V1F2,VR)
   40    CONTINUE
         WRITE (IPRT,1010) I, RED(I), CR, I, RESMS, NSUA, F1, PF1, F2,
     +      PF2
   50 CONTINUE
      WRITE (IPRT,1020) RESSS, NSUA
      WRITE (IPRT,1030) YSUM, NNZW
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (////50X, 20HANALYSIS OF VARIANCE/24X, 16H-DEPENDENT ON OR,
     +   33HDER VARIABLES ARE ENTERED, UNLESS, 21H VECTORS ARE ORTHOGON,
     +   3HAL-//
     +   1X, 5H PAR , 4X, 14HSUM OF SQUARES, 63X,
     +   19H------ PAR=0 ------, 4X, 19H------ PARS=0 -----/
     +   1X, 5HINDEX, 4X, 14HRED DUE TO PAR, 7X, 10HCUM MS RED,
     +   6X, 9HDF(MSRED), 6X, 10HCUM RES MS, 6X, 7HDF(RMS), 5X,
     +   'F', 8X, 7HPROB(F), 7X, 'F', 8X, 7HPROB(F)/)
 1010 FORMAT (1X, I3, 6X, G16.9, 3X, G16.9, 1X, I6, 8X, G16.9, 1X, I5,
     +   4X, G12.6, F7.3, 4X, G12.6, F7.3)
 1020 FORMAT (/1X, 10HRESIDUAL  , 1X, G14.7, 20X, I6)
 1030 FORMAT (1X, 10HTOTAL     , 1X, G14.7, 20X, I6)
      END
!PPFF
      DOUBLE PRECISION FUNCTION PPFF(P, NU1, NU2)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS FUNCTION IS A VERSION OF DATAPLOT SUBROUTINE FPPF,
!     WITH MODIFICATIONS NECESSARY TO CORRESPOND TO STARPAC CONVENTIONS.
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FOR THE F DISTRIBUTION
!              WITH INTEGER DEGREES OF FREEDOM
!              PARAMETERS = NU1 AND NU2.
!              THIS DISTRIBUTION IS DEFINED FOR ALL NON-NEGATIVE X.
!              THE PROBABILITY DENSITY FUNCTION IS GIVEN
!              IN THE REFERENCES BELOW.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0D0 AND 1.0D0)
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!                     --NU1    = THE INTEGER DEGREES OF FREEDOM
!                                FOR THE NUMERATOR OF THE F RATIO.
!                                NU1 SHOULD BE POSITIVE.
!                     --NU2    = THE INTEGER DEGREES OF FREEDOM
!                                FOR THE DENOMINATOR OF THE F RATIO.
!                                NU2 SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--PPFF    = THE SINGLE PRECISION PERCENT POINT
!                                FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT
!             FUNCTION VALUE PPFF FOR THE F DISTRIBUTION
!             WITH DEGREES OF FREEDOM
!             PARAMETERS = NU1 AND NU2.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN
!                   0.0D0 (INCLUSIVELY) AND 1.0D0 (EXCLUSIVELY).
!                 --NU1 SHOULD BE A POSITIVE INTEGER VARIABLE.
!                 --NU2 SHOULD BE A POSITIVE INTEGER VARIABLE.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGES 946-947,
!                 FORMULAE 26.6.4, 26.6.5, 26.6.8, AND 26.6.15.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGE 83, FORMULA 20,
!                 AND PAGE 84, THIRD FORMULA.
!               --PAULSON, AN APPROXIMATE NORMAILIZATION
!                 OF THE ANALYSIS OF VARIANCE DISTRIBUTION,
!                 ANNALS OF MATHEMATICAL STATISTICS, 1942,
!                 NUMBER 13, PAGES 233-135.
!               --SCHEFFE AND TUKEY, A FORMULA FOR SAMPLE SIZES
!                 FOR POPULATION TOLERANCE LIMITS, 1944,
!                 NUMBER 15, PAGE 217.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE-- THIS ROUTINE WAS ADAPTED FROM DATAPLOT SUBROUTINE
!            FPPF WITH PERMISSION FROM THE AUTHOR.  DATAPLOT IS
!            A REGISTERED TRADEMARK.
!
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THIS LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!     VERSION NUMBER--82.3
!     ORIGINAL VERSION--MAY       1978.
!     UPDATED         --AUGUST    1979.
!     UPDATED         --DECEMBER  1981.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   P
      INTEGER
     +   NU1,NU2
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ANU1,ANU2,EXPF,PCALC,SDF,TOL,X,XDEL,XLOW,XMAX,
     +   XMID,XMIN,XN,XUP,ZN
      INTEGER
     +   IBUG,ICOUNT,IPRT,MAXIT
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFF,PPFNML
      EXTERNAL CDFF,PPFNML
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,EXP,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ANU1
!        THE (DOUBLE PRECISION) DEGREES OF FREEDOM IN THE NUMERATOR.
!     DOUBLE PRECISION ANU2
!        THE (DOUBLE PRECISION) DEGREES OF FREEDOM IN THE DENOMINATOR.
!     DOUBLE PRECISION EXPF
!        *
!     INTEGER IBUG
!        *
!     INTEGER ICOUNT
!        *
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MAXIT
!        *
!     INTEGER NU1
!        THE DEGREES OF FREEDOM IN THE NUMERATOR.
!     INTEGER  NU2
!        THE DEGREES OF FREEDOM IN THE DENOMINATOR.
!     DOUBLE PRECISION P
!        THE VALUE (BETWEEN 0.0D0 AND 1.0D0) AT WHICH THE PERCENT POINT
!        IS TO BE CALCULATED.
!     DOUBLE PRECISION PCALC
!        *
!     DOUBLE PRECISION SDF
!        *
!     DOUBLE PRECISION TOL
!        *
!     DOUBLE PRECISION X
!        *
!     DOUBLE PRECISION XDEL
!        *
!     DOUBLE PRECISION XLOW
!        *
!     DOUBLE PRECISION XMAX
!        *
!     DOUBLE PRECISION XMID
!        *
!     DOUBLE PRECISION XMIN
!        *
!     DOUBLE PRECISION XN
!        *
!     DOUBLE PRECISION XUP
!        *
!     DOUBLE PRECISION ZN
!        *
!
!---------------------------------------------------------------------
!
!     COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!     COMMON /PRINT/IFEEDB,IPRINT
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      CALL IPRINT(IPRT)
!
      PPFF = 0.0D0
      IF (NU1.LE.0) GO TO 10
      IF (NU2.LE.0) GO TO 20
      IF (P.LT.0.0D0 .OR. P.GE.1.0D0) GO TO 30
      GO TO 40
   10 WRITE (IPRT,1010)
      WRITE (IPRT,1040) NU1
      PPFF = 0.0D0
      RETURN
   20 WRITE (IPRT,1020)
      WRITE (IPRT,1040) NU2
      PPFF = 0.0D0
      RETURN
   30 WRITE (IPRT,1000)
      WRITE (IPRT,1030) P
      PPFF = 0.0D0
      RETURN
   40 CONTINUE
!
!-----START POINT-----------------------------------------------------
!
      IBUG = 0.0D0
!
      TOL = 0.000001D0
      MAXIT = 100
      XMIN = 0.0D0
      XMAX = 10.0D30
      XLOW = XMIN
      XUP = XMAX
!
      ANU1 = NU1
      ANU2 = NU2
!
      EXPF = 0.5D0*((1.0D0/ANU2)-(1.0D0/ANU1))
      SDF = SQRT(0.5D0*((1.0D0/ANU2)+(1.0D0/ANU1)))
      ZN = PPFNML(P)
      XN = EXPF + ZN*SDF
      XMID = EXP(2.0D0*XN)
      IF (IBUG.EQ.1) WRITE (IPRT,1050) XMID
!
      IF (P.EQ.0.0D0) GO TO 50
      GO TO 60
   50 CONTINUE
      PPFF = XMIN
      RETURN
   60 CONTINUE
!
      ICOUNT = 0
!
   70 CONTINUE
      X = XMID
      PCALC = CDFF(X,ANU1,ANU2)
      IF (PCALC.EQ.P) GO TO 130
      IF (PCALC.GT.P) GO TO 100
!
   80 CONTINUE
      XLOW = XMID
      X = XMID*2.0D0
      IF (X.GE.XUP) GO TO 90
      XMID = X
      IF (IBUG.EQ.1) WRITE (IPRT,1050) XMID
      PCALC = CDFF(X,ANU1,ANU2)
      IF (PCALC.EQ.P) GO TO 130
      IF (PCALC.LT.P) GO TO 80
      XUP = X
   90 CONTINUE
      XMID = (XLOW+XUP)/2.0D0
      IF (IBUG.EQ.1) WRITE (IPRT,1050) XMID
      GO TO 120
!
  100 CONTINUE
      XUP = XMID
      X = XMID/2.0D0
      IF (X.LE.XLOW) GO TO 110
      XMID = X
      IF (IBUG.EQ.1) WRITE (IPRT,1050) XMID
      PCALC = CDFF(X,ANU1,ANU2)
      IF (PCALC.EQ.P) GO TO 130
      IF (PCALC.GT.P) GO TO 100
      XLOW = X
  110 CONTINUE
      XMID = (XLOW+XUP)/2.0D0
      IF (IBUG.EQ.1) WRITE (IPRT,1050) XMID
!
  120 CONTINUE
      XDEL = ABS(XMID-XLOW)
      ICOUNT = ICOUNT + 1
      IF (XDEL.LT.TOL .OR. ICOUNT.GT.MAXIT) GO TO 130
      GO TO 70
!
  130 CONTINUE
      PPFF = XMID
!
      RETURN
 1000 FORMAT (' ', 49H***** FATAL ERROR--THE FIRST  INPUT ARGUMENT TO T,
     +   59HHE FPPF SUBROUTINE IS OUTSIDE THE ALLOWABLE (0,1) INTERVAL ,
     +   5H*****)
 1010 FORMAT (' ', 49H***** FATAL ERROR--THE SECOND INPUT ARGUMENT TO T,
     +   42HHE FPPF   SUBROUTINE IS NON-POSITIVE *****)
 1020 FORMAT (' ', 49H***** FATAL ERROR--THE THIRD  INPUT ARGUMENT TO T,
     +   42HHE FCDF   SUBROUTINE IS NON-POSITIVE *****)
 1030 FORMAT (' ', 35H***** THE VALUE OF THE ARGUMENT IS , E15.8,
     +   6H *****)
 1040 FORMAT (' ', 35H***** THE VALUE OF THE ARGUMENT IS , I8, 6H *****)
 1050 FORMAT (' ', 7HXMID = , E15.7)
      END
!AIMX1
      SUBROUTINE AIMX1(MXN, MXPAR, MXFC, MXFCO, MXFAC,
     +   MOD, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV,
     +   NFCST, NFCSTO, IFCSTO, FCST, IFCST, FCSTSD)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     SET THE STARTING PARAMETER VALUES FOR AIMX
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IFCST,IVAPRX,IVCV,MIT,MOD,MXFAC,MXFC,MXFCO,MXN,MXPAR,N,
     +   NFAC,NFCST,NFCSTO,NPAR,NPARE,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FCST(MXFC,*),FCSTSD(*),PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),
     +   SDRES(*),STP(*),VCV(MXPAR,*)
      INTEGER
     +   IFCSTO(*),IFIXED(*),MSPEC(4,*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   SQMEPS
      INTEGER
     +   I,J
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!
!  EXTERNAL SUBROUTINES
      EXTERNAL SETRV
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION FCST(MXFC,MXFCO)
!        THE FORECASTS.
!     DOUBLE PRECISION FCSTSD(MXFC)
!        THE STANDARD DEVIATION OF THE FORECASTS.
!     INTEGER I
!        *
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFCST
!        *
!     INTEGER IFCSTO(MXFCO)
!        THE FORECAST ORIGINS.
!     INTEGER IFIXED(MXPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IVAPRX
!        *
!     INTEGER IVCV
!        THE ACTUAL FIRST DIMENSION OF VCV.
!     INTEGER J
!        *
!     INTEGER MIT
!        *
!     INTEGER MOD
!        AN INDICATOR VALUE USED TO DESIGNATE THE MODEL FOR WHICH
!        THE PARAMETERS ARE TO BE SET.
!     INTEGER MSPEC(4,MXFAC)
!        THE VALUES OF P, D, Q AND S FOR EACH FACTOR.
!     INTEGER MXFAC
!        THE MAXIMUM NUMBER OF FACTORS ALLOWED.
!     INTEGER MXFC
!        THE MAXIMUM NUMBER OF FORECASTS ALLOWED.
!     INTEGER MXFCO
!        THE MAXIMUM NUMBER OF FORECASTS ORIGINS ALLOWED.
!     INTEGER MXN
!        THE MAXIMUM NUMBER OF OBSERVATIONS ALLOWED.
!     INTEGER MXPAR
!        THE MAXIMUM NUMBER OF PARAMETERS ALLOWED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFCST, NFCSTO
!        THE NUMBER OF FORECASTS AND FORCAST ORIGINS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!        TO BE PROVIDED.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
!     INTEGER NPRT
!        *
!     DOUBLE PRECISION PAR(MXPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION PV(MXN)
!        THE PREDICTED VALUES.
!     DOUBLE PRECISION RES(MXN)
!        THE RESIDUALS.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     DOUBLE PRECISION SCALE(MXPAR)
!        THE SCALE VALUES.
!     DOUBLE PRECISION SDPV(MXN)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(MXN)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION SQMEPS, STOPP, STOPSS
!        *
!     DOUBLE PRECISION STP(MXPAR)
!        THE STEP VALUES.
!     DOUBLE PRECISION VCV(MXPAR,MXPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!
      GO TO (10, 20, 30, 40, 50, 60), MOD
!
   10 CONTINUE
      N = 144
      NFAC = 2
      MSPEC(1,1) = 0
      MSPEC(2,1) = 1
      MSPEC(3,1) = 1
      MSPEC(4,1) = 1
      MSPEC(1,2) = 0
      MSPEC(2,2) = 1
      MSPEC(3,2) = 1
      MSPEC(4,2) = 12
      NPAR = 3
      PAR(1) = 0.0D0
      PAR(2) = 0.4D0
      PAR(3) = 0.6D0
      IFIXED(1) = 1
      IFIXED(2) = 0
      IFIXED(3) = 0
!
      GO TO 70
!
!
   20 PAR(1) = 1.0D0
      PAR(2) = 2.0D0
      PAR(3) = 3.0D0
!
      GO TO 70
!
!
   30 PAR(1) = 6.0D0
      PAR(2) = 5.0D0
      PAR(3) = 4.0D0
      PAR(4) = 3.0D0
      PAR(5) = 2.0D0
!
      GO TO 70
!
!
   40 CALL SETRV(PAR, NPAR, 0.0D0)
!
      GO TO 70
!
!
   50 CALL SETRV(PAR, NPAR, 0.5D0)
!
      GO TO 70
!
!
   60 PAR(1) = 100.0D0
      PAR(2) = 15.0D0
!
   70 CONTINUE
!
      SQMEPS = SQRT(RMDCON(3,typ=0.0_wp))
!
      MIT = 25
      DO 80 I=1,10
         STP(I) = SQMEPS
         SCALE(I) = 1.0D0
   80 CONTINUE
      STOPSS = 10.0D-7
      STOPP = 10.0D-7
      DELTA = 0.5D0
      NPRT = 11111
      IVAPRX = 3
      IVCV = MXPAR
!
      NFCST = 36
      NFCSTO = 2
      IFCSTO(1) = 103
      IFCSTO(2) = N
      IFCST = MXFC
!
      DO 85 I=1,MXN
         RES(I) = -1.0D0
         PV(I) = -1.0D0
         SDPV(I) = -1.0D0
         SDRES(I) = -1.0D0
   85 CONTINUE
!
      DO 100 I=1,MXPAR
         DO 90 J=1,MXPAR
            VCV(I,J) = -1.0D0
   90    CONTINUE
  100 CONTINUE
!
      DO 110 I = 1, MXFC
        FCSTSD(I) = -1.0D0
        DO 105 J = 1, MXFCO
          FCST(I,J) = -1.0D0
  105   CONTINUE
  110 CONTINUE
!
      NPARE = -1
      RSD = -1.0D0
!
      IERR = -1
!
      RETURN
!
      END
!STAT2W
      SUBROUTINE STAT2W(Y, WT, N, NNZW, STS, SUMDA, SUMDI, SUMWD2,
     +   SUMD2, SUMD3, SUMD4, SUMW)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES FOR A VECTOR Y THE STATISTICS THAT DO
!     NOT REQUIRE SORTING OF THE VECTOR, THAT IS, THOSE NOT COMPUTED
!     BY STAT1W.  WEIGHTS ARE USED IN THE CALCULATIONS.
!
!     THIS SUBROUTINE IS BASED ON A MODIFICATION OF THE STATIS
!     CODE USED IN OMNITAB, VERSION 5 (6/16/72), WRITTEN BY
!     SALLY PEAVY.  THE ORIGINAL ADAPTATION TO STARPAC WAS
!     DONE BY JANET DONALDSON.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SUMD2,SUMD3,SUMD4,SUMDA,SUMDI,SUMW,SUMWD2
      INTEGER
     +   N,NNZW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   STS(53),WT(N),Y(N)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DIF,T,TA,TK1,TK2
      INTEGER
     +   I,IC,ICI,ICOUNT,IDRUNS,IMINUS,IPLUS,IRUN,J
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFF,PPFCHS,PPFT
      EXTERNAL CDFF,PPFCHS,PPFT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,SQRT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DIF
!        THE SUM OF THE DIFFERENCES BETWEEN SUCCEEDING ELEMENTS
!        IN Y.
!     INTEGER I
!        A LOOP INDEX.
!     INTEGER IC
!        PREVIOUS SIGN IN RUNS CALCULATION.
!     INTEGER ICI
!        CURRENT SIGN IN RUNS CALCULATION.
!     INTEGER ICOUNT
!        USED IN RUNS CALCULATIONS.
!     INTEGER IDRUNS
!        THE NUMBER OF RUNS.
!     INTEGER IERR
!        AN ERROR FLAG SET IN COMMON ERRCHK.
!     INTEGER IMINUS, IPLUS
!        COUNTS OF SIGNS OF DEVIATIONS.
!     INTEGER IRUN
!        THE NUMBER OF RUNS UP AND DOWN.
!     INTEGER J
!        A LOOP INDEX.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y AND WT.
!     INTEGER NNZW
!        INPUT PARAMETER.  THE NUMBER OF POSITIVE ELEMENTS IN WT.
!     DOUBLE PRECISION STS(53)
!        OUTPUT PARAMETER.  THE VECTOR OF 53 STATISTICS COMPUTED.
!     ROW STATISTIC                    ROW STATISTIC
!         1  LENGTH OF VECTOR             TESTS FOR NONRANDOMNESS
!         2  NUMBER OF NONZERO WEIGHTS    23  NUMBER OF RUNS UP AND DOWN
!        MEASURES OF LOCATION             24  EXPECTED NUMBER OF RUNS
!         3  UNWEIGHTED MEAN              25  S.D. OF NUMBER OF RUNS
!         4  WEIGHTED MEAN                26  MEAN SQR. SUCCESSIVE DIFF.
!         5  MEDIAN                       27  MEAN SQR. SUCC. DIFF./VAR.
!         6  MID-RANGE                    DEVIATIONS FROM WTD MEAN
!         7  25 P.C. UNWTD. TRIMMED MEAN  28  NUMBER OF + SIGNS
!         8  25 P.C. WTD. TRIMMED MEAN    29  NUMBER OF - SIGNS
!        MEASURES OF DISPERSION           30  NUMBER OF RUNS
!         9  STANDARD DEVIATION (S.D.)    31  EXPECTED NUMBER OF RUNS
!        10  S.D. OF MEAN                 32  S.D. OF RUNS
!        11  RANGE                        33  DIFF./S.D. OF RUNS
!        12  MEAN VARIATION               OTHER STATISTICS
!        13  VARIANCE (VAR.)              34  MINIMUM
!        14  COEFFICIENT OF VARIATION     35  MAXIMUM
!        CONFIDENCE INTERVALS             36  BETA 1
!        15  LOWER CONFIDENCE LIMIT, MEAN 37  BETA 2
!        16  UPPER CONFIDENCE LIMIT, MEAN 38  WTD. SUM OF VALUES
!        17  LOWER CONFIDENCE LIMIT, S.D. 39  WTD. SUM OF SQUARES
!        18  UPPER CONFIDENCE LIMIT, S.D. 40  WTD. SUM OF SQRD. DEVS.
!        LINEAR TREND STATISTICS          41  STUDENTS T
!        19  SLOPE                        42  WTD. SUM OF ABS. VALUES
!        20  S.D. OF SLOPE                43  WTD. AVG. ABS. VALUES
!        21  SLOPE/S.D. OF SLOPE = T      44-53 FREQ. DISTRIBUTION
!        22  PROB ( X .GT. ABS(OBS. T))
!     DOUBLE PRECISION SUMDA
!        INPUT PARAMETER.  THE SUM OF THE ABSOLUTE VALUES OF THE
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION SUMDI
!        INPUT PARAMETER.  THE SUM OF THE PRODUCTS OF I AND THE
!        ITH DIFFERENCE DIFF.
!     DOUBLE PRECISION SUMD2
!        INPUT PARAMETER.  THE SUM OF THE SQUARES OF THE
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION SUMD3
!        INPUT PARAMETER.  THE SUM OF THE CUBES OF THE
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION SUMD4
!        INPUT PARAMETER.  THE SUM OF THE HYPERCUBES OF THE
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION SUMW
!        INPUT PARAMETER.  THE SUM OF THE WEIGHTS VECTOR WT.
!     DOUBLE PRECISION SUMWD2
!        INPUT PARAMETER.  THE WEIGHTED SUM OF THE SQUARED
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION T
!        A RESIDUAL (Y(I) - MEANY)
!     DOUBLE PRECISION TA
!        A TEMPORARY VARIABLE IN THE RUNS CALCULATION.
!     DOUBLE PRECISION TK1, TK2
!        CHI-SQUARED VALUES.
!     DOUBLE PRECISION WT(N)
!        INPUT PARAMETER.  THE VECTOR OF WEIGHTS FOR THE
!        Y OBSERVATIONS.
!     DOUBLE PRECISION Y(N)
!        INPUT PARAMETER.  A SET OF N DATA POINTS, SORTED
!        INTO ASCENDING ORDER.
!
!
!     BEGIN STORAGE OF STATISTICS.
!
      STS(1) = N
      STS(2) = NNZW
      STS(24) = (2.0D0*STS(2)-1.0D0)/3.0D0
      STS(25) = SQRT((16.0D0*STS(2)-29.0D0)/90.0D0)
      STS(43) = STS(42)/SUMW
!
!     COMPUTE RESIDUALS AND STANDARD DEVIATIONS.
!
      ICI = 0
      IPLUS = 0
      IMINUS = 0
      IDRUNS = 0
      IC = 0
      DO 30 I=1,N
         IF (WT(I).LE.0.0D0) GO TO 30
         T = Y(I) - STS(4)
         IF (T.LT.0.0D0) GO TO 10
         IPLUS = IPLUS + 1
         ICI = 1
         GO TO 20
   10    IMINUS = IMINUS + 1
         ICI = -1
   20    IF (IC.EQ.ICI) GO TO 30
         IC = ICI
         IDRUNS = IDRUNS + 1
   30 CONTINUE
      STS(28) = IPLUS
      STS(29) = IMINUS
      STS(31) = 1.0D0 + (2.0D0*STS(28)*STS(29)/STS(2))
      STS(32) =
     +   SQRT((2.0D0*STS(28)*STS(29)*(2.0D0*STS(28)*STS(29)-
     +                                     STS(28)-STS(29)))/
     +        ((STS(28)+STS(29))**2*(STS(2)-1.0D0)))
      STS(30) = IDRUNS
      STS(33) = 0.0D0
      IF (STS(32).NE.0.0D0)
     +   STS(33) = (STS(30)-STS(31))/STS(32)
      STS(13) = SUMWD2/(STS(2)-1.0D0)
      STS(9) = SQRT(STS(13))
      STS(10) = STS(9)/(SQRT(SUMW))
      IF (STS(4).NE.0.0D0)
     +   STS(14) = 100.0D0*ABS(STS(9)/STS(4))
      IF (STS(4).EQ.0.0D0) STS(14) = 0.0D0
      STS(36) = 0.0D0
      IF (SUMD2.NE.0.0D0)
     +   STS(36) = (SUMD3/STS(2))**2/((SUMD2/STS(2))**3)
      STS(37) = 0.0D0
      IF (SUMD2.NE.0.0D0)
     +   STS(37) = (SUMD4/STS(2))/((SUMD2/STS(2))**2)
      STS(40) = SUMWD2
      STS(19) = (12.0D0*SUMDI)/(STS(2)*(STS(2)**2-1.0D0))
      STS(20) = (1.0D0/(STS(2)-2.0D0)*
     +             (12.0D0*(SUMD2/(STS(2)*(STS(2)**2-1.0D0)))-
     +              STS(19)**2))
      IF (STS(20).LE.0.0D0) STS(20) = 0.0D0
      STS(20) = SQRT(STS(20))
      IF (STS(20).EQ.0.0D0) STS(21) = 0.0D0
      IF (STS(20).GT.0.0D0) STS(21) = STS(19)/STS(20)
!
      STS(22) = 1.0D0 - CDFF(STS(21)*STS(21), 1.0D0, STS(2)-2.0D0)
!
!     COMPUTE NUMBER OF RUNS IN THE DATA.
!
      DIF = 0.0D0
      IRUN = 1
      TA = 0.0D0
      DO 50 I=1,N
         IF (I.GE.N) GO TO 60
         IF (WT(I).LE.0.0D0) GO TO 50
         J = I
   40    J = J + 1
         IF (J.GE.N) GO TO 60
         IF (WT(J).LE.0.0D0) GO TO 40
         TA = Y(J) - Y(I)
         IF (TA.NE.0.0D0) GO TO 60
   50 CONTINUE
   60 ICOUNT = 0
      DO 80 I=1,N
         IF (WT(I).LE.0.0D0) GO TO 80
         ICOUNT = ICOUNT + 1
         IF (ICOUNT.GE.NNZW) GO TO 80
         J = I
   70    J = J + 1
         IF (WT(J).LE.0.0D0) GO TO 70
         T = Y(J) - Y(I)
         DIF = DIF + T*T
         IF (TA*T.GE.0.0D0) GO TO 80
         TA = T
         IRUN = IRUN + 1
   80 CONTINUE
      STS(23) = IRUN
      STS(26) = DIF/(STS(2)-1.0D0)
      STS(27) = 0.0D0
      IF (STS(13).NE.0.0D0)
     +   STS(27) = STS(26)/STS(13)
      STS(41) = 0.0D0
      IF (STS(9).NE.0.0D0)
     +   STS(41) = (STS(4)*SQRT(SUMW))/STS(9)
      STS(12) = SUMDA/STS(2)
      T = PPFT(0.975D0, NNZW-1)
      TK1 = PPFCHS(0.975D0, NNZW-1)
      TK2 = PPFCHS(0.025D0, NNZW-1)
      STS(15) = STS(4) - T*STS(10)
      STS(16) = STS(4) + T*STS(10)
      STS(17) = SQRT((STS(2)-1.0D0)/TK1)*STS(9)
      STS(18) = SQRT((STS(2)-1.0D0)/TK2)*STS(9)
      RETURN
      END
!XDFLT
      SUBROUTINE XDFLT(LDS,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE TIME SERIES DIGITAL FILTERING AND
!     COMPLEX DEMODULATION ROUTINES.
!
!     SERIES Y IS THE WOLF SUNSPOT DATA FROM 1700 TO 1960 AS
!     TABULATED BY WALDMEIER
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDS
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FC,FMAX,FMIN,YFMISS,YMISS
      INTEGER
     +   I,IAR,IPRT,ITEST,K,LDSTAK,LPHI,N,NF,NFAC,NPRT,NYF,NYS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FREQ(101),GAIN(101),HHP(50),HLP(50),PHAS(300),PHI(50),Y(300),
     +   YF(300),YS(300)
      INTEGER
     +   IOD(10),ND(10)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ARFLT,DIF,DIFC,DIFM,DIFMC,GFARF,GFARFS,GFSLF,GFSLFS,
     +   HIPASS,HPCOEF,IPRINT,LOPASS,LPCOEF,MAFLT,SAMPLE,SLFLT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FC
!        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MINIMUM AND MAXIMUM FREQUENCY FOR WHICH THE GAIN
!        FUNCTION IS TO BE ESTIMATED.
!     DOUBLE PRECISION FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        HAS BEEN ESTIMATED.
!     DOUBLE PRECISION GAIN(101)
!        THE VECTOR IN WHICH THE GAIN FUNCTION ESTIMATES ARE
!        STORED.
!     DOUBLE PRECISION HHP(50)
!        THE ARRAY IN WHICH THE -IDEAL- HIGH PASS FILTER COEFFICIENTS
!        WILL BE RETURNED.
!     DOUBLE PRECISION HLP(50)
!        THE ARRAY IN WHICH THE INPUT LOW PASS FILTER COEFFICIENTS
!        ARE STORED.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IOD(10)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER ITEST
!        THE NUMBER OF THE TEST BEING PERFORMED
!     INTEGER K
!        THE NUMBER OF TERMS IN THE SYMETRIC LINEAR FILTER.
!     INTEGER LDS, LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE INPUT SERIES.
!     INTEGER ND(10)
!        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE
!        FACTORS ARE TO BE APPLIED.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        IS TO BE ESTIMATED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT = 1 THE PLOT IS DECIBELS/LINEAR
!        NPRT = 2 THE PLOT IS LOG/LINEAR
!     INTEGER NYF
!        THE NUMBER OF VALUES IN THE FILTERED SERIES.
!     INTEGER NYS
!        THE NUMBER OF VALUES IN THE SAMPLED SERIES.
!     DOUBLE PRECISION PHAS(300)
!        THE ARRAY IN WHICH THE PRIMARY PHASE ESTIMATES ARE RETURNED.
!     DOUBLE PRECISION PHI(50)
!        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
!     DOUBLE PRECISION Y(300)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YF(300)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!     DOUBLE PRECISION YFMISS
!        THE MISSING VALUE CODE USED IN THE FILTERED SERIES.
!     DOUBLE PRECISION YMISS
!        THE MISSING VALUE CODE USED IN THE INPUT TIME SERIES.
!     DOUBLE PRECISION YS(300)
!        THE ARRAY CONTAINING THE SAMPLED SERIES.
!
      DATA   Y(  1),  Y(  2),  Y(  3),  Y(  4),  Y(  5),  Y(  6)
     +    /     5.0D0, 11.0D0, 16.0D0, 23.0D0, 36.0D0, 58.0D0/
      DATA   Y(  7),  Y(  8),  Y(  9),  Y( 10),  Y( 11),  Y( 12)
     +    /    29.0D0, 20.0D0, 10.0D0,  8.0D0,  3.0D0,  0.0D0/
      DATA   Y( 13),  Y( 14),  Y( 15),  Y( 16),  Y( 17),  Y( 18)
     +    /     0.0D0, 2.0D0, 11.0D0, 27.0D0, 47.0D0, 63.0D0/
      DATA   Y( 19),  Y( 20),  Y( 21),  Y( 22),  Y( 23),  Y( 24)
     +    /    60.0D0, 39.0D0, 28.0D0, 26.0D0, 22.0D0, 11.0D0/
      DATA   Y( 25),  Y( 26),  Y( 27),  Y( 28),  Y( 29),  Y( 30)
     +    /    21.0D0, 40.0D0, 78.0D0,122.0D0,103.0D0, 73.0D0/
      DATA   Y( 31),  Y( 32),  Y( 33),  Y( 34),  Y( 35),  Y( 36)
     +    /    47.0D0, 35.0D0, 11.0D0,  5.0D0, 16.0D0, 34.0D0/
      DATA   Y( 37),  Y( 38),  Y( 39),  Y( 40),  Y( 41),  Y( 42)
     +    /    70.0D0, 81.0D0,111.0D0,101.0D0, 73.0D0, 40.0D0/
      DATA   Y( 43),  Y( 44),  Y( 45),  Y( 46),  Y( 47),  Y( 48)
     +    /    20.0D0, 16.0D0,  5.0D0, 11.0D0, 22.0D0, 40.0D0/
      DATA   Y( 49),  Y( 50),  Y( 51),  Y( 52),  Y( 53),  Y( 54)
     +    /    60.0D0, 80.9D0, 83.4D0, 47.7D0, 47.8D0, 30.7D0/
      DATA   Y( 55),  Y( 56),  Y( 57),  Y( 58),  Y( 59),  Y( 60)
     +    /    12.2D0,  9.6D0, 10.2D0, 32.4D0, 47.6D0, 54.0D0/
      DATA   Y( 61),  Y( 62),  Y( 63),  Y( 64),  Y( 65),  Y( 66)
     +    /    62.9D0, 85.9D0, 61.2D0, 45.1D0, 36.4D0, 20.9D0/
      DATA   Y( 67),  Y( 68),  Y( 69),  Y( 70),  Y( 71),  Y( 72)
     +    /    11.4D0, 37.8D0, 69.8D0,106.1D0,100.8D0, 81.6D0/
      DATA   Y( 73),  Y( 74),  Y( 75),  Y( 76),  Y( 77),  Y( 78)
     +    /    66.5D0, 34.8D0, 30.6D0,  7.0D0, 19.8D0, 92.5D0/
      DATA   Y( 79),  Y( 80),  Y( 81),  Y( 82),  Y( 83),  Y( 84)
     +    /   154.4D0,125.9D0, 84.8D0, 68.1D0, 38.5D0, 22.8D0/
      DATA   Y( 85),  Y( 86),  Y( 87),  Y( 88),  Y( 89),  Y( 90)
     +    /    10.2D0, 24.1D0, 82.9D0,132.0D0,130.9D0,118.1D0/
      DATA   Y( 91),  Y( 92),  Y( 93),  Y( 94),  Y( 95),  Y( 96)
     +    /    89.9D0, 66.6D0, 60.0D0, 46.9D0, 41.0D0, 21.3D0/
      DATA   Y( 97),  Y( 98),  Y( 99),  Y(100),  Y(101),  Y(102)
     +    /    16.0D0,  6.4D0,  4.1D0,  6.8D0, 14.5D0, 34.0D0/
      DATA   Y(103),  Y(104),  Y(105),  Y(106),  Y(107),  Y(108)
     +    /    45.0D0, 43.1D0, 47.5D0, 42.2D0, 28.1D0, 10.1D0/
      DATA   Y(109),  Y(110),  Y(111),  Y(112),  Y(113),  Y(114)
     +    /     8.1D0,  2.5D0,  0.0D0,  1.4D0,  5.0D0, 12.2D0/
      DATA   Y(115),  Y(116),  Y(117),  Y(118),  Y(119),  Y(120)
     +    /    13.9D0, 35.4D0, 45.8D0, 41.1D0, 30.1D0, 23.9D0/
      DATA   Y(121),  Y(122),  Y(123),  Y(124),  Y(125),  Y(126)
     +    /    15.6D0,  6.6D0,  4.0D0,  1.8D0,  8.5D0, 16.6D0/
      DATA   Y(127),  Y(128),  Y(129),  Y(130),  Y(131),  Y(132)
     +    /    36.3D0, 49.6D0, 64.2D0, 67.0D0, 70.9D0, 47.8D0/
      DATA   Y(133),  Y(134),  Y(135),  Y(136),  Y(137),  Y(138)
     +    /    27.5D0,  8.5D0, 13.2D0, 56.9D0,121.5D0,138.3D0/
      DATA   Y(139),  Y(140),  Y(141),  Y(142),  Y(143),  Y(144)
     +    /   103.2D0, 85.7D0, 64.6D0, 36.7D0, 24.2D0, 10.7D0/
      DATA   Y(145),  Y(146),  Y(147),  Y(148),  Y(149),  Y(150)
     +    /    15.0D0, 40.1D0, 61.5D0, 98.5D0,124.7D0, 96.3D0/
      DATA   Y(151),  Y(152),  Y(153),  Y(154),  Y(155),  Y(156)
     +    /    66.6D0, 64.5D0, 54.1D0, 39.0D0, 20.6D0,  6.7D0/
      DATA   Y(157),  Y(158),  Y(159),  Y(160),  Y(161),  Y(162)
     +    /     4.3D0, 22.7D0, 54.8D0, 93.8D0, 95.8D0, 77.2D0/
      DATA   Y(163),  Y(164),  Y(165),  Y(166),  Y(167),  Y(168)
     +    /    59.1D0, 44.0D0, 47.0D0, 30.5D0, 16.3D0,  7.3D0/
      DATA   Y(169),  Y(170),  Y(171),  Y(172),  Y(173),  Y(174)
     +    /    37.6D0, 74.0D0,139.0D0,111.2D0,101.6D0, 66.2D0/
      DATA   Y(175),  Y(176),  Y(177),  Y(178),  Y(179),  Y(180)
     +    /    44.7D0, 17.0D0, 11.3D0, 12.4D0,  3.4D0,  6.0D0/
      DATA   Y(181),  Y(182),  Y(183),  Y(184),  Y(185),  Y(186)
     +    /    32.3D0, 54.3D0, 59.7D0, 63.7D0, 63.5D0, 52.2D0/
      DATA   Y(187),  Y(188),  Y(189),  Y(190),  Y(191),  Y(192)
     +    /    25.4D0, 13.1D0,  6.8D0,  6.3D0,  7.1D0, 35.6D0/
      DATA   Y(193),  Y(194),  Y(195),  Y(196),  Y(197),  Y(198)
     +    /    73.0D0, 85.1D0, 78.0D0, 64.0D0, 41.8D0, 26.2D0/
      DATA   Y(199),  Y(200),  Y(201),  Y(202),  Y(203),  Y(204)
     +    /    26.7D0, 12.1D0,  9.5D0,  2.7D0,  5.0D0, 24.4D0/
      DATA   Y(205),  Y(206),  Y(207),  Y(208),  Y(209),  Y(210)
     +    /    42.0D0, 63.5D0, 53.8D0, 62.0D0, 48.5D0, 43.9D0/
      DATA   Y(211),  Y(212),  Y(213),  Y(214),  Y(215),  Y(216)
     +    /    18.6D0,  5.7D0,  3.6D0,  1.4D0,  9.6D0, 47.4D0/
      DATA   Y(217),  Y(218),  Y(219),  Y(220),  Y(221),  Y(222)
     +    /    57.1D0,103.9D0, 80.6D0, 63.6D0, 37.6D0, 26.1D0/
      DATA   Y(223),  Y(224),  Y(225),  Y(226),  Y(227),  Y(228)
     +    /    14.2D0,  5.8D0, 16.7D0, 44.3D0, 63.9D0, 69.0D0/
      DATA   Y(229),  Y(230),  Y(231),  Y(232),  Y(233),  Y(234)
     +    /    77.8D0, 64.9D0, 35.7D0, 21.2D0, 11.1D0,  5.7D0/
      DATA   Y(235),  Y(236),  Y(237),  Y(238),  Y(239),  Y(240)
     +    /     8.7D0, 36.1D0, 79.7D0,114.4D0,109.6D0, 88.8D0/
      DATA   Y(241),  Y(242),  Y(243),  Y(244),  Y(245),  Y(246)
     +    /    67.8D0, 47.5D0, 30.6D0, 16.3D0,  9.6D0, 33.2D0/
      DATA   Y(247),  Y(248),  Y(249),  Y(250),  Y(251),  Y(252)
     +    /    92.6D0,151.6D0,136.3D0,134.7D0, 83.9D0, 69.4D0/
      DATA   Y(253),  Y(254),  Y(255),  Y(256),  Y(257),  Y(258)
     +    /    31.5D0, 13.9D0,  4.4D0, 38.0D0,141.7D0,190.2D0/
      DATA   Y(259),  Y(260),  Y(261)
     +    /   184.8D0,159.0D0,112.3D0/
!
      CALL IPRINT(IPRT)
      ITEST = 1
      LDSTAK = LDS
!
      N = 261
      NPRT = 2
      FC = 1.0D0/22.0D0
      NF = 101
      FMIN = 0.0D0
      FMAX = 0.2D0
      LPHI = 50
      NFAC = 1
      ND(1) = 1
      IOD(1) = 1
      IAR = 1
      PHI(1) = 0.6D0
      K = 41
      YMISS = 11.0D0
!
!     TEST OF LPCOEF
!
   10 WRITE (IPRT, 1001)
      CALL LPCOEF (FC, K, HLP)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM LPCOEF
!
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (HLP(I), I = 1, K)
!
!     TEST OF LOPASS
!
      WRITE (IPRT, 1007)
      CALL LOPASS (Y, N, FC, K, HLP, YF, NYF)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM LOPASS
!
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (HLP(I), I = 1, K)
        WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
      END IF
!
!     TEST OF HIPASS
!
      WRITE (IPRT, 1008)
      CALL HIPASS (Y, N, FC, K, HHP, YF, NYF)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM HIPASS
!
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (HHP(I), I = 1, K)
        WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
      END IF
!
!     TEST OF HPCOEF
!
   20 WRITE (IPRT, 1003)
      CALL HPCOEF (HLP, K, HHP)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM HPCOEF
!
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (HHP(I), I = 1, K)
!
!     TEST OF MAFLT
!
      WRITE (IPRT, 1020)
      CALL MAFLT (Y, N, K, YF, NYF)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM MAFLT
!
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
!
!     TEST OF SLFLT
!
      WRITE (IPRT, 1005)
      CALL SLFLT (Y, N, K, HLP, YF, NYF)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM SLFLT
!
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
!
!     TEST OF SAMPLE
!
      WRITE (IPRT, 1006)
      CALL SAMPLE (YF, N, K, YS, NYS)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM SAMPLE
!
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (YF(I), I = 1, NYS)
!
!     TEST OF ARFLT
!
      WRITE (IPRT, 1009)
      CALL ARFLT (Y, N,  IAR, PHI, YF, NYF)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM ARFLT
!
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
!
!     TEST OF DIF
!
      WRITE (IPRT, 1015)
      CALL DIF (Y, N, YF, NYF)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM DIF
!
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
!
!     TEST OF DIFM
!
      WRITE (IPRT, 1018)
      CALL DIFM (Y, YMISS, N, YF, YFMISS, NYF)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM DIFM
!
      IF (IERR.EQ.0) THEN
         WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
         WRITE (IPRT, 1004) YFMISS
      END IF
!
!     TEST OF GFSLF
!
      WRITE (IPRT, 1011)
      CALL GFSLF (HLP, K)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF GFARF
!
      WRITE (IPRT, 1013)
      CALL GFARF (PHI, IAR)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF DIFC
!
   30 WRITE (IPRT, 1010)
      CALL DIFC (Y, N, NFAC, ND, IOD, IAR, PHI, LPHI, YF, NYF, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM DIFC
!
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (PHI(I), I = 1, K)
        WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
      END IF
!
!     TEST OF DIFMC
!
      WRITE (IPRT, 1019)
      CALL DIFMC (Y, YMISS, N, NFAC, ND, IOD, IAR, PHI, LPHI, YF,
     +   YFMISS, NYF, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM DIFMC
!
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (PHI(I), I = 1, K)
        WRITE (IPRT, 1004) (YF(I), I = 1, NYF)
        WRITE (IPRT, 1004) YFMISS
      END IF
!
!     TEST OF GFSLFS
!
      WRITE (IPRT, 1012)
      CALL GFSLFS (HLP, K, NF, FMIN, FMAX, GAIN, FREQ, NPRT, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM GFSLFS
!
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (GAIN(I), I = 1, NF)
        WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
      END IF
!
!     TEST OF GFARFS
!
      WRITE (IPRT, 1014)
      CALL GFARFS (PHI, IAR, NF, FMIN, FMAX, GAIN, PHAS, FREQ, NPRT,
     +   LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM GFARFS
!
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (GAIN(I), I = 1, NF)
        WRITE (IPRT, 1004) (PHAS(I), I = 1, NF)
        WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
      END IF
!
      GO TO (100, 200, 300, 400), ITEST
!
!     TEST SPECIAL CASES
!
  100 ITEST = ITEST + 1
!
!     TEST OF GFSLFS
!
      FMIN = 0.4D0
      FMAX = 0.1D0
      NPRT = 1
      WRITE (IPRT, 1012)
      CALL GFSLFS (HLP, K, NF, FMIN, FMAX, GAIN, FREQ, NPRT, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM GFSLFS
!
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (GAIN(I), I = 1, NF)
        WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
      END IF
!
!     TEST OF GFARFS
!
      NPRT = -1
      WRITE (IPRT, 1014)
      CALL GFARFS (PHI, IAR, NF, FMIN, FMAX, GAIN, PHAS, FREQ, NPRT,
     +   LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM GFARFS
!
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (GAIN(I), I = 1, NF)
        WRITE (IPRT, 1004) (PHAS(I), I = 1, NF)
        WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
      END IF
!
!     TEST MINIMUM PROBLEM SIZE
!
      N = 3
      K = 1
      NPRT = -1
      IAR = 1
      NF = 1
      GO TO 20
!
!     TEST ERROR CONDITIONS
!
  200 ITEST = ITEST + 1
      N = -5
      FC = 1.0D0
      NF = 0
      LPHI = 0
      NFAC = 1
      ND(1) = -1
      IOD(1) = -1
      IAR = 0
      K = -1
      GO TO 10
!
!     TEST LDSTAK
!
  300 ITEST = ITEST + 1
      N = 261
      NPRT = 2
      FC = 1.0D0/22.0D0
      NF = 101
      FMIN = 0.0D0
      FMAX = 0.2D0
      LPHI = 50
      NFAC = 1
      ND(1) = 1
      IOD(1) = 1
      IAR = 1
      PHI(1) = 0.6D0
      K = 41
      YMISS = 11.0D0
      LDSTAK = 0
      GO TO 30
!
  400 RETURN
!
!     FORMAT STATEMENTS
!
 1001 FORMAT ('1', 14HTEST OF LPCOEF)
 1002 FORMAT (/' IERR IS ', I5)
 1003 FORMAT ('1', 14HTEST OF HPCOEF)
 1004 FORMAT (10E10.3)
 1005 FORMAT ('1', 13HTEST OF SLFLT)
 1006 FORMAT ('1', 14HTEST OF SAMPLE)
 1007 FORMAT ('1', 14HTEST OF LOPASS)
 1008 FORMAT ('1', 14HTEST OF HIPASS)
 1009 FORMAT ('1', 13HTEST OF ARFLT)
 1010 FORMAT ('1', 12HTEST OF DIFC)
 1011 FORMAT ('1', 13HTEST OF GFSLF)
 1012 FORMAT ('1', 14HTEST OF GFSLFS)
 1013 FORMAT ('1', 13HTEST OF GFARF)
 1014 FORMAT ('1', 14HTEST OF GFARFS)
 1015 FORMAT ('1', 11HTEST OF DIF)
 1018 FORMAT ('1', 12HTEST OF DIFM)
 1019 FORMAT ('1', 13HTEST OF DIFMC)
 1020 FORMAT ('1', 13HTEST OF MAFLT)
!
      END
!AMFCNT
      SUBROUTINE AMFCNT(Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK,
     +   NFCST, NFCSTO, IFCSTO, NPRT, FCST, IFCST, FCSTSD, NMSUB, SAVE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR FORECASTING USING
!     ARIMA MODELS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IFCST,LDSTAK,N,NFAC,NFCST,NFCSTO,NPAR,NPRT
      LOGICAL
     +   SAVE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FCST(*),FCSTSD(*),PAR(*),Y(*)
      INTEGER
     +   IFCSTO(*),MSPEC(4,*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR,IFLAG,MBO,MBOL,MSPECT,NFACT,NPARAR,NPARDF,NPARMA,
     +   NRESTS,PARAR,PARDF,PARMA,T,TEMP
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   F,FSD,IFP,IS,LDSMIN,NALL0,PV
      LOGICAL
     +   PAGE,WIDE
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMFER,AMFMN,BACKOP,CPYVII,LDSCMP,STKCLR,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
      COMMON /MDLTSC/MSPECT,NFACT,PARDF,NPARDF,PARAR,NPARAR,PARMA,
     +   NPARMA,MBO,MBOL,T,TEMP,NRESTS,IFLAG
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER F
!        THE STARTING LOCATION IN THE WORK VECTOR FOR
!        THE FORECASTS.
!     DOUBLE PRECISION FCST(IFCST,NFCSTO)
!        THE STORAGE ARRAY FOR THE FORECASTS.
!     DOUBLE PRECISION FCSTSD(NFCST)
!        THE STORAGE ARRAY FOR THE STANDARD DEVIATIONS OF THE FORECASTS.
!     INTEGER FSD
!        THE STARTING LOCATION IN THE WORK VECTOR FOR
!        THE STANDARD DEVIATIONS OF THE FORECASTS.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFCST
!        THE FIRST DIMENSION OF THE ARRAY FCST.
!     INTEGER IFCSTO(NFCSTO)
!        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
!     INTEGER IFP
!        AN INDICATOR FOR THE PRECISION OF THE STACK ALLOCATION TYPE,
!        WHERE IFP=3 INDICATES SINGLE AND IFP=4 INDICATES DOUBLE.
!     INTEGER IS
!        A VALUE USED TO DETERMINE THE AMOUNT OF WORK SPACE NEEDED
!        BASED ON WHETHER STEP SIZES ARE INPUT OR ARE TO BE CALCULATED.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBOL
!        THE MAXIMUM BACK ORDER ON THE LEFT
!     INTEGER MSPEC(4,NFAC)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER MSPECT
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        NUMBER OF STACK ALLOCATIONS OUTSTANDING.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFACT
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFCST
!        THE NUMBER OF FORECASTS.
!     INTEGER NFCSTO
!        THE NUMBER OF THE ORIGINS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARAR
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE AUTOREGRESSIVE PARAMETERS
!     INTEGER PARDF
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
!     INTEGER PARMA
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE MOVING AVERAGE PARAMETERS
!     INTEGER PV
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE PREDICTED VALUES
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     INTEGER T
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR.
!     INTEGER TEMP
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!     SET VARIOUS PROGRAM VALUES
!
      WIDE = .TRUE.
      PAGE = .FALSE.
!
!     COMPUTE BACK OPERATORS
!
      CALL BACKOP(MSPEC, NFAC, NPARDF, MBOL, MBO, NPARMA, NPARAR)
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      IS = 0
!
      CALL LDSCMP(8, 0, 4*NFAC,
     +   0, 0, 0, 'D', 5*MBO + 2*NFCST + N + MBO + 101, LDSMIN)
!
      CALL AMFER(NMSUB, N, NPAR, LDSTAK, LDSMIN, SAVE, MSPEC, NFAC,
     +   IFCST, NFCST)
!
      IF (IERR.EQ.0) THEN
!
        CALL STKSET(LDSTAK, 4)
!
!       SUBDIVIDE WORKSPACE FOR STEP SIZES
!
        NALL0 = STKST(1)
!
        IFP = 4
!
        PARDF = STKGET(MBO, IFP)
        PARAR = STKGET(MBO, IFP)
        PARMA = STKGET(MBO, IFP)
        T = STKGET(2*MBO, IFP)
!
        TEMP = T + MBO
!
        NFACT = NFAC
        MSPECT = STKGET(4*NFAC, 2)
        F = STKGET(NFCST, IFP)
        FSD = STKGET(NFCST, IFP)
!
!       SET UP FOR MODEL
!
        NRESTS = MBO + 101 + N
        PV = STKGET(NRESTS, IFP)
!
        CALL CPYVII(NFAC, MSPEC(1,1), 4, ISTAK(MSPECT), 1)
        CALL CPYVII(NFAC, MSPEC(2,1), 4, ISTAK(MSPECT+NFAC), 1)
        CALL CPYVII(NFAC, MSPEC(3,1), 4, ISTAK(MSPECT+2*NFAC), 1)
        CALL CPYVII(NFAC, MSPEC(4,1), 4, ISTAK(MSPECT+3*NFAC), 1)
!
!       CALL MAIN ROUTINE FOR COMPUTING AND PRINTING FORECASTS
!
        CALL AMFMN (PAR, RSTAK(PV), Y, NPAR, N, NFAC, ISTAK(MSPECT),
     +    RSTAK(PARDF), NPARDF, RSTAK(T), RSTAK(TEMP), RSTAK(PARAR),
     +    RSTAK(PARMA), MBO, MBOL, N-NRESTS+1, N, NPRT, SAVE,
     +    NFCST, NFCSTO, IFCSTO, FCST, IFCST, FCSTSD, RSTAK(F),
     +    RSTAK(FSD), NPARAR, NPARMA)
      END IF
!
      CALL STKCLR(NALL0)
!
      RETURN
!
      END
!MPPM
      SUBROUTINE MPPM(YM, YMMISS, X, XMISS, N, M, IYM)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH MULTIPLE Y-AXIS VALUES AND WITH MISSING
!     OBSERVATIONS (SHORT CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   IYM,M,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   ILOG,IPRT,ISCHCK,ISIZE,LISYM,NOUT
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(IYM,M)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(M)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'P',       'P',       'M',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      MULTI = .TRUE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 2
      ISIZE = -1
      NOUT = 0
      MISS = .TRUE.
      LISYM = 1
!
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL MPPM (YM, YMMISS, X, XMISS, N, M, IYM)')
      END
!ERVGTM
      SUBROUTINE ERVGTM (NMSUB, NMVAR, VEC, VCMISS, N, VECLB, NVMX,
     +   HEAD, MSGTYP, NV, ERROR, NMMIN)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS TO ENSURE THAT NO VALUES, OR ONLY A MAXIMUM
!     OF NVMX, ARE NOT GREATER THAN A SPECIFIED LOWER BOUND VECLB,
!     WITH NAME NMMIN. THE ROUTINE ALTERNATIVELY CHECKS TO MAKE SURE
!     THAT NO VALUES ARE IN VIOLATION OF THIS LOWER BOUND IF THE FIRST
!     VALUE IN THE VECTOR IS NOT.  THE CHECKING OPTION IS SPECIFIED
!     WITH MSGTYP.  IF AN ERROR IS FOUND, THE ERROR IS PRINTED AND
!     AN ERROR FLAG AND THE NUMBER OF VIOLATINS ARE RETURNED.
!     VALUES OF VEC EQUAL TO VCMISS ARE EXEMPTED FROM THE CHECKING.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VCMISS,VECLB
      INTEGER
     +   MSGTYP,N,NV,NVMX
      LOGICAL
     +   ERROR,HEAD
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VEC(*)
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
!
!  LOCAL SCALARS
      INTEGER
     +   I,NVMN
!
!  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ERVGTP
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MOD
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        THE VALUE RETURNED FROM THE ERROR CHECKING ROUTINES TO INDICATE
!        WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED (TRUE)
!        OR NOT (FALSE).
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER MSGTYP
!        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
!        IF (MSGTYP.GE.4) THE MESSAGE PRINTED WILL USE NMMIN
!        OTHERWISE IT WILL USE VECLB.
!        IF (MSGTYP = 1 OR 4) NO VIOLATIONS ARE ALLOWED.
!        IF (MSGTYP = 2 OR 5) THE NUMBER OF VIOLATIONS MUST
!                             BE LESS THAN   NVMX   .
!        IF (MSGTYP = 3 OR 6) VIOLATIONS ARE COUNTED ONLY IF THE
!                             THE FIRST ELEMENT IS NOT IN VIOLATION.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE ARGUMENTS NAME.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND.
!     INTEGER NVMN
!        THE SMALLEST NUMBER OF NON-VIOLATIONS ALLOWED.
!     INTEGER NVMX
!        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
!     DOUBLE PRECISION VCMISS
!        MISSING VALUE CODE IN VEC.
!     DOUBLE PRECISION VEC(N)
!        THE VECTOR BEING TESTED.
!     DOUBLE PRECISION VECLB
!        THE VALUE THAT THE VECTOR IS BEING TESTED AGAINST.
!
      ERROR = .FALSE.
!
      IF (N .LE. 0) RETURN
!
!     TEST WHETHER TESTING IS NECESSRY
!
      IF ((MOD(MSGTYP,3) .EQ. 0) .AND. (VEC(1) .LE. VECLB)) RETURN
!
!     CHECK FOR VIOLATIONS
!
      NV = 0
      DO 5 I = 1, N
         IF (MVCHK(VEC(I), VCMISS)) GO TO 5
         IF ((VEC(I).LE.VECLB)) NV = NV + 1
    5 CONTINUE
!
      IF (NV .LE. NVMX) RETURN
!
!     VIOLATIONS FOUND
!
      ERROR = .TRUE.
      NVMN = N - NVMX
      CALL ERVGTP (NMSUB, NMVAR, VECLB, NVMN, NVMX, HEAD, MSGTYP, NV,
     +   NMMIN)
!
      RETURN
!
      END
!PPFNML
      DOUBLE PRECISION FUNCTION PPFNML(P)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS FUNCTION IS A VERSION OF DATAPAC SUBROUTINE
!     NORPPF, WITH MODIFICATIONS TO FACILITATE CONVERSION TO
!     DOUBLE PRECISION AUTOMATICALLY USING THE NAG, INC. CODE APT, AND
!     TO CORRESPOND TO STARPAC CONVENTIONS.
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE NORMAL (GAUSSIAN)
!              DISTRIBUTION WITH MEAN = 0 AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/SQRT(2*PI))*EXP(-X*X/2).
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     ERROR CHECKING--NONE
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0D0 AND 1.0D0, EXCLUSIVELY.
!     REFERENCES--ODEH AND EVANS, THE PERCENTAGE POINTS
!                 OF THE NORMAL DISTRIBUTION, ALGORITHM 70,
!                 APPLIED STATISTICS, 1974, PAGES 96-97.
!               --EVANS, ALGORITHMS FOR MINIMAL DEGREE
!                 POLYNOMIAL AND RATIONAL APPROXIMATION,
!                 M. SC. THESIS, 1972, UNIVERSITY
!                 OF VICTORIA, B. C., CANADA.
!               --HASTINGS, APPROXIMATIONS FOR DIGITAL
!                 COMPUTERS, 1955, PAGES 113, 191, 192.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 933, FORMULA 26.2.23.
!               --FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231.
!               --FILLIBEN, "THE PERCENT POINT FUNCTION",
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 40-111.
!               --THE KELLEY STATISTICAL TABLES, 1948.
!               --OWEN, HANDBOOK OF STATISTICAL TABLES,
!                 1962, PAGES 3-16.
!               --PEARSON AND HARTLEY, BIOMETRIKA TABLES
!                 FOR STATISTICIANS, VOLUME 1, 1954,
!                 PAGES 104-113.
!     COMMENTS--THE CODING AS PRESENTED BELOW
!               IS ESSENTIALLY IDENTICAL TO THAT
!               PRESENTED BY ODEH AND EVANS
!               AS ALGORITHM 70 OF APPLIED STATISTICS.
!               THE PRESENT AUTHOR HAS MODIFIED THE
!               ORIGINAL ODEH AND EVANS CODE WITH ONLY
!               MINOR STYLISTIC CHANGES.
!             --AS POINTED OUT BY ODEH AND EVANS
!               IN APPLIED STATISTICS,
!               THEIR ALGORITHM REPRESENTES A
!               SUBSTANTIAL IMPROVEMENT OVER THE
!               PREVIOUSLY EMPLOYED
!               HASTINGS APPROXIMATION FOR THE
!               NORMAL PERCENT POINT FUNCTION--
!               THE ACCURACY OF APPROXIMATION
!               BEING IMPROVED FROM 4.5*(10**-4)
!               TO 1.5*(10**-8).
!
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --OCTOBER   1976.
!
!     MODIFIED BY     --JANET R. DONALDSON, DECEMBER 7, 1981
!                       STATISTICAL ENGINEERING DIVISION
!                       NATIONAL BUREAU OF STANDARDS, BOULDER, COLORDAO
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   P
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ADEN,ANUM,P0,P1,P2,P3,P4,Q0,Q1,Q2,Q3,Q4,R,T
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ADEN, ANUM
!        *
!     DOUBLE PRECISION P
!        THE PROBABILITY AT WHICH THE PERCENT POINT IS TO BE EVALUATED
!     DOUBLE PRECISION P0, P1, P2, P3, P4
!        VARIOUS PARAMETERS USED IN THE APPROXIMATIONS.
!     DOUBLE PRECISION Q0, Q1, Q2, Q3, Q4
!        VARIOUS ADDITIONAL PARAMETERS USED IN THE APPROXIMATIONS.
!     DOUBLE PRECISION R
!        *
!     DOUBLE PRECISION T
!        *
!
      DATA P0, P1, P2, P3, P4
     +  /-.322232431088D0, -1.0D0, -.342242088547D0,
     +   -.204231210245D-1,-.453642210148D-4/
      DATA Q0, Q1, Q2, Q3, Q4
     +  /.993484626060D-1, .588581570495D0,
     +   .531103462366D0, .103537752850D0, .38560700634D-2/
!
!
      IF (P.NE.0.5D0) GO TO 30
      PPFNML = 0.0D0
      RETURN
!
   30 R = P
      IF (P.GT.0.5D0) R = 1.0D0 - R
      T = SQRT(-2.0D0*LOG(R))
      ANUM = ((((T*P4+P3)*T+P2)*T+P1)*T+P0)
      ADEN = ((((T*Q4+Q3)*T+Q2)*T+Q1)*T+Q0)
      PPFNML = T + (ANUM/ADEN)
!
      IF (P.LT.0.5D0) PPFNML = -PPFNML
!
      RETURN
!
      END
!AMEISM
      SUBROUTINE AMEISM (AMEHDR, PAGE, WIDE, HLFRPT, NPAR, M, N, NNZW,
     +   WEIGHT, IFIXD, PAR, SCALE, LSCALE, IWORK, LIWORK, RWORK,
     +   LRWORK, RES, APRXDV, STPT, LSTPT, NPARE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS AN INITIAL SUMMARY OF THE STARTING
!     ESTIMATES AND THE CONTROL PARAMETERS FOR THE NONLINEAR
!     LEAST SQUARES SUBROUTINES FOR ARIMA MODELING.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LIWORK,LRWORK,LSCALE,LSTPT,M,N,NNZW,NPAR,NPARE
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,WEIGHT,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),RWORK(*),SCALE(*),STPT(*)
      INTEGER
     +   IFIXD(*),IWORK(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL AMEHDR
!
!  SCALARS IN COMMON
      INTEGER
     +   IFLAG,MBO,MBOL,MSPECT,NFACT,NPARAR,NPARDF,NPARMA,NRESTS,
     +   PARAR,PARDF,PARMA,T,TEMP
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD,RSS
      INTEGER
     +   IAMHD,IPRT,ISUBHD,LMAX0,MXFCAL,MXITER,RFCTOL,XCTOL
!
!  LOCAL ARRAYS
      INTEGER
     +   ISTAK(12)
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   DNRM2
      EXTERNAL DNRM2
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMLST,IPRINT,MODSUM
!
!  INTRINSIC FUNCTIONS
      INTRINSIC DBLE,SQRT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /MDLTSC/MSPECT,NFACT,PARDF,NPARDF,PARAR,NPARAR,PARMA,
     +   NPARMA,MBO,MBOL,T,TEMP,NRESTS,IFLAG
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     EXTERNAL AMEHDR
!        THE ROUTINE USED TO PRINT THE HEADING
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IAMHD
!        THE INDICATOR VALUE USED TO DESIGNATE THE TYPE OF LIST
!        TO BE GENERATED
!        IF IAMHD=1, THE LIST IS FOR THE INITIAL SUMMARY OF THE
!                    ESTIMATION ROUTINES.
!        IF IAMHD=2, THE LIST IS FOR THE INITIAL REPORT OF THE
!                    FORECASTING ROUTINES.
!        IF IAMHD=3, THE LIST IS FOR THE FINAL REPORT OF THE
!                    ESTIMATION ROUTINES.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IWORK(LIWORK)
!        WORK SPACE USED BY THE NL2 SUBROUTINES.
!     INTEGER LIWORK
!        THE DIMENSION OF VECTOR IWORK.
!     INTEGER LMAX0
!        THE LOCATION IN RWORK OF THE VALUE INDICATING THE
!        MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     INTEGER LRWORK
!        THE DIMENSION OF VECTOR RWORK.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER LSTPT
!        THE DIMENSION OF VECTOR STPT.
!     INTEGER M
!        A DUMMY VARIABLE.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBOL
!        THE MAXIMUM BACK ORDER ON THE LEFT
!     INTEGER MSPECT
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER MXFCAL
!        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
!        MAXIMUM NUMBER OF FUNCTION CALLS ALLOWED, EXCLUDING
!        CALLS NECESSARY TO COMPUTE THE DERIVATIVES AND VARIANCE
!        COVARIANCE MATRIX.
!     INTEGER MXITER
!        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
!        MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFACT
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARAR
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE AUTOREGRESSIVE PARAMETERS
!     INTEGER PARDF
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
!     INTEGER PARMA
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE MOVING AVERAGE PARAMETERS
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     INTEGER RFCTOL
!        THE LOCATION IN RWORK OF THE RELATIVE FUNCTION CONVERGENCE
!        TOLERANCE.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     DOUBLE PRECISION RSS
!        THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION RWORK(LRWORK)
!        WORK SPACE USED BY THE NL2 SUBROUTINES.
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION STPT(LSTPT)
!        THE STEP SIZE ARRAY.
!     INTEGER T
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR.
!     INTEGER TEMP
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     INTEGER XCTOL
!        THE LOCATION IN RWORK OF THE PARAMETER CONVERGENCE TOLERANCE.
!
!     IWORK SUBSCRIPT VALUES
!
      DATA MXFCAL/17/, MXITER/18/
!
!     RWORK SUBSCRIPT VALUES
!
      DATA LMAX0/35/, RFCTOL/32/, XCTOL/33/
!
      CALL IPRINT(IPRT)
!
      ISUBHD = 1
      CALL AMEHDR(PAGE, WIDE, ISUBHD)
!
      CALL MODSUM(NFACT, ISTAK(MSPECT))
      IAMHD = 1
      CALL AMLST (IAMHD, PAR, NPAR, NFACT, ISTAK(MSPECT), N, PAR, NPAR,
     +  SCALE, LSCALE, STPT, LSTPT, IFIXD, RSS, RSD, NPARDF, NPARE, 0)
!
      IF (WEIGHT) WRITE (IPRT, 1170) NNZW
      WRITE(IPRT, 1070) IWORK(MXITER)
      WRITE(IPRT, 1090) IWORK(MXFCAL)
      WRITE(IPRT, 1080)
      WRITE(IPRT, 1100) RWORK(RFCTOL)
      WRITE(IPRT, 1110) RWORK(XCTOL)
      WRITE(IPRT, 1120) RWORK(LMAX0)
      RSD = DNRM2(NRESTS, RES, 1)
      RSS = RSD * RSD
      IF (N-NPARDF-NPARE.GE.1)
     +     RSD = RSD / SQRT(DBLE(N-NPARDF-NPARE))
      WRITE (IPRT, 1200) RSS
      WRITE (IPRT, 1210) RSD
      WRITE (IPRT, 1220) N, NPARDF, NPARE, NNZW-NPARE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1070 FORMAT (/37H MAXIMUM NUMBER OF ITERATIONS ALLOWED, 32X, 5H(MIT),
     +   1X, I5)
 1080 FORMAT(/44H CONVERGENCE CRITERION FOR TEST BASED ON THE/)
 1090 FORMAT(/' MAXIMUM NUMBER OF MODEL SUBROUTINE CALLS',
     +   8H ALLOWED, 26X, I5)
 1100 FORMAT (5X, 39H FORECASTED RELATIVE CHANGE IN RESIDUAL,
     +   15H SUM OF SQUARES, 7X, 8H(STOPSS), 1X, G11.4)
 1110 FORMAT(5X, 49H MAXIMUM SCALED RELATIVE CHANGE IN THE PARAMETERS,
     +   13X, 7H(STOPP), 1X, G11.4)
 1120 FORMAT(//' MAXIMUM CHANGE ALLOWED IN THE PARAMETERS',
     +   23H AT THE FIRST ITERATION, 3X, 7H(DELTA), 1X, G11.4)
 1170 FORMAT (/' NUMBER OF NON ZERO WEIGHTED OBSERVATIONS', 27X,
     +   6H(NNZW), 1X, I5)
 1200 FORMAT (/44H RESIDUAL SUM OF SQUARES FOR INPUT PARAMETER,
     +   7H VALUES, 24X, G11.4, '  (BACKFORECASTS INCLUDED)')
 1210 FORMAT (/48H RESIDUAL STANDARD DEVIATION FOR INPUT PARAMETER,
     +   7H VALUES, 14X, 5H(RSD), 1X, G11.4)
 1220 FORMAT (/ 19H BASED ON DEGREES O,
     +   9HF FREEDOM, 1X, I4, 3H - , I3, 3H - , I3, 3H = , I4)
      END
!ARFLT
      SUBROUTINE ARFLT (Y, N, IAR, PHI, YF, NYF)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PERFORMS THE AUTOREGRESSIVE FILTERING
!     OPERATION DEFINED BY PHI, RETURNING THE FILTERED SERIES
!     IN YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IAR,N,NYF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PHI(*),Y(*),YF(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   YMEAN
      INTEGER
     +   I,IPRT
      LOGICAL
     +   ERR01,HEAD
!
!  LOCAL ARRAYS
      CHARACTER
     +   LN(8)*1,NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN,EISGE,FLTAR,IPRINT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     CHARACTER*1 LN(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     DOUBLE PRECISION PHI(IAR)
!        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE INPUT SERIES Y.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'A',       'R',       'F',       'L',       'T',       ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 3, 1, HEAD, ERR01, LN)
!
!
      IF (.NOT. ERR01) GO TO 10
!
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   10 CONTINUE
!
!     COMPUTE ARITHMETIC MEAN
!
      CALL AMEAN(Y, N, YMEAN)
!
      DO 20 I = 1, N
         YF(I) = Y(I) - YMEAN
   20 CONTINUE
!
      CALL FLTAR (YF, N, IAR, PHI, YF, NYF)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   43H       CALL ARFLT (Y, N, IAR, PHI, YF, NYF))
      END
!MULTBP
      SUBROUTINE MULTBP(T, LT, C, LC, TEMP, LTEMP, MBO)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE MULTIPLIES TOGETHER TWO DIFFERENCE FACTORS FROM A
!     (BOX-JENKINS) TIME SERIES MODEL.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 1, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LC,LT,LTEMP,MBO
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   C(MBO),T(2*MBO),TEMP(MBO)
!
!  LOCAL SCALARS
      INTEGER
     +   I,J,JI,K
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION C(MBO)
!        THE SECOND FACTOR ON INPUT AND THE EXPANDED FACTOR ON OUTPUT.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER JI
!        AN INDEX VARIABLE
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER LC
!        THE LARGEST ORDER OF THE SECOND FACTOR ON INPUT, AND
!        THE LARGEST ORDER OF THE EXPANDED FACTOR ON OUTPUT.
!     INTEGER LT
!        THE LARGEST ORDER OF THE FIRST FACTOR.
!     INTEGER LTEMP
!        THE LENGTH OF THE VECTOR TEMP.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     DOUBLE PRECISION T(2*MBO)
!        A TEMPORARY WORK VECTOR.
!     DOUBLE PRECISION TEMP(MBO)
!        A TEMPORARY WORK VECTOR
!
      IF (LC .EQ. 0) GO TO 15
      DO 10 J = 1, LC
         TEMP(J) = C(J)
   10 CONTINUE
   15 K = LC + 1
      DO 20 J=K,LTEMP
         TEMP(J) = 0.0D0
   20 CONTINUE
      IF (LT .EQ. 0) GO TO 50
      DO 40 J=1,LT
         TEMP(J) = TEMP(J) + T(J)
         IF (LC .EQ. 0) GO TO 40
         DO 30 I=1,LC
            JI = J + I
            TEMP(JI) = TEMP(JI) - C(I)*T(J)
   30    CONTINUE
   40 CONTINUE
!
   50 DO 60 J=1,LTEMP
         C(J) = TEMP(J)
   60 CONTINUE
      LC = LTEMP
      RETURN
      END
!VCVOTF
      SUBROUTINE VCVOTF(NPAR, VCV, LVCV, EST, LMASK, MASK, IVCVPT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS THE VARIANCE COVARIANCE MATRIX
!     STORED ROW WISE WHEN IT IS TO BE LABELLED ON THE BASIS OF A MASK.
!     IF EST IS TRUE, THE COVARIANCES ARE LISTED ABOVE THE
!     DIAGONAL, THE VARIANCES ON THE DIAGONAL, AND THE CORRELATION
!     COEFFICIENTS BELOW THE DIAGONAL.
!     IF EST IS FALSE, THE STANDARD DEVIATIONS ARE LISTED ON THE
!     DIAGONAL, AND THE CORRELATION COEFFICIENTS ARE BELOW THE
!     DIAGONAL.
!
!     WRITTEN BY  -  JOHN E. KOONTZ
!          STATISTICAL ENGINEERING DIVISION
!          NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!        BASED ON VCVOUT VERSION OF DECEMBER 29, 1982
!        WRITTEN BY JANET R. DONALDSON
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IVCVPT,LMASK,LVCV,NPAR
      LOGICAL
     +   EST
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VCV(LVCV)
      INTEGER
     +   MASK(LMASK)
!
!  LOCAL SCALARS
      INTEGER
     +   CODE,I,II,IPRT,MODE
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,MATPRF
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CODE
!        IF 1 -SINGLE PRINTED, X ONLY (Y IS DUMMY ARG)
!           2 -DOUBLE PRINTED LINE, BOTH X AND Y
!     LOGICAL EST
!        AN INDICATOR USED TO DESIGNATE WHETHER THE VCV TO BE PRINTED
!        IS OF THE ESTIMATED PARAMETERS (TRUE) OR NOT (FALSE).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER II
!        THE INDEX OF THE (I,I)TH ELEMENT OF THE VCV MATRIX
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCVPT
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
!        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
!        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)
!        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                       *INVERSE(HESSIAN)
!     INTEGER LMASK
!        THE LENGTH OF MASK.
!     INTEGER LVCV
!        THE LENGTH OF ARRAY VCV.
!     INTEGER MASK(LMASK)
!        MASK VECTOR FOR VCV.  THE INDEX OF THE ITH ELEMENT OF
!        MASK EQUAL TO ZERO IS THE LABEL IN THE OUTPUT OF VCV
!        OF THE ITH ROW AND ITH COLUMN.
!     INTEGER MODE
!        IF 0, LOWER TRIANGULAR PART PRINTED
!           1, LOWER TRIANGULAR PART IS PRINTED WITH
!              SQUARE ROOTS OF THE DIAGONAL
!           2, LOWER TRIANGLE PRINTED AS CORRELATION MATRIX
!              WITH SQUARE ROOTS ON THE DIAGONAL
!           3, FULL MATRIX PRINTED
!           4, FULL MATRIX PRINTED WITH CORRELATION MATRIX
!              PRINTED BELOW THE DIAGONAL
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     DOUBLE PRECISION VCV(LVCV)
!        THE VARIANCE COVARIANCE MATRIX.
!
!     COMMENCE BODY OF ROUTINE
!
      CALL IPRINT(IPRT)
!
      CODE = 1
!
!     DETERMINE WHETHER TO ISSUE NEGATIVE VARIANCE WARNING
!
      MODE = 0
      DO 30 I=1,NPAR
         II = I*(I-1)/2 + I
         IF (VCV(II).GT.0.0D0) GO TO 30
         IF (EST) GO TO 10
         WRITE (IPRT,1000)
         GO TO 20
!
   10    CONTINUE
         WRITE (IPRT,1050)
         IF (IVCVPT.EQ.1) WRITE (IPRT,1060)
         IF (IVCVPT.EQ.2) WRITE (IPRT,1070)
         IF (IVCVPT.EQ.3) WRITE (IPRT,1080)
   20    WRITE (IPRT,1010)
         GO TO 50
   30 CONTINUE
!
      IF (EST) GO TO 40
!
!     PRINT HEADING FOR CORRELATION ROUTINES
!
      WRITE (IPRT,1040)
      WRITE (IPRT,1030)
      MODE = 2
      GO TO 50
!
   40 CONTINUE
!
!     PRINT HEADING FOR ESTIMATION ROUTINES
!
      WRITE (IPRT,1050)
      IF (IVCVPT.EQ.1) WRITE (IPRT,1060)
      IF (IVCVPT.EQ.2) WRITE (IPRT,1070)
      IF (IVCVPT.EQ.3) WRITE (IPRT,1080)
      WRITE (IPRT,1020)
      MODE = 4
!
   50 CALL MATPRF(VCV, VCV, NPAR, MODE, CODE, LVCV, MASK, LMASK)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (///18H COVARIANCE MATRIX)
 1010 FORMAT (/39H     NONPOSITIVE VARIANCES ENCOUNTERED./10H     CORRE,
     +   39HLATION COEFFICIENTS CANNOT BE COMPUTED.)
 1020 FORMAT (4X, 36H- COVARIANCES ARE ABOVE THE DIAGONAL/4X, 7H- VARIA,
     +   24HNCES ARE ON THE DIAGONAL/4X, 27H- CORRELATION COEFFICIENTS ,
     +   22HARE BELOW THE DIAGONAL)
 1030 FORMAT (4X, 41H- STANDARD DEVIATIONS ARE ON THE DIAGONAL/4X,
     +   49H- CORRELATION COEFFICIENTS ARE BELOW THE DIAGONAL)
 1040 FORMAT (/19H CORRELATION MATRIX)
 1050 FORMAT (///45H VARIANCE-COVARIANCE AND CORRELATION MATRICES,
     +   38H OF THE ESTIMATED (UNFIXED) PARAMETERS/ 1X, 82('-'))
 1060 FORMAT (/
     +   4X, 54H- APPROXIMATION BASED ON ASSUMPTION THAT RESIDUALS ARE,
     +   6H SMALL)
 1070 FORMAT (
     +   /4X, 51H- APPROXIMATION BASED ON ASYMPTOTIC MAXIMUM LIKELIH,
     +   10HOOD THEORY)
 1080 FORMAT (/4X,
     +   51H- APPROXIMATION BASED ON ASSUMPTION THAT CONDITIONS,
     +   10H NECESSARY/
     +   5X, 41H FOR ASYMPTOTIC MAXIMUM LIKELIHOOD THEORY,
     +   18H MIGHT BE VIOLATED)
      END
!PPMC
      SUBROUTINE PPMC(YM, YMMISS, X, XMISS, N, ILOG, ISIZE, NOUT, YLB,
     +   YUB, XLB, XUB)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT FOR DATA WITH MISSING OBSERVATIONS (LONG CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   ILOG,ISIZE,N,NOUT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(1)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,ISCHCK,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'P',       'P',       'M',       'C',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      M = 1
      IYM = N
      MULTI = .FALSE.
      ISCHCK = 0
      MISS = .TRUE.
      LISYM = 1
!
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL PPMC (Y, YMISS, X, XMISS, N, ILOG,'/
     +   '      +           ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      END
!BFSFS
      SUBROUTINE BFSFS(YFFT1, YFFT2, N, LYFFT, LDSTAK, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     BIVARIATE SPECTRUM ANALYSIS (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   ICSPC2,IPHAS,LDSTAK,LYFFT,N,NF,NPRT,NW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CSPC2(*),FREQ(*),PHAS(*),YFFT1(*),YFFT2(*)
      INTEGER
     +   LAGS(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,YMISS1,YMISS2
      INTEGER
     +   CCOV,CCOV11,CCOV12,CCOV21,CCOV22,CEVEN,CODD,I,ICCOV,IFP,
     +   INDEX1,INDEX2,INLPPC,IO,IPRT,ISYM,JCCOV,JNLPPC,LAGMAX,
     +   LAGMX1,LDSMIN,LPCV,LW,LWORK,M,NALL0,NFFT,SPCF1,SPCF2,W,
     +   WORK,XAXIS,YAXIS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12),NLPPC(1,1,1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,IPRINT,LDSCMP,PARZEN,SETESL,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     INTEGER CCOV, CCOV11, CCOV12, CCOV21, CCOV22
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE COVARIANCES.
!     INTEGER CEVEN
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     INTEGER CODD
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CSPC2(ICSPC2,NW)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NLPPC(1,1,1)
!        A DUMMY ARRAY.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION PHAS(IPHAS,NW)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SPCF1, SPCF2
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     INTEGER W
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE WINDOWS.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR THE VECTOR WORK.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YMISS1, YMISS2
!        DUMMY VARIABLES.
!     DOUBLE PRECISION YFFT1(LYFFT)
!        THE FIRST TIME SERIES.
!     DOUBLE PRECISION YFFT2(LYFFT)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','F','S',' '/
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(4) = .TRUE.
!
!     SET MAXIMUM LAG VALUE TO BE USED.
!
      IF (NW.GE.1) THEN
         LAGMAX = LAGS(1)
         DO 10 I=2,NW
            LAGMAX = MAX(LAGMAX,LAGS(I))
   10    CONTINUE
      ELSE
         LAGMAX = N - 1
      END IF
      LAGMX1 = LAGMAX + 1
      CALL SETESL(N+LAGMAX, 4, NFFT)
!
      ICCOV = LAGMAX + 1
      JCCOV = 2
      INLPPC = 1
      JNLPPC = 1
      M = 2
      INDEX1 = 1
      INDEX2 = 2
!
!     COMPUTE THE MINIMUM ALLOWABLE STACK AREA
!
      IF (NPRT.EQ.0) THEN
         IO = 0
      ELSE
         IO = 1
      END IF
!
      CALL LDSCMP(9, 0, IO*4*NF, 0, 0, 0, 'D',
     +            6*LAGMAX+6+NFFT+IO*8*NF, LDSMIN)
!
      YMISS1 = 1.0D0
      YMISS2 = 1.0D0
      LPCV = 4*NF
      LW = NFFT
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING STACK ALLOCATIONS (NALL0)
!     SET THE STACK ALLOCATION TYPE (IFP)
!
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
!
      IFP = 4
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS
!
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         CCOV = 1
         CEVEN = 1
         CODD = 1
         SPCF1 = 1
         SPCF2 = 1
         W = 1
!
         CCOV11 = 1
         CCOV21 = 1
         CCOV12 = 1
         CCOV22 = 1
!
         ISYM = 1
         XAXIS = 1
         YAXIS = 1
      ELSE
         CCOV = STKGET(4*LAGMX1,IFP)
         CEVEN = STKGET(LAGMX1,IFP)
         CODD = STKGET(LAGMX1,IFP)
         SPCF1 = STKGET(NF,IFP)
         SPCF2 = STKGET(NF,IFP)
         W = STKGET(LW,IFP)
!
         CCOV11 = CCOV
         CCOV21 = CCOV + LAGMX1
         CCOV12 = CCOV21 + LAGMX1
         CCOV22 = CCOV12 + LAGMX1
!
         IF (NPRT.EQ.0) THEN
            ISYM = W
            XAXIS = W
            YAXIS = W
         ELSE
            ISYM = STKGET(LPCV,2)
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
         END IF
      END IF
!
      WORK = W
      LWORK = LW
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
      CALL BFSDRV(YFFT1, YFFT2, YMISS1, YMISS2, RSTAK(CCOV), NLPPC,
     +   RSTAK(SPCF1), RSTAK(SPCF2), NF, FMIN, FMAX, FREQ, N, NW,
     +   LAGMAX, LAGS, LAGMX1, RSTAK(WORK), LWORK, DELTA, ISTAK(ISYM),
     +   RSTAK(XAXIS), RSTAK(YAXIS), LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS,
     +   RSTAK(CODD), RSTAK(CEVEN), RSTAK(W), LW, NMSUB, LDSMIN,
     +   LDSTAK, OPTION, NFFT, INLPPC, JNLPPC, LYFFT)
!
      CALL STKCLR(NALL0)
!
!     CHECK FOR ERRORS
!
      IF (IERR.EQ.0) RETURN
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL BFSFS (YFFT1, YFFT2, N, LYFFT, LDSTAK,'/
     +   '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +   '      +            CSPC2, ICSPC2, PHAS, IPHAS, FREQ)')
      END
!LOPASS
      SUBROUTINE LOPASS (Y, N, FC, K, HLP, YF, NYF)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE CARRIES OUT LOW-PASS FILTERING OF THE
!     SERIES.  THE FILTER IS THE K-TERM
!     LEAST SQUARES APPROXIMATION TO THE CUTOFF FILTER
!     WITH CUTOF FREQUENCY FC.  ITS TRANSFER FUNCTION
!     HAS A TRANSITION BAND OF WIDTH DELTA SURROUNDING FC,
!     WHERE DELTA = 4*PI/K.
!
!     WRITTEN BY  -  PETER BLOOMFIELD
!                    FOURIER ANALYSIS OF TIME SERIES- AN
!                       INTRODUCTION
!                    JOHN WILEY AND SONS, NEW YORK, 1976
!                    PAGE 149
!     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
!                                STATISTICAL ENGINEERING DIVISION
!                                NATIONAL BUREAU OF STANDARDS
!                                BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC
      INTEGER
     +   K,N,NYF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   HLP(*),Y(*),YF(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,HEAD
!
!  LOCAL ARRAYS
      CHARACTER
     +   LFC(8)*1,LK(8)*1,LN(8)*1,NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,ERIODD,ERSII,ERSLFS,FLTSL,IPRINT,LPFLT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION FC
!        THE USER SUPPLIED CUTOFF FREQUENCY.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     DOUBLE PRECISION HLP(K)
!        THE ARRAY IN WHICH THE -IDEAL- HIGH PASS FILTER COEFFICIENTS
!        WILL BE RETURNED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS TO BE COMPUTED.
!     CHARACTER*1 LFC(8), LK(8), LN(8)
!        THE ARRAY CONTAINING THE NAMES OF THE VARIABLES FC, K AND N.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'L',       'O',       'P',       'A',       'S',       'S'/
      DATA
     +  LFC(1), LFC(2), LFC(3), LFC(4), LFC(5), LFC(6), LFC(7), LFC(8)
     + /  'F',   'C',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 3, 1, HEAD, ERR01, LN)
!
      CALL ERSII(NMSUB, LFC, FC, 0.0D0, 0.5D0, 2, HEAD, ERR02, LFC, LFC)
!
      CALL EISII(NMSUB, LK, K, 1, N, 2, HEAD, ERR03, LK, LK)
!
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR04)
!
      IF (ERR01 .OR. ERR02 .OR. ERR03 .OR. ERR04) GO TO 10
!
      CALL ERSLFS(NMSUB, FC, K, HEAD, ERR05)
!
      IF (.NOT. ERR05) GO TO 20
!
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   20 CONTINUE
!
      CALL LPFLT (FC, K, HLP)
!
      CALL FLTSL (Y, N, K, HLP, YF, NYF)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   46H       CALL LOPASS (Y, N, FC, K, HLP, YF, NYF))
      END
!STPDRV
      SUBROUTINE STPDRV(NMSUB, XM, N, M, IXM, MDL, PAR, NPAR, LDSTAK,
     +   STP, NETA, EXMPT, SCALE, LSCALE, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE DRIVER ROUTINE FOR SELECTING STEP SIZES
!     TO BE USED IN COMPUTING FORWARD DIFFERENCE QUOTIENT ESTIMATES
!     OF THE NUMERICAL DERIVATIVES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   EXMPT
      INTEGER
     +   IXM,LDSTAK,LSCALE,M,N,NETA,NPAR,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),SCALE(*),STP(*),XM(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   ISUBHD,LIFIXD
      LOGICAL
     +   HLFRPT,PAGE,PRTFXD,WIDE
!
!  LOCAL ARRAYS
      INTEGER
     +   IFIXED(1)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL STKSET,STPCNT,STPER,STPHDR
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXCEPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE STEP SIZE SELECTION
!        ROUTINE HAS ALREADY PRINTED PART OF THE INITIAL SUMMARY (TRUE)
!        OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE LENGTH OF THE VECTOR IFIXED.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     DOUBLE PRECISION STP(NPAR)
!        THE SELECTED STEP SIZES.
!     EXTERNAL STPHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION XM(IXM,M)
!        THE INDEPENDENT VARIABLE ARRAY
!
!
!     PERFORM ERROR CHECKING
!
      CALL STPER(NMSUB, N, M, IXM, NPAR, LDSTAK, SCALE, LSCALE)
!
      IF (IERR.NE.0) RETURN
!
      CALL STKSET(LDSTAK, 4)
!
      PAGE = .FALSE.
      WIDE = .TRUE.
      ISUBHD = 0
!
      PRTFXD = .FALSE.
      IFIXED(1) = -1
      LIFIXD = 1
!
!     PASS CONTROL OF STEP SIZE SELECTION TO SUBROUTINE STPCNT
!
      CALL STPCNT(XM, N, M, IXM, MDL, PAR, NPAR, STP, EXMPT, NETA,
     +   SCALE, LSCALE, NPRT, STPHDR, PAGE, WIDE, ISUBHD, HLFRPT,
     +   PRTFXD, IFIXED, LIFIXD)
!
      RETURN
!
      END
!XACF
      SUBROUTINE XACF(LDS,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE TIME SERIES CORRELATION SUBROUTINES
!
!     SERIES Y IS LISTED AS SERIES X1 ON PAGE 362 IN JENKINS AND WATTS.
!
!     SERIES YD IS LISTED AS SERIES G ON PAGE 531 OF BOX AND JENKINS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDS
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   AMISS,YMISS
      INTEGER
     +   I,IAR,IPRT,ITEST,LACOV,LAGMAX,LDSTAK,LYFFT,N,NFAC,NPRT,NYD
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(21),PHI(21),Y(100),YD(150),YFFT(150)
      INTEGER
     +   IOD(2),ND(2),NLPPA(21)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACF,ACFD,ACFF,ACFFS,ACFM,ACFMS,ACFS,IPRINT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(21)
!        THE AUTOCOVARIANCE VECTOR.
!     DOUBLE PRECISION AMISS
!        THE MISSING VALUE CODE FOR THE RETURNED ACVF ESTIMATES
!        (VECTOR ACOV).
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!     INTEGER IOD(2)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER ITEST
!        THE NUMBER OF THE TEST BEING RUN
!     INTEGER LACOV
!        THE LENGTH OF THE ACVF RELATED VECTORS.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE ARRAYS USED WHEN THE COMPUTATIONS ARE
!        PERFORMED BY THE FFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER ND(2)
!        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE
!        FACTORS ARE TO BE APPLIED.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS.
!     INTEGER NLPPA(21)
!        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
!        USED TO COMPUTE EACH ACVF ESTIMATE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     INTEGER NYD
!        THE NUMBER OF OBSERVATIONS IN THE SERIES TO BE DIFFERENCED.
!     DOUBLE PRECISION PHI(21)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     DOUBLE PRECISION Y(100), YD(150)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YFFT(150)
!        THE VECTORS USED FOR STORING THE SERIES FOR THE ROUTINES
!        USING THE FFT.
!     DOUBLE PRECISION YMISS
!        THE MISSING VALUE CODES FOR SERIES Y AND YM.
!
      DATA    Y(  1),   Y(  2),   Y(  3),   Y(  4),   Y(  5),   Y(  6)
     +    / -2.07D0, -1.15D0,  0.69D0, -0.46D0, -1.49D0, -0.70D0/
      DATA    Y(  7),   Y(  8),   Y(  9),   Y( 10),   Y( 11),   Y( 12)
     +    / -1.07D0, -0.69D0, -0.68D0,  1.27D0, -1.05D0, -0.05D0/
      DATA    Y( 13),   Y( 14),   Y( 15),   Y( 16),   Y( 17),   Y( 18)
     +    / -0.84D0, -0.62D0, -0.49D0, -1.29D0, -0.49D0, -1.06D0/
      DATA    Y( 19),   Y( 20),   Y( 21),   Y( 22),   Y( 23),   Y( 24)
     +    / -0.38D0, -0.52D0, -0.13D0,  1.30D0, -1.51D0, -0.43D0/
      DATA    Y( 25),   Y( 26),   Y( 27),   Y( 28),   Y( 29),   Y( 30)
     +    / -1.33D0, -0.78D0,  0.31D0, -0.95D0, -0.90D0, -0.30D0/
      DATA    Y( 31),   Y( 32),   Y( 33),   Y( 34),   Y( 35),   Y( 36)
     +    / -1.02D0, -0.53D0,  0.15D0,  1.40D0,  1.22D0,  0.59D0/
      DATA    Y( 37),   Y( 38),   Y( 39),   Y( 40),   Y( 41),   Y( 42)
     +    /  0.70D0,  1.70D0,  2.78D0,  1.98D0,  1.39D0,  1.85D0/
      DATA    Y( 43),   Y( 44),   Y( 45),   Y( 46),   Y( 47),   Y( 48)
     +    /  2.60D0,  0.51D0,  2.77D0,  1.16D0,  1.07D0, -0.48D0/
      DATA    Y( 49),   Y( 50),   Y( 51),   Y( 52),   Y( 53),   Y( 54)
     +    / -0.52D0,  0.37D0,  0.00D0, -1.99D0, -1.75D0,  0.70D0/
      DATA    Y( 55),   Y( 56),   Y( 57),   Y( 58),   Y( 59),   Y( 60)
     +    /  0.73D0,  1.16D0,  0.06D0, -0.02D0,  1.10D0, -0.35D0/
      DATA    Y( 61),   Y( 62),   Y( 63),   Y( 64),   Y( 65),   Y( 66)
     +    / -1.67D0, -1.57D0,  1.16D0,  1.84D0,  3.35D0,  0.40D0/
      DATA    Y( 67),   Y( 68),   Y( 69),   Y( 70),   Y( 71),   Y( 72)
     +    /  0.45D0,  1.30D0,  0.93D0,  1.17D0, -1.74D0, -1.28D0/
      DATA    Y( 73),   Y( 74),   Y( 75),   Y( 76),   Y( 77),   Y( 78)
     +    / -0.07D0,  1.50D0,  0.53D0,  0.20D0, -0.42D0,  1.18D0/
      DATA    Y( 79),   Y( 80),   Y( 81),   Y( 82),   Y( 83),   Y( 84)
     +    /  0.82D0,  1.50D0,  2.92D0,  1.18D0,  1.23D0,  3.16D0/
      DATA    Y( 85),   Y( 86),   Y( 87),   Y( 88),   Y( 89),   Y( 90)
     +    /  0.79D0,  0.68D0,  1.14D0,  1.02D0,  1.02D0, -0.71D0/
      DATA    Y( 91),   Y( 92),   Y( 93),   Y( 94),   Y( 95),   Y( 96)
     +    / -0.17D0, -1.50D0, -0.26D0, -0.38D0,  0.93D0, -0.33D0/
      DATA    Y( 97),   Y( 98),   Y( 99),   Y(100)
     +    / -1.12D0, -2.95D0, -2.09D0, -1.11D0                    /
!
      DATA   YD(  1),  YD(  2),  YD(  3),  YD(  4),  YD(  5),  YD(  6)
     +    /  112.0D0, 118.0D0, 132.0D0, 129.0D0, 121.0D0, 135.0D0/
      DATA   YD(  7),  YD(  8),  YD(  9),  YD( 10),  YD( 11),  YD( 12)
     +    /  148.0D0, 148.0D0, 136.0D0, 119.0D0, 104.0D0, 118.0D0/
      DATA   YD( 13),  YD( 14),  YD( 15),  YD( 16),  YD( 17),  YD( 18)
     +    /  115.0D0, 126.0D0, 141.0D0, 135.0D0, 125.0D0, 149.0D0/
      DATA   YD( 19),  YD( 20),  YD( 21),  YD( 22),  YD( 23),  YD( 24)
     +    /  170.0D0, 170.0D0, 158.0D0, 133.0D0, 114.0D0, 140.0D0/
      DATA   YD( 25),  YD( 26),  YD( 27),  YD( 28),  YD( 29),  YD( 30)
     +    /  145.0D0, 150.0D0, 178.0D0, 163.0D0, 172.0D0, 178.0D0/
      DATA   YD( 31),  YD( 32),  YD( 33),  YD( 34),  YD( 35),  YD( 36)
     +    /  199.0D0, 199.0D0, 184.0D0, 162.0D0, 146.0D0, 166.0D0/
      DATA   YD( 37),  YD( 38),  YD( 39),  YD( 40),  YD( 41),  YD( 42)
     +    /  171.0D0, 180.0D0, 193.0D0, 181.0D0, 183.0D0, 218.0D0/
      DATA   YD( 43),  YD( 44),  YD( 45),  YD( 46),  YD( 47),  YD( 48)
     +    /  230.0D0, 242.0D0, 209.0D0, 191.0D0, 172.0D0, 194.0D0/
      DATA   YD( 49),  YD( 50),  YD( 51),  YD( 52),  YD( 53),  YD( 54)
     +    /  196.0D0, 196.0D0, 236.0D0, 235.0D0, 229.0D0, 243.0D0/
      DATA   YD( 55),  YD( 56),  YD( 57),  YD( 58),  YD( 59),  YD( 60)
     +    /  264.0D0, 272.0D0, 237.0D0, 211.0D0, 180.0D0, 201.0D0/
      DATA   YD( 61),  YD( 62),  YD( 63),  YD( 64),  YD( 65),  YD( 66)
     +    /  204.0D0, 188.0D0, 235.0D0, 227.0D0, 234.0D0, 264.0D0/
      DATA   YD( 67),  YD( 68),  YD( 69),  YD( 70),  YD( 71),  YD( 72)
     +    /  302.0D0, 293.0D0, 259.0D0, 229.0D0, 203.0D0, 229.0D0/
      DATA   YD( 73),  YD( 74),  YD( 75),  YD( 76),  YD( 77),  YD( 78)
     +    /  242.0D0, 233.0D0, 267.0D0, 269.0D0, 270.0D0, 315.0D0/
      DATA   YD( 79),  YD( 80),  YD( 81),  YD( 82),  YD( 83),  YD( 84)
     +    /  364.0D0, 347.0D0, 312.0D0, 274.0D0, 237.0D0, 278.0D0/
      DATA   YD( 85),  YD( 86),  YD( 87),  YD( 88),  YD( 89),  YD( 90)
     +    /  284.0D0, 277.0D0, 317.0D0, 313.0D0, 318.0D0, 374.0D0/
      DATA   YD( 91),  YD( 92),  YD( 93),  YD( 94),  YD( 95),  YD( 96)
     +    /  413.0D0, 405.0D0, 355.0D0, 306.0D0, 271.0D0, 306.0D0/
      DATA   YD( 97),  YD( 98),  YD( 99),  YD(100),  YD(101),  YD(102)
     +    /  315.0D0, 301.0D0, 356.0D0, 348.0D0, 355.0D0, 422.0D0/
      DATA   YD(103),  YD(104),  YD(105),  YD(106),  YD(107),  YD(108)
     +    /  465.0D0, 467.0D0, 404.0D0, 347.0D0, 305.0D0, 336.0D0/
      DATA   YD(109),  YD(110),  YD(111),  YD(112),  YD(113),  YD(114)
     +    /  340.0D0, 318.0D0, 362.0D0, 348.0D0, 363.0D0, 435.0D0/
      DATA   YD(115),  YD(116),  YD(117),  YD(118),  YD(119),  YD(120)
     +    /  491.0D0, 505.0D0, 404.0D0, 359.0D0, 310.0D0, 337.0D0/
      DATA   YD(121),  YD(122),  YD(123),  YD(124),  YD(125),  YD(126)
     +    /  360.0D0, 342.0D0, 406.0D0, 396.0D0, 420.0D0, 472.0D0/
      DATA   YD(127),  YD(128),  YD(129),  YD(130),  YD(131),  YD(132)
     +    /  548.0D0, 559.0D0, 463.0D0, 407.0D0, 362.0D0, 405.0D0/
      DATA   YD(133),  YD(134),  YD(135),  YD(136),  YD(137),  YD(138)
     +    /  417.0D0, 391.0D0, 419.0D0, 461.0D0, 472.0D0, 535.0D0/
      DATA   YD(139),  YD(140),  YD(141),  YD(142),  YD(143),  YD(144)
     +    /  622.0D0, 606.0D0, 508.0D0, 461.0D0, 390.0D0, 432.0D0/
!
      CALL IPRINT(IPRT)
      ITEST = 1
      LDSTAK = LDS
!
      N = 100
      LAGMAX = 20
      NPRT = 1
      LYFFT = 150
      LACOV = 21
      NYD = 144
      NFAC = 2
      ND(1) = 1
      ND(2) = 1
      IOD(1) = 12
      IOD(2) = 1
      YMISS = 1.16D0
!
!     TEST OF ACF
!
    5 WRITE (IPRT,1000)
      CALL ACF(Y, N)
      WRITE (IPRT,1010) IERR
!
!     TEST OF ACFS
!
      WRITE (IPRT,1020)
      CALL ACFS(Y, N, LAGMAX, LACOV, ACOV, IAR, PHI, NPRT, LDSTAK)
      WRITE (IPRT,1010) IERR
!
!     PRINT STORAGE FROM ACFS
!
      IF (IERR.EQ.0) THEN
        WRITE (IPRT,1030) (ACOV(I),I=1,LAGMAX+1)
        WRITE (IPRT,1030) (PHI(I),I=1,IAR)
      END IF
!
!     TEST OF ACFD
!
      WRITE (IPRT,1040)
      CALL ACFD(YD, NYD, LAGMAX, NFAC, ND, IOD, LDSTAK)
      WRITE (IPRT,1010) IERR
!
!     TEST OF ACFM
!
      WRITE (IPRT,1050)
      CALL ACFM(Y, YMISS, N)
      WRITE (IPRT,1010) IERR
!
!     TEST OF ACFMS
!
      WRITE (IPRT,1120)
      CALL ACFMS(Y, YMISS, N, LAGMAX, LACOV, ACOV, AMISS, NLPPA, NPRT,
     +   LDSTAK)
      WRITE (IPRT,1010) IERR
!
!     PRINT STORAGE FROM ACFMS
!
      IF (IERR.EQ.0) THEN
        WRITE (IPRT,1030) (ACOV(I),I=1,LAGMAX+1)
        WRITE (IPRT,1140) (NLPPA(I),I=1,LAGMAX+1)
      END IF
!
!     COPY DATA INTO YFFT FOR ACFF
!
      DO 10 I=1,N
         YFFT(I) = Y(I)
   10 CONTINUE
!
!     TEST OF ACFF
!
      WRITE (IPRT,1090)
      CALL ACFF(YFFT, N, LYFFT, LDSTAK)
      WRITE (IPRT,1010) IERR
!
!     COPY DATA INTO YFFT FOR ACFFS
!
      DO 20 I=1,N
         YFFT(I) = Y(I)
   20 CONTINUE
!
!     TEST OF ACFFS
!
      WRITE (IPRT,1130)
      CALL ACFFS(YFFT, N, LYFFT, LDSTAK, LAGMAX, LACOV, ACOV, IAR, PHI,
     +   NPRT)
      WRITE (IPRT,1010) IERR
!
!     PRINT STORAGE FROM ACFFS
!
      IF (IERR.EQ.0) THEN
        WRITE (IPRT,1030) (ACOV(I),I=1,LAGMAX+1)
        WRITE (IPRT,1030) (PHI(I),I=1,IAR)
      END IF
!
      GO TO (100, 200, 300, 400), ITEST
!
!     TEST MINIMUM PROBLEM SIZE
!
  100 ITEST = ITEST + 1
      N = 13
      LAGMAX = 1
      NFAC = 1
      ND(1) = 1
      IOD(1) = 1
      GO TO 5
!
!     CHECK ERROR HANDLING
!
  200 ITEST = ITEST + 1
      N = 0
      LAGMAX = 20
      LYFFT = 0
      LACOV = 0
      NYD = 0
      NFAC = 1
      ND(1) = 0
      IOD(1) = 0
      GO TO 5
!
!     CHECK ERROR HANDLING
!
  300 ITEST = ITEST + 1
      N = 100
      LAGMAX = 0
      LYFFT = 0
      LACOV = 0
      NYD = 144
      NFAC = 0
      LDSTAK = 0
      GO TO 5
!
  400 RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT ('1TEST OF ACF')
 1010 FORMAT (8H IERR IS, I5)
 1020 FORMAT ('1', 12HTEST OF ACFS)
 1030 FORMAT (9F10.5)
 1040 FORMAT ('1', 12HTEST OF ACFD)
 1050 FORMAT ('1', 12HTEST OF ACFM)
 1090 FORMAT ('1', 12HTEST OF ACFF)
 1120 FORMAT ('1', 13HTEST OF ACFMS)
 1130 FORMAT ('1', 13HTEST OF ACFFS)
 1140 FORMAT (9I10)
      END
!CCFOUT
      SUBROUTINE CCFOUT (J, YMEANJ, YSDJ, NJ, NUSEDJ, K, YMEANK, YSDK,
     +   NK, NUSEDK, LAGMAX, NCC, RHOC, SDRHOC, IFMISS, NLPP12,
     +   NLPP21, LCCOV, YMISSJ, YMISSK, NEWPG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRINTS THE CROSS CORRELATIONS AND THEIR
!     STANDARD ERRORS, AND MISCELLANEOUS SUMMARY INFORMATION.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMEANJ,YMEANK,YMISSJ,YMISSK,YSDJ,YSDK
      INTEGER
     +   J,K,LAGMAX,LCCOV,NCC,NJ,NK,NUSEDJ,NUSEDK
      LOGICAL
     +   IFMISS,NEWPG
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RHOC(*),SDRHOC(*)
      INTEGER
     +   NLPP12(*),NLPP21(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM,PMISSJ,PMISSK
      INTEGER
     +   IPRT,NMISSJ,NMISSK
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      INTEGER
     +   ISYM(1)
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CCFLST,IPRINT,VERSP,VPMN
!
!  INTRINSIC FUNCTIONS
      INTRINSIC DBLE
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     LOGICAL IFMISS
!        THE INDICATOR VARIABLE USED TO DETERMINE
!        WHETHER THE INPUT SERIES HAS MISSING DATA OR NOT.
!     INTEGER IPRT
!        THE UNIT NUMBER OF THE DEVICE USED FOR PRINTED
!        OUTPUT.
!     INTEGER ISYM(1)
!        A DUMMY ARRAY.
!     INTEGER J, K
!        THE SUBSCRIPT VALUES OF THE TWO SERIES BEING COMPARED.
!     INTEGER LAGMAX
!        THE LARGEST LAG VALUE TO BE USED.
!     INTEGER LCCOV
!        THE NUMBER OF LOCATIONS ALLOWED FOR STORING THE NLPPC.
!     INTEGER NCC
!        THE NUMBER OF CROSS CORRELATIONS COMPUTED (FROM -LAGMAX
!        TO +LAGMAX).
!     LOGICAL NEWPG
!        AN INDICATOR VARIABLE USED TO DETERMINE IF THE OUTPUT SHOULD
!        START ON A NEW PAGE.
!     INTEGER NJ, NK
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NLPP12(LCCOV), NLPP21(LCCOV)
!        THE NUMBER OF LAGGED PRODUCT PAIRS USED TO COMPUTE EACH
!        CCVF AT EACH LAG.
!     INTEGER NMISSJ, NMISSK
!        THE NUMBER OF MISSING VALUES IN EACH SERIES.
!     INTEGER NUSEDJ, NUSEDK
!        THE ACTIVE NUMBER OF OBSERVATIONS IN EACH SERIES.
!     DOUBLE PRECISION PMISSJ, PMISSK
!        THE PERCENT OF MISSING OBSERVATIONS.
!     DOUBLE PRECISION RHOC(NCC)
!        THE ARRAY IN WHICH THE CROSS CORRELATIONS ARE STORED
!     DOUBLE PRECISION SDRHOC(NCC)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!        ARE STORED
!     DOUBLE PRECISION YMEANJ, YMEANK
!        THE MEAN OF EACH OF THE SERIES.
!     DOUBLE PRECISION YMISSJ, YMISSK
!        THE MISSING VALUE CODE FOR EACH SERIES.
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE CROSS CORRELATIONS.
!     DOUBLE PRECISION YSDJ, YSDK
!        THE STANDARD DEVIAION OF EACH SERIES.
!
      FPLM = D1MACH(2)
!
      YMMISS(1) = FPLM
!
!     PRINT SUMMARY INFORMATION
!
      CALL IPRINT(IPRT)
!
      IF (NEWPG) WRITE (IPRT, 1004)
      CALL VERSP (.TRUE.)
      WRITE(IPRT, 1005)
!
      WRITE(IPRT, 1000) J, K, YMEANJ, YMEANK, YSDJ, YSDK, NJ, NK
      IF (.NOT. IFMISS) GO TO 10
      NMISSJ = NJ - NUSEDJ
      PMISSJ = 100.0D0 * NMISSJ / NJ
      NMISSK = NK - NUSEDK
      PMISSK = 100.0D0 * NMISSK / NK
      WRITE(IPRT, 1003) NMISSJ, NMISSK, PMISSJ, PMISSK
!
   10 WRITE(IPRT, 1006) LAGMAX
      IF (IFMISS) WRITE(IPRT, 1007) YMISSJ, YMISSK
!
      IF (YSDJ .GT. 0.0D0 .AND. YSDK .GT. 0.0D0) GO TO 20
      WRITE (IPRT, 1008) J, K
      RETURN
!
!     PRINT CCF INFORMATION
!
   20 CONTINUE
      WRITE(IPRT, 1002)
      WRITE (IPRT, 1001) J, K
      CALL CCFLST (RHOC, SDRHOC, NLPP12, NLPP21, LAGMAX, LCCOV, NCC,
     +   IFMISS)
!
!     PLOT CCF INFORMATION
!
      WRITE(IPRT, 1004)
      CALL VERSP (.TRUE.)
      WRITE (IPRT, 1001) J, K
      CALL VPMN(RHOC, YMMISS, 2*LAGMAX+1, 1, 2*LAGMAX+1, 1, 0,
     +   ISYM, 1, 0, -1.0D0, 1.0D0, DBLE(-LAGMAX), 1.0D0, IFMISS,
     +   0, 0, 1)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/ 42X, 7HSERIES , I2, 5X, 7HSERIES , I2//
     +   41H AVERAGE OF THE SERIES                 = , 2G14.7/
     +   41H STANDARD DEVIATION OF THE SERIES      = , 2G14.7/
     +   41H NUMBER OF TIME POINTS                 = , 2(I10, 4X))
 1001 FORMAT (42H CROSS CORRELATION FUNCTION ESTIMATE (CCF)//
     +   22H CCF CORRELATES SERIES , I2, 22H AT TIME T WITH SERIES , I2,
     +   15H AT TIME T + K./
     +   5X, 55H(IF PEAK CORRELATION OCCURES AT POSITIVE (NEGATIVE) LAG/
     +   8X, 36HTHEN SERIES 1 LEADS (LAGS) SERIES 2))
 1002 FORMAT(//)
 1003 FORMAT (
     +   41H NUMBER OF MISSING OBSERVATIONS        = , 2(I10, 4X)/
     +   41H PERCENTAGE OF OBSERVATIONS MISSING    = , 2(F10.4, 4X))
 1004 FORMAT ('1')
 1005 FORMAT ( 27H CROSS CORRELATION ANALYSIS)
 1006 FORMAT(/
     +   41H LARGEST LAG VALUE TO BE USED          = , I10)
 1007 FORMAT(
     +   41H MISSING VALUE CODE                    = , 2G14.7)
 1008 FORMAT (//35H CROSS CORRELATIONS BETWEEN SERIES , I2, 5H AND ,
     +   I2, 22H COULD NOT BE COMPUTED/
     +   54H BECAUSE THE LAG ZERO AUTOCOVARIANCE OF ONE OR BOTH OF/
     +   20H THE SERIES IS ZERO.)
      END
!RANDU
      DOUBLE PRECISION FUNCTION RANDU(JD)
!***BEGIN PROLOGUE  RANDU  (ORIGINALLY UNI)
!***DATE WRITTEN   810915
!***REVISION DATE  900315
!***CATEGORY NO.  L6A21
!***KEYWORDS  RANDOM NUMBERS, UNIFORM RANDOM NUMBERS
!***AUTHOR    BLUE, JAMES
!             KAHANER, DAVID
!             APPLIED AND COMPUTATIONAL MATHEMATICS DIVISTION, NIST
!
!             MARSAGLIA, GEORGE
!             COMPUTER SCIENCE DEPT., WASH STATE UNIV
!
!             MODIFIED BY -
!             DONALDSON, JANET
!             APPLIED AND COMPUTATIONAL MATHEMATICS DIVISTION, NIST
!
!***PURPOSE  THIS ROUTINE GENERATES QUASI UNIFORM RANDOM NUMBERS ON
!             (0,1] AND CAN BE USED ON ANY COMPUTER WHICH ALLOWS
!             INTEGERS AT LEAST AS LARGE AS 32767.
!***DESCRIPTION
!
!       THIS ROUTINE GENERATES QUASI UNIFORM RANDOM NUMBERS ON THE
!       INTERVAL (0,1].  IT CAN BE USED WITH ANY COMPUTER WHICH ALLOWS
!       INTEGERS AT LEAST AS LARGE AS 32767.
!
!
!   USE
!       FIRST TIME....
!                   Z = RANDU(JD)
!                     HERE JD IS ANY  N O N - Z E R O  INTEGER.
!                     THIS CAUSES INITIALIZATION OF THE PROGRAM
!                     AND THE FIRST RANDOM NUMBER TO BE RETURNED AS Z.
!       SUBSEQUENT TIMES...
!                   Z = RANDU(0)
!                     CAUSES THE NEXT RANDOM NUMBER TO BE RETURNED AS Z.
!
!
!===================================================================
!   NOTE: USERS WHO WISH TO TRANSPORT THIS PROGRAM FROM ONE COMPUTER
!         TO ANOTHER SHOULD READ THE FOLLOWING INFORMATION:
!
!   MACHINE DEPENDENCIES...
!      MDIG = A LOWER BOUND ON THE NUMBER OF BINARY DIGITS AVAILABLE
!              FOR REPRESENTING INTEGERS, INCLUDING THE SIGN BIT.
!              THIS VALUE MUST BE AT LEAST 16, BUT MAY BE INCREASED
!              IN LINE WITH REMARK A BELOW.
!
!   REMARKS...
!     A. THIS PROGRAM CAN BE USED IN TWO WAYS:
!        (1) TO OBTAIN REPEATABLE RESULTS ON DIFFERENT COMPUTERS,
!            SET 'MDIG' TO THE SMALLEST OF ITS VALUES ON EACH, OR,
!        (2) TO ALLOW THE LONGEST SEQUENCE OF RANDOM NUMBERS TO BE
!            GENERATED WITHOUT CYCLING (REPEATING) SET 'MDIG' TO THE
!            LARGEST POSSIBLE VALUE.
!     B. THE SEQUENCE OF NUMBERS GENERATED DEPENDS ON THE INITIAL
!          INPUT 'JD' AS WELL AS THE VALUE OF 'MDIG'.
!          IF MDIG=16 ONE SHOULD FIND THAT
!            THE FIRST EVALUATION
!              Z=RANDU(305) GIVES Z=.027832881...
!            THE SECOND EVALUATION
!              Z=RANDU(0) GIVES   Z=.56102176...
!            THE THIRD EVALUATION
!              Z=RANDU(0) GIVES   Z=.41456343...
!            THE THOUSANDTH EVALUATION
!              Z=RANDU(0) GIVES   Z=.19797357...
!
!***REFERENCES  MARSAGLIA G., "COMMENTS ON THE PERFECT UNIFORM RANDOM
!                 NUMBER GENERATOR", UNPUBLISHED NOTES, WASH S. U.
!***ROUTINES CALLED  I1MACH,XERROR
!***END PROLOGUE  RANDU
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   JD
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ONE,ZERO
      INTEGER
     +   I,J,J0,J1,JSEED,K,K0,K1,M1,M2,MDIG
!
!  LOCAL ARRAYS
      INTEGER
     +   M(17)
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   I1MACH
      EXTERNAL I1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL XERROR
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MIN,MOD,REAL
!
!  SAVE STATEMENT
      SAVE I,J,M,M1,M2
!
!
      DATA M(1),M(2),M(3),M(4),M(5),M(6),M(7),M(8),M(9),M(10),M(11),
     +     M(12),M(13),M(14),M(15),M(16),M(17)/30788,23052,2053,19346,
     +     10646,19427,23975,19049,10949,19693,29746,26748,2796,23890,
     +     29168,31924,16499/
      DATA M1,M2,I,J/32767,256,5,17/
      DATA ZERO,ONE /0.0D0,1.0D0/
!
!***FIRST EXECUTABLE STATEMENT  RANDU
      IF (JD.NE.0) THEN
!  FILL
          MDIG = I1MACH(8) + 1
!
!  MODIFICATION SO SAME NUMBERS WILL BE GENERATED ON ALL MACHINES
!  WITH I1MACH(8) AT LEAST 31
!
          MDIG = MIN(MDIG,32)
!
!  BE SURE THAT MDIG AT LEAST 16...
          IF (MDIG.LT.16) CALL XERROR('RANDU--MDIG LESS THAN 16',22,1,2)
          M1 = 2** (MDIG-2) + (2** (MDIG-2)-1)
          M2 = 2** (MDIG/2)
          JSEED = MIN(ABS(JD),M1)
          IF (MOD(JSEED,2).EQ.0) JSEED = JSEED - 1
          K0 = MOD(9069,M2)
          K1 = 9069/M2
          J0 = MOD(JSEED,M2)
          J1 = JSEED/M2
          DO 10 I = 1,17
              JSEED = J0*K0
              J1 = MOD(JSEED/M2+J0*K1+J1*K0,M2/2)
              J0 = MOD(JSEED,M2)
              M(I) = J0 + M2*J1
   10     CONTINUE
          I = 5
          J = 17
      END IF
!  BEGIN MAIN LOOP HERE
      K = M(I) - M(J)
      IF (K.LT.0) K = K + M1
      M(J) = K
      I = I - 1
      IF (I.EQ.0) I = 17
      J = J - 1
      IF (J.EQ.0) J = 17
      RANDU = DBLE(K)/DBLE(M1)
!
!  MODIFICATION SO RANDOM NUMBERS IN (0,1] RATHER THAN [0,1)
!
      IF (RANDU.EQ.ZERO) RANDU = ONE
      END
!AMEFIN
      SUBROUTINE AMEFIN(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, IFIXD,
     +   PAR, NPAR, NPARE, RES, PAGE, WIDE, IPTOUT, NDIGIT, RSSHLF, RSD,
     +   PVT, SDPVT, SDREST, RD, VCVL, LVCVL, D, AMEHDR, IVCVPT, ISKULL,
     +   NRESTS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPLETES THE ANALYSIS FOR THE NONLINEAR
!     LEAST SQUARES ESTIMATION ROUTINES ONCE THE ESTIMATES
!     HAVE BEEN FOUND.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD,RSSHLF
      INTEGER
     +   IVCVPT,IXM,LVCVL,LWT,M,N,NDIGIT,NNZW,NPAR,NPARE,NRESTS
      LOGICAL
     +   PAGE,WEIGHT,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,*),PAR(*),PVT(*),RD(*),RES(*),SDPVT(*),SDREST(*),VCVL(*),
     +   WT(*),XM(IXM,*),Y(*)
      INTEGER
     +   IFIXD(*),IPTOUT(*),ISKULL(10)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL AMEHDR
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   COND,RSS,YSS
      INTEGER
     +   I,IDF
      LOGICAL
     +   EXACT,PRTFSM
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMEOUT,NLCMP
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION COND
!        THE CONDITION NUMBER OF D.
!     DOUBLE PRECISION D(N,NPAR)
!        THE FIRST DERIVATIVE OF THE MODEL (JACOBIAN).
!     LOGICAL EXACT
!        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
!        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
!     EXTERNAL AMEHDR
!        THE ROUTINE USED TO PRINT THE HEADING
!     INTEGER IDF
!        THE DEGREES OF FREEDOM IN THE FIT.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IPTOUT(NDIGIT)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER ISKULL(10)
!        AN ERROR MESSAGE INDICATOR VARIABLE.
!     INTEGER IVCVPT
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
!        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
!        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)
!        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                       *INVERSE(HESSIAN)
!     INTEGER IXM
!        THE FIRST DIMENSION OF MATRIX XM.
!     INTEGER LVCVL
!        THE DIMENSION OF VECTOR VCVL.
!     INTEGER LWT
!        THE DIMENSION OF VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     LOGICAL PRTFSM
!        THE VARIABLE USED TO INDICATE WHETHER ANY OF THE SUMMARY
!        INFORMATION IS TO BE PRINTED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PVT(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
!     DOUBLE PRECISION RD(N)
!        THE DIAGONAL ELEMENTS OF THE R MATRIX OF THE Q - R
!        FACTORIZATION OF D.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     DOUBLE PRECISION RSS
!        THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION RSSHLF
!        HALF THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION SDPVT(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDREST(N)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION VCVL(LVCVL)
!        THE LOWER HALF OF THE VARIANCE-COVARIANCE MATRIX, STORED
!        ROW WISE.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!     DOUBLE PRECISION YSS
!        THE SUM OF THE SQUARES ABOUT THE MEAN Y VALUE.
!
!     MODIFY VCV TO REFLECT PROPER DEGREES OF FREEDOM
!
      DO 10 I=1,LVCVL
         VCVL(I) = (NRESTS-NPAR)*VCVL(I)/(N-NPAR)
   10 CONTINUE
!
!     COMPUTE RETURNED AND/OR PRINTED VALUES.
!
      CALL NLCMP (Y, WEIGHT, WT, LWT, N, NPAR, NPARE, RES,
     +   D, RD, COND, VCVL, LVCVL, NNZW, IDF, RSSHLF, RSS, RSD, YSS,
     +   EXACT, PVT, SDPVT, SDREST, ISKULL)
!
      PRTFSM = ((IPTOUT(3).NE.0) .OR. (IPTOUT(4).NE.0) .OR.
     +   (IPTOUT(5).NE.0) .OR. (IERR.NE.0))
!
!     PRINT SUMMARY INFORMATION IF DESIRED OR IF AN ERROR FLAG
!     HAS BEEN SET.
!
      IF (PRTFSM) CALL AMEOUT(Y, N,
     +   IFIXD, PAR, NPAR, NPARE, RES, IPTOUT, NDIGIT, PAGE, IDF, COND,
     +   RSS, RSD, YSS, EXACT, PVT, SDPVT, SDREST, VCVL, LVCVL, IVCVPT,
     +   ISKULL, AMEHDR, WIDE)
      RETURN
!
      END
!GFSLF
      SUBROUTINE GFSLF (H, K)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE
!     GAIN FUNCTION OF A SYMMETRIC LINEAR FILTER (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   K
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   H(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,FMAX,FMIN,YPLTMN,YPLTMX
      INTEGER
     +   IGFERR,IPRT,NF,NORD,NPRT
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD,SYM
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FREQ(101),GAIN(101),XORD(101),YORD(101)
      INTEGER
     +   ISORT(101)
      CHARACTER
     +   LH(8)*1,LK(8)*1,NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,ERIODD,ERSLF,GFORD,GFOUT,GFSEST,IPRINT,SETFRQ
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     LOGICAL ERR01, ERR02, ERR03
!        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION FMAX, FMIN
!        THE MINIMUM AND MAXIMUM FREQUENCY FOR WHICH THE GAIN
!        FUNCTION IS TO BE ESTIMATED.
!     DOUBLE PRECISION FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        HAS BEEN ESTIMATED.
!     DOUBLE PRECISION GAIN(101)
!        THE VECTOR IN WHICH THE GAIN FUNCTION ESTIMATES ARE
!        STORED.
!     DOUBLE PRECISION H(K)
!        THE ARRAY OF SYMMETRIC LINEAR FILTER COEFFICIENTS.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IGFERR
!        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
!        TO HAVE PRODUCED REASONABLE RESULTS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER ISORT(101)
!        THE ARRAY USED FOR SORTING.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS.
!     CHARACTER*1 LH(8), LK(8)
!        THE ARRAY CONTAINING THE NAME OF THE VARIABLES H AND K.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        IS TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NORD
!        THE NUMBER OF POINTS TO BE PLOTTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     LOGICAL SYM
!        THE VARIABLE USED TO INDICATE WHETHER THE GAIN FUNCTION
!        COMPUTED WAS FOR A SYMMETRIC OR AUTOREGRESSIVE FILTER.
!     DOUBLE PRECISION XORD(101)
!        THE X COORDINATES FOR THE GAIN FUNCTION PLOT
!     DOUBLE PRECISION YORD(101)
!        THE Y COORDINATES FOR THE GAIN FUNCTION PLOT
!     DOUBLE PRECISION YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'G',       'F',       'S',       'L',       'F',       ' '/
      DATA
     +  LH(1), LH(2), LH(3), LH(4), LH(5), LH(6), LH(7), LH(8)
     + /  'H',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LK, K, 1, 1, HEAD, ERR01, LK)
!
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR02)
!
      IF ((.NOT. ERR01) .AND. (.NOT. ERR02)) THEN
         CALL ERSLF(NMSUB, LH, K, H, HEAD, ERR03)
      ELSE
         ERR03 = .FALSE.
      END IF
!
      IF (ERR01 .OR. ERR02 .OR. ERR03) GO TO 10
      GO TO 20
!
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   20 CONTINUE
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      SYM = .TRUE.
      NF = 101
!
      FMIN = 0.0D0
      FMAX = 0.5D0
!
      DELTA = 1.0D0
!
      NPRT = -1
!
!     SET FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO BE ESTIMATED
!
      CALL SETFRQ (FREQ, NF, NPRT, FMIN, FMAX, DELTA)
!
!     COMPUTE THE GAIN FUNCTION
!
      CALL GFSEST (H, K, NF, FREQ, GAIN, DELTA)
!
!     PLOT THE RESULTS
!
      CALL GFORD (FREQ, GAIN, ISORT, NF, XORD, YORD, NORD,
     +   YPLTMN, YPLTMX, NPRT, IGFERR)
!
      CALL GFOUT (XORD, YORD, NORD, FREQ, GAIN, NF, K,
     +   SYM, FMIN, FMAX, YPLTMN, YPLTMX, NPRT, IGFERR, NMSUB)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   24H       CALL GFSLF (H, K))
      END
!SPPLTD
      SUBROUTINE SPPLTD (SPCMN, SPCMX, ALOW, AUP, YPLTMN, YPLTMX,
     +   CILOW, CIMID, CIUP, YMAX)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SETS VARIOUS Y AXIS LIMITS FOR DECIBLE
!     SPECTRUM PLOTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALOW,AUP,CILOW,CIMID,CIUP,SPCMN,SPCMX,YMAX,YPLTMN,YPLTMX
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RNGMN,YMIN
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,LOG10
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALOW, AUP
!        FACTORS USED TO COMPUTE THE CONFIDENCE INTERVALS.
!     DOUBLE PRECISION CILOW, CIMID, CIUP
!        THE Y CORDNATES FOR THE LOWER  MID AND UPPER CONFIDENCE
!        INTERVAL POINTS.
!     DOUBLE PRECISION RNGMN
!        THE MINIMUM Y AXIS RANGE FOR THE PLOT.
!     DOUBLE PRECISION SPCMN, SPCMX
!        THE MINIMUM AND MAXIMUM SPECTRAL VALUE TO BE PLOTTED.
!     DOUBLE PRECISION YMAX, YMIN
!        THE MAXIMUM AND MINIMUM ACTUAL SPECTRAL VALUE
!        (IN DECIBELS) TO BE PLOTTED.
!     DOUBLE PRECISION YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VAUES TO BE PLOTTED FOR THE Y AXIS.
!
!     SET CO-ORDINATES FOR DECIBLE PLOTS
!
      YMAX = 10.0D0 * LOG10(SPCMX)
      YMIN = 10.0D0 * LOG10(SPCMN) - YMAX
!
      YPLTMX = 0.0D0
      RNGMN = 20.0D0 * (LOG10(AUP) - LOG10(ALOW))
      IF (ABS(YMIN) .LT. RNGMN) YPLTMX = (RNGMN + YMIN) * 0.5D0
      YPLTMN = YMIN - YPLTMX
      CIUP = YPLTMX
      CIMID = CIUP - 10.0D0 * LOG10(AUP)
      CILOW = CIMID + 10.0D0 * LOG10(ALOW)
!
      RETURN
      END
!MVPML
      SUBROUTINE MVPML(YM, YMMISS, N, M, IYM, NS, ILOG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA AND MULTIPLE Y-AXIS VALUES
!     (LOG PLOT OPTION).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,IYM,M,N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,IPRT,IRLIN,ISCHCK,ISIZE,LISYM
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(M)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'V',       'P',       'M',       'L',       ' '/
!
!     SET DEFAULT VALUES
!
      MULTI = .TRUE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 2
      ISIZE = -1
      MISS = .TRUE.
      LISYM = 1
      IRLIN = -1
      IBAR = 0
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL MVPML (YM, YMMISS, N, M, IYM, NS, ILOG)')
      END
!SETFRQ
      SUBROUTINE SETFRQ (FREQ, NF, NPRT, FMIN, FMAX, H)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE FREQUENCIES AT WHICH THE
!     SPECTRUM IS TO BE ESTIMATED.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN,H
      INTEGER
     +   NF,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTAF
      INTEGER
     +   I
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG10
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTAF
!        THE FREQUENCY INCREMENT.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCIES AT WHICH THE
!        SPECTRUM IS TO BE ESTIMATED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     DOUBLE PRECISION H
!        THE SAMPLING INTERVAL.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
!        ARE TO BE ESTIMATED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT EQUALS 2 THE FREQUENCY SCALE IS LINEAR, AND IF
!        NPRT EQUALS 3 THE FREQUENCY SCALE IS LOG.
!
      IF (NPRT .EQ. 3) GO TO 20
!
!     COMPUTE FREQUENCY VALUES FOR LINEAR SCALE
!
      FREQ(1) = FMIN
!
      IF (NF .EQ. 1) RETURN
!
      DELTAF = (FMAX - FMIN) / (H * (NF - 1))
      DO 10 I = 2, NF
         FREQ(I) = FREQ(I-1) + DELTAF
   10 CONTINUE
!
      FREQ(NF) = FMAX
      RETURN
!
   20 CONTINUE
!
!     COMPUTE FREQUENCY VALUES FOR LOG SCALE
!
      DELTAF = (LOG10(FMAX) - LOG10(FMIN)) / (H * (NF - 1))
!
      FREQ(1) = FMIN
!
      IF (NF .EQ. 1) RETURN
!
      DO 30 I = 2, NF
         FREQ(I) = 10.0D0**(LOG10(FREQ(I-1)) + DELTAF)
   30 CONTINUE
!
      FREQ(NF) = FMAX
!
!
      RETURN
      END
!CCFMN
      SUBROUTINE CCFMN (Y1, Y2, N, LAGMAX, NCC, CCOV11, CCOV22, CCOV12,
     +   CCOV21, LCCOV, Y1MEAN, Y2MEAN, RHOC, SDRHOC, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING CROSS CORRELATIONS AND
!     THEIR STANDARD ERRORS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   Y1MEAN,Y2MEAN
      INTEGER
     +   LAGMAX,LCCOV,N,NCC,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV11(LCCOV),CCOV12(LCCOV),CCOV21(LCCOV),CCOV22(LCCOV),
     +   RHOC(NCC),SDRHOC(NCC),Y1(N),Y2(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FAC
      INTEGER
     +   I,I0,IM,IP
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CCFSD,CCVF
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCOV11(LCCOV)
!        THE ARRAY IN WHICH THE AUTOCOVARIANCE FUNCTION ESTIMATES
!        FOR THE FIRST SERIES IS STORED.
!     DOUBLE PRECISION CCOV12(LCCOV), CCOV21(LCCOV)
!        THE ARRAYS IN WHICH THE CROSS COVARIANCE FUNCTION
!        ESTIMATES FOR THE FIRST SERIES LAGGED BEHIND THE SECOND
!        AND VISA VERSA, ARE STORED.
!     DOUBLE PRECISION CCOV22(LCCOV)
!        THE ARRAY IN WHICH THE AUTOCOVARIANCE FUNCTION ESTIMATES
!        FOR THE SECOND SERIES IS STORED.
!     DOUBLE PRECISION FAC
!        THE INVERSE OF THE SQUARE ROOT OF THE PRODUCT OF THE
!        AUTOCOVARIANCES AT LAG ZERO.
!     INTEGER I
!        THE INDEXING VARIABLE FOR THE LAG VALUE.
!     INTEGER  IM, IP, I0
!        THE LOCATIONS IN THE CCF RELATED ARRAYS
!        OF THE LAG -I, I, AND 0, RESPECTIVELY.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE AT WHICH THE CCVF IS TO BE COMPUTED.
!     INTEGER LCCOV
!        THE DIMENSION OF THE COVARIANCE RELATED ARRAYS.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NCC
!        THE NUMBER OF CCF COMPUTED.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO CONTROL COMPUTATIONS NEEDED
!        ONLY FOR PRINTED OUTPUT.
!     DOUBLE PRECISION RHOC(NCC)
!        THE ARRAY IN WHICH THE CROSS CORRELATIONS ARE STORED
!     DOUBLE PRECISION SDRHOC(NCC)
!        THE ARRAY CONTAINING THE STD. ERRORS OF THE CROSS CORRELATIONS.
!        ARE STORED
!     DOUBLE PRECISION Y1(N), Y1MEAN
!        THE FIRST SERIES, AND ITS MEAN.
!     DOUBLE PRECISION Y2(N), Y2MEAN
!        THE SECOND SERIES, AND ITS MEAN.
!
!     COMPUTE THE CROSS CORRELATIONS.
!
      CALL CCVF(Y1, Y2, N, LAGMAX, Y1MEAN, Y2MEAN, CCOV12, CCOV21,
     +   LCCOV)
!
      IF (NPRT .EQ. 0 .OR. CCOV11(1)*CCOV22(1) .EQ. 0.0D0) RETURN
!
      FAC = 1.0D0 / SQRT(CCOV11(1) * CCOV22(1))
!
      I0 = LAGMAX + 1
      RHOC(I0) = CCOV12(1) * FAC
      DO 10 I = 1, LAGMAX
         IP = I0 + I
         RHOC(IP) = CCOV12(I+1) * FAC
!
         IM = I0 - I
         RHOC(IM) = CCOV21(I+1) * FAC
   10 CONTINUE
!
!     COMPUTE STANDARD ERROR OF THE CROSSCORRELATIONS.
!
      CALL CCFSD (CCOV11, CCOV22, SDRHOC, LAGMAX, NCC, N, LCCOV)
!
      RETURN
      END
!IPGDV
      SUBROUTINE IPGDV (PER, NF, N, PERI, FREQ, XAXIS, YAXIS, ISYM,
     +   LPCV, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES CO-ORDINATES FOR THE SPECTRAL PLOTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LPCV,N,NF,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),PER(NF),PERI(NF),XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISYM(LPCV)
!
!  LOCAL SCALARS
      INTEGER
     +   ISPCER,NPTS
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPGMN,IPGORD,IPGOUT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION FREQ(NF)
!        THE ARRAY IN WHICH THE FREQUENCIES AT WHICH THE PERIODOGRAM
!        WAS ESTIMATED ARE STORED.
!     INTEGER ISPCER
!        AN ERROR INDICATOR FOR THE INTEGRATED PERIODOGRAM COMPUTATIONS.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER N
!        THE ACTUAL NUMBER OF OBSERVATIONS IN THE SERIES FROM WHICH
!        THE PERIODOGRAM WAS COMPUTED.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A PAGE PLOT.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
!        ARE ESTIMATED.
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     DOUBLE PRECISION PER(NF)
!        THE RAW PERIODOGRAM.
!     DOUBLE PRECISION PERI(NF)
!        THE ARRAY CONTAINING THE INTEGRATED PERIODOGRAM VALUES.
!     DOUBLE PRECISION XAXIS(LPCV), YAXIS(LPCV)
!        THE X, Y CO-ORDINATES FOR THE SPECTRAL PLOTS.
!
!     COMPUTE THE INTEGRATED PERIODOGRAM
!
      CALL IPGMN(PER, NF, PERI, ISPCER)
!
      IF (ISPCER .NE. 0) GO TO 10
!
      IF (NPRT .EQ. 0) RETURN
!
!     SET CO-ORDINATES FOR THE INTEGRATED PERIODOGRAM
!
      CALL IPGORD(PERI, NF, N, FREQ, XAXIS, YAXIS, ISYM, NPTS, LPCV)
!
!     PLOT THE INTEGRATED PERIODOGRAM
!
   10 CALL IPGOUT (XAXIS, YAXIS, ISYM, NPTS, LPCV, ISPCER)
!
      RETURN
!
      END
!DCKMN
      SUBROUTINE DCKMN(J, D, PAR, SCALE, NPAR, ETA, TAU, MDL, XM,
     +   N, NROW, M, IXM, PV, PVTEMP, MSG, LMSG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR CHECKING USER SUPPLIED
!     ANALYTIC DERIVATIVES AGAINST NUMERICAL DERIVATIVES
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   D,ETA,PV,SCALE,TAU
      INTEGER
     +   IXM,J,LMSG,M,N,NPAR,NROW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PVTEMP(N),XM(IXM,M)
      INTEGER
     +   MSG(LMSG)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FD,PARMX,PVPSTP,STP,TEMP
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DCKCRV,DCKZRO
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,SIGN,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION D
!        THE SCALAR IN WHICH ROW   NROW   OF THE DERIVATIVE
!        MATRIX WITH RESPECT TO THE JTH UNKNOWN PARAMETER
!        IS STORED.
!     DOUBLE PRECISION ETA
!        THE RELATIVE NOISE IN THE MODEL
!     DOUBLE PRECISION FD
!        THE FORWARD DIFFERENCE QUOTIENT DERIVATIVE WITH RESPECT TO THE
!        JTH PARAMETER
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARTIAL DERIVATIVE BEING EXAMINED.
!     INTEGER LMSG
!        THE LENGTH OF THE VECTOR MSG.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER MSG(LMSG)
!        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION PARMX
!        THE MAXIMUM OF THE CURRENT PARAMETER ESTIMATE AND THE
!        TYPICAL VALUE OF THAT PARAMETER
!     DOUBLE PRECISION PV
!        THE SCALAR IN WHICH THE PREDICTED VALUE FROM THE MODEL FOR
!        ROW   NROW   IS STORED.
!     DOUBLE PRECISION PVPSTP
!        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
!        BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J) + STP.
!     DOUBLE PRECISION PVTEMP(N)
!        THE VECTOR OF PREDICTED VALUE FROM THE MODEL.
!     DOUBLE PRECISION SCALE
!        THE TYPICAL SIZE OF THE JTH PARAMETER.
!     DOUBLE PRECISION STP
!        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FINITE DIFFERENC
!        DERIVATIVE
!     DOUBLE PRECISION TAU
!        THE AGREEMENT TOLERANCE.
!     DOUBLE PRECISION TEMP
!        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
!        PARAMETER IS STORED.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
!     CALCULATE THE JTH PARTIAL DERIVATIVE USING FORWARD DIFFERENCE
!     QUOTIENTS AND DECIDE IF IT AGREES WITH USER SUPPLIED VALUES
!
      MSG(J+1) = 0
!
      PARMX = MAX(ABS(PAR(J)),ABS(SCALE))
      IF (PARMX .EQ. 0.0D0) PARMX = 1.0D0
!
!     COMPUTE INITIAL STEP SIZE
!
      STP = (SQRT(ETA)*PARMX*SIGN(1.0D0,PAR(J))+PAR(J)) - PAR(J)
!
!     COMPUTE PREDICTED VALUES
!
      TEMP = PAR(J)
      PAR(J) = PAR(J) + STP
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVTEMP)
      PAR(J) = TEMP
!
      PVPSTP = PVTEMP(NROW)
!
      FD = (PVPSTP-PV)/STP
!
!     CHECK FOR DISAGREEMENT
!
      IF (ABS(FD-D) .GT. TAU*ABS(D)) GO TO 10
!
!     NUMERICAL AND ANALYTIC DERIVATIVES AGREE
!
!     CHECK IF ANALYTIC DERIVATIVE IS IDENTICALLY ZERO, INDICATING
!     THE POSSIBILITY THAT THE DERIVATIVE SHOULD BE RECHECKED AT
!     ANOTHER POINT.
!
      IF (D.NE.0.0D0) RETURN
!
!     JTH ANALYTIC AND NUMERICAL DERIVATIVES BOTH ARE ZERO.
!
      IF (MSG(1).EQ.0) MSG(1) = 1
      MSG(J+1) = 3
      RETURN
!
   10 CONTINUE
!
!     NUMERICAL AND ANALYTIC DERIVATIVES DISAGREE
!
!     CHECK WHY
!
      IF (D.EQ.0.0D0) THEN
         CALL DCKZRO(J, PAR, NPAR, MDL, XM, N,
     +      NROW, M, IXM, PV, PVTEMP, MSG, LMSG, FD, PARMX, PVPSTP,
     +      STP)
      ELSE
         CALL DCKCRV(J, D, PAR, NPAR, ETA, TAU, MDL, XM,
     +      N, NROW, M, IXM, PV, PVTEMP, MSG, LMSG, FD, PARMX,
     +      PVPSTP, STP)
      END IF
!
      RETURN
      END
!ACFMS
      SUBROUTINE ACFMS (Y, YMISS, N, LAGMAX, LACOV, ACOV, AMISS, NLPPA,
     +   NPRT, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
!     CORRELATIONS OF A TIME SERIES WITH MISSING VALUES (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   AMISS,YMISS
      INTEGER
     +   LACOV,LAGMAX,LDSTAK,N,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),Y(*)
      INTEGER
     +   NLPPA(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CHIA,CHIAP,FPLM,OSPVAR,YMEAN,YSD
      INTEGER
     +   AIC,FTEST,I,IAR,IFP,IPRT,LAGLST,LDSMIN,LYFFT,NALL0,NFAC,
     +   NFFT,PHI,PRHO,SDRHO,WORK
      LOGICAL
     +   DIFFER,ISFFT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   IOD(1),ND(1),NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      INTEGER
     +   STKGET,STKST
      EXTERNAL D1MACH,STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACFER,ACFMNM,ACFOUT,IPRINT,LDSCMP,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV)
!        THE AUTOCOVARIANCE VECTOR.
!     INTEGER AIC
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE AKAIKES CRITERION FOR EACH ORDER.
!     DOUBLE PRECISION AMISS
!        THE MISSING VALUE CODE FOR THE RETURNED ACVF ESTIMATES
!        (VECTOR ACOV).
!     DOUBLE PRECISION CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     LOGICAL DIFFER
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER FTEST
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE PARTIAL F RATIO AND PROBABILITIES
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!     INTEGER IFP
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE FLOATING
!        POINT VARIABLES ARE SINGLE (IFP=3) OR DOUBLE (IFP=4) PRECISION.
!     INTEGER IOD(1)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGLST
!        THE LAST LAG BEFORE MISSING DATA CAUSED THE ACVF OF THE
!        SERIES NOT TO BE COMPUTED.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     INTEGER ND(1)
!        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
!     INTEGER NDUM(1)
!        A DUMMY ARRAY.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NLPPA(LACOV)
!        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
!        USED TO COMPUTE EACH ACVF ESTIMATE.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     DOUBLE PRECISION OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
!     INTEGER PHI
!        THE STARTING LOCATION IN DSTAK FOR THE
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     INTEGER PRHO
!        THE STARTING LOCATION IN THE WORK AREA FOR PRHO.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SDRHO
!        THE STARTING LOCATION IN THE WORK AREA FOR SDRHO.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR WORK.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER
!        OR NOT AN OBSERVATION IN THE SERIES IS MISSING.
!        IF Y(I) .EQ. YMISS, THE VALUE IS ASSUMED MISSING.
!        IF Y(I) .NE. YMISS, THE VALUE IS ASSUMED NOT MISSING.
!     DOUBLE PRECISION YSD
!        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'A',       'C',       'F',       'M',       'S',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      DIFFER = .FALSE.
      NFAC = 1
      ND(1) = 0
      IOD(1) = 0
      ISFFT = .FALSE.
      LYFFT = N
      NFFT = N
!
      IF (NPRT .EQ. 0) THEN
        LDSMIN = 0
      ELSE
        CALL LDSCMP(5, 0, 0, 0, 0, 0, 'D', 6*LAGMAX+1, LDSMIN)
      END IF
!
      CALL ACFER(NMSUB, N, LAGMAX, LACOV, LDSTAK, LDSMIN,
     +  DIFFER, NFAC, ND, IOD, ISFFT, LYFFT, NFFT)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      IF (IERR.EQ.0) THEN
!
!       SET UP THE WORK AREA.
!
        CALL STKSET(LDSTAK, 4)
        NALL0 = STKST(1)
!
        FPLM = D1MACH(2)
!
        AMISS = FPLM
!
        IF (NPRT.EQ.0) THEN
!
!         SPECIFY STARTING LOCATIONS IN THE STACK FOR DUMMY VARIABLES
!
          PRHO = 1
          AIC = 1
          FTEST = 1
          PHI = 1
          WORK = 1
          SDRHO = 1
        ELSE
!
          IFP = 4
!
          PRHO = STKGET(LAGMAX, IFP)
          AIC = STKGET(LAGMAX+1, IFP)
          FTEST = STKGET(2*LAGMAX, IFP)
          PHI = STKGET(LAGMAX, IFP)
          WORK = STKGET(LAGMAX, IFP)
          SDRHO = WORK
        END IF
!
        IF (IERR.EQ.0) THEN
!
!         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
          CALL ACFMNM (Y, YMISS, N, LAGMAX, ACOV(2), RSTAK(SDRHO),
     +       NLPPA, YMEAN, RSTAK(PRHO), RSTAK(AIC), RSTAK(FTEST),
     +       RSTAK(PHI), IAR, OSPVAR, ACOV, LACOV, LAGMAX+1, CHIA,
     +       CHIAP, LAGLST, RSTAK(WORK), NPRT)
!
          IF (LAGLST .GE. 0) THEN
            YSD = SQRT (ACOV(1) * N / (N - 1))
          ELSE
            YSD = ACOV(1)
          END IF
!
!           CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
          IF ((NPRT.NE.0) .OR. (ACOV(1).EQ.0.0D0))
     +      CALL ACFOUT (YMEAN, YSD, N, NLPPA(1), LAGMAX, ACOV(2),
     +         RSTAK(SDRHO), RSTAK(PRHO), NLPPA, RSTAK(AIC), LAGMAX+1,
     +         RSTAK(FTEST), IAR, RSTAK(PHI), OSPVAR, CHIA, CHIAP,
     +         LAGLST, .TRUE., YMISS, .FALSE., .FALSE., 0, NDUM, NDUM,
     +         0)
!
          IF (NPRT.NE.0) THEN
            DO 50 I = 1, LAGMAX
               ACOV(I+1) = ACOV(I+1) * ACOV(1)
   50       CONTINUE
          END IF
        END IF
!
        CALL STKCLR(NALL0)
      END IF
!
      IF (IERR.NE.0) THEN
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL ACFMS (Y, YMISS, N,'/
     +  '      +            LAGMAX, LACOV, ACOV, AMISS, NLPPA, NPRT,',
     +  ' LDSTAK)')
      END
!AMEPT2
      SUBROUTINE AMEPT2 (RES, SDREST, N, RSS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE, ADAPTED FROM OMNITAB II, PRINTS
!     THE FOUR STANDARDIZED RESIDUAL PLOTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RES(*),SDREST(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   AN,DOT,FAC1,FAC2,FPLM,GAMMA,PI,RATIO,ROWDIV,ROWMAX,ROWMID,
     +   ROWMIN,XDIV,XMAX,XMIN,YLABEL,YMAX,YMIN
      INTEGER
     +   I,I1,I2,IMID,IPLOT,IPRB,IPRT,IROW,IX,K,L,NCOL,NCOLP1,
     +   NCOLPL,NCOLT2,NDOT,NROW
      CHARACTER
     +   IBLANK*1,IMINUS*1,IPLUS*1,ISTAR*1
!
!  LOCAL ARRAYS
      CHARACTER
     +   LINE(113)*1
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      LOGICAL
     +   MVCHK
      EXTERNAL D1MACH,MVCHK
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DOTC,GETPI,IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC INT,MAX,MIN,MOD
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AN
!        THE NUMBER OF OBSERVATIONS, USED IN COMPUTING
!        THE NORMAL PROBABILITY PLOT.
!     DOUBLE PRECISION DOT
!        THE DOT PRODUCT USED TO COMPUTE THE CORRELATION COEFFICIENT.
!     DOUBLE PRECISION FAC1, FAC2
!        FACTORS USED IN COMPUTING THE NORMAL PROBABILITY PLOT.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     DOUBLE PRECISION GAMMA
!        A VALUE USED IN COMPUTING THE NORMAL PROBABILITY PLOT.
!     INTEGER I
!        AN INDEX VARIABLE.
!     CHARACTER*1 IBLANK
!        THE VALUE OF THE CHARACTER -BLANK-.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IMID
!        THE MIDPOINT OF THE AUTOCORRELATION PLOT.
!     CHARACTER*1 IMINUS
!        THE CHARACTER MINUS.
!     INTEGER IPLOT
!        AN INDICATOR VARIABLE DESIGNATING WHETHER THE FIRST OR
!        SECOND SET OF TWO PLOTS ARE BEING PRINTED.
!     CHARACTER*1 IPLUS
!        THE CHARACTER PLUS.
!     INTEGER IPRB
!        THE LOCATION IN THE PLOT STRING OF THE SYMBOL FOR THE
!        PROBABILITY PLOT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IROW
!        THE ROW OF THE VARIABLES BEING PLOTTED.
!     CHARACTER*1 ISTAR
!        THE CHARACTER STAR.
!     INTEGER IX
!        THE LOCATION IN THE PLOT STRING OF THE SYMBOL FOR THE PLOTS
!        VERSUS THE INDEPENDENT VARIABLE.
!     INTEGER I1, I2
!        INDEX VALUES.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER L
!        AN INDEX VARIABLE.
!     CHARACTER*1 LINE(113)
!        THE SYMBOLS (BLANKS AND CHARACTERS) FOR A GIVEN LINE
!        OF THE PLOT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NCOL, NCOLPL, NCOLP1, NCOLT2
!        THE NUMBER OF COLUMNS IN THE PLOT, NCOL+L, NCOL+1,
!        AND NCOL * 2.
!     INTEGER NDOT
!        THE NUMBER OF POINTS MAKING UP DOT.
!     INTEGER NROW
!        THE NUMBER OF COLUMNS IN THE PLOT.
!     DOUBLE PRECISION PI
!        THE VALUE OF PI.
!     DOUBLE PRECISION RATIO
!        A VALUE USED TO PRODUCE THE NORMAL PROBABILITY PLOT.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION ROWDIV
!        THE VALUE OF A DIVISION ALONG THE -ROW- AXIS.
!     DOUBLE PRECISION ROWMAX
!        THE LARGEST ROW VALUE.
!     DOUBLE PRECISION ROWMID
!        THE MIDPOINT OF THE RANGE OF THE ROWS PLOTTED.
!     DOUBLE PRECISION ROWMIN
!        THE SMALLEST ROW VALUE PLOTTED.
!     DOUBLE PRECISION RSS
!        THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION SDREST(N)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION XDIV
!        THE VALUE OF A DIVISION ALONG THE X AXIS.
!     DOUBLE PRECISION XMAX
!        THE LARGEST VALUE ALONG THE X AXIS.
!     DOUBLE PRECISION XMIN
!        THE SMALLEST VALUE ALONG THE X AXIS.
!     DOUBLE PRECISION YLABEL
!        THE LABEL TO BE PRINTED ALONG THE Y AXIS.
!     DOUBLE PRECISION YMAX
!        THE LARGEST VALUE ALONG THE Y AXIS
!     DOUBLE PRECISION YMIN
!        THE SMALLEST VALUE ALONG THE Y AXIS.
!
      DATA IPLUS/'+'/, IMINUS/'-'/, ISTAR/'*'/, IBLANK/' '/
!
      CALL IPRINT(IPRT)
!
      FPLM = D1MACH(2)
!
!     CHECK FOR INSUFFICIENT POINTS TO PLOT
!
      IF (IERR.NE.4) GO TO 20
      DO 10 I = 1, N
         IF (SDREST(I).NE.FPLM) GO TO 20
   10 CONTINUE
      WRITE (IPRT, 1090)
      RETURN
!
   20 CONTINUE
!
!     INITIALIZE VALUES FOR PROBABILITY PLOT
!
      CALL GETPI(PI)
      GAMMA = PI/8.0D0
      AN = N
      FAC1 = 1.0D0 / (AN - 2.0D0*GAMMA + 1.0D0)
      FAC2 = 10.0D0
!
!     INITIALIZE THE PLOT SIZE (IN PLOT UNITS)
!
      NROW = 26
!
!     BEGIN COMPUTATIONS FOR FIRST SET OF PLOTS
!
      IPLOT = 1
      NCOL = 111
!
!     SET X AXIS LIMITS FOR STANDARDIZED RESIDUAL VS ROW PLOT,
!
      ROWMIN = 1
      ROWMAX = N
!
      ROWMID = (ROWMAX+ROWMIN)/2.0D0
      ROWDIV = (ROWMAX-ROWMIN)/(NCOL-1)
!
!     PRINT TITLES FOR FIRST PLOTS
!
      WRITE (IPRT,1000)
      GO TO 90
!
!     BEGIN COMPUTATIONS FOR SECOND SET OF PLOTS
!
   40 IPLOT = 2
      NCOL = 51
!
!     SET AXIS LIMITS FOR THE STANDARDIZED RESIDUALS VS
!     STANDARDIZED RESIDUALS LAGGED BY ONE AND FOR PROBABILITY PLOT
!
      XMIN = -3.75D0
      XMAX = 3.75D0
      XDIV = (XMAX-XMIN)/(NCOL-1)
!
!     PRINT TITLES FOR SECOND PLOTS
!
      WRITE (IPRT,1050)
!
!     WRITE FIRST LINE OF PLOTS
!
   90 CONTINUE
!
!     PRINT PLOTS, ONE LINE AT A TIME
!
      NCOLP1 = NCOL + 1
      NCOLT2 = 2*NCOL
      YLABEL = 3.75D0
      YMAX = FPLM
      YMIN = 4.05D0
      DO 160 K=1,NROW
         YMIN = YMIN - 0.3D0
         IF (-3.70D0.GE.YMIN) YMIN = -FPLM
         DO 100 L=1,NCOL
            NCOLPL = L + NCOL
            LINE(L) = IBLANK
            IF (IPLOT.EQ.2) LINE(NCOLPL) = IBLANK
            IF ((K.NE.1) .AND. (K.NE.NROW)) GO TO 100
               LINE(L) = IMINUS
               IF (IPLOT.EQ.2) LINE(NCOLPL) = IMINUS
               IF ((MOD(L,10).NE.1) .AND. (L.NE.1+NCOL/2)) GO TO 100
                  LINE(L) = IPLUS
                  IF (IPLOT.EQ.2) LINE(NCOLPL) = IPLUS
  100    CONTINUE
         DO 130 I=1,N
            IF (.NOT.MVCHK(SDREST(I),FPLM)) THEN
               IF ((SDREST(I).GT.YMIN) .AND. (SDREST(I).LE.YMAX)) THEN
                  IF (IPLOT.EQ.1) THEN
                      IROW = INT(((I-ROWMIN)/ROWDIV)+1.5D0)
                      LINE(IROW) = ISTAR
                   ELSE
                      RATIO = (AN-GAMMA) * FAC1
                      IPRB = INT(4.91D0*(RATIO**0.14D0-
     +                          (1.0D0-RATIO)**0.14D0)*FAC2) + 77
                      IF (IPRB.LE.NCOL) IPRB = NCOL+1
                      IF (IPRB.GE.103) IPRB = 102
                      LINE(IPRB) = ISTAR
                      AN = AN - 1.0D0
                      IF ((AN.LT.2.0D0) .AND. (N.LE.10)) THEN
                         GAMMA = 1.0D0/3.0D0
                      END IF
                   END IF
                END IF
             END IF
  130    CONTINUE
!
!     SET PLOT LINE FOR CORRELATION PLOT OF SECOND SET OF PLOTS
!
         IF (IPLOT.EQ.2) THEN
            IMID = (NCOL-1)/2
            IF (K.LE.N-1) THEN
               DOT = 0.0D0
               CALL DOTC(RES, 0.0D0, N, RES(K+1), 0.0D0,
     +                   N-K, DOT, NDOT)
               IX = INT(IMID*DOT/RSS) + IMID + 1
               I1 = MIN(IX,IMID+1)
               I2 = MAX(IX,IMID+1)
               DO 135 IX=I1,I2
                  LINE(IX) = ISTAR
  135          CONTINUE
            END IF
         END IF
         IF (MOD(K,5).EQ.1) THEN
            IF (IPLOT.EQ.1) THEN
               WRITE (IPRT,2020) YLABEL, (LINE(L),L=1,NCOL)
            ELSE
               WRITE (IPRT,1020) K, (LINE(L),L=1,NCOL), YLABEL,
     +                           (LINE(L),L=NCOLP1,NCOLT2)
            END IF
            YLABEL = YLABEL - 1.5D0
         ELSE
            IF (IPLOT.EQ.1) THEN
               WRITE (IPRT,2030) (LINE(L),L=1,111)
            ELSE
               WRITE (IPRT,1030) (LINE(L),L=1,102)
            END IF
         END IF
         YMAX = YMIN
  160 CONTINUE
!
!     PRINT BOTTOM LINE OF GRAPHS
!
      IF (IPLOT.EQ.1) THEN
!
!     PRINT X AXIS LABELS FOR FIRST SET OF PLOTS
!
         WRITE (IPRT,1040) ROWMIN, ROWMID, ROWMAX
         GO TO 40
!
!     PRINT X AXIS LABELS FOR SECOND SET OF PLOTS
!
      ELSE
         WRITE (IPRT,1070)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/51X, 23H STD RES VS ROW NUMBER )
 1020 FORMAT (1X, I5, '+', 51A1, '+', 2X, F5.2, '+', 51A1, '+')
 1030 FORMAT (6X, '-', 51A1, '-', 7X, '-', 51A1, '-')
 1040 FORMAT (1X, F8.1, 47X, F8.1, 47X, F8.1)
 1050 FORMAT (/13X, 'AUTOCORRELATION FUNCTION OF RESIDUALS',
     +   23X, 36H NORMAL PROBABILITY PLOT OF STD RES )
 1070 FORMAT (4X, 5H-1.00, 22X, 3H0.0, 21X, 4H1.00, 5X, 4H-2.5, 23X,
     +   3H0.0, 22X, 3H2.5)
 1090 FORMAT (// 1X, 13(1H*)/ 1X, 13H*  WARNING  */ 1X, 13(1H*)//
     +   54H THE STANDARDIZED RESIDUAL PLOTS HAVE BEEN SUPPRESSED.,
     +   45H  NONE OF THE STANDARDIZED RESIDUALS COULD BE,
     +   10H COMPUTED,/
     +   50H BECAUSE FOR EACH OBSERVATION EITHER THE WEIGHT OR,
     +   48H THE STANDARD DEVIATION OF THE RESIDUAL IS ZERO.)
 2020 FORMAT (1X, F5.2, '+', 111A1, '+')
 2030 FORMAT (6X, '-', 111A1, '-')
      END
!AMLST
      SUBROUTINE AMLST (IAMHD, PAR, NPAR, NFAC, MSPECT, N, VCVL,
     +   LVCVL, SCALE, LSCALE, STPT, LSTPT, IFIXD, RSS, RSD, NPARDF,
     +   NPARE, IDF)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRINTS THE PARAMETER SUMMARY OUTPUT FROM THE
!     ARIMA FORECASTING SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 4, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD,RSS
      INTEGER
     +   IAMHD,IDF,LSCALE,LSTPT,LVCVL,N,NFAC,NPAR,NPARDF,NPARE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),SCALE(*),STPT(*),VCVL(*)
      INTEGER
     +   IFIXD(*),MSPECT(NFAC,4)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM,T975
      INTEGER
     +   IPARMN,IPARMX,IPRT,LBLTYP
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   PPFT,D1MACH
      EXTERNAL PPFT,D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMLST1,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER IAMHD
!        THE INDICATOR VALUE USED TO DESIGNATE THE TYPE OF LIST
!        TO BE GENERATED
!        IF IAMHD=1, THE LIST IS FOR THE INITIAL SUMMARY OF THE
!                    ESTIMATION ROUTINES.
!        IF IAMHD=2, THE LIST IS FOR THE INITIAL REPORT OF THE
!                    FORECASTING ROUTINES.
!        IF IAMHD=3, THE LIST IS FOR THE FINAL REPORT OF THE
!                    ESTIMATION ROUTINES.
!     INTEGER IDF
!        THE DEGREES OF FREEDOM IN THE FIT.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IPARMN
!        THE SMALLEST PARAMETER INDEX INCLUDED IN THIS TERM.
!     INTEGER IPARMX
!        THE LARGEST PARAMETER INDEX INCLUDED IN THIS TERM.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER LSTPT
!        THE DIMENSION OF VECTOR STPT.
!     INTEGER LVCVL
!        THE DIMENSION OF VECTOR VCVL.
!     INTEGER MSPECT(NFAC,4)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     DOUBLE PRECISION RSS
!        THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION STPT(LSTPT)
!        THE STEP SIZE ARRAY.
!     DOUBLE PRECISION T975
!        THE VALUE OF THE 97.5 PERCENT POINT FUNCTION FOR THE
!        T DISTRIBUTION.
!     DOUBLE PRECISION VCVL(LVCVL)
!        THE LOWER HALF OF THE VARIANCE-COVARIANCE MATRIX, STORED
!        ROW WISE.
!
      FPLM = D1MACH(2)
!
      CALL IPRINT(IPRT)
!
!     PRINT HEADING FOR INFORMATION ABOUT PARAMETERS
!
      WRITE(IPRT, 1001)
!
      IF (IAMHD .EQ. 1) WRITE(IPRT, 1004)
      IF (IAMHD .EQ. 2) WRITE(IPRT, 1005)
      IF (IAMHD .EQ. 3) WRITE(IPRT, 1006)
      WRITE(IPRT, 1001)
!
!     PRINT MODEL SUMMARY INFORMATION
!
      IPARMN = 1
      IPARMX = 0
      T975 = PPFT(0.95D0, N-NPAR)
!
!     PRINT AUTOREGRESSIVE TERMS
!
      LBLTYP = 1
      CALL AMLST1 (IAMHD, PAR, NPAR, MSPECT, NFAC, VCVL, LVCVL,
     +  SCALE, LSCALE, STPT, LSTPT, IPARMN, IPARMX, LBLTYP, T975, IFIXD)
!
!     PRINT MEAN OR TREND TERM
!
      LBLTYP = 2
      CALL AMLST1 (IAMHD, PAR, NPAR, MSPECT, 1, VCVL, LVCVL,
     +  SCALE, LSCALE, STPT, LSTPT, IPARMN, IPARMX, LBLTYP, T975, IFIXD)
!
!     PRINT MOVING AVERAGE TERMS
!
      LBLTYP = 3
      CALL AMLST1 (IAMHD, PAR, NPAR, MSPECT, NFAC, VCVL, LVCVL,
     +  SCALE, LSCALE, STPT, LSTPT, IPARMN, IPARMX, LBLTYP, T975, IFIXD)
!
      WRITE (IPRT, 1160) N
      IF (IAMHD.GE.2)
     +   WRITE (IPRT, 1040) RSS, RSD, N, NPARDF, NPARE, IDF
      RETURN
!
!     FORMAT STATEMENTS
!
 1001 FORMAT(1X)
 1004 FORMAT (//73X, '  --STEP SIZE FOR'/
     +  39X, '  ------PARAMETER', 17X, '  --APPROXIMATING'/
     +  ' -----------------PARAMETER DESCRIPTION  STARTING VALUES',
     +  '  ----------SCALE  -----DERIVATIVE'/
     +  ' INDEX  ---------TYPE  --ORDER  --FIXED  ----------(PAR)',
     +  '  --------(SCALE)  ----------(STP)')
 1005 FORMAT(30X, '  ------PARAMETER'/
     +  ' --------PARAMETER DESCRIPTION  ------ESTIMATES'/
     +  ' INDEX  ---------TYPE  --ORDER  ----------(PAR)')
 1006 FORMAT(
     +  39X, '  ------PARAMETER  -----STD DEV OF', 17X,
     +  '  ---------------------APPROXIMATE'/
     +  ' -----------------PARAMETER DESCRIPTION  ------ESTIMATES',
     +  '  ------PARAMETER  ----------RATIO',
     +  '  ----95 PERCENT CONFIDENCE LIMITS'/
     +  ' INDEX  ---------TYPE  --ORDER  --FIXED  ----------(PAR)',
     +  '  ------ESTIMATES',
     +  '  PAR/(SD OF PAR)  ----------LOWER  ----------UPPER')
 1040 FORMAT (//' RESIDUAL SUM OF SQUARES       ', 8X, G15.7,
     +  '  (BACKFORECASTS INCLUDED)'//6H RESID,
     +   25HUAL STANDARD DEVIATION   , 8X, G15.7/19H BASED ON DEGREES O,
     +   9HF FREEDOM, 1X, I4, 3H - , I3, 3H - , I3, 3H = , I4)
 1160 FORMAT (//23H NUMBER OF OBSERVATIONS, 48X, 3H(N), 1X, I5)
      END
!XSTAT
      SUBROUTINE XSTAT(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS PROGRAM TESTS FEATURES OF THE STAT FAMILY TO ENSURE THAT
!     ALL ASPECTS OF THE STAT FAMILY ROUTINES WORK CORRECTLY.
!
!     WRITTEN BY  -  JOHN E. KOONTZ AND JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM,WTEMP,YTEMP1,YTEMPN
      INTEGER
     +   I,IPRT,N,NCONST,NPRTOF,NPRTON
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   STS(53),WT(84),WTALL0(10),WTALL1(84),Y(84),YCONST(10),
     +   YPATH(10)
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,STAT,STATS,STATW,STATWS
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        A LOOP INDEX.
!     INTEGER IERR
!        FLAG TO INDICATE PRESENCE OF ERROR DETECTED BY PRECEDING
!        STARPAC CALL.  (0 IS OK, 1 IS ERROR)
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER LDSTAK
!        AMOUNT OF WORK AREA.  SIZE OF DSTAK.
!     INTEGER N
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER NCONST
!        LENGTH OF THE VECTOR YCONST.
!     INTEGER NPRTOF
!        FLAG FOR NO OUTPUT (EXCEPT ERROR MESSAGES).
!     INTEGER NPRTON
!        FLAG FOR FULL PRINTOUT.
!     DOUBLE PRECISION STS(53)
!        VECTOR OF STATISTICS.
!     DOUBLE PRECISION WT(84)
!        WEIGHTS VECTOR.
!     DOUBLE PRECISION WTALL0(10)
!        N VECTOR OF 0 WEIGHTS.
!     DOUBLE PRECISION WTALL1(84)
!        N VECTOR OF 1 WEIGHTS.
!     DOUBLE PRECISION WTEMP
!        TEMPORARY STORAGE FOR ONE OF THE WEIGHTS.
!     DOUBLE PRECISION Y(84)
!        DATA VECTOR FOR TESTS.
!     DOUBLE PRECISION YCONST(10)
!        VECTOR OF CONSTANT DATA.
!     DOUBLE PRECISION YPATH(10)
!        A VECTOR OF Y VALUES DESIGNED TO FORCE DIFFERENT PATHS
!        THROUGH THE SUMMATION ROUTINES.
!     DOUBLE PRECISION YTEMPN, YTEMP1
!        TEMPORARY STORAGE FOR THE FIRST AND LAST Y VALUE.
!
!     DATA INITIALIZATIONS.
!
      DATA N /84/
      DATA NCONST /10/
      DATA NPRTON /1/
      DATA NPRTOF /0/
!
!     DAVIS-HARRISON R.H. DATA, PIKES PEAK.
!
!     THIS IS AN ARBITRARILY CHOSEN DATA SET.
!
      DATA Y( 1), Y( 2), Y( 3), Y( 4)
     +    / 0.6067D0, 0.6087D0, 0.6086D0, 0.6134D0/
      DATA Y( 5), Y( 6), Y( 7)
     +    / 0.6108D0, 0.6138D0, 0.6125D0/
      DATA Y( 8), Y( 9), Y(10), Y(11)
     +    / 0.6122D0, 0.6110D0, 0.6104D0, 0.7213D0/
      DATA Y(12), Y(13), Y(14)
     +    / 0.7078D0, 0.7021D0, 0.7004D0/
      DATA Y(15), Y(16), Y(17), Y(18)
     +    / 0.6981D0, 0.7242D0, 0.7268D0, 0.7418D0/
      DATA Y(19), Y(20), Y(21)
     +    / 0.7407D0, 0.7199D0, 0.6225D0/
      DATA Y(22), Y(23), Y(24), Y(25)
     +    / 0.6254D0, 0.6252D0, 0.6267D0, 0.6218D0/
      DATA Y(26), Y(27), Y(28)
     +    / 0.6178D0, 0.6216D0, 0.6192D0/
      DATA Y(29), Y(30), Y(31), Y(32)
     +    / 0.6191D0, 0.6250D0, 0.6188D0, 0.6233D0/
      DATA Y(33), Y(34), Y(35)
     +    / 0.6225D0, 0.6204D0, 0.6207D0/
      DATA Y(36), Y(37), Y(38), Y(39)
     +    / 0.6168D0, 0.6141D0, 0.6291D0, 0.6231D0/
      DATA Y(40), Y(41), Y(42)
     +    / 0.6222D0, 0.6252D0, 0.6308D0/
      DATA Y(43), Y(44), Y(45), Y(46)
     +    / 0.6376D0, 0.6330D0, 0.6303D0, 0.6301D0/
      DATA Y(47), Y(48), Y(49)
     +    / 0.6390D0, 0.6423D0, 0.6300D0/
      DATA Y(50), Y(51), Y(52), Y(53)
     +    / 0.6260D0, 0.6292D0, 0.6298D0, 0.6290D0/
      DATA Y(54), Y(55), Y(56)
     +    / 0.6262D0, 0.5952D0, 0.5951D0/
      DATA Y(57), Y(58), Y(59), Y(60)
     +    / 0.6314D0, 0.6440D0, 0.6439D0, 0.6326D0/
      DATA Y(61), Y(62), Y(63)
     +    / 0.6392D0, 0.6417D0, 0.6412D0/
      DATA Y(64), Y(65), Y(66), Y(67)
     +    / 0.6530D0, 0.6411D0, 0.6355D0, 0.6344D0/
      DATA Y(68), Y(69), Y(70)
     +    / 0.6623D0, 0.6276D0, 0.6307D0/
      DATA Y(71), Y(72), Y(73), Y(74)
     +    / 0.6354D0, 0.6197D0, 0.6153D0, 0.6340D0/
      DATA Y(75), Y(76), Y(77)
     +    / 0.6338D0, 0.6284D0, 0.6162D0/
      DATA Y(78), Y(79), Y(80), Y(81)
     +    / 0.6252D0, 0.6349D0, 0.6344D0, 0.6361D0/
      DATA Y(82), Y(83), Y(84)
     +    / 0.6373D0, 0.6337D0, 0.6383D0/
      DATA WT( 1), WT( 2), WT( 3), WT( 4), WT( 5), WT( 6), WT( 7)
     +   / 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0/
      DATA WT( 8), WT( 9), WT(10), WT(11), WT(12), WT(13), WT(14)
     +   / 0.5D0, 0.5D0, 0.5D0, 0.0D0, 0.0D0, 0.0D0, 0.0D0/
      DATA WT(15), WT(16), WT(17), WT(18), WT(19), WT(20), WT(21)
     +   / 0.0D0, 0.0D0, 0.0D0, 0.0D0, 0.0D0, 0.0D0, 0.5D0/
      DATA WT(22), WT(23), WT(24), WT(25), WT(26), WT(27), WT(28)
     +   / 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0/
      DATA WT(29), WT(30), WT(31), WT(32), WT(33), WT(34), WT(35)
     +   / 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0/
      DATA WT(36), WT(37), WT(38), WT(39), WT(40), WT(41), WT(42)
     +   / 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0, 0.5D0/
      DATA WT(43), WT(44), WT(45), WT(46), WT(47), WT(48), WT(49)
     +   / 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0/
      DATA WT(50), WT(51), WT(52), WT(53), WT(54), WT(55), WT(56)
     +   / 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 0.0D0, 0.0D0/
      DATA WT(57), WT(58), WT(59), WT(60), WT(61), WT(62), WT(63)
     +   / 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0/
      DATA WT(64), WT(65), WT(66), WT(67), WT(68), WT(69), WT(70)
     +   / 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0/
      DATA WT(71), WT(72), WT(73), WT(74), WT(75), WT(76), WT(77)
     +   / 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0/
      DATA WT(78), WT(79), WT(80), WT(81), WT(82), WT(83), WT(84)
     +   / 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0, 1.0D0/
!
!     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
!
      CALL IPRINT(IPRT)
!
      FPLM = D1MACH(2)
!
!     SET UP THE WEIGHTS VECTORS.
!
      DO 10 I=1,N
         WTALL1(I) = 1.0D0
   10 CONTINUE
      DO 20 I=1,NCONST
         YCONST(I) = 1.0D0
         WTALL0(I) = 0.0D0
   20 CONTINUE
!
!     HEADING.
!
      WRITE (IPRT,1150)
!
!     TEST 1.  CHECK ALL ERROR MESSAGES.
!
!     ERROR 1, TWO OR FEWER ELEMENTS.
!
      WRITE (IPRT,1180)
      WRITE(IPRT,1230)
      WRITE(IPRT,1240)
      CALL STAT(Y, 2, LDSTAK)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1230)
      WRITE(IPRT,1250)
      CALL STATS(Y, 2, LDSTAK, STS, NPRTON)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1230)
      WRITE(IPRT,1400)
      CALL STATW(Y, WT, 2, LDSTAK)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1230)
      WRITE(IPRT,1410)
      CALL STATWS(Y, WT, 2, LDSTAK, STS, NPRTON)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
!
!     ERROR 2, NOT ENOUGH SPACE IN CSTAK.
!
      WRITE (IPRT,1190)
      WRITE(IPRT,1230)
      WRITE(IPRT,1240)
      CALL STAT(Y, N, N/4)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1230)
      WRITE(IPRT,1250)
      CALL STATS(Y, N, N/4, STS, NPRTON)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1230)
      WRITE(IPRT,1400)
      CALL STATW(Y, WT, N, N/4)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1230)
      WRITE(IPRT,1410)
      CALL STATWS(Y, WT, N, N/4, STS, NPRTON)
      WRITE (IPRT,1170) IERR
!
!     ERROR 4, NEGATIVE WEIGHTS.
!
      WRITE (IPRT,1210)
      WTEMP = WT(2)
      WT(2) = -1.0D0
      WRITE(IPRT,1230)
      WRITE(IPRT,1400)
      CALL STATW(Y, WT, N, LDSTAK)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1230)
      WRITE(IPRT,1410)
      CALL STATWS(Y, WT, N, LDSTAK, STS, NPRTON)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
      WT(2) = WTEMP
!
!     ERROR 5, ALL WEIGHTS ZERO (PLUS CONSTANT Y).
!
      WRITE (IPRT,1220)
      WRITE(IPRT,1230)
      WRITE(IPRT,1400)
      CALL STATW(YCONST, WTALL0, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1230)
      WRITE(IPRT,1410)
      CALL STATWS(YCONST, WTALL0, NCONST, LDSTAK, STS, NPRTON)
      WRITE (IPRT,1170) IERR
!
!     TEST 2.  CHECK FOR READING OUTSIDE OF DATA ARRAY.
!
      WRITE (IPRT,1160)
      YTEMP1 = YCONST(1)
      YCONST(1) = FPLM
      YTEMPN = YCONST(NCONST)
      YCONST(NCONST) = FPLM
      WRITE(IPRT,1440)
      WRITE(IPRT,1240)
      CALL STAT(YCONST(2), NCONST-2, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1440)
      WRITE(IPRT,1250)
      CALL STATS(YCONST(2), NCONST-2, LDSTAK, STS, NPRTON)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1440)
      WRITE(IPRT,1400)
      CALL STATW(YCONST(2), WT, NCONST-2, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1440)
      WRITE(IPRT,1410)
      CALL STATWS(YCONST(2), WT, NCONST-2, LDSTAK, STS, NPRTON)
      WRITE (IPRT,1170) IERR
      YCONST(1) = YTEMP1
      YCONST(NCONST) = YTEMPN
!
!     TEST 3.  CONSTANT Y.
!
      WRITE (IPRT,1200)
      WRITE(IPRT,1440)
      WRITE(IPRT,1240)
      CALL STAT(YCONST, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1440)
      WRITE(IPRT,1250)
      CALL STATS(YCONST, NCONST, LDSTAK, STS, NPRTON)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1440)
      WRITE(IPRT,1400)
      CALL STATW(YCONST, WT, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE(IPRT,1440)
      WRITE(IPRT,1410)
      CALL STATWS(YCONST, WT, NCONST, LDSTAK, STS, NPRTON)
      WRITE (IPRT,1170) IERR
!
!     TEST 4.  SEE IF TURNING OFF THE PRINTOUT WORKS.
!
      WRITE (IPRT,1260)
      WRITE (IPRT,1270)
      WRITE(IPRT,1230)
      WRITE(IPRT,1250)
      CALL STATS(Y, N, LDSTAK, STS, NPRTOF)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1280)
      WRITE(IPRT,1230)
      WRITE(IPRT,1410)
      CALL STATWS(Y, WT, N, LDSTAK, STS, NPRTOF)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
!
!     TEST 5.  MAKE A WORKING RUN OF EACH ROUTINE  FIRST WITH
!              N=2 (THE MINIMUN VALID VALUE) AND THEN FOR THE WHOLE
!              DATA SET TO CHECK THE OUTPUT.
!
      WRITE (IPRT,1300)
      WRITE (IPRT,1310)
      WRITE(IPRT,1240)
      CALL STAT(Y, 3, LDSTAK)
      WRITE (IPRT,1310)
      WRITE(IPRT,1240)
      CALL STAT(Y, N, LDSTAK)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
!
      WRITE (IPRT,1320)
      WRITE(IPRT,1400)
      CALL STATW(Y, WT, 3, LDSTAK)
      WRITE (IPRT,1320)
      WRITE(IPRT,1400)
      CALL STATW(Y, WT, N, LDSTAK)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
!
      WRITE (IPRT,1340)
      WRITE(IPRT,1250)
      CALL STATS(Y, 3, LDSTAK, STS, NPRTON)
      WRITE (IPRT,1340)
      WRITE(IPRT,1250)
      CALL STATS(Y, N, LDSTAK, STS, NPRTON)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
!
      WRITE (IPRT,1350)
      WRITE(IPRT,1410)
      CALL STATWS(Y, WT, 3, LDSTAK, STS, NPRTON)
      WRITE (IPRT,1350)
      WRITE(IPRT,1410)
      CALL STATWS(Y, WT, N, LDSTAK, STS, NPRTON)
      WRITE(IPRT,1390) (Y(I), I = 1, 10)
      WRITE (IPRT,1170) IERR
!
!     TEST 5.  CHECK RESULTS OF WEIGHTING ALL OBSERVATIONS
!              WITH 1.0D0.  COMPARE WITH STAT EXECUTION.
!
      WRITE (IPRT,1370)
      WRITE(IPRT,1400)
      CALL STATW(Y, WTALL1, N, LDSTAK)
      WRITE (IPRT,1170) IERR
!
!     TEST 6.  CHECK RESULTS OF FORCING DIFFERENCE PATHS THROUGH
!              THE SUMMATION ROUTINES, USING SMALL, SIMPLE DATA SETS.
!
      WRITE (IPRT,1000)
!
!     RUN DATA SET 6.1
!
      DO 30 I=1,10
         YPATH(I) = I
   30 CONTINUE
      WRITE (IPRT,1010)
      WRITE(IPRT,1240)
      CALL STAT(YPATH, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1020)
      WRITE(IPRT,1400)
      CALL STATW(YPATH, WTALL1, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
!
!     RUN DATA SET 6.2
!
      DO 40 I=1,10
         YPATH(I) = -I
   40 CONTINUE
      WRITE (IPRT,1030)
      WRITE(IPRT,1240)
      CALL STAT(YPATH, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1040)
      WRITE(IPRT,1400)
      CALL STATW(YPATH, WTALL1, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
!
!     RUN DATA SET 6.3
!
      DO 50 I=1,10
         YPATH(I) = I-1
   50 CONTINUE
      WRITE (IPRT,1050)
      WRITE(IPRT,1240)
      CALL STAT(YPATH, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1060)
      WRITE(IPRT,1400)
      CALL STATW(YPATH, WTALL1, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
!
!     RUN DATA SET 6.4
!
      DO 60 I=1,10
         YPATH(I) = 1-I
   60 CONTINUE
      WRITE (IPRT,1070)
      WRITE(IPRT,1240)
      CALL STAT(YPATH, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1080)
      WRITE(IPRT,1400)
      CALL STATW(YPATH, WTALL1, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
!
!     RUN DATA SET 6.5
!
      DO 70 I=1,10
         YPATH(I) = I-6
   70 CONTINUE
      WRITE (IPRT,1090)
      WRITE(IPRT,1240)
      CALL STAT(YPATH, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1100)
      WRITE(IPRT,1400)
      CALL STATW(YPATH, WTALL1, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
!
!     RUN DATA SET 6.6
!
      DO 80 I=1,10
         YPATH(I) = I-5
   80 CONTINUE
      WRITE (IPRT,1110)
      WRITE(IPRT,1240)
      CALL STAT(YPATH, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1120)
      WRITE(IPRT,1400)
      CALL STATW(YPATH, WTALL1, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
!
!     RUN DATA SET 6.7
!
      DO 90 I=1,10
         YPATH(I) = 0.0D0
   90 CONTINUE
      YPATH(1) = -5.0D0
      YPATH(10) = 5.0D0
      WRITE (IPRT,1130)
      WRITE(IPRT,1240)
      CALL STAT(YPATH, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1140)
      WRITE(IPRT,1400)
      CALL STATW(YPATH, WTALL1, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
!
!     RUN DATA SET 6.8
!
      DO 100 I=1,10
         YPATH(I) = 0.0D0
  100 CONTINUE
      YPATH(1) = -5.0D0
      WTALL1(1) = 0.0D0
      YPATH(10) = 5.0D0
      WTALL1(10) = 0.0D0
      WRITE (IPRT,1380)
      WRITE(IPRT,1400)
      CALL STATW(YPATH, WTALL1, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      RETURN
!
!     FORMATS
!
 1000 FORMAT(51H1TEST 6.  TRY DIFFERENT PATHS THROUGH THE SUMMATION,
     +   6H CODE.)
 1010 FORMAT('1RUN STAT ON 1, ..., 10.')
 1020 FORMAT('1RUN STATW ON 1, ..., 10.  WEIGHTS ARE ALL 1.')
 1030 FORMAT('1RUN STAT ON -1, ..., -10.')
 1040 FORMAT('1RUN STATW ON -1, ..., -10.  WEIGHTS ARE ALL 1.')
 1050 FORMAT('1RUN STAT ON 0, ..., 9.')
 1060 FORMAT('1RUN STATW ON 0, ..., 9.  WEIGHTS ARE ALL 1.')
 1070 FORMAT('1RUN STAT ON 0, ..., -9.')
 1080 FORMAT('1RUN STATW ON 0, ..., -9.  WEIGHTS ARE ALL 1.')
 1090 FORMAT('1STAT ON -5, ..., 4.')
 1100 FORMAT('1RUN STATW ON -5, ..., 4.  WEIGHTS ARE ALL 1.')
 1110 FORMAT('1RUN STAT ON -4, ..., 5.')
 1120 FORMAT('1RUN STATW ON -4, ..., 5.  WEIGHTS ARE ALL 1.')
 1130 FORMAT('1RUN STAT ON -1, 8*0, 1.')
 1140 FORMAT('1RUN STATW ON -1, 8*0, 1.  WEIGHTS ARE ALL 1.')
 1150 FORMAT('1TEST RUNS FOR THE STATISTICAL ANALYSIS FAMILY ROUTINES.')
 1160 FORMAT('1TEST RUNS TO BE SURE CODE IS NOT READING OUTSIDE',
     +       ' DATA ARRAY.')
 1170 FORMAT(/' THE VALUE OF IERR IS ', I4)
 1180 FORMAT('1TRY TWO OR FEWER ELEMENTS.')
 1190 FORMAT('1TRY INSUFFICIENT WORK AREA.')
 1200 FORMAT('1TRY CONSTANT Y.')
 1210 FORMAT('1TRY NEGATIVE WEIGHTS.')
 1220 FORMAT('1TRY ALL WEIGHTS ZERO (AND CONSTANT Y).')
 1230 FORMAT (///)
 1240 FORMAT (' CALL TO STAT')
 1250 FORMAT (' CALL TO STATS')
 1260 FORMAT(45H1TEST3.  TRY TURNING OFF THE PRINT FOR THOSE ,
     +   24HROUTINES WHICH ALLOW IT.)
 1270 FORMAT(37H TRY TURNING THE PRINT OFF FOR STATS.)
 1280 FORMAT(38H TRY TURNING THE PRINT OFF FOR STATWS.)
 1300 FORMAT(52H1TEST 4.  MAKE WORKING RUNS OF ALL ROUTINES TO CHECK,
     +   16H THE STATISTICS.)
 1310 FORMAT('1RUN STAT ON THE DAVIS-HARRISON PIKES PEAK DATA.')
 1320 FORMAT('1RUN STATW ON THE DAVIS-HARRISON PIKES PEAK DATA.')
 1340 FORMAT('1RUN STATS ON THE DAVIS-HARRISON PIKES PEAK DATA.')
 1350 FORMAT('1RUN STATWS ON THE DAVIS-HARRISON PIKES PEAK DATA.')
 1370 FORMAT('1RUN STATW ON THE DAVIS-HARRISON PIKES PEAK DATA.',
     +  '  WEIGHTS ALL EQUAL TO ONE.  COMPARE TO STAT ABOVE, NOT TO',
     +  ' STATW.')
 1380 FORMAT(42H SERIES WITH NONZERO VALUES WEIGHTED ZERO.)
 1390 FORMAT(/8H DATA = , 10F7.4)
 1400 FORMAT (14H CALL TO STATW)
 1410 FORMAT (15H CALL TO STATWS)
 1440 FORMAT ('1')
      END
!SPP
      SUBROUTINE SPP(YM, X, N, ISYM)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH USER CONTROL OF PLOT SYMBOLS (SHORT CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
      INTEGER
     +   ISYM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   ILOG,IPRT,ISCHCK,ISIZE,IYM,LISYM,M,NOUT
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!     THE LABELED COMMON FOR COMMUNICATING ERROR FLAGS TO THE USER
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'P',       'P',       ' ',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      YMMISS(1) = 1.0D0
      XMISS = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 1
      ISIZE = -1
      NOUT = 0
      MISS = .FALSE.
      LISYM = N
!
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL SPP (Y, X, N, ISYM)')
      END
!NLITRP
      SUBROUTINE NLITRP(NLHDR, HEAD, PAGE, WIDE, IPTOUT, NPAR, NNZW,
     +   IWORK, IIWORK, RWORK, IRWORK, IFIXD, PARE, NPARE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS THE ITERATION REPORTS FOR THE
!     NONLINEAR LEAST SQUARES REGRESSION SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IIWORK,IPTOUT,IRWORK,NNZW,NPAR,NPARE
      LOGICAL
     +   HEAD,PAGE,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PARE(NPAR),RWORK(IRWORK)
      INTEGER
     +   IFIXD(NPAR),IWORK(IIWORK)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL NLHDR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD,RSS,RSSC,RSSPC
      INTEGER
     +   DST0,F,F0,FDIF,ICASE,IPRT,ISUBHD,MXITER,NFCALL,NITER,
     +   NREDUC,PREDUC,RELDX,STPPAR
      CHARACTER
     +   LETTRN*1,LETTRY*1
!
!  LOCAL ARRAYS
      CHARACTER
     +   ISCHKD(2)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LSTVCF
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MOD,DBLE,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER DST0
!        THE LOCATION IN RWORK OF THE VALUE OF THE 2 NORM OF D TIMES
!        THE  NEWTON STEP.
!     INTEGER F
!        THE LOCATION IN RWORK OF THE VALUE OF HALF THE RESIDUAL
!        SUM OF SQUARES AT THE CURRENT PARAMETER VALUES.
!     INTEGER FDIF
!        THE LOCATION IN RWORK OF THE DIFFERENCE BETWEEN THE
!        RESIDUAL SUM OF SQUARES AT THE BEGINNING AND END OF THE
!        CURRENT ITERATION.
!     INTEGER F0
!        THE LOCATION IN RWORK OF THE VALUE OF HALF THE RESIDUAL
!        VARIANCE AT THE BEGINNING OF THE CURRENT ITERATION.
!     LOGICAL HEAD
!        THE VARIABLE USED TO INDICATE WHETHER A HEADING IS TO BE
!        PRINTED DURING A GIVEN CALL TO THE ITERATION REPORT (TRUE)
!        OR NOT (FALSE).
!     INTEGER ICASE
!        AN INDICATER VARIABLE USED TO DESIGNATE THE MESSAGE TO BE
!        PRINTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IIWORK
!        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IRWORK
!        THE DIMENSION OF THE DOUBLE PRECISION WORK VECTOR RWORK.
!     CHARACTER*1 ISCHKD(2)
!        THE INDICATOR USED TO DESIGNATE WHETHER THE
!        TEST VALUE WAS CHECKED FOR CONVERGENCE (Y) OR NOT (N).
!     INTEGER ISUBHD
!        AN INTEGER VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IWORK(IIWORK)
!        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
!     CHARACTER*1 LETTRN, LETTRY
!        THE LETTERS N AND Y, RESPECTIVELY.
!     INTEGER MXITER
!        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
!        MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER NFCALL
!        THE LOCATION IN IWORK OF THE NUMBER OF FUNCTION EVALUATIONS.
!     INTEGER NITER
!        THE LOCATION IN IWORK OF THE NUMBER OF THE CURRENT ITERATION.
!     EXTERNAL NLHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF UNKNOWN PARAMETERS TO BE OPTIMIZED.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NREDUC
!        THE LOCATION IN RWORK OF THE VALUE USED TO CHECK IF THE
!        HESSIAN APPROXIMATION IS POSITIVE DEFINITE.  IF
!        IF RWORK(NREDUC) .EQ. 0, THE HESSIAN IS SINGULAR, OTHERWISE
!        IT IS NOT.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PARE(NPAR)
!        THE CURRENT ESTIMATES OF THE UNKNOWN PARAMETERS, BUT ONLY
!        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
!     INTEGER PREDUC
!        THE LOCATION IN RWORK OF THE PREDICTED FUNCTION REDUCTION
!        FOR THE CURRENT STEP.
!     INTEGER RELDX
!        THE LOCATION IN RWORK OF THE SCALED RELATIVE CHANGE IN
!        THE PARAMETER VALUES CAUSED BY THE CURRENT ITERATION.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     DOUBLE PRECISION RSS
!        THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION RSSC
!        THE CHANGE IN THE RESIDUAL SUM OF SQUARES CAUSED BY THIS
!        ITERATION.
!     DOUBLE PRECISION RSSPC
!        THE PREDICTED CHANGE IN THE RESIDUAL SUM OF SQUARES AT THIS
!        ITERATION.
!     DOUBLE PRECISION RWORK(IRWORK)
!        THE DOUBLE PRECISION WORK VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER STPPAR
!        THE LOCATION IN RWORK OF THE MARQUARDT LAMBDA PARAMETER.
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!
!
      DATA LETTRN /'N'/, LETTRY /'Y'/
!
!     IWORK SUBSCRIPT VALUES
!
      DATA MXITER /18/, NFCALL /6/, NITER /31/
!
!     RWORK SUBSCRIPT VALUES
!
      DATA DST0 /3/, F /10/, FDIF /11/, F0 /13/, NREDUC /6/, PREDUC
     +   /7/, RELDX /17/, STPPAR /5/
!
      CALL IPRINT(IPRT)
!
      IF (IWORK(1).EQ.10) GO TO 90
      IF ((IPTOUT.EQ.1) .AND. (IWORK(NITER).NE.1) .AND.
     +   (IWORK(NITER).NE.IWORK(MXITER)) .AND. (IWORK(1).LE.2)) RETURN
!
      ISUBHD = 0
      IF (HEAD) CALL NLHDR(PAGE, WIDE, ISUBHD)
      HEAD = .FALSE.
      IF (MOD(IWORK(NITER),4).EQ.0) HEAD = .TRUE.
!
      WRITE (IPRT,1000) IWORK(NITER)
!
!     COMPUTE STATISTICS TO BE PRINTED
!
      RSS = 2.0D0*RWORK(F)
      RSD = SQRT(RSS)
      IF (NNZW-NPARE.GE.1) RSD = RSD/SQRT(DBLE(NNZW-NPARE))
!
      RSSC = 0.0D0
      IF (RWORK(F0).GT.0.0D0) RSSC = RWORK(FDIF)/RWORK(F0)
!
      RSSPC = 0.0D0
      IF (RWORK(F0).GT.0.0D0) RSSPC = RWORK(NREDUC)/RWORK(F0)
!
!     REFERENCE NL2 SUBROUTINE ASSESS, STATEMENT LABEL 300 TO 320
!
      ISCHKD(1) = LETTRN
      ISCHKD(2) = LETTRN
      IF (RWORK(FDIF).GT.2.0D0*RWORK(PREDUC)) GO TO 10
      IF (RWORK(DST0).LT.0.0D0) GO TO 10
      IF (RWORK(NREDUC).GE.0.0D0) ISCHKD(1) = LETTRY
      IF (RWORK(STPPAR).EQ.0.0D0) ISCHKD(2) = LETTRY
   10 CONTINUE
!
      WRITE (IPRT,1010) IWORK(NFCALL), RSD, RSS, RSSC, RSSPC,
     +   ISCHKD(1), RWORK(RELDX), ISCHKD(2)
      IF (NPARE.LT.NPAR) WRITE (IPRT,1020)
      IF (NPARE.GE.NPAR) WRITE (IPRT,1150)
      CALL LSTVCF(NPARE, PARE, NPAR, IFIXD)
!
      IF (IWORK(1).LE.2) RETURN
!
!     PRINT FINAL ITERATION MESSAGE
!
      ICASE = IWORK(1) - 2
      GO TO (20, 30, 40, 50, 60, 70, 80, 90, 100, 140, 110, 120, 130),
     +   ICASE
!
!     ***** PARAMETER CONVERGENCE *****
!
   20 WRITE (IPRT,1030)
      RETURN
!
!     ***** RESIDUAL SUM OF SQUARES CONVERGENCE *****
!
   30 WRITE (IPRT,1040)
      RETURN
!
!     ***** PARAMETER AND RESIDUAL SUM OF SQUARES CONVERGENCE ****
!
   40 WRITE (IPRT,1050)
      RETURN
!
!     ***** RESIDUAL SUM OF SQUARES IS EXACTLY ZERO *****
!
   50 WRITE (IPRT,1060)
      RETURN
!
!     ***** SINGULAR CONVERGENCE *****
!
   60 WRITE (IPRT,1070)
      RETURN
!
!     ***** FALSE CONVERGENCE *****
!
   70 WRITE (IPRT,1080)
      RETURN
!
!     ***** LIMIT ON NUM. OF CALLS TO THE MODEL SUBROUTINE REACHED *****
!
   80 WRITE (IPRT,1090)
      RETURN
!
!     ***** ITERATION LIMIT REACHED *****
!
   90 WRITE (IPRT,1100)
      RETURN
!
!     ***** STOPX *****
!
  100 WRITE (IPRT,1110)
      RETURN
!
!     ***** INITIAL RESIDUAL SUM OF SQUARES OVERFLOWS *****
!
  110 WRITE (IPRT,1120)
      RETURN
!
!     ***** BAD PARAMETERS TO ASSESS *****
!
  120 WRITE (IPRT,1130)
      RETURN
!
!     ***** J COULD NOT BE COMPUTED *****
!
  130 WRITE (IPRT,1140)
      RETURN
!
  140 RETURN
!
!      FORMAT STATEMENTS
!
 1000 FORMAT (//17H ITERATION NUMBER, I5/1X, 22('-'))
 1010 FORMAT (5X, 5HMODEL, 53X, 10HFORECASTED/5X, 5HCALLS, 9X, 3HRSD,
     +   13X, 3HRSS, 8X, 12HREL CHNG RSS, 4X, 12HREL CHNG RSS, 4X,
     +   12HREL CHNG PAR/62X, 5HVALUE, 3X, 4HCHKD, 4X, 5HVALUE, 3X,
     +   4HCHKD/3X, I7, 3(2X, G14.4), 2(G12.4, 3X, A1))
 1020 FORMAT (/5X, 25H CURRENT PARAMETER VALUES, 19H (ONLY UNFIXED PARA,
     +   18HMETERS ARE LISTED))
 1030 FORMAT (/34H ***** PARAMETER CONVERGENCE *****)
 1040 FORMAT (/48H ***** RESIDUAL SUM OF SQUARES CONVERGENCE *****)
 1050 FORMAT (/44H ***** PARAMETER AND RESIDUAL SUM OF SQUARES,
     +   18H CONVERGENCE *****)
 1060 FORMAT (/50H ***** THE RESIDUAL SUM OF SQUARES IS EXACTLY ZERO,
     +   6H *****)
 1070 FORMAT (/33H ***** SINGULAR CONVERGENCE *****)
 1080 FORMAT (/30H ***** FALSE CONVERGENCE *****)
 1090 FORMAT (/44H ***** LIMIT ON NUMBER OF CALLS TO THE MODEL,
     +   25H SUBROUTINE REACHED *****)
 1100 FORMAT (/36H ***** ITERATION LIMIT REACHED *****)
 1110 FORMAT (/18H ***** STOPX *****)
 1120 FORMAT (/53H ***** INITIAL RESIDUAL SUM OF SQUARES OVERFLOWS ****,
     +   1H*)
 1130 FORMAT (/37H ***** BAD PARAMETERS TO ASSESS *****)
 1140 FORMAT (/52H ***** DERIVATIVE MATRIX COULD NOT BE COMPUTED *****)
 1150 FORMAT (/5X, 25H CURRENT PARAMETER VALUES)
      END
!ADJLMT
      SUBROUTINE ADJLMT(YMN, YMX)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CORRECTS THE PLOT LIMITS WHEN ALL
!     OBSERVATIONS ARE IDENTICALLY EQUAL.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMN,YMX
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION YMN, YMX
!        THE Y-AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
!
      IF (YMN .LT. YMX) RETURN
!
!     CORRECT FOR ALL OBSERVATIONS IDENTICALLY EQUAL
!
      YMN = YMN - ABS(YMN/2.0D0)
      YMX = YMX + ABS(YMX/2.0D0)
      IF (YMN .LT. YMX) RETURN
      YMN = -0.5D0
      YMX = 0.5D0
!
      RETURN
      END
!XXCH7
      SUBROUTINE XXCH7(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     TEST SUBPROGRAM FOR SIMPLE TEST OF
!     THE CORRELATION ANALYSIS FAMILY OF ROUTINES.
!
!     DATA IS FROM DRAPER AND SMITH [1968], PAGE 216.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,IYM,M,N
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YM(10,5)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CORR,IPRINT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER IYM
!        THE FIRST DIMENSION OF THE ARRAY YM.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER M
!        THE NUMBER OF VARIABLES MEASURED FOR EACH OBSERVATION.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     DOUBLE PRECISION YM(10,5)
!        THE OBSERVED MULTIVARIATE DATA.
!
!
      DATA     YM(1,1),   YM(1,2),   YM(1,3),   YM(1,4)
     +    /      42.2D0,  11.2D0,  31.9D0, 167.1D0/
      DATA     YM(2,1),   YM(2,2),   YM(2,3),   YM(2,4)
     +    /      48.6D0,  10.6D0,  13.2D0, 174.4D0/
      DATA     YM(3,1),   YM(3,2),   YM(3,3),   YM(3,4)
     +    /      42.6D0,  10.6D0,  28.7D0, 160.8D0/
      DATA     YM(4,1),   YM(4,2),   YM(4,3),   YM(4,4)
     +    /      39.0D0,  10.4D0,  26.1D0, 162.0D0/
      DATA     YM(5,1),   YM(5,2),   YM(5,3),   YM(5,4)
     +    /      34.7D0,   9.3D0,  30.1D0, 140.8D0/
      DATA     YM(6,1),   YM(6,2),   YM(6,3),   YM(6,4)
     +    /      44.5D0,  10.8D0,   8.5D0, 174.6D0/
      DATA     YM(7,1),   YM(7,2),   YM(7,3),   YM(7,4)
     +    /      39.1D0,  10.7D0,  24.3D0, 163.7D0/
      DATA     YM(8,1),   YM(8,2),   YM(8,3),   YM(8,4)
     +    /      40.1D0,  10.0D0,  18.6D0, 174.5D0/
      DATA     YM(9,1),   YM(9,2),   YM(9,3),   YM(9,4)
     +    /      45.9D0,  12.0D0,  20.4D0, 185.7D0/
!
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      CALL IPRINT(IPRT)
      IYM = 10
      N = 9
      M = 4
!
!     PRINT HEADER
!
      WRITE (IPRT,1000)
!
!     RUN SIMPLE EXAMPLE OF CORR
!
      WRITE (IPRT,1100)
      CALL CORR(YM, N, M, IYM, LDSTAK)
      WRITE (IPRT,2000) IERR
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT ('1*CH7')
 1100 FORMAT (' SIMPLE TEST OF CORR')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
!
      END
!LLER
      SUBROUTINE LLER(NMSUB, IXM, IVCV, N, NPAR, LPAR, LDSTAK, WT, LNWT,
     +   WEIGHT, NNZW, IFIT, SAVE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE ERROR CHECKING ROUTINE FOR THE LINEAR LEAST
!     SQUARES LLSTING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IFIT,IVCV,IXM,LDSTAK,LNWT,LPAR,N,NNZW,NPAR
      LOGICAL
     +   SAVE,WEIGHT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   WT(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   I,LDSMIN,NZW
      LOGICAL
     +   HEAD
!
!  LOCAL ARRAYS
      LOGICAL
     +   ERROR(10)
      CHARACTER
     +   LIVCV(8)*1,LIXM(8)*1,LLDS(8)*1,LLPAR(8)*1,LN(8)*1,
     +   LN1(8)*1,LNC(8)*1,LNDEG(8)*1,LNDEG1(8)*1,LNPAR(8)*1,
     +   LONE(8)*1,LWT(8)*1,LZERO(8)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,ERVWT,LDSCMP
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR(10)
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIT
!        THE INDICATOR VALUE DESIGNATING WHETHER THE LLS IS OF A
!        GENERAL MODEL (IFIT=3) OR A POLYNOMIAL MODEL (IFIT=1).
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     CHARACTER*1 LIVCV(8), LIXM(8), LLPAR(8), LLDS(8), LN(8), LNC(8),
!    *   LNDEG(8), LNDEG1(8), LNPAR(8), LN1(8), LONE(8), LWT(8),
!    *   LZERO(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LNWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NZW
!        THE NUMBER OF ZERO WEIGHTS.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LNWT)
!        THE USER SUPPLIED WEIGHTS.
!
!     SET UP NAME ARRAYS
!
      DATA LIVCV(1), LIVCV(2), LIVCV(3), LIVCV(4), LIVCV(5), LIVCV(6),
     +   LIVCV(7), LIVCV(8) /'I','V','C','V',' ',' ',' ',' '/
      DATA LIXM(1), LIXM(2), LIXM(3), LIXM(4), LIXM(5), LIXM(6),
     +   LIXM(7), LIXM(8) /'I','X','M',' ',' ',' ',' ',' '/
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +   LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA LLPAR(1), LLPAR(2), LLPAR(3), LLPAR(4), LLPAR(5), LLPAR(6),
     +   LLPAR(7), LLPAR(8) /'L','P','A','R',' ',' ',' ',' '/
      DATA LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8) /'N',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LNDEG(1), LNDEG(2), LNDEG(3), LNDEG(4), LNDEG(5), LNDEG(6),
     +   LNDEG(7), LNDEG(8) /'N','D','E','G',' ',' ',' ',' '/
      DATA LNDEG1(1), LNDEG1(2), LNDEG1(3), LNDEG1(4), LNDEG1(5),
     +   LNDEG1(6), LNDEG1(7), LNDEG1(8) /'N','D','E','G','+','1',
     +   ' ',' '/
      DATA LNPAR(1), LNPAR(2), LNPAR(3), LNPAR(4), LNPAR(5),
     +   LNPAR(6), LNPAR(7), LNPAR(8) /'N','P','A','R',' ',' ',' ',
     +   ' '/
      DATA LN1(1), LN1(2), LN1(3), LN1(4), LN1(5), LN1(6),
     +   LN1(7), LN1(8) /'N','-','1',' ',' ',' ',' ',' '/
      DATA LONE(1), LONE(2), LONE(3), LONE(4), LONE(5), LONE(6),
     +   LONE(7), LONE(8) /'O','N','E',' ',' ',' ',' ',' '/
      DATA LWT(1), LWT(2), LWT(3), LWT(4), LWT(5), LWT(6), LWT(7),
     +   LWT(8) /'W','T',' ',' ',' ',' ',' ',' '/
      DATA LZERO(1), LZERO(2), LZERO(3), LZERO(4), LZERO(5), LZERO(6),
     +   LZERO(7), LZERO(8) /'Z','E','R','O',' ',' ',' ',' '/
!
!     ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
      DO 10 I=1,10
         ERROR(I) = .FALSE.
   10 CONTINUE
!
      IF (IFIT.EQ.1) GO TO 30
!
      DO 20 I = 1, 8
         LNC(I) = LNPAR(I)
   20 CONTINUE
      GO TO 50
!
   30 CONTINUE
      DO 40 I = 1, 8
         LNC(I) = LNDEG1(I)
   40 CONTINUE
!
   50 CONTINUE
!
      CALL EISGE(NMSUB, LN, N, 1, 1, HEAD, ERROR(1), LN)
!
      IF (IFIT.EQ.3)
     +   CALL EISII(NMSUB, LNPAR, NPAR, 1, N, 1, HEAD, ERROR(2), LONE,
     +   LN)
      IF (IFIT.EQ.1)
     +   CALL EISII(NMSUB, LNDEG, NPAR-1, 0, N-1, 1, HEAD, ERROR(2),
     +      LZERO, LN1)
!
      CALL EISGE(NMSUB, LIXM, IXM, N, 3, HEAD, ERROR(4), LN)
!
      IF (SAVE .AND. (IFIT.EQ.1))
     +   CALL EISGE(NMSUB, LLPAR, LPAR, NPAR, 7, HEAD, ERROR(5), LNDEG1)
!
      IF (SAVE)
     +    CALL EISGE(NMSUB, LIVCV, IVCV, NPAR, 3, HEAD, ERROR(6), LNC)
!
      IF (ERROR(1) .OR. ERROR(2) .OR. ERROR(3)) GO TO 70
!
      NNZW = N
      IF (WEIGHT) CALL ERVWT(NMSUB, LWT, WT, N, NPAR, HEAD, NNZW,
     +   NZW, 2, ERROR(8), LNC)
!
      CALL LDSCMP(15, 0, 0, 0, 0, 0, 'D',
     +            6*N + NPAR*(N+2*NPAR+5) + 1, LDSMIN)
!
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR(9), LLDS)
!
      DO 60 I=1,10
         IF (ERROR(I)) GO TO 70
   60 CONTINUE
      RETURN
!
   70 CONTINUE
      IERR = 1
      RETURN
!
      END
!MVP
      SUBROUTINE MVP(YM, N, M, IYM, NS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MULTIPLE Y-AXIS VALUES (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IYM,M,N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IPRT,IRLIN,ISCHCK,ISIZE,LISYM
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'V',       'P',       ' ',       ' ',       ' '/
!
!     DEFINE CONSTANTS
!
!     SET DEFAULT VALUES
!
      MULTI = .TRUE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 2
      ISIZE = -1
      MISS = .FALSE.
      LISYM = 1
      IRLIN = -1
      IBAR = 0
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YM, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL MVP (YM, N, M, IYM, NS)')
      END
!STAT2
      SUBROUTINE STAT2(Y, N, STS, SUMDA, SUMDI, SUMD2, SUMD3, SUMD4)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES FOR A VECTOR Y THE STATISTICS THAT DO
!     NOT REQUIRE SORTING OF THE VECTOR, THAT IS, THOSE NOT COMPUTED
!     BY STAT1.  NO WEIGHTS ARE USED.
!
!     THIS SUBROUTINE IS BASED ON A MODIFICATION OF THE STATIS
!     CODE USED IN OMNITAB, VERSION 5 (6/16/72), WRITTEN BY
!     SALLY PEAVY.  THE ORIGINAL ADAPTATION TO STARPAC WAS
!     DONE BY JANET DONALDSON.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SUMD2,SUMD3,SUMD4,SUMDA,SUMDI
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   STS(53),Y(N)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DIF,T,TA,TK1,TK2
      INTEGER
     +   I,IC,ICI,IDRUNS,IMINUS,IPLUS,IRUN
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFF,PPFCHS,PPFT
      EXTERNAL CDFF,PPFCHS,PPFT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,SQRT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DIF
!        THE SUM OF THE DIFFERENCES BETWEEN SUCCEEDING ELEMENTS
!        IN Y.
!     INTEGER I
!        A LOOP INDEX.
!     INTEGER IC
!        PREVIOUS SIGN IN RUNS CALCULATION.
!     INTEGER ICI
!        CURRENT SIGN IN RUNS CALCULATION.
!     INTEGER IDRUNS
!        THE NUMBER OF RUNS.
!     INTEGER IERR
!        AN ERROR FLAG SET IN COMMON ERRCHK.
!     INTEGER IMINUS, IPLUS
!        COUNTS OF SIGNS OF DEVIATIONS.
!     INTEGER IRUN
!        THE NUMBER OF RUNS UP AND DOWN.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y AND WT.
!     DOUBLE PRECISION STS(53)
!        OUTPUT PARAMETER.  THE VECTOR OF 53 STATISTICS COMPUTED.
!        ROW STATISTIC                    ROW STATISTIC
!         1  LENGTH OF VECTOR             TESTS FOR NONRANDOMNESS
!         2  NUMBER OF NONZERO WEIGHTS    23  NUMBER OF RUNS UP AND DOWN
!        MEASURES OF LOCATION             24  EXPECTED NUMBER OF RUNS
!         3  UNWEIGHTED MEAN              25  S.D. OF NUMBER OF RUNS
!         4  WEIGHTED MEAN                26  MEAN SQR. SUCCESSIVE DIFF.
!         5  MEDIAN                       27  MEAN SQR. SUCC. DIFF./VAR.
!         6  MID-RANGE                    DEVIATIONS FROM WTD MEAN
!         7  25 P.C. UNWTD. TRIMMED MEAN  28  NUMBER OF + SIGNS
!         8  25 P.C. WTD. TRIMMED MEAN    29  NUMBER OF - SIGNS
!        MEASURES OF DISPERSION           30  NUMBER OF RUNS
!         9  STANDARD DEVIATION (S.D.)    31  EXPECTED NUMBER OF RUNS
!        10  S.D. OF MEAN                 32  S.D. OF RUNS
!        11  RANGE                        33  DIFF./S.D. OF RUNS
!        12  MEAN VARIATION               OTHER STATISTICS
!        13  VARIANCE (VAR.)              34  MINIMUM
!        14  COEFFICIENT OF VARIATION     35  MAXIMUM
!        CONFIDENCE INTERVALS             36  BETA 1
!        15  LOWER CONFIDENCE LIMIT, MEAN 37  BETA 2
!        16  UPPER CONFIDENCE LIMIT, MEAN 38  WTD. SUM OF VALUES
!        17  LOWER CONFIDENCE LIMIT, S.D. 39  WTD. SUM OF SQUARES
!        18  UPPER CONFIDENCE LIMIT, S.D. 40  WTD. SUM OF SQRD. DEVS.
!        LINEAR TREND STATISTICS          41  STUDENTS T
!        19  SLOPE                        42  WTD. SUM OF ABS. VALUES
!        20  S.D. OF SLOPE                43  WTD. AVG. ABS. VALUES
!        21  SLOPE/S.D. OF SLOPE = T      44-53 FREQ. DISTRIBUTION
!        22  PROB ( X .GT. ABS(OBS. T))
!     DOUBLE PRECISION SUMDA
!        INPUT PARAMETER.  THE SUM OF THE ABSOLUTE VALUES OF THE
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION SUMDI
!        INPUT PARAMETER.  THE SUM OF THE PRODUCTS OF I AND THE
!        ITH DIFFERENCE DIFF.
!     DOUBLE PRECISION SUMD2
!        INPUT PARAMETER.  THE SUM OF THE SQUARES OF THE
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION SUMD3
!        INPUT PARAMETER.  THE SUM OF THE CUBES OF THE
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION SUMD4
!        INPUT PARAMETER.  THE SUM OF THE HYPERCUBES OF THE
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION T
!        A RESIDUAL (Y(I) - MEANY)
!     DOUBLE PRECISION TA
!        A TEMPORARY VARIABLE IN THE RUNS CALCULATION.
!     DOUBLE PRECISION TK1, TK2
!        CHI-SQUARED VALUES.
!     DOUBLE PRECISION Y(N)
!        INPUT PARAMETER.  A SET OF N DATA POINTS, SORTED
!        INTO ASCENDING ORDER.
!
!
!     BEGIN STORAGE OF STATISTICS.
!
      STS(1) = N
      STS(2) = STS(1)
      STS(24) = (2.0D0*STS(1)-1.0D0)/3.0D0
      STS(25) = SQRT((16.0D0*STS(1)-29.0D0)/90.0D0)
      STS(43) = STS(42)/STS(1)
!
!     COMPUTE RESIDUALS AND STANDARD DEVIATIONS.
!
      ICI = 0
      IPLUS = 0
      IMINUS = 0
      IDRUNS = 0
      IC = 0
      DO 30 I=1,N
         T = Y(I) - STS(4)
         IF (T.LT.0.0D0) GO TO 10
         IPLUS = IPLUS + 1
         ICI = +1
         GO TO 20
   10    IMINUS = IMINUS + 1
         ICI = -1
   20    IF (IC.EQ.ICI) GO TO 30
         IC = ICI
         IDRUNS = IDRUNS + 1
   30 CONTINUE
      STS(28) = IPLUS
      STS(29) = IMINUS
      STS(31) = 1.0D0 + (2.0D0*STS(28)*STS(29)/STS(1))
      STS(32) = SQRT((2.0D0*STS(28)*STS(29)*
     +                 (2.0D0*STS(28)*STS(29) -
     +                  STS(28)-STS(29)))/
     +            ((STS(28)+STS(29))**2*(STS(1)-1.0D0)))
      STS(30) = IDRUNS
      STS(33) = 0.0D0
      IF (STS(32).NE.0.0D0)
     +   STS(33) = (STS(30)-STS(31))/STS(32)
      STS(13) = SUMD2/(STS(1)-1.0D0)
      STS(9) = SQRT(STS(13))
      STS(10) = STS(9)/SQRT(STS(1))
      IF (STS(4).NE.0.0D0)
     +   STS(14) = 100.0D0*ABS(STS(9)/STS(4))
      IF (STS(4).EQ.0.0D0) STS(14) = 0.0D0
      STS(36) = 0.0D0
      IF (SUMD2.GT.0.0D0)
     +   STS(36) = (SUMD3/STS(1))**2/((SUMD2/STS(1))**3)
      STS(37) = 0.0D0
      IF (SUMD2.GT.0.0D0)
     +   STS(37) = (SUMD4/STS(1))/((SUMD2/STS(1))**2)
      STS(40) = SUMD2
      STS(19) = (12.0D0*SUMDI)/(STS(1)*(STS(1)**2-1.0D0))
      STS(20) = (1.0D0/(STS(1)-2.0D0)*
     +             (12.0D0*(SUMD2/(STS(1)*(STS(1)**2-1.0D0)))-
     +              STS(19)**2))
      IF (STS(20).LE.0.0D0) STS(20) = 0.0D0
      STS(20) = SQRT(STS(20))
      IF (STS(20).EQ.0.0D0) STS(21) = 0.0D0
      IF (STS(20).GT.0.0D0) STS(21) = STS(19)/STS(20)
!
      STS(22) = 1.0D0 - CDFF(STS(21)*STS(21), 1.0D0, STS(1)-2.0D0)
!
!     COMPUTE NUMBER OF RUNS IN THE DATA.
!
      DIF = 0.0D0
      IRUN = 1
      TA = 0.0D0
      DO 40 I=1,N
         IF (I.GE.N) GO TO 50
         TA = Y(I+1) - Y(I)
         IF (TA.NE.0.0D0) GO TO 50
   40 CONTINUE
   50 DO 60 I=1,N
         IF (I.EQ.N) GO TO 60
         T = Y(I+1) - Y(I)
         DIF = DIF + T*T
         IF (TA*T.GE.0.0D0) GO TO 60
         TA = T
         IRUN = IRUN + 1
   60 CONTINUE
      STS(23) = IRUN
      STS(26) = DIF/(STS(1)-1.0D0)
      STS(27) = 0.0D0
      IF (STS(13).NE.0.0D0)
     +   STS(27) = STS(26)/STS(13)
      STS(41) = 0.0D0
      IF (STS(9).NE.0.0D0)
     +   STS(41) = (STS(4)*SQRT(STS(1)))/STS(9)
      STS(12) = SUMDA/STS(1)
      T = PPFT(0.975D0, N-1)
      TK1 = PPFCHS(0.975D0, N-1)
      TK2 = PPFCHS(0.025D0, N-1)
      STS(15) = STS(4) - T*STS(10)
      STS(16) = STS(4) + T*STS(10)
      STS(17) = SQRT((STS(1)-1.0D0)/TK1)*STS(9)
      STS(18) = SQRT((STS(1)-1.0D0)/TK2)*STS(9)
      RETURN
      END
!IPGM
      SUBROUTINE IPGM (YFFT, N, LYFFT, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
!     THE INTEGRATED PERIODOGRAM OF A SERIES (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,LYFFT,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YFFT(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   FREQ,IEXTND,IPRT,ISYM,LDSMIN,LPCV,NALL0,NF,NFFT,NPRT,
     +   XAXIS,YAXIS
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   LLDS(8)*1,LLYFFT(8)*1,LN(8)*1,NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CNTR,EISGE,IPGDV,IPRINT,LDSCMP,PGMMN,SETESL,STKCLR,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     INTEGER FREQ
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
!        INTEGRATED SPECTRUM VALUES ARE STORED.
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IEXTND
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
!        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
!        USED TO EXTEND THE SERIES.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     CHARACTER*1 LLDS(8), LLYFFT(8), LN(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING ALLOCATIONS OF THE STACK AT THE
!        TIME OF THIS CALL.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A PAGE PLOT.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE X AXIS VALUES TO BE PLOTTED ARE STORED.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
!     DOUBLE PRECISION YFFT(LYFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'I',       'P',       'G',       'M',       ' ',       ' '/
      DATA
     + LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     +  LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA
     + LLYFFT(1), LLYFFT(2), LLYFFT(3), LLYFFT(4), LLYFFT(5),
     +  LLYFFT(6), LLYFFT(7), LLYFFT(8)
     +  /'L','Y','F','F','T',' ',' ',' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /'N',' ',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
      IF (ERR01) GO TO 5
!
!     SET LENGTH OF EXTENDED SERIES
!
      CALL SETESL(N, 2, NFFT)
      NF = NFFT/2
!
      CALL EISGE(NMSUB, LLYFFT, LYFFT, NFFT, 9, HEAD, ERR02, LLYFFT)
!
      CALL LDSCMP(3, 0, NF+103, 0, 0, 0, 'D', 2*NFFT+206, LDSMIN)
!
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR03, LLDS)
!
      IF (ERR01 .OR. ERR02 .OR. ERR03) GO TO 5
      GO TO 10
!
    5 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   10 CONTINUE
!
!     SET THE SIZE OF THE WORK AREA
!
      CALL STKSET(LDSTAK, 4)
!
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!
      NALL0 = STKST(1)
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      LPCV = NF + 103
      NPRT = 1
!
!     CENTER THE SERIES
!
      CALL CNTR(YFFT, N, YFFT)
      IEXTND = 0
!
!     SUBDIVIDE THE STACK.
!
      ISYM = STKGET(LPCV, 2)
      XAXIS = STKGET(LPCV, 4)
      YAXIS = STKGET(LPCV, 4)
!
      FREQ = XAXIS
!
!     COMPUTE THE RAW PERIODOGRAM.
!
      CALL PGMMN (YFFT, N, NFFT, IEXTND, NF, YFFT, LYFFT, RSTAK(YAXIS),
     +   RSTAK(FREQ), LPCV, 0, NMSUB)
!
!     CALL THE MAIN DRIVER FOR COMPUTING (AND PLOTTING) THE INTEGRATED
!     PERIODOGRAM.
!
      CALL IPGDV (YFFT, NF, N, YFFT, RSTAK(FREQ), RSTAK(XAXIS),
     +   RSTAK(YAXIS), ISTAK(ISYM), LPCV, NPRT)
!
      CALL STKCLR(NALL0)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL IPGM (YFFT, N, LYFFT, LDSTAK)')
      END
!REPCK
      SUBROUTINE REPCK(D, NRESTS, NPAR, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE MODIFIES D TO CONFORM TO N BY NPAR FORMAT REQUIRED
!     BY NLCMP.  FUTURE REVISIONS TO NLCMP SHOULD BE MADE TO ELIMINATE
!     THE NEED FOR THIS ROUTINE.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N,NPAR,NRESTS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(NRESTS*NPAR)
!
!  LOCAL SCALARS
      INTEGER
     +   I,I1,I2,J
!
!
      I1 = -N
      I2 = -N
      DO 10 J = 1, NPAR
        I1 = I1 + NRESTS
        I2 = I2 + N
        DO 5 I = 1, N
          D(I2+I) = D(I1+I)
    5   CONTINUE
   10 CONTINUE
      RETURN
      END
!MDFLT
      SUBROUTINE MDFLT (PER, NF, NK, KMD, PERF, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR APPLYING MODIFIED
!     DANIEL FILTERS TO A SYMMETRIC SERIES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,NF,NK
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PER(*),PERF(*)
      INTEGER
     +   KMD(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   SYM
      INTEGER
     +   I,IPRT,L,LDSMIN,NALL0,WORK
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      CHARACTER
     +   LKMD(8)*1,LLDS(8)*1,LNF(8)*1,LNK(8)*1,NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EIVEO,FLTMD,IPRINT,LDSCMP,STKCLR,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT NUMBER USED FOR OUTPUT.
!     INTEGER KMD(NK)
!        THE ARRAY OF FILTER LENGTHS.
!     CHARACTER*1 LKMD(8), LLDS(8), LNK(8), LNF(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     INTEGER NF
!        THE NUMBER OF POINTS IN THE SERIES TO BE FILTERED.
!     INTEGER NK
!        THE NUMBER OF FILTERS TO BE APPLIED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     DOUBLE PRECISION PER(NF)
!        THE INPUT SERIES TO BE FILTERED.
!     DOUBLE PRECISION PERF(NF)
!        THE FILTERED SERIES.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION SYM
!        AN INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE SERIES
!        IS SYMMETRIC (SYM = 1.0D0) OR NOT (SYM = -1.0D0).
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR THE WORK VECTOR.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'M',       'D',       'F',       'L',       'T',       ' '/
      DATA
     + LKMD(1), LKMD(2), LKMD(3), LKMD(4), LKMD(5),
     +  LKMD(6), LKMD(7), LKMD(8) /'K','M','D',' ',' ',' ',' ',' '/
      DATA
     + LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     +  LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA
     + LNF(1), LNF(2), LNF(3), LNF(4), LNF(5),
     +  LNF(6), LNF(7), LNF(8) /'N','F',' ',' ',' ',' ',' ',' '/
      DATA
     + LNK(1), LNK(2), LNK(3), LNK(4), LNK(5),
     +  LNK(6), LNK(7), LNK(8) /'N','K',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LNF, NF, 17, 1, HEAD, ERR01, LNF)
!
      CALL EISGE(NMSUB, LNK, NK, 1, 1, HEAD, ERR02, LNK)
!
      IF (.NOT.ERR02) CALL EIVEO(NMSUB, LKMD, KMD, NK, .TRUE., HEAD)
!
      IF (ERR01) GO TO 10
!
      CALL LDSCMP(1, 0, 0, 0, 0, 0, 'D', NF, LDSMIN)
!
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR03, LLDS)
!
      IF ((.NOT.ERR02) .AND. (.NOT.ERR03)) GO TO 20
!
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   20 CONTINUE
!
!     SET THE SIZE OF THE WORK AREA
!
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
!
!     SUBDIVIDE THE WORK AREA
!
      WORK = STKGET(NF, 4)
!
!     DESIGNATE THE SERIES IS SYMMETRIC
!
      SYM = 1.0D0
!
      DO 30 I = 1, NF
         PERF(I) = PER(I)
   30 CONTINUE
!
      DO 40 L = 1, NK
         CALL FLTMD(PERF, RSTAK(WORK), NF, KMD(L), SYM)
   40 CONTINUE
!
      CALL STKCLR(NALL0)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL MDFLT (PER, NF, NK, KMD, PERF, LDSTAK)')
      END
!LLSP
      SUBROUTINE LLSP(Y, XM, N, NDEG, RES, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CALL FOR POLYNOMIAL MODEL LEAST SQUARES FIT
!     NO WEIGHTS SPECIFIED
!     NO STORAGE OTHER THAN RESIDUALS
!     FOUR PAGES AUTOMATIC PRINTOUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N,NDEG
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RES(*),XM(*),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LPAR,LPV,LSDPV,LSDRES,LWT,NPAR,NPRT
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(1),PV(1),SDPV(1),SDRES(1),VCV(1,1),WT(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLCNTP
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDEG
!        THE DEGREE OF THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     DOUBLE PRECISION PAR(1)
!        A DUMMY ARRAY FOR
!        THE PARAMETERS  TO BE ESTIMATED.
!     DOUBLE PRECISION PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUES.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(1)
!        A DUMMY ARRAY FOR
!        THE WEIGHTS.
!     DOUBLE PRECISION XM(N,1)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'L','L','S','P',' ',' '/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      WEIGHT = .FALSE.
      SAVE = .FALSE.
      NPRT = 1111
      LPAR = 1
      LPV = 1
      LSDPV = 1
      LSDRES = 1
      IVCV = 1
      LWT = 1
!
      CALL LLCNTP(Y, WT, LWT, XM, N, NDEG, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (//42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   45H       CALL LLSP (Y, X, N, NDEG, RES, LSDTAK))
      END
!XXCH8
      SUBROUTINE XXCH8(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     TEST SUBPROGRAM FOR SIMPLE TEST OF
!     THE LINEAR LEAST SQUARES FAMILY OF ROUTINES.
!
!     LLS PROBLEM IS FROM DANIAL AND WOOD [1971], PAGES 61-65.
!
!     LLSP PROBLEM IS FROM MILLER AND FREUND [1977], PAGE 311.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,IXM,N1,N2,NDEG,NPAR
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RES(25),X(25),XM(25,5),Y1(25),Y2(25)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLS,LLSP
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX X.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER NDEG
!        THE DEGREE OF THE POLYNOMIAL MODEL TO BE FIT.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER N1, N2
!        THE NUMBER OF OBSERVATIONS IN EACH PROBLEM.
!     DOUBLE PRECISION RES(25)
!        THE RESIDUALS.
!     DOUBLE PRECISION X(25)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION XM(25,5)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION Y1(25), Y2(25)
!        THE DEPENDENT VARIABLE.
!
!
      DATA      XM(1,1),  XM(1,2),  XM(1,3),  XM(1,4)
     +    /      1.0D0, 80.0D0, 27.0D0, 89.0D0/
      DATA      XM(2,1),  XM(2,2),  XM(2,3),  XM(2,4)
     +    /      1.0D0, 80.0D0, 27.0D0, 88.0D0/
      DATA      XM(3,1),  XM(3,2),  XM(3,3),  XM(3,4)
     +    /      1.0D0, 75.0D0, 25.0D0, 90.0D0/
      DATA      XM(4,1),  XM(4,2),  XM(4,3),  XM(4,4)
     +    /      1.0D0, 62.0D0, 24.0D0, 87.0D0/
      DATA      XM(5,1),  XM(5,2),  XM(5,3),  XM(5,4)
     +    /      1.0D0, 62.0D0, 22.0D0, 87.0D0/
      DATA      XM(6,1),  XM(6,2),  XM(6,3),  XM(6,4)
     +    /      1.0D0, 62.0D0, 23.0D0, 87.0D0/
      DATA      XM(7,1),  XM(7,2),  XM(7,3),  XM(7,4)
     +    /      1.0D0, 62.0D0, 24.0D0, 93.0D0/
      DATA      XM(8,1),  XM(8,2),  XM(8,3),  XM(8,4)
     +    /      1.0D0, 62.0D0, 24.0D0, 93.0D0/
      DATA      XM(9,1),  XM(9,2),  XM(9,3),  XM(9,4)
     +    /      1.0D0, 58.0D0, 23.0D0, 87.0D0/
      DATA     XM(10,1), XM(10,2), XM(10,3), XM(10,4)
     +    /      1.0D0, 58.0D0, 18.0D0, 80.0D0/
      DATA     XM(11,1), XM(11,2), XM(11,3), XM(11,4)
     +    /      1.0D0, 58.0D0, 18.0D0, 89.0D0/
      DATA     XM(12,1), XM(12,2), XM(12,3), XM(12,4)
     +    /      1.0D0, 58.0D0, 17.0D0, 88.0D0/
      DATA     XM(13,1), XM(13,2), XM(13,3), XM(13,4)
     +    /      1.0D0, 58.0D0, 18.0D0, 82.0D0/
      DATA     XM(14,1), XM(14,2), XM(14,3), XM(14,4)
     +    /      1.0D0, 58.0D0, 19.0D0, 93.0D0/
      DATA     XM(15,1), XM(15,2), XM(15,3), XM(15,4)
     +    /      1.0D0, 50.0D0, 18.0D0, 89.0D0/
      DATA     XM(16,1), XM(16,2), XM(16,3), XM(16,4)
     +    /      1.0D0, 50.0D0, 18.0D0, 86.0D0/
      DATA     XM(17,1), XM(17,2), XM(17,3), XM(17,4)
     +    /      1.0D0, 50.0D0, 19.0D0, 72.0D0/
      DATA     XM(18,1), XM(18,2), XM(18,3), XM(18,4)
     +    /      1.0D0, 50.0D0, 19.0D0, 79.0D0/
      DATA     XM(19,1), XM(19,2), XM(19,3), XM(19,4)
     +    /      1.0D0, 50.0D0, 20.0D0, 80.0D0/
      DATA     XM(20,1), XM(20,2), XM(20,3), XM(20,4)
     +    /      1.0D0, 56.0D0, 20.0D0, 82.0D0/
      DATA     XM(21,1), XM(21,2), XM(21,3), XM(21,4)
     +    /      1.0D0, 70.0D0, 20.0D0, 91.0D0/
!
      DATA        Y1(1),    Y1(2),    Y1(3)
     +    /     42.0D0, 37.0D0, 37.0D0/
      DATA        Y1(4),    Y1(5),    Y1(6)
     +    /     28.0D0, 18.0D0, 18.0D0/
      DATA        Y1(7),    Y1(8),    Y1(9)
     +    /     19.0D0, 20.0D0, 15.0D0/
      DATA       Y1(10),   Y1(11),   Y1(12)
     +    /     14.0D0, 14.0D0, 13.0D0/
      DATA       Y1(13),   Y1(14),   Y1(15)
     +    /     11.0D0, 12.0D0,  8.0D0/
      DATA       Y1(16),   Y1(17),   Y1(18)
     +    /      7.0D0,  8.0D0,  8.0D0/
      DATA       Y1(19),   Y1(20),   Y1(21)
     +    /      9.0D0, 15.0D0, 15.0D0/
!
      DATA         X(1),     X(2),     X(3)
     +    /      0.0D0,  1.0D0,  2.0D0/
      DATA         X(4),     X(5),     X(6)
     +    /      3.0D0,  4.0D0,  5.0D0/
      DATA         X(7),     X(8),     X(9)
     +    /      6.0D0,  7.0D0,  8.0D0/
!
      DATA        Y2(1),    Y2(2),    Y2(3)
     +    /     12.0D0, 10.5D0, 10.0D0/
      DATA        Y2(4),    Y2(5),    Y2(6)
     +    /      8.0D0,  7.0D0,  8.0D0/
      DATA        Y2(7),    Y2(8),    Y2(9)
     +    /      7.5D0,  8.5D0,  9.0D0/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      CALL IPRINT(IPRT)
      IXM = 25
      N1 = 21
      N2 = 9
      NPAR = 4
      NDEG = 2
!
!     PRINT HEADER
!
      WRITE (IPRT,1000)
!
!     RUN SIMPLE EXAMPLE OF LLS
!
      WRITE (IPRT,1100)
      CALL LLS(Y1, XM, N1, IXM, NPAR, RES, LDSTAK)
      WRITE (IPRT,2000) IERR
!
!     RUN SIMPLE EXAMPLE OF LLSP
!
      WRITE (IPRT,1200)
      CALL LLSP(Y2, X, N2, NDEG, RES, LDSTAK)
      WRITE (IPRT,2000) IERR
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT ('1*CH8')
 1100 FORMAT (' SIMPLE TEST OF LLS')
 1200 FORMAT ('1SIMPLE TEST OF LLSP')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
!
      END
!SUMID
      SUBROUTINE SUMID(X, N, XMEAN, SUMDI)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO CALCULATE THE SUM OF THE PRODUCTS OF I AND THE I TH
!     DIFFERENCE AMONG THE ELEMENTS OF THE VECTOR X - XMEAN.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SUMDI,XMEAN
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DIFF
      INTEGER
     +   I
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DIFF
!        THE DIFFERENCE OF A VALUE OF X AND THE WEIGHTED MEAN OF X.
!     INTEGER I
!        A LOOP INDEX.
!     INTEGER N
!        INPUT PARAMETER.  THE NUMBER OF ELEMENTS IN X.
!     DOUBLE PRECISION SUMDI
!        OUTPUT PARAMETER.  THE SUM OF THE PRODUCTS OF I AND THE
!        ELEMENTS OF THE VECTOR X - XMEAN.
!     DOUBLE PRECISION X(N)
!        INPUT PARAMETER.  THE VECTOR OF N DATA VALUES.
!     DOUBLE PRECISION XMEAN
!        INPUT PARAMETER.  THE MEAN OF X.
!
      SUMDI = 0.0D0
      DO 10 I=1,N
         DIFF = X(I) - XMEAN
         SUMDI = SUMDI + I*DIFF
   10 CONTINUE
      RETURN
      END
!UFSEST
      SUBROUTINE UFSEST(ACOV, W, LAG, SPCF, ISPCF, LACOV, LW, NF, FREQ,
     +   DELTA)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE SPECTRUM, SPCF, AND
!     THEIR LOWER AND UPPER CONFIDENCE LIMITS, SPCLCL AND SPCUCL,
!     RESPECTIVELY.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA
      INTEGER
     +   ISPCF,LACOV,LAG,LW,NF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(LACOV),FREQ(NF),SPCF(ISPCF),W(LW)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   C,PI,V0,V1,V2
      INTEGER
     +   I,K,KK
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
!
!  INTRINSIC FUNCTIONS
      INTRINSIC COS
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV)
!        THE AUTOCOVARIANCES OF THE SERIES.
!     DOUBLE PRECISION C
!        A VALUE USED TO COMPUTE THE SPECTRUM VALUES.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER K, KK
!        INDEXING VARIABLES.
!     INTEGER LACOV
!        THE LENGTH OF VECTOR ACOV.
!     INTEGER LAG
!        THE LAG WINDOW TRUCCATION POINT.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     DOUBLE PRECISION PI
!        THE VALUE OF PI.
!     DOUBLE PRECISION SPCF(ISPCF)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     DOUBLE PRECISION V0, V1, V2
!        CONSTANTS USED FOR COMPUTING THE SPECTRUM VALUES.
!     DOUBLE PRECISION W(LW)
!        THE VECTOR OF LAG WINDOWS.
!
      CALL GETPI(PI)
!
!        COMPUTE THE SPECTRUM AND ITS CONFIDENCE LIMITS.
!
      DO 20 I=1,NF
         C = COS(2.0D0*PI*FREQ(I))
         V0 = 0.0D0
         V1 = 0.0D0
         DO 10 K=1,LAG
            KK = LAG + 1 - K
            V2 = 2.0D0*C*V1 - V0 + W(KK+1)*ACOV(KK+1)
            V0 = V1
            V1 = V2
   10    CONTINUE
         SPCF(I) = DELTA*(ACOV(1)*W(1)+2.0D0*(V1*C-V0))
         IF (SPCF(I).LT.0.0D0) SPCF(I) = 0.0D0
   20 CONTINUE
      RETURN
      END
!ERSLFS
      SUBROUTINE ERSLFS(NMSUB, FC, K, HEAD, ERROR)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PERFORMS ERROR CHECKING FOR THE INPUT
!     VALUES USED TO SPECIFY SYMMETRIC LINEAR FILTERING OF A
!     TIME SERIES
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC
      INTEGER
     +   K
      LOGICAL
     +   ERROR,HEAD
!
!  ARRAY ARGUMENTS
      CHARACTER
     +   NMSUB(6)*1
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   TEMP
      INTEGER
     +   IPRT
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION FC
!        THE USER SUPPLIED CUTOFF FREQUENCY.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER K
!        THE NUMBER OF TERMS IN THE FILTER.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THE CALLING SUBROUTINE.
!     DOUBLE PRECISION TEMP
!        A TEMPORARY VARIABLE USED FOR TYPE CONVERSION.
!
      ERROR = .FALSE.
      TEMP = K
!
      IF (FC - 1.0D0/TEMP .GE. 0.0D0) GO TO 10
!
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
      WRITE (IPRT, 1010) FC, K
      ERROR = .TRUE.
      RETURN
!
   10 CONTINUE
!
      IF (FC + 1.0D0/K .LT. 0.5D0) RETURN
!
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
      WRITE (IPRT, 1020) FC, K
      ERROR = .TRUE.
      RETURN
!
!     FORMAT STATEMENTS
!
 1010 FORMAT (/36H THE CUTOFF FREQUENCY, FC, MINUS ONE,
     +   41H OVER THE NUMBER OF FILTER TERMS, K, THAT/
     +   53H IS, FC - 1/K, MUST BE GREATER THAN OR EQUAL TO ZERO.,
     +   29H THE INPUT VALUES OF FC AND K/
     +   4H ARE, F8.5, 4H AND, I5, 15H, RESPECTIVELY.)
 1020 FORMAT (/35H THE CUTOFF FREQUENCY, FC, PLUS ONE,
     +   45H OVER THE NUMBER OF FILTER TERMS, K, THAT IS,/
     +   49H FC + 1/K, MUST BE GREATER THAN OR EQUAL TO ZERO.,
     +   29H THE INPUT VALUES OF FC AND K/
     +   4H ARE, F7.5, 4H AND, I5, 15H, RESPECTIVELY.)
!
      END
!UAS
      SUBROUTINE UAS (Y, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
!     SPECTRUM ESTIMATION (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,VAR,YMEAN
      INTEGER
     +   IAR,IPRT,LACOV,LAG,LAGMAX,LAIC,LDSMIN,LDSTAK,LPCV,LPHI,
     +   LSPC,LWORK,NF,NPRT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),AIC(101),FREQ(101),FTEST(2,100),PHI(100),SPCA(101),
     +   SPCF(101),WORK(101),XAXIS(207),YAXIS(207)
      INTEGER
     +   ISORT(101),ISYM(207)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACVF,IPRINT,PARZEN,SETLAG,UASDV,UASER
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(101)
!        THE AUTOCOVARIANCE COMPUTED FROM THE LAG PRODUCT PAIRS.
!     DOUBLE PRECISION AIC(101)
!        THE ARRAY CONTAINING AKIAKES CRITERIA FOR EACH ORDER.
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
!        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     DOUBLE PRECISION FTEST(2, 100)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISYM(207)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE COVARIANCE ARRAYS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE ARRAY AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER LSPC
!         THE LENGTH OF THE SPECTRUM ARRAYS.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
!        ARE TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE TYPE OF WINDOW TO BE USED.
!     DOUBLE PRECISION PHI(100)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     DOUBLE PRECISION SPCA(101)
!        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!     DOUBLE PRECISION SPCF(101)
!        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
!     DOUBLE PRECISION VAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED MODEL.
!     DOUBLE PRECISION WORK(101)
!        A DOUBLE PRECISION WORK AREA USED FOR THE LAG WINDOWS AND FOR
!        COMPUTING THE AUTOREGRESSIVE COEFFICIENTS.
!     DOUBLE PRECISION XAXIS(207)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YAXIS(207)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'U',       'A',       'S',       ' ',       ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(4) = .FALSE.
!
      LAG = 0
      IAR = 0
      NF = 101
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = -1
      LDSTAK = 0
      LDSMIN = 0
!
!     SET THE MAXIMUM NUMBER OF LAGS TO BE USED.
!
      CALL SETLAG(N, LAGMAX)
!
!     CALL ERROR CHECKING ROUTINE
!
      CALL UASER(NMSUB, N, ACOV, IAR, PHI, LAGMAX, LAG, LACOV,
     +   NF, LDSTAK, LDSMIN, N, N, OPTION)
!
      IF (IERR.NE.0) THEN
         IERR = 1
         CALL IPRINT (IPRT)
         WRITE (IPRT, 1000)
         RETURN
      END IF
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      LPCV = 207
      LSPC = 101
      LPHI = 100
      LAIC = 101
      LACOV = 101
      LWORK = 101
!
      ALPHA = .95D0
      DELTA = 1.0D0
!
!     COMPUTE AUTOCOVARIANCES
!
      CALL ACVF (Y, N, YMEAN, ACOV, LAGMAX, LACOV)
!
!     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
!
      CALL UASDV(ACOV, SPCA, SPCF, LSPC, IAR, PHI, NF, FMIN, FMAX, FREQ,
     +   N, LAGMAX, FTEST, AIC, WORK, LACOV, LWORK, DELTA, ISORT,
     +   ISYM, XAXIS, YAXIS, LPCV, ALPHA, LAG, LAIC, LPHI, NPRT, VAR,
     +   PARZEN, NMSUB)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   22H       CALL UAS (Y, N))
      END
!UASOUT
      SUBROUTINE UASOUT (XAXIS, YAXIS, ISYM, NPTS, BW, IDF, LAG,
     +   IAR, PHI, ISPCER, LPCV, XPLTMN, XPLTMX, YPLTMN, YPLTMX,
     +   FTEST, AIC, LAIC, VAR, NPRT, LAGMAX, AICPRT, N, NMSUB)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES THE SPECTRUM PLOTS FOR THE
!     AUTOREGRESSIVE SPECTRUM ESTIMATES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   BW,VAR,XPLTMN,XPLTMX,YPLTMN,YPLTMX
      INTEGER
     +   IAR,IDF,ISPCER,LAG,LAGMAX,LAIC,LPCV,N,NPRT,NPTS
      LOGICAL
     +   AICPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AIC(LAIC),FTEST(2,LAGMAX),PHI(LAGMAX),XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISYM(LPCV)
      CHARACTER
     +   NMSUB(6)*1
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XMN,XMX,YMN,YMX
      INTEGER
     +   ILOG,IPRT
      LOGICAL
     +   ERROR
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PRHO(1)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AOSLST,IPRINT,PPLMT,PPMN,VERSP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AIC(LAIC)
!        THE ARRAY CONTAINING AKIAKES CRITERIA FOR EACH ORDER.
!     LOGICAL AICPRT
!        AN INDICATOR VARIABLE USED TO DETERMINE IF THE AKIAKE
!        INFORMATION CRITERIA AND CHI SQUARED STATISTICS SHOULD
!        BE PRINTED.
!     DOUBLE PRECISION BW
!        THE BANDWIDTH.
!     LOGICAL ERROR
!        AN ERROR FLAG
!     DOUBLE PRECISION FTEST(2,LAGMAX)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IDF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     INTEGER IPRT
!        THE LOGICAL UNIT NUMBER FOR THE OUTPUT.
!     INTEGER ISPCER
!        A VARIABLE USED TO DESIGNATE AN ERROR IN THE SPECTRAL
!        ESTIMATES.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR THE FOURIER SPECTRUM.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE ARRAY AIC.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     DOUBLE PRECISION PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     DOUBLE PRECISION PRHO(1)
!        A DUMMY VARIABLE.
!     DOUBLE PRECISION VAR
!        THE ONE STEP PREDICTION VARIANCE FOR ORDER IAR.
!     DOUBLE PRECISION XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRAL PLOT.
!     DOUBLE PRECISION XMN, XMX
!     DOUBLE PRECISION XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     DOUBLE PRECISION YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRAL PLOT.
!     DOUBLE PRECISION YMN, YMX
!        *
!     DOUBLE PRECISION YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
!     SET LOGICAL UNIT NUMBER FOR OUTPUT AND SET OUTPUT WIDTH.
!
      CALL IPRINT (IPRT)
!
      IF (.NOT. AICPRT) GO TO 5
!
!     PRINT AUTOREGRESSIVE MODEL ORDER SELECTION STATISTICS
!
      CALL VERSP(.TRUE.)
      WRITE(IPRT, 1007)
      CALL AOSLST (PRHO, AIC, FTEST, LAGMAX, LAIC, IAR, PHI, VAR,
     +   .FALSE., N)
      WRITE (IPRT, 1001)
!
    5 CONTINUE
      CALL VERSP(.TRUE.)
!
      WRITE(IPRT, 1002) LAG, BW, IDF
      WRITE(IPRT, 1000) IAR
      IF (ISPCER .EQ. 0) GO TO 10
      WRITE(IPRT, 1006)
      RETURN
!
   10 CONTINUE
      IF (NPRT.LE.0) THEN
        ILOG = 0
      ELSE
        ILOG = 1
      END IF
!
      CALL PPLMT(YAXIS, YAXIS, XAXIS, XAXIS, NPTS, 1, LPCV, YPLTMN,
     +  YPLTMX, YMN, YMX, XPLTMN, XPLTMX, XMN, XMX, ERROR, NMSUB,
     +  .FALSE.)
      IF (.NOT.ERROR)
     +   CALL PPMN (YAXIS, YAXIS, XAXIS, XAXIS, NPTS, 1, LPCV, 1, ISYM,
     +    LPCV, 0, -1, YMN, YMX, XMN, XMX, .FALSE., ILOG)
      IF (XPLTMN .NE. 0.0D0 .OR. XPLTMX .NE. 0.5D0) RETURN
      WRITE (IPRT, 1004)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (11H AND ORDER , I2, 28H AUTOREGRESSIVE SPECTRUM (.))
 1001 FORMAT ('1')
 1002 FORMAT (44H FOURIER SPECTRUM (+) (LAG WIND. TRUNC. PT.=, I5,
     +   1X, 5H/ BW=, F6.4, 1X, 6H/ EDF=, I6, ')')
 1004 FORMAT(5H+FREQ/
     +   7H PERIOD, 9X, 3HINF, 7X, 3H20., 7X, 3H10., 8X, 6H6.6667, 4X,
     +   2H5., 8X, 2H4., 8X, 6H3.3333, 4X, 6H2.8571, 4X, 3H2.5, 7X,
     +   6H2.2222, 4X, 2H2.)
!1005 FORMAT(5H+FREQ/
!    1   7H PERIOD, 9X, 3HINF, 7X, 3H10., 4X, 2H5., 8X, 6H3.3333, 4X,
!    2   3H2.5, 4X, 2H2.)
 1006 FORMAT(//
     +   56H ** THE PLOT HAS BEEN SUPRESSED BECAUSE FEWER THAN    **/
     +   56H ** FOUR VALID (POSITIVE) SPECTRAL ESTIMATES COULD BE **/
     +   56H ** COMPUTED.                                         **)
 1007 FORMAT (/42H AUTOREGRESSIVE ORDER SELECTION STATISTICS/)
      END
!MGS
      SUBROUTINE MGS(A, B, N, NP, X, C, D, R, IR, IA, IER)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE SOLUTION  X  TO THE LINEAR SYSTEM OF
!     EQUATIONS  AX=B, USING THE METHOD OF MODIFIED GRAM-SCHMIDT.
!     THE MATRIX A IS DECOMPOSED INTO THREE MATRICES
!        Q  AN ORTHOGONAL MATRIX
!        D  A DIAGONAL MATRIX AND
!        R  AN UPPER TRIANGULAR MATRIX
!     THE SOLUTION VECTOR X IS THE VECTOR WHICH SOLVES THE SYSTEM
!     OF EQUATIONS  RX = C
!     X, A, AND B ARE NOT PRESERVED ON OUTPUT
!
!     ADAPTED FROM OMNITAB II BY -
!                  JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IA,IER,IR,N,NP
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   A(IA,NP),B(N),C(NP),D(NP),R(IR,NP),X(NP)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   SM1,SM2
      INTEGER
     +   I,J,JJ,K,NPJJMJ
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION A(IA,NP)
!           THE COEFFICIENTS MATRIX (NOT PRESERVED ON OUTPUT)
!     DOUBLE PRECISION B(N)
!           THE CONSTANT COLUMN MATRIX OF THE SYSTEM (NOT PRESERVED
!           ON OUTPUT)
!     DOUBLE PRECISION C(NP)
!           THE MATRIX C DESCRIBED ABOVE
!     DOUBLE PRECISION D(NP)
!           THE DIAGONAL ELEMENTS OF THE MATRIX D DESCRIBED ABOVE
!     INTEGER I
!           *
!     INTEGER IA
!           THE ROW DIMENSION OF A.
!     INTEGER IER
!           *
!     INTEGER IR
!           THE ROW DIMENSION OF R.
!     INTEGER J
!           *
!     INTEGER JJ
!           *
!     INTEGER K
!           *
!     INTEGER N
!           THE NUMBER OF OBSERVATIONS
!     INTEGER NP
!           THE NUMBER OF PARAMETERS
!     INTEGER NPJJMJ
!           *
!     DOUBLE PRECISION R(IR,NP)
!           THE UPPER ELEMENTS OF THE MATRIX R DESCRIBED ABOVE
!     DOUBLE PRECISION SM1
!           *
!     DOUBLE PRECISION SM2
!           *
!     DOUBLE PRECISION X(NP)
!           THE SOLUTION MATRIX
!
!
      IER = 0
!
      SM1 = 0.0D0
      SM2 = 0.0D0
      DO 10 I=1,N
         SM1 = A(I,1)*A(I,1) + SM1
         SM2 = A(I,1)*B(I) + SM2
   10 CONTINUE
      IF (SM1.EQ.0.0D0) GO TO 100
      D(1) = SM1
      C(1) = SM2/SM1
      IF (NP.EQ.1) GO TO 70
      DO 60 K=2,NP
         DO 40 J=K,NP
            SM1 = 0.0D0
            DO 20 I=1,N
               SM1 = A(I,K-1)*A(I,J) + SM1
   20       CONTINUE
            R(K-1,J) = SM1/D(K-1)
            DO 30 I=1,N
               A(I,J) = A(I,J) - A(I,K-1)*R(K-1,J)
   30       CONTINUE
   40    CONTINUE
         SM1 = 0.0D0
         SM2 = 0.0D0
         DO 50 I=1,N
            B(I) = B(I) - A(I,K-1)*C(K-1)
            SM1 = A(I,K)*A(I,K) + SM1
            SM2 = A(I,K)*B(I) + SM2
   50    CONTINUE
         IF (SM1.EQ.0.0D0) GO TO 100
         D(K) = SM1
         C(K) = SM2/SM1
   60 CONTINUE
!
!     COMPLETE BACKSOLVE
!
   70 X(NP) = C(NP)
      IF (NP.EQ.1) RETURN
      DO 90 I=2,NP
         K = NP + 1 - I
         JJ = K + 1
         SM1 = 0.0D0
         DO 80 J=JJ,NP
            NPJJMJ = NP + JJ - J
            SM1 = R(K,NPJJMJ)*X(NPJJMJ) + SM1
   80    CONTINUE
         X(K) = C(K) - SM1
   90 CONTINUE
      RETURN
  100 IER = 1
      RETURN
      END
!UFSDRV
      SUBROUTINE UFSDRV(Y, LY, YMISS, ACOV, NLPPA, SPCF, ISPCF, NF,
     +   FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS, WORK, LACOV, LWORK,
     +   DELTA, ISORT, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, WINDOW,
     +   NMSUB, LDSMIN, LDSTAK, OPTION, LNLPPA, NFFT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLING ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS .
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS
      INTEGER
     +   ISPCF,LACOV,LAGMAX,LDSMIN,LDSTAK,LNLPPA,LPCV,LWORK,LY,N,
     +   NF,NFFT,NPRT,NW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),FREQ(*),SPCF(*),WORK(*),XAXIS(*),Y(*),YAXIS(*)
      INTEGER
     +   ISORT(*),ISYM(*),LAGS(*),NLPPA(*)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL WINDOW
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALOW,AUP,BW,DF,FMN,FMX,SPCFMN,SPCFMX,XPLTMN,XPLTMX,YMEAN,
     +   YPLTMN,YPLTMX
      INTEGER
     +   I,ILOG,ISPCER,LAG,LAGLST,NFUSED,NPTS,NSPC,NWUSED
      LOGICAL
     +   NEWPG,UNIVAR
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   LSTLAG
      EXTERNAL LSTLAG
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACVF,ACVFF,ACVFM,SETFRQ,SPCCK,UFSER,UFSLAG,UFSMN,UFSOUT,
     +   UFSPCV
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN,NINT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV)
!        THE AUTOCOVARIANCE.
!     DOUBLE PRECISION ALOW
!        A FACTOR USED TO COMPUTE THE LOWER CONFIDENCE LIMITS.
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION AUP
!        A FACTOR USED TO COMPUTE THE UPPER CONFIDENCE LIMITS.
!     DOUBLE PRECISION BW
!        THE BANDWIDTH.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FMN, FMX
!        THE MAXIMUM AND MINIMUM FREQUENCES ACTUALLY USED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER ILOG
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        ILOG = 0 THE PLOT IS LINEAR/LINEAR, IF
!        ILOG = 1 THE PLOT IS LOG/LINEAR, IF
!        ILOG = 2 THE PLOT IS LINEAR/LOG, AND IF
!        ILOG = 3 THE PLOT IS LOG/LOG.
!     INTEGER ISORT(NF)
!        THE VECTOR USED FOR SORTING.
!     INTEGER ISPCER
!        AN ERROR FLAG USED FOR THE SPECTRUM PLOTS.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAG
!        THE LAG WINDWO TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGLST
!        THE LAST LAG BEFORE MISSING DATA CAUSED AN ACVF
!        TO BE UNABLE TO BE COMPUTED.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     LOGICAL NEWPG
!        THE LOGICAL VARIABLE USED TO DETERMINE IF OUTPUT
!        WILL BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NFUSED
!        THE NUMBER OF FREQUENCIES ACTUALLY USED.
!     INTEGER NLPPA(LNLPPA)
!        THE ARRAY CONTAINING THE NUMBER OF LAG PRODUCT PAIRS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     INTEGER NSPC
!        THE NUMBER OF VALID (POSITIVE) SPECTRUM VALUES.
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     INTEGER NWUSED
!        THE NUMBER OF DIFFERENT BANDWIDTHS ACTUALLY USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     DOUBLE PRECISION SPCF(ISPCF,NW)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     DOUBLE PRECISION SPCFMN, SPCFMX
!        THE MINIMUM AND MAXIMUM SPECTRUM VALUE TO BE PLOTTED.
!     LOGICAL UNIVAR
!        THE LOGICAL VARIABLE USED TO DETERMINE IF THE OUTPUT
!        IS FOR UNIVARIATE (TRUE) OR BIVARIATE (FALSE) SPECTRA.
!     EXTERNAL WINDOW
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION WORK(LWORK)
!        THE VECTOR OF LAG WINDOWS.
!     DOUBLE PRECISION XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     DOUBLE PRECISION Y(LY)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!     DOUBLE PRECISION YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
      NFUSED = NF
      IF (OPTION(4)) THEN
        FMN = MAX(FMIN, 0.0D0)
        FMX = MIN(FMAX, 0.5D0)
        IF (FMN.GE.FMX) THEN
          FMN = 0.0D0
          FMX = 0.5D0
        END IF
      ELSE
!
!       SET VARIOUS VALUES FOR SHORT FORMS OF CALL STATEMENT
!
        NPRT = -1
        FMN = 0.0D0
        FMX = 0.5D0
      END IF
!
!     CHECK FOR ERRORS
!
      CALL UFSER(NMSUB, N, LAGMAX, LACOV, NFUSED, ISPCF, NW, LAGS,
     +  LDSTAK, LDSMIN, LY, NFFT, OPTION)
!
      IF (IERR.EQ.1) RETURN
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      ALPHA = 0.95D0
      DELTA = 1.0D0
!
!     COMPUTE COVARIANCES
!
      LAGLST = LAGMAX
      IF (OPTION(1)) THEN
        CALL ACVFF(Y, N, NFFT, YMEAN, ACOV, LAGMAX, LACOV,
     +   LY, WORK, NFFT)
      ELSE
        IF (.NOT.OPTION(3)) THEN
          IF (OPTION(2)) THEN
            CALL ACVFM(Y, YMISS, N, YMEAN, ACOV, LAGMAX, LAGLST,
     +        NLPPA, LACOV)
          ELSE
            CALL ACVF(Y, N, YMEAN, ACOV, LAGMAX, LACOV)
          END IF
        END IF
      END IF
      IF (OPTION(2) .AND. OPTION(3)) LAGLST = LSTLAG(NLPPA,LAGMAX,LACOV)
!
      IF (LAGLST.GE.1) GO TO 20
!
!     AN ERROR HAS BEEN DETECTED
!
      IERR = 2
      RETURN
!
   20 CONTINUE
!
!     COMPUTE THE VECTOR OF LAG WINDOW TRUNCATION POINTS, ORDERED
!     SMALLEST TO LARGEST.
!
      NWUSED = NW
      IF (.NOT.OPTION(4)) CALL UFSLAG(ACOV, LAGLST, LAGS, N, NW,
     +   NWUSED, LACOV)
!
!     BEGIN COMPUTING FOURIER SPECTRUM FOR SERIES
!
      UNIVAR = .TRUE.
!
      IF (NPRT.GE.1) THEN
        ILOG = 1
      ELSE
        ILOG = 0
      END IF
!
      XPLTMN = FMN
      XPLTMX = FMX
!
!     SET FREQUENCIES FOR THE SPECTRUM.
!
      CALL SETFRQ(FREQ, NFUSED, 2, FMN, FMX, DELTA)
!
!     COMPUTE AND PLOT SPECTRUM VALUES.
!
      NEWPG = .FALSE.
!
      DO 50 I=1,NWUSED
         LAG = LAGS(I)
         ISPCER = 0
         IF (LAG.LE.LAGLST) GO TO 30
         ISPCER = 2
         DF = 0.0D0
         GO TO 40
!
   30    CALL UFSMN(ACOV, NLPPA, LAG, DF, NFUSED, FREQ, ALPHA, BW,
     +              SPCF(1+(I-1)*ISPCF), ALOW, AUP, LACOV, ISPCF,
     +              WINDOW, WORK, LAG, N, DELTA, OPTION(2), LNLPPA)
!
         IF (NPRT.EQ.0) GO TO 50
!
         ISPCER = 0
         CALL SPCCK(SPCF(1+(I-1)*ISPCF), ISORT, NFUSED,
     +              SPCFMN, SPCFMX, NSPC, ISPCER)
!
         IF (ISPCER.NE.0) GO TO 40
!
         CALL UFSPCV(SPCF(1+(I-1)*ISPCF), SPCFMN, SPCFMX,
     +               FREQ, NFUSED, XAXIS, YAXIS, ISYM, NPTS, ISPCF,
     +               NFUSED+5, NSPC, BW, ALOW, AUP,
     +               XPLTMN, XPLTMX, YPLTMN, YPLTMX, NPRT)
!
   40    CALL UFSOUT(XAXIS, YAXIS, ISYM, NPTS, BW, NINT(DF), LAG,
     +      LAGLST, NEWPG, ISPCER, NFUSED+5, XPLTMN, XPLTMX, YPLTMN,
     +      YPLTMX, ILOG, YAXIS, XAXIS, NPTS, UNIVAR, NMSUB)
!
         NEWPG = .TRUE.
!
   50 CONTINUE
!
      RETURN
!
      END
!ACF
      SUBROUTINE ACF (Y, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
!     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
!     (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN,YSD
      INTEGER
     +   IAR,IPRT,LACOV,LAGMAX,LAIC,LDSMIN,LDSTAK,LYFFT,NFAC,NFFT,
     +   NPRT
      LOGICAL
     +   DIFFER,ISFFT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),AIC(101),FTEST(2,100),PHI(100),PRHO(100),RHO(100),
     +   SDRHO(100),WORK(100)
      INTEGER
     +   IOD(1),ND(1),NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACFER,ACFMN,ACFOUT,IPRINT,SETLAG
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (ACOV(2),RHO(1))
      EQUIVALENCE (WORK(1),SDRHO(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(101)
!        THE AUTOCOVARIANCE FUNCTION ESTIMATE VECTOR.
!     DOUBLE PRECISION AIC(101)
!        THE ARRAY CONTAINING AKIAKES CRITERIA FOR EACH ORDER.
!     DOUBLE PRECISION CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     LOGICAL DIFFER
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
!     DOUBLE PRECISION FTEST(2, 100)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IOD(1)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER ND(1)
!        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
!     INTEGER NDUM(1)
!        A DUMMY ARRAY.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING THE PRINTED OUTPUT.
!     DOUBLE PRECISION OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED ORDER (IAR).
!     DOUBLE PRECISION PHI(100)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     DOUBLE PRECISION PRHO(100)
!        THE ARRAY CONTAINING THE PARTIAL ACF ESTIMATES.
!     DOUBLE PRECISION RHO(100)
!        THE ARRAY CONTAINING THE ACF ESTIMATES.
!     DOUBLE PRECISION SDRHO(100)
!        THE ARRAY CONTAINING THE STANDARD ERRORS OF THE ACF ESTIMATES.
!     DOUBLE PRECISION WORK(100)
!        A VECTOR USED IN THE COMPUTATIONS OF THE PARTIAL
!        AUTOCORRELATION COEFFICIENTS.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YMEAN, YSD
!        THE MEAN AND STANDARD DEVIATION OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5), NMSUB(6)
     + /     'A',       'C',       'F',       ' ',       ' ',      ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      LAGMAX = 1
      LACOV = 101
      LAIC = 101
      LDSMIN = 0
      LDSTAK = 0
      NPRT = 1
      DIFFER = .FALSE.
      NFAC = 1
      ND(1) = 0
      IOD(1) = 0
      ISFFT = .FALSE.
      LYFFT = N
      NFFT = N
!
      CALL ACFER(NMSUB, N, LAGMAX, LACOV, LDSTAK, LDSMIN,
     +  DIFFER, NFAC, ND, IOD, ISFFT, LYFFT, NFFT)
!
      IF (IERR.EQ.0) THEN
!
!       SET NUMBER OF ACF TO BE COMPUTED
!
        CALL SETLAG (N, LAGMAX)
!
!       CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
        CALL ACFMN (Y, N, LAGMAX, RHO, SDRHO, YMEAN, PRHO, AIC, FTEST,
     +     PHI, IAR, OSPVAR, ACOV, LACOV, LAIC, CHIA, CHIAP, WORK, NPRT)
!
        YSD = SQRT(ACOV(1) * N / (N-1))
!
!       CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
        CALL ACFOUT (YMEAN, YSD, N, N, LAGMAX, RHO, SDRHO, PRHO, NDUM,
     +     AIC, LAIC, FTEST, IAR, PHI, OSPVAR, CHIA, CHIAP, LAGMAX,
     +     .FALSE., 0.0D0, .FALSE., .FALSE., 0, NDUM, NDUM, 0)
      END IF
!
      IF (IERR.NE.0) THEN
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   22H       CALL ACF (Y, N))
      END
!XDEMOD
      SUBROUTINE XDEMOD(LDS,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE TIME SERIES
!     COMPLEX DEMODULATION ROUTINES.
!
!     SERIES Y IS THE WOLF SUNSPOT DATA FROM 1700 TO 1960 AS
!     TABULATED BY WALDMEIER
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDS
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FC,FD
      INTEGER
     +   I,IPRT,ITEST,K,LDSTAK,N,NDEM,NPRT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AMPL(300),PHAS(300),Y(300)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DEMOD,DEMODS,IPRINT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AMPL(300)
!        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FC
!        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
!     DOUBLE PRECISION FD
!        THE DEMODULATION FREQUENCY.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER ITEST
!        THE NUMBER OF THE TEST BEING RUN
!     INTEGER K
!        THE NUMBER OF TERMS IN THE SYMETRIC LINEAR FILTER.
!     INTEGER LDS, LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE INPUT SERIES.
!     INTEGER NDEM
!        THE NUMBER OF VALUES IN THE DEMODULATED SERIES, I. E., IT
!        IS THE NUMBER OF VALUES IN THE AMPLITUDE AND PHASE ARRAYS.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT .EQ. 0 THE PLOT IS SUPPRESSED
!        NPRT .NE. 1 THE PLOT IS PROVIDED
!     DOUBLE PRECISION PHAS(300)
!        THE ARRAY IN WHICH THE PRIMARY PHASE ESTIMATES ARE RETURNED.
!     DOUBLE PRECISION Y(300)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!
      DATA   Y(  1),  Y(  2),  Y(  3),  Y(  4),  Y(  5),  Y(  6)
     +    /     5.0D0, 11.0D0, 16.0D0, 23.0D0, 36.0D0, 58.0D0/
      DATA   Y(  7),  Y(  8),  Y(  9),  Y( 10),  Y( 11),  Y( 12)
     +    /    29.0D0, 20.0D0, 10.0D0,  8.0D0,  3.0D0,  0.0D0/
      DATA   Y( 13),  Y( 14),  Y( 15),  Y( 16),  Y( 17),  Y( 18)
     +    /     0.0D0, 2.0D0, 11.0D0, 27.0D0, 47.0D0, 63.0D0/
      DATA   Y( 19),  Y( 20),  Y( 21),  Y( 22),  Y( 23),  Y( 24)
     +    /    60.0D0, 39.0D0, 28.0D0, 26.0D0, 22.0D0, 11.0D0/
      DATA   Y( 25),  Y( 26),  Y( 27),  Y( 28),  Y( 29),  Y( 30)
     +    /    21.0D0, 40.0D0, 78.0D0,122.0D0,103.0D0, 73.0D0/
      DATA   Y( 31),  Y( 32),  Y( 33),  Y( 34),  Y( 35),  Y( 36)
     +    /    47.0D0, 35.0D0, 11.0D0,  5.0D0, 16.0D0, 34.0D0/
      DATA   Y( 37),  Y( 38),  Y( 39),  Y( 40),  Y( 41),  Y( 42)
     +    /    70.0D0, 81.0D0,111.0D0,101.0D0, 73.0D0, 40.0D0/
      DATA   Y( 43),  Y( 44),  Y( 45),  Y( 46),  Y( 47),  Y( 48)
     +    /    20.0D0, 16.0D0,  5.0D0, 11.0D0, 22.0D0, 40.0D0/
      DATA   Y( 49),  Y( 50),  Y( 51),  Y( 52),  Y( 53),  Y( 54)
     +    /    60.0D0, 80.9D0, 83.4D0, 47.7D0, 47.8D0, 30.7D0/
      DATA   Y( 55),  Y( 56),  Y( 57),  Y( 58),  Y( 59),  Y( 60)
     +    /    12.2D0,  9.6D0, 10.2D0, 32.4D0, 47.6D0, 54.0D0/
      DATA   Y( 61),  Y( 62),  Y( 63),  Y( 64),  Y( 65),  Y( 66)
     +    /    62.9D0, 85.9D0, 61.2D0, 45.1D0, 36.4D0, 20.9D0/
      DATA   Y( 67),  Y( 68),  Y( 69),  Y( 70),  Y( 71),  Y( 72)
     +    /    11.4D0, 37.8D0, 69.8D0,106.1D0,100.8D0, 81.6D0/
      DATA   Y( 73),  Y( 74),  Y( 75),  Y( 76),  Y( 77),  Y( 78)
     +    /    66.5D0, 34.8D0, 30.6D0,  7.0D0, 19.8D0, 92.5D0/
      DATA   Y( 79),  Y( 80),  Y( 81),  Y( 82),  Y( 83),  Y( 84)
     +    /   154.4D0,125.9D0, 84.8D0, 68.1D0, 38.5D0, 22.8D0/
      DATA   Y( 85),  Y( 86),  Y( 87),  Y( 88),  Y( 89),  Y( 90)
     +    /    10.2D0, 24.1D0, 82.9D0,132.0D0,130.9D0,118.1D0/
      DATA   Y( 91),  Y( 92),  Y( 93),  Y( 94),  Y( 95),  Y( 96)
     +    /    89.9D0, 66.6D0, 60.0D0, 46.9D0, 41.0D0, 21.3D0/
      DATA   Y( 97),  Y( 98),  Y( 99),  Y(100),  Y(101),  Y(102)
     +    /    16.0D0,  6.4D0,  4.1D0,  6.8D0, 14.5D0, 34.0D0/
      DATA   Y(103),  Y(104),  Y(105),  Y(106),  Y(107),  Y(108)
     +    /    45.0D0, 43.1D0, 47.5D0, 42.2D0, 28.1D0, 10.1D0/
      DATA   Y(109),  Y(110),  Y(111),  Y(112),  Y(113),  Y(114)
     +    /     8.1D0,  2.5D0,  0.0D0,  1.4D0,  5.0D0, 12.2D0/
      DATA   Y(115),  Y(116),  Y(117),  Y(118),  Y(119),  Y(120)
     +    /    13.9D0, 35.4D0, 45.8D0, 41.1D0, 30.1D0, 23.9D0/
      DATA   Y(121),  Y(122),  Y(123),  Y(124),  Y(125),  Y(126)
     +    /    15.6D0,  6.6D0,  4.0D0,  1.8D0,  8.5D0, 16.6D0/
      DATA   Y(127),  Y(128),  Y(129),  Y(130),  Y(131),  Y(132)
     +    /    36.3D0, 49.6D0, 64.2D0, 67.0D0, 70.9D0, 47.8D0/
      DATA   Y(133),  Y(134),  Y(135),  Y(136),  Y(137),  Y(138)
     +    /    27.5D0,  8.5D0, 13.2D0, 56.9D0,121.5D0,138.3D0/
      DATA   Y(139),  Y(140),  Y(141),  Y(142),  Y(143),  Y(144)
     +    /   103.2D0, 85.7D0, 64.6D0, 36.7D0, 24.2D0, 10.7D0/
      DATA   Y(145),  Y(146),  Y(147),  Y(148),  Y(149),  Y(150)
     +    /    15.0D0, 40.1D0, 61.5D0, 98.5D0,124.7D0, 96.3D0/
      DATA   Y(151),  Y(152),  Y(153),  Y(154),  Y(155),  Y(156)
     +    /    66.6D0, 64.5D0, 54.1D0, 39.0D0, 20.6D0,  6.7D0/
      DATA   Y(157),  Y(158),  Y(159),  Y(160),  Y(161),  Y(162)
     +    /     4.3D0, 22.7D0, 54.8D0, 93.8D0, 95.8D0, 77.2D0/
      DATA   Y(163),  Y(164),  Y(165),  Y(166),  Y(167),  Y(168)
     +    /    59.1D0, 44.0D0, 47.0D0, 30.5D0, 16.3D0,  7.3D0/
      DATA   Y(169),  Y(170),  Y(171),  Y(172),  Y(173),  Y(174)
     +    /    37.6D0, 74.0D0,139.0D0,111.2D0,101.6D0, 66.2D0/
      DATA   Y(175),  Y(176),  Y(177),  Y(178),  Y(179),  Y(180)
     +    /    44.7D0, 17.0D0, 11.3D0, 12.4D0,  3.4D0,  6.0D0/
      DATA   Y(181),  Y(182),  Y(183),  Y(184),  Y(185),  Y(186)
     +    /    32.3D0, 54.3D0, 59.7D0, 63.7D0, 63.5D0, 52.2D0/
      DATA   Y(187),  Y(188),  Y(189),  Y(190),  Y(191),  Y(192)
     +    /    25.4D0, 13.1D0,  6.8D0,  6.3D0,  7.1D0, 35.6D0/
      DATA   Y(193),  Y(194),  Y(195),  Y(196),  Y(197),  Y(198)
     +    /    73.0D0, 85.1D0, 78.0D0, 64.0D0, 41.8D0, 26.2D0/
      DATA   Y(199),  Y(200),  Y(201),  Y(202),  Y(203),  Y(204)
     +    /    26.7D0, 12.1D0,  9.5D0,  2.7D0,  5.0D0, 24.4D0/
      DATA   Y(205),  Y(206),  Y(207),  Y(208),  Y(209),  Y(210)
     +    /    42.0D0, 63.5D0, 53.8D0, 62.0D0, 48.5D0, 43.9D0/
      DATA   Y(211),  Y(212),  Y(213),  Y(214),  Y(215),  Y(216)
     +    /    18.6D0,  5.7D0,  3.6D0,  1.4D0,  9.6D0, 47.4D0/
      DATA   Y(217),  Y(218),  Y(219),  Y(220),  Y(221),  Y(222)
     +    /    57.1D0,103.9D0, 80.6D0, 63.6D0, 37.6D0, 26.1D0/
      DATA   Y(223),  Y(224),  Y(225),  Y(226),  Y(227),  Y(228)
     +    /    14.2D0,  5.8D0, 16.7D0, 44.3D0, 63.9D0, 69.0D0/
      DATA   Y(229),  Y(230),  Y(231),  Y(232),  Y(233),  Y(234)
     +    /    77.8D0, 64.9D0, 35.7D0, 21.2D0, 11.1D0,  5.7D0/
      DATA   Y(235),  Y(236),  Y(237),  Y(238),  Y(239),  Y(240)
     +    /     8.7D0, 36.1D0, 79.7D0,114.4D0,109.6D0, 88.8D0/
      DATA   Y(241),  Y(242),  Y(243),  Y(244),  Y(245),  Y(246)
     +    /    67.8D0, 47.5D0, 30.6D0, 16.3D0,  9.6D0, 33.2D0/
      DATA   Y(247),  Y(248),  Y(249),  Y(250),  Y(251),  Y(252)
     +    /    92.6D0,151.6D0,136.3D0,134.7D0, 83.9D0, 69.4D0/
      DATA   Y(253),  Y(254),  Y(255),  Y(256),  Y(257),  Y(258)
     +    /    31.5D0, 13.9D0,  4.4D0, 38.0D0,141.7D0,190.2D0/
      DATA   Y(259),  Y(260),  Y(261)
     +    /   184.8D0,159.0D0,112.3D0/
!
      CALL IPRINT(IPRT)
      ITEST = 1
      LDSTAK = LDS
!
      N = 261
      NPRT = 1
      FD = 1.0D0/11.0D0
      FC = 1.0D0/22.0D0
      K = 41
!
!     TEST OF DEMOD
!
    5 WRITE (IPRT, 1016)
      CALL DEMOD (Y, N, FD, FC, K, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF DEMODS
!
      WRITE (IPRT, 1017)
      CALL DEMODS (Y, N, FD, FC, K, AMPL, PHAS, NDEM, NPRT, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     PRINT STORAGE FROM DEMODS
!
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (AMPL(I), I = 1, NDEM)
        WRITE (IPRT, 1004) (PHAS(I), I = 1, NDEM)
      END IF
!
      GO TO (100, 200, 300), ITEST
!
!     TEST MINIMUM PROBLEM SPECIFICATIONS
!
  100 ITEST = ITEST + 1
      N = 17
      K = 15
      NPRT = -1
      GO TO 5
!
!     TEST ERROR CONDITIONS
!
  200 ITEST = ITEST + 1
      N = 0
      FD = 0.5D0
      FC = 0.3D0
      K = 1
      GO TO 5
!
  300 RETURN
!
!     FORMAT STATEMENTS
!
 1002 FORMAT (8H IERR IS, I5)
 1004 FORMAT (10F10.5)
 1016 FORMAT ('1', 13HTEST OF DEMOD)
 1017 FORMAT ('1', 14HTEST OF DEMODS)
!
      END
!UFS
      SUBROUTINE UFS(Y, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS
      INTEGER
     +   IPRT,ISPCF,LACOV,LAGMAX,LDSMIN,LDSTAK,LNLPPA,LPCV,LWORK,
     +   LY,NF,NPRT,NW
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),FREQ(101),SPCF(101,4),WORK(101),XAXIS(106),
     +   YAXIS(106)
      INTEGER
     +   ISORT(101),ISYM(106),LAGS(4),NLPPA(1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PARZEN,SETLAG,UFSDRV
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(101)
!        THE AUTOCOVARIANCE AT LAG ZERO (BIASED VARIANCE).
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISYM(106)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(1)
!        A DUMMY ARRAY WHEN THE SERIES DOES NOT CONTAIN MISSING VALUES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION SPCF(101,4)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     DOUBLE PRECISION WORK(101)
!        THE VECTOR OF LAG WINDOWS.
!     DOUBLE PRECISION XAXIS(106)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION Y(N)
!         THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YAXIS(106)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YMISS
!        A DUMMY VARIABLE WHEN THE SERIES DO NOT CONTAIN MISSING VALUES
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S',' ',' ',' '/
!
!     SET UP
!
      OPTION(4) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(1) = .FALSE.
!
      LDSTAK = 0
      LDSMIN = 0
!
      ISPCF = 101
      LACOV = 101
      LNLPPA = 1
      LY = N
      LPCV = 106
      LWORK = 101
      NF = 101
      YMISS = 1.0D0
!
!     SET MAXIMUM LAG VALUE TO BE USED.
!     AND NUMBER OF LAG WINDOW TRUNCATION POINTS TO USE.
!
      CALL SETLAG(N, LAGMAX)
      NW = 4
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!     FOR SERIES WITH MISSING DATA.
!
      CALL UFSDRV(Y, LY, YMISS, ACOV, NLPPA, SPCF, ISPCF, NF, FMIN,
     +   FMAX, FREQ, N, NW, LAGMAX, LAGS, WORK, LACOV, LWORK, DELTA,
     +   ISORT, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, PARZEN, NMSUB,
     +   LDSMIN, LDSTAK, OPTION, LNLPPA, LY)
!
!     CHECK FOR ERRORS
!
      IF (IERR.EQ.0) RETURN
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL UFS (Y, N)')
      END
!XNLSD
      SUBROUTINE XNLSD(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DEMONSTRATE THE USER CALLABLE ROUTINES IN THE NONLINEAR
!     LEAST SQUARES FAMILY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IPRT,IVAPRX,IVCV,IXM1,LDSA1,LDSMIN,LDSN1A,LDSN1B,
     +   M1,MIT,N1,NNZW,NPAR1,NPARE,NPRT,NTEST
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR1(10),PV(100),RES(100),SCALE(10),SDPV(100),SDRES(100),
     +   STP(10),VCV(6,6),WT(100),XM1(10,2),Y1(10)
      INTEGER
     +   IFIXED(10)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DRV1A,FITXSP,IPRINT,LDSCMP,MDL1,NL2X,NLS,NLSC,NLSD,NLSDC,
     +   NLSDS,NLSS,NLSW,NLSWC,NLSWD,NLSWDC,NLSWDS,NLSWS,NLSX1,
     +   NLSX2,SETRV
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV1A
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
!        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(10)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM1
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSA1, LDSN1A, LDSN1B
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK
!        FOR THE ROUTINES WITH ANALYTIC DERIVATIVES AND
!        NUMERICAL DERIVATIVES, RESPECTIVELY.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M1
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL1
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N1
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
!     INTEGER NPAR1
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     DOUBLE PRECISION PAR1(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION PV(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(100)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     DOUBLE PRECISION SCALE(10)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     DOUBLE PRECISION SDPV(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF THE
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(10)
!        THE RCSTEP SIZE ARRAY.
!     DOUBLE PRECISION VCV(6,6)
!        THE COVARIANCE MATRIX.
!     DOUBLE PRECISION WT(100)
!        THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION XM1(10,2)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y1(10)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     DEFINE CONSTANTS
!
      DATA Y1(1), Y1(2), Y1(3), Y1(4), Y1(5), Y1(6)
     +   /2.138D0, 3.421D0, 3.597D0, 4.340D0, 4.882D0, 5.660D0/
!
      DATA XM1(1,1), XM1(2,1), XM1(3,1), XM1(4,1), XM1(5,1), XM1(6,1)
     +   /1.309D0, 1.471D0, 1.490D0, 1.565D0, 1.611D0, 1.680D0/
!
      CALL IPRINT(IPRT)
!
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
!
      CALL SETRV(WT, N1, 1.0D0)
!
      CALL LDSCMP(6, 0, 60+2*NPAR1, 0, 0, 0,
     +   'D', 94+N1*(3+NPAR1)+NPAR1*(3*NPAR1+35)/2, LDSA1)
      CALL LDSCMP(14, 0, MAX(2*(N1+NPAR1),60+2*NPAR1), 0, 0, 0,
     +   'D', MAX(10*N1,94+N1*(3+NPAR1)+NPAR1*(3*NPAR1+37)/2), LDSN1A)
      CALL LDSCMP(14, 0, 60+2*NPAR1, 0, 0, 0,
     +   'D', 94+N1*(3+NPAR1)+NPAR1*(3*NPAR1+37)/2, LDSN1B)
!
      LDSMIN = MAX(LDSA1, LDSN1A, LDSN1B)
!
      IF (LDSMIN.LE.LDSTAK) GO TO 5
!
      WRITE (IPRT, 1140) LDSMIN
      RETURN
!
    5 CONTINUE
!
      NTEST = 0
!
!
!     **TEST ON NORMAL STATEMENT**
!
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1000)
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLS(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSN1A)
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1010)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSC(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSN1B,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1020)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSS(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSN1B,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1030)
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSW(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSN1A)
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1040)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWC(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSN1B, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1050)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWS(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSN1B, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1060)
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSD(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSA1)
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1070)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSDC(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1080)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSDS(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1090)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWD(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSA1)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1100)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWDC(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1110)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
!
!
!     TEST NL2SOL AND NL2SNO DIRECTLY
!
      WRITE (IPRT,1320)
      CALL NL2X(0.0_wp)
!
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (14H TEST OF NLS  )
 1010 FORMAT (15H TEST OF NLSC  )
 1020 FORMAT (15H TEST OF NLSS  )
 1030 FORMAT (14H TEST OF NLSW )
 1040 FORMAT (15H TEST OF NLSWC )
 1050 FORMAT (15H TEST OF NLSWS )
 1060 FORMAT (14H TEST OF NLSD )
 1070 FORMAT (15H TEST OF NLSDC )
 1080 FORMAT (15H TEST OF NLSDS )
 1090 FORMAT (14H TEST OF NLSWD)
 1100 FORMAT (15H TEST OF NLSWDC)
 1110 FORMAT (15H TEST OF NLSWDS)
 1120 FORMAT (/29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1130 FORMAT (15H NORMAL PROBLEM)
 1140 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1320 FORMAT (42H1TEST OF NL2SOL AND NL2SNO CALLED DIRECTLY)
 1330 FORMAT (54H1NONLINEAR LEAST SQUARES ESTIMATION SUBROUTINE TEST NU,
     +   4HMBER, I5/)
 1340 FORMAT (24H INPUT   -  IFIXED(1) = , I6, 9X, 11H, STP(1) = ,
     +   G15.8, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8, 10H, STOPP = ,
     +   G15.8/13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I5)
 1350 FORMAT (//24H OUTPUT  -  IFIXED(1) = , I6, 9X, 11H, STP(1) = ,
     +   G15.8, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8, 10H, STOPP = ,
     +   G15.8/13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I5//)
 1360 FORMAT (24H INPUT   -  IFIXED(1) = , I6, 9X, 11H, IDRVCK = ,
     +   I5, 10X, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8,
     +   10H, STOPP = , G15.8/
     +   13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I6)
 1370 FORMAT (//24H OUTPUT  -  IFIXED(1) = , I6, 9X, 11H, IDRVCK = ,
     +   I5, 10X, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8,
     +   10H, STOPP = , G15.8/
     +   13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I5//)
      END
!BFSF
      SUBROUTINE BFSF(YFFT1, YFFT2, N, LYFFT, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     BIVARIATE SPECTRUM ANALYSIS (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,LYFFT,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YFFT1(*),YFFT2(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS1,YMISS2
      INTEGER
     +   ICCOV,ICSPC2,IFP,INDEX1,INDEX2,INLPPC,IPHAS,IPRT,JCCOV,
     +   JNLPPC,LAGMAX,LAGMX1,LDSMIN,LPCV,LW,LWORK,M,NALL0,NF,NFFT,
     +   NPRT,NW,WORK
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCOV(101,2,2),CEVEN(101),CODD(101),CSPC2(101,4),FREQ(101),
     +   PHAS(101,4),RSTAK(12),SPCF1(101),SPCF2(101),W(101),
     +   XAXIS(404),YAXIS(404)
      INTEGER
     +   ISYM(404),LAGS(4),NLPPC(1,1,1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,IPRINT,LDSCMP,PARZEN,SETESL,SETLAG,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION CCOV(101,2,2)
!        THE COVARIANCES.
!     DOUBLE PRECISION CEVEN(101)
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CODD(101)
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CSPC2(101,4)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISYM(404)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTORS Y1 AND YFFT1 AND YFFT2
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS ON ENTRY
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NLPPC(1,1,1)
!        A DUMMY ARRAY.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION PHAS(101,4)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION SPCF1(101), SPCF2(101)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     DOUBLE PRECISION W(101)
!        THE WINDOWS.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE WORK VECTOR
!     DOUBLE PRECISION XAXIS(404)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YAXIS(404)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YMISS1, YMISS2
!        DUMMY VARIABLES.
!     DOUBLE PRECISION YFFT1(LYFFT)
!        THE FIRST TIME SERIES.
!     DOUBLE PRECISION YFFT2(LYFFT)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','F',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(1) = .TRUE.
      OPTION(2) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(4) = .FALSE.
!
      ICCOV = 101
      JCCOV = 2
      M = 2
      INDEX1 = 1
      INDEX2 = 2
!
      ICSPC2 = 101
      IPHAS = 101
!
      LDSMIN = 0
!
      NF = 101
      YMISS1 = 1.0D0
      YMISS2 = 1.0D0
      INLPPC = 1
      JNLPPC = 1
      LW = 101
      LPCV = 404
!
!     SET MAXIMUM LAG VALUE (LAGMAX)
!     SET NUMBER OF LAG WINDOW TRUCCATION POINTS (NW)
!     SET EXTENDED SERIES LENGTH (NFFT)
!
      CALL SETLAG(N, LAGMAX)
      NW = 4
      CALL SETESL(N+LAGMAX, 4, NFFT)
!
!     COMPUTE MINIMUM ALLOWABLE STACK LENGTH (LDSMIN)
!
      CALL LDSCMP(1, 0, 0, 0, 0, 0, 'D', NFFT, LDSMIN)
!
!     SET SIZE OF WORK AREA
!     SET NUMBER OF OUTSTANDING ALLOCATIONS (NALL0)
!     SET THE STACK ALLOCATION TYPE (IFP)
!
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
!
      IFP = 4
!
!     SET THE STARTING LOCATIONS INTHE WORK AREA FOR VARIOUS ARRAYS
!
      IF ((LDSMIN.LE.LDSTAK) .AND. (LDSMIN.GE.7)) THEN
         WORK = STKGET(NFFT,IFP)
         LWORK = NFFT
      ELSE
         WORK = 1
         LWORK = 1
      END IF
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
      CALL BFSDRV(YFFT1, YFFT2, YMISS1, YMISS2, CCOV, NLPPC, SPCF1,
     +            SPCF2, NF, FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS,
     +            LAGMX1, RSTAK(WORK), LWORK, DELTA, ISYM, XAXIS,
     +            YAXIS, LPCV, ALPHA, NPRT, PARZEN, ICCOV, JCCOV, M,
     +            INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS, CODD,
     +            CEVEN, W, LW, NMSUB, LDSMIN, LDSTAK, OPTION, NFFT,
     +            INLPPC, JNLPPC, LYFFT)
!
      IF (IERR.EQ.0) RETURN
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL BFSF (YFFT1, YFFT2, N, LYFFT, LDSTAK)')
      END
!LOGLMT
      SUBROUTINE LOGLMT (ILOGY, YMN, YMX, YLABEL, NUMROW, ISTEP, DELY,
     +  YWIDTH, NLABLY, YDMN, YDMX)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ADJUST PLOT LIMITS FOR LOG PLOTS, AND COMPUTE LOG AXIS LABELS
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELY,YDMN,YDMX,YMN,YMX,YWIDTH
      INTEGER
     +   ILOGY,ISTEP,NLABLY,NUMROW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YLABEL(20)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   YNLOG,YXLOG
      INTEGER
     +   IYN,IYNLOG,IYX,IYXLOG,J,K
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG10,MIN,MOD,NINT,DBLE
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELY
!     INTEGER ILOGY, ISTEP, IYN, IYNLOG, IYX, IYXLOG, J, K
!     INTEGER NLABLY, NUMROW
!     DOUBLE PRECISION YLABEL(20)
!        THE Y-AXIS LABLES.
!     DOUBLE PRECISION YDMN, YDMX
!        THE Y-AXIS DATA LIMITS ACTUALLY USED.
!     DOUBLE PRECISION YMN, YMX
!        THE Y-AXIS PLOT LIMITS ACTUALLY USED.
!     DOUBLE PRECISION YNLOG, YWIDTH, YXLOG
!
      IF (ILOGY.EQ.0) THEN
!
        YDMN = YMN
        YDMX = YMX
!
!       DETERMINE THE VALUE OF A DIVISION
!
        DELY=YMX-YMN
        YWIDTH=DELY/(NUMROW-1)
!
!       COMPUTE EVENLY SPACED LABELS FOR NON-LOG AXIS
!
        NLABLY = 0
        DO 10 J = 1, NUMROW, ISTEP
          NLABLY = NLABLY + 1
          YLABEL(NLABLY) = YMX+(1-J)*YWIDTH
   10   CONTINUE
          IF (MOD(NUMROW,ISTEP).EQ.1) YLABEL(NLABLY) = YMN
          IF (YMX.EQ.(-YMN) .AND. MOD(NLABLY,2).EQ.1) THEN
             YLABEL(NLABLY/2+1) = 0.0
          END IF
      ELSE
!
        YDMN = LOG10(YMN)
        YDMX = LOG10(YMX)
!
!       ADJUST AXIS LIMITS FOR LOG AXIS IF NECESSARY
!
        YXLOG=LOG10(YMX)
        IYXLOG=YXLOG
        IF (YMX.LT.1.0D0) IYXLOG=IYXLOG-1
        YNLOG=LOG10(YMN)
        IF ((YXLOG-YNLOG).LE.0.92082D0) THEN
!
!         RANGE IS LESS THAN .9 DECADES
!
          IYNLOG=YNLOG
          IF (YMN.LT.1.0D0) IYNLOG=IYNLOG-1
          IF (IYXLOG.LE.IYNLOG) THEN
!
!           VALUES FALL IN THE SAME DECADE
!
            YNLOG=IYNLOG
            YXLOG=YNLOG+1.0D0
            IYXLOG=YXLOG
          ELSE
!
!           VALUES FALL INTO TWO DECADES
!
            IYN=NINT(YMN/(10.0D0**IYNLOG))
            YNLOG=MIN(LOG10(IYN*(10.0D0**IYNLOG)),YNLOG)
            YXLOG=YNLOG+1.0D0
            IYXLOG=YXLOG
          END IF
        END IF
        YMX=YXLOG
        YMN=YNLOG
!
!       DETERMINE THE VALUE OF A DIVISION
!
        DELY=YMX-YMN
        YWIDTH=DELY/(NUMROW-1)
!
!       COMPUTE AXIS LABELS
!
        YLABEL(1)=10.0D0**YXLOG
        IYX=YLABEL(1)/(10.0D0**IYXLOG)
        K=2
        IF (YXLOG-YNLOG.GT.3.0D0) K=5
        IF (YXLOG-YNLOG.GT.6.0D0) K=10
!
        NLABLY = 1
!
        IF (YXLOG-YNLOG.LE.12.0D0) THEN
!
!       SET NICE LABELS
!
          IF (K.EQ.10) IYX=1
          IF (IYX.NE.1.AND.(IYX-((IYX/K)*K)).NE.0) IYX=((IYX/K)*K)
          IF (IYX.LE.1) THEN
            IYX=10
            IYXLOG=IYXLOG-1
          END IF
          IF (YLABEL(1)-IYX*(10.0D0**IYXLOG).GT.0.0D0 .AND.
     +     YXLOG-(YXLOG-YNLOG)/(2.0D0*(NUMROW-1)) .GT.
     +     LOG10(DBLE(IYX))+IYXLOG) IYX=IYX+K
          IYX=IYX-K
          IF (IYX.LE.0) THEN
            IYX=10
            IYXLOG=IYXLOG-1
          END IF
          DO 155 J=2,20
             NLABLY=NLABLY+1
             YLABEL(NLABLY)=IYX*(10.0D0**IYXLOG)
             IF (YLABEL(NLABLY).LE.10.0D0**YNLOG) GO TO 156
             IYX=IYX-K
             IF (IYX.GT.0) GO TO 155
             IYX=10
             IYXLOG=IYXLOG-1
  155     CONTINUE
  156     YLABEL(NLABLY)=10.0D0**YNLOG
        ELSE
!
!         COMPUTE EVENLY SPACED LABELS
!
          DO 160 J = ISTEP, NUMROW, ISTEP
            NLABLY = NLABLY + 1
            YLABEL(NLABLY) = 10.0D0**(YMX+(1.0D0-J)*YWIDTH)
  160     CONTINUE
        END IF
      END IF
!
      RETURN
      END
!UASCFT
      SUBROUTINE UASCFT (ACOV, LAGMAX, LACOV, IAR, PHI, N, VAR)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE AUTOREGRESSIVE MODEL COEFFICIENTS
!     FOR AN ORDER IAR MODEL USING DURBINS RECURSIVE METHOD.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VAR
      INTEGER
     +   IAR,LACOV,LAGMAX,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(LACOV),PHI(IAR)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSS
      INTEGER
     +   L
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ARCOEF
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV)
!        THE ARRAY OF AUTOCOVARIANCE ESTIMATES.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER L
!        AN INDEX VARIABLE.
!     INTEGER LACOV
!        THE LENGTH OF THE ARRAY ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES.
!     DOUBLE PRECISION PHI(IAR)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     DOUBLE PRECISION RSS, VAR
!
!
      PHI(1) = ACOV(2) / ACOV(1)
      RSS = ACOV(1) * N * (1.0D0 - PHI(1)*PHI(1))
!
      IF (IAR .LE. 1) GO TO 20
!
      DO 10 L = 2, IAR
         CALL ARCOEF(ACOV(2), PHI, RSS, L, LAGMAX, ACOV(1))
   10 CONTINUE
!
   20 VAR = RSS / (N-IAR-1)
!
      RETURN
!
      END
!AMEMN
      SUBROUTINE AMEMN(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, NRESTS,
     +   APRXDV, IFIXD, PAR, PARE, NPAR, RES, PAGE, WIDE,
     +   HLFRPT, STP, LSTP, MIT, STOPSS, STOPP, SCALE, LSCALE, DELTA,
     +   IVAPRX, IPTOUT, NDIGIT, RSD, RESTS, SDPVI, SDRESI, VCVL, LVCVL,
     +   D, IWORK, IIWORK, RWORK, IRWORK, NLHDR, NPARE, PVT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLING SUBROUTINE FOR PERFORMING NONLINEAR
!     LEAST SQUARES REGRESSION USING THE NL2 SOFTWARE PACKAGE
!     (IMPLEMENTING THE METHOD OF DENNIS, GAY AND WELSCH).
!     THIS SUBROUTINE WAS ADAPTED FROM SUBROUTINE NL2SOL.
!
!     REFERENCES
!
!     DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1979), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, (BEING REVISED).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IIWORK,IRWORK,IVAPRX,IXM,LSCALE,LSTP,LVCVL,LWT,M,MIT,N,
     +   NDIGIT,NNZW,NPAR,NPARE,NRESTS,SDPVI,SDRESI,VCVL
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,WEIGHT,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(NRESTS,*),PAR(*),PARE(*),PVT(*),RES(*),RESTS(*),RWORK(*),
     +   SCALE(*),STP(*),WT(*),XM(IXM,*),Y(*)
      INTEGER
     +   IFIXD(*),IPTOUT(*),IWORK(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL NLHDR
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   CNVCOD,COVMAT,I,ICNVCD,IVCVPT,QTR,RD,RDI,RSAVE,RSSHLF,S,
     +   SCL
      LOGICAL
     +   CMPDRV,DONE,HEAD,NEWITR,PRTSMY
!
!  LOCAL ARRAYS
      INTEGER
     +   ISKULL(10)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMDRV,AMEFIN,AMEISM,DRV,MDLTS3,NL2ITR,NLERR,NLINIT,
     +   NLITRP,NLSUPK,REPCK,DCOPY
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL CMPDRV
!        THE VARIABLE USED TO INDICATE WHETHER DERIVATIVES MUST BE
!        COMPUTED (TRUE) OR NOT (FALSE).
!     INTEGER CNVCOD
!        A VALUE USED TO CONTROL THE PRINTING OF ITERATION REPORTS.
!     INTEGER COVMAT
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
!        OF THE BEGINNING OF THE VCV MATRIX.
!     DOUBLE PRECISION D(NRESTS,NPAR)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     LOGICAL DONE
!        THE VARIABLE USED TO INDICATE WHETHER THIS IS THE FINAL
!        COMPUTATION OF THE JACOBIAN OR NOT.
!     LOGICAL HEAD
!        THE VARIABLE USED TO INDICATE WHETHER A HEADING IS TO BE
!        PRINTED DURING A GIVEN CALL TO THE ITERATION REPORT (TRUE)
!        OR NOT (FALSE).
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER ICNVCD
!        THE LOCATION IN IWORK OF
!        THE CONVERGENCE CONDITION.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IIWORK
!        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
!     INTEGER IPTOUT(NDIGIT)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER IRWORK
!        THE DIMENSION OF THE DOUBLE PRECISION WORK VECTOR RWORK.
!     INTEGER ISKULL(10)
!        AN ERROR MESSAGE INDICATOR VARIABLE.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCVPT
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
!        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
!        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)
!        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                       *INVERSE(HESSIAN)
!     INTEGER IWORK(IIWORK)
!        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LVCVL
!        THE LENGTH OF THE VECTOR CONTAINING
!        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDLTS3
!        THE STARPAC FORMAT SUBROUTINE FOR COMPUTING THE ARIMA MODEL
!        RESIDUALS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     LOGICAL NEWITR
!        A FLAG USED TO INDICATE WHETHER A NEW ITERATION HAS BEEN
!        COMPLETED (TRUE) OR NOT (FALSE).
!     EXTERNAL NLHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PARE(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS, BUT ONLY
!        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
!     LOGICAL PRTSMY
!        THE VARIABLE USED TO INDICATE WHETHER THE SUMMARY
!        INFORMATION IS TO BE PRINTED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PVT(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER QTR
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
!        THE ARRAY Q TRANSPOSE R.
!     INTEGER RD
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK OF
!        THE DIAGONAL ELEMENTS OF THE R MATRIX OF THE Q - R
!        FACTORIZATION OF D.
!     INTEGER RDI
!        THE LOCATION IN RWORK OF THE DIAGONAL ELEMENTS OF THE R
!        MATRIX OF THE Q - R FACTORIZATION OF D.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RESTS(NRESTS)
!        THE RESIDUALS FROM THE ARIMA MODEL.
!     INTEGER RSAVE
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
!        THE ARRAY RSAVE.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     INTEGER RSSHLF
!        THE LOCATION IN RWORK OF
!        HALF THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION RWORK(IRWORK)
!        THE DOUBLE PRECISION WORK VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER S
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
!        THE ARRAY OF SECOND ORDER TERMS OF THE HESSIAN.
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     INTEGER SCL
!        THE INDEX IN RWORK OF THE 1ST VALUE OF THE USER SUPPLIED SCALE
!        VALUE.
!     INTEGER SDPVI
!        THE STARTING LOCATION IN RWORK OF
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     INTEGER SDRESI
!        THE STARTING LOCATION IN RWORK OF THE
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!        PREDICTED DECREASE IN THE RESIDUAL STANDARD DEVIATION (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FORTHE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(LSTP)
!        THE DUMMY STEP SIZE ARRAY.
!     INTEGER VCVL
!        THE STARTING LOCATION IN RWORK OF THE LOWER HALF OF THE
!        VCV MATRIX, STORED ROW WISE.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     IWORK SUBSCRIPT VALUES
!
      DATA CNVCOD /34/, ICNVCD /1/, COVMAT /26/, QTR /49/, RD /51/,
     +   RSAVE /52/, S/53/
      DATA RSSHLF /10/
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
!     INITIALIZE CONTROL PARAMETERS
!
      CALL NLINIT (NRESTS, IFIXD, PAR, NPAR, PARE, NPARE, MIT, STOPSS,
     +   STOPP, SCALE, LSCALE, DELTA, IVAPRX, APRXDV, IVCVPT, IWORK,
     +   IIWORK, RWORK, IRWORK, SCL)
!
      CMPDRV = .TRUE.
      DONE = .FALSE.
      HEAD = .TRUE.
      NEWITR = .FALSE.
      PRTSMY = (IPTOUT(1).NE.0)
!
!     COMPUTE RESIDUALS
!
   10 CALL MDLTS3(PAR, NPAR, XM, N, M, IXM, RESTS)
!
!     PRINT INITIAL SUMMARY
!
      IF (.NOT.PRTSMY) GO TO 30
      CALL AMEISM(NLHDR, PAGE, WIDE, HLFRPT, NPAR, M, N, NNZW, WEIGHT,
     +   IFIXD, PAR, SCALE, LSCALE, IWORK, IIWORK, RWORK, IRWORK, RESTS,
     +   APRXDV, STP, LSTP, NPARE)
      PRTSMY = .FALSE.
!
   30 CONTINUE
!
      IF (.NOT.CMPDRV) GO TO 50
!
      CMPDRV = .FALSE.
!
   40 CONTINUE
!
!     PRINT ITERATION REPORT IF DESIRED
!
      IF ((IPTOUT(2).NE.0) .AND. NEWITR) CALL NLITRP(NLHDR, HEAD, PAGE,
     +   WIDE, IPTOUT(2), NPAR, NNZW, IWORK, IIWORK, RWORK, IRWORK,
     +   IFIXD, PARE, NPARE)
!
!  ***  COMPUTE JACOBIAN  ***
!
      IF (DONE) CALL MDLTS3(PAR, NPAR, XM, N, M, IXM, RESTS)
!
      CALL AMDRV(MDLTS3, DRV, DONE, IFIXD, PAR, NPAR, XM, N, M, IXM,
     +  NRESTS, RESTS, D, WEIGHT, WT, LWT, STP, LSTP, RWORK(SCL), NPARE)
!
      IF (DONE) GO TO 70
!
!     COMPUTE NEXT ITERATION
!
   50 CALL NL2ITR(RWORK(SCL), IWORK, D, NRESTS, NRESTS, NPARE, RESTS,
     +   RWORK, PARE)
!
!     UNPACK PARAMETERS
!
      CALL NLSUPK(PARE, NPARE, PAR, IFIXD, NPAR)
!
      NEWITR = (IWORK(CNVCOD).EQ.0)
      IF (IWORK(1)-2) 10, 40, 60
!
   60 DONE = .TRUE.
      GO TO 40
   70 CONTINUE
!
!     SET ERROR FLAGS, IF NECESSARY
!
      CALL NLERR(IWORK(ICNVCD), ISKULL)
!
!     FINISH COMPUTATIONS AND PRINT ANY DESIRED RESULTS
!
      CALL DCOPY(N, RESTS(NRESTS-N+1), 1, RES(1), 1)
      DO 75 I = 1, N
         PVT(I) = Y(I) - RES(I)
   75 CONTINUE
      SDPVI = IWORK(RSAVE)
      SDRESI = IWORK(QTR)
      VCVL = IWORK(COVMAT)
      IF (VCVL.GE.1) GO TO 80
!
      VCVL = IWORK(S)
      IF (IERR.NE.0) GO TO 80
      ISKULL(1) = 1
      ISKULL(7) = 1
      IERR = 7
!
   80 CONTINUE
!
      LVCVL = NPARE*(NPARE+1)/2
!
      RDI = IWORK(RD)
!
!     REPCK IS CALLED TO AVOID MODIFICATION OF NLS CODE.  FUTURE
!     REVISIONS OF NLS CODE SHOULD INCLUDE MODIFICATIONS NECESSARY
!     TO ELIMINATE NEED TO REPACK D FOR ARIMA CODE.
!
      CALL REPCK(D, NRESTS, NPAR, N)
      CALL AMEFIN(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, IFIXD, PAR,
     +   NPAR, NPARE, RES, PAGE, WIDE, IPTOUT, NDIGIT, RWORK(RSSHLF),
     +   RSD, PVT, RWORK(SDPVI), RWORK(SDRESI), RWORK(RDI),
     +   RWORK(VCVL), LVCVL, D, NLHDR, IVCVPT, ISKULL, NRESTS)
!
      RETURN
!
      END
!DRV2
      SUBROUTINE DRV2(PAR, NPAR, XM, N, M, IXM, D)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DERIVATIVE FUNCTION FOR NLS FAMILY EXERCISER SUBROUTINE MDL2.
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PAR(NPAR),XM(IXM,M)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION PAR(NPAR)
!        MODEL PARAMETERS
!     DOUBLE PRECISION D(N,NPAR)
!        THE FIRST DERIVATIVE WITH RESPECT TO THE ITH PARAMETER
!     INTEGER I
!        ROW MARKER
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLESC
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS
!     DOUBLE PRECISION XM(IXM,M)
!        MODEL INDEPENDENT VARIABLE
!
!
      DO 10 I=1,N
         D(I,1) = XM(I,1)
         D(I,2) = XM(I,2)
         D(I,3) = XM(I,3)**3
   10 CONTINUE
!
      RETURN
!
      END
!LLSPWS
      SUBROUTINE LLSPWS(Y, WT, XM, N, NDEG, RES, LDSTAK,
     +   NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CALL FOR POLYNOMIAL MODEL LEAST SQUARES FIT
!     USER SUPPLIED WEIGHTS SPECIFIED
!     FULL STORAGE
!     USER CONTROL OF AUTOMATIC PRINTOUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,LDSTAK,LPAR,N,NDEG,NPAR,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SDPV(*),SDRES(*),VCV(*),WT(*),XM(*),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,LPV,LSDPV,LSDRES,LWT
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLCNTP
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDEG
!        THE DEGREE OF THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     DOUBLE PRECISION PAR(LPAR)
!        THE PARAMETERS  TO BE ESTIMATED.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUES.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION SDPV(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(N)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(N)
!        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
!     DOUBLE PRECISION XM(N,1)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'L','L','S','P','W','S'/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      WEIGHT = .TRUE.
      SAVE = .TRUE.
      LPV = N
      LSDPV = N
      LSDRES = N
      LWT = N
!
      CALL LLCNTP(Y, WT, LWT, XM, N, NDEG, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (//42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL LLSPWS (Y, WT, X, N, NDEG, RES, LSDTAK,'/
     +   '      +             NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV,'/
     +   '      +             SDRES, VCV, IVCV)')
      END
!LLS
      SUBROUTINE LLS(Y, XM, N, IXM, NPAR, RES, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CALL FOR GENERAL LINEAR MODEL LEAST SQUARES FIT
!     NO WEIGHTS SPECIFIED
!     NO STORAGE OTHER THAN RESIDUALS
!     FOUR PAGES AUTOMATIC PRINTOUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RES(*),XM(*),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LPAR,LPV,LSDPV,LSDRES,LWT,NPRT
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(1),PV(1),SDPV(1),SDRES(1),VCV(1,1),WT(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLCNTG
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     DOUBLE PRECISION PAR(1)
!        A DUMMY ARRAY FOR
!        THE PARAMETERS  TO BE ESTIMATED.
!     DOUBLE PRECISION PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUES.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(1)
!        A DUMMY ARRAY FOR
!        THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,NPAR)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'L','L','S',' ',' ',' '/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      WEIGHT = .FALSE.
      SAVE = .FALSE.
      NPRT = 1111
      LPAR = 1
      LPV = 1
      LSDPV = 1
      LSDRES = 1
      IVCV = 1
      LWT = 1
!
      CALL LLCNTG(Y, WT, LWT, XM, N, IXM, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (//42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   50H       CALL LLS (Y, XM, N, IXM, NPAR, RES, LSDTAK))
      END
!LLSWS
      SUBROUTINE LLSWS(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CALL FOR GENERAL LINEAR MODEL LEAST SQUARES FIT
!     USER SUPPLIED WEIGHTS SPECIFIED
!     FULL STORAGE
!     USER CONTROL OF AUTOMATIC PRINTOUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,IXM,LDSTAK,N,NPAR,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SDPV(*),SDRES(*),VCV(*),WT(*),XM(*),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,LPAR,LPV,LSDPV,LSDRES,LWT
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLCNTG
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     DOUBLE PRECISION PAR(NPAR)
!        THE PARAMETERS  TO BE ESTIMATED.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUES.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION SDPV(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(N)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(N)
!        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
!     DOUBLE PRECISION XM(IXM,NPAR)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'L','L','S','W','S',' '/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      WEIGHT = .TRUE.
      SAVE = .TRUE.
      LPAR = NPAR
      LPV = N
      LSDPV = N
      LSDRES = N
      LWT = N
!
      CALL LLCNTG(Y, WT, LWT, XM, N, IXM, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (//42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL LLSWS (Y, WT, XM, N, IXM, NPAR, RES, LSDTAK,'/
     + '      +            NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)')
      END
!IPGMP
      SUBROUTINE IPGMP (PER, FREQ, NF, N, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
!     THE INTEGRATED PERIODOGRAM OF A SERIES (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N,NF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),PER(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,ISYM,LDSMIN,LPCV,NALL0,NPRT,PERI,XAXIS,YAXIS
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   LLDS(8)*1,LN(8)*1,LNF(8)*1,NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,IPGDV,IPRINT,LDSCMP,STKCLR,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION FREQ(NF)
!        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
!        INTEGRATED SPECTRUM VALUES ARE STORED.
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER ISYM
!        ...
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     CHARACTER*1 LLDS(8), LN(8), LNF(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER LPCV
!        ...
!     INTEGER N
!        THE ACTUAL NUMBER OF OBSERVATIONS IN THE SERIES FROM WHICH
!        THE PERIODOGRAM WAS COMPUTED.
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING ALLOCATIONS OF THE STACK AT THE
!        TIME OF THIS CALL.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        TO BE COMPUTED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A PAGE PLOT.
!     DOUBLE PRECISION PER(NF)
!        THE RAW PERIODOGRAM.
!     INTEGER PERI
!        THE STARTING LOCATION IN THE STACK FOR
!        THE VECTOR CONTAINING THE INTEGRATED PERIODOGRAM.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE X AXIS VALUES TO BE PLOTTED ARE STORED.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'I',       'P',       'G',       'M',       'P',       ' '/
      DATA
     + LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     +  LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /'N',' ',' ',' ',' ',' ',' ',' '/
      DATA
     + LNF(1), LNF(2), LNF(3), LNF(4), LNF(5), LNF(6), LNF(7), LNF(8)
     + /'N','F',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
!
      CALL EISGE(NMSUB, LNF, NF, (N+2)/2, 1, HEAD, ERR02, LNF)
!
      IF (ERR01) GO TO 5
!
      CALL LDSCMP(4, 0, NF+103, 0, 0, 0, 'D', 3*NF+206, LDSMIN)
!
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR03, LLDS)
!
      IF (ERR02 .OR. ERR03) GO TO 5
      GO TO 10
!
    5 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   10 CONTINUE
!
!     SET THE SIZE OF THE WORK AREA
!
      CALL STKSET(LDSTAK, 4)
!
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!
      NALL0 = STKST(1)
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      LPCV = NF + 103
      NPRT = 1
!
!     SUBDIVIDE THE STACK.
!
      ISYM = STKGET(LPCV, 2)
      PERI = STKGET(NF, 4)
      XAXIS = STKGET(LPCV, 4)
      YAXIS = STKGET(LPCV, 4)
!
!     CALL THE MAIN DRIVER FOR COMPUTING (AND PLOTTING) THE INTEGRATED
!     PERIODOGRAM.
!
      CALL IPGDV (PER, NF, N, RSTAK(PERI), FREQ, RSTAK(XAXIS),
     +   RSTAK(YAXIS), ISTAK(ISYM), LPCV, NPRT)
!
      CALL STKCLR(NALL0)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL IPGMP (PER, FREQ, NF, N, LDSTAK)')
      END
!XSTPLD
      SUBROUTINE XSTPLD(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,EXMPT
      INTEGER
     +   I,IPRT,IXM,LDSMIN,M,N,NETA,NPAR,NPRT,NTEST
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(10),SCALE(10),STP(10),XM(200,2)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LDSCMP,LSTVEC,MDL4,STPLS,STPLS1,STPLS2,STPLSC
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        *
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL4
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     DOUBLE PRECISION PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION SCALE(10)
!        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION STP(10)
!        THE SELECTED STEP SIZES FOR EACH PARAMETER.
!     DOUBLE PRECISION XM(200,2)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      CALL IPRINT(IPRT)
!
!     SET PARAMETER VALUES
!
      CALL STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
      CALL STPLS2(NPAR, STP)
      CALL LDSCMP(14, 0, 2*(N+NPAR), 0, 0, 0, 'D', 10*N, LDSMIN)
!
      IF (LDSMIN.LE.LDSTAK) GO TO 5
!
      WRITE (IPRT, 1020) LDSMIN
      RETURN
!
    5 CONTINUE
!
!     CREATE INDEPENDENT VARIABLE
!
      DELTA = 0.0625D0
      XM(1,1) = 0.0D0
      DO 10 I=2,N
         XM(I,1) = XM(I-1,1) + DELTA
   10 CONTINUE
!
      NTEST = 0
!
!     CHECK RESULTS FROM VALID CALLS
!
!     SIMPLE EXAMPLE
!
      CALL STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1090) NTEST
      WRITE (IPRT,1040)
      WRITE (IPRT,1000)
      CALL STPLS2(NPAR, STP)
      CALL STPLS(XM, N, M, IXM, MDL4, PAR, NPAR, LDSMIN, STP)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1080)
      CALL LSTVEC(4, STP)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1090) NTEST
      WRITE (IPRT,1040)
      WRITE (IPRT,1060) NETA, EXMPT, SCALE(1), NPRT
      WRITE (IPRT,1010)
      CALL STPLS2(NPAR, STP)
      CALL STPLSC(XM, N, M, IXM, MDL4, PAR, NPAR, LDSMIN, STP, NETA,
     +   EXMPT, SCALE, NPRT)
      WRITE (IPRT,1100) NETA, EXMPT, SCALE(1), NPRT
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1080)
      CALL LSTVEC(4, STP)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (15H TEST OF STPLS )
 1010 FORMAT (15H TEST OF STPLSC)
 1020 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1040 FORMAT (15H SIMPLE EXAMPLE)
 1050 FORMAT (/29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1060 FORMAT (19H INPUT   -  NETA = , I5, 10H, EXMPT = , G15.8,
     +   13H, SCALE(1) = , G15.8, 9H, NPRT = , I5)
 1080 FORMAT (//23H RETURNED VALUES OF STP)
 1090 FORMAT (54H1DERIVATIVE STEP SIZE SELECTION SUBROUTINE TEST NUMBER,
     +   I5)
 1100 FORMAT (//19H OUTPUT  -  NETA = , I5, 10H, EXMPT = , G15.8,
     +   13H, SCALE(1) = , G15.8, 9H, NPRT = , I5//)
      END
!EXTEND
      DOUBLE PRECISION FUNCTION EXTEND(X, I, N, SYM)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!      THIS FUNCTION RETURNS THE ITH TERM IN THE SERIES X,
!     EXTENDING IF NECESSARY WITH EVEN OR ODD SYMMETRY ACCORDING
!     TO THE SIGN OF SYM, WHICH SHOULD BE EITHER PLUS OR MINUS ONE.
!     (THE VALUE ZERO WILL RESULT IN THE EXTENDED VALUE BEING ZERO.)
!     THIS ROUTINE IS TAKEN FROM BLOOMFIELDS BOOK, PAGE 179.
!
!     WRITTEN BY  -  PETER BLOOMFIELD
!     CODED BY  -  JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SYM
      INTEGER
     +   I,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CON
      INTEGER
     +   J
!
      J = I
      CON = 1.0D0
   10 IF (J .GE. 1) GO TO 20
      J = 2-J
      CON = CON * SYM
   20 IF (J .LE. N) GO TO 30
      J = 2*N-J
      CON = CON * SYM
      GO TO 10
   30 EXTEND = X(J)*CON
!
      RETURN
!
      END
!UASS
      SUBROUTINE UASS (Y, N, IAR, PHI, LAGMAX, LAG, NF, FMIN, FMAX,
     +   NPRT, SPCA, SPCF, FREQ, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
!     SPECTRUM ESTIMATION (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   IAR,LAG,LAGMAX,LDSTAK,N,NF,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),PHI(*),SPCA(*),SPCF(*),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMN,FMX,VAR,YMEAN
      INTEGER
     +   ACOV,AIC,FTEST,IA,IFP,IO,IPRT,ISORT,ISYM,LACOV,LAIC,
     +   LDSMIN,LPCV,LPHI,LSPC,LWORK,NALL0,WORK,XAXIS,YAXIS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACVF,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UASDV,UASER,
     +   UASVAR
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER ACOV
!        THE STARTING LOCATION IN RSTAK FOR THE ARRAY OF
!        THE AUTOCOVARIANCE ARRAY.
!     INTEGER AIC
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY CONTAINING THE AIC.
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
!        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
!     DOUBLE PRECISION FMN, FMX
!        THE MAXIMUM AND MINIMUM FREQUENCY ACTUALLY USED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     INTEGER FTEST
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IA
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON WHETHER OR NOT THE MODEL ORDER IS TO BE SELECTED OR
!        HAS BEEN PROVIDED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION IN ISTAK FOR
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN ISTAK FOR
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE COVARIANCE ARRAYS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE ARRAY AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER LSPC
!         THE LENGTH OF THE SPECTRUM ARRAYS.
!     INTEGER LWORK
!        THE LENGTH OF THE WORK ARRAY.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS OUTSTANDING WHEN THIS ROUTINE
!        WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
!        ARE TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE TYPE OF WINDOW TO BE USED.
!     DOUBLE PRECISION PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION SPCA(NF)
!        THE ARRAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!     DOUBLE PRECISION SPCF(NF)
!        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
!     DOUBLE PRECISION VAR
!        THE ONE STEP PREDICTION VARIANCE.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE STACK FOR
!        THE WORK ARRAY.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN RSTAK FOR
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN RSTAK FOR
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'U',       'A',       'S',       'S',       ' ',       ' '/
!
      IFP = 4
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(4) = .TRUE.
!
      IO = 1
      IF (NPRT .EQ. 0) IO = 0
      IA = 1
      IF (IAR .NE. 0) IA = 0
!
      CALL LDSCMP(7, 0, IO*(2*NF+5), 0, 0, 0, 'D',
     +   2*LAGMAX+2+IA*(3*LAGMAX+1)+IO*(4*NF+10), LDSMIN)
!
!     CALL ERROR CHECKING ROUTINE
!
      CALL UASER(NMSUB, N, Y, IAR, PHI, LAGMAX, LAG, LACOV,
     +   NF, LDSTAK, LDSMIN, N, N, OPTION)
!
   10 IF (IERR.NE.0) THEN
         IERR = 1
         CALL IPRINT (IPRT)
         WRITE (IPRT, 1000)
         RETURN
      END IF
!
!     SET SIZE OF WORK AREA.
!
      CALL STKSET (LDSTAK, 4)
!
!     SAVE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
!
      NALL0 = STKST(1)
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      LSPC = NF
      LPCV = 2*NF + 5
      LPHI = LAGMAX
      LACOV = LAGMAX + 1
      LWORK = LAGMAX+1
!
      FMN = MAX(FMIN, 0.0D0)
      FMX = MIN(FMAX, 0.5D0)
      IF (FMN.GE.FMX) THEN
        FMN = 0.0D0
        FMX = 0.5D0
      END IF
!
      ALPHA = 0.95D0
      DELTA = 1.0D0
!
!     COMPUTE AUTOCOVARIANCES
!
      ACOV = STKGET(LACOV, IFP)
!
      CALL ACVF (Y, N, YMEAN, RSTAK(ACOV), LAGMAX, LACOV)
!
      IF (IAR.GE.1) THEN
!
!     USER HAS CHOSEN ORDER AND SUPPLIED COEFFICIENTS.
!     COMPUTE RESIDUAL VARIANCE.
!
         CALL UASVAR (Y, YMEAN, N, IAR, PHI, VAR)
      END IF
!
!     SET UP ADDITIONAL STACK WORK AREA, IF NEEDED.
!
      WORK = STKGET(LWORK, IFP)
!
      IF (IAR.EQ.0) THEN
         LAIC = LAGMAX+1
         AIC = STKGET(LAIC, IFP)
         FTEST = STKGET(2*LAGMAX, IFP)
      ELSE
         LAIC = LWORK
         AIC = WORK
         FTEST = WORK
      END IF
      IF (NPRT.EQ.0) THEN
         XAXIS = WORK
         YAXIS = WORK
         ISYM = WORK
         ISORT = WORK
      ELSE
         XAXIS = STKGET(LPCV, IFP)
         YAXIS = STKGET(LPCV, IFP)
         ISYM = STKGET(LPCV, 2)
         ISORT = ISYM
      END IF
!
      IF (IERR.EQ.1) GO TO 10
!
!     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
!
      CALL UASDV(RSTAK(ACOV), SPCA, SPCF, LSPC, IAR, PHI, NF, FMN,
     +   FMX, FREQ, N, LAGMAX, RSTAK(FTEST), RSTAK(AIC), RSTAK(WORK),
     +   LACOV, LWORK, DELTA, ISTAK(ISORT), ISTAK(ISYM), RSTAK(XAXIS),
     +   RSTAK(YAXIS), LPCV, ALPHA, LAG, LAIC, LPHI, NPRT, VAR, PARZEN,
     +   NMSUB)
!
      CALL STKCLR(NALL0)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL UASS (Y, N,'/
     + '      +           IAR, PHI, LAGMAX, LAG, NF, FMIN, FMAX, NPRT,'/
     + '      +           SPCA, SPCF, FREQ, LDSTAK)')
      END
!UASVAR
      SUBROUTINE UASVAR (Y, YMEAN, N, IAR, PHI, VAR)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE VARIANCE FOR A GIVEN SERIES
!     AND AUTOREGRESSIVE MODEL.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VAR,YMEAN
      INTEGER
     +   IAR,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PHI(IAR),Y(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RES,RSS
      INTEGER
     +   I,IAR1,J,K
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IAR1
!        THE VALUE IAR + 1.
!     INTEGER J, K
!        INDEX VALUES.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     DOUBLE PRECISION PHI(IAR)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     DOUBLE PRECISION RES
!        *
!     DOUBLE PRECISION RSS
!        THE ONE STEP PREDICTION RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION VAR
!        THE ONE STEP PREDICTION VARIANCE.
!     DOUBLE PRECISION Y(N)
!         THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
      RSS = 0.0D0
      IAR1 = IAR+1
      DO 20 I = IAR1, N
         RES = Y(I) - YMEAN
         DO 10 J = 1, IAR
            K = I-J
            RES = RES - PHI(J) * (Y(K)-YMEAN)
   10    CONTINUE
         RSS = RSS + RES*RES
   20 CONTINUE
!
      VAR = RSS / (N-IAR1)
!
      RETURN
!
      END
!SPPML
      SUBROUTINE SPPML(YM, YMMISS, X, XMISS, N, ISYM, ILOG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH USER CONTROL OF PLOT SYMBOLS AND WITH MISSING
!     OBSERVATIONS (LOG OPTION).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   ILOG,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(1)
      INTEGER
     +   ISYM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   IPRT,ISCHCK,ISIZE,IYM,LISYM,M,NOUT
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'P',       'P',       'M',       'L',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      M = 1
      IYM = N
      MULTI = .FALSE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 1
      ISIZE = -1
      NOUT = 0
      MISS = .TRUE.
      LISYM = N
!
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL SPPML (Y, YMISS, X, XMISS, N, ISYM, ILOG)')
      END
!CCFS
      SUBROUTINE CCFS (YM, N, M, IYM, LAGMAX, CCOV, ICCOV, JCCOV,
     +   NPRT, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
!     CORRELATIONS AND COVARIANCES OF A MULTIVARIATE SERIES (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,IYM,JCCOV,LAGMAX,LDSTAK,M,N,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(*),YM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IFP,INLPPC,IO,IPRT,IYMFFT,J,JNLPPC,K,LDSMIN,LYFFT,NALL0,
     +   NFFT,RHOC,SDRHOC,YMEAN,YMEANJ,YMEANK,YSD,YSDJ,YSDK
      LOGICAL
     +   ISFFT,ISLONG,NEWPG
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACVF,CCFER,CCFMN,CCFOUT,IPRINT,LDSCMP,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  STATEMENT FUNCTIONS
      INTEGER
     +   I2,I3
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCOV(ICCOV, JCCOV, M)
!        THE CROSS COVARIANCE MATRIX.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ICCOV
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INLPPC
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
!        IN THE USERS PROGRAM.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON WHETHER PRINTED OUTPUT IS DESIRED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     LOGICAL ISLONG
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
!     INTEGER IYM
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YM AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IYMFFT
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER I2
!        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN YM
!     INTEGER I3
!        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN CCOV
!     INTEGER J
!        THE INDEX OF -SERIES 1- IN THE ARRAY YM.
!     INTEGER JCCOV
!        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
!        IN THE USERS PROGRAM.
!     INTEGER K
!        THE INDEX OF -SERIES 2- IN THE ARRAY YM.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER M
!        THE NUMBER OF SERIES BEING COMPARED, IE THE
!        NUMBER OF COLUMNS OF DATA IN YM.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     INTEGER NDUM(1)
!        A DUMMY DIMENSIONED VARIABLE.
!     LOGICAL NEWPG
!        AN INDICATOR VARIABLE USED TO DETERMINE WHEN A NEW PAGE
!        IS APPROPRIATE FOR THE OUTPUT.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPEDIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS GIVEN.
!     INTEGER RHOC
!        THE STARTING LOCATION IN DSTAK OF THE ARRAY RHOC.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SDRHOC
!        THE STARTING LOCATION IN THE WORK AREA FOR SDRHOC.
!     DOUBLE PRECISION YM(IYM, M)
!        THE MATRIX CONTAINING THE OBSERVED TIME SERIES
!     INTEGER YMEAN, YMEANJ, YMEANK
!        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
!        MEANS OF EACH OF THE SERIES, AND THE LOCATION IN
!        THE ARRAY FOR THE MEAN OF THE JTH AND KTH SERIES,
!        RESPECTIVELY.
!     INTEGER YSD, YSDJ, YSDK
!        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
!        STANDARD DEVIATIONS OF EACH OF THE SERIES, AND THE
!        LOCATION IN THE ARRAY FOR THE STANDARD DEVIATION OF
!        THE JTH AND KTH SERIES, RESPECTIVELY.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'C',       'C',       'F',       'S',       ' ',       ' '/
!
      I2(I,J) = I + (J-1)*IYM
      I3(I,J,K) = I + (J-1)*ICCOV + (K-1)*JCCOV*ICCOV
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      INLPPC = ICCOV
      JNLPPC = JCCOV
      LYFFT = N + LAGMAX
      IYMFFT = IYM
      NFFT = N
      ISFFT = .FALSE.
      ISLONG = .TRUE.
!
      IO = 1
      IF (NPRT .EQ. 0) IO = 0
!
      CALL LDSCMP(2+2*IO, 0, 0, 0, 0, 0, 'D',
     +            2*M+IO*(4*LAGMAX+2), LDSMIN)
!
      CALL CCFER(NMSUB, N, LAGMAX, LDSTAK, LDSMIN, ICCOV, JCCOV,
     +  INLPPC, JNLPPC, M, LYFFT, NFFT, IYM, IYMFFT, ISFFT, ISLONG)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      IF (IERR.EQ.0) THEN
!
!       SET UP THE WORK AREA.
!
        CALL STKSET (LDSTAK, 4)
        NALL0 = STKST(1)
!
        IFP = 4
!
        YMEAN = STKGET(M, IFP)
        YSD = STKGET(M, IFP)
        IF (NPRT.EQ.0) THEN
          RHOC = YSD
          SDRHOC = YSD
        ELSE
          RHOC = STKGET(2*LAGMAX+1, IFP)
          SDRHOC = STKGET(2*LAGMAX+1, IFP)
        END IF
!
        IF (IERR.EQ.0) THEN
!
!         BEGIN LOOP FOR COMPUTATIONS
!
          NEWPG = .FALSE.
!
          DO 40 K = 1, M
!
             YMEANK = YMEAN + K - 1
             YSDK = YSD + K - 1
!
             CALL ACVF (YM(I2(1,K)), N, RSTAK(YMEANK),
     +                  CCOV(I3(1,K,K)), LAGMAX, ICCOV)
             RSTAK(YSDK) = SQRT(CCOV(I3(1,K,K)) * N / (N - 1))
!
             IF ((K-1).LE.0) GO TO 40
!
             DO 30 J = 1, (K-1)
!
                YMEANJ = YMEAN + J - 1
                YSDJ = YSD + J - 1
!
                CALL CCFMN (YM(I2(1,J)), YM(I2(1,K)),
     +                      N, LAGMAX, 2*LAGMAX+1,
     +                      CCOV(I3(1,J,J)), CCOV(I3(1,K,K)),
     +                      CCOV(I3(1,J,K)), CCOV(I3(1,K,J)),
     +                      ICCOV, RSTAK(YMEANJ), RSTAK(YMEANK),
     +                      RSTAK(RHOC), RSTAK(SDRHOC), NPRT)
!
                IF (NPRT .EQ. 0) GO TO 30
!
!         CALL ROUTINE TO PRINT OUT CORRELATIONS
!
                CALL CCFOUT (J, RSTAK(YMEANJ), RSTAK(YSDJ), N, N, K,
     +             RSTAK(YMEANK), RSTAK(YSDK), N, N, LAGMAX, 2*LAGMAX+1,
     +             RSTAK(RHOC), RSTAK(SDRHOC), .FALSE., NDUM, NDUM, 1,
     +             0.0D0, 0.0D0, NEWPG)
!
                NEWPG = .TRUE.
!
   30        CONTINUE
   40     CONTINUE
        END IF
!
        CALL STKCLR(NALL0)
      END IF
!
      IF (IERR.NE.0) THEN
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL CCFS (YM, N, M, IYM,'/
     +   '      +           LAGMAX, CCOV, ICCOV, JCCOV, NPRT, LDSTAK)')
      END
!AIME
      SUBROUTINE AIME (Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR ARIMA ESTIMATION
!     (CONTROL CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N,NFAC,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),Y(*)
      INTEGER
     +   MSPEC(4,*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IPRT,IVAPRX,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,MIT,
     +   NPARE,NPRT
      LOGICAL
     +   SAVE
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SCALE(1),SDPV(1),SDRES(1),STP(1),VCV(1,1)
      INTEGER
     +   IFIXED(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMEDRV,IPRINT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!        IF IFIXED(1).LT.0, THEN IFIXED(I)=DEFAULT,I=1,...,NPAR, AND THE
!                           DIMENSION OF IFIXED WILL BE ASSUMED TO BE 1.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE FOR
!        IVAPRX LE 0, VCV = THE DEFAULT OPTION
!        IVAPRX EQ 1, VCV = INVERSE(TRANSPOSE(J)*J)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2, VCV = INVERSE(H)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4, VCV = INVERSE(TRANSPOSE(J)*J)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5, VCV = INVERSE(H)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7, VCV = THE DEFAULT OPTION
!        WITH J REPRESENTING THE JACOBIAN AND H THE HESSIAN.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE DIMENSION OF VECTOR IFIXED.
!     INTEGER LPV
!        THE DIMENSION OF VECTOR PV.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER LSDPV
!        THE DIMENSION OF VECTOR SDPV.
!     INTEGER LSDRES
!        THE DIMENSION OF VECTOR SDRES.
!     INTEGER LSTP
!        THE DIMENSION OF VECTOR STP.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER MSPEC(4,NFAC)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PV(1)
!        THE PREDICTED VALUE OF THE FIT, UNUSED WHEN SAVE = FALSE.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(1)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!        IF SCALE(1).LE.0, THEN SCALE(I)=DEFAULT,I=1,...,NPAR, AND THE
!                          DIMENSION OF SCALE WILL BE ASSUMED TO BE 1.
!     DOUBLE PRECISION SDPV(1)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES, UNUSED
!        WHEN SAVE = FALSE.
!     DOUBLE PRECISION SDRES(1)
!        THE STANDARDIZED RESIDUALS, UNUSED WHEN SAVE = FALSE.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(1)
!        THE STEP SIZE ARRAY.
!        IF STP(1).LE.0, THEN STP(I)=DEFAULT,I=1,...,NPAR, AND THE
!                        DIMENSION OF STP WILL BE ASSUMED TO BE 1.
!     DOUBLE PRECISION VCV(1,1)
!        THE VARIANCE-COVARIANCE MATRIX, UNUSED WHEN SAVE = FALSE.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'A','I','M','E',' ',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      SAVE = .FALSE.
!
      LIFIXD = 1
      IFIXED(1) = -1
      LSTP = 1
      STP(1) = 0.0D0
      MIT = -1
      STOPSS = -1.0D0
      STOPP = -1.0D0
      LSCALE = 1
      SCALE(1) = 0.0D0
      DELTA = -1.0D0
      IVAPRX = -1
      NPRT = -1
      LPV = 1
      LSDPV = 1
      LSDRES = 1
      IVCV = 1
!
      CALL AMEDRV(Y, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, SAVE, NPARE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
!
 1000 FORMAT (/' THE CORRECT FORM OF THE CALL STATEMENT IS'//
     +  '       CALL AIME (Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK)')
      END
!UASVS
      SUBROUTINE UASVS (ACOV, LAGMAX, Y, N, IAR, PHI, LAG, NF,
     +   FMIN, FMAX, NPRT, SPCA, SPCF, FREQ, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
!     SPECTRUM ESTIMATION WHEN THE ACVF HAVE PREVIOUSLY BEEN
!     COMPUTED AND STORED (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   IAR,LAG,LAGMAX,LDSTAK,N,NF,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),FREQ(*),PHI(*),SPCA(*),SPCF(*),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMN,FMX,VAR,YMEAN
      INTEGER
     +   AIC,FTEST,IA,IFP,IO,IPRT,ISORT,ISYM,LACOV,LAIC,LDSMIN,
     +   LPCV,LPHI,LSPC,LWORK,NALL0,WORK,XAXIS,YAXIS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UASDV,UASER,
     +   UASVAR
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LAGMAX+1)
!        THE ARRAY OF AUTOCOVARIANCE ESTIMATES.
!     INTEGER AIC
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY CONTAINING THE AIC.
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
!        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
!     DOUBLE PRECISION FMN, FMX
!        THE MAXIMUM AND MINIMUM FREQUENCY ACTUALLY USED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     INTEGER FTEST
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IA
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON WHETHER OR NOT THE MODEL ORDER IS TO BE SELECTED OR
!        HAS BEEN PROVIDED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION IN ISTAK FOR
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN ISTAK FOR
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE COVARIANCE ARRAYS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE ARRAY AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER LSPC
!         THE LENGTH OF THE SPECTRUM ARRAYS.
!     INTEGER LWORK
!        THE ACTUAL LENGTH OF THE WORK ARRAY.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS OUTSTANDING WHEN THIS ROUTINE
!        WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
!        ARE TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE TYPE OF WINDOW TO BE USED.
!     DOUBLE PRECISION PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION SPCA(NF)
!        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!     DOUBLE PRECISION SPCF(NF)
!        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
!     DOUBLE PRECISION VAR
!        THE ONE STEP PREDICTION VARIANCE.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE STACK FOR
!        THE WORK ARRAY.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN RSTAK FOR
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN RSTAK FOR
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'U',       'A',       'S',       'V',       'S',       ' '/
!
      IFP = 4
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .TRUE.
      OPTION(4) = .TRUE.
!
      LACOV = LAGMAX+1
!
      IO = 1
      IF (NPRT .EQ. 0) IO = 0
      IA = 1
      IF (IAR .NE. 0) IA = 0
!
      CALL LDSCMP(6, 0, IO*(2*NF+5), 0, 0, 0, 'D',
     +   LAGMAX + 1 + IA*(3*LAGMAX+1) + IO*(4*NF+10), LDSMIN)
!
!     CALL ERROR CHECKING ROUTINE
!
      CALL UASER(NMSUB, N, ACOV, IAR, PHI, LAGMAX, LAG, LACOV,
     +   NF, LDSTAK, LDSMIN, N, N, OPTION)
!
    5 IF (IERR.NE.0) THEN
         IERR = 1
         CALL IPRINT (IPRT)
         WRITE (IPRT, 1000)
         RETURN
      END IF
!
!     SET SIZE OF WORK AREA.
!
      CALL STKSET (LDSTAK, 4)
!
!     SAVE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
!
      NALL0 = STKST(1)
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      LSPC = NF
      LPCV = 2*NF + 5
      LPHI = LAGMAX
      LWORK = LAGMAX+1
!
      FMN = MAX(FMIN, 0.0D0)
      FMX = MIN(FMAX, 0.5D0)
      IF (FMN.GE.FMX) THEN
        FMN = 0.0D0
        FMX = 0.5D0
      END IF
!
      ALPHA = 0.95D0
      DELTA = 1.0D0
!
      IF (IAR.GE.1) THEN
!
!     USER HAS CHOSEN ORDER AND SUPPLIED COEFFICIENTS.
!     COMPUTE RESIDUAL VARIANCE.
!
         CALL AMEAN (Y, N, YMEAN)
         CALL UASVAR (Y, YMEAN, N, IAR, PHI, VAR)
      END IF
!
!     SET UP ADDITIONAL STACK WORK AREA, IF NEEDED.
!
      WORK = STKGET(LWORK,IFP)
      IF (IAR.EQ.0) THEN
         LAIC = LAGMAX+1
         AIC = STKGET(LAIC, IFP)
         FTEST = STKGET(2*LAGMAX, IFP)
      ELSE
         LAIC = LWORK
         AIC = WORK
         FTEST = WORK
      END IF
      IF (NPRT.EQ.0) THEN
         XAXIS = WORK
         YAXIS = WORK
         ISYM = WORK
         ISORT = WORK
      ELSE
         XAXIS = STKGET(LPCV, IFP)
         YAXIS = STKGET(LPCV, IFP)
         ISYM = STKGET(LPCV, 2)
         ISORT = ISYM
      END IF
!
      IF (IERR.EQ.1) GO TO 5
!
!     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
!
      CALL UASDV(ACOV, SPCA, SPCF, LSPC, IAR, PHI, NF, FMN,
     +   FMX, FREQ, N, LAGMAX, RSTAK(FTEST), RSTAK(AIC), RSTAK(WORK),
     +   LACOV, LWORK, DELTA, ISTAK(ISORT), ISTAK(ISYM), RSTAK(XAXIS),
     +   RSTAK(YAXIS), LPCV, ALPHA, LAG, LAIC, LPHI, NPRT, VAR, PARZEN,
     +   NMSUB)
!
      CALL STKCLR(NALL0)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL UASVS (ACOV, LAGMAX, Y, N,'/
     +  '      +            IAR, PHI, LAG, NF, FMIN, FMAX, NPRT,'/
     +  '      +            SPCA, SPCF, FREQ, LDSTAK)')
      END
!ACFMN
      SUBROUTINE ACFMN(Y, N, LAGMAX, RHO, SDRHO, YMEAN, PRHO, AIC,
     +   FTEST, PHI, IAR, OSPVAR, ACOV, LACOV, LAIC, CHIA, CHIAP, WORK,
     +   NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING AUTOCORRELATIONS AND
!     PARTIAL AUTOCORRELATIONS OF A TIME SERIES .
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN
      INTEGER
     +   IAR,LACOV,LAGMAX,LAIC,N,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),AIC(*),FTEST(2,*),PHI(*),PRHO(*),RHO(*),SDRHO(*),
     +   WORK(*),Y(*)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACFSD,ACVF,AOS,CHIRHO
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV)
!        THE AUTOCOVARIANCE FUNCTION ESTIMATE VECTOR.
!     DOUBLE PRECISION AIC(LAIC)
!        THE ARRAY CONTAINING AKAIAES CRITERION FOR EACH ORDER.
!     DOUBLE PRECISION CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     DOUBLE PRECISION FTEST(2, LAGMAX)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     DOUBLE PRECISION OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED ORDER (IAR).
!     DOUBLE PRECISION PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER (IAR).
!     DOUBLE PRECISION PRHO(LAGMAX)
!        THE ARRAY IN WHICH THE PARTIAL AUTOCORRELATIONS ARE STORED
!     DOUBLE PRECISION RHO(LAGMAX)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
!     DOUBLE PRECISION SDRHO(LAGMAX)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!     DOUBLE PRECISION WORK(LAGMAX)
!        AN ARRAY USED IN THE COMPUTATIONS OF THE PARTIAL
!        AUTOCORRELATIONS COEFFICIENTS.
!        ARE STORED
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!     COMPUTE AUTOCOVARIANCESS AND STANDARD DEVIATION OF THE SERIES.
!
      CALL ACVF(Y, N, YMEAN, ACOV, LAGMAX, LACOV)
!
      IF (ACOV(1) .EQ. 0.0D0) RETURN
!
!     COMPUTE PARTIAL AUTOCORRELATIONS AND THE AUTOREGRESSIVE MODEL
!     ORDER SELECTION STATISTICS.
!
      CALL AOS (N, LAGMAX, ACOV, PRHO, IAR, OSPVAR, PHI, WORK,
     +   AIC, FTEST, LACOV, LAIC)
!
      IF (NPRT .EQ. 0) RETURN
!
!     COMPUTE AUTOCORRELATIONS
!
      DO 10 I = 1, LAGMAX
         RHO(I) = ACOV(I+1) / ACOV(1)
   10 CONTINUE
!
!     COMPUTE STANDARD ERROR OF AUTOCORRELATIONS.
!
      CALL ACFSD (RHO, SDRHO, LAGMAX, N)
!
!     COMPUTE CHI STATISTIC BASED ON AUTOCORRELATION VALUES
!
      CALL CHIRHO (RHO, N, LAGMAX, CHIA, CHIAP)
!
      RETURN
      END
!ERVII
      SUBROUTINE ERVII (NMSUB, NMVAR, Y, N, YLB, YUB, NVMX,
     +   HEAD, MSGTYP, NV, ERROR)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS FOR VALUES IN THE INPUT VECTOR   Y
!     WHICH ARE OUTSIDE THE (INCLUSIVE) LIMITS YLB TO YUB, PRINTS
!     AN ERROR MESSAGE IF THE NUMBER OF VIOLATIONS EXCEEDS THE LARGEST
!     NUMBER OF VIOLATIONS ALLOWED, AND RETURNS THE NUMBER OF
!     VIOLATIONS AND AN ERROR FLAG INDICATING THE RESULTS.  THREE
!     MESSAGES ARE AVAILABLE, SPECIFIED BY    MSGTYP   .
!        IF (MSGTYP = 0) NO VIOLATIONS ARE ALLOWED.
!        IF (MSGTYP = 1) THE NUMBER OF VIOLATIONS MUST
!                        BE LESS THAN   NVMX   .
!        IF (MSGTYP = 2) VIOLATIONS ARE COUNTED ONLY IF THE
!                        THE FIRST ELEMENT IS NOT IN VIOLATION.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YLB,YUB
      INTEGER
     +   MSGTYP,N,NV,NVMX
      LOGICAL
     +   ERROR,HEAD
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
      CHARACTER
     +   NMSUB(6)*1,NMVAR(8)*1
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT,NNV,NNVMN
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        THE VALUE RETURNED FROM THE ERROR CHECKING ROUTINES TO INDICATE
!        WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED (TRUE)
!        OR NOT (FALSE).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        THE INDICATOR VARIABLE FOR THE TYPE OF MESSAGE.
!        IF (MSGTYP = 0) NO VIOLATIONS ARE ALLOWED.
!        IF (MSGTYP = 1) THE NUMBER OF VIOLATIONS MUST
!                        BE LESS THAN   NVMX   .
!        IF (MSGTYP = 2) VIOLATIONS ARE COUNTED ONLY IF THE
!                        THE FIRST ELEMENT IS NOT IN VIOLATION.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE PARAMETERS NAME.
!     INTEGER NNV
!        THE NUMBER OF VALUES NOT IN VIOLATION.
!     INTEGER NNVMN
!        THE SMALLEST NUMBER OF VALUES NOT IN VIOLATION ALLOWED.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND.
!     INTEGER NVMX
!        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR BEING TESTED.
!     DOUBLE PRECISION YLB, YUB
!        THE (INCLUSIVE) RANGE THAT THE VECTOR IS BEING TESTED
!        AGAINST.
!
      ERROR = .FALSE.
!
      IF (N .LE. 0) RETURN
!
!     TEST WHETHER TESTING IS NECESSRY
!
      IF ((MSGTYP .EQ. 2) .AND.
     +    (Y(1) .LT. YLB) .OR. (Y(1) .GT. YUB)) RETURN
!
!     CHECK FOR VIOLATIONS
!
      NV = 0
      DO 10 I = 1, N
         IF ((Y(I).LT.YLB) .OR. (Y(I).GT.YUB)) NV = NV + 1
   10 CONTINUE
!
      IF (NV .LE. NVMX) RETURN
!
!     VIOLATIONS FOUND
!
      ERROR = .TRUE.
      CALL IPRINT(IPRT)
!
      CALL EHDR(NMSUB, HEAD)
!
      NNV = N - NV
      NNVMN = N - NVMX
!
      IF (MSGTYP .EQ. 0)
     +   WRITE(IPRT, 1010) (NMVAR(I), I = 1, 6), YLB, YUB, NV
      IF (MSGTYP .EQ. 1)
     +   WRITE(IPRT, 1020) (NMVAR(I), I = 1, 6), YLB, YUB,
     +   NNVMN, NNV
      IF (MSGTYP .EQ. 2)
     +   WRITE(IPRT, 1030) (NMVAR(I), I = 1, 6), YLB, YUB
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1010 FORMAT(/
     +   26H THE VALUES IN THE VECTOR , 6A1,
     +   26H MUST ALL BE IN THE RANGE , 1PE14.7, 3H TO/
     +   1X, 1PE14.7,
     +      52H, INCLUSIVE. THE NUMBER OF VALUES OUTSIDE THIS RANGE,
     +   4H IS , I5, '.')
 1020 FORMAT(/
     +   36H THE NUMBER OF VALUES IN THE VECTOR , 6A1,
     +   14H IN THE RANGE , 1PE14.7, 3H TO/
     +   1X, 1PE14.7, 34H, INCLUSIVE, MUST EQUAL OR EXCEED , I5, '.'/
     +   ' THE NUMBER OF VALUES IN THIS RANGE IS ', I5, '.')
 1030 FORMAT(/
     +   34H IF THE FIRST VALUE OF THE VECTOR , 6A1,
     +   16H IS IN THE RANGE, 1PE14.7, 3H TO/
     +   1X, 1PE14.7,
     +      52H INCLUSIVE, ALL OF THE VALUES MUST BE IN THIS RANGE.)
!
      END
!FLTARM
      SUBROUTINE FLTARM (Y, YMISS, N, IAR, PHI, YF, YFMISS, NYF)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE FILTERS THE INPUT SERIES Y, WHICH CONTAINS MISSING
!     DATA, USING THE IAR TERMS OF THE AUTOREGRESSIVE FILTER PHI,
!     COPYING THE FILTERED SERIES INTO YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YFMISS,YMISS
      INTEGER
     +   IAR,N,NYF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PHI(*),Y(*),YF(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM,TEMP
      INTEGER
     +   I,I1,J,K
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      LOGICAL
     +   MVCHK
      EXTERNAL D1MACH,MVCHK
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IAR
!        THE NUMBER OF FILTER TERMS.
!     INTEGER I1, J, K
!        INDEXING VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     DOUBLE PRECISION PHI(IAR)
!        THE ARRAY IN WHICH THE FILTER COEFFICIENTS ARE STORED.
!     DOUBLE PRECISION TEMP
!        A TEMPORARY STORAGE LOCATION.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!     DOUBLE PRECISION YFMISS
!        THE MISSING VALUE CODE USED IN THE FILTERED SERIES TO
!        INDICATE THE VALUE COULD NOT BE COMPUTED DUE TO MISSING DATA.
!     DOUBLE PRECISION YMISS
!        THE MISSING VALUE CODE USED IN THE INPUT SERIES TO INDICATE
!        AN OBSERVATION IS MISSING.
!
      FPLM = D1MACH(2)
!
      YFMISS = FPLM
!
      DO 10 I = 1, N
         YF(I) = Y(I)
   10 CONTINUE
!
      NYF = N - IAR
!
      DO 50 I = 1, NYF
         TEMP = YFMISS
         K = I + IAR
         IF (MVCHK(YF(K), YMISS)) GO TO 40
         TEMP = YF(K)
         DO 30 J = 1, IAR
            K = K - 1
            IF (.NOT. MVCHK(YF(K), YMISS)) GO TO 20
            TEMP = YFMISS
            GO TO 40
   20       CONTINUE
            TEMP = TEMP - PHI(J) * YF(K)
   30    CONTINUE
   40    YF(I) = TEMP
   50 CONTINUE
!
      I1 = NYF + 1
!
      DO 60 I = I1, N
         YF(I) = 0.0D0
   60 CONTINUE
      RETURN
      END
!RELCOM
      SUBROUTINE RELCOM(N, V, W, RELTOL, ABSTOL, NFAIL, IFAIL)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES THE NUMBER OF TIMES THE
!     RELATIVE DIFFERENCE BETWEEN V(I) AND W(I), I = 1, 2, ..., N,
!     IS GREATER THAN   RELTOL  .
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ABSTOL,RELTOL
      INTEGER
     +   N,NFAIL
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   V(N),W(N)
      INTEGER
     +   IFAIL(N)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ABSTOL
!        THE ABSOLUTE TOLERANCE USED IN THE COMPARISON.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IFAIL(N)
!        AN INDICATOR VARIABLE DESIGNATING WHETHER OR NOT THE COMPARISON
!        FAILED OR NOT, WHERE 0 INDICATES NOT FAILURE AND 1 INDICATES
!        FALURE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAIL
!        THE TOTAL NUMBER OF FAILURES.
!     DOUBLE PRECISION RELTOL
!        THE RELATIVE TOLERANCE USED IN THE COMPARISON.
!     DOUBLE PRECISION V(N), W(N)
!        THE VALUES BEING COMPARED.
!
      NFAIL = 0
!
      DO 30 I = 1, N
         IF ((ABS(V(I)-W(I)).LE.RELTOL*MAX(ABS(V(I)),ABS(W(I)))) .OR.
     +       (((V(I).EQ.0.0D0).OR.(W(I).EQ.0.0D0)).AND.
     +        (ABS(V(I)-W(I)).LE.ABSTOL))) THEN
            IFAIL(I) = 0
         ELSE
            IFAIL(I) = 1
            NFAIL = NFAIL + 1
         END IF
   30 CONTINUE
!
      RETURN
!
      END
!CCFFS
      SUBROUTINE CCFFS (YMFFT, N, M, IYMFFT, LAGMAX,
     +   CCOV, ICCOV, JCCOV, NPRT, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
!     CORRELATIONS AND COVARIANCES OF A MULTIVARIATE SERIES USING THE
!     SINGLETON FFT (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,IYMFFT,JCCOV,LAGMAX,LDSTAK,M,N,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(*),YMFFT(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IFP,INLPPC,IO,IPRT,IYM,J,JNLPPC,K,LDSMIN,LYFFT,NALL0,
     +   NFFT,RHOC,SDRHOC,WORK,YMEAN,YMEANJ,YMEANK,YSD,YSDJ,YSDK
      LOGICAL
     +   ISFFT,ISLONG,NEWPG
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACVFF,CCFER,CCFMNF,CCFOUT,FFTLEN,IPRINT,LDSCMP,STKCLR,
     +   STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  STATEMENT FUNCTIONS
      INTEGER
     +   I2,I3
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCOV(ICCOV, JCCOV, M)
!        THE CROSS COVARIANCE MATRIX.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ICCOV
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INLPPC
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
!        IN THE USERS PROGRAM.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON WHETHER PRINTED OUTPUT IS DESIRED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     LOGICAL ISLONG
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
!     INTEGER IYM
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YM AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IYMFFT
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER I2
!        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN YMFFT
!     INTEGER I3
!        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN CCOV
!     INTEGER J
!        THE INDEX OF -SERIES 1- IN THE ARRAY YMFFT.
!     INTEGER JCCOV
!        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
!        IN THE USERS PROGRAM.
!     INTEGER K
!        THE INDEX OF -SERIES 2- IN THE ARRAY YMFFT.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE NUMBER OF LOCATIONS IN EACH COLUMN OF YMFFT ALLOWED FOR
!        THE EXTENDED SERIES.
!     INTEGER M
!        THE NUMBER OF SERIES BEING COMPARED, IE THE
!        NUMBER OF COLUMNS OF DATA IN YMFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     INTEGER NDUM(1)
!        A DUMMY DMENSIONED ARRAY.
!     LOGICAL NEWPG
!        AN INDICATOR VARIABLE USED TO DETERMINE WHEN A NEW PAGE
!        IS APPROPRIATE FOR THE OUTPUT.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPEDIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS GIVEN.
!     INTEGER RHOC
!        THE STARTING LOCATION IN STAK/DSTAK OF THE ARRAY RHOC.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SDRHOC
!        THE STARTING LOCATION IN THE WORK AREA FOR SDRHOC.
!     INTEGER WORK
!        THE STARGING LOCATION IN DSTAK OF
!        THE WORK VECTOR NEEDED BY THE FFT.
!     INTEGER YMEAN, YMEANJ, YMEANK
!        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
!        MEANS OF EACH OF THE SERIES, AND THE LOCATION IN
!        THE ARRAY FOR THE MEAN OF THE JTH AND KTH SERIES,
!        RESPECTIVELY.
!     DOUBLE PRECISION YMFFT(IYMFFT, M)
!        THE MATRIX CONTAINING THE OBSERVED TIME SERIES
!     INTEGER YSD, YSDJ, YSDK
!        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
!        STANDARD DEVIATIONS OF EACH OF THE SERIES, AND THE
!        LOCATION IN THE ARRAY FOR THE STANDARD DEVIATION OF
!        THE JTH AND KTH SERIES, RESPECTIVELY.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'C',       'C',       'F',       'F',       'S',       ' '/
!
      I2(I,J) = I + (J-1)*IYMFFT
      I3(I,J,K) = I + (J-1)*ICCOV + (K-1)*JCCOV*ICCOV
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      INLPPC = ICCOV
      IYM = IYMFFT
      JNLPPC = JCCOV
      LYFFT = IYMFFT
      M = 2
      ISFFT = .TRUE.
      ISLONG = .TRUE.
!
      IO = 1
      IF (NPRT .EQ. 0) IO = 0
!
!     SET LENGTH OF EXTENDED SERIES
!
      IF ((N.GE.3) .AND. (LAGMAX.GE.1)) THEN
         CALL FFTLEN (N+LAGMAX, 4, NFFT)
      ELSE
         NFFT = N
      END IF
!
      CALL LDSCMP(3+2*IO, 0, 0, 0, 0, 0, 'D',
     +            2*M+NFFT+IO*(4*LAGMAX+2), LDSMIN)
!
      CALL CCFER(NMSUB, N, LAGMAX, LDSTAK, LDSMIN, ICCOV, JCCOV,
     +  INLPPC, JNLPPC, M, LYFFT, NFFT, IYM, IYMFFT, ISFFT, ISLONG)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      IF (IERR.EQ.0) THEN
!
!       SET UP THE WORK AREA.
!
        CALL STKSET (LDSTAK, 4)
        NALL0 = STKST(1)
!
        IFP = 4
!
        YMEAN = STKGET(M, IFP)
        YSD = STKGET(M, IFP)
        IF (NPRT.EQ.0) THEN
          RHOC = YSD
          SDRHOC = YSD
        ELSE
          RHOC = STKGET(2*LAGMAX+1, IFP)
          SDRHOC = STKGET(2*LAGMAX+1, IFP)
        END IF
        WORK = STKGET(NFFT, IFP)
!
        IF (IERR.EQ.0) THEN
!
!         BEGIN LOOP FOR COMPUTATIONS
!
          NEWPG = .FALSE.
!
          DO 40 K = 1, M
!
             YMEANK = YMEAN + K - 1
             YSDK = YSD + K - 1
!
             CALL ACVFF (YMFFT(I2(1,K)), N, NFFT, RSTAK(YMEANK),
     +                   CCOV(I3(1,K,K)), LAGMAX, ICCOV, LYFFT,
     +                   RSTAK(WORK), NFFT)
             RSTAK(YSDK) = SQRT(CCOV(I3(1,K,K)) * N / (N - 1))
!
             IF ((K-1).LE.0) GO TO 40
!
             DO 30 J = 1, (K-1)
!
                YMEANJ = YMEAN + J - 1
                YSDJ = YSD + J - 1
!
                CALL CCFMNF(YMFFT(I2(1,J)), YMFFT(I2(1,K)),
     +                      N, NFFT, LAGMAX, 2*LAGMAX+1,
     +                      CCOV(I3(1,J,J)), CCOV(I3(1,K,K)),
     +                      CCOV(I3(1,J,K)), CCOV(I3(1,K,J)),
     +                      ICCOV, RSTAK(RHOC), RSTAK(SDRHOC), NPRT,
     +                      LYFFT, RSTAK(WORK), NFFT)
!
                IF (NPRT .EQ. 0) GO TO 30
!
!         CALL ROUTINE TO PRINT OUT CORRELATIONS
!
                CALL CCFOUT (J, RSTAK(YMEANJ), RSTAK(YSDJ), N, N, K,
     +             RSTAK(YMEANK), RSTAK(YSDK), N, N, LAGMAX, 2*LAGMAX+1,
     +             RSTAK(RHOC), RSTAK(SDRHOC), .FALSE., NDUM, NDUM, 1,
     +             0.0D0, 0.0D0, NEWPG)
!
                NEWPG = .TRUE.
!
   30        CONTINUE
   40     CONTINUE
        END IF
!
        CALL STKCLR(NALL0)
      END IF
!
      IF (IERR.NE.0) THEN
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL CCFFS (YMFFT, N, M, IYMFFT,'/
     + '      +            LAGMAX, CCOV, ICCOV, JCCOV, NPRT, LDSTAK)')
      END
!CCVFF
      SUBROUTINE CCVFF (YFFT1, YFFT2, N, NFFT, LAGMAX, CCOV12, CCOV21,
     +   ICCOV, LYFFT, WORK, LWORK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE CROSS COVARIANCE FUNCTION
!     BETWEEN TWO SERIES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,LAGMAX,LWORK,LYFFT,N,NFFT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV12(ICCOV),CCOV21(ICCOV),WORK(LWORK),YFFT1(LYFFT),
     +   YFFT2(LYFFT)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FAC
      INTEGER
     +   I,ISN,J,LAG,NF,NF2,NFFT2
!
!  EXTERNAL SUBROUTINES
      EXTERNAL FFT,REALTR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCOV12(ICCOV), CCOV21(ICCOV)
!        THE ARRAYS IN WHICH THE CCVF FOR SERIES 1 LAGGED
!        BEHIND SERIES 2 AND VISA VERSA, RESPECTIVELY, ARE STORED.
!     DOUBLE PRECISION FAC
!        THE APPROPRIATE FACTOR USED TO SCALE THE CCVF.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER ICCOV
!        THE DIMENSION OF THE ARRAYS CCOV12 AND CCOV21.
!     INTEGER LAG, LAGMAX
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        CROSS CORRELATION BEING COMPUTED, AND THE MAXIMUM LAG
!        VALUE TO BE USED.
!     INTEGER LWORK
!        THE DIMENSION OF THE VECTOR WORK.
!     INTEGER LYFFT
!        THE ACTUAL LENGTH OF THE ARRAYS YFFT1 AND YFFT2.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NF
!        THE NUMBER OF FOURIER FREQUENCIES.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NFFT2
!        THE EFFECTIVE NUMBER OF OBSERVATIONS FOR THE FFT TRANSFORM.
!     INTEGER NF2
!        TWICE THE NUMBER OF FOURIER FREQUENCIES.
!     DOUBLE PRECISION WORK(LWORK)
!        THE WORK ARRAY NEEDED FOR THE COMPUTATIONS.
!     DOUBLE PRECISION YFFT1(LYFFT), YFFT2(LYFFT)
!        THE VECTORS CONTAINING THE OBSERVED SERIES ALREADY PROCESSED
!        BY ONE PASS OF A FFT.
!
      NFFT2 = (NFFT-2) / 2
      NF = NFFT2 + 1
      NF2 = NF * 2
!
!     COMPUTE THE CROSS COVARIANCES
!
      DO 10 I = 2, NF2, 2
         WORK(I-1) = YFFT1(I-1)*YFFT2(I-1) + YFFT1(I)*YFFT2(I)
         WORK(I) = YFFT1(I)*YFFT2(I-1) - YFFT1(I-1)*YFFT2(I)
   10 CONTINUE
!
      FAC = 1.0D0 / (4 * (NFFT-2) * N)
!
      ISN = -2
!
      CALL REALTR (WORK, WORK(2), NFFT2, ISN)
!
      CALL FFT (WORK, WORK(2), NFFT2, NFFT2, NFFT2, ISN)
!
      CCOV12(1) = WORK(1) * FAC
      CCOV21(1) = CCOV12(1)
!
      DO 20 LAG = 1, LAGMAX
         CCOV21(LAG+1) = WORK(LAG+1) * FAC
!
         J = NFFT - 1 - LAG
         CCOV12(LAG+1) = WORK(J) * FAC
   20 CONTINUE
!
      RETURN
      END
!XBFS
      SUBROUTINE XBFS(LDS,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE FOURIER SPECTRUM ANALYSIS ROUTINES
!
!     SERIES Y1 AND Y2 ARE LISTED AS SERIES X1 AND X2 ON PAGE OF 361 OF
!     JENKINS AND WATTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDS
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CMISS,FMAX,FMIN,YMISS,YMISS1,YMISS2
      INTEGER
     +   I,ICCOV,ICSPC2,INDEX1,INDEX2,INLPPC,IPHAS,IPRT,ISPCF,J,
     +   JCCOV,JNLPPC,LACOV,LAGMAX,LDSTAK,LYFFT,N,NF,NPRT,NW
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCOV(101,2,2),CSPC2(300,2),FREQ(300),PHAS(300,2),Y1(150),
     +   Y2(150),YFFT1(400),YFFT2(400),YM(150,2),YMMISS(4)
      INTEGER
     +   LAGS(4),NLPPC(101,2,2)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL BFS,BFSF,BFSFS,BFSM,BFSMS,BFSMV,BFSMVS,BFSS,BFSV,BFSVS,
     +   CCFMS,CCFS,IPRINT,NRAND,DCOPY,SETIV,SETRV
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (YM(1,1),Y1(1))
      EQUIVALENCE (YM(1,2),Y2(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CMISS
!         THE MISSING VALUE CODE FOR THE RETURNED CCVF ESTIMATES.
!     DOUBLE PRECISION CCOV(101,2,2)
!        THE COVARIANCES.
!     DOUBLE PRECISION CSPC2(300,2)
!        THE SQUARED COHERENCY COMPONENT OF THE SPECTRUM.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCIES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(300)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISPCF
!         THE ACTUAL DIMENSION FOR THE SPECTRUM ARRAYS.
!     INTEGER J
!        INDEX VARIABLE.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCOVARIANCE BEING COMPUTED AND THE MAXIMUM LAG TO BE USED,
!        RESPECTIVELY.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDS, LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTORS YFFT AND ZFFT, RESPECTIVELY..
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC(101,2,2)
!        THE NUMBERS OF LAGGED PRODUCT PAIRS USED FOR EACH ACVF.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE NUMBER OF DIFFERENT LAG WINDOW TRUNCATION POINTS SPECIFIED,
!        AND THEREFORE, THE NUMBER OF PLOTS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     DOUBLE PRECISION PHAS(300,2)
!        THE PHASE COMPONENT OF THE SPECTRUM.
!     DOUBLE PRECISION YFFT1(400), YFFT2(400)
!        THE VECTORS OF THE OBSERVED TIME SERIES TO BE ANALYZED USING
!        THE FFT.
!     DOUBLE PRECISION YMISS, YMISS1, YMISS2, YMMISS(4)
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!     DOUBLE PRECISION YM(150,2)
!        THE MULTIVARIATE REPRESENTATION OF THE DATA
!     DOUBLE PRECISION Y1(150), Y2(150)
!         THE VECTORS CONTAINING THE TIME SERIES FROM JENKINS AND WATTS.
!
      DATA   Y1(  1),  Y1(  2),  Y1(  3),  Y1(  4),  Y1(  5),  Y1(  6)
     +    /-0.88D0, -0.16D0, -1.87D0, -1.12D0,  1.38D0,  2.13D0/
      DATA   Y1(  7),  Y1(  8),  Y1(  9),  Y1( 10),  Y1( 11),  Y1( 12)
     +    / 2.76D0,  0.56D0, -0.69D0, -1.79D0, -3.82D0, -2.38D0/
      DATA   Y1( 13),  Y1( 14),  Y1( 15),  Y1( 16),  Y1( 17),  Y1( 18)
     +    / 1.00D0,  0.70D0, -0.15D0,  0.98D0,  0.11D0, -0.35D0/
      DATA   Y1( 19),  Y1( 20),  Y1( 21),  Y1( 22),  Y1( 23),  Y1( 24)
     +    /-0.73D0,  0.89D0, -1.63D0, -0.44D0, -1.37D0, -1.71D0/
      DATA   Y1( 25),  Y1( 26),  Y1( 27),  Y1( 28),  Y1( 29),  Y1( 30)
     +    /-1.22D0, -2.00D0, -0.22D0,  0.38D0,  1.31D0,  0.71D0/
      DATA   Y1( 31),  Y1( 32),  Y1( 33),  Y1( 34),  Y1( 35),  Y1( 36)
     +    / 0.32D0,  0.48D0, -1.88D0, -0.94D0, -1.54D0, -0.13D0/
      DATA   Y1( 37),  Y1( 38),  Y1( 39),  Y1( 40),  Y1( 41),  Y1( 42)
     +    / 1.02D0,  0.02D0, -0.77D0,  0.11D0, -0.60D0, -0.52D0/
      DATA   Y1( 43),  Y1( 44),  Y1( 45),  Y1( 46),  Y1( 47),  Y1( 48)
     +    /-0.09D0,  1.23D0,  1.46D0,  0.61D0,  0.42D0,  2.16D0/
      DATA   Y1( 49),  Y1( 50),  Y1( 51),  Y1( 52),  Y1( 53),  Y1( 54)
     +    / 3.18D0,  2.10D0,  0.37D0, -0.24D0,  0.57D0, -0.53D0/
      DATA   Y1( 55),  Y1( 56),  Y1( 57),  Y1( 58),  Y1( 59),  Y1( 60)
     +    / 2.44D0,  1.02D0, -0.53D0, -2.49D0, -2.12D0, -1.04D0/
      DATA   Y1( 61),  Y1( 62),  Y1( 63),  Y1( 64),  Y1( 65),  Y1( 66)
     +    /-0.12D0, -1.88D0, -1.50D0,  1.54D0,  3.33D0,  3.08D0/
      DATA   Y1( 67),  Y1( 68),  Y1( 69),  Y1( 70),  Y1( 71),  Y1( 72)
     +    / 1.71D0,  0.79D0,  1.55D0,  0.89D0, -0.89D0, -1.18D0/
      DATA   Y1( 73),  Y1( 74),  Y1( 75),  Y1( 76),  Y1( 77),  Y1( 78)
     +    / 0.89D0,  1.71D0,  3.05D0,  0.15D0, -1.04D0,  0.12D0/
      DATA   Y1( 79),  Y1( 80),  Y1( 81),  Y1( 82),  Y1( 83),  Y1( 84)
     +    / 0.08D0,  0.11D0, -2.62D0, -1.28D0,  1.07D0,  3.20D0/
      DATA   Y1( 85),  Y1( 86),  Y1( 87),  Y1( 88),  Y1( 89),  Y1( 90)
     +    / 1.92D0,  0.53D0, -1.08D0,  0.49D0, -0.58D0,  0.17D0/
      DATA   Y1( 91),  Y1( 92),  Y1( 93),  Y1( 94),  Y1( 95),  Y1( 96)
     +    / 1.15D0, -0.97D0, -1.63D0,  1.14D0, -0.67D0, -0.88D0/
      DATA   Y1( 97),  Y1( 98),  Y1( 99),  Y1(100)
     +    /-0.07D0,  0.24D0,  0.55D0, -2.16D0/
      DATA   Y2(  1),  Y2(  2),  Y2(  3),  Y2(  4),  Y2(  5),  Y2(  6)
     +    / 0.79D0,  1.12D0, -1.10D0, -2.39D0, -1.75D0, -0.82D0/
      DATA   Y2(  7),  Y2(  8),  Y2(  9),  Y2( 10),  Y2( 11),  Y2( 12)
     +    /-0.36D0,  1.27D0,  1.75D0,  2.44D0,  0.36D0, -2.10D0/
      DATA   Y2( 13),  Y2( 14),  Y2( 15),  Y2( 16),  Y2( 17),  Y2( 18)
     +    /-1.93D0, -1.30D0, -1.75D0, -0.34D0,  0.74D0,  0.49D0/
      DATA   Y2( 19),  Y2( 20),  Y2( 21),  Y2( 22),  Y2( 23),  Y2( 24)
     +    / 0.70D0,  0.71D0,  0.09D0,  0.59D0,  1.54D0,  0.14D0/
      DATA   Y2( 25),  Y2( 26),  Y2( 27),  Y2( 28),  Y2( 29),  Y2( 30)
     +    / 0.55D0, -1.40D0, -2.55D0, -1.66D0, -0.43D0,  0.58D0/
      DATA   Y2( 31),  Y2( 32),  Y2( 33),  Y2( 34),  Y2( 35),  Y2( 36)
     +    / 2.18D0, -0.24D0,  0.58D0, -0.18D0, -1.55D0, -0.64D0/
      DATA   Y2( 37),  Y2( 38),  Y2( 39),  Y2( 40),  Y2( 41),  Y2( 42)
     +    /-1.09D0,  0.90D0, -0.66D0, -0.35D0,  0.48D0,  0.50D0/
      DATA   Y2( 43),  Y2( 44),  Y2( 45),  Y2( 46),  Y2( 47),  Y2( 48)
     +    / 0.05D0, -0.68D0,  0.24D0,  0.58D0, -1.26D0, -0.25D0/
      DATA   Y2( 49),  Y2( 50),  Y2( 51),  Y2( 52),  Y2( 53),  Y2( 54)
     +    / 0.25D0,  2.18D0,  2.96D0,  1.56D0, -0.36D0, -0.59D0/
      DATA   Y2( 55),  Y2( 56),  Y2( 57),  Y2( 58),  Y2( 59),  Y2( 60)
     +    /-0.12D0,  3.03D0,  2.11D0,  0.78D0,  0.89D0, -1.45D0/
      DATA   Y2( 61),  Y2( 62),  Y2( 63),  Y2( 64),  Y2( 65),  Y2( 66)
     +    /-0.36D0, -0.37D0, -1.39D0, -4.19D0, -0.73D0, -0.98D0/
      DATA   Y2( 67),  Y2( 68),  Y2( 69),  Y2( 70),  Y2( 71),  Y2( 72)
     +    / 0.36D0,  0.06D0, -1.94D0, -0.08D0,  0.17D0,  1.00D0/
      DATA   Y2( 73),  Y2( 74),  Y2( 75),  Y2( 76),  Y2( 77),  Y2( 78)
     +    /-0.05D0,  0.43D0,  0.15D0,  2.69D0,  0.57D0,  0.29D0/
      DATA   Y2( 79),  Y2( 80),  Y2( 81),  Y2( 82),  Y2( 83),  Y2( 84)
     +    / 1.10D0,  0.48D0, -1.06D0, -2.28D0, -2.03D0, -0.75D0/
      DATA   Y2( 85),  Y2( 86),  Y2( 87),  Y2( 88),  Y2( 89),  Y2( 90)
     +    / 1.00D0,  1.71D0,  0.58D0,  1.97D0,  0.99D0,  1.94D0/
      DATA   Y2( 91),  Y2( 92),  Y2( 93),  Y2( 94),  Y2( 95),  Y2( 96)
     +    / 2.18D0,  3.14D0,  0.60D0,  0.51D0,  1.35D0,  0.56D0/
      DATA   Y2( 97),  Y2( 98),  Y2( 99),  Y2(100)
     +    / 0.11D0,  0.00D0,  2.34D0,  1.88D0/
!
!
      CALL IPRINT(IPRT)
      CALL SETRV(YMMISS, 4, 0.89D0)
!
!     CHECK ERROR HANDLING
!
!        TEST 1  -  MISCELANEOUS ERROR CHECKING
!
      WRITE (IPRT, 2000)
      LAGMAX = -1
      N = -10
      INDEX1 = 0
      INDEX2 = 0
      ICCOV = 0
      JCCOV = 0
      INLPPC = 0
      JNLPPC = 0
      ICSPC2 = -10
      IPHAS = -10
      LACOV = -11
      LYFFT = -11
      NW = -1
      NF = -5
      FMIN = 0.5D0
      FMAX = 0.0D0
      NPRT = -1
      ISPCF = -20
      LDSTAK = 0
      YMISS1 = 0.89D0
      YMISS2 = 0.89D0
!
      WRITE(IPRT, 1001)
      CALL BFS (Y1, Y2, N)
      WRITE (IPRT, 1002) IERR
!
      WRITE(IPRT, 1003)
      CALL BFSS(Y1, Y2, N, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
      WRITE(IPRT, 1019)
      CALL BFSF (YFFT1, YFFT2, N, LYFFT, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
      WRITE(IPRT, 1020)
      CALL BFSFS(YFFT1, YFFT2, N, LYFFT, LDSTAK, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ)
      WRITE (IPRT, 1002) IERR
!
      WRITE(IPRT, 1005)
      CALL BFSM (Y1, YMISS1, Y2, YMISS2, N)
      WRITE (IPRT, 1002) IERR
!
      WRITE(IPRT, 1006)
      CALL BFSMS(Y1, YMISS1, Y2, YMISS2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
      WRITE (IPRT, 1007)
      CALL BFSV(CCOV, INDEX1, INDEX2, N, LAGMAX, ICCOV, JCCOV)
      WRITE (IPRT, 1002) IERR
!
      WRITE (IPRT, 1008)
      CALL BFSVS (CCOV, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS,
     +   FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
      WRITE (IPRT, 1021)
      CALL BFSMV(CCOV, NLPPC, INDEX1, INDEX2, N, LAGMAX, ICCOV, JCCOV,
     +   INLPPC, JNLPPC)
      WRITE (IPRT, 1002) IERR
!
      WRITE (IPRT, 1022)
      CALL BFSMVS (CCOV, NLPPC, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   INLPPC, JNLPPC, NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2, ICSPC2,
     +   PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!        TEST 2  -  MISCELANEOUS ERROR CHECKING (CONTINUED)
!
      WRITE (IPRT, 2010)
      N = 100
      LAGMAX = 40
      INDEX1 = 0
      INDEX2 = 0
      ICCOV = 0
      JCCOV = 0
      INLPPC = 0
      JNLPPC = 0
      ICSPC2 = 300
      IPHAS = 300
      LACOV = 101
      LYFFT = -11
      NW = 2
      LAGS(1) = 0
      LAGS(2) = 100
      NF = 202
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 3
      ISPCF = 101
      LDSTAK = 0
!
      WRITE(IPRT, 1003)
      CALL BFSS(Y1, Y2, N, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
      WRITE(IPRT, 1019)
      CALL BFSF (YFFT1, YFFT2, N, LYFFT, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
      WRITE(IPRT, 1020)
      CALL BFSFS(YFFT1, YFFT2, N, LYFFT, LDSTAK, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ)
      WRITE (IPRT, 1002) IERR
!
      WRITE(IPRT, 1006)
      CALL BFSMS(Y1, YMISS1, Y2, YMISS2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
      WRITE (IPRT, 1008)
      CALL BFSVS (CCOV, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS,
     +   FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
      WRITE (IPRT, 1022)
      CALL BFSMVS (CCOV, NLPPC, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   INLPPC, JNLPPC, NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2, ICSPC2,
     +   PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!        TEST 3  -  LDSTAK TOO SMALL
!
      WRITE (IPRT, 2030)
      N = 100
      INDEX1 = 2
      INDEX2 = 1
      ICCOV = 101
      JCCOV = 2
      INLPPC = 101
      JNLPPC = 2
      ICSPC2 = 300
      IPHAS = 300
      LAGMAX = 99
      LACOV = 101
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 26
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 1
      ISPCF = 101
      LDSTAK = 0
!
      WRITE(IPRT, 1003)
      CALL BFSS(Y1, Y2, N, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
      WRITE(IPRT, 1019)
      CALL BFSF (YFFT1, YFFT2, N, LYFFT, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
      WRITE(IPRT, 1020)
      CALL BFSFS(YFFT1, YFFT2, N, LYFFT, LDSTAK, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ)
      WRITE (IPRT, 1002) IERR
!
      WRITE(IPRT, 1006)
      CALL BFSMS(Y1, YMISS1, Y2, YMISS2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
      WRITE (IPRT, 1008)
      CALL BFSVS (CCOV, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS,
     +   FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
      WRITE (IPRT, 1022)
      CALL BFSMVS (CCOV, NLPPC, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   INLPPC, JNLPPC, NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2, ICSPC2,
     +   PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!        TEST 4  -  ALL DATA AND COVARIANCES MISSING
!
      WRITE (IPRT, 2040)
      N = 100
      LAGMAX = 99
      ICSPC2 = 300
      IPHAS = 300
      LACOV = 101
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 26
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 1
      ISPCF = 101
      LDSTAK = LDS
      CALL SETRV(YFFT1, N, YMISS1)
      CALL SETRV(YFFT2, N, YMISS2)
      CALL SETRV(CCOV, 404, 0.0D0)
      CALL SETIV(NLPPC, 404, 0)
!
      WRITE(IPRT, 1005)
      CALL BFSM (YFFT1, YMISS1, YFFT2, YMISS2, N)
      WRITE (IPRT, 1002) IERR
!
      WRITE(IPRT, 1006)
      CALL BFSMS(YFFT1, YMISS1, YFFT2, YMISS2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
      WRITE (IPRT, 1021)
      CALL BFSMV(CCOV, NLPPC, INDEX1, INDEX2, N, LAGMAX, ICCOV, JCCOV,
     +   INLPPC, JNLPPC)
      WRITE (IPRT, 1002) IERR
!
      WRITE (IPRT, 1022)
      CALL BFSMVS (CCOV, NLPPC, INDEX1, INDEX2, N, ICCOV, JCCOV,
     +   INLPPC, JNLPPC, NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2, ICSPC2,
     +   PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!        TEST 5  -  EVERY OTHER VALUE MISSING
!
      WRITE (IPRT, 2050)
      N = 100
      LAGMAX = 99
      ICSPC2 = 300
      IPHAS = 300
      LACOV = 101
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 26
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 1
      ISPCF = 101
      LDSTAK = LDS
      CALL SETRV(YFFT1, N, YMISS1)
      CALL SETRV(YFFT2, N, YMISS2)
      DO 10 I = 1, N, 2
         YFFT1(I) = Y1(I)
         YFFT2(I) = Y2(I)
   10 CONTINUE
!
      WRITE(IPRT, 1005)
      CALL BFSM (YFFT1, YMISS1, YFFT2, YMISS2, N)
      WRITE (IPRT, 1002) IERR
!
      WRITE(IPRT, 1006)
      CALL BFSMS(YFFT1, YMISS1, YFFT2, YMISS2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     CHECK RESULTS FROM VALID CALL
!
      WRITE(IPRT, 2020)
      YMISS = 1.16D0
      N = 100
      LAGMAX = 99
      ICSPC2 = 300
      IPHAS = 300
      LACOV = 101
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 26
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 1
      ISPCF = 101
      LDSTAK = LDS
!
!     TEST OF BFS
!
      WRITE(IPRT, 1001)
      CALL BFS (Y1, Y2, N)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF BFSS
!
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1003)
      CALL BFSS(Y1, Y2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM BFSS
!
      WRITE (IPRT, 1004) (FREQ(I), (CSPC2(I,J), PHAS(I,J),J=1,NW),
     +   I=1,NF)
!
!     TEST OF BFSF
!
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1019)
      CALL DCOPY(N, Y1, 1, YFFT1, 1)
      CALL DCOPY(N, Y2, 1, YFFT2, 1)
      CALL BFSF (YFFT1, YFFT2, N, LYFFT, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF BFSFS
!
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1020)
      CALL DCOPY(N, Y1, 1, YFFT1, 1)
      CALL DCOPY(N, Y2, 1, YFFT2, 1)
      CALL BFSFS(YFFT1, YFFT2, N, LYFFT, LDSTAK, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM BFSFS
!
      WRITE (IPRT, 1004) (FREQ(I), (CSPC2(I,J), PHAS(I,J),J=1,NW),
     +   I=1,NF)
!
!     TEST OF BFSM
!
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1005)
      CALL BFSM (Y1, YMISS1, Y2, YMISS2, N)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF BFSMS
!
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1006)
      CALL BFSMS(Y1, YMISS1, Y2, YMISS2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM BFSMS
!
      WRITE (IPRT, 1004) (FREQ(I), (CSPC2(I,J), PHAS(I,J),J=1,NW),
     +   I=1,NF)
!
!     TEST OF BFSV
!
      WRITE(IPRT, 2020)
      CALL CCFS (YM, N, 2, 150, LAGMAX, CCOV, ICCOV, JCCOV, 0,
     +   LDSTAK)
      WRITE (IPRT, 1007)
      CALL BFSV(CCOV, INDEX1, INDEX2, N, LAGMAX, ICCOV, JCCOV)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF BFSVS
!
      WRITE(IPRT, 2020)
      WRITE (IPRT, 1008)
      CALL BFSVS(CCOV, INDEX1, INDEX2, N, ICCOV, JCCOV, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM BFSVS
!
      WRITE (IPRT, 1004) (FREQ(I), (CSPC2(I,J), PHAS(I,J),J=1,NW),
     +   I=1,NF)
!
!     TEST OF BFSMV
!
      WRITE(IPRT, 2020)
      CALL CCFMS (YM, YMMISS, N, 2, 150, LAGMAX, CCOV, CMISS, ICCOV,
     +  JCCOV, NLPPC, INLPPC, JNLPPC, 0, LDSTAK)
      WRITE (IPRT, 1021)
      CALL BFSMV(CCOV, NLPPC, INDEX1, INDEX2, N, LAGMAX, ICCOV,
     +  JCCOV, INLPPC, JNLPPC)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF BFSMVS
!
      WRITE(IPRT, 2020)
      WRITE (IPRT, 1022)
      CALL BFSMVS(CCOV, NLPPC, INDEX1, INDEX2, N, ICCOV,
     +  JCCOV, INLPPC, JNLPPC, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +  CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM BFSMVS
!
      WRITE (IPRT, 1004) (FREQ(I), (CSPC2(I,J), PHAS(I,J),J=1,NW),
     +   I=1,NF)
!
!     MINIMUM PROBLEM SIZE
!
      YMISS = 1.16D0
      N = 17
      LAGMAX = 1
      ICSPC2 = 1
      IPHAS = 1
      LACOV = 101
      LYFFT = 400
      NW = 1
      LAGS(1) = 1
      LAGS(2) = 16
      NF = 1
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 1
      ISPCF = 101
      LDSTAK = LDS
!
!     TEST OF BFS
!
      WRITE(IPRT, 2060)
      WRITE(IPRT, 1001)
      CALL BFS(Y1, Y2, N)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF BFSS
!
      WRITE(IPRT, 2060)
      WRITE(IPRT, 1003)
      CALL BFSS(Y1, Y2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM BFSS
!
      WRITE (IPRT, 1004) (FREQ(I), (CSPC2(I,J), PHAS(I,J),J=1,NW),
     +   I=1,NF)
!
!     CHECK HANDLING OF FMIN AND FMAX
!
      YMISS = 1.16D0
      N = 100
      LAGMAX = 99
      ICSPC2 = 300
      IPHAS = 300
      LACOV = 101
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 26
      FMIN = 0.45D0
      FMAX = 0.5D0
      NPRT = 1
      ISPCF = 101
      LDSTAK = LDS
!
!     TEST OF BFSS
!
      WRITE(IPRT, 2070)
      WRITE(IPRT, 1003)
      CALL BFSS(Y1, Y2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM BFSS
!
      WRITE (IPRT, 1004) (FREQ(I), (CSPC2(I,J), PHAS(I,J),J=1,NW),
     +   I=1,NF)
!
!     CHECK RESULTS FOR WHITE NOISE SPECTRUM
!
      YMISS = 1.16D0
      CALL NRAND(YFFT1, N, 12343)
      CALL NRAND(YFFT2, N, 34523)
      N = 100
      LAGMAX = 99
      ICSPC2 = 300
      IPHAS = 300
      LACOV = 101
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 26
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 1
      ISPCF = 101
      LDSTAK = LDS
!
!     TEST OF BFSFS
!
      WRITE(IPRT, 2080)
      WRITE(IPRT, 1003)
      CALL BFSFS(YFFT1, YFFT2, N, LYFFT, LDSTAK, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM BFSS
!
      WRITE (IPRT, 1004) (FREQ(I), (CSPC2(I,J), PHAS(I,J),J=1,NW),
     +   I=1,NF)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1001 FORMAT (12H TEST OF BFS)
 1002 FORMAT (8H IERR IS, I5/)
 1003 FORMAT (13H TEST OF BFSS)
 1004 FORMAT (5(1X, E15.7))
 1005 FORMAT (13H TEST OF BFSM)
 1006 FORMAT (14H TEST OF BFSMS)
 1007 FORMAT (13H TEST OF BFSV)
 1008 FORMAT (14H TEST OF BFSVS)
 1019 FORMAT (13H TEST OF BFSF)
 1020 FORMAT (14H TEST OF BFSFS)
 1021 FORMAT (14H TEST OF BFSMV)
 1022 FORMAT (15H TEST OF BFSMVS)
 2000 FORMAT (32H1CHECK ERROR HANDLING  -  TEST 1)
 2010 FORMAT (32H1CHECK ERROR HANDLING  -  TEST 2)
 2020 FORMAT (14H1VALID PROBLEM)
 2030 FORMAT (14H1LDS TOO SMALL)
 2040 FORMAT (33H1ALL DATA AND COVARIANCES MISSING)
 2050 FORMAT (31H1EVERY OTHER DATA VALUE MISSING)
 2060 FORMAT (21H1MINIMUM PROBLEM SIZE)
 2070 FORMAT (32H1CHECK HANDLING OF FMIN AND FMAX)
 2080 FORMAT (21H1WHITE NOISE SPECTRUM)
      END
!OBSSM2
      SUBROUTINE OBSSM2(N, Y, PVT, SDPVT, RES, SDREST, IFIRST, ILAST)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBOUTINE LISTS THE DATA SUMMARY FOR THE ARIMA ESTIMATION
!     SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IFIRST,ILAST,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PVT(N),RES(N),SDPVT(N),SDREST(N),Y(N)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,IPRT
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIRST, ILAST
!        THE FIRST AND LAST INDICES TO BE LISTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     DOUBLE PRECISION PVT(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION SDPVT(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDREST(N)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
      FPLM = D1MACH(2)
!
      CALL IPRINT(IPRT)
!
      DO 140 I=IFIRST,ILAST
!
!     PRINT DATA SUMMARY.
!
         IF ((SDPVT(I).NE.FPLM) .AND. (SDREST(I).NE.FPLM))
     +      WRITE (IPRT, 1060) I, Y(I), PVT(I), SDPVT(I), RES(I),
     +      SDREST(I)
         IF ((SDPVT(I).NE.FPLM) .AND. (SDREST(I).EQ.FPLM))
     +      WRITE (IPRT, 1050) I, Y(I), PVT(I), SDPVT(I), RES(I)
         IF ((SDPVT(I).EQ.FPLM) .AND. (SDREST(I).EQ.FPLM))
     +      WRITE (IPRT, 1080) I, Y(I), PVT(I), RES(I)
!
  140 CONTINUE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1050 FORMAT (1X, I4, 4E16.8, 4X, 4HNC *, 1X, E9.3)
 1060 FORMAT (1X, I4, 4E16.8, 1X, F7.2, 1X, E9.3)
 1080 FORMAT (1X, I4, 2E16.8, 8X, 4HNC *, 4X, E16.8, 4X, 4HNC *,
     +   1X, E9.3)
      END
!AMFOUT
      SUBROUTINE AMFOUT(F, FSD, N, NFCST, IFCSTO, IFO, NFCSTO, Y,
     +  T975, PAGE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES ARIMA FORECASTING OUTPUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   T975
      INTEGER
     +   IFO,N,NFCST,NFCSTO
      LOGICAL
     +   PAGE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   F(*),FSD(*),Y(*)
      INTEGER
     +   IFCSTO(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FL,FU,SCALE,YMN,YMX
      INTEGER
     +   I,IEND,IF,ILIM,INTER,IPF,IPFL,IPFU,IPRT,IPY,IY,J
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YLIM(4)
      CHARACTER
     +   LINE(53)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMFHDR,IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC INT,MAX,MIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION F(NFCST)
!        THE FORECASTS.
!     DOUBLE PRECISION FL
!        THE LOWER 95 PERCENT CONFIDENCE LIMIT FOR THE FORECAST
!     DOUBLE PRECISION FSD(NFCST)
!        THE STANDARD DEVIATIONS OF THE FORECASTS.
!     DOUBLE PRECISION FU
!        THE UPPER 95 PERCENT CONFIDENCE LIMIT FOR THE FORECAST
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IEND
!        THE LAST LOCATION IN THE PLOT STRING.
!     INTEGER IF
!        AN INDEX VARIABLE.
!     INTEGER IFCSTO(NFCSTO)
!        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
!     INTEGER IFO
!        THE INDEX OF THE ORIGIN BEING USED.
!     INTEGER ILIM
!        THE NUMBER OF LOCATIONS IN YLIM.
!     INTEGER INTER
!        THE NUMBER OF PLOT INTERVALS.
!     INTEGER IPF
!        THE LOCATION IN THE PLOT STRING OF THE FORECAST.
!     INTEGER IPFL
!        THE LOCATION IN THE PLOT STRING OF THE FORECAST LOWER
!        CONFIDENCE LIMIT.
!     INTEGER IPFU
!        THE LOCATION IN THE PLOT STRING OF THE FORECAST UPPER
!        CONFIDENCE LIMIT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IPY
!        THE LOCATION IN THE PLOT STRING OF THE OBSERVED VALUE.
!     INTEGER IY
!        AN INDEX VARIABLE.
!     INTEGER J
!        AN INDEX VARIABLE.
!     CHARACTER*1 LINE(53)
!        THE ARRAY OF SYMBOLS TO BE PLOTTED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFCST
!        THE NUMBER OF FORECASTS.
!     INTEGER NFCSTO
!        THE NUMBER OF THE ORIGINS.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION SCALE
!        THE PLOT SCALE.
!     DOUBLE PRECISION T975
!        THE VALUE OF THE 97.5 PERCENT POINT FUNCTION FOR THE
!        T DISTRIBUTION.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!     DOUBLE PRECISION YLIM(4)
!        THE VALUES OF THE AXIS LABELS.
!     DOUBLE PRECISION YMN
!        THE MINIMUM VALUE TO BE PLOTTED.
!     DOUBLE PRECISION YMX
!        THE MAXIMUM VALUE TO BE PLOTTED.
!
!     SET VARIABLES FOR PLOTS
!
      CALL IPRINT(IPRT)
      INTER = 50
      IEND = INTER + 1
      ILIM = 4
!
!     COMPUTE SCALE FOR PLOT
!
      YMN = F(NFCST)-T975*FSD(NFCST)
      YMX = F(NFCST)+T975*FSD(NFCST)
      IY = IFCSTO(IFO)
      DO 10 I = 1, NFCST
        YMN = MIN(YMN, F(I)-T975*FSD(I))
        YMX = MAX(YMX, F(I)+T975*FSD(I))
        IF ((IY.GE.1) .AND. (IY.LE.N)) THEN
          YMN = MIN(YMN, Y(IY))
          YMX = MAX(YMX, Y(IY))
          IY = IY + 1
        END IF
   10 CONTINUE
      IF (IFCSTO(IFO).GE.2) THEN
        DO 20 IY = MAX(IFCSTO(IFO)-4, 1), IFCSTO(IFO)-1
          YMN = MIN(YMN, Y(IY))
          YMX = MAX(YMX, Y(IY))
   20   CONTINUE
      END IF
!
      SCALE = (YMX-YMN) / INTER
!
!     PRINT PLOT HEADINGS
!
      DO 30 I = 1, ILIM
        YLIM(I) = YMN + SCALE*I*10.0D0
   30 CONTINUE
!
      CALL AMFHDR(PAGE, .TRUE., 0)
      WRITE (IPRT, 1030) IFO
      WRITE (IPRT, 1000) YMN, YLIM(2), YLIM(4),
     +  YLIM(1), YLIM(4), YMX
!
!     BEGIN PLOTTING
!
      DO 80 I=MAX(IFCSTO(IFO)-4,1), IFCSTO(IFO)+NFCST
         IF (I.NE.IFCSTO(IFO)) THEN
           DO 40 J = 1, IEND
             LINE(J) = ' '
   40      CONTINUE
         ELSE
           DO 50 J = 1, IEND
             LINE(J) = '.'
   50      CONTINUE
         END IF
         IF (I.LE.IFCSTO(IFO)) THEN
           IPY = INT(((Y(I)-YMN) / SCALE) + 1.5D0)
           LINE(IPY) = '*'
           WRITE (IPRT, 1020) I, (LINE(J),J=1,IEND), I, Y(I)
         ELSE
           IF = I-IFCSTO(IFO)
           FL = F(IF) - T975*FSD(IF)
           FU = F(IF) + T975*FSD(IF)
           IF (I.LE.N) THEN
             IPFL = INT(((FL-YMN) / SCALE) + 1.5D0)
             IPFU = INT(((FU-YMN) / SCALE) + 1.5D0)
             DO 60 J = IPFL, IPFU
               LINE(J) = '-'
   60        CONTINUE
             LINE(IPFL) = '('
             LINE(IPFU) = ')'
             IPY = INT(((Y(I)-YMN) / SCALE) + 1.5D0)
             LINE(IPY) = '*'
             IPF = INT(((F(IF)-YMN) / SCALE) + 1.5D0)
             IF (IPF.NE.IPY) THEN
               LINE(IPF) = 'X'
             ELSE
               LINE(IPF) = '2'
             END IF
             WRITE (IPRT, 1010) I, (LINE(J),J=1,IEND), I,
     +         F(IF), FL, FU, Y(I)
           ELSE
             IPFL = INT(((FL-YMN) / SCALE) + 1.5D0)
             IPFU = INT(((FU-YMN) / SCALE) + 1.5D0)
             DO 70 J = IPFL, IPFU
               LINE(J) = '-'
   70        CONTINUE
             LINE(IPFL) = '('
             LINE(IPFU) = ')'
             IPF = INT(((F(IF)-YMN) / SCALE) + 1.5D0)
             LINE(IPF) = 'X'
             WRITE (IPRT, 1010) I, (LINE(J),J=1,IEND), I,
     +         F(IF), FL, FU
           END IF
         END IF
   80 CONTINUE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (//
     +  82X, ' --------------------95  PERCENT'/
     +  1X, 3(G15.8, 5X), 21X,
     +  ' --------------CONFIDENCE LIMITS',
     +  ' ---------ACTUAL'/
     +  11X, 2(G15.8, 5X), G15.8,
     +  ' ------FORECASTS ----------LOWER',
     +  ' ----------UPPER -------IF KNOWN'/
     +  9X, 5('I---------'), 'I', 6X,
     +  ' ------------[X] ------------[(]',
     +  ' ------------[)] ------------[*]')
 1010 FORMAT (2X, I5, 1X, 'I', 51A1, 'I', I5, 4(1X, G15.8))
 1020 FORMAT (2X, I5, 1X, 'I', 51A1, 'I', I5, 49X, G15.8)
 1030 FORMAT (//' FORECASTS FOR ORIGIN ', I2)
!
      END
!CMPFD
      SUBROUTINE CMPFD(N,STP,PVSTP,PV,FD)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES A FINITE DIFFERENCE DERIVATIVE,
!     ASSUMING THAT IF THE DIFFERENCE BETWEEN PVSTP(I) AND PV(I) IS
!     SMALL ENOUGH THE DERIVATIVE IS ZERO.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 30, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   STP
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FD(*),PV(*),PVSTP(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLRS
      INTEGER
     +   I
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE.
!     DOUBLE PRECISION FD(N)
!        THE FINITE-DIFFERENCE DERIVATIVE.
!     DOUBLE PRECISION FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUES AT THE CURRENT PARAMETER VALUE.
!     DOUBLE PRECISION PVSTP(N)
!        THE PREDICTED VALUES AT THE CURRENT PARAMETER VALUE PLUS STP.
!     DOUBLE PRECISION STP
!        THE STEP.
!
      FPLRS = D1MACH(4)
!
      DO 10 I=1,N
         FD(I) = PVSTP(I) - PV(I)
         IF (ABS(FD(I)).GE.5*FPLRS*MIN(ABS(PVSTP(I)),ABS(PV(I)))) THEN
            FD(I) = FD(I) / STP
         ELSE
            FD(I) = 0.0D0
         END IF
   10 CONTINUE
      RETURN
      END
!XXCH2
      SUBROUTINE XXCH2(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE PAGE PLOT FAMILY OF ROUTINES.
!
!     DATA IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND JENKINS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JULY 22, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,IYM,M,N
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AIR(144),X(12),YM(12,12)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,MPP
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (AIR(1),YM(1,1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AIR(144)
!        THE AIRLINE DATA.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER IYM
!        THE EXACT VALUE OF THE FIRST DIMENSION OF THE MATRIX YM.
!     INTEGER LDSTAK
!        A DUMMY VARIABLE FOR THIS TEST SUBPROGRAM.
!     INTEGER M
!        THE NUMBER OF COLUMNS OF DATA IN YM.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN EACH COLUMN OF YM.
!     DOUBLE PRECISION X(12)
!        VECTOR OF OBSERVATIONS FOR X(HORIZONTAL) COORDINATES
!     DOUBLE PRECISION YM(12,12)
!        MULTIVARIATE OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES.
!
!
      DATA    X(  1),   X(  2),   X(  3),   X(  4),   X(  5),   X(  6)
     +    /   1.0D0,    2.0D0,    3.0D0,    4.0D0,    5.0D0,    6.0D0/
      DATA    X(  7),   X(  8),   X(  9),   X( 10),   X( 11),   X( 12)
     +    /   7.0D0,    8.0D0,    9.0D0,   10.0D0,   11.0D0,   12.0D0/
!
      DATA  AIR(  1), AIR(  2), AIR(  3), AIR(  4), AIR(  5), AIR(  6)
     +    / 112.0D0,  118.0D0,  132.0D0,  129.0D0,  121.0D0,  135.0D0/
      DATA  AIR(  7), AIR(  8), AIR(  9), AIR( 10), AIR( 11), AIR( 12)
     +    / 148.0D0,  148.0D0,  136.0D0,  119.0D0,  104.0D0,  118.0D0/
      DATA  AIR( 13), AIR( 14), AIR( 15), AIR( 16), AIR( 17), AIR( 18)
     +    / 115.0D0,  126.0D0,  141.0D0,  135.0D0,  125.0D0,  149.0D0/
      DATA  AIR( 19), AIR( 20), AIR( 21), AIR( 22), AIR( 23), AIR( 24)
     +    / 170.0D0,  170.0D0,  158.0D0,  133.0D0,  114.0D0,  140.0D0/
      DATA  AIR( 25), AIR( 26), AIR( 27), AIR( 28), AIR( 29), AIR( 30)
     +    / 145.0D0,  150.0D0,  178.0D0,  163.0D0,  172.0D0,  178.0D0/
      DATA  AIR( 31), AIR( 32), AIR( 33), AIR( 34), AIR( 35), AIR( 36)
     +    / 199.0D0,  199.0D0,  184.0D0,  162.0D0,  146.0D0,  166.0D0/
      DATA  AIR( 37), AIR( 38), AIR( 39), AIR( 40), AIR( 41), AIR( 42)
     +    / 171.0D0,  180.0D0,  193.0D0,  181.0D0,  183.0D0,  218.0D0/
      DATA  AIR( 43), AIR( 44), AIR( 45), AIR( 46), AIR( 47), AIR( 48)
     +    / 230.0D0,  242.0D0,  209.0D0,  191.0D0,  172.0D0,  194.0D0/
      DATA  AIR( 49), AIR( 50), AIR( 51), AIR( 52), AIR( 53), AIR( 54)
     +    / 196.0D0,  196.0D0,  236.0D0,  235.0D0,  229.0D0,  243.0D0/
      DATA  AIR( 55), AIR( 56), AIR( 57), AIR( 58), AIR( 59), AIR( 60)
     +    / 264.0D0,  272.0D0,  237.0D0,  211.0D0,  180.0D0,  201.0D0/
      DATA  AIR( 61), AIR( 62), AIR( 63), AIR( 64), AIR( 65), AIR( 66)
     +    / 204.0D0,  188.0D0,  235.0D0,  227.0D0,  234.0D0,  264.0D0/
      DATA  AIR( 67), AIR( 68), AIR( 69), AIR( 70), AIR( 71), AIR( 72)
     +    / 302.0D0,  293.0D0,  259.0D0,  229.0D0,  203.0D0,  229.0D0/
      DATA  AIR( 73), AIR( 74), AIR( 75), AIR( 76), AIR( 77), AIR( 78)
     +    / 242.0D0,  233.0D0,  267.0D0,  269.0D0,  270.0D0,  315.0D0/
      DATA  AIR( 79), AIR( 80), AIR( 81), AIR( 82), AIR( 83), AIR( 84)
     +    / 364.0D0,  347.0D0,  312.0D0,  274.0D0,  237.0D0,  278.0D0/
      DATA  AIR( 85), AIR( 86), AIR( 87), AIR( 88), AIR( 89), AIR( 90)
     +    / 284.0D0,  277.0D0,  317.0D0,  313.0D0,  318.0D0,  374.0D0/
      DATA  AIR( 91), AIR( 92), AIR( 93), AIR( 94), AIR( 95), AIR( 96)
     +    / 413.0D0,  405.0D0,  355.0D0,  306.0D0,  271.0D0,  306.0D0/
      DATA  AIR( 97), AIR( 98), AIR( 99), AIR(100), AIR(101), AIR(102)
     +    / 315.0D0,  301.0D0,  356.0D0,  348.0D0,  355.0D0,  422.0D0/
      DATA  AIR(103), AIR(104), AIR(105), AIR(106), AIR(107), AIR(108)
     +    / 465.0D0,  467.0D0,  404.0D0,  347.0D0,  305.0D0,  336.0D0/
      DATA  AIR(109), AIR(110), AIR(111), AIR(112), AIR(113), AIR(114)
     +    / 340.0D0,  318.0D0,  362.0D0,  348.0D0,  363.0D0,  435.0D0/
      DATA  AIR(115), AIR(116), AIR(117), AIR(118), AIR(119), AIR(120)
     +    / 491.0D0,  505.0D0,  404.0D0,  359.0D0,  310.0D0,  337.0D0/
      DATA  AIR(121), AIR(122), AIR(123), AIR(124), AIR(125), AIR(126)
     +    / 360.0D0,  342.0D0,  406.0D0,  396.0D0,  420.0D0,  472.0D0/
      DATA  AIR(127), AIR(128), AIR(129), AIR(130), AIR(131), AIR(132)
     +    / 548.0D0,  559.0D0,  463.0D0,  407.0D0,  362.0D0,  405.0D0/
      DATA  AIR(133), AIR(134), AIR(135), AIR(136), AIR(137), AIR(138)
     +    / 417.0D0,  391.0D0,  419.0D0,  461.0D0,  472.0D0,  535.0D0/
      DATA  AIR(139), AIR(140), AIR(141), AIR(142), AIR(143), AIR(144)
     +    / 622.0D0,  606.0D0,  508.0D0,  461.0D0,  390.0D0,  432.0D0/
!
!     DEFINE CONSTANTS
!
      CALL IPRINT(IPRT)
      IYM = 12
      N = 12
      M = 12
!
!     WRITE HEADER
!
      WRITE(IPRT, 1000)
!
!     RUN SIMPLE TEST OF MPP
!
      WRITE(IPRT, 1100)
      CALL MPP(YM, X, N, M, IYM)
      WRITE (IPRT,2000) IERR
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT ('1*CH2')
 1100 FORMAT (' SIMPLE TEST OF MPP')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
!XXCH1
      SUBROUTINE XXCH1(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE PAGE PLOT AND STATISTICAL ANALYSIS FAMILIES OF ROUTINES.
!
!     DATA SET IS 84 RELATIVE HUMIDITY MEASUREMENTS FROM PIKES PEAK.
!
!     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT,N
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   X(100),Y(100)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PP,STAT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        ERROR FLAG
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER N
!        THE LENGTH OF THE VECTOR Y.
!     DOUBLE PRECISION X(100)
!        THE ORDER INDICES OF THE DATA.
!     DOUBLE PRECISION Y(100)
!        DATA VECTOR FOR TESTS.
!
!
      DATA N /84/
!
      DATA Y( 1), Y( 2), Y( 3), Y( 4)
     +    / 0.6067D0, 0.6087D0, 0.6086D0, 0.6134D0/
      DATA Y( 5), Y( 6), Y( 7)
     +    / 0.6108D0, 0.6138D0, 0.6125D0/
      DATA Y( 8), Y( 9), Y(10), Y(11)
     +    / 0.6122D0, 0.6110D0, 0.6104D0, 0.7213D0/
      DATA Y(12), Y(13), Y(14)
     +    / 0.7078D0, 0.7021D0, 0.7004D0/
      DATA Y(15), Y(16), Y(17), Y(18)
     +    / 0.6981D0, 0.7242D0, 0.7268D0, 0.7418D0/
      DATA Y(19), Y(20), Y(21)
     +    / 0.7407D0, 0.7199D0, 0.6225D0/
      DATA Y(22), Y(23), Y(24), Y(25)
     +    / 0.6254D0, 0.6252D0, 0.6267D0, 0.6218D0/
      DATA Y(26), Y(27), Y(28)
     +    / 0.6178D0, 0.6216D0, 0.6192D0/
      DATA Y(29), Y(30), Y(31), Y(32)
     +    / 0.6191D0, 0.6250D0, 0.6188D0, 0.6233D0/
      DATA Y(33), Y(34), Y(35)
     +    / 0.6225D0, 0.6204D0, 0.6207D0/
      DATA Y(36), Y(37), Y(38), Y(39)
     +    / 0.6168D0, 0.6141D0, 0.6291D0, 0.6231D0/
      DATA Y(40), Y(41), Y(42)
     +    / 0.6222D0, 0.6252D0, 0.6308D0/
      DATA Y(43), Y(44), Y(45), Y(46)
     +    / 0.6376D0, 0.6330D0, 0.6303D0, 0.6301D0/
      DATA Y(47), Y(48), Y(49)
     +    / 0.6390D0, 0.6423D0, 0.6300D0/
      DATA Y(50), Y(51), Y(52), Y(53)
     +    / 0.6260D0, 0.6292D0, 0.6298D0, 0.6290D0/
      DATA Y(54), Y(55), Y(56)
     +    / 0.6262D0, 0.5952D0, 0.5951D0/
      DATA Y(57), Y(58), Y(59), Y(60)
     +    / 0.6314D0, 0.6440D0, 0.6439D0, 0.6326D0/
      DATA Y(61), Y(62), Y(63)
     +    / 0.6392D0, 0.6417D0, 0.6412D0/
      DATA Y(64), Y(65), Y(66), Y(67)
     +    / 0.6530D0, 0.6411D0, 0.6355D0, 0.6344D0/
      DATA Y(68), Y(69), Y(70)
     +    / 0.6623D0, 0.6276D0, 0.6307D0/
      DATA Y(71), Y(72), Y(73), Y(74)
     +    / 0.6354D0, 0.6197D0, 0.6153D0, 0.6340D0/
      DATA Y(75), Y(76), Y(77)
     +    / 0.6338D0, 0.6284D0, 0.6162D0/
      DATA Y(78), Y(79), Y(80), Y(81)
     +    / 0.6252D0, 0.6349D0, 0.6344D0, 0.6361D0/
      DATA Y(82), Y(83), Y(84)
     +    / 0.6373D0, 0.6337D0, 0.6383D0/
!
!     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
!
      CALL IPRINT(IPRT)
!
      DO 10 I=1,N
         X(I) = I
   10 CONTINUE
!
!     PRINT HEADING
!
      WRITE (IPRT,1000)
!
!     PERFORM SIMPLE TEST OF PP
!
      WRITE (IPRT,1100)
      CALL PP(Y, X, N)
      WRITE (IPRT,2000) IERR
!
!     PERFORM SIMPLE TEST OF STAT
!
      WRITE (IPRT,1200)
      CALL STAT(Y, N, LDSTAK)
      WRITE (IPRT,2000) IERR
!
      RETURN
!
!     FORMATS
!
 1000 FORMAT ('1*CH1')
 1100 FORMAT (' SIMPLE TEST OF PP')
 1200 FORMAT ('1SIMPLE TEST OF STAT')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
!IPGMPS
      SUBROUTINE IPGMPS (PER, FREQ, NF, N, LDSTAK, PERI, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
!     THE INTEGRATED PERIODOGRAM OF A SERIES (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N,NF,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),PER(*),PERI(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,ISYM,LDSMIN,LPCV,NALL0,XAXIS,YAXIS
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   LLDS(8)*1,LN(8)*1,LNF(8)*1,NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,IPGDV,IPRINT,LDSCMP,STKCLR,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION FREQ(NF)
!        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
!        INTEGRATED SPECTRUM VALUES ARE STORED.
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     CHARACTER*1 LLDS(8), LN(8), LNF(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER N
!        THE ACTUAL NUMBER OF OBSERVATIONS IN THE SERIES FROM WHICH
!        THE PERIODOGRAM WAS COMPUTED.
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING ALLOCATIONS OF THE STACK AT THE
!        TIME OF THIS CALL.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        COMPUTED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A PAGE PLOT.
!     DOUBLE PRECISION PER(NF)
!        THE INTEGRATED PERIODOGRAM.
!     DOUBLE PRECISION PERI(NF)
!        THE VECTOR IN WHICH THE INTEGRATED PERIODOGRAM IS STORED.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE X AXIS VALUES TO BE PLOTTED ARE STORED.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'I',       'P',       'G',       'M',       'P',       'S'/
      DATA
     + LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     +  LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA
     + LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /'N',' ',' ',' ',' ',' ',' ',' '/
      DATA
     + LNF(1), LNF(2), LNF(3), LNF(4), LNF(5), LNF(6), LNF(7), LNF(8)
     + /'N','F',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
!
      CALL EISGE(NMSUB, LNF, NF, (N+2)/2, 1, HEAD, ERR02, LNF)
!
      IF (ERR01) GO TO 5
!
      IF (NPRT .EQ. 0) THEN
        LDSMIN = 0
      ELSE
        CALL LDSCMP(3, 0, NF+103, 0, 0, 0, 'D', 2*NF+206, LDSMIN)
      END IF
!
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR03, LLDS)
!
      IF (ERR02 .OR. ERR03) GO TO 5
      GO TO 10
!
    5 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   10 CONTINUE
!
!     SET THE SIZE OF THE WORK AREA
!
      CALL STKSET(LDSTAK, 4)
!
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!
      NALL0 = STKST(1)
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      LPCV = NF + 103
!
!     SUBDIVIDE THE STACK.
!
      IF (NPRT .EQ. 0) THEN
         ISYM = 1
         XAXIS = 1
         YAXIS = 1
      ELSE
         ISYM = STKGET(LPCV, 2)
         XAXIS = STKGET(LPCV, 4)
         YAXIS = STKGET(LPCV, 4)
      END IF
!
!     CALL THE MAIN DRIVER FOR COMPUTING (AND PLOTTING) THE INTEGRATED
!     PERIODOGRAM.
!
      CALL IPGDV (PER, NF, N, PERI, FREQ, RSTAK(XAXIS),
     +   RSTAK(YAXIS), ISTAK(ISYM), LPCV, NPRT)
!
      CALL STKCLR(NALL0)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL IPGMPS (PER, FREQ, NF, N, LDSTAK, PERI, NPRT)')
      END
!NRANDC
      SUBROUTINE NRANDC(Y, N, ISEED, YMEAN, SIGMA)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE GENERATES N NORMALLY DISTRIBUTED PSEUDO-
!     RANDOM NUMBERS WITH MEAN YMEAN AND STANDARD DEVIATION SIGMA.  THE
!     NUMBERS GENERATED ARE DETERMINED BY ISEED.  THEY ARE RETURNED IN Y
!
!     ORIGIN - CONCEIVED BY DR. PETER TRYON TO FACILITATE USE OF
!          EXISTING RANDOM NUMBER GENERATOR
!
!     WRITTEN BY -
!          JOHN E. KOONTZ AND JANET R. DONALDSON
!          STATISTICAL ENGINEERING DIVISION
!          NATIONAL BUREAU OF STANDARDS,
!          BOULDER, COLORADO 80302
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SIGMA,YMEAN
      INTEGER
     +   ISEED,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT,ISEEDU
      LOGICAL
     +   ERR01,ERR02,HEAD
!
!  LOCAL ARRAYS
      CHARACTER
     +   LN(8)*1,LONE(8)*1,LSIGMA(8)*1,LZERO(8)*1,NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
!     REAL(TYPE=WP) :: RANDN
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISRNG,ERSGE,IPRINT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!          THE INDEX OF THE COMPUTING LOOP
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THEIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN FOUND.
!     INTEGER IPRT
!        THE STANDARD OUTPUT FILE UNIT NUMBER
!     INTEGER ISEED
!        THE ISEED TO THE RANDOM NUMBER GENERATOR.
!        ISEED MUST LIE BETWEEN 0 AND 2**((MIN(32,I1MACH(8)+1))-1) -1,
!        INCLUSIVE.  IF ISEED IS NOT EQUAL TO 0, ISEED MUST BE ODD.
!     INTEGER ISEEDU
!        THE VALUE OF THE SEED ACTUALLY USED.
!     CHARACTER*1 LN(8), LONE(8), LSIGMA(8), LZERO(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE VARIABLES(S) CHECKED
!        FOR ERRORS
!     INTEGER N
!        THE LENGTH OF DATA SET GENERATED
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THIS SUBROUTINE
!     DOUBLE PRECISION SIGMA
!        THE STANDARD DEVIATION OF THE GENERATED VALUES.
!     DOUBLE PRECISION Y(N)
!        THE GENERATED RANDOM VALUES.
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE GENERATED VALUES.
!
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'N',      'R',      'A',      'N',      'D',      'C'/
      DATA     LN(1),    LN(2),    LN(3),    LN(4),    LN(5),    LN(6),
     +         LN(7),    LN(8)/'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA   LONE(1),  LONE(2),  LONE(3),  LONE(4),  LONE(5),  LONE(6),
     +       LONE(7),  LONE(8)/'O', 'N', 'E', ' ', ' ', ' ', ' ', ' '/
      DATA LSIGMA(1),LSIGMA(2),LSIGMA(3),LSIGMA(4),LSIGMA(5),LSIGMA(6),
     +     LSIGMA(7),LSIGMA(8)/'S', 'I', 'G', 'M', 'A', ' ', ' ', ' '/
      DATA  LZERO(1), LZERO(2), LZERO(3), LZERO(4), LZERO(5), LZERO(6),
     +      LZERO(7), LZERO(8)/'Z', 'E', 'R', 'O', ' ', ' ', ' ', ' '/
!
      IERR = 0
!
      HEAD = .TRUE.
!
!     CHECK FOR INPUT ERRORS
!
      CALL EISGE(NMSUB, LN, N, 1, 2, HEAD, ERR01, LONE)
      CALL ERSGE(NMSUB, LSIGMA, SIGMA, 0.0D0, 2, HEAD, ERR02, LZERO)
      CALL EISRNG(NMSUB, ISEED, ISEEDU, HEAD)
!
      IF (ERR01.OR.ERR02) THEN
!
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
        IERR = 1
!
      ELSE
!
!     GENERATE THE PSEUDO-RANDOM NUMBERS
!
        Y(1) = RANDN(ISEEDU,typ=0.0_wp)
        DO 20 I=1,N
           Y(I) = RANDN(0,typ=0.0_wp)*SIGMA + YMEAN
   20   CONTINUE
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NRANDC (Y, N, ISEED, YMEAN, SIGMA)')
      END
!ACFSDM
      SUBROUTINE ACFSDM (RHO, SDRHO, NC, N, NLPPA)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE STANDARD ERROR OF THE AUTOCORRELATIONS
!     WHEN MISSING DATA ARE INVOLVED.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N,NC
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RHO(*),SDRHO(*)
      INTEGER
     +   NLPPA(*)
!
!  LOCAL SCALARS
      INTEGER
     +   K,KLAST,LAG
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN,DBLE,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER KLAST
!        THE LAST LAG VALUE TO BE USED.
!     INTEGER LAG
!        THE INDEX VARIABLE USED TO INDICATE THE AUTOCORRELATION
!        BEING EXAMINED.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NC
!        THE NUMBER OF AUTOCORRELATIONS COMPUTED
!     INTEGER NLPPA(NC)
!        THE ARRAY IN WHICH THE NUMBER OF OBSERVATIONS USED TO
!        COMPUTE EACH AUTOCORRELATION AND PARTIAL AUTOCORRELATION
!        IS STORED
!     DOUBLE PRECISION RHO(NC)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
!     DOUBLE PRECISION SDRHO(NC)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!        ARE STORED
!
      SDRHO(1) = SQRT(DBLE(NLPPA(1))) * (N-1) / (N * NLPPA(1))
      IF (NC .EQ. 1) RETURN
      DO 20 LAG = 2, NC
         SDRHO(LAG) = 0.0D0
         KLAST = MIN(LAG-1, N-LAG)
         DO 10 K = 1, KLAST
            SDRHO(LAG) = SDRHO(LAG) + (N-LAG-K) * RHO(K) * RHO(K)
   10    CONTINUE
         SDRHO(LAG) = SQRT((N-LAG) + 2.0D0 * SDRHO(LAG)) *
     +      (N-LAG) / (N*NLPPA(LAG))
   20 CONTINUE
      RETURN
      END
!STPOUT
      SUBROUTINE STPOUT(HEAD, N, EXM, NEXMPT, NETA, J, PAR, NPAR, STP,
     +   NFAIL, IFAIL, SCALE, LSCALE, HDR, PAGE, WIDE, ISUBHD, NPRT,
     +   PRTFXD, IFIXD)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS THE RESULTS OF THE STEP SIZE SELECTING
!     SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   EXM
      INTEGER
     +   ISUBHD,J,LSCALE,N,NETA,NEXMPT,NPAR,NPRT
      LOGICAL
     +   HEAD,PAGE,PRTFXD,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),SCALE(LSCALE),STP(NPAR)
      INTEGER
     +   IFAIL(N),IFIXD(NPAR),NFAIL(NPAR)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL HDR
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT,K,NFLABS,NK,NPERL
      LOGICAL
     +   SAMELN
      CHARACTER
     +   BLANK*1,C*1,F*1,PLUS*1
!
!  LOCAL ARRAYS
      INTEGER
     +   INDEX(25)
      CHARACTER
     +   FIXED(3)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL FIXPRT,IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC IABS
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     CHARACTER*1 BLANK
!        THE CHARACTER BLANK.
!     CHARACTER*1 C
!        THE CHARACTER FLAG INDICATING HIGH CURVATURE.
!     DOUBLE PRECISION EXM
!        THE PROPORTION OF OBSERVATIONS ACTUALLY USED FOR WHICH THE
!        COMPUTED NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE
!        EXEMPTED FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     CHARACTER*1 F
!        THE CHARACTER FLAG INDICATING NUMBER OF OBSERVATIONS
!        FAILING SELECTION CRITERIA EXCEEDED EXEMPTED NUMBER.
!     CHARACTER*1 FIXED(3)
!        THE CHARACTERS USED TO LABEL THE PARAMETERS FIXED OR NOT.
!     EXTERNAL HDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IFAIL(N)
!        THE ARRAY OF INDICATOR VARIABLES DESIGNATING WHETHER
!        THE STEP SIZE SELECTED WAS SATISFACTORY FOR A GIVEN
!        OBSERVATION AND PARAMETER.
!     INTEGER INDEX(25)
!        THE ROW NUMBERS OF OBSERVATIONS FOR WHICH THE STEP SIZE
!        SELECTED FAILED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXD(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXD(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NEXMPT
!        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
!        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
!        SIZE STILL BE CONSIDERED OK.
!     INTEGER NFAIL(NPAR)
!        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP
!        SIZE DOES NOT MEET THE CRITERIA.
!     INTEGER NFLABS
!        THE ABSOLUTE VALUE OF NFAIL.
!     INTEGER NK
!        AN INDEX VARIABLE.
!     INTEGER NPERL
!        THE NUMBER OF OBSERVATIONS TO BE PRINTED PER LINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE OUTPUT
!        IS TO BEGIN ON A NEW PAGE.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
!        PARAMETERS ARE STORED.
!     CHARACTER*1 PLUS
!        THE CHARACTER PLUS.
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     LOGICAL SAMELN
!        AN INDICATOR VALUE TO DESIGNATE WHETHER THE LINE IS TO BE
!        PRINTED ON THE SAME LINE AS THE PREVIOUS LINE PRINTED (TRUE)
!        OR NOT (FALSE).
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION STP(NPAR)
!        THE SELECTED STEP SIZE.
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!
      DATA BLANK /' '/, PLUS /'+'/
      CALL IPRINT(IPRT)
!
!     INITIALIZE ARRAY FIXED
!
      DO 10 K=1,3
         FIXED(K) = BLANK
   10 CONTINUE
!
      IF (HEAD) THEN
!
!     PRINT HEADING
!
         HEAD = .FALSE.
!
         CALL HDR(PAGE, WIDE, ISUBHD)
         IF (PRTFXD) THEN
            WRITE (IPRT,1000)
         ELSE
            WRITE (IPRT,1010)
         END IF
!
!     PRINT INFORMATION OTHERWISE SUPPRESSED BY PRINT CONTROL
!
         DO 20 I=1,J-1
            IF (PRTFXD) CALL FIXPRT(IFIXD(I), FIXED)
            IF (IFIXD(I).EQ.0) THEN
               F = BLANK
               C = BLANK
               NFLABS = IABS(NFAIL(I))
               IF (NFLABS.GT.NEXMPT) F = PLUS
               IF (NFAIL(I).LT.0) C = PLUS
               IF (SCALE(1).GT.0.0D0) THEN
                  WRITE (IPRT,1020) I, (FIXED(K),K=1,3), PAR(I),
     +                              SCALE(I),
     +                              STP(I), NFLABS, F, C
               ELSE
                  WRITE (IPRT,1040) I, (FIXED(K),K=1,3), PAR(I),
     +                              STP(I), NFLABS, F, C
               END IF
               IF (NFLABS.GT.NEXMPT) WRITE (IPRT,1030)
            ELSE
               WRITE (IPRT,1045) I, (FIXED(K),K=1,3), PAR(I)
            END IF
   20    CONTINUE
      END IF
!
!     PRINT INFORMATION FOR CURRENT PARAMETER
!
      I = J
      IF (PRTFXD) CALL FIXPRT(IFIXD(I), FIXED)
      IF (IFIXD(I).EQ.0) THEN
         F = BLANK
         C = BLANK
         NFLABS = IABS(NFAIL(I))
         IF (NFLABS.GT.NEXMPT) F = PLUS
         IF (NFAIL(I).LT.0) C = PLUS
         IF (SCALE(1).GT.0.0D0) THEN
            WRITE (IPRT,1020) I, (FIXED(K),K=1,3), PAR(I),
     +                        SCALE(I),
     +                        STP(I), NFLABS, F, C
         ELSE
            WRITE (IPRT,1040) I, (FIXED(K),K=1,3), PAR(I),
     +                        STP(I), NFLABS, F, C
         END IF
         IF (NFLABS.GE.1) THEN
            IF ((NPRT.EQ.0) .AND. (NFLABS.LE.NEXMPT)) THEN
               WRITE (IPRT,1030)
            ELSE
!
!     PRINT ROW NUMBERS
!
               NPERL = 7
!
               SAMELN = .TRUE.
               NK = 0
               DO 60 I=1,N
                  IF (IFAIL(I).EQ.0) GO TO 60
                  NK = NK + 1
                  INDEX(NK) = I
                  IF (NK.LT.NPERL) GO TO 60
                  IF (SAMELN) THEN
                     WRITE (IPRT,1050) (INDEX(K),K=1,NK)
                  ELSE
                     WRITE (IPRT,1060) (INDEX(K),K=1,NK)
                  END IF
                  SAMELN = .FALSE.
                  NK = 0
   60          CONTINUE
               IF (SAMELN) THEN
                  WRITE (IPRT,1050) (INDEX(K),K=1,NK)
               ELSE
                  WRITE (IPRT,1060) (INDEX(K),K=1,NK)
               END IF
            END IF
         END IF
      ELSE
         WRITE (IPRT,1045) I, (FIXED(K),K=1,3), PAR(I)
      END IF
      IF (J.LT.NPAR) RETURN
!
!     PRINT FINAL NOTES AND SUMMARY
!
      WRITE (IPRT,1070)
      IF (NPRT.NE.0) GO TO 100
      DO 90 I=1,NPAR
         IF (IFIXD(I).EQ.0) THEN
            IF (IABS(NFAIL(I)).GT.NEXMPT) GO TO 90
            WRITE (IPRT,1080)
            GO TO 100
         END IF
   90 CONTINUE
!
  100 CONTINUE
!
!     PRINT CONTROL VALUES USED.
!
      WRITE (IPRT,1090) NETA
      WRITE (IPRT,1100) EXM
      WRITE (IPRT,1110) NEXMPT
      WRITE (IPRT,1120) N
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (//50X, 13HSTEP SIZE FOR, 4X, 25HOBSERVATIONS FAILING STEP,
     +   24H SIZE SELECTION CRITERIA/50X, 13HAPPROXIMATING, 21X, 1H*/7X,
     +   24HPARAMETER STARTING VALUE, 6X, 5HSCALE, 10X, 10HDERIVATIVE,
     +   7X, 5HCOUNT, 5X, 5HNOTES, 5X, 10HROW NUMBER/1X, 5HINDEX, 2X,
     +   5HFIXED, 6X, 5H(PAR), 12X, 7H(SCALE), 11X, 5H(STP), 21X, 3HF C/
     +   )
 1010 FORMAT (//50X, 13HSTEP SIZE FOR, 4X, 25HOBSERVATIONS FAILING STEP,
     +   24H SIZE SELECTION CRITERIA/18X, 9HPARAMETER, 23X, 9HAPPROXIMA,
     +   4HTING, 21X, 1H*/16X, 14HSTARTING VALUE, 7X, 5HSCALE, 10X,
     +   10HDERIVATIVE, 7X, 5HCOUNT, 5X, 5HNOTES, 5X, 13HROW NUMBER(S)/
     +   1X, 5HINDEX, 13X, 5H(PAR), 12X, 7H(SCALE), 11X, 5H(STP), 21X,
     +   3HF C/)
 1020 FORMAT (1X, I3, 5X, 3A1, 3G17.8, 5X, I5, 7X, A1, 1X, A1)
 1030 FORMAT ('+', 89X, 2H**)
 1040 FORMAT (1X, I3, 5X, 3A1, G17.8, 7X, 7HDEFAULT, 3X, G17.8, 5X, I5,
     +   7X, A1, 1X, A1)
 1045 FORMAT (1X, I3, 5X, 3A1, G17.8, 9X, '---', 14X, '---',
     +        14X, '-')
 1050 FORMAT ('+', 86X, 7I5)
 1060 FORMAT (87X, 7I5)
 1070 FORMAT (//1X, 36H*  NOTES.  A PLUS (+) IN THE COLUMNS, 8H HEADED ,
     +   33HF OR C HAS THE FOLLOWING MEANING.//4X, 17HF - NUMBER OF OBS,
     +   27HERVATIONS FAILING STEP SIZE, 27H SELECTION CRITERIA EXCEEDS/
     +   8X, 29HNUMBER OF EXEMPTIONS ALLOWED.//4X, 17HC - HIGH CURVATUR,
     +   30HE IN THE MODEL IS SUSPECTED AS, 13H THE CAUSE OF/8X,
     +   19HALL FAILURES NOTED.)
 1080 FORMAT (//46H ** ROW NUMBERS ARE ONLY LISTED WHEN NUMBER OF,
     +   26H OBSERVATIONS FAILING STEP/4X, 25HSIZE SELECTION CRITERIA E,
     +   27HXCEEDS NUMBER OF EXEMPTIONS, 9H ALLOWED.)
 1090 FORMAT (/43H NUMBER OF RELIABLE DIGITS IN MODEL RESULTS, 25X,
     +   6H(NETA), 1X, I5)
 1100 FORMAT (/41H PROPORTION OF OBSERVATIONS EXEMPTED FROM, 8H SELECTI,
     +   11HON CRITERIA, 7X, 7H(EXMPT), 2X, F6.4)
 1110 FORMAT (/37H NUMBER OF OBSERVATIONS EXEMPTED FROM, 11H SELECTION ,
     +   8HCRITERIA, 19X, I5)
 1120 FORMAT (/23H NUMBER OF OBSERVATIONS, 48X, 3H(N), 1X, I5)
      END
!BFSS
      SUBROUTINE BFSS(Y1, Y2, N, NW, LAGS, NF, FMIN, FMAX, NPRT, CSPC2,
     +   ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     BIVARIATE SPECTRUM ANALYSIS (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   ICSPC2,IPHAS,LDSTAK,N,NF,NPRT,NW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CSPC2(*),FREQ(*),PHAS(*),Y1(*),Y2(*)
      INTEGER
     +   LAGS(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,YMISS1,YMISS2
      INTEGER
     +   CCOV,CCOV11,CCOV12,CCOV21,CCOV22,CEVEN,CODD,I,ICCOV,IFP,
     +   INDEX1,INDEX2,INLPPC,IO,IPRT,ISYM,JCCOV,JNLPPC,LAGMAX,
     +   LAGMX1,LDSMIN,LPCV,LW,LWORK,LY,M,NALL0,SPCF1,SPCF2,W,WORK,
     +   XAXIS,YAXIS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12),NLPPC(1,1,1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     INTEGER CCOV, CCOV11, CCOV12, CCOV21, CCOV22
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE COVARIANCES.
!     INTEGER CEVEN
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     INTEGER CODD
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CSPC2(ICSPC2,NW)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC(1,1,1)
!        A DUMMY ARRAY.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT = 1 THE PLOT IS PROVIDED.
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION PHAS(IPHAS,NW)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SPCF1, SPCF2
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     INTEGER W
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE WINDOWS.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR THE VECTOR WORK.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YMISS1, YMISS2
!        DUMMY VARIABLES.
!     DOUBLE PRECISION Y1(N)
!        THE FIRST TIME SERIES.
!     DOUBLE PRECISION Y2(N)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','S',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(4) = .TRUE.
!
!     SET MAXIMUM LAG VALUE TO BE USED (LAGMAX).
!
      IF (NW.GE.1) THEN
         LAGMAX = LAGS(1)
         DO 10 I=1,NW
            LAGMAX = MAX(LAGMAX,LAGS(I))
   10    CONTINUE
      ELSE
         LAGMAX = N - 1
      END IF
      LAGMX1 = LAGMAX + 1
!
      ICCOV = LAGMAX + 1
      JCCOV = 2
      INLPPC = 1
      JNLPPC = 1
      M = 2
      INDEX1 = 1
      INDEX2 = 2
!
!     COMPUTE THE MINIMUM ALLOWABLE STACK AREA (LDSMIN)
!
      IO = 1
      IF (NPRT.EQ.0) IO = 0
!
      CALL LDSCMP(9, 0, IO*4*NF, 0, 0, 0, 'D',
     +            7*LAGMAX+7+IO*8*NF, LDSMIN)
!
      LY = N
      YMISS1 = 1.0D0
      YMISS2 = 1.0D0
      LPCV = 4*NF
      LW = LAGMAX + 1
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING STACK ALLOCATIONS (NALL0).
!     SET THE STACK ALLOCATION TYPE (IFP)
!
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
!
      IFP = 4
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS
!
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         CCOV = 1
         CEVEN = 1
         CODD = 1
         SPCF1 = 1
         SPCF2 = 1
         W = 1
!
         CCOV11 = 1
         CCOV21 = 1
         CCOV12 = 1
         CCOV22 = 1
!
         ISYM = 1
         XAXIS = 1
         YAXIS = 1
      ELSE
         CCOV = STKGET(4*LAGMX1,IFP)
         CEVEN = STKGET(LAGMX1,IFP)
         CODD = STKGET(LAGMX1,IFP)
         SPCF1 = STKGET(NF,IFP)
         SPCF2 = STKGET(NF,IFP)
         W = STKGET(LW,IFP)
!
         CCOV11 = CCOV
         CCOV21 = CCOV + LAGMX1
         CCOV12 = CCOV21 + LAGMX1
         CCOV22 = CCOV12 + LAGMX1
!
         IF (NPRT.EQ.0) THEN
            ISYM = W
            XAXIS = W
            YAXIS = W
         ELSE
            ISYM = STKGET(LPCV,2)
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
        END IF
      END IF
!
      WORK = W
      LWORK = LW
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
      CALL BFSDRV(Y1, Y2, YMISS1, YMISS2, RSTAK(CCOV), NLPPC,
     +   RSTAK(SPCF1), RSTAK(SPCF2), NF, FMIN, FMAX, FREQ, N, NW,
     +   LAGMAX, LAGS, LAGMX1, RSTAK(WORK), LWORK, DELTA, ISTAK(ISYM),
     +   RSTAK(XAXIS), RSTAK(YAXIS), LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS,
     +   RSTAK(CODD), RSTAK(CEVEN), RSTAK(W), LW, NMSUB, LDSMIN,
     +   LDSTAK, OPTION, N, INLPPC, JNLPPC, LY)
!
      CALL STKCLR(NALL0)
!
!     CHECK FOR ERRORS
!
      IF (IERR.EQ.0) RETURN
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL BFSS (Y1, Y2, N,'/
     +   '      +           NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +   '      +           CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)')
      END
!FFT
      SUBROUTINE FFT(A, B, NTOT, N, NSPAN, ISN)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  MULTIVARIATE COMPLEX FOURIER TRANSFORM, COMPUTED IN PLACE
!    USING MIXED-RADIX FAST FOURIER TRANSFORM ALGORITHM.
!  BY R. C. SINGLETON, STANFORD RESEARCH INSTITUTE, OCT. 1968
!  ARRAYS A AND B ORIGINALLY HOLD THE DOUBLE PRECISION AND IMAGINARY
!    COMPONENTS OF THE DATA, AND RETURN THE DOUBLE PRECISION AND
!    IMAGINARY COMPONENTS OF THE RESULTING FOURIER COEFFICIENTS.
!  MULTIVARIATE DATA IS INDEXED ACCORDING TO THE FORTRAN
!    ARRAY ELEMENT SUCCESSOR FUNCTION, WITHOUT LIMIT
!    ON THE NUMBER OF IMPLIED MULTIPLE SUBSCRIPTS.
!    THE SUBROUTINE IS CALLED ONCE FOR EACH VARIATE.
!    THE CALLS FOR A MULTIVARIATE TRANSFORM MAY BE IN ANY ORDER.
!  NTOT IS THE TOTAL NUMBER OF COMPLEX DATA VALUES.
!  N IS THE DIMENSION OF THE CURRENT VARIABLE.
!  NSPAN/N IS THE SPACING OF CONSECUTIVE DATA VALUES
!    WHILE INDEXING THE CURRENT VARIABLE.
!  THE SIGN OF ISN DETERMINES THE SIGN OF THE COMPLEX
!    EXPONENTIAL, AND THE MAGNITUDE OF ISN IS NORMALLY ONE.
!  A TRI-VARIATE TRANSFORM WITH A(N1,N2,N3), B(N1,N2,N3)
!    IS COMPUTED BY
!      CALL FFT(A,B,N1*N2*N3,N1,N1,1)
!      CALL FFT(A,B,N1*N2*N3,N2,N1*N2,1)
!      CALL FFT(A,B,N1*N2*N3,N3,N1*N2*N3,1)
!  FOR A SINGLE-VARIATE TRANSFORM,
!    NTOT = N = NSPAN = (NUMBER OF COMPLEX DATA VALUES), F.G.
!      CALL FFT(A,B,N,N,N,1)
!  THE DATA MAY ALTERNATIVELY BE STORED IN A SINGLE COMPLEX
!    ARRAY A, THEN THE MAGNITUDE OF ISN CHANGED TO TWO TO
!    GIVE THE CORRECT INDEXING INCREMENT AND A(2) USED TO
!    PASS THE INITIAL ADDRESS FOR THE SEQUENCE OF IMAGINARY
!    VALUES, E.G.
!      CALL FFT(A,A(2),NTOT,N,NSPAN,2)
!  ARRAYS AT(MAXF), CK(MAXF), BT(MAXF), SK(MAXF), AND NP(MAXP)
!    ARE USED FOR TEMPORARY STORAGE.  IF THE AVAILABEL STORAGE
!    IS INSUFFICIENT, THE PROGRAM IS TERMINATED BY A STOP.
!    MAXF MUST BE .GE. THE MAXIMUM PRIME FACTOR OF N.
!    MAXP MUST BE .GT. THE NUMBER OF PRIME FACTORS OF N.
!
!     NB. THE ABOVE DESCRIPTION OF MAXP APPEARS TO BE INCORRECT.
!         MAXP SEEMS TO BE THE MAXIMUM SIZE OF THE SQUARE FREE
!         PORTION K OF N.
!
!    IN ADDITION, IF THE SQUARE-FREE PORTION K OF N HAS TWO OR
!    MORE PRIME FACTORS, THEN MAXP MUST BE .GE. K-1.
!     DIMENSION A(1), B(1)
!  ARRAY STORAGE IN NFAC FOR A MAXIMUM OF 11 FACTORS OF N.
!  IF N HAS MORE THAN ONE SQUARE-FREE FACTOR, THE PRODUCT OF THE
!    SQUARE-FREE FACTORS MUST BE .LE. 210
!     DIMENSION NFAC(11), NP(209)
!  ARRAY STORAGE FOR MAXIMUM PRIME FACTOR OF 23
!     DIMENSION AT(23), CK(23), BT(23), SK(23)
!
!
!  VARIABLE DECLARATIONS
!
!  PARAMETERS
      INTEGER
     +   MAXF1
      PARAMETER (MAXF1=23)
      INTEGER
     +   MAXP1
      PARAMETER (MAXP1=209)
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ISN,N,NSPAN,NTOT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   A(*),B(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   AA,AJ,AJM,AJP,AK,AKM,AKP,BB,BJ,BJM,BJP,BK,BKM,BKP,C1,C2,C3,
     +   C72,CD,RAD,RADF,S1,S120,S2,S3,S72,SD
      INTEGER
     +   I,II,INC,IPRT,J,JC,JF,JJ,K,K1,K2,K3,K4,KK,KS,KSPAN,KSPNN,
     +   KT,M,MAXF,MAXP,NN,NT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AT(MAXF1),BT(MAXF1),CK(MAXF1),SK(MAXF1)
      INTEGER
     +   NFAC(11),NP(MAXP1)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ATAN,COS,MOD,SIN,SQRT
!
!  EQUIVALENCES
      EQUIVALENCE (I,II)
!
!  THE FOLLOWING TWO CONSTANTS SHOULD AGREE WITH THE ARRAY DIMENSIONS.
      MAXF = MAXF1
      MAXP = MAXP1
      IF (N.LT.2) RETURN
!
!  INITIALIZE VARIABLES
!
      C1 = 0
      C2 = 0
      C3 = 0
      S1 = 0
      S2 = 0
      S3 = 0
      K1 = 0
      K2 = 0
      K3 = 0
      K4 = 0
!
      INC = ISN
      RAD = 8.0D0*ATAN(1.0D0)
      S72 = RAD/5.0D0
      C72 = COS(S72)
      S72 = SIN(S72)
      S120 = SQRT(0.75D0)
      IF (ISN.GE.0) GO TO 10
      S72 = -S72
      S120 = -S120
      RAD = -RAD
      INC = -INC
   10 NT = INC*NTOT
      KS = INC*NSPAN
      KSPAN = KS
      NN = NT - INC
      JC = KS/N
      RADF = RAD*JC*0.5D0
      I = 0
      JF = 0
!  DETERMINE THE FACTORS OF N
      M = 0
      K = N
      GO TO 30
   20 M = M + 1
      NFAC(M) = 4
      K = K/16
   30 IF (K-(K/16)*16.EQ.0) GO TO 20
      J = 3
      JJ = 9
      GO TO 50
   40 M = M + 1
      NFAC(M) = J
      K = K/JJ
   50 IF (MOD(K,JJ).EQ.0) GO TO 40
      J = J + 2
      JJ = J**2
      IF (JJ.LE.K) GO TO 50
      IF (K.GT.4) GO TO 60
      KT = M
      NFAC(M+1) = K
      IF (K.NE.1) M = M + 1
      GO TO 100
   60 IF (K-(K/4)*4.NE.0) GO TO 70
      M = M + 1
      NFAC(M) = 2
      K = K/4
   70 KT = M
      J = 2
   80 IF (MOD(K,J).NE.0) GO TO 90
      M = M + 1
      NFAC(M) = J
      K = K/J
   90 J = ((J+1)/2)*2 + 1
      IF (J.LE.K) GO TO 80
  100 IF (KT.EQ.0) GO TO 120
      J = KT
  110 M = M + 1
      NFAC(M) = NFAC(J)
      J = J - 1
      IF (J.NE.0) GO TO 110
!  COMPUTE FOURIER TRANSFORM
  120 SD = RADF/KSPAN
      CD = 2.0D0*SIN(SD)**2
      SD = SIN(SD+SD)
      KK = 1
      I = I + 1
      IF (NFAC(I).NE.2) GO TO 170
!  TRANSFORM FOR FACTOR OF 2 (INCLUDING ROTATION FACTOR)
      KSPAN = KSPAN/2
      K1 = KSPAN + 2
  130 K2 = KK + KSPAN
      AK = A(K2)
      BK = B(K2)
      A(K2) = A(KK) - AK
      B(K2) = B(KK) - BK
      A(KK) = A(KK) + AK
      B(KK) = B(KK) + BK
      KK = K2 + KSPAN
      IF (KK.LE.NN) GO TO 130
      KK = KK - NN
      IF (KK.LE.JC) GO TO 130
      IF (KK.GT.KSPAN) GO TO 360
  140 C1 = 1.0D0 - CD
      S1 = SD
  150 K2 = KK + KSPAN
      AK = A(KK) - A(K2)
      BK = B(KK) - B(K2)
      A(KK) = A(KK) + A(K2)
      B(KK) = B(KK) + B(K2)
      A(K2) = C1*AK - S1*BK
      B(K2) = S1*AK + C1*BK
      KK = K2 + KSPAN
      IF (KK.LT.NT) GO TO 150
      K2 = KK - NT
      C1 = -C1
      KK = K1 - K2
      IF (KK.GT.K2) GO TO 150
      AK = C1 - (CD*C1+SD*S1)
      S1 = (SD*C1-CD*S1) + S1
!  THE FOLLOWING THREE STATEMENTS COMPENSATE FOR TRUNCATION ERROR
      C1 = 0.5D0/(AK**2+S1**2) + 0.5D0
      S1 = C1*S1
      C1 = C1*AK
      KK = KK + JC
      IF (KK.LT.K2) GO TO 150
      K1 = K1 + INC + INC
      KK = (K1-KSPAN)/2 + JC
      IF (KK.LE.JC+JC) GO TO 140
      GO TO 120
!  TRANSFORM FOR FACTOR OF 3 (OPTIONAL CODE)
  160 K1 = KK + KSPAN
      K2 = K1 + KSPAN
      AK = A(KK)
      BK = B(KK)
      AJ = A(K1) + A(K2)
      BJ = B(K1) + B(K2)
      A(KK) = AK + AJ
      B(KK) = BK + BJ
      AK = -0.5D0*AJ + AK
      BK = -0.5D0*BJ + BK
      AJ = (A(K1)-A(K2))*S120
      BJ = (B(K1)-B(K2))*S120
      A(K1) = AK - BJ
      B(K1) = BK + AJ
      A(K2) = AK + BJ
      B(K2) = BK - AJ
      KK = K2 + KSPAN
      IF (KK.LT.NN) GO TO 160
      KK = KK - NN
      IF (KK.LE.KSPAN) GO TO 160
      GO TO 320
!  TRANSFORM FOR FACTOR OF 4
  170 IF (NFAC(I).NE.4) GO TO 260
      KSPNN = KSPAN
      KSPAN = KSPAN/4
  180 C1 = 1.0D0
      S1 = 0
  190 K1 = KK + KSPAN
      K2 = K1 + KSPAN
      K3 = K2 + KSPAN
      AKP = A(KK) + A(K2)
      AKM = A(KK) - A(K2)
      AJP = A(K1) + A(K3)
      AJM = A(K1) - A(K3)
      A(KK) = AKP + AJP
      AJP = AKP - AJP
      BKP = B(KK) + B(K2)
      BKM = B(KK) - B(K2)
      BJP = B(K1) + B(K3)
      BJM = B(K1) - B(K3)
      B(KK) = BKP + BJP
      BJP = BKP - BJP
      IF (ISN.LT.0) GO TO 220
      AKP = AKM - BJM
      AKM = AKM + BJM
      BKP = BKM + AJM
      BKM = BKM - AJM
      IF (S1.EQ.0.0D0) GO TO 230
  200 A(K1) = AKP*C1 - BKP*S1
      B(K1) = AKP*S1 + BKP*C1
      A(K2) = AJP*C2 - BJP*S2
      B(K2) = AJP*S2 + BJP*C2
      A(K3) = AKM*C3 - BKM*S3
      B(K3) = AKM*S3 + BKM*C3
      KK = K3 + KSPAN
      IF (KK.LE.NT) GO TO 190
  210 C2 = C1 - (CD*C1+SD*S1)
      S1 = (SD*C1-CD*S1) + S1
      C1 = 0.5D0/(C2**2+S1**2) + 0.5D0
      S1 = C1*S1
      C1 = C1*C2
      C2 = C1**2 - S1**2
      S2 = 2.0D0*C1*S1
      C3 = C2*C1 - S2*S1
      S3 = C2*S1 + S2*C1
      KK = KK - NT + JC
      IF (KK.LE.KSPAN) GO TO 190
      KK = KK - KSPAN + INC
      IF (KK.LE.JC) GO TO 180
      IF (KSPAN.EQ.JC) GO TO 360
      GO TO 120
  220 AKP = AKM + BJM
      AKM = AKM - BJM
      BKP = BKM - AJM
      BKM = BKM + AJM
      IF (S1.NE.0.0D0) GO TO 200
  230 A(K1) = AKP
      B(K1) = BKP
      A(K2) = AJP
      B(K2) = BJP
      A(K3) = AKM
      B(K3) = BKM
      KK = K3 + KSPAN
      IF (KK.LE.NT) GO TO 190
      GO TO 210
!  TRANSFORM FOR FACTOR OF 5 (OPTIONAL CODE)
  240 C2 = C72**2 - S72**2
      S2 = 2.0D0*C72*S72
  250 K1 = KK + KSPAN
      K2 = K1 + KSPAN
      K3 = K2 + KSPAN
      K4 = K3 + KSPAN
      AKP = A(K1) + A(K4)
      AKM = A(K1) - A(K4)
      BKP = B(K1) + B(K4)
      BKM = B(K1) - B(K4)
      AJP = A(K2) + A(K3)
      AJM = A(K2) - A(K3)
      BJP = B(K2) + B(K3)
      BJM = B(K2) - B(K3)
      AA = A(KK)
      BB = B(KK)
      A(KK) = AA + AKP + AJP
      B(KK) = BB + BKP + BJP
      AK = AKP*C72 + AJP*C2 + AA
      BK = BKP*C72 + BJP*C2 + BB
      AJ = AKM*S72 + AJM*S2
      BJ = BKM*S72 + BJM*S2
      A(K1) = AK - BJ
      A(K4) = AK + BJ
      B(K1) = BK + AJ
      B(K4) = BK - AJ
      AK = AKP*C2 + AJP*C72 + AA
      BK = BKP*C2 + BJP*C72 + BB
      AJ = AKM*S2 - AJM*S72
      BJ = BKM*S2 - BJM*S72
      A(K2) = AK - BJ
      A(K3) = AK + BJ
      B(K2) = BK + AJ
      B(K3) = BK - AJ
      KK = K4 + KSPAN
      IF (KK.LT.NN) GO TO 250
      KK = KK - NN
      IF (KK.LE.KSPAN) GO TO 250
      GO TO 320
!  TRANSFORM FOR ODD FACTORS
  260 K = NFAC(I)
      KSPNN = KSPAN
      KSPAN = KSPAN/K
      IF (K.EQ.3) GO TO 160
      IF (K.EQ.5) GO TO 240
      IF (K.EQ.JF) GO TO 280
      JF = K
      S1 = RAD/K
      C1 = COS(S1)
      S1 = SIN(S1)
      IF (JF.GT.MAXF) GO TO 590
      CK(JF) = 1.0D0
      SK(JF) = 0.0D0
      J = 1
  270 CK(J) = CK(K)*C1 + SK(K)*S1
      SK(J) = CK(K)*S1 - SK(K)*C1
      K = K - 1
      CK(K) = CK(J)
      SK(K) = -SK(J)
      J = J + 1
      IF (J.LT.K) GO TO 270
  280 K1 = KK
      K2 = KK + KSPNN
      AA = A(KK)
      BB = B(KK)
      AK = AA
      BK = BB
      J = 1
      K1 = K1 + KSPAN
  290 K2 = K2 - KSPAN
      J = J + 1
      AT(J) = A(K1) + A(K2)
      AK = AT(J) + AK
      BT(J) = B(K1) + B(K2)
      BK = BT(J) + BK
      J = J + 1
      AT(J) = A(K1) - A(K2)
      BT(J) = B(K1) - B(K2)
      K1 = K1 + KSPAN
      IF (K1.LT.K2) GO TO 290
      A(KK) = AK
      B(KK) = BK
      K1 = KK
      K2 = KK + KSPNN
      J = 1
  300 K1 = K1 + KSPAN
      K2 = K2 - KSPAN
      JJ = J
      AK = AA
      BK = BB
      AJ = 0.0D0
      BJ = 0.0D0
      K = 1
  310 K = K + 1
      AK = AT(K)*CK(JJ) + AK
      BK = BT(K)*CK(JJ) + BK
      K = K + 1
      AJ = AT(K)*SK(JJ) + AJ
      BJ = BT(K)*SK(JJ) + BJ
      JJ = JJ + J
      IF (JJ.GT.JF) JJ = JJ - JF
      IF (K.LT.JF) GO TO 310
      K = JF - J
      A(K1) = AK - BJ
      B(K1) = BK + AJ
      A(K2) = AK + BJ
      B(K2) = BK - AJ
      J = J + 1
      IF (J.LT.K) GO TO 300
      KK = KK + KSPNN
      IF (KK.LE.NN) GO TO 280
      KK = KK - NN
      IF (KK.LE.KSPAN) GO TO 280
!  MULTIPLY BY ROTATION FACTOR (EXCEPT FOR FACTORS OF 2 AND 4)
  320 IF (I.EQ.M) GO TO 360
      KK = JC + 1
  330 C2 = 1.0D0 - CD
      S1 = SD
  340 C1 = C2
      S2 = S1
      KK = KK + KSPAN
  350 AK = A(KK)
      A(KK) = C2*AK - S2*B(KK)
      B(KK) = S2*AK + C2*B(KK)
      KK = KK + KSPNN
      IF (KK.LE.NT) GO TO 350
      AK = S1*S2
      S2 = S1*C2 + C1*S2
      C2 = C1*C2 - AK
      KK = KK - NT + KSPAN
      IF (KK.LE.KSPNN) GO TO 350
      C2 = C1 - (CD*C1+SD*S1)
      S1 = S1 + (SD*C1-CD*S1)
      C1 = 0.5D0/(C2**2+S1**2) + 0.5D0
      S1 = C1*S1
      C2 = C1*C2
      KK = KK - KSPNN + JC
      IF (KK.LE.KSPAN) GO TO 340
      KK = KK - KSPAN + JC + INC
      IF (KK.LE.JC+JC) GO TO 330
      GO TO 120
!  PERMUTE THE RESULTS TO NORMAL ORDER--- DONE IN TWO STAGES
!  PERMUTATION FOR SQUARE FACTORS OF N
  360 NP(1) = KS
      IF (KT.EQ.0) GO TO 450
      K = KT + KT + 1
      IF (M.LT.K) K = K - 1
      J = 1
      NP(K+1) = JC
  370 NP(J+1) = NP(J)/NFAC(J)
      NP(K) = NP(K+1)*NFAC(J)
      J = J + 1
      K = K - 1
      IF (J.LT.K) GO TO 370
      K3 = NP(K+1)
      KSPAN = NP(2)
      KK = JC + 1
      K2 = KSPAN + 1
      J = 1
      IF (N.NE.NTOT) GO TO 410
!  PERMUTATION FOR SINGLE-VARIATE TRANSFORM (OPTIONAL CODE)
  380 AK = A(KK)
      A(KK) = A(K2)
      A(K2) = AK
      BK = B(KK)
      B(KK) = B(K2)
      B(K2) = BK
      KK = KK + INC
      K2 = KSPAN + K2
      IF (K2.LT.KS) GO TO 380
  390 K2 = K2 - NP(J)
      J = J + 1
      K2 = NP(J+1) + K2
      IF (K2.GT.NP(J)) GO TO 390
      J = 1
  400 IF (KK.LT.K2) GO TO 380
      KK = KK + INC
      K2 = KSPAN + K2
      IF (K2.LT.KS) GO TO 400
      IF (KK.LT.KS) GO TO 390
      JC = K3
      GO TO 450
!  PERMUTATION FOR MULTIVARIATE TRANSFORM
  410 K = KK + JC
  420 AK = A(KK)
      A(KK) = A(K2)
      A(K2) = AK
      BK = B(KK)
      B(KK) = B(K2)
      B(K2) = BK
      KK = KK + INC
      K2 = K2 + INC
      IF (KK.LT.K) GO TO 420
      KK = KK + KS - JC
      K2 = K2 + KS - JC
      IF (KK.LT.NT) GO TO 410
      K2 = K2 - NT + KSPAN
      KK = KK - NT + JC
      IF (K2.LT.KS) GO TO 410
  430 K2 = K2 - NP(J)
      J = J + 1
      K2 = NP(J+1) + K2
      IF (K2.GT.NP(J)) GO TO 430
      J = 1
  440 IF (KK.LT.K2) GO TO 410
      KK = KK + JC
      K2 = KSPAN + K2
      IF (K2.LT.KS) GO TO 440
      IF (KK.LT.KS) GO TO 430
      JC = K3
  450 IF (2*KT+1.GE.M) RETURN
      KSPNN = NP(KT+1)
!  PERMUTATION FOR SQUARE-FREE FACTORS OF N
      J = M - KT
      NFAC(J+1) = 1
  460 NFAC(J) = NFAC(J)*NFAC(J+1)
      J = J - 1
      IF (J.NE.KT) GO TO 460
      KT = KT + 1
      NN = NFAC(KT) - 1
      IF (NN.GT.MAXP) GO TO 590
      JJ = 0
      J = 0
      GO TO 490
  470 JJ = JJ - K2
      K2 = KK
      K = K + 1
      KK = NFAC(K)
  480 JJ = KK + JJ
      IF (JJ.GE.K2) GO TO 470
      NP(J) = JJ
  490 K2 = NFAC(KT)
      K = KT + 1
      KK = NFAC(K)
      J = J + 1
      IF (J.LE.NN) GO TO 480
!  DETERMINE THE PERMUTATION CYCLES OF LENGTH GREATER THAN 1
      J = 0
      GO TO 510
  500 K = KK
      KK = NP(K)
      NP(K) = -KK
      IF (KK.NE.J) GO TO 500
      K3 = KK
  510 J = J + 1
      KK = NP(J)
      IF (KK.LT.0) GO TO 510
      IF (KK.NE.J) GO TO 500
      NP(J) = -J
      IF (J.NE.NN) GO TO 510
      MAXF = INC*MAXF
!  REORDER A AND B, FOLLOWING THE PERMUTATION CYCLES
      GO TO 580
  520 J = J - 1
      IF (NP(J).LT.0) GO TO 520
      JJ = JC
  530 KSPAN = JJ
      IF (JJ.GT.MAXF) KSPAN = MAXF
      JJ = JJ - KSPAN
      K = NP(J)
      KK = JC*K + II + JJ
      K1 = KK + KSPAN
      K2 = 0
  540 K2 = K2 + 1
      AT(K2) = A(K1)
      BT(K2) = B(K1)
      K1 = K1 - INC
      IF (K1.NE.KK) GO TO 540
  550 K1 = KK + KSPAN
      K2 = K1 - JC*(K+NP(K))
      K = -NP(K)
  560 A(K1) = A(K2)
      B(K1) = B(K2)
      K1 = K1 - INC
      K2 = K2 - INC
      IF (K1.NE.KK) GO TO 560
      KK = K2
      IF (K.NE.J) GO TO 550
      K1 = KK + KSPAN
      K2 = 0
  570 K2 = K2 + 1
      A(K1) = AT(K2)
      B(K1) = BT(K2)
      K1 = K1 - INC
      IF (K1.NE.KK) GO TO 570
      IF (JJ.NE.0) GO TO 530
      IF (J.NE.1) GO TO 520
  580 J = K3 + 1
      NT = NT - KSPNN
      II = NT - INC + 1
      IF (NT.GE.0) GO TO 520
      RETURN
!  ERROR FINISH, INSUFFICIENT ARRAY STORAGE
  590 ISN = 0
      CALL IPRINT(IPRT)
      WRITE(IPRT, 1000)
!
!     NB.  THE FOLLOWING STOP SHOULD BE CHANGED TO A RETURN WHEN
!          THE TIME SERIES ROUTINES ARE MODIFIED FOR STARPAC.
!
      STOP
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (' ', 17('*')/18H * ERROR MESSAGE */1X, 17('*')//
     +   45H ARRAY BOUNDS EXCEEDED WITHIN SUBROUTINE FFT./
     +   44H PLEASE BRING THIS ERROR TO THE ATTENTION OF/
     +   22H    JANET R. DONALDSON/
     +   16H    303-497-5114/
     +   16H    FTS 320-5114)
      END
!DCKER
      SUBROUTINE DCKER(NMSUB, N, M, IXM, NPAR, LDSTAK, SCALE, LSCALE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE ERROR CHECKING ROUTINE FOR DERIVATIVE CHECKING
!     ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,LSCALE,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   SCALE(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   I,LDSMIN,NV
      LOGICAL
     +   HEAD
!
!  LOCAL ARRAYS
      LOGICAL
     +   ERROR(10)
      CHARACTER
     +   LIXM(8)*1,LLDS(8)*1,LM(8)*1,LN(8)*1,LNPAR(8)*1,
     +   LSCL(8)*1,LZERO(8)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISLE,ERVGT,LDSCMP
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR(10)
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LIXM(8), LLDS(8), LM(8), LN(8), LNPAR(8), LSCL(8),
!    *   LZERO(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND BY THE SCALE CHECKING ROUTINE.
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!
!     SET UP NAME ARRAYS
!
      DATA LIXM(1), LIXM(2), LIXM(3), LIXM(4), LIXM(5), LIXM(6),
     +   LIXM(7), LIXM(8) /'I','X','M',' ',' ',' ',' ',' '/
      DATA LM(1), LM(2), LM(3), LM(4), LM(5), LM(6), LM(7), LM(8) /'M',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5),
     +   LLDS(6), LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',
     +   ' '/
      DATA LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8) /'N',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LNPAR(1), LNPAR(2), LNPAR(3), LNPAR(4), LNPAR(5),
     +   LNPAR(6), LNPAR(7), LNPAR(8) /'N','P',' ',' ',' ',' ',' ',
     +   ' '/
      DATA LSCL(1), LSCL(2), LSCL(3), LSCL(4), LSCL(5),
     +   LSCL(6), LSCL(7), LSCL(8) /'S','C','A','L','E',' ',' ',
     +   ' '/
      DATA LZERO(1), LZERO(2), LZERO(3), LZERO(4), LZERO(5),
     +   LZERO(6), LZERO(7), LZERO(8) /'Z','E','R','O',' ',' ',' ',' '/
!
!     ERROR CHECKING
!
      DO 10 I=1,10
         ERROR(I) = .FALSE.
   10 CONTINUE
!
      IERR = 0
      HEAD = .TRUE.
!
      CALL EISGE(NMSUB, LN, N, 1, 1, HEAD, ERROR(1), LN)
!
      CALL EISGE(NMSUB, LM, M, 1, 1, HEAD, ERROR(2), LM)
!
      CALL EISGE(NMSUB, LIXM, IXM, N, 3, HEAD, ERROR(3), LN)
!
      CALL EISLE(NMSUB, LNPAR, NPAR, N, 2, HEAD, ERROR(4), LN)
!
      CALL LDSCMP(5, 0, 2*NPAR+1, 0, 0, 0, 'D',
     +            N*NPAR + NPAR + N, LDSMIN)
!
      IF ((.NOT.ERROR(1)) .AND. (.NOT.ERROR(4)))
     +   CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR(5),
     +   LLDS)
!
      CALL ERVGT(NMSUB, LSCL, SCALE, LSCALE, 0.0D0, 0, HEAD, 6, NV,
     +   ERROR(9), LZERO)
!
      DO 20 I=1,10
         IF (ERROR(I)) GO TO 30
   20 CONTINUE
      RETURN
!
   30 CONTINUE
      IERR = 1
      RETURN
!
      END
!OBSSUM
      SUBROUTINE OBSSUM(N, M, XM, Y, PV, SDPV, RES, SDRES, WT, IXM,
     +   WEIGHT, K, IFIRST, ILAST, JCOL1, JCOLM)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBOUTINE LISTS THE DATA SUMMARY FOR THE
!     LEAST SQUARES SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29,  1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IFIRST,ILAST,IXM,JCOL1,JCOLM,K,M,N
      LOGICAL
     +   WEIGHT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PV(N),RES(N),SDPV(N),SDRES(N),WT(N),XM(IXM,M),Y(N)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,IPRT,J
      CHARACTER
     +   STRING*20,FMT1*160,FMT2*160,FMT3*160
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      LOGICAL
     +   MVCHK
      EXTERNAL D1MACH,MVCHK
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     CHARACTER*160 FMT1,FMT2,FMT3
!        THE FORMATS USED TO PRINT THE INFORMATION.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS HAVE
!        BEEN DETECTED.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED.
!     INTEGER IFIRST, ILAST
!        THE FIRST AND LAST INDICES TO BE LISTED.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER JCOLM
!        THE LAST COLUMN OF THE INDEPENDENT VARIABLE TO BE PRINTED.
!     INTEGER JCOL1
!        THE FIRST COLUMN OF THE INDEPENDENT VARIABLE TO BE PRINTED.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     CHARACTER*20 STRING
!        CHARACTER STRING USED TO BUILD THE FORMATS.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(N)
!        THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
      FPLM = D1MACH(2)
!
      CALL IPRINT(IPRT)
!
!     CONSTRUCT FORMAT
!
      IF (K.EQ.1) THEN
         STRING = '1X,I4,15X,G15.8,15X,'
      ELSE IF (K.EQ.2) THEN
         STRING = '1X,I4,7X,2G15.8,8X, '
      ELSE
         STRING = '1X,I4,3G15.8,       '
      END IF
      WRITE (FMT1,1020) STRING
      WRITE (FMT2,1030) STRING
      WRITE (FMT3,1040) STRING
!
      DO 140 I=IFIRST, ILAST
         IF (MVCHK(SDPV(I),FPLM)) THEN
            IF (WEIGHT) THEN
               WRITE (IPRT, FMT1) I, (XM(I,J),J=JCOL1,JCOLM),
     +                            Y(I), PV(I), RES(I), WT(I)
            ELSE
               WRITE (IPRT, FMT1) I, (XM(I,J),J=JCOL1,JCOLM),
     +                            Y(I), PV(I), RES(I)
            END IF
         ELSE
            IF (MVCHK(SDRES(I),FPLM)) THEN
               IF (WEIGHT) THEN
                  WRITE (IPRT, FMT2) I, (XM(I,J),J=JCOL1,JCOLM),
     +                               Y(I), PV(I), SDPV(I), RES(I), WT(I)
               ELSE
                  WRITE (IPRT, FMT2) I, (XM(I,J),J=JCOL1,JCOLM),
     +                               Y(I), PV(I), SDPV(I), RES(I)
               END IF
            ELSE
               IF (WEIGHT) THEN
                  WRITE (IPRT, FMT3) I, (XM(I,J),J=JCOL1,JCOLM),
     +                               Y(I), PV(I), SDPV(I), RES(I),
     +                               SDRES(I), WT(I)
               ELSE
                  WRITE (IPRT, FMT3) I, (XM(I,J),J=JCOL1,JCOLM),
     +                               Y(I), PV(I), SDPV(I), RES(I),
     +                               SDRES(I)
               END IF
            END IF
         END IF
  140 CONTINUE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1020 FORMAT ('(',A20,'2G16.8,8X,4HNC *,4X,G16.8,4X,4HNC *,1X,E9.3)')
 1030 FORMAT ('(',A20,'4G16.8,4X,4HNC *,1X,E9.3)')
 1040 FORMAT ('(',A20,'4G16.8,1X,F7.2,1X,E9.3)')
      END
!UFSF
      SUBROUTINE UFSF(YFFT, N, LYFFT, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS USING THE FFT (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,LYFFT,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YFFT(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS
      INTEGER
     +   IFP,IPRT,ISPCF,LACOV,LAGMAX,LDSMIN,LNLPPA,LPCV,LWORK,
     +   NALL0,NF,NFFT,NPRT,NW,WORK
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),FREQ(101),RSTAK(12),SPCF(101,4),XAXIS(106),
     +   YAXIS(106)
      INTEGER
     +   ISORT(101),ISYM(106),LAGS(4),NLPPA(1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LDSCMP,PARZEN,SETESL,SETLAG,STKSET,UFSDRV
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(101)
!        THE AUTOCOVARIANCE AT LAG ZERO (BIASED VARIANCE).
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP = 4 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISYM(106)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
!       THIS ROUTINE WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NLPPA(1)
!        A DUMMY ARRAY WHEN THE SERIES DOES NOT CONTAIN MISSING VALUES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION SPCF(101,4)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY WORK.
!     DOUBLE PRECISION XAXIS(106)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YFFT(LYFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YAXIS(106)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YMISS
!        A DUMMY VARIABLE WHEN THE SERIES DO NOT CONTAIN MISSING VALUES
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','F',' ',' '/
!
!     SET UP
!
      OPTION(4) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(1) = .TRUE.
!
!     SET MAXIMUM LAG VALUE TO BE USED.
!     SET EXTENDED SERIES LENGTH.
!     SET NUMBER OF LAG WINDOW TRUNCATION POINTS TO USE.
!
      CALL SETLAG(N, LAGMAX)
      CALL SETESL(N+LAGMAX, 4, NFFT)
      NW = 4
!
      ISPCF = 101
      LACOV = 101
      LNLPPA = 1
      LPCV = 106
      LWORK = NFFT
      NF = 101
      YMISS = 1.0D0
!
!     COMPUTE MIIMUM ALLOWABLE STACK LENGTH
!
      CALL LDSCMP(1, 0, 0, 0, 0, 0, 'D', NFFT, LDSMIN)
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!     SET THE STACK ALLOCATION TYPE.
!
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
!
      IFP = 4
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
!
      IF ((LDSMIN.LE.LDSTAK) .AND. (LDSMIN.GE.7)) THEN
         WORK = STKGET(LWORK,IFP)
      ELSE
         WORK = 1
      END IF
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!     FOR SERIES WITH MISSING DATA.
!
      CALL UFSDRV(YFFT, LYFFT, YMISS, ACOV, NLPPA, SPCF, ISPCF, NF,
     +   FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS, RSTAK(WORK), LACOV,
     +   LWORK, DELTA, ISORT, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT,
     +   PARZEN, NMSUB, LDSMIN, LDSTAK, OPTION, LNLPPA, NFFT)
!
!     CHECK FOR ERRORS
!
      IF (IERR.EQ.0) RETURN
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL UFSF (YFFT, N, LYFFT, LDSTAK)')
      END
!XSTPLE
      SUBROUTINE XSTPLE(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,EXMPT
      INTEGER
     +   I,IPRT,IXM,LDSMIN,M,N,NETA,NPAR,NPRT,NTEST
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(10),SCALE(10),STP(10),XM(200,2)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LDSCMP,MDL4,STPLS,STPLS1,STPLS2,STPLSC
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        *
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL4
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     DOUBLE PRECISION PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION SCALE(10)
!        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION STP(10)
!        THE SELECTED STEP SIZES FOR EACH PARAMETER.
!     DOUBLE PRECISION XM(200,2)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      CALL IPRINT(IPRT)
!
!     SET PARAMETER VALUES
!
      CALL STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
      CALL STPLS2(NPAR, STP)
      CALL LDSCMP(14, 0, 2*(N+NPAR), 0, 0, 0, 'D', 10*N, LDSMIN)
!
      IF (LDSMIN.LE.LDSTAK) GO TO 5
!
      WRITE (IPRT, 1040) LDSMIN
      RETURN
!
    5 CONTINUE
!
!     CREATE INDEPENDENT VARIABLE
!
      DELTA = 0.0625D0
      XM(1,1) = 0.0D0
      DO 10 I=2,N
         XM(I,1) = XM(I-1,1) + DELTA
   10 CONTINUE
!
      NTEST = 0
!     CHECK ERROR HANDLING
!
!        TEST 1  -  MISCELANEOUS ERROR CHECKING
!
      N = -5
      M = -5
      IXM = -10
      NPAR = -10
!
!
      NTEST = NTEST + 1
      WRITE (IPRT,1090) NTEST
      WRITE (IPRT,1020)
      WRITE (IPRT,1000)
      IERR = -1
      CALL STPLS(XM, N, M, IXM, MDL4, PAR, NPAR, LDSTAK, STP)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1010)
      IERR = -1
      CALL STPLSC(XM, N, M, IXM, MDL4, PAR, NPAR, LDSTAK, STP, NETA,
     +   EXMPT, SCALE, NPRT)
      WRITE (IPRT,1050) IERR
!
!        TEST 2  -  MISCELANEOUS ERROR CHECKING (CONTINUED)
!
      CALL STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
      SCALE(2) = 0.0D0
!
      NTEST = NTEST + 1
      WRITE (IPRT,1090) NTEST
      WRITE (IPRT,1030)
      WRITE (IPRT,1000)
      IERR = -1
      CALL STPLS(XM, N, M, IXM, MDL4, PAR, NPAR, LDSMIN-1, STP)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1010)
      IERR = -1
      CALL STPLSC(XM, N, M, IXM, MDL4, PAR, NPAR, LDSMIN-1, STP, NETA,
     +   EXMPT, SCALE, NPRT)
      WRITE (IPRT,1050) IERR
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (15H TEST OF STPLS )
 1010 FORMAT (15H TEST OF STPLSC)
 1020 FORMAT (32H CHECK ERROR HANDLING  -  TEST 1)
 1030 FORMAT (32H CHECK ERROR HANDLING  -  TEST 2)
 1040 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1050 FORMAT (/29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1090 FORMAT (54H1DERIVATIVE STEP SIZE SELECTION SUBROUTINE TEST NUMBER,
     +   I5)
      END
!SRTRRI
      SUBROUTINE SRTRRI(A, RR, LA, IR)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SORTS THE LENGTH LA INTEGER ARRAY IR, THE LENGTH LA
!     ARRAY A, AND THE LENGTH LA ARRAY RR INTO ASCENDING
!     ORDER, BASED ON THE VALUES IN IR.  THE INTEGER ARRAY IR
!     CONSTITUTES THE KEY.  THE OTHER ARRAYS ARE CARRIED ALONG.
!     ORDINARILY THE ARRAY IR CONTAINS THE PERMUTATION VECTOR
!     RESULTING FROM AN APPLICATION OF THE ROUTINE SRTIRR, SO THAT
!     SORTING ON IR RESTORES A TO THE ORDER THAT IT HAD BEFORE
!     SRTIRR WAS APPLIED.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!        (BASED CLOSELY ON THE IMSL CDC LIBRARY 3 ROUTINE VSORTP)
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LA
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   A(LA),RR(LA)
      INTEGER
     +   IR(LA)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   R,RT,RTT,T,TT
      INTEGER
     +   I,IJ,IT,ITT,J,K,L,M
!
!  LOCAL ARRAYS
      INTEGER
     +   IL(21),IU(21)
!
!  INTRINSIC FUNCTIONS
      INTRINSIC INT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION A(LA)
!        INPUT/OUTPUT PARAMETER.  THE ARRAY TO BE SORTED ON
!        THE BASIS OF THE VALUES IN IR.  IF IR IS A PERMUTATION
!        VECTOR PRODUCED ORIGINALLY IN A SORT OF A, THEN THIS
!        OPERATION RESTORES A TO ITS ORIGINAL ORDER.
!     INTEGER I
!        *
!     INTEGER IJ
!        *
!     INTEGER IL(21)
!        *
!     INTEGER IR(LA)
!        INPUT/OUTPUT PARAMETER.  THE INTEGER KEY ARRAY.  ORDINARILY
!        IT WILL BE A PERMUTATION VECTOR PRODUCED BY SOME PREVIOUS
!        SORT OF A AND RR ON A, SO THAT SORTING ON IR WILL RESTORE
!        A TO ITS ORIGINAL ORDER.
!     INTEGER IT
!        *
!     INTEGER ITT
!        *
!     INTEGER IU(21)
!        *
!     INTEGER J
!        *
!     INTEGER K
!        *
!     INTEGER L
!        *
!     INTEGER LA
!        INPUT PARAMETER.  THE LENGTH OF THE INPUT/OUTPUT PARAMETERS
!        A, RR, AND IR.
!     INTEGER M
!        *
!     DOUBLE PRECISION R
!        *
!     DOUBLE PRECISION RR(LA)
!        INPUT/OUTPUT PARAMETER.  THE ARRAY CARRIED ALONG IN
!        THE SORT.  IT MIGHT BE THE SET OF WEIGHTS FOR A.
!     DOUBLE PRECISION RT
!        *
!     DOUBLE PRECISION RTT
!        *
!     DOUBLE PRECISION T
!        *
!     DOUBLE PRECISION TT
!        *
!
      M = 1
      I = 1
      J = LA
      R = .375D0
   10 IF (I.EQ.J) GO TO 90
      IF (R.GT.0.5898437D0) GO TO 20
      R = R + 3.90625D-2
      GO TO 30
   20 R = R - .21875D0
   30 K = I
!                                  SELECT A CENTRAL ELEMENT OF THE
!                                  ARRAY AND SAVE IT IN LOCATION IT
      IJ = I + INT((J-I)*R)
      T = A(IJ)
      IT = IR(IJ)
      RT = RR(IJ)
!                                  IF FIRST ELEMENT OF ARRAY IS GREATER
!                                  THAN IT, INTERCHANGE WITH IT
      IF (IR(I).LE.IT) GO TO 40
      A(IJ) = A(I)
      A(I) = T
      T = A(IJ)
      IR(IJ) = IR(I)
      IR(I) = IT
      IT = IR(IJ)
      RR(IJ) = RR(I)
      RR(I) = RT
      RT = RR(IJ)
   40 L = J
!                                  IF LAST ELEMENT OF ARRAY IS LESS THAN
!                                  IT, INTERCHANGE WITH IT
      IF (IR(J).GE.IT) GO TO 60
      A(IJ) = A(J)
      A(J) = T
      T = A(IJ)
      IR(IJ) = IR(J)
      IR(J) = IT
      IT = IR(IJ)
      RR(IJ) = RR(J)
      RR(J) = RT
      RT = RR(IJ)
!                                  IF FIRST ELEMENT OF ARRAY IS GREATER
!                                  THAN IT, INTERCHANGE WITH IT
      IF (IR(I).LE.IT) GO TO 60
      A(IJ) = A(I)
      A(I) = T
      T = A(IJ)
      IR(IJ) = IR(I)
      IR(I) = IT
      IT = IR(IJ)
      RR(IJ) = RR(I)
      RR(I) = RT
      RT = RR(IJ)
      GO TO 60
   50 TT = A(L)
      A(L) = A(K)
      A(K) = TT
      ITT = IR(L)
      IR(L) = IR(K)
      IR(K) = ITT
      RTT = RR(L)
      RR(L) = RR(K)
      RR(K) = RTT
!                                  FIND AN ELEMENT IN THE SECOND HALF OF
!                                  THE ARRAY WHICH IS SMALLER THAN IT
   60 L = L - 1
      IF (IR(L).GT.IT) GO TO 60
!                                  FIND AN ELEMENT IN THE FIRST HALF OF
!                                  THE ARRAY WHICH IS GREATER THAN IT
   70 K = K + 1
      IF (IR(K).LT.IT) GO TO 70
!                                  INTERCHANGE THESE ELEMENTS
      IF (K.LE.L) GO TO 50
!                                  SAVE UPPER AND LOWER SUBSCRIPTS OF
!                                  THE ARRAY YET TO BE SORTED
      IF (L-I.LE.J-K) GO TO 80
      IL(M) = I
      IU(M) = L
      I = K
      M = M + 1
      GO TO 100
   80 IL(M) = K
      IU(M) = J
      J = L
      M = M + 1
      GO TO 100
!                                  BEGIN AGAIN ON ANOTHER PORTION OF
!                                  THE UNSORTED ARRAY
   90 M = M - 1
      IF (M.EQ.0) RETURN
      I = IL(M)
      J = IU(M)
  100 IF (J-I.GE.1) GO TO 30
      IF (I.EQ.1) GO TO 10
      I = I - 1
  110 I = I + 1
      IF (I.EQ.J) GO TO 90
      T = A(I+1)
      IT = IR(I+1)
      RT = RR(I+1)
      IF (IR(I).LE.IT) GO TO 110
      K = I
  120 A(K+1) = A(K)
      IR(K+1) = IR(K)
      RR(K+1) = RR(K)
      K = K - 1
      IF (IT.LT.IR(K)) GO TO 120
      A(K+1) = T
      IR(K+1) = IT
      RR(K+1) = RT
      GO TO 110
      END
!NLCMP
      SUBROUTINE NLCMP (Y, WEIGHT, WT, LWT, N, NPAR, NPARE,
     +   RES, D, RD, COND, VCVL, LVCVL, NNZW, IDF, RSSHLF, RSS, RSD,
     +   YSS, EXACT, PVT, SDPVT, SDREST, ISKULL)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES VARIOUS STATISTICS AND VALUES RETURNED
!     AND/OR PRINTED BY THE NLS FAMILY OF ROUTINES WHEN WEIGHTS ARE
!     INVOLVED.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   COND,RSD,RSS,RSSHLF,YSS
      INTEGER
     +   IDF,LVCVL,LWT,N,NNZW,NPAR,NPARE
      LOGICAL
     +   EXACT,WEIGHT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PVT(N),RD(N),RES(N),SDPVT(N),SDREST(N),VCVL(LVCVL),
     +   WT(LWT),Y(N)
      INTEGER
     +   ISKULL(10)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FAC,FPLM,RVAR,SM,TJ,WTI,WTSUM,YWTSM,YWTYSM
      INTEGER
     +   I,J,JK,K
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL FITEXT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,SQRT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION COND
!        THE CONDITION NUMBER OF D.
!     DOUBLE PRECISION D(N,NPAR)
!        THE FIRST DERIVATIVE OF THE MODEL (JACOBIAN).
!     LOGICAL EXACT
!        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
!        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION FAC
!        A FACTOR USED TO CORRECT FOR ZERO WEIGHTED OBSERVATIONS IN
!        THE VARIANCE COVARIANCE COMPUTATION.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IDF
!        THE DEGREES OF FREEDOM IN THE FIT.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER ISKULL(10)
!        AN ERROR MESSAGE INDICATOR VARIABLE.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER JK
!        THE INDEX OF THE (J,K)TH ELEMENT OF THE VARIANCE-COVARIANCE
!        MATRIX.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER LVCVL
!        THE DIMENSION OF VECTOR VCVL.
!     INTEGER LWT
!        THE DIMENSION OF VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     DOUBLE PRECISION PVT(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
!     DOUBLE PRECISION RD(N)
!        THE DIAGONAL ELEMENTS OF THE R MATRIX OF THE Q - R
!        FACTORIZATION OF D.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     DOUBLE PRECISION RSS
!        THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION RSSHLF
!        HALF THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION RVAR
!        THE RESIDUAL VARIANCE.
!     DOUBLE PRECISION SDPVT(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDREST(N)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION SM
!        A VARIABLE USED FOR SUMMATION.
!     DOUBLE PRECISION TJ
!        ...
!     DOUBLE PRECISION VCVL(LVCVL)
!        THE LOWER HALF OF THE VARIANCE-COVARIANCE MATRIX, STORED
!        ROW WISE.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION WTI
!        THE ACTUAL WEIGHT USED FOR THE ITH OBSERVATION.
!     DOUBLE PRECISION WTSUM
!        THE SUM OF THE WEIGHTS.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!     DOUBLE PRECISION YSS
!        THE SUM OF THE SQUARES ABOUT THE MEAN Y VALUE.
!     DOUBLE PRECISION YWTSM
!        THE SUM OF THE VALUES Y(I)*WT(I), I=1,N.
!     DOUBLE PRECISION YWTYSM
!        THE SUM OF THE VALUES Y(I)*WT(I)*WT(I), I=1,N.
!
      FPLM = D1MACH(2)
!
!     COMPUTE RESIDUALS
!
      DO 10 I=1,N
         RES(I) = Y(I) - PVT(I)
   10 CONTINUE
!
!     COMPUTE VARIOUS STATISTICS
!
      IDF = NNZW - NPARE
      RSS = 2.0D0*RSSHLF
      RVAR = 0.0D0
      IF (IDF.GE.1) RVAR = RSS/IDF
      RSD = SQRT(RVAR)
      YWTSM = 0.0D0
      YWTYSM = 0.0D0
      WTSUM = 0.0D0
      DO 20 I=1,N
         WTI = 1.0D0
         IF (WEIGHT) WTI = WT(I)
         YWTSM = YWTSM + Y(I)*WTI
         YWTYSM = YWTYSM + Y(I)*WTI*Y(I)
         WTSUM = WTSUM + WTI
   20 CONTINUE
      YSS = MAX(YWTYSM-(YWTSM*YWTSM)/WTSUM,0.0D0)
!
      CALL FITEXT(RSS, YSS, EXACT)
!
      COND = FPLM
      IF (RD(NPARE).NE.0.0D0) COND = ABS(RD(1)/RD(NPARE))
!
      IF (IERR.NE.0) RETURN
!
!     CORRECT FOR DEGREES OF FREEDOM IF NECESSARY BECAUSE OF ZERO
!     WEIGHTED OBSERVATIONS.
!
      IF (N.EQ.NNZW) GO TO 40
!
      FAC = N-NPARE
      IF (IDF.GE.1) FAC = FAC/IDF
      DO 30 I=1,LVCVL
         VCVL(I) = VCVL(I)*FAC
   30 CONTINUE
!
   40 CONTINUE
!
!     IF THE RESIDUAL SUM OF SQUARES IS IDENTICALLY ZERO, THEN
!     NO FURTHER COMPUTATIONS ARE NECESSARY
!
      IF ((IDF.LE.0) .OR. EXACT) RETURN
!
!     IF THE STANDARD DEVIATIONS OF THE PREDICTED VALUES AND
!     STANDARDIZED RESIDUALS ARE NOT SAVED OR PRINTED, THEN NO
!     FURTHER COMPUTATIONS ARE NECESSARY.
!
!     COMPUTE THE STANDARD DEVIATIONS OF THE PREDICTED VALUES (SDPVT)
!
      DO 90 I=1,N
         SM = 0.0D0
         DO 60 J=1,NPARE
            TJ = 0.0D0
            DO 50 K=1,NPARE
               IF (J.GE.K) THEN
                  JK = J*(J-1)/2 + K
               ELSE
                  JK = K*(K-1)/2 + J
               END IF
               TJ = TJ + VCVL(JK)*D(I,K)
   50       CONTINUE
               SM = SM + D(I,J)*TJ
   60    CONTINUE
         IF (SM.LT.0.0D0) SM = 0.0D0
         SDPVT(I) = SQRT(SM)
!
         SDREST(I) = FPLM
         WTI = 1.0D0
         IF (WEIGHT) WTI = WT(I)
         IF (WTI.EQ.0.0D0) GO TO 90
!
         IF (RVAR/WTI-SM.LE.0.0D0) GO TO 70
         GO TO 80
!
!           THEN
!
   70    SDREST(I) = FPLM
         ISKULL(1) = 1
         ISKULL(4) = 1
         IERR = 4
         GO TO 90
!
!           ELSE
!
   80    SDREST(I) = RES(I)/SQRT(RVAR/WTI-SM)
!
!        END IF
!
   90 CONTINUE
!
      RETURN
!
      END
!STATER
      SUBROUTINE STATER(NMSUB, WT, N, LDSTAK, WTS, NNZW, STACK, IERR)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE CHECKS INPUT PARAMETERS TO THE USER
!     CALLABLE MEMBERS OF THE STAT FAMILY OF ROUTINES
!     FOR ERRORS AND REPORTS ANY THAT IT FINDS, BESIDES
!     RETURNING A FLAG INDICATING THAT ERRORS HAVE BEEN
!     FOUND.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IERR,LDSTAK,N,NNZW
      LOGICAL
     +   STACK,WTS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   WT(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  LOCAL SCALARS
      INTEGER
     +   LDSMIN,NZW
      LOGICAL
     +   HEAD,IER1,IER2,IER3
!
!  LOCAL ARRAYS
      CHARACTER
     +   LLDS(8)*1,LN(8)*1,LTHREE(8)*1,LWT(8)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,ERVWT,LDSCMP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        OUTPUT PARAMETER.  A FLAG INDICATING WHETHER OR
!        NOT AN ERROR HAS BEEN FOUND.  0 = OK, 1 = ERROR.
!     LOGICAL IER1
!        TRUE IF N .LT. 3
!     LOGICAL IER2
!        TRUE IF LDSTAK .LT. (N + 13)/2.0D0
!     LOGICAL IER3
!        TRUE IF SOME WT .LT. 0.0D0 OR NNZW .LT. 3
!     INTEGER LDSMIN
!        MINIMUM LENGTH OF FRAMEWORK AREA IN DOUBLE
!        PRECISION ELEMENTS.
!     INTEGER LDSTAK
!        INPUT PARAMETER.  THE NUMBER OF LOCATIONS PROVIDED IN
!        THE FRAMEWORK AREA.
!     CHARACTER*1 LLDS(8), LN(8), LTHREE(8), LWT(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) FO THE VARIALBE(S) CHECKED
!        FOR ERRORS
!     INTEGER N
!        INPUT PARAMETER.  THE NUMBER OF ELEMENTS IN Y AND WT.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE
!     INTEGER NNZW
!        OUTPUT PARAMETER.  IF WTS, THEN SET EQUAL TO THE
!        NUMBER OF VALUES IN WT WHICH ARE POSITIVE.  ELSE,
!        UNDEFINED.
!     INTEGER NZW
!        THE NUMBER OF ZERO WEIGHTS.
!     LOGICAL STACK
!        A FLAG INDICATING WHETHER THIS ROUTINE USES THE STACK (TRUE)
!        OR NOT (FALSE).
!     DOUBLE PRECISION WT(N)
!        INPUT PARAMETER.  THE VECTOR OF WEIGHTS CORRESPONDING
!        TO THE VECTOR Y.
!     LOGICAL WTS
!        INPUT PARAMETER.  A FLAG INDICATING WHETHER OR NOT
!        THERE IS REALLY A VECTOR WT (TRUE), OR ONLY A DUMMY PARAMETER
!        (FALSE).
!
!     INITIALIZE NAME VECTORS
!
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +  LLDS(7), LLDS(8) / 'L', 'D', 'S', 'T', 'A', 'K', ' ', ' '/
      DATA     LN(1),    LN(2),    LN(3),    LN(4),    LN(5),    LN(6),
     +  LN(7), LN(8)  / 'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA LTHREE(1),LTHREE(2),LTHREE(3),LTHREE(4),LTHREE(5),LTHREE(6),
     +  LTHREE(7), LTHREE(8) / 'T', 'H', 'R', 'E', 'E', ' ', ' ', ' '/
      DATA    LWT(1),   LWT(2),   LWT(3),   LWT(4),   LWT(5),   LWT(6),
     +  LWT(7), LWT(8) / 'W', 'T', ' ', ' ', ' ', ' ', ' ', ' '/
!
!     INITIALIZE ERROR FLAGS
!
      IER1 = .FALSE.
      IER2 = .FALSE.
      IER3 = .FALSE.
!
      IERR = 0
!
      HEAD = .TRUE.
!
!     CHECK TO SEE THAT THERE ARE AT LEAST THREE DATA POINTS.
!
      CALL EISGE(NMSUB, LN, N, 3, 2, HEAD, IER1, LTHREE)
!
!     CHECK TO SEE THAT AN AMOUNT OF WORK AREA EQUAL
!     IN LENGTH TO THE REQUIREMENTS OF THE PERMUTATION
!     VECTOR WILL BE AVAILABLE.
!
      IF (STACK) THEN
         CALL LDSCMP(1, 0, N, 0, 0, 0, 'D', 0, LDSMIN)
         CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, IER2, LLDS)
      END IF
!
!     IF THERE ARE WEIGHTS
!     CHECK TO SEE THAT AT LEAST THREE DATA ITEMS HAVE NONZERO WEIGHTS.
!
      NNZW = N
      IF (WTS) THEN
         CALL ERVWT(NMSUB, LWT, WT, N, 3, HEAD, NNZW, NZW, 1, IER3,
     +              LTHREE)
      END IF
!
!     SEE IF ANY ERRORS WERE FOUND.
!
      IF (IER1 .OR. IER2 .OR. IER3) IERR = 1
      RETURN
      END
!CCVFM
      SUBROUTINE CCVFM(Y1, Y1MISS, Y2, Y2MISS, N, NC, Y1MEAN, Y2MEAN,
     +   CCOV12, CCOV21, ICCOV, NLPP12, NLPP21)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE CROSS COVARIANCE FUNCTION
!     BETWEEN TWO SERIES WHEN MISSING DATA ARE INVOLVED.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   Y1MEAN,Y1MISS,Y2MEAN,Y2MISS
      INTEGER
     +   ICCOV,N,NC
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV12(ICCOV),CCOV21(ICCOV),Y1(N),Y2(N)
      INTEGER
     +   NLPP12(ICCOV),NLPP21(ICCOV)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DOTXY,FPLM
      INTEGER
     +   LAG,NDOTXY
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DOTCM
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCOV12(ICCOV), CCOV21(ICCOV)
!        THE ARRAYS IN WHICH THE CCVF FOR SERIES 1 LAGGED
!        BEHIND SERIES 2 AND VISA VERSA, RESPECTIVELY, ARE
!        STORED.
!     DOUBLE PRECISION DOTXY
!        VARIOUS CROSS PRUDUCTS BETWEEN SERIES Y1 AND Y2.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER ICCOV
!        THE ROW DIMENSION OF THE ARRAYS CCOV12 AND CCOV21.
!     INTEGER LAG
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCORRELATION BEING COMPUTED.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NC
!        THE NUMBER OF CROSS CORRELATIONS DESIRED.
!     INTEGER NLPP12(ICCOV), NLPP21(ICCOV)
!        THE NUMBER OF LAGGED PRODUCT PAIRS USED TO COMPUTE THE CCVF
!        FOR EACH PAIR OF SERIES AT EACH LAG.
!     INTEGER NDOTXY
!        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY.
!     DOUBLE PRECISION Y1(N), Y1MEAN, Y1MISS
!        THE FIRST SERIES, AND ITS MEAN, AND MISSING VALUE CODE.
!     DOUBLE PRECISION Y2(N), Y2MEAN, Y2MISS
!        THE SECOND SERIES, AND ITS MEAN, AND MISSING VALUE CODE.
!
      FPLM = D1MACH(2)
!
!     COMPUTE THE CROSS COVARIANCES
!
      CALL DOTCM (Y1, Y1MEAN, Y1MISS, N, Y2, Y2MEAN, Y2MISS, N, DOTXY,
     +   NDOTXY)
!
      NLPP12(1) = NDOTXY
      CCOV12(1) = FPLM
      IF (NDOTXY .GE. 1) CCOV12(1) = DOTXY / NDOTXY
!
      CCOV21(1) = CCOV12(1)
      NLPP21(1) = NDOTXY
!
      DO 10 LAG = 1, NC
!
         CALL DOTCM (Y1, Y1MEAN, Y1MISS, N, Y2(LAG+1), Y2MEAN, Y2MISS,
     +       N-LAG, DOTXY, NDOTXY)
!
         NLPP12(LAG+1) = NDOTXY
         CCOV12(LAG+1) = FPLM
         IF (NDOTXY .GE. 1)
     +      CCOV12(LAG+1) = DOTXY * (N-LAG) / (N*NDOTXY)
!
         CALL DOTCM (Y2, Y2MEAN, Y2MISS, N, Y1(LAG+1), Y1MEAN, Y1MISS,
     +      N-LAG, DOTXY, NDOTXY)
!
         NLPP21(LAG+1) = NDOTXY
         CCOV21(LAG+1) = FPLM
         IF (NDOTXY .GE. 1)
     +      CCOV21(LAG+1) = DOTXY * (N-LAG) / (N*NDOTXY)
!
   10 CONTINUE
!
      RETURN
      END
!MPPMC
      SUBROUTINE MPPMC(YM, YMMISS, X, XMISS, N, M, IYM, ILOG, ISIZE,
     +   NOUT, YLB, YUB, XLB, XUB)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH MULTIPLE Y-AXIS VALUES AND WITH MISSING
!     OBSERVATIONS (LONG CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   ILOG,ISIZE,IYM,M,N,NOUT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,ISCHCK,LISYM
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(N,M)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(M)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'P',       'P',       'M',       'C',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      MULTI = .TRUE.
      ISCHCK = 2
      MISS = .TRUE.
      LISYM = 1
!
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL MPPMC (YM, YMMISS, X, XMISS, N, M, IYM, ILOG,'/
     +   '      +            ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      END
!NLMN
      SUBROUTINE NLMN(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, MDL,
     +   NLDRV, APRXDV, DRV, IFIXD, PAR, PARE, NPAR, RES, PAGE, WIDE,
     +   HLFRPT, STP, LSTP, MIT, STOPSS, STOPP, SCALE, LSCALE, DELTA,
     +   IVAPRX, IPTOUT, NDIGIT, RSD, PV, SDPVI, SDRESI, VCVL, LVCVL, D,
     +   IWORK, IIWORK, RWORK, IRWORK, NLHDR, NPARE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLING SUBROUTINE FOR PERFORMING NONLINEAR
!     LEAST SQUARES REGRESSION USING THE NL2 SOFTWARE PACKAGE
!     (IMPLEMENTING THE METHOD OF DENNIS, GAY AND WELSCH).
!     THIS SUBROUTINE WAS ADAPTED FROM SUBROUTINE NL2SOL.
!
!     REFERENCES
!
!     DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1979), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, (BEING REVISED).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IIWORK,IRWORK,IVAPRX,IXM,LSCALE,LSTP,LVCVL,LWT,M,MIT,N,
     +   NDIGIT,NNZW,NPAR,NPARE,SDPVI,SDRESI,VCVL
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,WEIGHT,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PAR(NPAR),PARE(NPAR),PV(N),RES(N),RWORK(IRWORK),
     +   SCALE(LSCALE),STP(LSTP),WT(LWT),XM(IXM,M),Y(N)
      INTEGER
     +   IFIXD(NPAR),IPTOUT(NDIGIT),IWORK(IIWORK)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL,NLDRV,NLHDR
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   WTSQRT
      INTEGER
     +   CNVCOD,COVMAT,I,ICNVCD,IVCVPT,QTR,RD,RDI,RSAVE,RSSHLF,S,
     +   SCL
      LOGICAL
     +   CMPDRV,DONE,HEAD,NEWITR,PRTSMY
!
!  LOCAL ARRAYS
      INTEGER
     +   ISKULL(10)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL NL2ITR,NLERR,NLFIN,NLINIT,NLISM,NLITRP,NLSUPK
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL CMPDRV
!        THE VARIABLE USED TO INDICATE WHETHER DERIVATIVES MUST BE
!        COMPUTED (TRUE) OR NOT (FALSE).
!     INTEGER CNVCOD
!        A VALUE USED TO CONTROL THE PRINTING OF ITERATION REPORTS.
!     INTEGER COVMAT
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
!        OF THE BEGINNING OF THE VCV MATRIX.
!     DOUBLE PRECISION D(N,NPAR)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     LOGICAL DONE
!        THE VARIABLE USED TO INDICATE WHETHER THIS IS THE FINAL
!        COMPUTATION OF THE JACOBIAN OR NOT.
!     LOGICAL HEAD
!        THE VARIABLE USED TO INDICATE WHETHER A HEADING IS TO BE
!        PRINTED DURING A GIVEN CALL TO THE ITERATION REPORT (TRUE)
!        OR NOT (FALSE).
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER ICNVCD
!        THE LOCATION IN IWORK OF
!        THE CONVERGENCE CONDITION.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IIWORK
!        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
!     INTEGER IPTOUT(NDIGIT)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER IRWORK
!        THE DIMENSION OF THE DOUBLE PRECISION WORK VECTOR RWORK.
!     INTEGER ISKULL(10)
!        AN ERROR MESSAGE INDICATOR VARIABLE.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCVPT
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
!        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
!        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)
!        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                       *INVERSE(HESSIAN)
!     INTEGER IWORK(IIWORK)
!        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LVCVL
!        THE LENGTH OF THE VECTOR CONTAINING
!        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     LOGICAL NEWITR
!        A FLAG USED TO INDICATE WHETHER A NEW ITERATION HAS BEEN
!        COMPLETED (TRUE) OR NOT (FALSE).
!     EXTERNAL NLDRV
!        THE NAME OF THE ROUTINE WHICH CALCULATED THE DERIVATIVES
!     EXTERNAL NLHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PARE(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS, BUT ONLY
!        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
!     LOGICAL PRTSMY
!        THE VARIABLE USED TO INDICATE WHETHER THE SUMMARY
!        INFORMATION IS TO BE PRINTED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUES.
!     INTEGER QTR
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
!        THE ARRAY Q TRANSPOSE R.
!     INTEGER RD
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK OF
!        THE DIAGONAL ELEMENTS OF THE R MATRIX OF THE Q - R
!        FACTORIZATION OF D.
!     INTEGER RDI
!        THE LOCATION IN RWORK OF THE DIAGONAL ELEMENTS OF THE R
!        MATRIX OF THE Q - R FACTORIZATION OF D.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     INTEGER RSAVE
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
!        THE ARRAY RSAVE.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     INTEGER RSSHLF
!        THE LOCATION IN RWORK OF
!        HALF THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION RWORK(IRWORK)
!        THE DOUBLE PRECISION WORK VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER S
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
!        THE ARRAY OF SECOND ORDER TERMS OF THE HESSIAN.
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     INTEGER SCL
!        THE INDEX IN RWORK OF THE 1ST VALUE OF THE USER SUPPLIED SCALE
!        VALUE.
!     INTEGER SDPVI
!        THE STARTING LOCATION IN RWORK OF
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     INTEGER SDRESI
!        THE STARTING LOCATION IN RWORK OF THE
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!        PREDICTED DECREASE IN THE RESIDUAL STANDARD DEVIATION (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FORTHE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(LSTP)
!        THE DUMMY STEP SIZE ARRAY.
!     INTEGER VCVL
!        THE STARTING LOCATION IN RWORK OF THE LOWER HALF OF THE
!        VCV MATRIX, STORED ROW WISE.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION WTSQRT
!        THE SQUARE ROOT OF THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     IWORK SUBSCRIPT VALUES
!
      DATA CNVCOD /34/, ICNVCD /1/, COVMAT /26/, QTR /49/, RD /51/,
     +   RSAVE /52/, S/53/
      DATA RSSHLF /10/
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
!     INITIALIZE CONTROL PARAMETERS
!
      CALL NLINIT (N, IFIXD, PAR, NPAR, PARE, NPARE, MIT, STOPSS,
     +   STOPP, SCALE, LSCALE, DELTA, IVAPRX, APRXDV, IVCVPT, IWORK,
     +   IIWORK, RWORK, IRWORK, SCL)
!
      CMPDRV = .TRUE.
      DONE = .FALSE.
      HEAD = .TRUE.
      NEWITR = .FALSE.
      PRTSMY = (IPTOUT(1).NE.0)
!
!
!     COMPUTE RESIDUALS
!
   10 CALL MDL(PAR, NPAR, XM, N, M, IXM, PV)
!
      DO 20 I=1,N
         WTSQRT = 1.0D0
         IF (WEIGHT) WTSQRT = SQRT(WT(I))
         RES(I) = WTSQRT*(Y(I)-PV(I))
   20 CONTINUE
!
!     PRINT INITIAL SUMMARY
!
      IF (.NOT.PRTSMY) GO TO 30
      CALL NLISM(NLHDR, PAGE, WIDE, HLFRPT, NPAR, M, N, NNZW, WEIGHT,
     +   IFIXD, PAR, SCALE, IWORK, IIWORK, RWORK, IRWORK, RES, APRXDV,
     +   STP, LSTP, NPARE)
      PRTSMY = .FALSE.
!
   30 CONTINUE
!
      IF (.NOT.CMPDRV) GO TO 50
!
      CMPDRV = .FALSE.
!
   40 CONTINUE
!
!     PRINT ITERATION REPORT IF DESIRED
!
      IF ((IPTOUT(2).NE.0) .AND. NEWITR) CALL NLITRP(NLHDR, HEAD, PAGE,
     +   WIDE, IPTOUT(2), NPAR, NNZW, IWORK, IIWORK, RWORK, IRWORK,
     +   IFIXD, PARE, NPARE)
!
!  ***  COMPUTE JACOBIAN  ***
!
      IF (DONE) CALL MDL(PAR, NPAR, XM, N, M, IXM, PV)
!
      CALL NLDRV (MDL, DRV, DONE, IFIXD, PAR, NPAR, XM, N, M, IXM,
     +   PV, D, WEIGHT, WT, LWT, STP, LSTP, RWORK(SCL), NPARE)
!
      IF (DONE) GO TO 70
!
!     COMPUTE NEXT ITERATION
!
   50 CALL NL2ITR(RWORK(SCL), IWORK, D, N, N, NPARE, RES, RWORK, PARE)
!
!     UNPACK PARAMETERS
!
      CALL NLSUPK(PARE, NPARE, PAR, IFIXD, NPAR)
!
      NEWITR = (IWORK(CNVCOD).EQ.0)
      IF (IWORK(1)-2) 10, 40, 60
!
   60 DONE = .TRUE.
      GO TO 40
   70 CONTINUE
!
!     SET ERROR FLAGS, IF NECESSARY
!
      CALL NLERR(IWORK(ICNVCD), ISKULL)
!
!     FINISH COMPUTATIONS AND PRINT ANY DESIRED RESULTS
!
!     EQUIVALENCE LOCATIONS WITHIN RWORK.
!
      SDPVI = IWORK(RSAVE)
      SDRESI = IWORK(QTR)
      VCVL = IWORK(COVMAT)
      IF (VCVL.GE.1) GO TO 80
!
      VCVL = IWORK(S)
      IF (IERR.NE.0) GO TO 80
      ISKULL(1) = 1
      ISKULL(7) = 1
      IERR = 7
!
   80 CONTINUE
!
      LVCVL = NPARE*(NPARE+1)/2
!
      RDI = IWORK(RD)
!
      CALL NLFIN(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, IFIXD, PAR,
     +   NPAR, NPARE, RES, PAGE, WIDE, IPTOUT, NDIGIT, RWORK(RSSHLF),
     +   RSD, PV, RWORK(SDPVI), RWORK(SDRESI), RWORK(RDI), RWORK(VCVL),
     +   LVCVL, D, NLHDR, IVCVPT, ISKULL)
!
      RETURN
!
      END
!VPML
      SUBROUTINE VPML(YM, YMMISS, N, NS, ILOG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA (LOG PLOT OPTION).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(1)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,IPRT,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  ' ',       'V',       'P',       'M',       'L',       ' '/
!
!     SET DEFAULT VALUES
!
      M = 1
      IYM = N
      MULTI = .FALSE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 0
      ISIZE = -1
      MISS = .TRUE.
      LISYM = 1
      IRLIN = -1
      IBAR = 0
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL VPML (Y, YMISS, N, NS, ILOG)')
      END
!PPCNT
      SUBROUTINE PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLING ROUTINE FOR USER CALLED PAGE PLOT ROUTINES
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   ILOG,ISCHCK,ISIZE,IYM,LISYM,M,N,NOUT
      LOGICAL
     +   MISS,MULTI
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(*)
      INTEGER
     +   ISYM(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XMN,XMX,YMN,YMX
      LOGICAL
     +   ERROR,XCHECK
!
!  EXTERNAL SUBROUTINES
      EXTERNAL PLTCHK,PPLMT,PPMN,VERSP
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        A VALUE INDICATING WHETHER AN ERROR WAS DETECTEC (TRUE)
!        OR NOT (FALSE).
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(LISYM)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING, NOT USED IN SOME CASES
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     LOGICAL XCHECK
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER X-AXIS VALUES
!        ARE TO BE CHECKED (XCHECK = .TRUE.) OR NOT (XCHECK = .FALSE.)
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XMN, XMX
!        THE X-AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(IYM,M)
!        VECTOR OF OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES
!     DOUBLE PRECISION YMMISS(M)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YMN, YMX
!        THE Y-AYIS LOWER AND UPPER LIMITS ACTUALLY USED.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     COMMENCE BODY OF ROUTINE
!
      XCHECK = .TRUE.
      CALL PLTCHK (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +   YLB, YUB, XLB, XUB, NMSUB, MISS, XCHECK)
!
      IF (IERR.EQ.0) THEN
!
!       DETERMINE THE BOUNDS FOR THE X AND Y AXIS AND COMPLETE ERROR
!       CHECKING
!
        CALL PPLMT (YM, YMMISS, X, XMISS, N, M, IYM, YLB, YUB, YMN, YMX,
     +    XLB, XUB, XMN, XMX, ERROR, NMSUB, MISS)
!
        IF (ERROR) THEN
          IERR = 1
        ELSE
!
!       PRINT PLOT
!
        IF (ISIZE.LE.9) THEN
          CALL VERSP(.TRUE.)
        ELSE
          CALL VERSP(.FALSE.)
        END IF
        CALL PPMN (YM, YMMISS, X, XMISS, N, M, IYM, ISCHCK, ISYM,
     +    LISYM, ISIZE, NOUT, YMN, YMX, XMN, XMX, MISS, ILOG)
!
        END IF
      END IF
!
      RETURN
!
      END
!FLTSL
      SUBROUTINE FLTSL (Y, N, K, H, YF, NYF)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE FILTERS THE INPUT SERIES Y USING THE K TERMS
!     OF H, COPYING THE FILTERED SERIES INTO YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   K,N,NYF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   H(K),Y(N),YF(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   TEMP
      INTEGER
     +   I,I1,IHM,IHP,IKMID,IM,IP,J,KHALF,KMID
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION H(K)
!        THE ARRAY IN WHICH THE FILTER COEFFICIENTS ARE STORED.
!     INTEGER I, IHM, IHP, IKMID, IM, IP
!        INDEXING VARIABLES.
!     INTEGER J
!        AN INDEXING VARIABLE.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS.
!     INTEGER KHALF, KMID
!        THE HALF LENGTH OF THE FILTER AND THE MIDPOINT OF THE FILTER.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     DOUBLE PRECISION TEMP
!        A TEMPORY STORAGE LOCATION.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
      DO 10 I = 1, N
         YF(I) = Y(I)
   10 CONTINUE
!
      NYF = N - (K - 1)
!
      KHALF = (K - 1) / 2
!
      KMID = KHALF + 1
!
      DO 30 I = 1, NYF
         IKMID = I + KHALF
         TEMP = H(KMID) * YF(IKMID)
         DO 20 J = 1, KHALF
            IP = IKMID + J
            IHP = KMID + J
            IM = IKMID - J
            IHM = KMID - J
            TEMP = TEMP + H(IHP)*YF(IP) + H(IHM)*YF(IM)
   20    CONTINUE
         YF(I) = TEMP
   30 CONTINUE
!
      I1 = NYF + 1
!
      DO 40 I = I1, N
         YF(I) = 0.0D0
   40 CONTINUE
      RETURN
      END
!SUMWDS
      SUBROUTINE SUMWDS(X, W, N, LO, MID, HI, XMEANW, SUMDA, SUMWD2,
     +   SUMD2, SUMD3, SUMD4)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO CALCULATE WEIGHTED AND UNWEIGHTED SUMS
!     OF POWERS OF DIFFERENCES FROM THE WEIGHTED MEAN FOR A
!     SORTED VECTOR IN WHICH THE MIDTH ELEMENT IS THE ELEMENT
!     CLOSEST TO ZERO.  USED BY THE STAT FAMILY.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SUMD2,SUMD3,SUMD4,SUMDA,SUMWD2,XMEANW
      INTEGER
     +   HI,LO,MID,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   W(N),X(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DIFF
      INTEGER
     +   CURHI,CURLO,I,IREV
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CURHI
!        THE UPPER BOUND OF THE CURRENT INTERVAL.
!     INTEGER CURLO
!        THE LOWER BOUND OF THE CURRENT INTERVAL.
!     DOUBLE PRECISION DIFF
!        THE DIFFERENCES BETWEEN X(I) AND XMEANW.
!     INTEGER HI
!        INPUT PARAMETER.  THE UPPER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER I
!        A LOOP PARAMETER.
!     INTEGER IREV
!        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
!        IN THE REVERSE ORDER.
!     INTEGER LO
!        INPUT PARAMETER.  THE LOWER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER MID
!        INPUT PARAMETER.  THE INDEX OF THE ELEMENT IN X CLOSEST TO
!        ZERO IN VALUE.  THE POINT OUT FROM WHICH THE SUMMING IS
!        DONE.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
!     DOUBLE PRECISION SUMDA
!        OUTPUT PARAMETER.  THE SUM OF THE ABSOLUTE VALUES OF THE
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION SUMD2
!        OUTPUT PARAMETER.  THE SUM OF THE SQUARES OF THE
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION SUMD3
!        OUTPUT PARAMETER.  THE SUM OF THE CUBES OF THE
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION SUMD4
!        OUTPUT PARAMETER.  THE SUM OF THE HYPERCUBES OF THE
!        DIFFERENCES DIFF.
!     DOUBLE PRECISION SUMWD2
!        OUTPUT PARAMETER.  THE WEIGHTED SUM OF THE SQUARES OF
!        THE DIFFERENCES DIFF.
!     DOUBLE PRECISION W(N)
!        INPUT PARAMETER.  THE ARRAY OF WEIGHTS.
!     DOUBLE PRECISION X(N)
!        INPUT PARAMETER.  THE DATA ARRAY X IN WHICH THE SUMS ARE TAKEN.
!     DOUBLE PRECISION XMEANW
!        INPUT PARAMETER.  THE WEIGHTED MEAN OF X.
!
!     INITIALIZE SUMMATION VARIABLES.
!
      SUMDA = 0.0D0
      SUMWD2 = 0.0D0
      SUMD2 = 0.0D0
      SUMD3 = 0.0D0
      SUMD4 = 0.0D0
      IF (W(MID).EQ.0.0D0) GO TO 10
      DIFF = X(MID) - XMEANW
      SUMDA = ABS(DIFF)
      SUMWD2 = W(MID)*DIFF*DIFF
      SUMD2 = DIFF*DIFF
      SUMD3 = DIFF*DIFF*DIFF
      SUMD4 = DIFF*DIFF*DIFF*DIFF
   10 CURLO = MID - 1
      CURHI = MID + 1
!
!     SUM OUTWARDS, BOULDER, COLORADO FROM THE VALUE NEAREST ZERO.  THAT
!     THE LEAST IN MAGNITUDE TO THE GREATEST.
!
   20 IF (CURHI.GT.HI .OR. CURLO.LT.LO) GO TO 60
      IF (ABS(X(CURHI)).LT.ABS(X(CURLO))) GO TO 40
      IF (W(CURLO).EQ.0.0D0) GO TO 30
      DIFF = X(CURLO) - XMEANW
      SUMDA = SUMDA + ABS(DIFF)
      SUMWD2 = SUMWD2 + W(CURLO)*DIFF*DIFF
      SUMD2 = SUMD2 + DIFF*DIFF
      SUMD3 = SUMD3 + DIFF*DIFF*DIFF
      SUMD4 = SUMD4 + DIFF*DIFF*DIFF*DIFF
   30 CURLO = CURLO - 1
      GO TO 20
   40 IF (W(CURHI).EQ.0.0D0) GO TO 50
      DIFF = X(CURHI) - XMEANW
      SUMDA = SUMDA + ABS(DIFF)
      SUMWD2 = SUMWD2 + W(CURHI)*DIFF*DIFF
      SUMD2 = SUMD2 + DIFF*DIFF
      SUMD3 = SUMD3 + DIFF*DIFF*DIFF
      SUMD4 = SUMD4 + DIFF*DIFF*DIFF*DIFF
   50 CURHI = CURHI + 1
      GO TO 20
!
!     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
!     CENTER ZERO POINT.
!
   60 IF (CURHI.GT.HI) GO TO 80
      DO 70 I=CURHI,HI
         IF (W(I).EQ.0.0D0) GO TO 70
         DIFF = X(I) - XMEANW
         SUMDA = SUMDA + ABS(DIFF)
         SUMWD2 = SUMWD2 + W(I)*DIFF*DIFF
         SUMD2 = SUMD2 + DIFF*DIFF
         SUMD3 = SUMD3 + DIFF*DIFF*DIFF
         SUMD4 = SUMD4 + DIFF*DIFF*DIFF*DIFF
   70 CONTINUE
   80 IF (CURLO.LT.LO) GO TO 100
      DO 90 IREV=LO,CURLO
         I = LO - IREV + CURLO
         IF (W(I).EQ.0.0D0) GO TO 90
         DIFF = X(I) - XMEANW
         SUMDA = SUMDA + ABS(DIFF)
         SUMWD2 = SUMWD2 + W(I)*DIFF*DIFF
         SUMD2 = SUMD2 + DIFF*DIFF
         SUMD3 = SUMD3 + DIFF*DIFF*DIFF
         SUMD4 = SUMD4 + DIFF*DIFF*DIFF*DIFF
   90 CONTINUE
  100 RETURN
      END
!BFSMN
      SUBROUTINE BFSMN(SPCF1, SPCF2, CEVEN, CODD, W, LW, LAG, DF, NPRT,
     +   NF, CSPC2, PHAS, FREQ, NPTS, XAXIS, YAXIS, ISYM, LPCV, ALPHA,
     +   LAGMX1, DELTA)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE SQUARED COHERENCY AND PHASE COMPONENTS
!     OF A BIVARIATE SPECTRUM.
!
!     REFERENCE - JENKINS AND WATTS
!                 SPECTRAL ANALYSIS AND ITS APPLICATIONS
!
!     WRITTEN BY - STEPHEN M. KEEFER AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALPHA,DELTA,DF
      INTEGER
     +   LAG,LAGMX1,LPCV,LW,NF,NPRT,NPTS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CEVEN(*),CODD(*),CSPC2(*),FREQ(*),PHAS(*),SPCF1(*),SPCF2(*),
     +   W(*),XAXIS(*),YAXIS(*)
      INTEGER
     +   ISYM(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ARG,BARL,BARQ,BARY,C,CI,FAC,FPLM,FPLRS,FPSPM,G,PI,PIT2,SN,V0,
     +   V1,V2,Z0,Z1,Z2
      INTEGER
     +   I,K
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   PPFNML,D1MACH
      EXTERNAL PPFNML,D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ATAN2,COS,LOG,SIGN,SIN,SQRT,TANH
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION ARG
!        AN ARGUMENT USED IN THE SPECTRUM COMPUTATIONS.
!     DOUBLE PRECISION BARL
!        THE SMOOTHED COSPECTRAL ESTIMATES.
!     DOUBLE PRECISION BARQ
!        THE SMOOTHED QUADRATURE SPECTRAL ESTIMATES.
!     DOUBLE PRECISION BARY
!        A TRANSFORMATION OF THE SQUARED COHERENCY COMPONENT.
!     DOUBLE PRECISION C
!        AN ARGUMENT USED IN THE SPECTRUM COMPUTATIONS.
!     DOUBLE PRECISION CEVEN(LAGMX1)
!        THE SUMS OF THE COVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CI
!        THE CONFIDENCE INTERVAL FOR THE SQUARED COHERENCY COMPONENT.
!     DOUBLE PRECISION CODD(LAGMX1)
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CSPC2(NF)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     DOUBLE PRECISION FAC
!        THE CONVERSION FACTOR FROM RADIANS TO DEGREES.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     DOUBLE PRECISION FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     DOUBLE PRECISION FPSPM
!        THE FLOATING POINT SMALLEST POSITIVE MAGNITUDE.
!     DOUBLE PRECISION FREQ(NF)
!        THE FREQUENCIES AT WHICH THE SPECTRUM IS COMPUTED.
!     DOUBLE PRECISION G
!        AN ARGUMENT USED IN THE COMPUTATION OF THE ALPHA PERCENT
!        SIGNIFICANCE LEVEL.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER ISYM(LPCV)
!        THE VECTOR CONTAINING THE CODES FOR THE PLOT SYMBOLS.
!     INTEGER K
!         AN INDEX VALUE.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGMX1
!        THE VALUE LAGMAX+1.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!         THE LENGTH OF VECTOR W.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT = 2 THE PLOT IS PROVIDED.
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     DOUBLE PRECISION PHAS(NF)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION PI, PIT2
!        THE VALUE OF PI AND PI*2.
!     DOUBLE PRECISION SN
!        AN ARGUMENT USED IN THE COMPUTATION OF THE SPECTRUM.
!     DOUBLE PRECISION SPCF1(NF), SPCF2(NF)
!        THE UNIVARIATE SPECTRUM FOR EACH SERIES.
!     DOUBLE PRECISION V0, V1, V2
!        ARGUMENTS USED IN THE COMPUTATION OF THE SPECTRUM.
!     DOUBLE PRECISION W(LW)
!        THE WINDOW.
!     DOUBLE PRECISION XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION Z0, Z1, Z2
!        ARGUMENTS USED IN THE COMPUTATION OF THE SPECTRUM.
!
!
      CALL GETPI(PI)
      PIT2 = PI*2.0D0
!
      FPSPM = D1MACH(1)
      FPLM = D1MACH(2)
      FPLRS = D1MACH(4)
!
      FAC = 180.0D0/PI
!
!
!     COMPUTE SMOOTHED CO-SPECTRAL ESTIMATE
!
      DO 40 I=1,NF
!
!           COMPUTE SMOOTHED CO- AND QUADRATURE SPECTRA USING
!           THE ALGORITHM SHOWN ON PAGE 420 OF JENKINS AND WATTS
!
         IF (FREQ(I).EQ.0.0D0) THEN
            C = 1.0D0
            SN = 0.0D0
         ELSE IF (FREQ(I).EQ.0.25D0) THEN
            C = 0.0D0
            SN = 1.0D0
         ELSE IF (FREQ(I).EQ.0.5D0) THEN
            C = -1.0D0
            SN = 0.0
         ELSE
            ARG = PIT2*FREQ(I)
            C = COS(ARG)
            SN = SIN(ARG)
         END IF
         V0 = 0.0D0
         V1 = 0.0D0
         Z0 = 0.0D0
         Z1 = 0.0D0
         DO 10 K=LAG-1,1,-1
            V2 = 2.0D0*C*V1 - V0 + W(K+1)*CEVEN(K+1)
            Z2 = 2.0D0*C*Z1 - Z0 + W(K+1)*CODD(K+1)
            V0 = V1
            V1 = V2
            Z0 = Z1
            Z1 = Z2
   10    CONTINUE
         BARL = DELTA*(CEVEN(1)+2.0D0*(V1*C-V0))
         BARQ = 2.0D0*DELTA*Z1*SN
!
!     COMPUTE THE SMOOTHED SQUARED COHERENCY SPECTRA
!
         IF (SPCF1(I)*SPCF2(I).GT.0.0D0) THEN
            CSPC2(I) = (BARL*BARL+BARQ*BARQ)
            CSPC2(I) = CSPC2(I)/(SPCF1(I)*SPCF2(I))
         ELSE
            CSPC2(I) = FPLM
         END IF
!
!     COMPUTE PHASE (IN RADIANS)
!
         IF ((BARQ.NE.0.0D0) .OR. (BARL.NE.0.0D0)) THEN
            PHAS(I) = ATAN2(-BARQ,BARL)
         ELSE
            IF (I.EQ.1) THEN
               PHAS(I) = 0.0D0
            ELSE
               PHAS(I) = SIGN(PI,PHAS(I-1))
            END IF
         END IF
   40 CONTINUE
!
      IF (NPRT.EQ.0) RETURN
!
!     COMPUTE SMOOTHED SQUARED COHERENCY PLOT VECTORS
!
      CI = PPFNML(ALPHA)*SQRT(1.0D0/DF)
      G = 2.0D0/DF
      G = 1.0D0 - (1.0D0-ALPHA)**(G/(1.0D0-G))
      NPTS = 0
      DO 60 I=1,NF
         NPTS = NPTS + 1
!
!     COMPUTE 95 PER CENT SIGNIFICANCE LEVEL
!
         YAXIS(NPTS) = G
         XAXIS(NPTS) = FREQ(I)
         ISYM(NPTS) = 4
         IF (SPCF1(I)*SPCF2(I).LE.0.0D0) GO TO 60
!
!     COMPUTE COHERENCE SPECTRAL ESTIMATE
!
         IF (CSPC2(I).GT.1.0D0) GO TO 60
         NPTS = NPTS + 1
         YAXIS(NPTS) = CSPC2(I)
         XAXIS(NPTS) = FREQ(I)
         ISYM(NPTS) = 1
         IF (CSPC2(I).LT.G) GO TO 60
!
!     COMPUTE CONFIDENCE INTERVAL
!
         BARY = SQRT(CSPC2(I))
         BARY = 0.5D0*(LOG((1.0D0+BARY)/(1.0D0-BARY)))
         NPTS = NPTS + 1
         YAXIS(NPTS) = (TANH(BARY+CI))*(TANH(BARY+CI))
         XAXIS(NPTS) = FREQ(I)
         ISYM(NPTS) = 2
         NPTS = NPTS + 1
         YAXIS(NPTS) = (TANH(BARY-CI))*(TANH(BARY-CI))
         XAXIS(NPTS) = FREQ(I)
         ISYM(NPTS) = 2
   60 CONTINUE
!
      RETURN
!
      END
!BFSMS
      SUBROUTINE BFSMS (Y1, YMISS1, Y2, YMISS2, N, NW, LAGS, NF, FMIN,
     +   FMAX, NPRT, CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
!     FOURIER SPECTRUM ANALYSIS OF SERIES WITH MISSING OBSERVATIONS
!     (LONG CALL)
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN,YMISS1,YMISS2
      INTEGER
     +   ICSPC2,IPHAS,LDSTAK,N,NF,NPRT,NW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CSPC2(*),FREQ(*),PHAS(*),Y1(*),Y2(*)
      INTEGER
     +   LAGS(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA
      INTEGER
     +   CCOV,CEVEN,CODD,I,ICCOV,IFP,INDEX1,INDEX2,INLPPC,IO,IPRT,
     +   ISYM,JCCOV,JNLPPC,LAGMAX,LAGMX1,LDSMIN,LPCV,LW,LWORK,LY,M,
     +   NALL0,NLPPC,SPCF1,SPCF2,W,WORK,XAXIS,YAXIS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,ECVF,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     INTEGER CCOV
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE COVARIANCES.
!     INTEGER CEVEN
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     INTEGER CODD
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CSPC2(ICSPC2,NW)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC
!        THE STARTING LOCATION IN THE WORK AREA FOR NLPPC
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION PHAS(IPHAS,NW)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SPCF1, SPCF2
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     INTEGER W
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE WINDOWS.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR THE VECTOR WORK.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YMISS1, YMISS2
!        DUMMY VARIABLES.
!     DOUBLE PRECISION Y1(N)
!        THE FIRST TIME SERIES.
!     DOUBLE PRECISION Y2(N)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','M','S',' '/
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(1) = .FALSE.
      OPTION(2) = .TRUE.
      OPTION(3) = .FALSE.
      OPTION(4) = .TRUE.
!
!     SET MAXIMUM LAG VALUE TO BE USED (LAGMAX).
!
      LAGMAX = N - 1
      IF (NW.LE.0) GO TO 20
      LAGMAX = LAGS(1)
      DO 10 I=1,NW
         LAGMAX = MAX(LAGMAX,LAGS(I))
   10 CONTINUE
   20 CONTINUE
      LAGMX1 = LAGMAX + 1
!
      ICCOV = LAGMAX + 1
      JCCOV = 2
      INLPPC = LAGMAX + 1
      JNLPPC = 2
      M = 2
      INDEX1 = 1
      INDEX2 = 2
!
!     COMPUTE THE MINIMUM ALLOWABLE STACK AREA (LDSMIN)
!
      IO = 1
      IF (NPRT.EQ.0) IO = 0
!
      CALL LDSCMP(10, 0, 4*LAGMAX + 4 + IO*4*NF, 0, 0, 0, 'D',
     +  7*LAGMAX+7+2*NF+IO*8*NF, LDSMIN)
!
      LY = N
      LPCV = 4*NF
      LW = LAGMX1
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING STACK ALLOCATIONS (NALL0).
!     SET THE STACK ALLOCATION TYPE (IFP)
!
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
!
      IFP = 4
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS
!
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         CCOV = 1
         NLPPC = 1
         CEVEN = 1
         CODD = 1
         SPCF1 = 1
         SPCF2 = 1
         W = 1
!
         ISYM = 1
         XAXIS = 1
         YAXIS = 1
      ELSE
         CCOV = STKGET(4*LAGMX1,IFP)
         NLPPC = STKGET(4*LAGMX1,2)
         CEVEN = STKGET(LAGMX1,IFP)
         CODD = STKGET(LAGMX1,IFP)
         SPCF1 = STKGET(NF,IFP)
         SPCF2 = STKGET(NF,IFP)
         W = STKGET(LW,IFP)
         IF (NPRT.EQ.0) THEN
            ISYM = W
            XAXIS = W
            YAXIS = W
         ELSE
            ISYM = STKGET(LPCV,2)
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
         END IF
      END IF
!
      WORK = W
      LWORK = LW
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
      CALL BFSDRV(Y1, Y2, YMISS1, YMISS2, RSTAK(CCOV), ISTAK(NLPPC),
     +   RSTAK(SPCF1), RSTAK(SPCF2), NF, FMIN, FMAX, FREQ, N, NW,
     +   LAGMAX, LAGS, LAGMX1, RSTAK(WORK), LWORK, DELTA, ISTAK(ISYM),
     +   RSTAK(XAXIS), RSTAK(YAXIS), LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS,
     +   RSTAK(CODD), RSTAK(CEVEN), RSTAK(W), LW, NMSUB, LDSMIN,
     +   LDSTAK, OPTION, N, INLPPC, JNLPPC, LY)
!
      CALL STKCLR(NALL0)
!
!     CHECK FOR ERRORS
!
      IF (IERR.NE.0) THEN
        IF (IERR.EQ.2) CALL ECVF(NMSUB)
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL BFSMS (Y1, YMISS1, Y2, YMISS2, N,'/
     +  '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +  '      +            CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)')
      END
!SRTIRR
      SUBROUTINE SRTIRR(IR, RR, LA, A)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SORTS THE LENGTH LA ARRAY A, THE LENGTH LA
!     INTEGER ARRAY IR, AND THE LENGTH LA ARRAY RR INTO
!     ASCENDING ORDER, BASED ON THE VALUES IN A.  THE ARRAY
!     A CONSTITUTES THE SORTING KEY.  THE OTHER TWO ARRAYS ARE
!     CARRIED ALONG.  ORDINARILY THE ARRAY IR CONTAINS THE
!     VALUES 1, ..., LA INITIALLY, SO THAT THE THREE ARRAYS CAN
!     LATER BE SORTED AGAIN WITH IR AS THE KEY, IN ORDER TO
!     RESTORE A AND RR TO THEIR ORIGINAL ORDER.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!        (BASED CLOSELY ON THE IMSL CDC LIBRARY 3 ROUTINE VSORTP)
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LA
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   A(LA),RR(LA)
      INTEGER
     +   IR(LA)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   R,RT,RTT,T,TT
      INTEGER
     +   I,IJ,IT,ITT,J,K,L,M
!
!  LOCAL ARRAYS
      INTEGER
     +   IL(21),IU(21)
!
!  INTRINSIC FUNCTIONS
      INTRINSIC INT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION A(LA)
!        INPUT/OUTPUT PARAMETER.  THE KEY ARRAY.
!     INTEGER I
!        *
!     INTEGER IJ
!        *
!     INTEGER IL(21)
!        *
!     INTEGER IR(LA)
!        INPUT/OUTPUT PARAMETER.  THE INTEGER ARRAY CARRIED ALONG
!        IN THE SORT.  INITIALLY IT SHOULD CONTAIN 1, ..., LA.
!        ON EXIT IT CONTAINS THE PERMUTATION VECTOR OF THE SORT.
!        SORTING ON THE PERMUTATION VECTOR WILL RESTORE THE KEY
!        ARRAY A AND THE ARRAY RR TO THEIR ORIGINAL ORDERS.
!     INTEGER IT
!        *
!     INTEGER ITT
!        *
!     INTEGER IU(21)
!        *
!     INTEGER J
!        *
!     INTEGER K
!        *
!     INTEGER L
!        *
!     INTEGER LA
!        INPUT PARAMETER.  THE LENGTH OF THE INPUT/OUTPUT PARAMETERS
!        A, IR, AND RR.
!     INTEGER M
!        *
!     DOUBLE PRECISION R
!        *
!     DOUBLE PRECISION RR(LA)
!        INPUT/OUTPUT PARAMETER.  THE ARRAY CARRIED ALONG IN
!        THE SORT.  IT MIGHT BE THE SET OF WEIGHTS FOR A.
!     DOUBLE PRECISION RT
!        *
!     DOUBLE PRECISION RTT
!        *
!     DOUBLE PRECISION T
!        *
!     DOUBLE PRECISION TT
!
      M = 1
      I = 1
      J = LA
      R = .375D0
   10 IF (I.EQ.J) GO TO 90
      IF (R.GT.0.5898437D0) GO TO 20
      R = R + 3.90625D-2
      GO TO 30
   20 R = R - .21875D0
   30 K = I
!                                  SELECT A CENTRAL ELEMENT OF THE
!                                  ARRAY AND SAVE IT IN LOCATION T
      IJ = I + INT((J-I)*R)
      T = A(IJ)
      IT = IR(IJ)
      RT = RR(IJ)
!                                  IF FIRST ELEMENT OF ARRAY IS GREATER
!                                  THAN T, INTERCHANGE WITH T
      IF (A(I).LE.T) GO TO 40
      A(IJ) = A(I)
      A(I) = T
      T = A(IJ)
      IR(IJ) = IR(I)
      IR(I) = IT
      IT = IR(IJ)
      RR(IJ) = RR(I)
      RR(I) = RT
      RT = RR(IJ)
   40 L = J
!                                  IF LAST ELEMENT OF ARRAY IS LESS THAN
!                                  T, INTERCHANGE WITH T
      IF (A(J).GE.T) GO TO 60
      A(IJ) = A(J)
      A(J) = T
      T = A(IJ)
      IR(IJ) = IR(J)
      IR(J) = IT
      IT = IR(IJ)
      RR(IJ) = RR(J)
      RR(J) = RT
      RT = RR(IJ)
!                                  IF FIRST ELEMENT OF ARRAY IS GREATER
!                                  THAN T, INTERCHANGE WITH T
      IF (A(I).LE.T) GO TO 60
      A(IJ) = A(I)
      A(I) = T
      T = A(IJ)
      IR(IJ) = IR(I)
      IR(I) = IT
      IT = IR(IJ)
      RR(IJ) = RR(I)
      RR(I) = RT
      RT = RR(IJ)
      GO TO 60
   50 TT = A(L)
      A(L) = A(K)
      A(K) = TT
      ITT = IR(L)
      IR(L) = IR(K)
      IR(K) = ITT
      RTT = RR(L)
      RR(L) = RR(K)
      RR(K) = RTT
!                                  FIND AN ELEMENT IN THE SECOND HALF OF
!                                  THE ARRAY WHICH IS SMALLER THAN T
   60 L = L - 1
      IF (A(L).GT.T) GO TO 60
!                                  FIND AN ELEMENT IN THE FIRST HALF OF
!                                  THE ARRAY WHICH IS GREATER THAN T
   70 K = K + 1
      IF (A(K).LT.T) GO TO 70
!                                  INTERCHANGE THESE ELEMENTS
      IF (K.LE.L) GO TO 50
!                                  SAVE UPPER AND LOWER SUBSCRIPTS OF
!                                  THE ARRAY YET TO BE SORTED
      IF (L-I.LE.J-K) GO TO 80
      IL(M) = I
      IU(M) = L
      I = K
      M = M + 1
      GO TO 100
   80 IL(M) = K
      IU(M) = J
      J = L
      M = M + 1
      GO TO 100
!                                  BEGIN AGAIN ON ANOTHER PORTION OF
!                                  THE UNSORTED ARRAY
   90 M = M - 1
      IF (M.EQ.0) RETURN
      I = IL(M)
      J = IU(M)
  100 IF (J-I.GE.1) GO TO 30
      IF (I.EQ.1) GO TO 10
      I = I - 1
  110 I = I + 1
      IF (I.EQ.J) GO TO 90
      T = A(I+1)
      IT = IR(I+1)
      RT = RR(I+1)
      IF (A(I).LE.T) GO TO 110
      K = I
  120 A(K+1) = A(K)
      IR(K+1) = IR(K)
      RR(K+1) = RR(K)
      K = K - 1
      IF (T.LT.A(K)) GO TO 120
      A(K+1) = T
      IR(K+1) = IT
      RR(K+1) = RT
      GO TO 110
      END
!XNRAND
      SUBROUTINE XNRAND(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS PROGRAM TESTS FEATURES OF THE NRAND FAMILY TO ENSURE THAT
!     ALL ASPECTS OF THE NRAND FAMILY ROUTINES WORK CORRECTLY.
!
!     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   SIGMA,YMEAN
      INTEGER
     +   I,IPRT,ISEED,N
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   Y(1000)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL HIST,IPRINT,NRAND,NRANDC
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IERR
!        FLAG TO INDICATE PRESENCE OF ERROR DETECTED BY PRECEDING
!        STARPAC CALL.  (0 IS OK, 1 IS ERROR)
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER ISEED
!        THE SEED FOR THE RANDOM NUMBER GENERATOR.
!     INTEGER LDSTAK
!        AMOUNT OF WORK AREA.  SIZE OF DSTAK.
!     INTEGER N
!        THE LENGTH OF THE VECTOR Y.
!     DOUBLE PRECISION SIGMA
!        THE S.D. OF THE SAMPLE.
!     DOUBLE PRECISION Y(1000)
!        DATA VECTOR FOR TESTS.
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE SAMPLE.
!
!
!     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
!
      CALL IPRINT(IPRT)
!
!     CHECK FOR SUFFICIENT WORK AREA LENGTH.
!
      IF (LDSTAK.LT.1000) THEN
        WRITE (IPRT, 1000)
         RETURN
      END IF
!
!     HEADING.
!
      WRITE (IPRT,1150)
!
!     TEST 1.  CHECK ALL ERROR MESSAGES.
!
      WRITE (IPRT,1160)
!
!     ERROR 1, ZERO OR FEWER ELEMENTS OR NEGATIVE STANDARD DEVIATION.
!
      ISEED = 0
      SIGMA = -1
      N = 0
      YMEAN = 0.0D0
      CALL NRAND(Y, N, ISEED)
      WRITE (IPRT,1170) IERR
      CALL NRANDC(Y, N, ISEED, YMEAN, SIGMA)
      WRITE (IPRT,1170) IERR
!
!     COMPARE RESULTS
!
      ISEED = 334
      N = 10
      YMEAN = 0.0D0
      SIGMA = 1.0D0
!
      WRITE (IPRT, 1120) N, ISEED
      CALL NRAND (Y, N, ISEED)
      WRITE (IPRT, 1100) (Y(I),I=1,N)
!
      ISEED = 333
      WRITE (IPRT, 1130) N, YMEAN, SIGMA, ISEED
      CALL NRANDC (Y, N, ISEED, YMEAN, SIGMA)
      WRITE (IPRT, 1100) (Y(I),I=1,N)
!
      ISEED = 13531
      N = 1000
      YMEAN = 0.0D0
      SIGMA = 1.0D0
!
      WRITE (IPRT, 1120) N, ISEED
      CALL NRAND (Y, N, ISEED)
      CALL HIST (Y, N, LDSTAK)
!
      WRITE (IPRT, 1130) N, YMEAN, SIGMA, ISEED
      CALL NRANDC (Y, N, ISEED, YMEAN, SIGMA)
      CALL HIST (Y, N, LDSTAK)
!
      ISEED = 99999
      N = 1000
      YMEAN = 4.0D0
      SIGMA = 4.0D0
!
      WRITE (IPRT, 1120) N, ISEED
      CALL NRAND (Y, N, ISEED)
      CALL HIST (Y, N, LDSTAK)
!
      WRITE (IPRT, 1130) N, YMEAN, SIGMA, ISEED
      CALL NRANDC (Y, N, ISEED, YMEAN, SIGMA)
      CALL HIST (Y, N, LDSTAK)
!
      RETURN
!
!     FORMATS
!
 1000 FORMAT ('1THE DIMENSION OF DSTAK AND THE VALUE OF LDSTAK NEEDED'/
     +  ' FOR NRANDX MUST EQUAL OR EXCEED 1000.  CHANGE DRIVER'/
     +  ' AND RECALL NRANDX.')
 1100 FORMAT (5E15.8)
 1120 FORMAT ('1GENERATE ', I4,
     +  ' STANDARD NORMAL NUMBERS USING ISEED = ', I5)
 1130 FORMAT ('1GENERATE ', I4,
     +  ' NORMALLY DISTRIBUTED NUMBERS WITH YMEAN = ', F5.2,
     +  ' AND SIGMA = ', F5.2, ' USING ISEED = ', I5)
 1150 FORMAT ('1TEST RUNS FOR THE NRAND FAMILY OF ROUTINES.')
 1160 FORMAT(' TEST 1.  GENERATE EACH OF THE POSSIBLE ',
     +   15HERROR MESSAGES.)
 1170 FORMAT(/22H THE VALUE OF IERR IS , I4//)
      END
!UASF
      SUBROUTINE UASF (YFFT, N, LYFFT, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
!     SPECTRUM ESTIMATION USING THE FFT (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,LYFFT,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YFFT(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,VAR,YMEAN
      INTEGER
     +   IAR,IFP,IPRT,LACOV,LAG,LAGMAX,LAIC,LDSMIN,LPCV,LPHI,LSPC,
     +   LWORK,NALL0,NF,NFFT,NPRT,WORK
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),AIC(101),FREQ(101),FTEST(2,100),PHI(100),RSTAK(12),
     +   SPCA(101),SPCF(101),XAXIS(207),YAXIS(207)
      INTEGER
     +   ISORT(101),ISTAK(12),ISYM(207)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACVFF,IPRINT,LDSCMP,PARZEN,SETESL,SETLAG,STKCLR,STKSET,
     +   UASDV,UASER
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (ISYM(1),ISORT(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(101)
!        THE AUTOCOVARIANCE COMPUTED FROM THE LAG PRODUCT PAIRS.
!     DOUBLE PRECISION AIC(101)
!        THE ARRAY CONTAINING AKIAKES CRITERIA FOR EACH ORDER.
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
!        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     DOUBLE PRECISION FTEST(2, 100)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LSPC
!         THE LENGTH OF THE SPECTRUM ARRAYS.
!     INTEGER ISYM(207)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE COVARIANCE ARRAYS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE ARRAY AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER LWORK
!        THE LENGTH OF THE WORK ARRAY.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
!        THIS ROUTINE WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
!        ARE TO BE ESTIMATED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE TYPE OF WINDOW TO BE USED.
!     DOUBLE PRECISION PHI(100)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION SPCA(101)
!        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!     DOUBLE PRECISION SPCF(101)
!        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
!     DOUBLE PRECISION VAR
!        THE ONE STEP PREDICTION VARIANCE.
!     INTEGER WORK
!        THE STARTING LOCATION IN RSTAK FOR
!        THE WORK VECTOR.
!     DOUBLE PRECISION XAXIS(207)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YAXIS(207)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YFFT(LYFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'U',       'A',       'S',       'F',       ' ',       ' '/
!
      IFP = 4
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(1) = .TRUE.
      OPTION(2) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(4) = .FALSE.
!
      LAG = 0
      IAR = 0
      NF = 101
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = -1
!
!     SET THE MAXIMUM NUMBER OF LAGS TO BE USED.
!
      CALL SETLAG(N, LAGMAX)
!
!     SET LENGTH OF EXTENDED SERIES
!
      CALL SETESL(N+LAGMAX, 4, NFFT)
!
      CALL LDSCMP(1, 0, 0, 0, 0, 0, 'D', NFFT, LDSMIN)
!
      CALL UASER(NMSUB, N, ACOV, IAR, PHI, LAGMAX, LAG, LACOV,
     +   NF, LDSTAK, LDSMIN, LYFFT, NFFT, OPTION)
!
      IF (IERR.NE.0) THEN
         IERR = 1
         CALL IPRINT (IPRT)
         WRITE (IPRT, 1000)
         RETURN
      END IF
!
!     SET THE SIZE OF THE WORK AREA
!
      CALL STKSET(LDSTAK, 4)
!
!     SAVE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
!
      NALL0 = STKST(1)
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      LPCV = 207
      LSPC = 101
      LPHI = 100
      LAIC = 101
      LACOV = 101
      LWORK = NFFT
!
      ALPHA = 0.95D0
      DELTA = 1.0D0
!
!     SUBDIVIDE THE WORK AREA
!
      WORK = STKGET(LWORK, IFP)
!
!     COMPUTE AUTOCOVARIANCES
!
      CALL ACVFF (YFFT, N, NFFT, YMEAN, ACOV, LAGMAX, LACOV, LYFFT,
     +   RSTAK(WORK), LWORK)
!
!     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
!
      CALL UASDV(ACOV, SPCA, SPCF, LSPC, IAR, PHI, NF, FMIN, FMAX, FREQ,
     +   N, LAGMAX, FTEST, AIC, RSTAK(WORK), LACOV, LWORK, DELTA, ISORT,
     +   ISYM, XAXIS, YAXIS, LPCV, ALPHA, LAG, LAIC, LPHI, NPRT, VAR,
     +   PARZEN, NMSUB)
!
      CALL STKCLR(NALL0)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL UASF (YFFT, N, LYFFT, LDSTAK)')
      END
!ERAGT
      SUBROUTINE ERAGT (NMSUB, NMVAR, YM, N, M, IYM, YMMN, NVMX,
     +   HEAD, MSGTYP, NV, ERROR, NMMIN)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS TO ENSURE THAT NO VALUES, OR ONLY A MAXIMUM
!     OF NVMX, ARE NOT GREATER THAN A SPECIFIED LOWER BOUND YMMN,
!     WITH NAME NMMIN.   THE CHECKING OPTION IS SPECIFIED
!     WITH MSGTYP.  IF AN ERROR IS FOUND, THE ERROR IS PRINTED AND
!     AN ERROR FLAG AND THE NUMBER OF VIOLATINS ARE RETURNED.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMMN
      INTEGER
     +   IYM,M,MSGTYP,N,NV,NVMX
      LOGICAL
     +   ERROR,HEAD
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
!
!  LOCAL SCALARS
      INTEGER
     +   I,J
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ERAGTP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IYM
!        THE FIRST DIMENSION OF THE ARRAY YM.
!     INTEGER J
!        AN INDEXING VARIABLE.
!     INTEGER M
!        THE NUMBER OF COLUMNS OF DATA IN YM.
!     INTEGER MSGTYP
!        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
!        IF (MSGTYP.GE.3) THE MESSAGE PRINTED WILL USE NMMIN
!        OTHERWISE IT WILL USE YMMN.
!        IF (MSGTYP = 1 OR 3) NO VIOLATIONS ARE ALLOWED.
!        IF (MSGTYP = 2 OR 4) THE NUMBER OF VIOLATIONS MUST
!                             BE LESS THAN   NVMX   .
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE PARAMETERS NAME.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND.
!     INTEGER NVMX
!        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
!     DOUBLE PRECISION YM(IYM,M)
!        THE ARRAY BEING TESTED.
!     DOUBLE PRECISION YMMN
!        THE MINIMUM ACCEPTABLE VALUE.
!
      ERROR = .FALSE.
!
      IF ((N.LE.0) .OR. (M.LE.0)) RETURN
!
!     CHECK FOR VIOLATIONS
!
      NV = 0
      DO 5 I = 1, N
         DO 1 J = 1, M
            IF (YM(I+(J-1)*IYM) .LE. YMMN) NV = NV + 1
    1    CONTINUE
    5 CONTINUE
!
      IF (NV .LE. NVMX) RETURN
!
!     VIOLATIONS FOUND
!
      ERROR = .TRUE.
!
      CALL ERAGTP (NMSUB, NMVAR, YMMN, NVMX, HEAD, MSGTYP, NV,
     +   NMMIN)
!
      RETURN
!
      END
!LLSS
      SUBROUTINE LLSS(Y, XM, N, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CALL FOR GENERAL LINEAR MODEL LEAST SQUARES FIT
!     NO WEIGHTS SPECIFIED
!     FULL STORAGE
!     USER CONTROL OF AUTOMATIC PRINTOUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,IXM,LDSTAK,N,NPAR,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SDPV(*),SDRES(*),VCV(*),XM(*),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,LPAR,LPV,LSDPV,LSDRES,LWT
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   WT(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLCNTG
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     DOUBLE PRECISION PAR(NPAR)
!        THE PARAMETERS  TO BE ESTIMATED.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUES.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION SDPV(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(N)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(1)
!        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
!     DOUBLE PRECISION XM(IXM,NPAR)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'L','L','S','S',' ',' '/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      WEIGHT = .FALSE.
      SAVE = .TRUE.
      LPAR = NPAR
      LPV = N
      LSDPV = N
      LSDRES = N
      LWT = 1
!
      CALL LLCNTG(Y, WT, LWT, XM, N, IXM, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (//42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL LLSS (Y, XM, N, IXM, NPAR, RES, LSDTAK,'/
     +  '      +           NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)')
      END
!SVPC
      SUBROUTINE SVPC(YM, N, NS, ISYM, ILOG, ISIZE, IRLIN, IBAR,
     +   YLB, YUB, XLB, XINC)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH USER CONTROL OF THE PLOT SYMBOLS USED (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IRLIN,ISIZE,N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
      INTEGER
     +   ISYM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,ISCHCK,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'V',       'P',       'C',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      M = 1
      IYM = N
      MULTI = .FALSE.
      ISCHCK = 1
      MISS = .FALSE.
      LISYM = N
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YM, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL SVPC (Y, N, NS, ISYM, ILOG,'/
     +  '      +           ISIZE, IRLIN, IBAR, YLB, YUB, XLB, XINC)')
      END
!STATS
      SUBROUTINE STATS(Y, N, LDSTAK, STS, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES 53 DIFFERENT STATISTICS FOR A VECTOR
!     Y, WITH NO WEIGHTS SPECIFIED.  ONE PAGE OF AUTOMATIC
!     PRINTOUT IS PRODUCED.
!
!     WRITTEN BY - JANET R. DONALDSON, JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!        (EXTENSIVE REVISION OF OLDER VERSION)
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   STS(53),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,SUMD2,SUMD3,SUMD4,SUMDA,SUMDI,SUMT1
      INTEGER
     +   IDP,IINT,IPRT,LSORT,MID,NALL0,NNZW
      LOGICAL
     +   STACK,WTS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   WT(1)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GENI,IPRINT,SRTIR,SRTRI,STAT1,STAT2,STATER,STKCLR,STKSET,
     +   SUMBS,SUMDS,SUMID,SUMOT,SUMSS,SUMTS
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        THE PERCENTAGE TO TRIM FROM EACH END IN THE TRIMMED
!        MEANS.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDP
!        FRAMEWORK CODE VALUE FOR DOUBLE PRECISION NUMBERS.
!     INTEGER IERR
!        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
!        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
!        SOME ERROR EXISTS.
!     INTEGER IINT
!        THE CODE VALUE FOR INTEGER FOR FRAMEWORK.
!     INTEGER IPRT
!        THE NUMBER OF THE STANDARD OUTPUT UNIT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
!        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
!     INTEGER LSORT
!        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION
!        VECTOR.
!     INTEGER MID
!        IN THE SORTED ARRAY Y, A POINT EQUAL TO OR THE POINT
!        CLOSEST TO, ZERO.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
!        WAS CALLED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        INPUT PARAMETER.  FLAG TO CONTROL OUTPUT.
!        0 MEANS NO OUTPUT.  OTHER VALUES MEAN OUTPUT.
!     INTEGER NNZW
!        NUMBER OF NONZERO WEIGHTS.
!     LOGICAL STACK
!        A FLAG INDICATING WHETHER THIS ROUTINE USES THE STACK (TRUE)
!        OR NOT (FALSE).
!     DOUBLE PRECISION STS(53)
!        OUTPUT PARAMETER.  THE VECTOR OF THE 53 STATISTICS COMPUTED.
!     DOUBLE PRECISION SUMDA
!        THE SUM OF THE ABSOLUTE VALUES OF THE DIFFERENCES FROM
!        THE MEAN.
!     DOUBLE PRECISION SUMDI
!        THE SUM OF THE PRODUCTS OF THE INDEX AND DIFFERENCES.
!     DOUBLE PRECISION SUMD2
!        THE SUM OF THE SQUARE OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMD3
!        THE SUM OF THE CUBE OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMD4
!        THE SUM OF THE 4TH POWERS OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMT1
!        THE TRIMMED UNWEIGHTED SIMPLE SUM OF ELEMENTS IN Y.
!     DOUBLE PRECISION WT(1)
!        THE DUMMY WEIGHTS VECTOR.
!     LOGICAL WTS
!        A FLAG INDICATING WHETHER THERE ARE WEIGHTS (TRUE)
!        OR NOT (FALSE).
!     DOUBLE PRECISION Y(N)
!        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
!        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
!        TO ITS ORIGINAL ORDER AFTERWARDS.
!
!
!     INITIALIZE NAME VECTORS
!
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'S',      'T',      'A',      'T',      'S',      ' '/
!
      DATA ALPHA /0.25D0/
      DATA IDP /4/
      DATA IINT /2/
      DATA WTS /.FALSE./
      DATA STACK /.TRUE./
!
!     CHECK FOR ERRORS IN THE INPUT PARAMETERS.
!
      CALL STATER(NMSUB, WT, N, LDSTAK, WTS, NNZW, STACK, IERR)
      IF (IERR.NE.0) THEN
!
!     SET UP THE OUTPUT UNIT NUMBER.
!
         CALL IPRINT(IPRT)
         WRITE (IPRT,1000)
         RETURN
      END IF
!
!     SET UP FRAMEWORK AREA
!
      CALL STKSET (LDSTAK, IDP)
      NALL0 = STKST(1)
!
!     SET UP LSORT, THE PERMUTATION VECTOR.
!
      LSORT = STKGET(N,IINT)
      CALL GENI(ISTAK(LSORT), N, 1, 1)
!
!     SORT THE VECTOR Y.
!
      CALL SRTIR(ISTAK(LSORT), N, Y)
!
!     COMPUTE THE STATISTICS WHICH USE A SORTED ARRAY.
!
      CALL STAT1(Y, N, STS(5), STS(34), STS(35), STS(6),
     +   STS(11), 10, 0.0D0, 0.0D0, STS(44))
!
!     CALCULATE SUMS OF THE SORTED ARRAY.
!
      CALL SUMBS(Y, N, 1, MID, N)
      CALL SUMSS(Y, N, 1, MID, N, STS(38), STS(39), STS(42),
     +   STS(3))
      STS(4) = STS(3)
      CALL SUMTS(Y, N, ALPHA, SUMT1, STS(7))
      STS(8) = STS(7)
      CALL SUMDS(Y, N, 1, MID, N, STS(3), SUMDA, SUMD2, SUMD3, SUMD4)
!
!     RESTORE THE VECTOR Y TO ITS ORIGINAL ORDER.
!
      CALL SRTRI(Y, N, ISTAK(LSORT))
!
!     COMPUTE REST OF STATISTICS.
!
      CALL SUMID(Y, N, STS(3), SUMDI)
      CALL STAT2(Y, N, STS, SUMDA, SUMDI, SUMD2, SUMD3, SUMD4)
      IF (NPRT.NE.0) CALL SUMOT(STS, N, N, WTS)
!
!     RETURN THE VECTOR LSORT.
!
      CALL STKCLR(NALL0)
      RETURN
!
!     FORMAT STATEMENTS.
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL STATS (Y, N, LDSTAK, STS, NPRT)')
      END
!PPML
      SUBROUTINE PPML(YM, YMMISS, X, XMISS, N, ILOG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT FOR DATA WITH MISSING OBSERVATIONS (LOG OPTION).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   ILOG,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(1)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   IPRT,ISCHCK,ISIZE,IYM,LISYM,M,NOUT
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'P',       'P',       'M',       'L',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      M = 1
      IYM = N
      MULTI = .FALSE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 0
      ISIZE = -1
      NOUT = 0
      MISS = .TRUE.
      LISYM = 1
!
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL PPML (Y, YMISS, X, XMISS, N, ILOG)')
      END
!XUFS
      SUBROUTINE XUFS(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE FOURIER SPECTRUM ANALYSIS ROUTINES
!
!     SERIES Y IS THE FIRST 50 VALUES OF THE SERIES LISTED ON PAGE
!     318 OF JENKINS AND WATTS.  THE SPECTRUM OF THIS SERIES IS SHOWN
!     FOR VARIOUS BANDWIDTH ON PAGE 270 OF JENKINS AND WATTS.
!
!     SERIES Z IS THE WOLF SUNSPOT NUMBERS FROM 1700 TO 1960 AS
!     TABULATED BY WALDMEIER.  THE RAW AND SMOOTHED PERIODOGRAMS OF
!     TAPERED SERIES ARE SHOWN ON PAGES 95 AND 176, RESPECTIVELY, OF
!     BLOOMFIELD.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   AMISS,FMAX,FMIN,YMISS
      INTEGER
     +   I,IAR,IPRT,ISPCF,J,LACOV,LAGMAX,LDS,LYFFT,NF,NPRT,NW,NY
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),FREQ(300),PHI(100),SPCF(101,4),Y(150),YFFT(400)
      INTEGER
     +   LAGS(4),NLPPA(101)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACFMS,ACFS,IPRINT,NRAND,DCOPY,SETRV,UFS,UFSF,UFSFS,UFSM,
     +   UFSMS,UFSMV,UFSMVS,UFSS,UFSV,UFSVS
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(101)
!        THE AUTOCOVARIANCE VECTOR.
!     DOUBLE PRECISION AMISS
!         THE MISSING VALUE CODE FOR THE RETURNED ACVF ESTIMATES.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCIES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(300)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE MODEL TO BE USED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISPCF
!         THE ACTUAL DIMENSION FOR THE SPECTRUM ARRAYS.
!     INTEGER J
!        INDEX VARIABLE.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCOVARIANCE BEING COMPUTED AND THE MAXIMUM LAG TO BE USED,
!        RESPECTIVELY.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDS
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(101)
!        THE NUMBERS OF LAGGED PRODUCT PAIRS USED FOR EACH ACVF.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT = 0 THE PLOT IS SUPPRESSED, IF
!        NPRT = 2 THE PLOT IS DECIBELS/LINEAR, IF
!        NPRT = 2 THE PLOT IS LOG/LINEAR, IF
!        NPRT = 3 THE PLOT IS DECIBELS/LOG, AND IF
!        NPRT = 4 THE PLOT IS LOG/LOG.
!     INTEGER NW
!        THE NUMBER OF DIFFERENT LAG WINDOW TRUNCATION POINTS SPECIFIED,
!        AND THEREFORE, THE NUMBER OF PLOTS.
!     INTEGER NY
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     DOUBLE PRECISION PHI(100)
!        THE VECTOR OF THE ORDER IAR AUTOREGRESSIVE MODEL COEFFICIENTS.
!     DOUBLE PRECISION SPCF(101, 4)
!        THE ARRAYS IN WHICH THE FOURIER SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     DOUBLE PRECISION Y(150)
!         THE ARRAY CONTAINING THE TIME SERIES FROM JENKINS AND WATTS.
!     DOUBLE PRECISION YFFT(400)
!        THE VECTOR OF THE OBSERVED TIME SERIES TO BE ANALYZED USING
!        THE FFT.
!     DOUBLE PRECISION YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!
!
      DATA   Y(  1), Y(  2), Y(  3), Y(  4), Y(  5), Y(  6)
     +    /-0.88D0, -0.12D0, -0.89D0, -1.38D0, -0.07D0,  1.03D0/
      DATA   Y(  7), Y(  8), Y(  9), Y( 10), Y( 11), Y( 12)
     +    / 2.14D0,  0.35D0, -1.10D0, -1.78D0, -2.76D0, -1.77D0/
      DATA   Y( 13), Y( 14), Y( 15), Y( 16), Y( 17), Y( 18)
     +    / 0.98D0,  1.00D0, -0.70D0, -1.01D0, -1.30D0, -0.85D0/
      DATA   Y( 19), Y( 20), Y( 21), Y( 22), Y( 23), Y( 24)
     +    /-0.46D0,  1.63D0,  0.06D0, -0.17D0, -1.01D0, -1.04D0/
      DATA   Y( 25), Y( 26), Y( 27), Y( 28), Y( 29), Y( 30)
     +    /-0.66D0, -1.12D0, -0.51D0, -0.71D0, -0.20D0, -0.13D0/
      DATA   Y( 31), Y( 32), Y( 33), Y( 34), Y( 35), Y( 36)
     +    / 0.14D0,  1.59D0, -0.76D0, -1.08D0, -1.77D0, -1.20D0/
      DATA   Y( 37), Y( 38), Y( 39), Y( 40), Y( 41), Y( 42)
     +    / 0.45D0, -0.07D0, -0.63D0, -0.35D0, -0.87D0, -0.62D0/
      DATA   Y( 43), Y( 44), Y( 45), Y( 46), Y( 47), Y( 48)
     +    / 0.28D0,  1.90D0,  2.14D0,  1.05D0,  0.31D0,  1.07D0/
      DATA   Y( 49), Y( 50)
     +    / 2.67D0,  2.44D0/
!
      CALL IPRINT(IPRT)
!
!     CHECK ERROR HANDLING
!
!        TEST 1  -  MISCELANEOUS ERROR CHECKING
!
      WRITE (IPRT, 2000)
      YMISS = 1.16D0
      LAGMAX = -1
      NY = -10
      LACOV = 101
      LYFFT = -11
      NW = -1
      NF = -5
      FMIN = 0.5D0
      FMAX = 0.0D0
      NPRT = -1
      ISPCF = -20
      LDS = 0
      WRITE(IPRT, 1001)
      CALL UFS (Y, NY)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1003)
      CALL UFSS(Y, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1019)
      CALL UFSF (YFFT, NY, LYFFT, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1020)
      CALL UFSFS(YFFT, NY, LYFFT, LDS, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   SPCF, ISPCF, FREQ)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1005)
      CALL UFSM (Y, YMISS, NY)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1006)
      CALL UFSMS(Y, YMISS, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1007)
      CALL UFSV(ACOV, LAGMAX, NY)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1008)
      CALL UFSVS (ACOV, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1021)
      CALL UFSMV(ACOV, NLPPA, LAGMAX, NY)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1022)
      CALL UFSMVS (ACOV, NLPPA, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!        TEST 2  -  MISCELANEOUS ERROR CHECKING (CONTINUED)
!
      WRITE (IPRT, 2010)
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 55
      LYFFT = -11
      NW = 2
      LAGS(1) = 0
      LAGS(2) = 50
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 3
      ISPCF = 20
      LDS = 0
      WRITE(IPRT, 1003)
      CALL UFSS(Y, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1019)
      CALL UFSF (YFFT, NY, LYFFT, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1020)
      CALL UFSFS(YFFT, NY, LYFFT, LDS, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   SPCF, ISPCF, FREQ)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1006)
      CALL UFSMS(Y, YMISS, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1008)
      CALL UFSVS (ACOV, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1022)
      CALL UFSMVS (ACOV, NLPPA, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!        TEST 3  -  LDS TOO SMALL
!
      WRITE (IPRT, 2030)
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      NW = 2
      LAGS(1) = 0
      LAGS(2) = 50
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 3
      ISPCF = 101
      LDS = 0
      WRITE(IPRT, 1003)
      CALL UFSS(Y, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1019)
      CALL UFSF (YFFT, NY, LYFFT, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1020)
      CALL UFSFS(YFFT, NY, LYFFT, LDS, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   SPCF, ISPCF, FREQ)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1006)
      CALL UFSMS(Y, YMISS, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1008)
      CALL UFSVS (ACOV, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1022)
      CALL UFSMVS (ACOV, NLPPA, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!        TEST 4  -  ALL DATA AND COVARIANCES MISSING
!
      WRITE (IPRT, 2040)
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 3
      ISPCF = 101
      LDS = 700
      CALL SETRV(YFFT, NY, YMISS)
      CALL SETRV(ACOV, LAGMAX, 0.0D0)
      DO 5 I = 1, LAGMAX
         NLPPA(I) = 0
    5 CONTINUE
      WRITE (IPRT, 1005)
      CALL UFSM(YFFT, YMISS, NY)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1006)
      CALL UFSMS(YFFT, YMISS, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1021)
      CALL UFSMV (ACOV, NLPPA, LAGMAX, NY)
      WRITE (IPRT, 1002) IERR
      WRITE (IPRT, 1022)
      CALL UFSMVS (ACOV, NLPPA, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!        TEST 5  -  EVERY OTHER VALUE MISSING
!
      WRITE (IPRT, 2050)
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 3
      ISPCF = 101
      LDS = 700
      CALL SETRV(YFFT, NY, YMISS)
      DO 10 I = 1, NY, 2
         YFFT(I) = Y(I)
   10 CONTINUE
      WRITE (IPRT, 1005)
      CALL UFSM(YFFT, YMISS, NY)
      WRITE (IPRT, 1002) IERR
      WRITE(IPRT, 1006)
      CALL UFSMS(YFFT, YMISS, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!     CHECK RESULTS FROM VALID CALL
!
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 2
      ISPCF = 101
      LDS = LDSTAK
!
!     TEST OF UFS
!
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1001)
      CALL UFS (Y, NY)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF UFSS
!
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1003)
      CALL UFSS(Y, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM UFSS
!
      WRITE (IPRT, 1004) (FREQ(I), (SPCF(I,J),J=1,NW), I=1,NF)
!
!     TEST OF UFSF
!
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1019)
      CALL DCOPY(NY, Y, 1, YFFT, 1)
      CALL UFSF (YFFT, NY, LYFFT, LDS)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF UFSFS
!
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1020)
      CALL DCOPY(NY, Y, 1, YFFT, 1)
      CALL UFSFS(YFFT, NY, LYFFT, LDS, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   SPCF, ISPCF, FREQ)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM UFSFS
!
      WRITE (IPRT, 1004) (FREQ(I), (SPCF(I,J),J=1,NW), I=1,NF)
!
!     TEST OF UFSM
!
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1005)
      CALL UFSM (Y, YMISS, NY)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF UFSMS
!
      WRITE(IPRT, 2020)
      WRITE(IPRT, 1006)
      CALL UFSMS(Y, YMISS, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM UFSMS
!
      WRITE (IPRT, 1004) (FREQ(I), (SPCF(I,J),J=1,NW), I=1,NF)
!
!     TEST OF UFSV
!
      WRITE(IPRT, 2020)
      CALL ACFS (Y, NY, LAGMAX, LACOV, ACOV, IAR, PHI, 0, LDS)
      WRITE (IPRT, 1007)
      CALL UFSV(ACOV, LAGMAX, NY)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF UFSVS
!
      WRITE(IPRT, 2020)
      WRITE (IPRT, 1008)
      CALL UFSVS (ACOV, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM UFSVS
!
      WRITE (IPRT, 1004) (FREQ(I), (SPCF(I,J),J=1,NW), I=1,NF)
!
!     TEST OF UFSMV
!
      WRITE(IPRT, 2020)
      CALL ACFMS (Y, YMISS, NY, LAGMAX, LACOV, ACOV, AMISS, NLPPA,
     +   0, LDS)
      WRITE (IPRT, 1021)
      CALL UFSMV(ACOV, NLPPA, LAGMAX, NY)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF UFSMVS
!
      WRITE(IPRT, 2020)
      WRITE (IPRT, 1022)
      CALL UFSMVS (ACOV, NLPPA, LAGMAX, NY, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM UFSMVS
!
      WRITE (IPRT, 1004) (FREQ(I), (SPCF(I,J),J=1,NW), I=1,NF)
!
!     MINIMUM PROBLEM SIZE
!
      YMISS = 1.16D0
      NY = 17
      LAGMAX = 1
      LYFFT = 400
      NW = 2
      LAGS(1) = 1
      LAGS(2) = 16
      NF = 1
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 2
      ISPCF = 101
      LDS = 700
!
!     TEST OF UFS
!
      WRITE (IPRT, 2060)
      WRITE(IPRT, 1001)
      CALL UFS (Y, NY)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF UFSS
!
      WRITE(IPRT, 2060)
      WRITE(IPRT, 1003)
      CALL UFSS(Y, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM UFSS
!
      WRITE (IPRT, 1004) (FREQ(I), (SPCF(I,J),J=1,NW), I=1,NF)
!
!     CHECK HANDLING OF FMIN AND FMAX
!
      YMISS = 1.16D0
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 51
      FMIN = 0.45D0
      FMAX = 0.5D0
      NPRT = 2
      ISPCF = 101
      LDS = 700
!
!     TEST OF UFSS
!
      WRITE(IPRT, 2070)
      WRITE(IPRT, 1003)
      CALL UFSS(Y, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM UFSS
!
      WRITE (IPRT, 1004) (FREQ(I), (SPCF(I,J),J=1,NW), I=1,NF)
!
!     WHITE NOISE SPECTRUM
!
      YMISS = 1.16D0
      CALL NRAND(YFFT, NY, 12345)
      NY = 50
      LAGMAX = 49
      LYFFT = 400
      NW = 2
      LAGS(1) = 8
      LAGS(2) = 16
      NF = 51
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = 2
      ISPCF = 101
      LDS = 700
!
!     TEST OF UFSS
!
      WRITE(IPRT, 2080)
      WRITE(IPRT, 1003)
      CALL UFSS(YFFT, NY, NW, LAGS, NF, FMIN, FMAX, NPRT, SPCF,
     +   ISPCF, FREQ, LDS)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VALUES FROM UFSS
!
      WRITE (IPRT, 1004) (FREQ(I), (SPCF(I,J),J=1,NW), I=1,NF)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1001 FORMAT (12H TEST OF UFS)
 1002 FORMAT (/8H IERR IS, I5/)
 1003 FORMAT (13H TEST OF UFSS)
 1004 FORMAT (3(1X, E16.8))
 1005 FORMAT (13H TEST OF UFSM)
 1006 FORMAT (14H TEST OF UFSMS)
 1007 FORMAT (13H TEST OF UFSV)
 1008 FORMAT (14H TEST OF UFSVS)
 1019 FORMAT (13H TEST OF UFSF)
 1020 FORMAT (14H TEST OF UFSFS)
 1021 FORMAT (14H TEST OF UFSMV)
 1022 FORMAT (15H TEST OF UFSMVS)
 2000 FORMAT (32H1CHECK ERROR HANDLING  -  TEST 1)
 2010 FORMAT (32H1CHECK ERROR HANDLING  -  TEST 2)
 2020 FORMAT (14H1VALID PROBLEM)
 2030 FORMAT (14H1LDS TOO SMALL)
 2040 FORMAT (33H1ALL DATA AND COVARIANCES MISSING)
 2050 FORMAT (31H1EVERY OTHER DATA VALUE MISSING)
 2060 FORMAT (21H1MINIMUM PROBLEM SIZE)
 2070 FORMAT (32H1CHECK HANDLING OF FMIN AND FMAX)
 2080 FORMAT (21H1WHITE NOISE SPECTRUM)
      END
!NLCNT
      SUBROUTINE NLCNT(Y, WT, LWT, XM, N, M, IXM, MDL, NLDRV, APRXDV,
     +   DRV, PAR, NPAR, RES, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS,
     +   STOPP, SCALE, LSCALE, DELTA, IVAPRX, RSD, PV, LPV, SDPV,
     +   LSDPV, SDRES, LSDRES, VCV, IVCV, WEIGHT, SAVE, NNZW, NPARE,
     +   NLHDR, PAGE, WIDE, IPTOUT, NDIGIT, HLFRPT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IVAPRX,IVCV,IXM,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,LWT,M,
     +   MIT,N,NDIGIT,NNZW,NPAR,NPARE
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,SAVE,WEIGHT,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),STP(*),VCV(*),
     +   WT(*),XM(*),Y(*)
      INTEGER
     +   IFIXED(*),IPTOUT(5)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL,NLDRV,NLHDR
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   D,IFIXD,IFP,IIWORK,IRWORK,IWORK,LVCVL,NALL0,PARE,PVI,
     +   RWORK,SDPVI,SDRESI,VCVL
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CPYASF,CPYVII,NLMN,DCOPY,SETIV,STKCLR
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     INTEGER D
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE ARRAY IN WHICH THE NUMERICAL DERIVATIVES WITH RESPECT TO
!        EACH PARAMETER ARE STORED.
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD
!        THE STARTING LOCATION IN ISTAK OF
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IIWORK
!        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
!     INTEGER IPTOUT(5)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER IRWORK
!        THE DIMENSION OF THE DOUBLE PRECISION WORK VECTOR RWORK.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IWORK
!        THE STARTING LOCATION IN ISTAK OF
!        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LVCVL
!        THE LENGTH OF THE VECTOR CONTAINING
!        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        NUMBER OF ALLOCATIONS ON ENTRY.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     EXTERNAL NLDRV
!        THE NAME OF THE ROUTINE WHICH CALCULATES THE DERIVATIVES.
!     EXTERNAL NLHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARE
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE CURRENT ESTIMATES OF THE PARAMETERS, BUT ONLY
!        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
!     DOUBLE PRECISION PV(LPV)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     INTEGER PVI
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE PREDICTED VALUES.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER RWORK
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE DOUBLE PRECISION WORK VECTOR USED BY THE NL2 SUBROUTINES.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(LSCALE)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(LSDPV)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     INTEGER SDPVI
!        THE STARTING LOCATION IN RWORK OF
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(LSDRES)
!        THE STANDARDIZED RESIDUALS.
!     INTEGER SDRESI
!        THE STARTING LOCATION IN RWORK OF THE
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(LSTP)
!        THE STEP SIZE ARRAY.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE VARIANCE-COVARIANCE MATRIX.
!     INTEGER VCVL
!        THE STARTING LOCATION IN RWORK OF
!        THE VARIANCE-COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET VARIOUS PROGRAM VALUES
!
      NALL0 = STKST(1)
!
      IFP = 4
!
      IERR = 0
!
!     SUBDIVIDE WORK AREA FOR LEAST SQUARES ANALYSIS
!
      IIWORK = NPARE + 60
      IRWORK = 94 + 2*N + NPARE*(3*NPARE+33)/2
!
      IFIXD = STKGET(NPAR,2)
      IWORK = STKGET(IIWORK,2)
!
      D = STKGET(N*NPAR,IFP)
      PARE = STKGET(NPARE,IFP)
      PVI = STKGET(N,IFP)
      RWORK = STKGET(IRWORK,IFP)
!
      IF (IERR.EQ.1) RETURN
!
!     SET VALUES FOR IFIXD
!
      IF (IFIXED(1).GE.0) CALL CPYVII(NPAR, IFIXED, 1, ISTAK(IFIXD), 1)
      IF (IFIXED(1).LT.0) CALL SETIV(ISTAK(IFIXD), NPAR, 0)
!
      CALL NLMN(Y, WEIGHT, NNZW, WT, LWT, XM, N, M, IXM, MDL, NLDRV,
     +   APRXDV, DRV, ISTAK(IFIXD), PAR, RSTAK(PARE), NPAR, RES, PAGE,
     +   WIDE, HLFRPT, STP, LSTP, MIT, STOPSS, STOPP, SCALE, LSCALE,
     +   DELTA, IVAPRX, IPTOUT, NDIGIT, RSD, RSTAK(PVI), SDPVI,
     +   SDRESI, VCVL, LVCVL, RSTAK(D), ISTAK(IWORK), IIWORK,
     +   RSTAK(RWORK), IRWORK, NLHDR, NPARE)
!
      IF (.NOT.SAVE) GO TO 10
!
      SDPVI = RWORK + SDPVI - 1
      SDRESI = RWORK + SDRESI - 1
      VCVL = RWORK + VCVL - 1
!
      CALL DCOPY(N, RSTAK(PVI), 1, PV, 1)
      CALL DCOPY(N, RSTAK(SDPVI), 1, SDPV, 1)
      CALL DCOPY(N, RSTAK(SDRESI), 1, SDRES, 1)
      CALL CPYASF(NPARE, RSTAK(VCVL), LVCVL, VCV, IVCV)
!
   10 CALL STKCLR(NALL0)
!
      RETURN
!
      END
!AMEPT1
      SUBROUTINE AMEPT1(N, Y, PVT, SDPVT, RES, SDREST, IPTOUT, NDIGIT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBOUTINE PRINTS THE DATA SUMMARY FOR THE NONLINEAR
!     LEAST SQUARES SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N,NDIGIT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PVT(*),RES(*),SDPVT(*),SDREST(*),Y(*)
      INTEGER
     +   IPTOUT(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,IPRT,NMAX
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,OBSSM2
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IPTOUT(NDIGIT)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     INTEGER NMAX
!        THE MAXIMUM NUMBER OF ROWS TO BE PRINTED.
!     DOUBLE PRECISION PVT(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION SDPVT(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDREST(N)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
      FPLM = D1MACH(2)
!
      CALL IPRINT(IPRT)
!
      WRITE (IPRT,1100)
      WRITE (IPRT,1000)
      WRITE (IPRT, 1110)
!
      NMAX = N
      IF ((MAX(IPTOUT(3),1).EQ.1) .AND. (N.GE.45))
     +  NMAX = MIN(N,40)
!
!     PRINT OBSERVATION SUMMARY
!
      CALL OBSSM2(N, Y, PVT, SDPVT, RES, SDREST, 1, NMAX)
!
      IF (NMAX.GE.N) GO TO 200
!
      DO 195 I = 1, 3
         WRITE (IPRT, 1150)
  195 CONTINUE
!
!     PRINT LAST LINE OF OUTPUT
!
      CALL OBSSM2(N, Y, PVT, SDPVT, RES, SDREST, N, N)
!
  200 CONTINUE
!
      IF ((IERR.EQ.4)) WRITE (IPRT, 1080)
      IF ((IERR.GT.0) .AND. (IERR.NE.4)) WRITE (IPRT, 1090)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/ 5X, 16X, '  -----PREDICTED  ----STD DEV OF', 16X,
     +   '  ---STD'/
     +   2X, 3HROW, '  --------SERIES  ---------VALUE',
     +   '  ----PRED VALUE  ------RESIDUAL  ---RES')
 1080 FORMAT (// 37H *  NC  -  VALUE NOT COMPUTED BECAUSE,
     +   48H THE STANDARD DEVIATION OF THE RESIDUAL IS ZERO.)
 1090 FORMAT (// 29H *  NC  -  VALUE NOT COMPUTED,
     +   54H BECAUSE CONVERGENCE PROBLEMS PREVENTED THE COVARIANCE,
     +   28H MATRIX FROM BEING COMPUTED.)
 1100 FORMAT (//' RESULTS FROM LEAST SQUARES FIT'/ 1X, 31('-'))
 1110 FORMAT (' ')
 1150 FORMAT (4X, '.', 4(15X, '.'), 7X, '.')
      END
!FITPT1
      SUBROUTINE FITPT1(N, M, XM, Y, PV, SDPV, RES, SDRES, WT, IXM,
     +   NNZW, WEIGHT, IPTOUT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBOUTINE PRINTS THE DATA SUMMARY FOR THE NONLINEAR
!     LEAST SQUARES SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IPTOUT,IXM,M,N,NNZW
      LOGICAL
     +   WEIGHT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PV(N),RES(N),SDPV(N),SDRES(N),WT(N),XM(IXM,M),Y(N)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,IPRT,JCOL1,JCOLM,K,NMAX
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,OBSSUM
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS HAVE
!        BEEN DETECTED.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPTOUT
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER JCOLM
!        THE LAST COLUMN OF THE INDEPENDENT VARIABLE TO BE PRINTED.
!     INTEGER JCOL1
!        THE FIRST COLUMN OF THE INDEPENDENT VARIABLE TO BE PRINTED.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NMAX
!        THE MAXIMUM NUMBER OF ROWS TO BE PRINTED.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(N)
!        THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
      FPLM = D1MACH(2)
!
      CALL IPRINT(IPRT)
!
      WRITE (IPRT,1100)
!
      IF (WEIGHT) THEN
         WRITE (IPRT,1010)
      ELSE
         WRITE (IPRT,1000)
      END IF
      WRITE (IPRT, 1110)
!
!     TEST WHETHER COLUMN VECTOR XM(*, 1) = VECTOR 1.0D0
!
      DO 10 I=1,N
         IF (XM(I,1).NE.1.0D0) GO TO 20
   10 CONTINUE
      GO TO 30
!
!     NOT A UNIT VECTOR
!
   20 JCOL1 = 1
      JCOLM = MIN(M,3)
      GO TO 40
!
!     UNIT VECTOR
!
   30 JCOLM = MIN(M,4)
      JCOL1 = MIN(2,JCOLM)
   40 K = JCOLM - JCOL1 + 1
!
      NMAX = N
      IF ((IPTOUT.EQ.1) .AND. (N.GE.45)) NMAX = MIN(N,40)
!
!     PRINT OBSERVATION SUMMARY
!
      CALL OBSSUM(N, M, XM, Y, PV, SDPV, RES, SDRES, WT, IXM,
     +   WEIGHT, K, 1, NMAX, JCOL1, JCOLM)
!
      IF (NMAX.GE.N) GO TO 200
!
      DO 195 I = 1, 3
!
         GO TO (160, 170, 180), K
  160    WRITE (IPRT,1120)
         GO TO 190
  170    WRITE (IPRT,1130)
         GO TO 190
  180    WRITE (IPRT,1140)
!
  190    CONTINUE
         WRITE (IPRT, 1150)
         IF (WEIGHT) WRITE (IPRT, 1160)
!
  195 CONTINUE
!
!     PRINT LAST LINE OF OUTPUT
!
      CALL OBSSUM(N, M, XM, Y, PV, SDPV, RES, SDRES, WT, IXM,
     +   WEIGHT, K, N, N, JCOL1, JCOLM)
!
  200 CONTINUE
!
      IF ((NNZW.LT.N) .AND. (IERR.EQ.0)) WRITE (IPRT, 1060)
      IF ((NNZW.LT.N) .AND. (IERR.EQ.4)) WRITE (IPRT, 1070)
      IF ((NNZW.EQ.N) .AND. (IERR.EQ.4)) WRITE (IPRT, 1080)
      IF ((IERR.GT.0) .AND. (IERR.NE.4)) WRITE (IPRT, 1090)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/53X, 9HDEPENDENT, 7X, 9HPREDICTED, 5X, 12H STD DEV OF ,
     +   24X, 4HSTD /
     +   2X, 3HROW, 13X, 16HPREDICTOR VALUES, 20X, 8HVARIABLE, 8X,
     +   6H VALUE, 8X, 12HPRED VALUE  , 6X, 9HRESIDUAL , 8X, 3HRES)
 1010 FORMAT (/53X, 9HDEPENDENT, 7X, 9HPREDICTED, 5X, 12H STD DEV OF ,
     +   24X, 4HSTD /
     +   2X, 3HROW, 13X, 16HPREDICTOR VALUES, 20X, 8HVARIABLE, 8X,
     +   6H VALUE, 8X, 12HPRED VALUE  , 6X, 9HRESIDUAL , 8X, 3HRES,
     +   4X, 6HWEIGHT)
 1060 FORMAT (// 37H *  NC  -  VALUE NOT COMPUTED BECAUSE,
     +   20H THE WEIGHT IS ZERO.)
 1070 FORMAT (// 44H *  NC  -  VALUE NOT COMPUTED BECAUSE EITHER,
     +   53H THE WEIGHT OR THE STANDARD DEVIATION OF THE RESIDUAL,
     +   9H IS ZERO.)
 1080 FORMAT (// 37H *  NC  -  VALUE NOT COMPUTED BECAUSE,
     +   48H THE STANDARD DEVIATION OF THE RESIDUAL IS ZERO.)
 1090 FORMAT (// 29H *  NC  -  VALUE NOT COMPUTED,
     +   54H BECAUSE CONVERGENCE PROBLEMS PREVENTED THE COVARIANCE,
     +   28H MATRIX FROM BEING COMPUTED.)
 1100 FORMAT (//31H RESULTS FROM LEAST SQUARES FIT/ 1X, 31('-'))
 1110 FORMAT (' ')
 1120 FORMAT (4X, '.', 25X, '.')
 1130 FORMAT (4X, '.', 3X, 2(14X, '.'))
 1140 FORMAT (4X, '.', 10X, '.', 2(14X, '.'))
 1150 FORMAT ('+', 49X, 11X, '.', 3(15X, '.'), 11X, '.')
 1160 FORMAT ('+', 130X, '.')
      END
!DIFM
      SUBROUTINE DIFM (Y, YMISS, N, YF, YFMISS, NYF)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PERFORMS A FIRST DIFFERENCE FILTERING OPERATION,
!     RETURNING THE FILTERED SERIES IN YF, FOR AN INPUT SERIES
!     CONTAINING MISSING VALUES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YFMISS,YMISS
      INTEGER
     +   N,NYF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*),YF(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IAR,IPRT
      LOGICAL
     +   ERR01,HEAD
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PHI(1)
      CHARACTER
     +   LN(8)*1,NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,FLTARM,IPRINT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     CHARACTER*1 LN(8)
!        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES N.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     DOUBLE PRECISION PHI(1)
!        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!     DOUBLE PRECISION YFMISS
!        THE MISSING VALUE CODE USED IN THE FILTERED SERIES TO
!        INDICATE THE VALUE COULD NOT BE COMPUTED DUE TO MISSING DATA.
!     DOUBLE PRECISION YMISS
!        THE MISSING VALUE CODE USED IN THE INPUT SERIES TO INDICATE
!        AN OBSERVATION IS MISSING.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'D',       'I',       'F',       'M',       ' ',       ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 3, 1, HEAD, ERR01, LN)
!
      IF (.NOT. ERR01) GO TO 10
!
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   10 CONTINUE
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      IAR = 1
      PHI(1) = 1.0D0
!
      CALL FLTARM (Y, YMISS, N, IAR, PHI, YF, YFMISS, NYF)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   47H       CALL DIFM (Y, YMISS, N, YF, YFMISS, NYF))
      END
!STPER
      SUBROUTINE STPER(NMSUB, N, M, IXM, NPAR, LDSTAK, SCALE, LSCALE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE ERROR CHECKING ROUTINE FOR STEP SIZE SELECTION
!     ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,LSCALE,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   SCALE(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   I,LDSMIN,NV
      LOGICAL
     +   HEAD
!
!  LOCAL ARRAYS
      LOGICAL
     +   ERROR(10)
      CHARACTER
     +   LIXM(8)*1,LLDS(8)*1,LM(8)*1,LN(8)*1,LNPAR(8)*1,
     +   LONE(8)*1,LSCL(8)*1,LZERO(8)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,ERVGT,LDSCMP
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR(10)
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LIXM(8), LLDS(8), LM(8), LN(8), LNPAR(8), LONE(8),
!    +            LSCL(8), LZERO(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND.
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!
!     SET UP NAME ARRAYS
!
      DATA LIXM(1), LIXM(2), LIXM(3), LIXM(4), LIXM(5), LIXM(6),
     +   LIXM(7), LIXM(8) /'I','X','M',' ',' ',' ',' ',' '/
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +   LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA LM(1), LM(2), LM(3), LM(4), LM(5), LM(6), LM(7), LM(8) /'M',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8) /'N',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LNPAR(1), LNPAR(2), LNPAR(3), LNPAR(4), LNPAR(5),
     +   LNPAR(6), LNPAR(7), LNPAR(8) /'N','P','A','R',' ',' ',' ',
     +   ' '/
      DATA LONE(1), LONE(2), LONE(3), LONE(4), LONE(5),
     +   LONE(6), LONE(7), LONE(8) /' ',' ','O','N','E',' ',' ',
     +   ' '/
      DATA LSCL(1), LSCL(2), LSCL(3), LSCL(4), LSCL(5),
     +   LSCL(6), LSCL(7), LSCL(8) /'S','C','A','L','E',' ',' ',
     +   ' '/
      DATA LZERO(1), LZERO(2), LZERO(3), LZERO(4), LZERO(5),
     +   LZERO(6), LZERO(7), LZERO(8) /'Z','E','R','O',' ',' ',' ',' '/
!
!     ERROR CHECKING
!
      DO 10 I=1,10
         ERROR(I) = .FALSE.
   10 CONTINUE
!
      IERR = 0
      HEAD = .TRUE.
!
      CALL EISGE(NMSUB, LN, N, 1, 2, HEAD, ERROR(1), LONE)
!
      CALL EISGE(NMSUB, LM, M, 1, 2, HEAD, ERROR(2), LONE)
!
      CALL EISGE(NMSUB, LIXM, IXM, N, 3, HEAD, ERROR(3), LN)
!
      CALL EISGE(NMSUB, LNPAR, NPAR, 1, 2, HEAD, ERROR(4), LONE)
!
      CALL LDSCMP(14, 0, 2*(N+NPAR), 0, 0, 0, 'D', 9*N + MAX(N,NPAR),
     +            LDSMIN)
!
      IF ((.NOT.ERROR(1)) .AND. (.NOT.ERROR(4)))
     +   CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR(5),
     +   LLDS)
!
      CALL ERVGT(NMSUB, LSCL, SCALE, LSCALE, 0.0D0, 0, HEAD, 6, NV,
     +   ERROR(9), LZERO)
!
!
      DO 20 I=1,10
         IF (ERROR(I)) GO TO 30
   20 CONTINUE
      RETURN
!
   30 CONTINUE
      IERR = 1
      RETURN
!
      END
!NLSDC
      SUBROUTINE NLSDC(Y, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING ANALYTIC DERIVATIVES WITH USER
!     SUPPLIED CONTROL PARAMETERS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IVAPRX,IXM,LDSTAK,M,MIT,N,NPAR,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),SCALE(*),XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LWT,NNZW,NPARE
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SDPV(1),SDRES(1),VCV(1,1),WT(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTA
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE DERIVATIVES WE
!        CHECKED OR NOT.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(NPAR)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION VCV(1,1)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(1)
!        THE DUMMY ARRAY FOR THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','D','C',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      WEIGHT = .FALSE.
      SAVE = .FALSE.
!
      WT(1) = 1.0D0
      LIFIXD = NPAR
      LPV = 1
      LSCALE = NPAR
      LSDPV = 1
      LSDRES = 1
      LWT = 1
      IVCV = 1
!
      CALL NLCNTA(Y, WT, LWT, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, IDRVCK, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSDC (Y, XM, N, M, IXM, NLSMDL, NLSDRV,'/
     +   '      +            PAR, NPAR, RES, LDSTAK,'/
     +   '      +            IFIXED, IDRVCK, MIT, STOPSS, STOPP,'/
     +   '      +            SCALE, DELTA, IVAPRX, NPRT)')
      END
!XNLST
      SUBROUTINE XNLST(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DEMONSTRATE THE USER CALLABLE ROUTINES IN THE NONLINEAR
!     LEAST SQUARES FAMILY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   I,IDRVCK,IPRT,IVAPRX,IVCV,IXM1,IXM2,IXM3,LDSA1,LDSMIN,
     +   LDSN1B,M1,M2,M3,MIT,N1,N2,N3,NNZW,NPAR1,NPAR2,NPAR3,NPARE,
     +   NPRT,NTEST
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR1(10),PAR2(10),PAR3(10),PV(100),RES(100),SCALE(10),
     +   SDPV(100),SDRES(100),STOP(8),STP(10),VCV(6,6),WT(100),
     +   XM1(10,2),XM2(10,3),XM3(101,5),Y1(10),Y2(10),Y3(100)
      INTEGER
     +   IFIXED(10),IVCTST(9)
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DRV1A,DRV2,DRV3,FITXSP,IPRINT,LDSCMP,MDL1,MDL2,MDL3,NLSC,
     +   NLSDC,NLSDS,NLSS,NLSWC,NLSWDC,NLSWDS,NLSWS,NLSX1,NLSX2,
     +   SETRV
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV1A, DRV2, DRV3
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
!        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(10)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCTST(9)
!        VARIANCE-COVARIANCE CODE TEST VALUES.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM1, IXM2, IXM3
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSA1, LDSN1B
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK
!        FOR THE ROUTINES WITH ANALYTIC DERIVATIVES AND
!        NUMERICAL DERIVATIVES, RESPECTIVELY.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M1, M2, M3
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL1, MDL2, MDL3
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N1, N2, N3
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
!     INTEGER NPAR1, NPAR2, NPAR3
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     DOUBLE PRECISION PAR1(10), PAR2(10), PAR3(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION PV(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(100)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     DOUBLE PRECISION SCALE(10)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     DOUBLE PRECISION SDPV(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF THE
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOP(8)
!        STOPPING CRITERIA TEST VARIABLE.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(10)
!        THE RCSTEP SIZE ARRAY.
!     DOUBLE PRECISION VCV(6,6)
!        THE COVARIANCE MATRIX.
!     DOUBLE PRECISION WT(100)
!        THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION XM1(10,2), XM2(10,3), XM3(101,5)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y1(10), Y2(10), Y3(100)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     DEFINE CONSTANTS
!
      DATA Y1(1), Y1(2), Y1(3), Y1(4), Y1(5), Y1(6)
     +   /2.138D0, 3.421D0, 3.597D0, 4.340D0, 4.882D0, 5.660D0/
!
      DATA XM1(1,1), XM1(2,1), XM1(3,1), XM1(4,1), XM1(5,1), XM1(6,1)
     +   /1.309D0, 1.471D0, 1.490D0, 1.565D0, 1.611D0, 1.680D0/
!
      DATA N2 /10/, M2 /3/, IXM2 /10/, NPAR2 /3/
!
      DATA N3 /50/, M3 /5/, IXM3 /101/, NPAR3 /5/
!
      CALL IPRINT(IPRT)
!
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
!
      CALL SETRV(WT, N3, 1.0D0)
!
      CALL LDSCMP(6, 0, 60+2*NPAR1, 0, 0, 0,
     +   'D', 94+N1*(3+NPAR1)+NPAR1*(3*NPAR1+35)/2, LDSA1)
      CALL LDSCMP(14, 0, 60+2*NPAR1, 0, 0, 0,
     +   'D', 94+N1*(3+NPAR1)+NPAR1*(3*NPAR1+37)/2, LDSN1B)
      CALL LDSCMP(14, 0, MAX(2*(N3+NPAR3),60+2*NPAR3), 0, 0, 0,
     +   'D', MAX(10*N3,94+N3*(3+NPAR3)+NPAR3*(3*NPAR3+37)/2), LDSMIN)
!
      IF (LDSMIN.LE.LDSTAK) GO TO 5
!
      WRITE (IPRT, 1000) LDSMIN
      RETURN
!
    5 CONTINUE
!
      DO 10 I=1,N2
         Y2(I) = 0.0D0
         XM2(I,1) = I
         XM2(I,2) = I + 0.125D0
         XM2(I,3) = I + 0.25D0
   10 CONTINUE
!
      DO 20 I=1,N3
         XM3(I,1) = 1.0D0
         XM3(I,2) = I
         XM3(I,3) = XM3(I,2)*XM3(I,2)
         XM3(I,4) = XM3(I,3)*XM3(I,2)
         XM3(I,5) = XM3(I,4)*XM3(I,2)
         Y3(I) = XM3(I,1) + XM3(I,2) + XM3(I,3) + XM3(I,4) + XM3(I,5)
   20 CONTINUE
!
      NTEST = 0
!
!
!
!     **TEST CHECKING OF CONTROL CRITERIA**
!
      WRITE (IPRT,1240)
!
      STOP(1) = RMDCON(3,typ=0.0_wp)
      STOP(2) = 0.1D0
      STOP(3) = 0.9D0*RMDCON(3,typ=0.0_wp)
      STOP(4) = 0.11D0
      STOP(5) = 0.0D0
      STOP(6) = 1.0D0
      STOP(7) = -1.0D0
      STOP(8) = 1.1D0
!
      NPRT = 11000
      MIT = 0
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1250) MIT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      WRITE (IPRT,1100)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP, SCALE(1),
     +   DELTA, IVAPRX, NPRT
      CALL NLSWDC(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP, SCALE(1),
     +   DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
!
      MIT = 1
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1250) MIT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      WRITE (IPRT,1100)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP, SCALE(1),
     +   DELTA, IVAPRX, NPRT
      CALL NLSWDC(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP, SCALE(1),
     +   DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1250) MIT
      CALL NLSX1(2, PAR2, NPAR2, PV, SDPV, RES, SDRES, VCV, N2, IVCV,
     +   NNZW, NPARE, RSD)
      WRITE (IPRT,1050)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWS(Y2, WT, XM2, N2, M2, IXM2, MDL2, PAR2, NPAR2, RES,
     +   LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR2, PV, SDPV, RES, SDRES, VCV, N2, NPAR2, IVCV,
     +   NNZW, NPARE, RSD)
!
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
      DO 40 I=1,4
         NTEST = NTEST + 1
         WRITE (IPRT,1330) NTEST
         WRITE (IPRT,1260) STOP(I)
         CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1,
     +      IVCV, NNZW, NPARE, RSD)
         WRITE (IPRT,1100)
         WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOP(I), STOPP,
     +      SCALE(1), DELTA, IVAPRX, NPRT
         CALL NLSWDC(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1,
     +      NPAR1, RES, LDSTAK, IFIXED, IDRVCK, MIT, STOP(I), STOPP,
     +      SCALE, DELTA, IVAPRX, NPRT)
         WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOP(I), STOPP,
     +      SCALE(1), DELTA, IVAPRX, NPRT
         WRITE (IPRT,1120) IERR
   40 CONTINUE
      DO 50 I=5,8
         NTEST = NTEST + 1
         WRITE (IPRT,1330) NTEST
         WRITE (IPRT,1270) STOP(I)
         CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1,
     +      IVCV, NNZW, NPARE, RSD)
         WRITE (IPRT,1100)
         WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOP(I),
     +      SCALE(1), DELTA, IVAPRX, NPRT
         CALL NLSWDC(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1,
     +      NPAR1, RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOP(I),
     +      SCALE, DELTA, IVAPRX, NPRT)
         WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOP(I),
     +      SCALE(1), DELTA, IVAPRX, NPRT
         WRITE (IPRT,1120) IERR
   50 CONTINUE
      NPRT = 100000
      DO 60 I=1,6
         NTEST = NTEST + 1
         WRITE (IPRT,1330) NTEST
         WRITE (IPRT,1280) NPRT
         CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1,
     +      IVCV, NNZW, NPARE, RSD)
         WRITE (IPRT,1110)
         WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE(1), DELTA, IVAPRX, NPRT
         CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1,
     +      NPAR1, RES, LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE, DELTA, IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV,
     +      SDRES, VCV, IVCV)
         WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE(1), DELTA, IVAPRX, NPRT
         WRITE (IPRT,1120) IERR
         CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +      NNZW, NPARE, RSD)
         NPRT = NPRT/10
   60 CONTINUE
      NPRT = 11000
      DO 70 I=1,2
         NTEST = NTEST + 1
         WRITE (IPRT,1330) NTEST
         WRITE (IPRT,1280) NPRT
         CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1,
     +      IVCV, NNZW, NPARE, RSD)
         WRITE (IPRT,1110)
         WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE(1), DELTA, IVAPRX, NPRT
         CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1,
     +      NPAR1, RES, LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE, DELTA, IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV,
     +      SDRES, VCV, IVCV)
         WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE(1), DELTA, IVAPRX, NPRT
         WRITE (IPRT,1120) IERR
         CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +      NNZW, NPARE, RSD)
         NPRT = 11001
   70 CONTINUE
!
      NPRT = 0
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
!
      WRITE (IPRT,1010)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSC(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSN1B,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
      WRITE (IPRT,1020)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSS(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSN1B,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
      WRITE (IPRT,1040)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWC(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSN1B, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
      WRITE (IPRT,1050)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWS(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSN1B, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
      WRITE (IPRT,1070)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSDC(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
      WRITE (IPRT,1080)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSDS(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
      WRITE (IPRT,1100)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWDC(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
      WRITE (IPRT,1110)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      NPRT = -1
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1280) NPRT
      WRITE (IPRT,1110)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSA1, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
!
!     **TEST PARAMETER HANDLING**
!
      WRITE (IPRT,1190)
!
!     ALL ZERO
!
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
      STP(1) = -1.0D0
      SCALE(1) = -1.0D0
      DELTA = -1.0D0
      NPRT = 11000
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1200)
      CALL NLSX1(4, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      WRITE (IPRT,1010)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSC(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
      CALL NLSX1(4, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1200)
      WRITE (IPRT,1100)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWDC(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
!
!
!     **TEST WITH CONSTANT Y**
!
!     CONSTANT Y=0
!
      NPRT = 21222
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1210)
      CALL NLSX1(2, PAR2, NPAR2, PV, SDPV, RES, SDRES, VCV, N2, IVCV,
     +   NNZW, NPARE, RSD)
      WRITE (IPRT,1050)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWS(Y2, WT, XM2, N2, M2, IXM2, MDL2, PAR2, NPAR2, RES,
     +   LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR2, PV, SDPV, RES, SDRES, VCV, N2, NPAR2, IVCV,
     +   NNZW, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1210)
      WRITE (IPRT,1110)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(2, PAR2, NPAR2, PV, SDPV, RES, SDRES, VCV, N2, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWDS(Y2, WT, XM2, N2, M2, IXM2, MDL2, DRV2, PAR2, NPAR2,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR2, PV, SDPV, RES, SDRES, VCV, N2, NPAR2, IVCV,
     +   NNZW, NPARE, RSD)
!
!     **TEST WITH LINEAR MODEL**
!
      NPRT = 11212
      IVAPRX = 1
!
      DO 80 I=1,NPAR3
         IFIXED(I) = 0
   80 CONTINUE
      IFIXED(1) = 1
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1220)
      WRITE (IPRT,1010)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(3, PAR3, NPAR3, PV, SDPV, RES, SDRES, VCV, N3, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSC(Y3, XM3, N3, M3, IXM3, MDL3, PAR3, NPAR3, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1220)
      NPRT = 11111
      WRITE (IPRT,1070)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(3, PAR3, NPAR3, PV, SDPV, RES, SDRES, VCV, N3, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSDC(Y3, XM3, N3, M3, IXM3, MDL3, DRV3, PAR3, NPAR3, RES,
     +   LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
!
!     **TEST XM**
!
!
!     FIRST COLUMN ZERO
!
      CALL SETRV(Y2, N2, 2.0D0)
      CALL SETRV(XM2(1,1), N2, 0.0D0)
!
      NPRT = 11000
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1310)
      CALL NLSX1(2, PAR2, NPAR2, PV, SDPV, RES, SDRES, VCV, N2, IVCV,
     +   NNZW, NPARE, RSD)
      WRITE (IPRT,1110)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWDS(Y2, WT, XM2, N2, M2, IXM2, MDL2, DRV2, PAR2, NPAR2,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE,
     +   DELTA, IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV,
     +   IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR2, PV, SDPV, RES, SDRES, VCV, N2, NPAR2, IVCV,
     +   NNZW, NPARE, RSD)
!
!     2 COLUMNS ZERO
!
      CALL SETRV(XM2(1,2), N2, 0.0D0)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1300)
      WRITE (IPRT,1110)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSX1(2, PAR2, NPAR2, PV, SDPV, RES, SDRES, VCV, N2, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWDS(Y2, WT, XM2, N2, M2, IXM2, MDL2, DRV2, PAR2, NPAR2,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR2, PV, SDPV, RES, SDRES, VCV, N2, NPAR2, IVCV,
     +   NNZW, NPARE, RSD)
!
!     **TEST VARIANCE-COVARIANCE MATRIX COMPUTATIONS**
!
!
      IVCTST(1) = -1
      IVCTST(2) = 0
      IVCTST(3) = 1
      IVCTST(4) = 2
      IVCTST(5) = 3
      IVCTST(6) = 4
      IVCTST(7) = 5
      IVCTST(8) = 6
      IVCTST(9) = 7
      NPRT = 2
      DO 90 I=1,9
         NTEST = NTEST + 1
         WRITE (IPRT,1330) NTEST
         WRITE (IPRT,1380)
         CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1,
     +      IVCV, NNZW, NPARE, RSD)
         WRITE (IPRT,1110)
         WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE(1), DELTA, IVCTST(I), NPRT
         CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1,
     +      NPAR1, RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE, DELTA, IVCTST(I), NPRT, NNZW, NPARE, RSD, PV, SDPV,
     +      SDRES, VCV, IVCV)
         WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +      SCALE(1), DELTA, IVCTST(I), NPRT
         WRITE (IPRT,1120) IERR
         CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +      NNZW, NPARE, RSD)
   90 CONTINUE
!
!     **TEST WITH 2 ZERO WEIGHTS**
!
      NPRT = 22222
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1290)
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      WT(3) = 0.0D0
      WT(5) = 0.0D0
      WRITE (IPRT,1110)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR1, PV, SDPV, RES, SDRES, VCV, N1, NPAR1, IVCV,
     +   NNZW, NPARE, RSD)
!
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1010 FORMAT (15H TEST OF NLSC  )
 1020 FORMAT (15H TEST OF NLSS  )
 1040 FORMAT (15H TEST OF NLSWC )
 1050 FORMAT (15H TEST OF NLSWS )
 1070 FORMAT (15H TEST OF NLSDC )
 1080 FORMAT (15H TEST OF NLSDS )
 1100 FORMAT (15H TEST OF NLSWDC)
 1110 FORMAT (15H TEST OF NLSWDS)
 1120 FORMAT (/29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1190 FORMAT (28H **TEST PARAMETER HANDLING**)
 1200 FORMAT (20H ALL PARAMETERS ZERO)
 1210 FORMAT (30H **TEST WITH CONSTANT ZERO Y**)
 1220 FORMAT (22H **TEST LINEAR MODEL**)
 1240 FORMAT (26H **TEST CONTROL CRITERIA**)
 1250 FORMAT (34H --MAXIMUM NUMBER OF ITERATIONS = , I5)
 1260 FORMAT (12H --STOPSS = , G14.8)
 1270 FORMAT (11H --STOPP = , G14.8)
 1280 FORMAT (10H --NPRT = , I6)
 1290 FORMAT (29H **TEST WITH 2 ZERO WEIGHTS**)
 1300 FORMAT (19H **2 COLUMNS ZERO**)
 1310 FORMAT (18H **1 COLUMN ZERO**)
 1330 FORMAT (54H1NONLINEAR LEAST SQUARES ESTIMATION SUBROUTINE TEST NU,
     +   4HMBER, I5/)
 1340 FORMAT (24H INPUT   -  IFIXED(1) = , I6, 9X, 11H, STP(1) = ,
     +   G15.8, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8, 10H, STOPP = ,
     +   G15.8/13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I6)
 1350 FORMAT (//24H OUTPUT  -  IFIXED(1) = , I6, 9X, 11H, STP(1) = ,
     +   G15.8, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8, 10H, STOPP = ,
     +   G15.8/13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I6//)
 1360 FORMAT (24H INPUT   -  IFIXED(1) = , I6, 9X, 11H, IDRVCK = ,
     +   I5, 10X, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8,
     +   10H, STOPP = , G15.8/
     +   13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I6)
 1370 FORMAT (//24H OUTPUT  -  IFIXED(1) = , I6, 9X, 11H, IDRVCK = ,
     +   I5, 10X, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8,
     +   10H, STOPP = , G15.8/
     +   13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I6//)
 1380 FORMAT (54H TEST HANDLING OF VARIANCE-COVARIANCE COMPUTATION CODE,
     +   'S')
      END
!AMEANM
      SUBROUTINE AMEANM (Y, YMISS, N, NUSED, YMEAN)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE ARITHMETIC MEAN OF A SERIES WHEN MISSING
!     DATA ARE INVOLVED.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMEAN,YMISS
      INTEGER
     +   N,NUSED
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   SUMY
      INTEGER
     +   I
!
!  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NUSED
!        THE NUMBER OF ACTIVE NUMBER OF OBSERVATIONS.
!     DOUBLE PRECISION SUMY
!        THE VARIABLE USED TO SUM THE NON-MISSING Y VALUES.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!
      NUSED = 0
      SUMY = 0.0D0
      DO 10 I = 1, N
         IF (MVCHK(Y(I), YMISS)) GO TO 10
         SUMY = SUMY + Y(I)
         NUSED = NUSED + 1
   10 CONTINUE
      IF (NUSED.GE.1) THEN
         YMEAN = SUMY / NUSED
      ELSE
         YMEAN = SUMY
      END IF
      RETURN
      END
!ETAMDL
      SUBROUTINE ETAMDL(MDL, PAR, NPAR, XM, N, M, IXM, ETA, NETA,
     +   PARTMP, PV, NROWIN)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO COMPUTE NOISE AND NUMBER OF GOOD DIGITS IN
!     RESULTS OF MODEL ROUTINE AT ROW <NROW>.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ETA
      INTEGER
     +   IXM,M,N,NETA,NPAR,NROWIN
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PARTMP(NPAR),PV(N),XM(IXM,M)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   A,B,FAC,FPLRS,J,RSSSM,RSSSMJ,SQRTMP
      INTEGER
     +   I,K,NROW
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSS(5)
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL SETROW
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,LOG10,MAX,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION A, B
!        PARAMETERS OF THE FIT.
!     DOUBLE PRECISION ETA
!        THE NOISE IN THE MODEL RESULTS.
!     DOUBLE PRECISION FAC
!        A FACTOR USED IN THE COMPUTATIONS.
!     DOUBLE PRECISION FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     DOUBLE PRECISION J
!        THE VALUE FLOAT(I-3).
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER M
!        NUMBER OF VARIABLES
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        NUMBER OF OBSERVATIONS
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL RESULTS.
!     INTEGER NPAR
!        NUMBER OF PARAMETERS
!     INTEGER NROW
!        THE ROW NUMBER ACTUALLY USED.
!     INTEGER NROWIN
!        THE INPUT NUMBER OF THE ROW BEING CHECKED.
!     DOUBLE PRECISION PAR(NPAR)
!        MODEL PARAMETERS
!     DOUBLE PRECISION PARTMP(NPAR)
!        MODIFIED MODEL PARAMETERS
!     DOUBLE PRECISION PV(N)
!        PREDICTED VALUES
!     DOUBLE PRECISION RSS(5)
!        THE RESIDUAL SUM OF SQUARES FOR EACH VALUE OF J.
!     DOUBLE PRECISION RSSSM
!        THE SUM OF THE RESIDUAL SUM OF SQUARES FOR EACH SET OF
!        PARAMETER VALUES.
!     DOUBLE PRECISION RSSSMJ
!        THE SUM OF THE RESIDUAL SUM OF SQUARES TIMES J FOR EACH
!        SET OF PARAMETER VALUES.
!     DOUBLE PRECISION SQRTMP
!        THE SQUARE ROOT OF MACHINE PRECISION (FPLRS).
!     DOUBLE PRECISION XM(IXM,M)
!        INDEPENDENT VARIABLES
!
      FPLRS = D1MACH(4)
!
!     SELECT FIRST ROW OF INDEPENDENT VARIABLES WHICH CONTAINS NO ZEROS
!
      CALL SETROW(NROWIN, XM, N, M, IXM, NROW)
!
      SQRTMP = SQRT(FPLRS)
      RSSSM = 0.0D0
      RSSSMJ = 0.0D0
      DO 20 I=1,5
         J = I-3
         DO 10 K=1,NPAR
            PARTMP(K) = PAR(K)*(1.0D0+J*SQRTMP)
   10    CONTINUE
         CALL MDL(PARTMP, NPAR, XM, N, M, IXM, PV)
!
         RSS(I) = PV(NROW)
!
         RSSSM = RSSSM + RSS(I)
         RSSSMJ = RSSSMJ + J*RSS(I)
   20 CONTINUE
      A = 0.2D00*RSSSM
      B = 0.1D00*RSSSMJ
      FAC = 1.0D0
      IF (RSS(3).NE.0.0D0) FAC = FAC/RSS(3)
      DO 30 I=1,5
         J = I-3
         RSS(I) = ABS((RSS(I)-(A+J*B))*FAC)
   30 CONTINUE
      ETA = MAX(RSS(1),RSS(2),RSS(3),RSS(4),RSS(5),FPLRS)
      NETA = -LOG10(ETA)
      ETA = 10.0D0**(-NETA)
      RETURN
      END
!NLS
      SUBROUTINE NLS(Y, XM, N, M, IXM, MDL, PAR, NPAR, RES, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
!     (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),XM(*),Y(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IPRT,IVAPRX,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,LWT,
     +   MIT,NNZW,NPARE,NPRT
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SCALE(1),SDPV(1),SDRES(1),STP(1),VCV(1,1),WT(1)
      INTEGER
     +   IFIXED(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTN
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(1)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(1)
!        THE STEP SIZE ARRAY.
!     DOUBLE PRECISION VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(1)
!        THE DUMMY ARRAY FOR THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S',' ',' ',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      WEIGHT = .FALSE.
      SAVE = .FALSE.
!
      WT(1) = 1.0D0
      STP(1) = -1.0D0
      MIT = -1
      STOPSS = -1.0D0
      STOPP = -1.0D0
      SCALE(1) = -1.0D0
      DELTA = -1.0D0
      NPRT = -1
      IFIXED(1) = -1
      IVAPRX = 0
      LIFIXD = 1
      LPV = 1
      LSTP = 1
      LSCALE = 1
      LSDPV = 1
      LSDRES = 1
      LWT = 1
      IVCV = 1
!
      CALL NLCNTN(Y, WT, LWT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLS (Y, XM, N, M, IXM, NLSMDL,'/
     +   '      +          PAR, NPAR, RES, LDSTAK)')
      END
!NLCNTN
      SUBROUTINE NLCNTN(Y, WT, LWT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVCVOP, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IVCV,IVCVOP,IXM,LDSTAK,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,
     +   LSTP,LWT,M,MIT,N,NNZW,NPAR,NPARE,NPRT
      LOGICAL
     +   SAVE,WEIGHT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),STP(*),VCV(*),
     +   WT(*),XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   EXMPT
      INTEGER
     +   IFP,IS,ISUBHD,LDSMIN,NALL0,NDIGIT,NETA,STPI
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,PRTFXD,WIDE
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   IPTOUT(5),ISTAK(12)
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   ICNTI,STKGET,STKST
      EXTERNAL ICNTI,STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DRV,LDSCMP,NLCNT,NLDRVN,NLER,NLHDRN,PRTCNT,DCOPY,STKCLR,
     +   STKSET,STPCNT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IPTOUT(5)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER IS
!        A VALUE USED TO DETERMINE THE AMOUNT OF WORK SPACE NEEDED
!        BASED ON WHETHER STEP SIZES ARE INPUT OR ARE TO BE CALCULATED.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISUBHD
!        AN INTEGER VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IVCVOP
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVCVOP LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVCVOP EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVCVOP EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVCVOP EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVCVOP EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVCVOP EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVCVOP EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVCVOP GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        NUMBER OF ALLOCATIONS ON ENTRY.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL RESULTS.
!     EXTERNAL NLDRVN
!        THE NAME OF THE ROUTINE WHICH CALCULATES THE DERIVATIVES.
!     EXTERNAL NLHDRN
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PV(LPV)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(LSCALE)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(LSDPV)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(LSDRES)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(LSTP)
!        THE STEP SIZE ARRAY.
!     INTEGER STPI
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE STEP SIZE ARRAY.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE VARIANCE-COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET VARIOUS PROGRAM VALUES
!
      HLFRPT = .FALSE.
      APRXDV = .TRUE.
      PRTFXD = .TRUE.
      EXMPT = -1.0D0
      NETA = 0
!
      WIDE = .TRUE.
      PAGE = .FALSE.
!
      NDIGIT = 5
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      IF ((IFIXED(1).GE.0) .AND. (NPAR.GE.1)) THEN
         NPARE = ICNTI(IFIXED,NPAR,0)
      ELSE
         NPARE = NPAR
      END IF
!
      IF (STP(1).LE.0.0D0) THEN
         IS = 1
      ELSE
         IS = 0
      END IF
!
      CALL LDSCMP(14, 0, MAX(IS*2*(N+NPAR),60+NPAR+NPARE), 0, 0, 0,
     +   'D',
     +   MAX(IS*(9*N+MAX(N,NPAR)),94+N*(3+NPAR)+NPARE*(3*NPARE+37)/2),
     +   LDSMIN)
!
      CALL NLER (NMSUB, WEIGHT, WT, LWT, N, M, IXM,
     +   IFIXED, LIFIXD, NPAR, NPARE,
     +   LDSTAK, LDSMIN, STP, LSTP, SCALE, LSCALE, IVCV, SAVE, NNZW)
!
      IF (IERR.NE.0) RETURN
!
      CALL STKSET(LDSTAK, 4)
!
!     SET PRINT CONTROL VALUES
!
      CALL PRTCNT(NPRT, NDIGIT, IPTOUT)
!
!     SUBDIVIDE WORKSPACE FOR STEP SIZES
!
      NALL0 = STKST(1)
!
      IFP = 4
!
      STPI = STKGET(NPAR,IFP)
!
!     COPY SUPPLIED STEP SIZES TO WORK SPACE
!
      CALL DCOPY(LSTP, STP, 1, RSTAK(STPI), 1)
!
      IF (IERR.NE.0) GO TO 10
!
!     SELECT STEP SIZES, IF DESIRED
!
      ISUBHD = 1
!
      IF (STP(1).LE.0.0D0) CALL STPCNT(XM, N, M, IXM, MDL, PAR, NPAR,
     +   RSTAK(STPI), EXMPT, NETA, SCALE, LSCALE, IPTOUT(1), NLHDRN,
     +   PAGE, WIDE, ISUBHD, HLFRPT, PRTFXD, IFIXED, LIFIXD)
!
      CALL NLCNT(Y, WT, LWT, XM, N, M, IXM, MDL, NLDRVN, APRXDV, DRV,
     +   PAR, NPAR, RES, IFIXED, LIFIXD, RSTAK(STPI), NPAR, MIT,
     +   STOPSS, STOPP, SCALE, LSCALE, DELTA, IVCVOP, RSD, PV, LPV,
     +   SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV, WEIGHT, SAVE, NNZW,
     +   NPARE, NLHDRN, PAGE, WIDE, IPTOUT, NDIGIT, HLFRPT)
!
   10 CONTINUE
!
      CALL STKCLR(NALL0)
!
      RETURN
!
      END
!MDLTS3
      SUBROUTINE MDLTS3 (PAR, NPAR, XM, N, M, IXM, RESTS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR ESTIMATING BOX-JENKINS
!     ARIMA MODELS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 4, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),RESTS(NRESTS),XM(IXM,M)
!
!  SCALARS IN COMMON
      INTEGER
     +   IFLAG,MBO,MBOL,MSPECT,NFACT,NPARAR,NPARDF,NPARMA,NRESTS,
     +   PARAR,PARDF,PARMA,T,TEMP
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   PMU
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL MDLTS2
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /MDLTSC/MSPECT,NFACT,PARDF,NPARDF,PARAR,NPARAR,PARMA,
     +   NPARMA,MBO,MBOL,T,TEMP,NRESTS,IFLAG
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IFLAG
!        AN INDICATOR VARIABLE DESIGNATING WHETHER THE BACK FORECASTS
!        WERE ESSENTIALLY ZERO (IFLAG=0) OR NOT (IFLAG=1).
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IXM
!        THE FIRST DIMENSION OF MATRIX XM.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBOL
!        THE MAXIMUM BACK ORDER ON THE LEFT
!     INTEGER MSPECT
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFACT
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARAR
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE AUTOREGRESSIVE PARAMETERS
!     INTEGER PARDF
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
!     INTEGER PARMA
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE MOVING AVERAGE PARAMETERS
!     DOUBLE PRECISION PMU
!        THE VALUE OF MU, I.E., THE TREND OR MEAN.
!     DOUBLE PRECISION RESTS(NRESTS)
!        THE RESIDUALS FROM THE ARIMA MODEL.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER T
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR.
!     INTEGER TEMP
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR
!     DOUBLE PRECISION XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!
!
!     COMPUTE RESIDUALS
!
      CALL MDLTS2 (PAR, RESTS, XM(1,1), NPAR, N, NFACT, ISTAK(MSPECT),
     +  PMU, RSTAK(PARDF), NPARDF, RSTAK(T), RSTAK(TEMP), RSTAK(PARAR),
     +  RSTAK(PARMA), MBO, N-NRESTS+1, N, IFLAG)
!
      RETURN
      END
!BFSM
      SUBROUTINE BFSM(Y1, YMISS1, Y2, YMISS2, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
!     FOURIER SPECTRUM ANALYSIS OF SERIES WITH MISSING OBSERVATIONS
!     (SHORT CALL)
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMISS1,YMISS2
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y1(*),Y2(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN
      INTEGER
     +   ICCOV,ICSPC2,INDEX1,INDEX2,INLPPC,IPHAS,IPRT,JCCOV,JNLPPC,
     +   LAGMAX,LAGMX1,LDSMIN,LDSTAK,LPCV,LW,LY,M,NF,NPRT,NW
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCOV(101,2,2),CEVEN(101),CODD(101),CSPC2(101,4),FREQ(101),
     +   PHAS(101,4),SPCF1(101),SPCF2(101),W(101),XAXIS(404),
     +   YAXIS(404)
      INTEGER
     +   ISYM(404),LAGS(4),NLPPC(101,2,2)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,ECVF,IPRINT,PARZEN,SETLAG
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION CCOV(101,2,2)
!        THE COVARIANCES.
!     DOUBLE PRECISION CEVEN(101)
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CODD(101)
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CSPC2(101,4)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISYM(404)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC(101,2,2)
!        THE NUMBER OF OBSERVATIONS IN EACH COVARIANCE ESTIMATE
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION PHAS(101,4)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION SPCF1(101), SPCF2(101)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     DOUBLE PRECISION W(101)
!        THE WINDOWS.
!     DOUBLE PRECISION XAXIS(404)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YAXIS(404)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YMISS1, YMISS2
!        THE MISSING VALUE CODES
!     DOUBLE PRECISION Y1(N)
!        THE FIRST TIME SERIES.
!     DOUBLE PRECISION Y2(N)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','M',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(1) = .FALSE.
      OPTION(2) = .TRUE.
      OPTION(3) = .FALSE.
      OPTION(4) = .FALSE.
!
      ICCOV = 101
      JCCOV = 2
      M = 2
      INDEX1 = 1
      INDEX2 = 2
!
      ICSPC2 = 101
      IPHAS = 101
!
      LDSTAK = 0
      LDSMIN = 0
!
      NF = 101
      INLPPC = 101
      JNLPPC = 2
      LW = 101
      LY = N
      LPCV = 404
!
!     SET MAXIMUM LAG VALUE (LAGMAX)
!     SET NUMBER OF LAG WINDOW TRUCCATION POINTS (NW)
!
      CALL SETLAG(N, LAGMAX)
      NW = 4
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
      CALL BFSDRV(Y1, Y2, YMISS1, YMISS2, CCOV, NLPPC, SPCF1, SPCF2,
     +   NF, FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS, LAGMX1, W, LW,
     +   DELTA, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS, CODD,
     +   CEVEN, W, LW, NMSUB, LDSMIN, LDSTAK, OPTION, N, INLPPC,
     +   JNLPPC, LY)
!
      IF (IERR.NE.0) THEN
        IF (IERR.EQ.2) CALL ECVF(NMSUB)
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL BFSM (Y1, YMISS1, Y2, YMISS2, N)')
      END
!UFSS
      SUBROUTINE UFSS(Y, N, NW, LAGS, NF, FMIN, FMAX, NPRT,
     +   SPCF, ISPCF, FREQ, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   ISPCF,LDSTAK,N,NF,NPRT,NW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),SPCF(*),Y(*)
      INTEGER
     +   LAGS(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,YMISS
      INTEGER
     +   ACOV,I,IFP,IO,IPRT,ISORT,ISYM,LACOV,LAGMAX,LDSMIN,LNLPPA,
     +   LPCV,LWORK,LY,NALL0,WORK,XAXIS,YAXIS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12),NLPPA(1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UFSDRV
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER ACOV
!        THE STARTING LOCATION IN RSTAK FOR THE ACVF VECTOR.
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE SPECTRUM
!        IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF ERR01, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION FOR THE ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY ISYM.
!     INTEGER LACOV
!        THE LENGTH OF VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
!        THIS ROUTINE WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(1)
!        A DUMMY ARRAY FOR SERIES WITHOUT MISSING VALUES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION SPCF(ISPCF,NW)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY WINDOW.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY XAXIS.
!     DOUBLE PRECISION Y(N)
!         THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY YAXIS.
!     DOUBLE PRECISION YMISS
!        THE MISSING VALUE CODE FOR THE SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','S',' ',' '/
!
!     SET UP
!
      OPTION(4) = .TRUE.
      OPTION(3) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(1) = .FALSE.
!
!     SET MAXIMUM LAG VALUE TO BE USED.
!
      LAGMAX = N - 1
      IF (NW.LE.0) GO TO 20
      LAGMAX = LAGS(1)
      DO 10 I=1,NW
         LAGMAX = MAX(LAGMAX,LAGS(I))
   10 CONTINUE
   20 CONTINUE
      LACOV = LAGMAX + 1
      LNLPPA = 1
!
!     COMPUTE MINIMUM ALLOWABLE STACK LENGTH
!
      IO = 1
      IF (NPRT.EQ.0) IO = 0
!
      CALL LDSCMP(5, 0, IO*(NF+5), 0, 0, 0, 'D',
     +   2*LAGMAX+2+IO*(2*NF+10), LDSMIN)
!
      LY = N
      LPCV = NF + 5
      LWORK = LAGMAX+1
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!     SET THE STACK ALLOCATION TYPE.
!
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
!
      IFP = 4
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
!
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         ACOV = 1
         WORK = 1
         XAXIS = 1
         YAXIS = 1
         ISYM = 1
         ISORT = 1
      ELSE
         ACOV = STKGET(LACOV,IFP)
         WORK = STKGET(LWORK,IFP)
         IF (NPRT.NE.0) THEN
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
            ISYM = STKGET(LPCV,2)
            ISORT = ISYM
         ELSE
            XAXIS = WORK
            YAXIS = WORK
            ISYM = WORK
            ISORT = ISYM
         END IF
      END IF
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!
      CALL UFSDRV(Y, LY, YMISS, RSTAK(ACOV), NLPPA, SPCF, ISPCF,
     +   NF, FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS, RSTAK(WORK), LACOV,
     +   LWORK, DELTA, ISTAK(ISORT), ISTAK(ISYM), RSTAK(XAXIS),
     +   RSTAK(YAXIS), LPCV, ALPHA, NPRT, PARZEN, NMSUB, LDSMIN, LDSTAK,
     +   OPTION, LNLPPA, LY)
!
      CALL STKCLR(NALL0)
!
!     CHECK FOR ERRORS
!
      IF (IERR.EQ.0) RETURN
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL UFSS (Y, N,'/
     +   '      +           NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +   '      +           SPCF, ISPCF, FREQ, LDSTAK)')
      END
!CCFSDM
      SUBROUTINE CCFSDM (CCOV11, CCOV22, SDRHOC, LAGMAX, NCC, LAGLST, N,
     +   NLPP12, NLPP21, ICCOV, INLPPC)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING THE STANDARD ERROR
!     OF THE CROSS CORRELATIONS WHEN THERE ARE MISSING VALUES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,INLPPC,LAGLST,LAGMAX,N,NCC
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV11(ICCOV),CCOV22(ICCOV),SDRHOC(NCC)
      INTEGER
     +   NLPP12(INLPPC),NLPP21(INLPPC)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DIV,FPLM,SUM
      INTEGER
     +   I,ILAST,K,K0,KM,KP
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCOV11(ICCOV), CCOV22(ICCOV)
!        THE ARRAYS IN WHICH THE AUTOCOVARIANCES ARE STORED.
!     DOUBLE PRECISION DIV
!        THE SQUARE ROOT OF THE PRODUCT OF THE AUTOCOVARIANCE
!        FUNCTION VALUES AT LAG ZERO.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        INDEXING VARIABLES.
!     INTEGER ICCOV
!        THE DIMENSION OF THE COVARIANCE VECTORS.
!     INTEGER ILAST
!        THE LAST LAG AT WHICH THE STANDARD ERRORS ARE TO BE COMPUTED.
!     INTEGER INLPPC
!        THE DIMENSION OF THE LAGGED PRODUCT PAIR COUNT VECTORS.
!     INTEGER K
!        INDEXING VARIABLES.
!     INTEGER KM, KP, K0
!        THE LOCATIONS IN THE ARRAYS -RHOC- AND -SDRHOC-
!        OF THE LAG -K, K AND 0, RESPECTIVELY.
!     INTEGER LAGLST
!        THE LAST AUTOCORRELATION COMPUTED BEFORE A MISSING
!        AUTOCORRELATION WAS INCOUNTERED IN EITHER SERIES.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE USED.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NCC
!       THE NUMBER OF CROSS CORRELATIONS COMPUTED.
!     INTEGER NLPP12(INLPPC), NLPP21(INLPPC)
!        THE ARRAYS IN WHICH THE NUMBER OF OBSERVATIONS USED TO
!        COMPUTE EACH CROSS CORRELATION ARE STORED.
!     DOUBLE PRECISION SDRHOC(NCC)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE CROSS CORRELATION
!        ARE STORED
!     DOUBLE PRECISION SUM
!         A SUMMING VARIABLE.
!
      FPLM = D1MACH(2)
!
      DIV = CCOV11(1) * CCOV22(1)
!
      K0 = LAGMAX + 1
!
      SUM = 0.0D0
      DO 10 I = 1, LAGLST
         SUM = SUM + CCOV11(I+1) * CCOV22(I+1)
   10 CONTINUE
      SUM = SUM / DIV
      SDRHOC(K0) = FPLM
      IF (NLPP12(1) .GE. 1) SDRHOC(K0) =
     +   SQRT(N + 2.0D0 * SUM) / NLPP12(1)
!
      DO 30 K = 1, LAGMAX
         SUM = 0.0D0
         ILAST = MIN(LAGLST, N-LAGLST)
         DO 20 I = 1, ILAST
            SUM = SUM + (N-K-I) * CCOV11(I+1) * CCOV22(I+1)
   20    CONTINUE
         SUM = SUM / DIV
         KM = K0 - K
         SDRHOC(KM) = FPLM
         IF (NLPP21(K+1) .GE. 1) SDRHOC(KM) =
     +      SQRT((N - K) + 2.0D0 * SUM) * (N - K)/ (N * NLPP21(K+1))
!
         KP = K0 + K
         SDRHOC(KP) = FPLM
         IF (NLPP12(K+1) .GE. 1) SDRHOC(KP) =
     +      SQRT((N - K) + 2.0D0 * SUM) * (N - K) / (N * NLPP12(K+1))
   30 CONTINUE
!
      RETURN
      END
!XPGM
      SUBROUTINE XPGM(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE TIME SERIES PERIODOGRAM AND TIME SERIES
!     UTILITY SUBROUTINES
!
!     SERIES Y IS THE FIRST 50 VALUES OF THE SERIES LISTED ON PAGE
!     318 OF JENKINS AND WATTS.  THE SPECTRUM OF THIS SERIES IS SHOWN
!     FOR VARIOUS BANDWIDTH ON PAGE 270 OF JENKINS AND WATTS.
!
!     SERIES Z IS THE WOLF SUNSPOT NUMBERS FROM 1700 TO 1960 AS
!     TABULATED BY WALDMEIER.  THE RAW AND SMOOTHED PERIODOGRAMS OF
!     TAPERED SERIES ARE SHOWN ON PAGES 95 AND 176, RESPECTIVELY, OF
!     BLOOMFIELD.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   TAPERP
      INTEGER
     +   I,IEXTND,IPRT,ITEST,LAB,LFREQ,LPER,LPERI,LZFFT,NF,NFFT,NK,
     +   NPRT,NTEMP,NY,NZ
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AB(600),FREQ(300),PER(300),PERF(300),PERI(300),Y(150),
     +   YFFT(400),Z(275),ZFFT(600),ZT(275)
      INTEGER
     +   K(10)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CENTER,FFTLEN,FFTR,IPGM,IPGMP,IPGMPS,IPGMS,IPRINT,MDFLT,
     +   PGM,PGMS,PPL,DCOPY,TAPER
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AB(600)
!        THE VECTOR OF THE NF REAL AND IMAGINARY COMPONENTS OF THE
!        FOURIER COEFFICIENTS.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FREQ(300)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IEXTND
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
!        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
!        USED TO EXTEND THE SERIES.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ITEST
!        THE NUMBER OF THE TEST SET BEING PERFORMED
!     INTEGER K(10)
!        THE VECTOR OF THE MODIFIED DANIEL FILTER LENGTHS.
!     INTEGER LAB
!        THE LENGTH OF THE VECTOR AB.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LFREQ
!        THE LENGTH OF THE VECTOR FREQ.
!     INTEGER LPER
!        THE LENGTH OF THE VECTOR PER.
!     INTEGER LPERI
!        THE LENGTH OF THE VECTOR PERI.
!     INTEGER LZFFT
!        THE LENGTH OF THE VECTORS YFFT AND ZFFT, RESPECTIVELY..
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE EXTENDED SERIES LENGTH.
!     INTEGER NK
!        THE NUMBER OF MODIFIED DANIEL FILTERS TO BE APPLIED.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        FOR THE PERIODOGRAM ROUTINES
!        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .EQ.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
!        IF NPRT .GE.  2, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!        AND FOR THE INTEGRATED PERIODOGRAM ROUTINES
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .NE.  0, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         INTEGRATED PERIODOGRAM
!     INTEGER NTEMP
!        A TEMPORARY STORAGE LOCATION
!     INTEGER NY
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     INTEGER NZ
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Z.
!     DOUBLE PRECISION PER(300)
!        THE SERIES PERIODOGRAM.
!     DOUBLE PRECISION PERF(300)
!        THE FILTERED (SMOOTHED) PERIODOGRAM.
!     DOUBLE PRECISION PERI(300)
!        THE SERIES INTEGRATED PERIODOGRAM.
!     DOUBLE PRECISION TAPERP
!        THE PERCENT OF THE SERIES TO BE TAPERED.
!     DOUBLE PRECISION Y(150)
!         THE ARRAY CONTAINING THE TIME SERIES FROM JENKINS AND WATTS.
!     DOUBLE PRECISION YFFT(400)
!        THE VECTOR OF THE OBSERVED TIME SERIES TO BE ANALYZED USING
!        THE FFT.
!     DOUBLE PRECISION Z(275)
!        THE ARRAY OF THE WOLF SUNSPOT NUMBERS.
!     DOUBLE PRECISION ZFFT(600)
!        THE VECTOR OF THE TAPERED WOLF SUNSPOT NUMBERS TO BE
!        ANALYZED USING THE FFT.
!     DOUBLE PRECISION ZT(275)
!        THE ARRAY OF THE TAPERED SUNSPOT NUMBERS.
!
      DATA   Y(  1),  Y(  2),  Y(  3),  Y(  4),  Y(  5),  Y(  6)
     +    / -.88D0,  -.12D0,  -.89D0, -1.38D0,  -.07D0,  1.03D0/
      DATA   Y(  7),  Y(  8),  Y(  9),  Y( 10),  Y( 11),  Y( 12)
     +    / 2.14D0,   .35D0, -1.10D0, -1.78D0, -2.76D0, -1.77D0/
      DATA   Y( 13),  Y( 14),  Y( 15),  Y( 16),  Y( 17),  Y( 18)
     +    /  .98D0,  1.00D0,  -.70D0, -1.01D0, -1.30D0,  -.85D0/
      DATA   Y( 19),  Y( 20),  Y( 21),  Y( 22),  Y( 23),  Y( 24)
     +    / -.46D0,  1.63D0,   .06D0,  -.17D0, -1.01D0, -1.04D0/
      DATA   Y( 25),  Y( 26),  Y( 27),  Y( 28),  Y( 29),  Y( 30)
     +    / -.66D0, -1.12D0,  -.51D0,  -.71D0,  -.20D0,  -.13D0/
      DATA   Y( 31),  Y( 32),  Y( 33),  Y( 34),  Y( 35),  Y( 36)
     +    /  .14D0,  1.59D0,  -.76D0, -1.08D0, -1.77D0, -1.20D0/
      DATA   Y( 37),  Y( 38),  Y( 39),  Y( 40),  Y( 41),  Y( 42)
     +    /  .45D0,  -.07D0,  -.63D0,  -.35D0,  -.87D0,  -.62D0/
      DATA   Y( 43),  Y( 44),  Y( 45),  Y( 46),  Y( 47),  Y( 48)
     +    /  .28D0,  1.90D0,  2.14D0,  1.05D0,   .31D0,  1.07D0/
      DATA   Y( 49),  Y( 50)
     +    / 2.67D0,  2.44D0/
!
      DATA   Z(  1),  Z(  2),  Z(  3),  Z(  4),  Z(  5),  Z(  6)
     +    /  5.0D0,  11.0D0,  16.0D0,  23.0D0,  36.0D0,  58.0D0/
      DATA   Z(  7),  Z(  8),  Z(  9),  Z( 10),  Z( 11),  Z( 12)
     +    / 29.0D0,  20.0D0,  10.0D0,   8.0D0,   3.0D0,   0.0D0/
      DATA   Z( 13),  Z( 14),  Z( 15),  Z( 16),  Z( 17),  Z( 18)
     +    /  0.0D0,   2.0D0,  11.0D0,  27.0D0,  47.0D0,  63.0D0/
      DATA   Z( 19),  Z( 20),  Z( 21),  Z( 22),  Z( 23),  Z( 24)
     +    / 60.0D0,  39.0D0,  28.0D0,  26.0D0,  22.0D0,  11.0D0/
      DATA   Z( 25),  Z( 26),  Z( 27),  Z( 28),  Z( 29),  Z( 30)
     +    / 21.0D0,  40.0D0,  78.0D0, 122.0D0, 103.0D0,  73.0D0/
      DATA   Z( 31),  Z( 32),  Z( 33),  Z( 34),  Z( 35),  Z( 36)
     +    / 47.0D0,  35.0D0,  11.0D0,   5.0D0,  16.0D0,  34.0D0/
      DATA   Z( 37),  Z( 38),  Z( 39),  Z( 40),  Z( 41),  Z( 42)
     +    / 70.0D0,  81.0D0, 111.0D0, 101.0D0,  73.0D0,  40.0D0/
      DATA   Z( 43),  Z( 44),  Z( 45),  Z( 46),  Z( 47),  Z( 48)
     +    / 20.0D0,  16.0D0,   5.0D0,  11.0D0,  22.0D0,  40.0D0/
      DATA   Z( 49),  Z( 50),  Z( 51),  Z( 52),  Z( 53),  Z( 54)
     +    / 60.0D0,  80.9D0,  83.4D0,  47.7D0,  47.8D0,  30.7D0/
      DATA   Z( 55),  Z( 56),  Z( 57),  Z( 58),  Z( 59),  Z( 60)
     +    / 12.2D0,   9.6D0,  10.2D0,  32.4D0,  47.6D0,  54.0D0/
      DATA   Z( 61),  Z( 62),  Z( 63),  Z( 64),  Z( 65),  Z( 66)
     +    / 62.9D0,  85.9D0,  61.2D0,  45.1D0,  36.4D0,  20.9D0/
      DATA   Z( 67),  Z( 68),  Z( 69),  Z( 70),  Z( 71),  Z( 72)
     +    / 11.4D0,  37.8D0,  69.8D0, 106.1D0, 100.8D0,  81.6D0/
      DATA   Z( 73),  Z( 74),  Z( 75),  Z( 76),  Z( 77),  Z( 78)
     +    / 66.5D0,  34.8D0,  30.6D0,   7.0D0,  19.8D0,  92.5D0/
      DATA   Z( 79),  Z( 80),  Z( 81),  Z( 82),  Z( 83),  Z( 84)
     +    /154.4D0, 125.9D0,  84.8D0,  68.1D0,  38.5D0,  22.8D0/
      DATA   Z( 85),  Z( 86),  Z( 87),  Z( 88),  Z( 89),  Z( 90)
     +    / 10.2D0,  24.1D0,  82.9D0, 132.0D0, 130.9D0, 118.1D0/
      DATA   Z( 91),  Z( 92),  Z( 93),  Z( 94),  Z( 95),  Z( 96)
     +    / 89.9D0,  66.6D0,  60.0D0,  46.9D0,  41.0D0,  21.3D0/
      DATA   Z( 97),  Z( 98),  Z( 99),  Z(100),  Z(101),  Z(102)
     +    / 16.0D0,   6.4D0,   4.1D0,   6.8D0,  14.5D0,  34.0D0/
      DATA   Z(103),  Z(104),  Z(105),  Z(106),  Z(107),  Z(108)
     +    / 45.0D0,  43.1D0,  47.5D0,  42.2D0,  28.1D0,  10.1D0/
      DATA   Z(109),  Z(110),  Z(111),  Z(112),  Z(113),  Z(114)
     +    /  8.1D0,   2.5D0,   0.0D0,   1.4D0,   5.0D0,  12.2D0/
      DATA   Z(115),  Z(116),  Z(117),  Z(118),  Z(119),  Z(120)
     +    / 13.9D0,  35.4D0,  45.8D0,  41.1D0,  30.1D0,  23.9D0/
      DATA   Z(121),  Z(122),  Z(123),  Z(124),  Z(125),  Z(126)
     +    / 15.6D0,   6.6D0,   4.0D0,   1.8D0,   8.5D0,  16.6D0/
      DATA   Z(127),  Z(128),  Z(129),  Z(130),  Z(131),  Z(132)
     +    / 36.3D0,  49.6D0,  64.2D0,  67.0D0,  70.9D0,  47.8D0/
      DATA   Z(133),  Z(134),  Z(135),  Z(136),  Z(137),  Z(138)
     +    / 27.5D0,   8.5D0,  13.2D0,  56.9D0, 121.5D0, 138.3D0/
      DATA   Z(139),  Z(140),  Z(141),  Z(142),  Z(143),  Z(144)
     +    /103.2D0,  85.7D0,  64.6D0,  36.7D0,  24.2D0,  10.7D0/
      DATA   Z(145),  Z(146),  Z(147),  Z(148),  Z(149),  Z(150)
     +    / 15.0D0,  40.1D0,  61.5D0,  98.5D0, 124.7D0,  96.3D0/
      DATA   Z(151),  Z(152),  Z(153),  Z(154),  Z(155),  Z(156)
     +    / 66.6D0,  64.5D0,  54.1D0,  39.0D0,  20.6D0,   6.7D0/
      DATA   Z(157),  Z(158),  Z(159),  Z(160),  Z(161),  Z(162)
     +    /  4.3D0,  22.7D0,  54.8D0,  93.8D0,  95.8D0,  77.2D0/
      DATA   Z(163),  Z(164),  Z(165),  Z(166),  Z(167),  Z(168)
     +    / 59.1D0,  44.0D0,  47.0D0,  30.5D0,  16.3D0,   7.3D0/
      DATA   Z(169),  Z(170),  Z(171),  Z(172),  Z(173),  Z(174)
     +    / 37.6D0,  74.0D0, 139.0D0, 111.2D0, 101.6D0,  66.2D0/
      DATA   Z(175),  Z(176),  Z(177),  Z(178),  Z(179),  Z(180)
     +    / 44.7D0,  17.0D0,  11.3D0,  12.4D0,   3.4D0,   6.0D0/
      DATA   Z(181),  Z(182),  Z(183),  Z(184),  Z(185),  Z(186)
     +    / 32.3D0,  54.3D0,  59.7D0,  63.7D0,  63.5D0,  52.2D0/
      DATA   Z(187),  Z(188),  Z(189),  Z(190),  Z(191),  Z(192)
     +    / 25.4D0,  13.1D0,   6.8D0,   6.3D0,   7.1D0,  35.6D0/
      DATA   Z(193),  Z(194),  Z(195),  Z(196),  Z(197),  Z(198)
     +    / 73.0D0,  85.1D0,  78.0D0,  64.0D0,  41.8D0,  26.2D0/
      DATA   Z(199),  Z(200),  Z(201),  Z(202),  Z(203),  Z(204)
     +    / 26.7D0,  12.1D0,   9.5D0,   2.7D0,   5.0D0,  24.4D0/
      DATA   Z(205),  Z(206),  Z(207),  Z(208),  Z(209),  Z(210)
     +    / 42.0D0,  63.5D0,  53.8D0,  62.0D0,  48.5D0,  43.9D0/
      DATA   Z(211),  Z(212),  Z(213),  Z(214),  Z(215),  Z(216)
     +    / 18.6D0,   5.7D0,   3.6D0,   1.4D0,   9.6D0,  47.4D0/
      DATA   Z(217),  Z(218),  Z(219),  Z(220),  Z(221),  Z(222)
     +    / 57.1D0, 103.9D0,  80.6D0,  63.6D0,  37.6D0,  26.1D0/
      DATA   Z(223),  Z(224),  Z(225),  Z(226),  Z(227),  Z(228)
     +    / 14.2D0,   5.8D0,  16.7D0,  44.3D0,  63.9D0,  69.0D0/
      DATA   Z(229),  Z(230),  Z(231),  Z(232),  Z(233),  Z(234)
     +    / 77.8D0,  64.9D0,  35.7D0,  21.2D0,  11.1D0,   5.7D0/
      DATA   Z(235),  Z(236),  Z(237),  Z(238),  Z(239),  Z(240)
     +    /  8.7D0,  36.1D0,  79.7D0, 114.4D0, 109.6D0,  88.8D0/
      DATA   Z(241),  Z(242),  Z(243),  Z(244),  Z(245),  Z(246)
     +    / 67.8D0,  47.5D0,  30.6D0,  16.3D0,   9.6D0,  33.2D0/
      DATA   Z(247),  Z(248),  Z(249),  Z(250),  Z(251),  Z(252)
     +    / 92.6D0, 151.6D0, 136.3D0, 134.7D0,  83.9D0,  69.4D0/
      DATA   Z(253),  Z(254),  Z(255),  Z(256),  Z(257),  Z(258)
     +    / 31.5D0,  13.9D0,   4.4D0,  38.0D0, 141.7D0, 190.2D0/
      DATA   Z(259),  Z(260),  Z(261)
     +    /184.8D0, 159.0D0, 112.3D0/
!
      ITEST = 1
!
!     MAKE CALLS WITH VALID DATA
!
      NY = 50
      NZ = 261
      NFFT = 514
      NPRT = 2
      LZFFT = 600
      LPER = 514
      LPERI = 514
      TAPERP = 0.10D0
      LFREQ = 300
      IEXTND = 0
      LAB = 600
      NK = 3
      K(1) = 8
      K(2) = 8
      K(3) = 8
!
      CALL IPRINT(IPRT)
!
!     TEST OF CENTER
!
    5 WRITE (IPRT, 1018)
      CALL CENTER (Z, NZ, ZT)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VARIABLES FROM CENTER
!
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (ZT(I), I = 1, NZ)
!
!     TEST OF TAPER
!
      WRITE (IPRT, 1015)
      CALL TAPER (Z, NZ, TAPERP, ZT)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VARIABLES FROM TAPER
!
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (ZT(I), I = 1, NZ)
!
!     TEST OF PGM
!
      WRITE (IPRT, 1013)
      CALL DCOPY (NZ, ZT, 1, ZFFT, 1)
      CALL PGM (ZFFT, NZ, LZFFT, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF FFTLEN
!
      WRITE (IPRT, 1026)
      CALL FFTLEN(NFFT-2, 2, NTEMP)
      WRITE(IPRT, 1002) IERR
!
!     PRINT RETURNED VARIABLES FROM FFTLEN
!
      IF (IERR.EQ.0) WRITE (IPRT, 1027) NTEMP
!
!     TEST OF PGMS
!
      NTEMP = NFFT-1
      WRITE (IPRT, 1025)
      CALL DCOPY (NZ, ZT, 1, ZFFT, 1)
      CALL PGMS (ZFFT, NZ, NTEMP, LZFFT, IEXTND, NF, PER, LPER, FREQ,
     +   LFREQ, -2)
      WRITE (IPRT, 1027) NTEMP
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VARIABLES FROM PGMS
!
      IF (IERR.EQ.0) THEN
        WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
        WRITE (IPRT, 1004) (PER(I), I = 1, NF)
      END IF
!
!     TEST OF MDFLT
!
      WRITE (IPRT, 1016)
      CALL MDFLT (PER, NF, NK, K, PERF, LDSTAK)
      WRITE (IPRT, 1002) IERR
      IF (IERR.EQ.0) THEN
!
!       PRINT RETURNED VARIABLES FROM MDFLT
!
        WRITE (IPRT, 1004) (PERF(I), I = 1, NF)
!
!       DISPLAY SMOOTHED PERIODOGRAM ON A LOG PLOT
!
        WRITE (IPRT, 1028)
        CALL PPL (PERF, FREQ, NF, 1)
      END IF
!
!     TEST OF IPGMP
!
      WRITE (IPRT, 1029)
      CALL IPGMP (PER, FREQ, NF, NZ, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF IPGMPS
!
      WRITE (IPRT, 1030)
      CALL IPGMPS (PER, FREQ, NF, NZ, LDSTAK, PERI, NPRT)
      WRITE (IPRT, 1002) IERR
      IF (IERR.EQ.0) THEN
!
!     PRINT RETURNED VARIABLES FROM IPGMPS
!
         WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
         WRITE (IPRT, 1004) (PERI(I), I = 1, NF)
      END IF
!
!     TEST OF IPGM
!
      WRITE (IPRT, 1017)
      CALL DCOPY (NZ, ZT, 1, ZFFT, 1)
      CALL IPGM (ZFFT, NZ, LZFFT, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     TEST OF IPGMS
!
      WRITE (IPRT, 1014)
      CALL DCOPY (NZ, ZT, 1, ZFFT, 1)
      CALL IPGMS (ZFFT, NZ, LZFFT, LDSTAK, NF, PERI, LPERI, FREQ, LFREQ,
     +   NPRT)
      WRITE (IPRT, 1002) IERR
      IF (IERR.EQ.0) THEN
!
!     PRINT RETURNED VARIABLES FROM IPGMS
!
         WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
         WRITE (IPRT, 1004) (PERI(I), I = 1, NF)
      END IF
!
!     TEST OF FFTR (CENTERED DATA - O PERCENT TAPER)
!
      TAPERP = -1.0D0
      WRITE (IPRT, 1031)
      IF (NY.GE.1) CALL TAPER (Y, NY, TAPERP, YFFT)
      CALL FFTR (YFFT, NY, NFFT, IEXTND, NF, AB, LAB)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VARIABLES FROM FFTR
!
      IF (IERR.EQ.0) WRITE (IPRT, 1004) (AB(I), I = 1, NF)
!
      GO TO (10, 20, 30, 40) ITEST
!
!     CHECK MINIMUM PROBLEM SIZE
!
   10 ITEST = ITEST + 1
      NZ = 17
      NY = 17
      GO TO 5
!
!     CHECK VARIOUS OPTIONS
!
   20 ITEST = ITEST + 1
!
!     TEST OF MDFLT (ELEMENTS OF K NOT EVEN)
!
      K(1) = 7
      WRITE (IPRT, 1016)
      CALL MDFLT (PER, NF, NK, K, PERF, LDSTAK)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VARIABLES FROM MDFLT
!
      WRITE (IPRT, 1004) (PERF(I), I = 1, NF)
!
!     TEST OF PGMS (UNCENTERED DATA)
!
      IEXTND = 1
      NPRT = 1
      WRITE (IPRT, 1025)
      CALL DCOPY (NZ, Z, 1, ZFFT, 1)
      CALL PGMS (ZFFT, NZ, NFFT, LZFFT, IEXTND, NF, PER, LPER, FREQ,
     +   LFREQ, NPRT)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VARIABLES FROM PGMS
!
      WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
      WRITE (IPRT, 1004) (PER(I), I = 1, NF)
!
      NPRT = 2
      WRITE (IPRT, 1025)
      CALL DCOPY (NZ, Z, 1, ZFFT, 1)
      CALL PGMS (ZFFT, NZ, NFFT, LZFFT, IEXTND, NF, PER, LPER, FREQ,
     +   LFREQ, NPRT)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VARIABLES FROM PGMS
!
      WRITE (IPRT, 1004) (FREQ(I), I = 1, NF)
      WRITE (IPRT, 1004) (PER(I), I = 1, NF)
!
!     TEST OF FFTR (CENTERED DATA - 100 PERCENT TAPER)
!
      TAPERP = 1.1D0
      WRITE (IPRT, 1031)
      CALL TAPER (Y, NY, TAPERP, YFFT)
      CALL FFTR (YFFT, NY, NFFT, IEXTND, NF, AB, LAB)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VARIABLES FROM FFTR
!
      WRITE (IPRT, 1004) (AB(I), I = 1, NF)
!
!     TEST OF FFTR (CENTERED DATA - O PERCENT TAPER)
!
      TAPERP = -1.0D0
      WRITE (IPRT, 1031)
      CALL TAPER (Y, NY, TAPERP, YFFT)
      CALL FFTR (YFFT, NY, NFFT-1, IEXTND, NF, AB, NFFT-2)
      WRITE (IPRT, 1002) IERR
!
!     PRINT RETURNED VARIABLES FROM FFTR
!
      WRITE (IPRT, 1004) (AB(I), I = 1, NF)
!
!     PERFORM ERROR CHECKING
!
      NY = -1
      NZ = -1
      NFFT = 0
      NPRT = 2
      LZFFT = 0
      LPER = 0
      LPERI = 0
      TAPERP = 0.10D0
      LFREQ = 0
      IEXTND = 0
      LAB = 0
      NK = 0
      K(1) = 0
      K(2) = 0
      K(3) = 0
      GO TO 5
!
!     PERFORM MORE ERROR CHECKING
!
   30 ITEST = ITEST + 1
      NY = 50
      NZ = 261
      NPRT = 2
      LZFFT = 0
      LPER = 0
      LPERI = 0
      TAPERP = 0.10D0
      LFREQ = 0
      IEXTND = 0
      LAB = 0
      NK = 3
      K(1) = 0
      K(2) = 0
      K(3) = 0
      GO TO 5
!
   40 RETURN
!
!     FORMAT STATEMENTS
!
 1002 FORMAT (8H IERR IS, I5)
 1004 FORMAT (3(1X, E16.8))
 1013 FORMAT ('1', 11HTEST OF PGM)
 1014 FORMAT ('1', 13HTEST OF IPGMS)
 1015 FORMAT ('1', 13HTEST OF TAPER)
 1016 FORMAT ('1', 13HTEST OF MDFLT)
 1017 FORMAT ('1', 12HTEST OF IPGM)
 1018 FORMAT ('1', 14HTEST OF CENTER)
 1025 FORMAT ('1', 12HTEST OF PGMS)
 1026 FORMAT ('1', 14HTEST OF FFTLEN)
 1027 FORMAT (/8H NFFT IS, I6)
 1028 FORMAT ('1', 45HDISPLAY OF PERIODOGRAM SMOOTHED WITH MODIFIED,
     +   14H DANIEL FILTER)
 1029 FORMAT ('1', 13HTEST OF IPGMP)
 1030 FORMAT ('1', 14HTEST OF IPGMPS)
 1031 FORMAT ('1', 12HTEST OF FFTR)
      END
!DIFMC
      SUBROUTINE DIFMC (Y, YMISS, N, NFAC, ND, IOD, IAR, PHI, LPHI, YF,
     +   YFMISS, NYF, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE EXPANDS THE DIFFERENCE FILTER SPECIFIED BY NFAC,
!     IOD AND ND INTO PHI AND PERFORMS THE DIFFERENCE FILTERING
!     OPERATION DEFINED BY PHI ON A SERIES CONTAINING MISSING DATA,
!     RETURNING THE FILTERED SERIES IN YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YFMISS,YMISS
      INTEGER
     +   IAR,LDSTAK,LPHI,N,NFAC,NYF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PHI(*),Y(*),YF(*)
      INTEGER
     +   IOD(*),ND(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT,LDSMIN,NALL0,WORK
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,HEAD
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      CHARACTER
     +   LLDS(8)*1,LLPHI(8)*1,LN(8)*1,NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DCOEF,EISGE,ERDF,FLTARM,IPRINT,LDSCMP,STKCLR,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03, ERR04
!        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IOD(NFAC)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LLDS(8), LLPHI(8), LN(8)
!        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES LDSTAK, N
!        AND LPHI, RESPECTIVELY.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
!     INTEGER ND(NFAC)
!        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE
!        FACTORS ARE TO BE APPLIED.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     DOUBLE PRECISION PHI(LPHI)
!        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER WORK
!        THE STARTING LOCATION FOR THE WORK VECTOR NECESSARY TO
!        EXPAND THE DIFFERENCE FILTER.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!     DOUBLE PRECISION YFMISS
!        THE MISSING VALUE CODE USED IN THE FILTERED SERIES TO
!        INDICATE THE VALUE COULD NOT BE COMPUTED DUE TO MISSING DATA.
!     DOUBLE PRECISION YMISS
!        THE MISSING VALUE CODE USED IN THE INPUT SERIES TO INDICATE
!        AN OBSERVATION IS MISSING.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'D',       'I',       'F',       'M',       'C',       ' '/
      DATA
     +  LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +  LLDS(7), LLDS(8)
     + /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
      DATA
     +  LLPHI(1), LLPHI(2), LLPHI(3), LLPHI(4), LLPHI(5), LLPHI(6),
     +  LLPHI(7), LLPHI(8)
     + /  'L',   'P',   'H',   'I',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
      ERR01 = .FALSE.
      ERR02 = .FALSE.
      ERR03 = .FALSE.
      ERR04 = .FALSE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB,LN,N,3,1,HEAD,ERR01,LN)
!
      IAR = 0
!
      IF (NFAC.GE.1) THEN
!
         DO 10 I = 1, NFAC
            IAR = IAR + ND(I)*IOD(I)
   10    CONTINUE
!
         CALL ERDF(NMSUB,NFAC,ND,IOD,N,HEAD,ERR02)
!
         IF (.NOT.ERR02) THEN
            CALL EISGE(NMSUB,LLPHI,LPHI,IAR,9,HEAD,ERR03,LLPHI)
            CALL LDSCMP(1,0,0,0,0,0,'D',2*IAR,LDSMIN)
            CALL EISGE(NMSUB,LLDS,LDSTAK,LDSMIN,9,HEAD,ERR04,LLDS)
         END IF
      END IF
!
      IF (ERR01 .OR. ERR02 .OR. ERR03 .OR. ERR04) GO TO 20
      GO TO 30
!
   20 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   30 CONTINUE
!
      NYF = N
      DO 50 I = 1, NYF
         YF(I) = Y(I)
   50 CONTINUE
!
      YFMISS = YMISS
!
      IF (NFAC .LE. 0) RETURN
!
      CALL STKSET (LDSTAK, 4)
      NALL0 = STKST(1)
!
      DO 60 I = 1, LPHI
         PHI(I) = 0.0D0
   60 CONTINUE
!
      WORK = STKGET(2*IAR,4)
!
      IF (IERR .EQ. 1) GO TO 20
!
      CALL DCOEF (NFAC,ND,IOD,IAR,PHI,LPHI,RSTAK(WORK))
!
      CALL STKCLR(NALL0)
!
      IF (IERR .EQ. 1) GO TO 20
!
      CALL FLTARM (YF,YMISS,NYF,IAR,PHI,YF,YFMISS,NYF)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL DIFMC (Y, YMISS, N,'/
     +   '      +            NFAC, ND, IOD, IAR, PHI, LPHI,'/
     +   '      +            YF, YFMISS, NYF, LDSTAK)')
      END
!GMEAN
      SUBROUTINE GMEAN(Y, N, YMEAN)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE GEOMETRIC MEAN OF A SERIES, ASSUMING
!     ALL VALUES IN Y ARE NON-ZERO.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMEAN
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(N)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!  INTRINSIC FUNCTIONS
      INTRINSIC EXP,LOG
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     DOUBLE PRECISION YMEAN
!        THE GEOMETRIC MEAN OF THE OBSERVED SERIES
!
      YMEAN = 0.0D0
      DO 10 I = 1, N
         YMEAN = YMEAN + LOG(Y(I))
   10 CONTINUE
      YMEAN = EXP(YMEAN/N)
      RETURN
      END
!MATPRT
      SUBROUTINE MATPRT (X, Y, NC, IPRT, MODE, CODE, IRDIM)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE TAKES A SQUARE MATRIX AND PRINTS EITHER ITS
!     LOWER TRIANGULAR PART OR THE FULL MATRIX WITH OR WITHOUT DOUBLE
!     PRINTING.
!
!     WRITTEN BY - LINDA L. MITCHELL
!                  STATISTICAL ENGINEERING LAB/BOULDER
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   CODE,IPRT,IRDIM,MODE,NC
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(IRDIM,NC),Y(IRDIM,NC)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   TEMP
      INTEGER
     +   I,IWIDTH,J,K,KM,KN,L,NF
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CODE
!                  IF 1 -SINGLE PRINTED LINE, X ONLY (Y IS DUMMY ARG)
!                     2 -DOUBLE PRINTED LINE, BOTH X AND Y
!     INTEGER I
!                  ROW NUMBER
!     INTEGER IPRT
!                  THE OUTPUT UNIT NUMBER
!     INTEGER IRDIM
!                  ROW INDEX OF X
!     INTEGER IWIDTH
!                  THE WIDTH OF THE OUTPUT DEVICE.
!     INTEGER J
!                  FIRST COLUMN IN THE SET TO BE PRINTED
!     INTEGER K
!                  COLUMN NUMBER IN THE POSSIBLE SET OF NF
!     INTEGER KM
!                  LAST COLUMN IN THE SET
!                   LIMITED TO VALUES OF J-1 PLUS A NUMBER BETWEEN 1 AND
!                   NF (INCLUSIVE)
!     INTEGER KN
!                  LAST COLUMN TO PRINT WHEN PRINTING LOWER TRIANGLE
!     INTEGER L
!                  FIRST ROW TO PRINT FOR THIS SET
!     INTEGER MODE
!                  IF 0, LOWER TRIANGULAR PART PRINTED
!                     1, FULL MATRIX PRINTED
!                     2, LOWER TRIANGULAR PART IS PRINTED WITH
!                        SQUARE ROOTS OF THE DIAGONAL
!     INTEGER NC
!                  ROW AND COLUMN DIMENSION OF X
!     INTEGER NF
!                  THE NUMBER OF COLUMNS THAT CAN BE PRINTED, GIVEN
!                  THE WIDTH IWIDTH OF THE OUTPUT DEVICE.
!     DOUBLE PRECISION TEMP
!                  A TEMPORARY LOCATION
!     DOUBLE PRECISION X(IRDIM,NC)
!                  NC BY NC INPUT MATRIX
!     DOUBLE PRECISION Y(IRDIM,NC)
!                  MATRIX TO BE PRINTED ON THE SECOND LEVEL IF CODE=2
!
      IWIDTH = 132
      NF = MIN(7, (IWIDTH - 7)/17)
      L = 1
      DO 20 J=1,NC, NF
         KN = MIN(NC, J+NF-1)
         WRITE(IPRT,1000) (K,K=J,KN)
         WRITE(IPRT,1030)
         IF ((MODE.EQ.00) .OR. (MODE.EQ.2)) L = J
         DO 10 I=L,NC
            TEMP = X(I,I)
            KM = KN
            IF ((MODE.EQ.0) .OR. (MODE.EQ.2))
     +         KM = J + MIN(I-L, NF-1)
            IF ((MODE.EQ.2) .AND. ((I.GE.J) .AND. (I.LE.KM)))
     +         X(I,I) = SQRT(X(I,I))
            WRITE(IPRT,1010) I, (X(I,K),K=J,KM)
            IF (CODE.EQ.2) WRITE(IPRT,1020) (Y(I,K),K=J,KM)
            IF (CODE.EQ.2) WRITE(IPRT,1030)
            X(I,I) = TEMP
   10    CONTINUE
   20 CONTINUE
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/4X, 7HCOLUMN , 7(I9, 8X))
 1010 FORMAT (4X, I6, 1X, 7(3X, G14.8))
 1020 FORMAT (9X, 7(3X, G14.8))
 1030 FORMAT (4X)
      END
!ACCDIG
      SUBROUTINE ACCDIG(AX, X, AD, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     RETURNS NUMBER OF ACCURATE DIGITS, AD, IN AX AN APPROXIMATION TO X
!
!     WRITTEN BY DAVID HOGBEN, SEL, NBS.   10/29/69.
!
!     THIS ROUTINE WAS ADAPTED FROM THE OMNITAB ROUTINE ACCDIG
!     BY - -
!
!     JANET R. DONALDSON
!     STATISTICAL ENGINEERING DIVISION
!     NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AD(*),AX(*),X(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ADMAX,DIFF,FPLRS
      INTEGER
     +   I
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,LOG10,MAX,MIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AD(N)
!        THE NUMBER OF ACCURATE DIGITS.
!     DOUBLE PRECISION ADMAX
!        THE NUMBER OF DIGITS CARRIED IN A FLOATING POINT COMPUTATION.
!     DOUBLE PRECISION AX(N)
!        THE APPROXIMATION TO THE SOLUTION.
!     DOUBLE PRECISION DIFF
!        *
!     DOUBLE PRECISION FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     INTEGER I
!        AN INDEX.
!     INTEGER N
!        THE NUMBER OF ELEMENTS BEING COMPARED.
!     DOUBLE PRECISION X(N)
!        THE SOLUTION.
!
!
      FPLRS = D1MACH(4)
!
      ADMAX = -LOG10(FPLRS)
!
      DO 20 I=1,N
         DIFF = AX(I) - X(I)
         IF (DIFF.NE.0.0D0) GO TO 10
         AD(I) = ADMAX
         GO TO 20
   10    AD(I) = 0.0D0
         IF (ABS(X(I)).GT.0.0D0) AD(I) = LOG10(ABS(X(I)))
         IF (ABS(DIFF).GT.0.0D0) AD(I) = -LOG10(ABS(DIFF)) + AD(I)
         AD(I) = MIN(ADMAX,AD(I))
         AD(I) = MAX(-ADMAX,AD(I))
   20 CONTINUE
      RETURN
      END
!SVPM
      SUBROUTINE SVPM(YM, YMMISS, N, NS, ISYM)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA AND USER CONTROL OF THE PLOT SYMBOL USED
!     (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(*)
      INTEGER
     +   ISYM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IPRT,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'V',       'P',       'M',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      M = 1
      IYM = N
      MULTI = .FALSE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 1
      ISIZE = -1
      MISS = .TRUE.
      LISYM = N
      IRLIN = -1
      IBAR = 0
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL SVPM (Y, YMISS, N, NS, ISYM)')
      END
!CCFSD
      SUBROUTINE CCFSD (CCOV11, CCOV22, SDRHOC, LAGMAX, NCC, N, ICCOV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING THE STANDARD ERROR
!     OF THE CROSS CORRELATIONS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,LAGMAX,N,NCC
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV11(ICCOV),CCOV22(ICCOV),SDRHOC(NCC)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DIV,SUM
      INTEGER
     +   I,ILAST,K,K0,KM,KP
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCOV11(ICCOV), CCOV22(ICCOV)
!        THE ARRAYS IN WHICH THE AUTOCOVARIANCES ARE STORED
!     DOUBLE PRECISION DIV
!        THE SQUARE ROOT OF THE PRODUCT OF THE AUTOCOVARIANCE
!        FUNCTION VALUES AT LAG ZERO.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER ICCOV
!        THE DIMENSION OF THE ACVF ARRAYS.
!     INTEGER ILAST
!        THE LAST LAG AT WHICH THE STANDARD ERROR IS TO BE COMPUTED.
!     INTEGER K
!        AN INDEX VARIALBE.
!     INTEGER KM, KP, K0
!        THE LOCATIONS IN THE ARRAYS -RHOC- AND -SDRHOC-
!        OF THE LAG -K, K AND 0, RESPECTIVELY.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE USED.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NCC
!        THE NUMBER OF CCF COMPUTED.
!     DOUBLE PRECISION SDRHOC(NCC)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE CROSS CORRELATION
!        ARE STORED
!     DOUBLE PRECISION SUM
!         A SUMMING VARIABLE.
!
      K0 = LAGMAX + 1
!
      DIV = CCOV11(1) * CCOV22(1)
!
      SUM = 0.0D0
      DO 10 I = 1, LAGMAX
         SUM = SUM + CCOV11(I+1) * CCOV22(I+1)
   10 CONTINUE
      SUM = SUM / DIV
      SDRHOC(K0) = SQRT(N + 2.0D0 * SUM) / N
!
      DO 30 K = 1, LAGMAX
         SUM = 0.0D0
         ILAST = MIN(LAGMAX, N-LAGMAX)
         DO 20 I = 1, ILAST
            SUM = SUM + (N-K-I)*CCOV11(I+1)*CCOV22(I+1)
   20    CONTINUE
         SUM = SUM / DIV
         KM = K0 - K
         SDRHOC(KM) = SQRT((N - K) + 2.0D0 * SUM) / N
!
         KP = K0 + K
         SDRHOC(KP) = SDRHOC(KM)
!
   30 CONTINUE
!
      RETURN
      END
!AIMEC
      SUBROUTINE AIMEC(Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR ARIMA ESTIMATION
!     (CONTROL CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,STOPP,STOPSS
      INTEGER
     +   IVAPRX,LDSTAK,MIT,N,NFAC,NPAR,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),SCALE(*),STP(*),Y(*)
      INTEGER
     +   IFIXED(1),MSPEC(4,*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,NPARE
      LOGICAL
     +   SAVE
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SDPV(1),SDRES(1),VCV(1,1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMEDRV,IPRINT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!        IF IFIXED(1).LT.0, THEN IFIXED(I)=DEFAULT,I=1,...,NPAR, AND THE
!                           DIMENSION OF IFIXED WILL BE ASSUMED TO BE 1.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE FOR
!        IVAPRX LE 0, VCV = THE DEFAULT OPTION
!        IVAPRX EQ 1, VCV = INVERSE(TRANSPOSE(J)*J)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2, VCV = INVERSE(H)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4, VCV = INVERSE(TRANSPOSE(J)*J)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5, VCV = INVERSE(H)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7, VCV = THE DEFAULT OPTION
!        WITH J REPRESENTING THE JACOBIAN AND H THE HESSIAN.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE DIMENSION OF VECTOR IFIXED.
!     INTEGER LPV
!        THE DIMENSION OF VECTOR PV.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER LSDPV
!        THE DIMENSION OF VECTOR SDPV.
!     INTEGER LSDRES
!        THE DIMENSION OF VECTOR SDRES.
!     INTEGER LSTP
!        THE DIMENSION OF VECTOR STP.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER MSPEC(4,NFAC)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PV(1)
!        THE PREDICTED VALUE OF THE FIT, UNUSED WHEN SAVE = FALSE.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(NPAR)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!        IF SCALE(1).LE.0, THEN SCALE(I)=DEFAULT,I=1,...,NPAR, AND THE
!                          DIMENSION OF SCALE WILL BE ASSUMED TO BE 1.
!     DOUBLE PRECISION SDPV(1)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES, UNUSED
!        WHEN SAVE = FALSE.
!     DOUBLE PRECISION SDRES(1)
!        THE STANDARDIZED RESIDUALS, UNUSED WHEN SAVE = FALSE.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(1)
!        THE STEP SIZE ARRAY.
!        IF STP(1).LE.0, THEN STP(I)=DEFAULT,I=1,...,NPAR, AND THE
!                        DIMENSION OF STP WILL BE ASSUMED TO BE 1.
!     DOUBLE PRECISION VCV(1,1)
!        THE VARIANCE-COVARIANCE MATRIX, UNUSED WHEN SAVE = FALSE.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'A','I','M','E','C',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      SAVE = .FALSE.
!
      LIFIXD = NPAR
      IF (IFIXED(1).LE.-1) LIFIXD = 1
      LPV = 1
      LSCALE = NPAR
      IF (SCALE(1).LE.0.0D0) LSCALE = 1
      LSTP = NPAR
      IF (STP(1).LE.0.0D0) LSTP = 1
      LSDPV = 1
      LSDRES = 1
      IVCV = 1
!
      CALL AMEDRV(Y, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, SAVE, NPARE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/' THE CORRECT FORM OF THE CALL STATEMENT IS'//
     +  '       CALL AIMEC (Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK,'/
     +  '      +            IFIXED, STP, MIT, STOPSS, STOPP, SCALE,'/
     +  '      +            DELTA, IVAPRX, NPRT)')
      END
!LLSW
      SUBROUTINE LLSW(Y, WT, XM, N, IXM, NPAR, RES, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CALL FOR GENERAL LINEAR MODEL LEAST SQUARES FIT
!     USER SUPPLIED WEIGHTS SPECIFIED
!     NO STORAGE OTHER THAN RESIDUALS
!     FOUR PAGES AUTOMATIC PRINTOUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RES(*),WT(*),XM(*),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LPAR,LPV,LSDPV,LSDRES,LWT,NPRT
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(1),PV(1),SDPV(1),SDRES(1),VCV(1,1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLCNTG
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     DOUBLE PRECISION PAR(1)
!        A DUMMY ARRAY FOR
!        THE PARAMETERS  TO BE ESTIMATED.
!     DOUBLE PRECISION PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUES.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(N)
!        A DUMMY ARRAY FOR
!        THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,NPAR)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'L','L','S','W',' ',' '/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      WEIGHT = .TRUE.
      SAVE = .FALSE.
      NPRT = 1111
      LPAR = 1
      LPV = 1
      LSDPV = 1
      LSDRES = 1
      IVCV = 1
      LWT = N
!
      CALL LLCNTG(Y, WT, LWT, XM, N, IXM, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (//42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL LLSW (Y, WT, XM, N, IXM, NPAR, RES, LSDTAK)')
      END
!STPLS2
      SUBROUTINE STPLS2(NPAR, STP)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     SET UP PROBLEM SPECIFICATION FOR TESTING THE USER CALLABLE
!     ROUTINES IN THE (LEAST SQUARES) STEP SIZE SELECTION FAMILY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   STP(NPAR)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     DOUBLE PRECISION STP(NPAR)
!        THE STEP SIZE ARRAY.
!
      DO 10 I=1,NPAR
         STP(I) = -1.0D0
   10 CONTINUE
!
      IERR = -1
!
      RETURN
!
      END
!NLSS
      SUBROUTINE NLSS(Y, XM, N, M, IXM, MDL, PAR, NPAR, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
!     (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IVAPRX,IVCV,IXM,LDSTAK,M,MIT,N,NPAR,NPARE,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),STP(*),VCV(*),
     +   XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,LWT,NNZW
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   WT(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTN
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(NPAR)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(NPAR)
!        THE STEP SIZE ARRAY.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(1)
!        THE DUMMY ARRAY FOR THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','S',' ',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      WEIGHT = .FALSE.
      SAVE = .TRUE.
!
      WT(1) = 1.0D0
      LIFIXD = NPAR
      LPV = N
      LSCALE = NPAR
      LSTP = NPAR
      LSDPV = N
      LSDRES = N
      LWT = 1
!
      CALL NLCNTN(Y, WT, LWT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSS (Y, XM, N, M, IXM, NLSMDL,'/
     +   '      +           PAR, NPAR, RES, LDSTAK,'/
     +   '      +           IFIXED, STP, MIT, STOPSS, STOPP,'/
     +   '      +           SCALE, DELTA, IVAPRX, NPRT,'/
     +   '      +           NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)')
      END
!CORRS
      SUBROUTINE CORRS(YM, N, M, IYM, LDSTAK, NPRT, VCV, IVCV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR THE CORRELATION FAMILY.
!     IT IS THE LONG CALL FORM.
!     THIS ROUTINE CALLS CORRER TO CHECK FOR ERRORS IN THE PARAMETERS.
!     IF THERE ARE NO PROBLEMS IT THEN ALLOCATES SPACE IN CSTAK
!     FOR THE VECTORS NEEDED AND CALLS THE MAIN ROUTINE, CORRMN, TO DO
!     THE CORRELATION ANALYSIS.
!
!     WRITTEN BY -
!        LINDA L. MITCHELL
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IVCV,IYM,LDSTAK,M,N,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VCV(*),YM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   AVG,CILO,CIUP,ICOR,IFP,IPRT,IWRK,LIWRK,LWRK,NALL0,PC,QF,
     +   QUAD,RANK,SC,SCINV,SD,SLPC,SLSC,SRCC,T,WRK
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CORRER,CORRMN,IPRINT,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER AVG
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  AVERAGES OF YM
!     INTEGER CILO
!                  OCCUPIES THE SAME SPACE AS SLPC AND IS THE LOWER
!                  CONFIDENCE INTERVAL
!     INTEGER CIUP
!                  OCCUPIES THE SAME SPACE AS SLSC AND IS THE UPPER
!                  CONFIDENCE INTERVAL
!     DOUBLE PRECISION DSTAK(12)
!                  THE DOUBLE PRECISION VERSION OF
!                  THE /CSTAK/ WORK AREA.
!     INTEGER ICOR
!                  DETERMINES WHICH SUBROUTINE CALLED CORRMN
!                  IF =1, THEN CALLED BY CORR
!                     =2, THEN CALLED BY CORRS
!     INTEGER IERR
!                  A FLAG RETURNED TO THE USER INDICATING
!                  WHETHER  ERRORS WERE DETECTED IN THE PARAMETER LIST
!                  IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!                  IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!                  AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3
!                  INDICATES SINGLE PRECISION AND IFP=4 INDICATES
!                  DOUBLE PRECISION.
!     INTEGER IPRT
!                  LOGICAL OUTPUT UNIT
!     INTEGER ISTAK(12)
!                  THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IVCV
!                  THE DIMENSION OF VCV ASSIGNED IN THE USERS PROGRAM.
!     INTEGER IWRK
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  INTEGER WORK VECTOR.
!     INTEGER IYM
!                  ROW DIMENSION OF YM SPECIFIED IN THE USERS PROGRAM.
!     INTEGER LDSTAK
!                  SIZE OF WORK AREA ALLOCATED IN THE USERS PROGRAM
!     INTEGER LIWRK
!                  THE LENGTH OF THE INTEGER WORK VECTOR.
!     INTEGER LWRK
!                  THE LENGTH OF THE DOUBLE PRECISION WORK VECTOR.
!     INTEGER M
!                  THE NUMBER OF VARIABLES
!     INTEGER N
!                  THE NUMBER OF OBSERVATIONS
!     INTEGER NALL0
!                  THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE
!                  TIME THAT THIS ROUTINE WAS CALLED.
!     CHARACTER*1 NMSUB(6)
!                  THE SUBROUTINE NAME
!     INTEGER NPRT
!                  THE VARIABLE CONTROLLING THE AUTOMATIC PRINTOUT
!                  NPRT = 0 PRINTOUT IS SUPRESSED
!                  OTHERWISE THE PRINTOUT IS PROVIDED.
!     INTEGER PC
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  THE PARTIAL CORRELATION COEFFICIENTS MATRIX
!     INTEGER QF
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  QUADRATIC FIT MATRIX
!     INTEGER QUAD
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  DOUBLE PRECISION  QUAD FIT
!     INTEGER RANK
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  MATRIX CONTAINING THE RANKS OF YM
!     DOUBLE PRECISION RSTAK(12)
!                  THE DOUBLE PRECISION VERSION OF
!                  THE /CSTAK/ WORK AREA.
!     INTEGER SC
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  THE SIMPLE CORRELATION COEFFICIENTS MATRIX
!     INTEGER SCINV
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  INVERSE MATRIX OF VCV
!     INTEGER SD
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  STANDARD DEVIATIONS VECTOR
!     INTEGER SLPC
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  SIGNIFICANCE LEVELS FOR PC
!     INTEGER SLSC
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  SIGNIFICANCE LEVELS FOR SC
!     INTEGER SRCC
!                  STARTING LOCATION IN THE WORK AREA FOR THE SPEAR-
!                  MAN RANK COEFFICIENTS
!     INTEGER T
!                  STARTING LOCATION IN THE WORK AREA
!                  FOR THE WORK VECTOR T
!     DOUBLE PRECISION VCV(IVCV,M)
!                  THE VARIANCE COVARIANCE MATRIX
!     INTEGER WRK
!                  THE STARTING LOCATION IN THE WORK AREA FOR
!                  WORK SPACE
!     DOUBLE PRECISION YM(IYM,M)
!                  THE OBSERVATION MATRIX
!
!
!     SET UP NAME ARRAY
!
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'C',      'O',      'R',      'R',      'S',      ' '/
!
!     SET UP FRAMEWORK VARIABLES FOR NUMBER TYPES
!
      IFP = 4
!
!     SET THE CALLER FLAG, THIS IS CORRS
!
      ICOR = 2
!
!     CHECK FOR ERRORS IN PARAMETERS
!
      CALL CORRER(NMSUB, M, N, IYM, IVCV, LDSTAK, ICOR, NPRT)
!
!     IF THERE IS AN ERROR RETURN TO THE CALLERS ROUTINE
!
      IF (IERR.EQ.0) GO TO 10
!
!     PRINT CORRECT FORM OF CALL STATEMENT AND RETURN TO CALLER
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     INITIALIZE THE STACK
!
   10 CALL STKSET (LDSTAK, 4)
      NALL0 = STKST(1)
!
!     ALLOCATE SPACE IN DSTAK FOR MATRICES
!
      LIWRK = MAX(N,M)
      LWRK = LIWRK
!
      WRK = STKGET(LWRK,IFP)
!
      IF (NPRT.EQ.0) THEN
         IWRK = WRK
         T = WRK
         RANK = WRK
         SC = WRK
         SCINV = WRK
         SLSC = WRK
         PC = WRK
         SLPC = WRK
         QUAD = WRK
         QF = WRK
      ELSE
         IWRK = STKGET(LIWRK,2)
         T = STKGET(M,IFP)
         RANK = STKGET(N*M,IFP)
         SC = STKGET(M*M,IFP)
         SCINV = STKGET(M*M,IFP)
         SLSC = STKGET(M*M,IFP)
         PC = STKGET(M*M,IFP)
         SLPC = STKGET(M*M,IFP)
         QUAD = STKGET(3*N,IFP)
         QF = STKGET(M*M,IFP)
      END IF
!
!     THE FOLLOWING VARIABLES HAVE BEEN INDIRECTLY EQUIVALENCED-
!
      CIUP = SLSC
      CILO = SLPC
      AVG = WRK
      SD = WRK
      SRCC = SCINV
!
      CALL CORRMN(YM, N, M, IYM, RSTAK(AVG), RSTAK(SD), RSTAK(T),
     +   RSTAK(RANK), RSTAK(SC), RSTAK(PC), RSTAK(SCINV), ISTAK(IWRK),
     +   RSTAK(WRK), RSTAK(SLSC), RSTAK(SLPC), RSTAK(SRCC),
     +   RSTAK(QUAD), RSTAK(CIUP), RSTAK(CILO), RSTAK(QF),
     +   NPRT, VCV, IVCV, LIWRK, LWRK)
!
!     RETURN AREA TO WORK
!
      CALL STKCLR(NALL0)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL CORRS (YM, N, M, IYM, LDSTAK, NPRT, VCV, IVCV)')
      END
!RANDN
      function randn(jd,typ) result(randn_)
      real(kind=wp) :: randn_
      real(kind=wp),intent(in) :: typ
!***BEGIN PROLOGUE  RANDN (ORIGINALLY RNOR)
!***DATE WRITTEN   810915
!***REVISION DATE  900315
!***CATEGORY NO.  L6A14
!***KEYWORDS  RANDOM NUMBERS, UNIFORM RANDOM NUMBERS
!***AUTHOR    KAHANER, DAVID
!             APPLIED AND COMPUTATIONAL MATHEMATICS DIVISTION, NIST
!
!             MARSAGLIA, GEORGE
!             COMPUTER SCIENCE DEPT., WASH STATE UNIV
!
!             MODIFIED BY -
!             DONALDSON, JANET
!             APPLIED AND COMPUTATIONAL MATHEMATICS DIVISTION, NIST
!
!***PURPOSE  GENERATES QUASI NORMAL RANDOM NUMBERS, WITH MEAN ZERO AND
!             UNIT STANDARD DEVIATION, AND CAN BE USED WITH ANY COMPUTER
!             WITH INTEGERS AT LEAST AS LARGE AS 32767.
!***DESCRIPTION
!
!       RANDN GENERATES QUASI NORMAL RANDOM NUMBERS WITH ZERO MEAN AND
!       UNIT STANDARD DEVIATION.
!       IT CAN BE USED WITH ANY COMPUTER WITH INTEGERS AT LEAST AS
!       LARGE AS 32767.
!
!
!   USE
!       FIRST TIME....
!                   Z = RANDN(JD)
!                     HERE JD IS ANY  N O N - Z E R O  INTEGER.
!                     THIS CAUSES INITIALIZATION OF THE PROGRAM
!                     AND THE FIRST RANDOM NUMBER TO BE RETURNED AS Z.
!       SUBSEQUENT TIMES...
!                   Z = RANDN(0)
!                     CAUSES THE NEXT RANDOM NUMBER TO BE RETURNED AS Z.
!
!=======================================================================
!
!    NOTE: USERS WHO WISH TO TRANSPORT THIS PROGRAM TO OTHER
!           COMPUTERS SHOULD READ THE FOLLOWING ....
!
!   MACHINE DEPENDENCIES...
!      MDIG = A LOWER BOUND ON THE NUMBER OF BINARY DIGITS AVAILABLE
!              FOR REPRESENTING INTEGERS, INCLUDING THE SIGN BIT.
!              THIS MUST BE AT LEAST 16, BUT CAN BE INCREASED IN
!              LINE WITH REMARK A BELOW.
!
!   REMARKS...
!     A. THIS PROGRAM CAN BE USED IN TWO WAYS:
!        (1) TO OBTAIN REPEATABLE RESULTS ON DIFFERENT COMPUTERS,
!            SET 'MDIG' TO THE SMALLEST OF ITS VALUES ON EACH, OR,
!        (2) TO ALLOW THE LONGEST SEQUENCE OF RANDOM NUMBERS TO BE
!            GENERATED WITHOUT CYCLING (REPEATING) SET 'MDIG' TO THE
!            LARGEST POSSIBLE VALUE.
!     B. THE SEQUENCE OF NUMBERS GENERATED DEPENDS ON THE INITIAL
!          INPUT 'JD' AS WELL AS THE VALUE OF 'MDIG'.
!          IF MDIG=16 ONE SHOULD FIND THAT
!            THE FIRST EVALUATION
!              Z=RANDN(87) GIVES  Z=-.40079207...
!            THE SECOND EVALUATION
!              Z=RANDN(0) GIVES   Z=-1.8728870...
!            THE THIRD EVALUATION
!              Z=RANDN(0) GIVES   Z=1.8216004...
!            THE FOURTH EVALUATION
!              Z=RANDN(0) GIVES   Z=.69410355...
!            THE THOUSANDTH EVALUATION
!              Z=RANDN(0) GIVES   Z=.96782424...
!
!***REFERENCES  MARSAGLIA & TSANG, "A FAST, EASILY IMPLEMENTED
!                 METHOD FOR SAMPLING FROM DECREASING OR
!                 SYMMETRIC UNIMODAL DENSITY FUNCTIONS", TO BE
!                 PUBLISHED IN SIAM J SISC 1983.
!***ROUTINES CALLED  I1MACH,XERROR
!***END PROLOGUE  RANDN
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   jd
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   aa,b,c,c1,c2,one,p5,pc,rmax,s,x,xn,y
      integer
     +   i,i1,j,j0,j1,jseed,k0,k1,m1,m2,mdig
!
!  LOCAL ARRAYS
      real(kind=wp) ::
     +   v(65),w(65)
      integer
     +   m(17)
!
!  EXTERNAL FUNCTIONS
      real(kind=wp) ::
     +   randu
      integer
     +   i1mach
      external randu,i1mach
!
!  EXTERNAL SUBROUTINES
      external xerror
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,exp,log,min,mod,real,sign
!
!  SAVE STATEMENT
      save i1,j1,m,m1,m2,rmax
!
      data aa,b,c,rmax/12.37586_wp,0.4878992_wp,12.67706_wp,
     + 3.0518509e-5_wp/
      data c1,c2,pc,xn/0.9689279_wp,1.301198_wp,0.1958303e-1_wp,
     + 2.776994_wp/
      data (v(i),i=1,15)/0.3409450_wp,0.4573146_wp,0.5397793_wp,
     +     0.6062427_wp,0.6631691_wp,0.7136975_wp,0.7596125_wp,
     + 0.8020356_wp,
     +     0.8417227_wp,0.8792102_wp,0.9148948_wp,0.9490791_wp,
     + 0.9820005_wp,
     +     1.0138492_wp,1.0447810_wp/
      data (v(i),i=16,30)/1.0749254_wp,1.1043917_wp,1.1332738_wp,
     +     1.1616530_wp,1.1896010_wp,1.2171815_wp,1.2444516_wp,
     + 1.2714635_wp,
     +     1.2982650_wp,1.3249008_wp,1.3514125_wp,1.3778399_wp,
     + 1.4042211_wp,
     +     1.4305929_wp,1.4569915_wp/
      data (v(i),i=31,45)/1.4834526_wp,1.5100121_wp,1.5367061_wp,
     +     1.5635712_wp,1.5906454_wp,1.6179680_wp,1.6455802_wp,
     + 1.6735255_wp,
     +     1.7018503_wp,1.7306045_wp,1.7598422_wp,1.7896223_wp,
     + 1.8200099_wp,
     +     1.8510770_wp,1.8829044_wp/
      data (v(i),i=46,60)/1.9155830_wp,1.9492166_wp,1.9839239_wp,
     +     2.0198430_wp,2.0571356_wp,2.0959930_wp,2.1366450_wp,
     + 2.1793713_wp,
     +     2.2245175_wp,2.2725185_wp,2.3239338_wp,2.3795007_wp,
     + 2.4402218_wp,
     +     2.5075117_wp,2.5834658_wp/
      data (v(i),i=61,65)/2.6713916_wp,2.7769943_wp,2.7769943_wp,
     +     2.7769943_wp,2.7769943/
      data (w(i),i=1,20)/0.10405134e-04_wp,0.13956560e-04_wp,
     + 0.16473259e-04_wp,
     +     0.18501623e-04_wp,0.20238931e-04_wp,0.21780983e-04_wp,
     + 0.23182241e-04_wp,
     +     0.24476931e-04_wp,0.25688121e-04_wp,0.26832186e-04_wp,
     + 0.27921226e-04_wp,
     +     0.28964480e-04_wp,0.29969191e-04_wp,0.30941168e-04_wp,
     + 0.31885160e-04_wp,
     +     0.32805121e-04_wp,0.33704388e-04_wp,0.34585827e-04_wp,
     + 0.35451919e-04_wp,
     +     0.36304851e-04_wp/
      data (w(i),i=21,40)/0.37146564e-04_wp,0.37978808e-04_wp,
     + 0.38803170e-04_wp,
     +     0.39621114e-04_wp,0.40433997e-04_wp,0.41243096e-04_wp,
     + 0.42049621e-04_wp,
     +     0.42854734e-04_wp,0.43659562e-04_wp,0.44465208e-04_wp,
     + 0.45272764e-04_wp,
     +     0.46083321e-04_wp,0.46897980e-04_wp,0.47717864e-04_wp,
     + 0.48544128e-04_wp,
     +     0.49377973e-04_wp,0.50220656e-04_wp,0.51073504e-04_wp,
     + 0.51937936e-04_wp,
     +     0.52815471e-04_wp/
      data (w(i),i=41,60)/0.53707761e-04_wp,0.54616606e-04_wp,
     + 0.55543990e-04_wp,
     +     0.56492112e-04_wp,0.57463436e-04_wp,0.58460740e-04_wp,
     + 0.59487185e-04_wp,
     +     0.60546402e-04_wp,0.61642600e-04_wp,0.62780711e-04_wp,
     + 0.63966581e-04_wp,
     +     0.65207221e-04_wp,0.66511165e-04_wp,0.67888959e-04_wp,
     + 0.69353880e-04_wp,
     +     0.70922996e-04_wp,0.72618816e-04_wp,0.74471933e-04_wp,
     + 0.76525519e-04_wp,
     +     0.78843526e-04_wp/
      data (w(i),i=61,65)/0.81526890e-04_wp,0.84749727e-04_wp,
     + 0.84749727e-04_wp,
     +     0.84749727e-04_wp,0.84749727e-04_wp/
      data m(1),m(2),m(3),m(4),m(5),m(6),m(7),m(8),m(9),m(10),m(11),
     +     m(12),m(13),m(14),m(15),m(16),m(17)/30788,23052,2053,19346,
     +     10646,19427,23975,19049,10949,19693,29746,26748,2796,23890,
     +     29168,31924,16499/
      data m1,m2,i1,j1/32767,256,5,17/
      data p5,one/0.5_wp,1.0_wp/
!
! FAST PART...
!
!
!***FIRST EXECUTABLE STATEMENT  RANDN
      if (jd.ne.0) then
!  FILL
          mdig = i1mach(8) + 1
!
!  MODIFICATION SO SAME NUMBERS WILL BE GENERATED ON ALL MACHINES
!  WITH I1MACH(8) AT LEAST 31
!
          mdig = min(mdig,32)
!
!  BE SURE THAT MDIG AT LEAST 16...
          if (mdig.lt.16) call xerror('RANDN--MDIG LESS THAN 16',23,1,2)
!
          m1 = 2** (mdig-2) + (2** (mdig-2)-1)
          m2 = 2** (mdig/2)
          jseed = min(abs(jd),m1)
          if (mod(jseed,2).eq.0) jseed = jseed - 1
          k0 = mod(9069,m2)
          k1 = 9069/m2
          j0 = mod(jseed,m2)
          j1 = jseed/m2
          do 10 i = 1,17
              jseed = j0*k0
              j1 = mod(jseed/m2+j0*k1+j1*k0,m2/2)
              j0 = mod(jseed,m2)
              m(i) = j0 + m2*j1
   10     continue
          j1 = 17
          i1 = 5
          rmax = one/real(m1,kind=wp)
!  SEED UNIFORM (0,1] GENERATOR.  (JUST A DUMMY CALL)
          randn_ = randu(jd)
          do 20 i = 1,65
              w(i) = rmax*v(i)
   20     continue
      end if

      i = m(i1) - m(j1)
      if (i.lt.0) i = i + m1
      m(j1) = i
      i1 = i1 - 1
      if (i1.eq.0) i1 = 17
      j1 = j1 - 1
      if (j1.eq.0) j1 = 17
      j = mod(i,64) + 1
      randn_ = i*w(j+1)
      if (((i/m2)/2)*2.eq. (i/m2)) randn_ = -randn_
      if (abs(randn_).gt.v(j)) then
!  SLOW PART; AA IS A*F(0)
          x = (abs(randn_)-v(j))/ (v(j+1)-v(j))
          y = randu(0)
          s = x + y
          if (s.le.c2) then
              if (s.le.c1) then
                  return
              else if (y.le.c-aa*exp(-p5 * (b-b*x)**2)) then
                  if (exp(-p5*v(j+1)**2)+y*pc/v(j+1).gt.
     +                exp(-p5*randn_**2)) then
   30                 continue
! TAIL PART; 3.855849 IS .5*XN**2
                      s = xn - log(randu(0))/xn
                      if (3.855849_wp+log(randu(0))-xn*s.gt.
     +                    -p5*s**2) go to 30
                      randn_ = sign(s,randn_)
                  end if
                  return
              else
              end if
          end if
          randn_ = sign(b-b*x,randn_)
      end if
      end
!HIST
      SUBROUTINE HIST(Y, N, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR PRODUCING A HISTOGRAM
!     (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   YLB,YUB
      INTEGER
     +   IDP,IFP,IINT,IPRT,LSORT,NALL0,NCELLS,YDIST
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL HSTER,HSTMN,IPRINT,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ANINT,LOG10,MIN,NINT,DBLE
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDP
!        THE CODE VALUE FOR DOUBLE PRECISION FOR FRAMEWORK.
!     INTEGER IERR
!        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
!        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
!        SOME ERROR EXISTS.
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IINT
!        THE CODE VALUE FOR INTEGER FOR FRAMEWORK
!     INTEGER IPRT
!        THE NUMBER OF THE STANDARD OUTPUT UNIT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
!        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
!     INTEGER LSORT
!        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION
!        VECTOR.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
!        WAS CALLED.
!     INTEGER NCELLS
!        THE NUMBER OF CELLS IN THE HISTOGRAM.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION Y(N)
!        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
!        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
!        TO ITS ORIGINAL ORDER AFTERWARDS.
!     INTEGER YDIST
!        THE STARTING LOCATION IN RSTAK OF THE DISTRIBUTION VECTOR.
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!
!     INITIALIZE NAME VECTORS
!
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'H',      'I',      'S',      'T',      ' ',      ' '/
!
      DATA IDP /4/
      DATA IINT /2/
      DATA YLB/0.0D0/, YUB/0.0D0/
!
!     COMPUTE NCELLS
!
      IF (N.GE.1) THEN
         NCELLS = MIN(NINT(5.5D0+1.5D0*ANINT(LOG10(DBLE(N)))),25)
      ELSE
         NCELLS = 1
      END IF
!
!     CHECK FOR ERRORS IN THE INPUT PARAMETERS
!
      CALL HSTER(NMSUB, Y, N, NCELLS, LDSTAK, YLB, YUB, IERR)
      IF (IERR.EQ.0) GO TO 10
!
!     PRINT ERROR MESSAGE.
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     SET UP FRAMEWORK AREA.
!
   10 CALL STKSET (LDSTAK, IDP)
      NALL0 = STKST(1)
!
!     SET UP WORK VECTORS
!
      IFP = 4
!
      LSORT = STKGET(N,IINT)
      YDIST = STKGET(NCELLS,IFP)
!
!     COMPUTE THE HISTOGRAM.
!
      CALL HSTMN(Y, N, NCELLS, YLB, YUB, ISTAK(LSORT), RSTAK(YDIST))
!
!     RETURN THE WORK VECTORS.
!
      CALL STKCLR(NALL0)
      RETURN
!
!     FORMAT STATEMENTS.
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL HIST (Y, N, LDSTAK)')
      END
!PGMEST
      SUBROUTINE PGMEST (YFFT, NFFT, NF, CNST, PER, LPER)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE PERIODOGRAM ESTIMATES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CNST
      INTEGER
     +   LPER,NF,NFFT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PER(LPER),YFFT(NFFT)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FAC
      INTEGER
     +   I,ISN,NFFT2
!
!  EXTERNAL SUBROUTINES
      EXTERNAL FFT,REALTR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CNST
!        THE VARIANCE OF THE OBSERVED TIME SERIES TIMES THE NUMBER OF
!        OBSERVATIONS IN THE SERIES IF CALLED BY IPGM,
!        OR 1.0D0 IF CALLED BY PGM.
!     DOUBLE PRECISION FAC
!        A FACTOR USED FOR COMPUTATIONS OF THE INTEGRATED PERIODOGRAM.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER ISN
!        A CODE USED FOR THE FFT.
!     INTEGER LPER
!        THE LENGTH OF THE PERIODOGRAM ARRAY.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        COMPUTED.
!     INTEGER NFFT
!        THE EFFECTIVE NUMBER OF OBSERVATIONS FOR THE FFT TRANSFORM.
!     INTEGER NFFT2
!        THE EFFECTIVE NUMBER OF COMPLEX OBSERVATIONS FOR THE FFT
!        TRANSFORM.
!     DOUBLE PRECISION PER(LPER)
!        THE PERIODOGRAM.
!     DOUBLE PRECISION YFFT(NFFT)
!        THE CENTERED SERIES.
!
!     COMPUTE THE FOURIER COEFFICIENTS
!
      NFFT2 = (NFFT-2) / 2
      ISN = 2
!
      CALL FFT (YFFT(1), YFFT(2), NFFT2, NFFT2, NFFT2, ISN)
      CALL REALTR (YFFT(1), YFFT(2), NFFT2, ISN)
!
      FAC = 0.5D0 / (CNST * (NFFT-2))
!
      NF = NFFT2 + 1
!
      DO 10 I = 1, NF
         PER(I) = (YFFT(2*I-1)*YFFT(2*I-1) + YFFT(2*I)*YFFT(2*I)) * FAC
   10 CONTINUE
!
      RETURN
      END
!CCFLST
      SUBROUTINE CCFLST (RHOC, SDRHOC, NLPP12, NLPP21, LAGMAX, LCCOV,
     +   NCC, IFMISS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE ACTUALLY LISTS THE CROSS CORRELATIONS AND THEIR
!     STANDARD ERRORS, AND MISCELLANEOUS SUMMARY INFORMATION.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LAGMAX,LCCOV,NCC
      LOGICAL
     +   IFMISS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RHOC(*),SDRHOC(*)
      INTEGER
     +   NLPP12(*),NLPP21(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,I1,IMAX,IMIN,IPRT,K,K0,K1,LAGN,NPERL
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RLST(12),SDRLST(12)
      INTEGER
     +   LAG(12),NLPLST(12)
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN,MOD
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     LOGICAL IFMISS
!        THE INDICATOR VARIABLE USED TO DETERMINE
!        WHETHER THE INPUT SERIES HAS MISSING DATA OR NOT.
!     INTEGER IMAX, IMIN
!        THE INDEX VALUES OF THE FIRST AND LAST OBSERVATION
!        TO BE PRINTED PER LINE
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT
!     INTEGER I1
!        AN INDEX VARIABLE.
!     INTEGER K, K0, K1
!        INDEX VARIABLES.
!     INTEGER LAG(12)
!        THE LAG VALUE OF THE CORRELATION BEING PRINTED.
!     INTEGER LAGMAX
!        THE LARGEST LAG VALUE TO BE USED.
!     INTEGER LAGN
!        THE NUMBER OF LAG VALUES TO BE PRINTED PER LINE.
!     INTEGER LCCOV
!        THE NUMBER OF LOCATIONS ALLOWED FOR STORING THE NLPPC.
!     INTEGER NCC
!        THE NUMBER OF CROSS CORRELATIONS COMPUTED (FROM -LAGMAX
!        TO +LAGMAX).
!     INTEGER NLPLST(12)
!        THE ARRAY WHICH CONTAINS THE VALUES OF NLPPC TO BE PRINTED
!        ON EACH LINE, ORDERED PROPERLY.
!     INTEGER NLPP12(LCCOV), NLPP21(LCCOV)
!        THE NUMBER OF LAGGED PRODUCT PAIRS USED TO COMPUTE EACH
!        CCVF AT EACH LAG.
!     INTEGER NPERL
!        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
!     DOUBLE PRECISION RHOC(NCC)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS OR PARTIAL
!        AUTOCORRELATIONS WILL BE PASSED TO THIS ROUTINE.
!     DOUBLE PRECISION RLST(12)
!        THE ARRAY WHICH CONTAINS THE VALUES OF RHO TO BE PRINTED
!        ON EACH LINE, ORDERED PROPERLY.
!     DOUBLE PRECISION SDRHOC(NCC)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!        ARE STORED
!     DOUBLE PRECISION SDRLST(12)
!        THE ARRAY WHICH CONTAINS THE VALUES OF SDRHO TO BE PRINTED
!        ON EACH LINE, ORDERED PROPERLY.
!
!
      CALL IPRINT(IPRT)
      NPERL = 12
!
      K0 = LAGMAX + 1
!
      LAGN = MOD(LAGMAX, NPERL)
      IF (LAGN .EQ. 0) LAGN = NPERL
      I1 = LAGN + 1
!
      DO 20 I = I1, K0, NPERL
         DO 10 K = 1, LAGN
            LAG(K) = I - K0 - K
            K1 = I - K
            RLST(K) = RHOC(K1)
            SDRLST(K) = SDRHOC(K1)
            IF (.NOT. IFMISS) GO TO 10
            K1 = K0 - K1
            NLPLST(K) = NLPP21(K1+1)
   10    CONTINUE
         WRITE(IPRT, 1000) (LAG(K), K = 1, LAGN)
         WRITE(IPRT, 1001) (RLST(K), K = 1, LAGN)
         WRITE(IPRT, 1002) (SDRLST(K), K = 1, LAGN)
         IF (IFMISS) WRITE(IPRT, 1003) (NLPLST(K), K = 1, LAGN)
         LAGN = NPERL
   20 CONTINUE
!
      LAG(1) = 0
      WRITE(IPRT, 1000) LAG(1)
      WRITE(IPRT, 1001) RHOC(K0)
      WRITE(IPRT, 1002) SDRHOC(K0)
      IF (IFMISS) WRITE(IPRT, 1003) NLPP12(1)
!
      DO 40 I = 1, LAGMAX, NPERL
         IMIN = I + K0
         IMAX = MIN(IMIN + NPERL - 1, 2*LAGMAX+1)
         LAGN = IMAX - IMIN + 1
         DO 30 K = 1, LAGN
            LAG(K) = I - 1 + K
   30    CONTINUE
         WRITE(IPRT, 1000) (LAG(K), K = 1, LAGN)
         WRITE(IPRT, 1001) (RHOC(K), K = IMIN, IMAX)
         WRITE(IPRT, 1002) (SDRHOC(K), K = IMIN, IMAX)
         IF (.NOT. IFMISS) GO TO 40
         IMIN = I
         IMAX = MIN(I + NPERL - 1, LAGMAX)
         WRITE (IPRT,1003) (NLPP12(K+1), K=IMIN,IMAX)
   40 CONTINUE
!
      FPLM = D1MACH(2)
!
      IF (SDRHOC(1).EQ.FPLM .OR. SDRHOC(2*LAGMAX+1).EQ.FPLM)
     +   WRITE(IPRT, 1004) FPLM
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/19H LAG               , 12(1X, I6))
 1001 FORMAT( 19H CCF               , 12(2X, F5.2))
 1002 FORMAT( 19H STANDARD ERROR    , 12(2X, F5.2))
 1003 FORMAT( 19H NO. OF OBS. USED  , 12(1X, I6))
 1004 FORMAT(///5X, F5.2, 38H INDICATES VALUE COULD NOT BE COMPUTED,
     +   21H DUE TO MISSING DATA.)
      END
!MDLTS2
      SUBROUTINE MDLTS2 (PAR, RESTS, Y, NPAR, N, NFAC, MSPECT, PMU,
     +  PARDF, NPARDF, T, TEMP, PARAR, PARMA, MBO, N1, N2, IFLAG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MODEL ROUTINE FOR PACKS SPECIFICATION OF
!     BOX-JENKINS MODELS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 4, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   PMU
      INTEGER
     +   IFLAG,MBO,N,N1,N2,NFAC,NPAR,NPARDF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PARAR(*),PARDF(*),PARMA(*),RESTS(N1:N2),T(*),
     +   TEMP(*),Y(N)
      INTEGER
     +   MSPECT(NFAC,4)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLPM,RESMAX,WTEST
      INTEGER
     +   I,IMOD,IMOD1,IPAR,IPQ,ISTART,J,K,L,MAXORD,MBO1,NP,NPARAR,
     +   NPARMA
      LOGICAL
     +   PARLE1
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,LOG,MOD,SIGN,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION FPLPM
!        THE FLOATING POINT LARGEST POSITIVE MAGNITUDE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IFLAG
!        AN INDICATOR VARIABLE DESIGNATING WHETHER THE BACK FORECASTS
!        WERE ESSENTIALLY ZERO (IFLAG=0) OR NOT (IFLAG=1).
!     INTEGER IMOD
!        AN INDEX VARIABLE.
!     INTEGER IPAR
!        AN INDEX VARIABLE.
!     INTEGER IPQ
!        AN INDEX VARIABLE.
!     INTEGER ISTART
!        ***
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER L
!        AN INDEX VARIABLE.
!     INTEGER MAXORD
!        THE LARGEST BACK ORDER.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBO1
!        THE VALUE MBO+1
!     INTEGER MSPECT(NFAC,4)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NP
!        THE NUMBER OF PARAMETERS IN THE EXPANDED TERM.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER N1
!        THE LOWER BOUND FOR RESTS.
!     INTEGER N2
!        THE UPPER BOUND FOR RESTS.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PARAR(MBO)
!        THE AUTOREGRESSIVE PARAMETERS
!     DOUBLE PRECISION PARDF(NPARDF)
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS.
!     LOGICAL PARLE1
!        A FLAG INDICATING WHETHER ALL OF THE MOVING AVERAGE PARAMETERS
!        ARE LESS THAN OR EQUAL TO 1 (PARLE1 = .TRUE.) OR NOT
!        (PARLE1 = .FALSE.)
!     DOUBLE PRECISION PARMA(MBO)
!        THE MOVING AVERAGE PARAMETERS
!     DOUBLE PRECISION PMU
!        THE VALUE OF MU, I.E., THE TREND OR MEAN.
!     DOUBLE PRECISION RESMAX
!        THE LARGEST POSSIBLE RESIDUAL WHICH WILL STILL AVOID OVERFLOW.
!     DOUBLE PRECISION RESTS(N1:N2)
!        THE PREDICTED VALUE OF THE FIT.
!     DOUBLE PRECISION T(2*MBO)
!        A TEMPORARY WORK VECTOR.
!     DOUBLE PRECISION TEMP(MBO)
!        A TEMPORARY WORK VECTOR
!     DOUBLE PRECISION WTEST
!        THE TEST VALUE USED TO DETERMINE IF THE DIFFERENCED SERIES
!        BACK FORECAST IS EFFECTIVELY ZERO OR NOT.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
      FPLPM = D1MACH(2)
!
!     ZERO THE PARAMETER ARRAYS PARAR AND PARMA
!
      DO 10 I=1,MBO
         T(I) = 0.0D0
         TEMP(I) = 0.0D0
   10 CONTINUE
!
      NP = 0
      IPAR = 0
      NPARAR = 0
      ISTART = 0
!
!     EXPAND THE MODEL AND STORE AUTOREGRESSIVE PARAMETERS IN PARAR
!     AND MOVING AVERAGE PARAMETERS IN PARMA
!
      DO 110 IPQ = 1, 3, 2
         DO 100 L=1,NFAC
            IF (MSPECT(L,IPQ).EQ.0) GO TO 100
            MAXORD = MSPECT(L,IPQ)*MSPECT(L,4)
            DO 90 K = MSPECT(L,4), MAXORD, MSPECT(L,4)
               IPAR = IPAR + 1
               TEMP(K) = TEMP(K) + PAR(IPAR)
               DO 80 I = 1, NP
                  TEMP(K+I) = TEMP(K+I) - T(I)*PAR(IPAR)
   80          CONTINUE
   90       CONTINUE
            NP = NP + MAXORD
            DO 95 K = 1, NP
               T(K) = TEMP(K)
   95       CONTINUE
  100    CONTINUE
          IF (IPQ.NE.3) THEN
            IPAR = IPAR + 1
            PMU = PAR(IPAR)
            NPARAR = NP
            DO 105 K =1, NPARAR
               PARAR(K) = T(K)
               T(K) = 0.0D0
               TEMP(K) = 0.0D0
  105       CONTINUE
            NP = 0
         END IF
  110 CONTINUE
      NPARMA = NP
      PARLE1 = .TRUE.
      DO 115 K =1, NPARMA
         PARMA(K) = T(K)
         IF (ABS(PARMA(K)).GT.1.0D0) PARLE1 = .FALSE.
  115 CONTINUE
!
!     COMPUTE FITTED VALUES AND RESIDUALS FOR MODEL.
!
!     COMPUTE W, THE DIFFERENCED SERIES MINUS ITS MEAN, AND STORE IN
!     RESTS(NPARDF+1) TO RESTS(N2)
!
      DO 140 I = NPARDF+1, N2, 1
         RESTS(I) = Y(I) - PMU
         DO 130 J = 1,NPARDF
            RESTS(I) = RESTS(I) - PARDF(J)*Y(I-J)
  130    CONTINUE
  140 CONTINUE
      WTEST = ABS(RESTS(NPARDF+1))*0.01
!
!     BACK FORECAST THE ERROR, E, FOR I = N-NPARAR TO NPARDF+1, AND
!     THE DIFFERENCED SERIES FOR I = NPARDF TO N1
!
      MBO1 = MBO+1
      IFLAG = 0
      DO 170 I = N2-NPARAR,NPARDF+1,-1
         IMOD = MOD(I+1-N1,MBO1) + 1
         T(IMOD) = RESTS(I)
         DO 150 J = 1,NPARAR
            T(IMOD) = T(IMOD) - PARAR(J)*RESTS(I+J)
  150    CONTINUE
         DO 160 J = 1,NPARMA
            IF ((I+J.GT.NPARDF) .AND. (I+J.LE.N))
     +         T(IMOD) = T(IMOD) + PARMA(J)*T(MOD(I+J+1-N1,MBO1)+1)
  160    CONTINUE
  170 CONTINUE
      DO 175 I = NPARDF,N1,-1
         IMOD = MOD(I+1-N1,MBO1) + 1
         RESTS(I) = 0.0D0
         DO 163 J = 1,NPARAR
            RESTS(I) = RESTS(I) + PARAR(J)*RESTS(I+J)
  163    CONTINUE
         DO 166 J = 1,NPARMA
            IF ((I+J.GT.NPARDF) .AND. (I+J.LE.N))
     +         RESTS(I) = RESTS(I) -
     +                    PARMA(J)*T(MOD(I+J+1-N1,MBO1)+1)
  166    CONTINUE
         ISTART = I
         IF ((ISTART.LE.1) .AND. (ABS(RESTS(I)).LE.WTEST)) GO TO 180
  175 CONTINUE
      IFLAG = 1
!
!     COMPUTE RESIDUALS AND STORE VALUES IN RESTS
!
  180 CONTINUE
      DO 210 I = ISTART,N2,1
         IMOD = MOD(I+1-N1,MBO1) + 1
         T(IMOD) = RESTS(I)
         DO 190 J = 1,NPARAR
            IF (I-J.GE.ISTART) T(IMOD) = T(IMOD) - PARAR(J)*RESTS(I-J)
  190    CONTINUE
!
         IF (PARLE1) THEN
!
!     COMPUTE RESIDUALS WHERE THERE IS NO CHANCE OF OVERFLOW
!
            DO 200 J = 1,NPARMA
               IF (I-J.GE.ISTART)
     +            T(IMOD) = T(IMOD) + PARMA(J)*T(MOD(I-J+1-N1,MBO1)+1)
  200       CONTINUE
         ELSE
!
!     COMPUTE RESIDUALS WHERE THERE IS A CHANCE OF OVERFLOW
!
            DO 205 J = 1,NPARMA
               IF (I-J.GE.ISTART) THEN
                  IMOD1 = MOD(I-J+1-N1,MBO1)+1
                  IF (PARMA(J).NE.0.0D0 .AND. T(IMOD1).NE.0.0D0) THEN
                     IF (LOG(ABS(PARMA(J)))+LOG(ABS(T(IMOD1))).LT.
     +                         LOG(FPLPM)
     +                     .AND.
     +                     (SIGN(1.0D0,T(IMOD)).NE.
     +                         SIGN(1.0D0,PARMA(J)*T(IMOD1))
     +                     .OR.
     +                     LOG(ABS(PARMA(J)))+LOG(ABS(T(IMOD1))).LT.
     +                         LOG(FPLPM-ABS(T(IMOD))))) THEN
                        T(IMOD) = T(IMOD) + PARMA(J)*T(IMOD1)
                     ELSE
                        GO TO 300
                     END IF
                  END IF
               END IF
  205       CONTINUE
         END IF
         IF (I-MBO.GE.ISTART) THEN
            RESTS(I-MBO) = T(MOD(I-MBO+1-N1,MBO1)+1)
         END IF
  210 CONTINUE
      DO 220 I = N-MBO+1,N
        RESTS(I) = T(MOD(I-MBO+2-N1,MBO1)+1)
  220 CONTINUE
!
      DO 230 I = N1, ISTART-1
         RESTS(I) = 0.0D0
  230 CONTINUE
!
      RETURN
!
!     SET RESIDUALS TO LARGEST POSSIBLE VALUE
!
  300 RESMAX = SQRT(FPLPM/(N2-N1+1))
      DO 310 I=N1,N2
         RESTS(I) = RESMAX
  310 CONTINUE
!
      RETURN
!
      END
!CORRXP
      SUBROUTINE CORRXP(M, VCV, IVCV, IPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     PRINT STORED OUTPUT RETURNED FROM CORRS
!
!     WRITTEN BY -
!        LINDA MITCHELL
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IPRT,IVCV,M
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VCV(*)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL MATPRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IPRT
!        THE LOGICAL OUTPUT NUMBER
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV
!     INTEGER M
!        THE NUMBER OF VARIABLES IN THE ANALYSIS
!     DOUBLE PRECISION VCV(IVCV,M)
!        ARRAYS TO BE PRINTED
!
      IF (IVCV.GE.M) THEN
         WRITE (IPRT,1000)
         WRITE (IPRT,1010)
         CALL MATPRT(VCV, VCV, M, IPRT, 1, 1, IVCV)
      END IF
!
!     FORMAT STATEMENTS
!
      RETURN
 1000 FORMAT (/ 20H STORAGE FROM CORRS.)
 1010 FORMAT (40H STORAGE FROM VARIANCE-COVARIANCE MATRIX)
      END
!MPPC
      SUBROUTINE MPPC(YM, X, N, M, IYM, ILOG, ISIZE, NOUT, YLB, YUB,
     +  XLB, XUB)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH MULTIPLE Y-AXIS VALUES (LONG CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   ILOG,ISIZE,IYM,M,N,NOUT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   IPRT,ISCHCK,LISYM
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(IYM,M)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'P',       'P',       'C',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      XMISS = 1.0D0
      MULTI = .TRUE.
      ISCHCK = 2
      MISS = .FALSE.
      LISYM = 1
!
      CALL PPCNT (YM, YM, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL MPPC (YM, X, N, M, IYM, ILOG,'/
     +  '      +           ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      END
!ACFMNM
      SUBROUTINE ACFMNM(Y, YMISS, N, LAGMAX, RHO, SDRHO, NLPPA, YMEAN,
     +   PRHO, AIC, FTEST, PHI, IAR, OSPVAR, ACOV, LACOV, LAIC, CHIA,
     +   CHIAP, LAGLST, WORK, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING AUTOCORRELATIONS AND
!     PARTIAL AUTOCORRELATIONS OF A TIME SERIES WITH MISSING DATA.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN,YMISS
      INTEGER
     +   IAR,LACOV,LAGLST,LAGMAX,LAIC,N,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),AIC(*),FTEST(2,*),PHI(*),PRHO(*),RHO(*),SDRHO(*),
     +   WORK(*),Y(*)
      INTEGER
     +   NLPPA(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,NUSED
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACFSDM,ACVFM,AOS,CHIRHO
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV)
!        THE AUTOCOVARIANCE FUNCTION ESTIMATE VECTOR.
!     DOUBLE PRECISION AIC(LAIC)
!        THE ARRAY CONTAINING AKAIAES CRITERION FOR EACH ORDER.
!     DOUBLE PRECISION CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     DOUBLE PRECISION FTEST(2, LAGMAX)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGLST
!        THE LAST LAG BEFORE MISSING DATA CAUSED THE ACVF OF THE
!        SERIES NOT TO BE COMPUTED.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER NLPPA(LACOV)
!        THE ARRAY CONTAINING THE NUMBERS OF LAGGED PRODUCT PAIRS
!        USED TO COMPUTE THE ACVF AT EACH LAG.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     INTEGER NUSED
!        THE NUMBER OF ACTIVE (NOT MISSING) OBSERVATIONS IN THE SERIES.
!     DOUBLE PRECISION OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED ORDER (IAR).
!     DOUBLE PRECISION PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER (IAR).
!     DOUBLE PRECISION PRHO(LAGMAX)
!        THE ARRAY IN WHICH THE PARTIAL AUTOCORRELATIONS ARE STORED
!     DOUBLE PRECISION RHO(LAGMAX)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
!     DOUBLE PRECISION SDRHO(LAGMAX)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!        ARE STORED
!     DOUBLE PRECISION WORK(LAGMAX)
!        AN ARRAY USED IN THE COMPUTATIONS OF THE PARTIAL
!        AUTOCORRELATIONS COEFFICIENTS.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER
!        OR NOT AN OBSERVATION IN THE SERIES IS MISSING.
!        IF Y(I) .EQ. YMISS, THE VALUE IS ASSUMED MISSING.
!        IF Y(I) .NE. YMISS, THE VALUE IS ASSUMED NOT MISSING.
!
!
      FPLM = D1MACH(2)
!
!     COMPUTE AUTOCOVARIANCES OF THE SERIES WITH MISSING DATA.
!
      CALL ACVFM(Y, YMISS, N, YMEAN, ACOV, LAGMAX, LAGLST, NLPPA, LACOV)
!
      IF (NLPPA(1) .EQ. 0 .OR. ACOV(1) .EQ. 0.0D0) RETURN
!
      IF (NPRT .EQ. 0) RETURN
!
!     COMPUTE PARTIAL AUTOCORRELATIONS AND THE AUTOREGRESSIVE MODEL
!     ORDER SELECTION STATISTICS IF THERE WERE NO MISSING DATA.
!
      IF (NLPPA(1) .EQ. N) CALL AOS (N, LAGMAX, ACOV, PRHO, IAR,
     +   OSPVAR, PHI, WORK, AIC, FTEST, LACOV, LAIC)
!
!     COMPUTE AUTOCORRELATIONS.
!
      DO 10 I = 1, LAGMAX
         IF (NLPPA(I+1) .GE. 1) RHO(I) = ACOV(I+1) / ACOV(1)
   10 CONTINUE
!
!     PRESET SDRHO VALUES FOR PRINTING ROUTINE
!
      DO 20 I = LAGLST, LAGMAX
         SDRHO(I) = FPLM
   20 CONTINUE
!
!     COMPUTE STANDARD ERROR OF AUTOCORRELATIONS.
!
      CALL ACFSDM (RHO, SDRHO, LAGLST, N, NLPPA(2))
!
      IF (LAGLST .EQ. 0) RETURN
!
!     COMPUTE CHI STATISTIC BASED ON AUTOCORRELATION VALUES
!
      NUSED = NLPPA(1)
!
      CALL CHIRHO (RHO, NUSED, LAGLST, CHIA, CHIAP)
!
      RETURN
      END
!XXCH11
      SUBROUTINE XXCH11(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE COMPLEX DEMODULATION FAMILY OF ROUTINES.
!
!     DATA IS THE WOLF SUMSPOT NUMBERS FOR THE YEARS 1700 TO 1960 AS
!     TABULATED BY WALDMEIER [1961].
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FC,FD
      INTEGER
     +   IPRT,K,N
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   Y(300)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DEMOD,IPRINT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FC
!        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
!     DOUBLE PRECISION FD
!        THE DEMODULATION FREQUENCY.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER K
!        THE NUMBER OF TERMS IN THE SYMETRIC LINEAR FILTER.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     DOUBLE PRECISION Y(300)
!        THE LOG OF THE AIRLINE DATA.
!
!
      DATA   Y(  1),  Y(  2),  Y(  3),  Y(  4),  Y(  5),  Y(  6)
     +    /     5.0D0, 11.0D0, 16.0D0, 23.0D0, 36.0D0, 58.0D0/
      DATA   Y(  7),  Y(  8),  Y(  9),  Y( 10),  Y( 11),  Y( 12)
     +    /    29.0D0, 20.0D0, 10.0D0,  8.0D0,  3.0D0,  0.0D0/
      DATA   Y( 13),  Y( 14),  Y( 15),  Y( 16),  Y( 17),  Y( 18)
     +    /     0.0D0, 2.0D0, 11.0D0, 27.0D0, 47.0D0, 63.0D0/
      DATA   Y( 19),  Y( 20),  Y( 21),  Y( 22),  Y( 23),  Y( 24)
     +    /    60.0D0, 39.0D0, 28.0D0, 26.0D0, 22.0D0, 11.0D0/
      DATA   Y( 25),  Y( 26),  Y( 27),  Y( 28),  Y( 29),  Y( 30)
     +    /    21.0D0, 40.0D0, 78.0D0,122.0D0,103.0D0, 73.0D0/
      DATA   Y( 31),  Y( 32),  Y( 33),  Y( 34),  Y( 35),  Y( 36)
     +    /    47.0D0, 35.0D0, 11.0D0,  5.0D0, 16.0D0, 34.0D0/
      DATA   Y( 37),  Y( 38),  Y( 39),  Y( 40),  Y( 41),  Y( 42)
     +    /    70.0D0, 81.0D0,111.0D0,101.0D0, 73.0D0, 40.0D0/
      DATA   Y( 43),  Y( 44),  Y( 45),  Y( 46),  Y( 47),  Y( 48)
     +    /    20.0D0, 16.0D0,  5.0D0, 11.0D0, 22.0D0, 40.0D0/
      DATA   Y( 49),  Y( 50),  Y( 51),  Y( 52),  Y( 53),  Y( 54)
     +    /    60.0D0, 80.9D0, 83.4D0, 47.7D0, 47.8D0, 30.7D0/
      DATA   Y( 55),  Y( 56),  Y( 57),  Y( 58),  Y( 59),  Y( 60)
     +    /    12.2D0,  9.6D0, 10.2D0, 32.4D0, 47.6D0, 54.0D0/
      DATA   Y( 61),  Y( 62),  Y( 63),  Y( 64),  Y( 65),  Y( 66)
     +    /    62.9D0, 85.9D0, 61.2D0, 45.1D0, 36.4D0, 20.9D0/
      DATA   Y( 67),  Y( 68),  Y( 69),  Y( 70),  Y( 71),  Y( 72)
     +    /    11.4D0, 37.8D0, 69.8D0,106.1D0,100.8D0, 81.6D0/
      DATA   Y( 73),  Y( 74),  Y( 75),  Y( 76),  Y( 77),  Y( 78)
     +    /    66.5D0, 34.8D0, 30.6D0,  7.0D0, 19.8D0, 92.5D0/
      DATA   Y( 79),  Y( 80),  Y( 81),  Y( 82),  Y( 83),  Y( 84)
     +    /   154.4D0,125.9D0, 84.8D0, 68.1D0, 38.5D0, 22.8D0/
      DATA   Y( 85),  Y( 86),  Y( 87),  Y( 88),  Y( 89),  Y( 90)
     +    /    10.2D0, 24.1D0, 82.9D0,132.0D0,130.9D0,118.1D0/
      DATA   Y( 91),  Y( 92),  Y( 93),  Y( 94),  Y( 95),  Y( 96)
     +    /    89.9D0, 66.6D0, 60.0D0, 46.9D0, 41.0D0, 21.3D0/
      DATA   Y( 97),  Y( 98),  Y( 99),  Y(100),  Y(101),  Y(102)
     +    /    16.0D0,  6.4D0,  4.1D0,  6.8D0, 14.5D0, 34.0D0/
      DATA   Y(103),  Y(104),  Y(105),  Y(106),  Y(107),  Y(108)
     +    /    45.0D0, 43.1D0, 47.5D0, 42.2D0, 28.1D0, 10.1D0/
      DATA   Y(109),  Y(110),  Y(111),  Y(112),  Y(113),  Y(114)
     +    /     8.1D0,  2.5D0,  0.0D0,  1.4D0,  5.0D0, 12.2D0/
      DATA   Y(115),  Y(116),  Y(117),  Y(118),  Y(119),  Y(120)
     +    /    13.9D0, 35.4D0, 45.8D0, 41.1D0, 30.1D0, 23.9D0/
      DATA   Y(121),  Y(122),  Y(123),  Y(124),  Y(125),  Y(126)
     +    /    15.6D0,  6.6D0,  4.0D0,  1.8D0,  8.5D0, 16.6D0/
      DATA   Y(127),  Y(128),  Y(129),  Y(130),  Y(131),  Y(132)
     +    /    36.3D0, 49.6D0, 64.2D0, 67.0D0, 70.9D0, 47.8D0/
      DATA   Y(133),  Y(134),  Y(135),  Y(136),  Y(137),  Y(138)
     +    /    27.5D0,  8.5D0, 13.2D0, 56.9D0,121.5D0,138.3D0/
      DATA   Y(139),  Y(140),  Y(141),  Y(142),  Y(143),  Y(144)
     +    /   103.2D0, 85.7D0, 64.6D0, 36.7D0, 24.2D0, 10.7D0/
      DATA   Y(145),  Y(146),  Y(147),  Y(148),  Y(149),  Y(150)
     +    /    15.0D0, 40.1D0, 61.5D0, 98.5D0,124.7D0, 96.3D0/
      DATA   Y(151),  Y(152),  Y(153),  Y(154),  Y(155),  Y(156)
     +    /    66.6D0, 64.5D0, 54.1D0, 39.0D0, 20.6D0,  6.7D0/
      DATA   Y(157),  Y(158),  Y(159),  Y(160),  Y(161),  Y(162)
     +    /     4.3D0, 22.7D0, 54.8D0, 93.8D0, 95.8D0, 77.2D0/
      DATA   Y(163),  Y(164),  Y(165),  Y(166),  Y(167),  Y(168)
     +    /    59.1D0, 44.0D0, 47.0D0, 30.5D0, 16.3D0,  7.3D0/
      DATA   Y(169),  Y(170),  Y(171),  Y(172),  Y(173),  Y(174)
     +    /    37.6D0, 74.0D0,139.0D0,111.2D0,101.6D0, 66.2D0/
      DATA   Y(175),  Y(176),  Y(177),  Y(178),  Y(179),  Y(180)
     +    /    44.7D0, 17.0D0, 11.3D0, 12.4D0,  3.4D0,  6.0D0/
      DATA   Y(181),  Y(182),  Y(183),  Y(184),  Y(185),  Y(186)
     +    /    32.3D0, 54.3D0, 59.7D0, 63.7D0, 63.5D0, 52.2D0/
      DATA   Y(187),  Y(188),  Y(189),  Y(190),  Y(191),  Y(192)
     +    /    25.4D0, 13.1D0,  6.8D0,  6.3D0,  7.1D0, 35.6D0/
      DATA   Y(193),  Y(194),  Y(195),  Y(196),  Y(197),  Y(198)
     +    /    73.0D0, 85.1D0, 78.0D0, 64.0D0, 41.8D0, 26.2D0/
      DATA   Y(199),  Y(200),  Y(201),  Y(202),  Y(203),  Y(204)
     +    /    26.7D0, 12.1D0,  9.5D0,  2.7D0,  5.0D0, 24.4D0/
      DATA   Y(205),  Y(206),  Y(207),  Y(208),  Y(209),  Y(210)
     +    /    42.0D0, 63.5D0, 53.8D0, 62.0D0, 48.5D0, 43.9D0/
      DATA   Y(211),  Y(212),  Y(213),  Y(214),  Y(215),  Y(216)
     +    /    18.6D0,  5.7D0,  3.6D0,  1.4D0,  9.6D0, 47.4D0/
      DATA   Y(217),  Y(218),  Y(219),  Y(220),  Y(221),  Y(222)
     +    /    57.1D0,103.9D0, 80.6D0, 63.6D0, 37.6D0, 26.1D0/
      DATA   Y(223),  Y(224),  Y(225),  Y(226),  Y(227),  Y(228)
     +    /    14.2D0,  5.8D0, 16.7D0, 44.3D0, 63.9D0, 69.0D0/
      DATA   Y(229),  Y(230),  Y(231),  Y(232),  Y(233),  Y(234)
     +    /    77.8D0, 64.9D0, 35.7D0, 21.2D0, 11.1D0,  5.7D0/
      DATA   Y(235),  Y(236),  Y(237),  Y(238),  Y(239),  Y(240)
     +    /     8.7D0, 36.1D0, 79.7D0,114.4D0,109.6D0, 88.8D0/
      DATA   Y(241),  Y(242),  Y(243),  Y(244),  Y(245),  Y(246)
     +    /    67.8D0, 47.5D0, 30.6D0, 16.3D0,  9.6D0, 33.2D0/
      DATA   Y(247),  Y(248),  Y(249),  Y(250),  Y(251),  Y(252)
     +    /    92.6D0,151.6D0,136.3D0,134.7D0, 83.9D0, 69.4D0/
      DATA   Y(253),  Y(254),  Y(255),  Y(256),  Y(257),  Y(258)
     +    /    31.5D0, 13.9D0,  4.4D0, 38.0D0,141.7D0,190.2D0/
      DATA   Y(259),  Y(260),  Y(261)
     +    /   184.8D0,159.0D0,112.3D0/
!
!     DEFINE CONSTANTS
!
      CALL IPRINT(IPRT)
      N = 261
      FD = 1.0/11.0
      FC = 1.0/22.0
      K = 41
!
!     WRITE HEADER
!
      WRITE(IPRT, 1000)
!
!     RUN SIMPLE TEST OF DIF
!
      WRITE(IPRT, 1100)
      CALL DEMOD (Y, N, FD, FC, K, LDSTAK)
      WRITE (IPRT,2000) IERR
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT ('1*CH11')
 1100 FORMAT (' SIMPLE TEST OF DEMOD')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
!DEMDRV
      SUBROUTINE DEMDRV (Y, N, FD, FC, K, HLP, AMPL, PHASE, IPHASE,
     +   NDEM, NPRT, NMSUB)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE DRIVER ROUTINE TO DEMODULATE SERIES
!     Y AT FREQUENCY FD, TO APPLY A LOW PASS FILTER WITH CUTOFF
!     FREQUENCY FC, AND TO EXTRACT THE AMPLITUDE AND PHASE COMPONENTS
!     OF THE RESULTING FILTERED SERIES .
!
!     WRITTEN BY  -  PETER BLOOMFIELD
!                    FOURIER ANALYSIS OF TIME SERIES- AN
!                       INTRODUCTION
!                    JOHN WILEY AND SONS, NEW YORK, 1976
!                    PAGE 147
!     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
!                                STATISTICAL ENGINEERING DIVISION
!                                NATIONAL BUREAU OF STANDARDS
!                                BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC,FD
      INTEGER
     +   IPHASE,K,N,NDEM,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AMPL(N),HLP(K),PHASE(IPHASE,2),Y(N)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DEMODU,DEMORD,DEMOUT,FLTSL,LPFLT,POLAR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AMPL(N)
!        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
!     DOUBLE PRECISION FC
!        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
!     DOUBLE PRECISION FD
!        THE DEMODULATION FREQUENCY.
!     DOUBLE PRECISION HLP(K)
!        THE ARRAY IN WHICH THE LOW PASS FILTER COEFFICIENTS ARE
!        STORED.
!     INTEGER K
!        THE USER SUPPLIED NUMBER OF TERMS TO BE USED FOR THE LOW
!        PASS FILTER.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDEM
!        THE NUMBER OF VALUES IN THE DEMODULATED SERIES, I.E., IN
!        THE AMPLITUDE AND PHASE ARRAYS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF NPRT
!        IS ZERO, NO OUTPUT IS GIVEN, OTHERWISE OUTPUT IS PROVIDED.
!     DOUBLE PRECISION PHASE(IPHASE,2)
!        THE ARRAY CONTAINING THE PRIMARY AND SECONDARY PHASE ESTIMATES.
!     DOUBLE PRECISION Y(N)
!        THE INPUT ARRAY CONTAINING THE OBSERVED SERIES.
!
!
      CALL DEMODU (Y, N, FD, AMPL, PHASE)
      CALL LPFLT (FC, K, HLP)
      CALL FLTSL (AMPL, N, K, HLP, AMPL, NDEM)
      CALL FLTSL (PHASE, N, K, HLP, PHASE, NDEM)
!
      CALL POLAR (AMPL, PHASE, NDEM)
!
      IF (NPRT .EQ. 0) RETURN
!
      CALL DEMORD (PHASE, PHASE(1,2), NDEM, N)
      CALL DEMOUT (FD, FC, K, AMPL, PHASE, IPHASE, NDEM, NMSUB)
!
      RETURN
!
      END
!DIFC
      SUBROUTINE DIFC (Y, N, NFAC, ND, IOD, IAR, PHI, LPHI, YF, NYF,
     +   LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE EXPANDS THE DIFFERENCE FILTER SPECIFIED BY NFAC,
!     IOD AND ND INTO PHI AND PERFORMS THE DIFFERENCE FILTERING
!     OPERATION DEFINED BY PHI, RETURNING THE FILTERED SERIES
!     IN YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IAR,LDSTAK,LPHI,N,NFAC,NYF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PHI(*),Y(*),YF(*)
      INTEGER
     +   IOD(*),ND(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT,LDSMIN,NALL0,WORK
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,HEAD
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      CHARACTER
     +   LLDS(8)*1,LLPHI(8)*1,LN(8)*1,NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DCOEF,EISGE,ERDF,FLTAR,IPRINT,LDSCMP,STKCLR,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03, ERR04
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IOD(NFAC)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LLDS(8), LLPHI(8), LN(8)
!        THE ARRAYS CONTAINING THE NAMES OF VARIOUS VARIABLES
!     INTEGER LPHI
!        THE LENGTH OF THE ARRAY PHI.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING WORK AREA ALLOCATIONS.
!     INTEGER ND(NFAC)
!        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE
!        FACTORS ARE TO BE APPLIED.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     DOUBLE PRECISION PHI(LPHI)
!        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER WORK
!        THE STARTING LOCATION FOR THE WORK VECTOR NECESSARY TO
!        EXPAND THE DIFFERENCE FILTER.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'D',       'I',       'F',       'C',       ' ',       ' '/
      DATA
     +  LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +  LLDS(7), LLDS(8)
     + /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
      DATA
     +  LLPHI(1), LLPHI(2), LLPHI(3), LLPHI(4), LLPHI(5), LLPHI(6),
     +  LLPHI(7), LLPHI(8)
     + /  'L',   'P',   'H',   'I',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
      ERR01 = .FALSE.
      ERR02 = .FALSE.
      ERR03 = .FALSE.
      ERR04 = .FALSE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB,LN,N,3,1,HEAD,ERR01,LN)
!
      IAR = 0
!
      IF (NFAC.GE.1) THEN
!
         DO 10 I = 1, NFAC
            IAR = IAR + ND(I)*IOD(I)
   10    CONTINUE
!
         CALL ERDF(NMSUB,NFAC,ND,IOD,N,HEAD,ERR02)
!
         IF (.NOT.ERR02) THEN
            CALL EISGE(NMSUB,LLPHI,LPHI,IAR,9,HEAD,ERR03,LLPHI)
            CALL LDSCMP(1,0,0,0,0,0,'D',2*IAR,LDSMIN)
            CALL EISGE(NMSUB,LLDS,LDSTAK,LDSMIN,9,HEAD,ERR04,LLDS)
         END IF
      END IF
!
!
      IF (ERR01 .OR. ERR02 .OR. ERR03 .OR. ERR04) GO TO 20
      GO TO 30
!
   20 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   30 CONTINUE
!
      NYF = N
      DO 50 I = 1, NYF
         YF(I) = Y(I)
   50 CONTINUE
!
      IF (NFAC .LE. 0) RETURN
!
      CALL STKSET (LDSTAK, 4)
      NALL0 = STKST(1)
!
      DO 60 I = 1, LPHI
         PHI(I) = 0.0D0
   60 CONTINUE
!
      WORK = STKGET(2*IAR, 4)
!
      IF (IERR .EQ. 1) GO TO 20
!
      CALL DCOEF (NFAC,ND,IOD,IAR,PHI,LPHI,RSTAK(WORK))
!
      CALL STKCLR(NALL0)
!
      IF (IERR .EQ. 1) GO TO 20
!
      CALL FLTAR (YF,NYF,IAR,PHI,YF,NYF)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL DIFC (Y, N,'/
     +   '      +           NFAC, ND, IOD, IAR, PHI, LPHI,'/
     +   '      +           YF, NYF, LDSTAK)')
      END
!NLSPK
      SUBROUTINE NLSPK(PAR, MASK, NPAR, PPAR, NPPAR)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PACKS A VECTOR PAR INTO A VECTOR PPAR, BY
!     OMITTING FROM THE PACKED VERSION THOSE ELEMENTS OF THE
!     UNPACKED VERSION CORRESPONDING TO ELEMENTS OF MASK WHICH
!     HAVE THE VALUE 1.  OTHER ELEMENTS OF MASK SHOULD BE ZERO.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   NPAR,NPPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PPAR(NPPAR)
      INTEGER
     +   MASK(NPAR)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPPAR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION PAR(NPAR)
!        INPUT PARAMETER.  THE UNPACKED VECTOR.
!     INTEGER I
!        LOOP PARAMETER.
!     INTEGER IPPAR
!        CURRENT ELEMENT OF PPAR.  RANGES FROM 0 (ON INITIALIZATION)
!        TO NPPAR.
!     INTEGER MASK(NPAR)
!        INPUT PARAMETER.  THE MASK GOVERNING THE PACKING OF PAR.
!        ELEMENTS OF MASK ARE 1 IF THE CORRESPONDING ELEMENT OF PAR
!        IS TO BE ELIMINATED IN PPAR, 0 IF IT IS TO BE INCLUDED.
!     INTEGER NPAR
!        INPUT PARAMETER.  THE LENGTH OF PAR.
!     INTEGER NPPAR
!        INPUT PARAMETER.  THE LENGTH OF PPAR.
!     DOUBLE PRECISION PPAR(NPPAR)
!        OUTPUT PARAMETER.  THE PACKED VERSION OF PAR.  SEE INITIAL
!        DESCRIPTION.
!
!     COMMENCE BODY OF ROUTINE
!
      IPPAR = 0
      DO 10 I=1,NPAR
         IF (MASK(I).NE.0) GO TO 10
         IPPAR = IPPAR + 1
         PPAR(IPPAR) = PAR(I)
   10 CONTINUE
      RETURN
      END
!ACFF
      SUBROUTINE ACFF (YFFT, N, LYFFT, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
!     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
!     USING AN FFT (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,LYFFT,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YFFT(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN,YSD
      INTEGER
     +   IAR,IFP,IPRT,LACOV,LAGMAX,LAIC,LDSMIN,NALL0,NFAC,NFFT,
     +   SDRHO,WORK
      LOGICAL
     +   DIFFER,ISFFT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),AIC(101),FTEST(2,100),PHI(100),PRHO(100),RHO(100),
     +   RSTAK(12)
      INTEGER
     +   IOD(1),ND(1),NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACFER,ACFMNF,ACFOUT,FFTLEN,IPRINT,LDSCMP,SETLAG,STKCLR,
     +   STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (ACOV(2),RHO(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(101)
!        THE AUTOCOVARIANCE VECTOR.
!     DOUBLE PRECISION AIC(101)
!       THE ARRAY CONTAINING AKAIKES CRITERIA FOR EACH ORDER.
!     DOUBLE PRECISION CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     LOGICAL DIFFER
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FTEST(2, 100)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0 ERRORS WERE DETECTED.
!     INTEGER IFP
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE FLOATING
!        POINT VARIABLES ARE SINGLE (IFP=3) OR DOUBLE (IFP=4) PRECISION.
!     INTEGER IOD(1)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     INTEGER ND(1)
!        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
!     INTEGER NDUM(1)
!        A DUMMY ARRAY.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     DOUBLE PRECISION OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED ORDER (IAR).
!     DOUBLE PRECISION PHI(100)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     DOUBLE PRECISION PRHO(100)
!        THE ARRAY CONTAINING THE PARITAL ACF ESTIMATES.
!     DOUBLE PRECISION RHO(100)
!        THE ARRAY CONTAINING THE ACF ESTIMATES.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SDRHO
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE STANDARD ERRORS OF THE ACF ESTIMATES.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR WORK.
!     DOUBLE PRECISION YFFT(LYFFT)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YSD
!        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'A',       'C',       'F',       'F',       ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      LACOV = 101
      LAIC = 101
      DIFFER = .FALSE.
      NFAC = 1
      ND(1) = 0
      IOD(1) = 0
      ISFFT = .TRUE.
!
      IF (N.GE.3) THEN
!
!     SET NUMBER OF ACF TO BE COMPUTED
!     AND LENGTH OF EXTENDED SERIES
!
         CALL SETLAG(N, LAGMAX)
         CALL FFTLEN(N+LAGMAX, 4, NFFT)
      END IF
!
      CALL LDSCMP(1, 0, 0, 0, 0, 0, 'D', NFFT, LDSMIN)
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL ACFER(NMSUB, N, LAGMAX, LACOV, LDSTAK, LDSMIN,
     +  DIFFER, NFAC, ND, IOD, ISFFT, LYFFT, NFFT)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      IF (IERR.EQ.0) THEN
!
!       SET UP THE WORK AREA.
!
        CALL STKSET (LDSTAK, 4)
        NALL0 = STKST(1)
!
        IFP = 4
!
        WORK = STKGET(NFFT, IFP)
        SDRHO = WORK
!
        IF (IERR.EQ.0) THEN
!
!         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
          CALL ACFMNF (YFFT, N, NFFT, LAGMAX, RHO, RSTAK(SDRHO), YMEAN,
     +       PRHO, AIC, FTEST, PHI, IAR, OSPVAR, ACOV, LACOV, LAIC,
     +       CHIA, CHIAP, LYFFT, RSTAK(WORK), NFFT, 1)
!
          YSD = SQRT (ACOV(1) * N / (N - 1))
!
!         CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
          CALL ACFOUT(YMEAN, YSD, N, N, LAGMAX, RHO, RSTAK(SDRHO), PRHO,
     +       NDUM, AIC, LAIC, FTEST, IAR, PHI, OSPVAR, CHIA, CHIAP,
     +       LAGMAX, .FALSE., 0.0D0, .FALSE., .FALSE., 0, NDUM, NDUM,
     +       0)
        END IF
!
        CALL STKCLR(NALL0)
      END IF
!
      IF (IERR.NE.0) THEN
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL ACFF (YFFT, N, LYFFT, LDSTAK)')
      END
!ERSII
      SUBROUTINE ERSII(NMSUB, NMVAR, VAL, VALMN, VALMX, MSGTYP, HEAD,
     +   ERROR, NMMIN, NMMAX)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THE ROUTINE CHECKS WHETHER THE VALUE   VAL   IS WITHIN THE
!     THE RANGE VALMN (INCLUSIVE) TO VALMX (INCLUSIVE), AND PRINTS A
!     DIAGNOSTIC IF IT IS NOT.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VAL,VALMN,VALMX
      INTEGER
     +   MSGTYP
      LOGICAL
     +   ERROR,HEAD
!
!  ARRAY ARGUMENTS
      CHARACTER
     +   NMMAX(8)*1,NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
!        PRINTED, WHERE IF ERROR IS .TRUE. AND
!        MSGTYP = 1 THE INPUT VALUE WAS OUTSIDE THE RANGE DETERMINED
!                   FROM OTHER INPUT ARGUMENTS
!        MSGTYP = 2 THE INPUT VALUE WAS OUTSIDE THE RANGE IMPOSED BY
!                   STARPAC
!     CHARACTER*1 NMMAX(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MAXIMUM.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE ARGUMENTS NAME.
!     DOUBLE PRECISION VAL
!        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
!     DOUBLE PRECISION VALMN, VALMX
!        THE MINIMUM AND MAXIMUM OF THE RANGE WITHIN WHICH THE
!        ARGUMENT MUST LIE.
!
      ERROR = .FALSE.
!
      IF (((VALMN.LE.VAL) .AND. (VAL.LE.VALMX)) .OR.
     +   (VALMX.LT.VALMN)) RETURN
!
      ERROR = .TRUE.
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
!
      WRITE (IPRT, 1000) (NMVAR(I),I=1,6), VAL
!
!     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE DETERMINED FROM
!     OTHER INPUT ARGUMENTS.
!
      IF (MSGTYP .EQ. 1)
     +   WRITE (IPRT, 1010) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8),
     +      (NMMAX(I),I=1,8)
!
!     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE IMPOSED BY STARPAC
!
      IF (MSGTYP .EQ. 2)
     +   WRITE (IPRT, 1020) (NMVAR(I),I=1,6), VALMN, VALMX
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/20H THE INPUT VALUE OF , 6A1, 4H IS , G15.8, '.')
 1010 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   16H MUST BE BETWEEN, 1X, 8A1,
     +   5H AND , 8A1, 12H, INCLUSIVE.)
 1020 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   16H MUST BE BETWEEN, 1X, G15.8,
     +   5H AND , G15.8, 12H, INCLUSIVE.)
!
      END
!STAT1
      SUBROUTINE STAT1(Y, N, YMED, YMIN, YMAX, YMIDRG, YRANGE, NCELLS,
     +   YLB, YUB, YDISTR)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS COMPUTES STATISTICS FOR A VECTOR Y THAT REQUIRE OR CAN
!     MAKE USE OF SORTEDNESS IN THE Y VECTOR.
!
!     THIS SUBROUTINE IS BASED ON A MODIFICATION OF THE STATIS
!     CODE USED IN OMNITAB, VERSION 5 (6/16/72), WRITTED BY
!     SALLY PEAVY.  THE ORIGINAL ADAPTATION TO STARPAC WAS MADE
!     BY JANET DONALDSON.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YLB,YMAX,YMED,YMIDRG,YMIN,YRANGE,YUB
      INTEGER
     +   N,NCELLS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(N),YDISTR(NCELLS)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELY,YT
      INTEGER
     +   I,IC,IC1,L,M,M1
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MOD
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELY
!        THE WIDTH OF AN INTERVAL ONE TENTH THE RANGE OF THE
!        DATA IN Y.
!     INTEGER I
!        A LOOP INDEX.
!     INTEGER IC
!        PREVIOUS SIGN IN RUNS CALCULATION.
!     INTEGER IC1
!        COUNT IN FREQUENCY DISTRIBUTION CALCULATIONS.
!     INTEGER L
!        A LOOP INDEX.
!     INTEGER M
!        A LOOP INDEX.
!     INTEGER M1
!        WHEN N IS EVEN, M1 IS M + 1, OTHERWISE IT IS M.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y AND WT.
!     INTEGER NCELLS
!        THE NUMBER OF CELLS IN THE FREQUENCY DISTRIBUTION.
!     DOUBLE PRECISION Y(N)
!        INPUT PARAMETER.  A SET OF N DATA POINTS, SORTED
!        INTO ASCENDING ORDER.
!     DOUBLE PRECISION YDISTR(NCELLS)
!        OUTPUT PARAMETER.  THE NUMBERS OF Y VALUES WITH
!        POSITIVE WEIGHTS IN EACH OF NCELLS EQUAL LENGTH INTERVALS
!        THAT DIVIDE THE RANGE OF Y VALUES.
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE FREQUENCY DISTRIBUTION.
!        IF YLB = YUB, THE MINIMUM OBSERVATION WILL BE USED.
!     DOUBLE PRECISION YMAX
!        OUTPUT PARAMETER.  THE MAXIMUM OF THE OBSERVATIONS Y HAVING
!        POSITIVE WEIGHT.
!     DOUBLE PRECISION YMED
!        OUTPUT PARAMETER.  THE MEDIAN OF THE OBSERVATIONS Y.
!     DOUBLE PRECISION YMIDRG
!        OUTPUT PARAMETER.  THE MIDRANGE OF THE OBSERVATIONS Y.
!     DOUBLE PRECISION YMIN
!        OUTPUT PARAMETER.  THE MINIMUM OF THE OBSERVATIONS Y HAVING
!        POSITIVE WEIGHT.
!     DOUBLE PRECISION YRANGE
!        THE RANGE OF THE OBSERVATIONS Y.
!     DOUBLE PRECISION YT
!        THE MAXIMUM VALUE IN EACH INTERVAL IN THE FREQUENCY
!        DISTRIBUTIONS CALCULATIONS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE FREQUENCY DISTRIBUTION.
!        IF YLB = YUB, THE MAXIMUM OBSERVATION WILL BE USED.
!
!     CALCULATE THE MEDIAN, MIDRANGE, RANGE, AND EXTREMA.
!
      M = (N+1)/2
      M1 = M
      IF (MOD(N,2).EQ.0) M1 = M1 + 1
      YMED = (Y(M)+Y(M1))/2.0D0
      YMIDRG = (Y(1)+Y(N))/2.0D0
      YRANGE = Y(N) - Y(1)
      YMIN = Y(1)
      YMAX = Y(N)
!
!     COMPUTE FREQUENCY DISTRIBUTION.
!
      IF (NCELLS.LE.0) RETURN
      IC1 = 0
      IF (NCELLS.EQ.1) GO TO 40
!
      DELY = YRANGE
      YT = YMIN
      IF (YLB.GE.YUB) GO TO 5
         DELY = YUB - YLB
         YT = YLB
    5 CONTINUE
      DELY = DELY / NCELLS
      YT = YT + DELY
      L = 0
      DO 30 I=2,NCELLS
         IC = 0
   10    L = L + 1
         IF (L.GT.N) GO TO 20
         IF (Y(L).GT.YT) GO TO 20
         IC = IC + 1
         IC1 = IC1 + 1
         GO TO 10
   20    YDISTR(I-1) = IC
         L = L - 1
         YT = YT + DELY
   30 CONTINUE
   40 YDISTR(NCELLS) = N - IC1
      RETURN
      END
!MDLTS1
      SUBROUTINE MDLTS1 (PAR, NPAR, XM, N, M, IXM, RESTS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR ESTIMATING BOX-JENKINS
!     ARIMA MODELS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 4, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),RESTS(NRESTS),XM(IXM,M)
!
!  SCALARS IN COMMON
      INTEGER
     +   IFLAG,MBO,MBOL,MSPECT,NFACT,NPARAR,NPARDF,NPARMA,NRESTS,
     +   PARAR,PARDF,PARMA,T,TEMP
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   PMU
      INTEGER
     +   I,I1
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL MDLTS2
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /MDLTSC/MSPECT,NFACT,PARDF,NPARDF,PARAR,NPARAR,PARMA,
     +   NPARMA,MBO,MBOL,T,TEMP,NRESTS,IFLAG
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IFLAG
!        AN INDICATOR VARIABLE DESIGNATING WHETHER THE BACK FORECASTS
!        WERE ESSENTIALLY ZERO (IFLAG=0) OR NOT (IFLAG=1).
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IXM
!        THE FIRST DIMENSION OF MATRIX XM.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBOL
!        THE MAXIMUM BACK ORDER ON THE LEFT
!     INTEGER MSPECT
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFACT
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARAR
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE AUTOREGRESSIVE PARAMETERS
!     INTEGER PARDF
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
!     INTEGER PARMA
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE MOVING AVERAGE PARAMETERS
!     DOUBLE PRECISION PMU
!        THE VALUE OF MU, I.E., THE TREND OR MEAN.
!     DOUBLE PRECISION RESTS(NRESTS)
!        THE RESIDUALS FROM THE ARIMA MODEL.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER T
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR.
!     INTEGER TEMP
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR
!     DOUBLE PRECISION XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!
!
!     COMPUTE RESIDUALS
!
      CALL MDLTS2 (PAR, RESTS, XM(1,1), NPAR, N, NFACT, ISTAK(MSPECT),
     +  PMU, RSTAK(PARDF), NPARDF, RSTAK(T), RSTAK(TEMP), RSTAK(PARAR),
     +  RSTAK(PARMA), MBO, N-NRESTS+1, N, IFLAG)
!
!     COMPUTE PREDICTED VALUES
!
      I1=NRESTS-N
      DO 20 I = 1,N
        I1=I1+1
        RESTS(I) = XM(I1,1)-RESTS(I1)
   20 CONTINUE
!
      RETURN
      END
!ACFD
      SUBROUTINE ACFD (Y, N, LAGMAX, NFAC, ND, IOD, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
!     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
!     WITH DIFFERENCING.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LAGMAX,LDSTAK,N,NFAC
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
      INTEGER
     +   IOD(*),ND(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN,YSD
      INTEGER
     +   ACOV,AIC,FTEST,I,IAR,IFP,IPRT,LACOV,LDSMIN,LYFFT,NALL0,
     +   NFFT,NTIMES,NYD,NYF,PHI,PRHO,SDRHO,WORK,YF
      LOGICAL
     +   DIFFER,ISFFT,NEWPG
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACFER,ACFMN,ACFOUT,DIFSER,IPRINT,LDSCMP,DCOPY,STKCLR,
     +   STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN,SQRT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER ACOV
!        THE STARTING LOCATION IN DSTAK FOR
!        THE AUTOCOVARIANCE VECTOR.
!     INTEGER AIC
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE AKAIKES CRITERION FOR EACH ORDER.
!     DOUBLE PRECISION CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     LOGICAL DIFFER
!        THE VARIABLE USED TO DESIGNATE WHETHER OR NOT THE SERIES
!        BEING ANALYZED WAS DIFFERENCED OR NOT.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER FTEST
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE PARTIAL F RATIO AND PROBABILITIES
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!     INTEGER IFP
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE FLOATING
!        POINT VARIABLES ARE SINGLE (IFP=3) OR DOUBLE (IFP=4) PRECISION.
!     INTEGER IOD(NFAC)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        A DUMMY VARIABLE
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     INTEGER ND(NFAC)
!        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE
!        FACTORS ARE TO BE APPLIED.
!     INTEGER NDUM(1)
!        A DUMMY DIMENSIONED VARIABLE.
!     LOGICAL NEWPG
!        THE VARIABLE USED TO DESIGNATE WHETHER OR NOT THE OUTPUT
!        IS TO BEGIN ON A NEW PAGE.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NTIMES
!        THE NUMBER OF TIMES THE FIRST DIFFERENCE FACTOR HAS BEEN
!        APPLIED.
!     INTEGER NYD, NYF
!        THE NUMBER OF OBSERVATIONS AFTER THE DIFFERENCE FILTER IS
!        APPLIED.
!     DOUBLE PRECISION OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
!     INTEGER PHI
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     INTEGER PRHO
!        THE STARTING LOCATION IN THE WORK AREA FOR PRHO.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SDRHO
!        THE STARTING LOCATION IN THE WORK AREA FOR SDRHO.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR WORK.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     INTEGER YF
!        THE STARTING LOCATION IN DSTAK FOR
!        THE VECTOR CONTAINING THE DIFFERENCE FILTERED SERIES.
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YSD
!        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'A',       'C',       'F',       'D',       ' ',       ' '/
!
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      LACOV = LAGMAX+1
      DIFFER = .TRUE.
      ISFFT = .FALSE.
      LYFFT = 0
      NFFT = 0
!
      CALL LDSCMP(7, 0, 0, 0, 0, 0, 'D', 7*LAGMAX+2+N, LDSMIN)
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL ACFER(NMSUB, N, LAGMAX, LACOV, LDSTAK, LDSMIN,
     +  DIFFER, NFAC, ND, IOD, ISFFT, LYFFT, NFFT)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      IF (IERR.EQ.0) THEN
!
!       SET UP THE WORK AREA.
!
        CALL STKSET(LDSTAK, 4)
        NALL0 = STKST(1)
!
        IFP = 4
!
        ACOV = STKGET(LAGMAX+1, IFP)
        PRHO = STKGET(LAGMAX, IFP)
        AIC = STKGET(LAGMAX+1, IFP)
        FTEST = STKGET(2*LAGMAX, IFP)
        PHI = STKGET(LAGMAX, IFP)
        WORK = STKGET(LAGMAX, IFP)
        YF = STKGET(N, IFP)
        SDRHO = WORK
!
        IF (IERR.EQ.0) THEN
!
          NEWPG = .FALSE.
          NTIMES = 0
!
!         CHECK WHETHER THERE IS MORE THAN ONE DIFFERENCE FACTOR.
!
          IF (NFAC.LE.1) THEN
            CALL DCOPY(N, Y, 1, RSTAK(YF), 1)
          ELSE
!
!           CREATE NEW DATA BY APPLYING DIFFERENCE FACTORS BEYOND THE
!           FIRST.
!
            CALL DIFSER(Y, N, NFAC-1, ND(2), IOD(2), RSTAK(YF), NYF)
          END IF
          NYD = N
!
!         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
          CALL ACFMN (RSTAK(YF), NYD, MIN(LAGMAX, NYD-1),
     +       RSTAK(ACOV+1), RSTAK(SDRHO), YMEAN, RSTAK(PRHO),
     +       RSTAK(AIC), RSTAK(FTEST), RSTAK(PHI), IAR, OSPVAR,
     +       RSTAK(ACOV), LAGMAX+1, LAGMAX+1, CHIA, CHIAP, RSTAK(WORK),
     +       1)
!
          YSD = SQRT(RSTAK(ACOV) * N / (N-1))
!
!         CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
          CALL ACFOUT (YMEAN, YSD, NYF, NYF, MIN(LAGMAX, NYD-1),
     +       RSTAK(ACOV+1), RSTAK(SDRHO), RSTAK(PRHO), NDUM, RSTAK(AIC),
     +       LAGMAX+1, RSTAK(FTEST), IAR, RSTAK(PHI), OSPVAR, CHIA,
     +       CHIAP, LAGMAX, .FALSE., 0.0D0, DIFFER, NEWPG, NFAC, ND,
     +       IOD, NTIMES)
!
          NEWPG = .TRUE.
!
!         COMPUTE CORRELATION ANALYSIS FOR FIRST DIFFERENCE FACTOR
!         APPLIED 1 TO ND(1) TIMES
!
          IF ((NFAC.GE.1) .AND. (ND(1).GE.1)) THEN
            DO 50 I = 1, ND(1)
!
               CALL DIFSER(RSTAK(YF), NYD, NFAC-1, ND(2), IOD(2),
     +           RSTAK(YF), NYF)
!
!              CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
             CALL ACFMN (RSTAK(YF), NYD, MIN(LAGMAX, NYD-1),
     +          RSTAK(ACOV+1), RSTAK(SDRHO), YMEAN, RSTAK(PRHO),
     +          RSTAK(AIC), RSTAK(FTEST), RSTAK(PHI), IAR, OSPVAR,
     +          RSTAK(ACOV), LAGMAX+1, LAGMAX+1, CHIA, CHIAP,
     +          RSTAK(WORK), 1)
!
               YSD = SQRT(RSTAK(ACOV) * N / (N-1))
!
!           CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
             CALL ACFOUT (YMEAN, YSD, NYF, NYF, MIN(LAGMAX, NYD-1),
     +          RSTAK(ACOV+1), RSTAK(SDRHO), RSTAK(PRHO), NDUM,
     +          RSTAK(AIC), LAGMAX+1, RSTAK(FTEST), IAR, RSTAK(PHI),
     +          OSPVAR, CHIA, CHIAP, LAGMAX, .FALSE., 0.0D0, DIFFER,
     +          NEWPG, NFAC, ND, IOD, I)
!
   50       CONTINUE
          END IF
        END IF
!
        CALL STKCLR(NALL0)
      END IF
!
      IF (IERR.NE.0) THEN
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL ACFD (Y, N, LAGMAX, NFAC, ND, IOD, LDSTAK)')
      END
!DCKCNT
      SUBROUTINE DCKCNT(XM, N, M, IXM, MDL, DRV, PAR, NPAR, NETA, NTAU,
     +   SCALE, LSCALE, NROW, NPRT, HDR, PAGE, WIDE, ISUBHD, HLFRPT,
     +   PRTFXD, IFIXED, LIFIXD)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CONTROLS THE DERIVATIVE CHECKING PROCESS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ISUBHD,IXM,LIFIXD,LSCALE,M,N,NETA,NPAR,NPRT,NROW,NTAU
      LOGICAL
     +   HLFRPT,PAGE,PRTFXD,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),SCALE(LSCALE),XM(IXM,M)
      INTEGER
     +   IFIXED(LIFIXD)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,HDR,MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   D,ETA,FPLRS,PV,SCL,TAU
      INTEGER
     +   DTEMP,IFIXD,IFP,INDXD,INDXPV,J,LMSG,MSG,NALL0,NDD,NDGT1,
     +   NDGT2,NROWU,PARTMP,PVTEMP
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      INTEGER
     +   STKGET,STKST
      EXTERNAL D1MACH,STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CPYVII,DCKMN,DCKOUT,ETAMDL,SETIV,SETROW,STKCLR
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG10
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION D
!        THE SCALAR IN WHICH ROW   NROWU   OF THE DERIVATIVE
!        MATRIX WITH RESPECT TO THE JTH UNKNOWN PARAMETER
!        IS STORED.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER DTEMP
!        THE STARTING LOCATION IN THE WORK AREA IN WHICH
!        THE ARRAY IN WHICH THE ANALYTIC DERIVATIVES WITH
!        RESPECT TO EACH UNKNOWN PARAMETER ARE STORED.
!     DOUBLE PRECISION ETA
!        THE RELATIVE NOISE IN THE MODEL.
!     DOUBLE PRECISION FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     EXTERNAL HDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFIXD
!        THE STARTING LOCATION IN ISTAK OF
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INDXD, INDXPV
!        THE INDEX IN THE WORK AREA OF
!        THE LOCATION OF THE VALUE OF THE
!        DERIVATIVE WITH RESPECT TO THE JTH PARAMETER AT ROW   NROWU
!        AND OF THE LOCATION OF THE PREDICTED VALUE FROM THE MODEL FOR R
!        ROW   NROWU   .
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED BY
!        ROUTINE HDR.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER LIFIXD
!        THE LENGTH OF THE VECTOR IFIXED.
!     INTEGER LMSG
!        THE LENGTH OF THE VECTOR MSG.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER MSG
!        THE STARTING LOCATION IN THE WORK AREA OF
!        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
!     INTEGER NDD
!        THE NUMBER OF DECIMAL DIGITS CARRIED FOR A SINGLE
!        PRECISION DOUBLE PRECISION NUMBER.
!     INTEGER NDGT1
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL USED, EITHER
!        SET TO THE USER SUPPLIED VALUE OF NETA, OR COMPUTED
!        BY ETAMDL.
!     INTEGER NDGT2
!        THE ACTUAL NUMBER OF DIGITS OF AGREEMENT USED, EITHER
!        SET TO THE USER SUPPLIED VALUE OF NTAU, OR COMPUTED
!        FROM NDGT1.
!     INTEGER NETA
!        THE USER SUPPLIED NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NROW, NROWU
!        THE USER-SUPPLIED NUMBER OF THE ROW OF THE INDEPENDENT
!        VARIABLE ARRAY AT WHICH THE DERIVATIVE IS TO BE CHECKED,
!        AND THE NUMBER OF THE ROW ACTUALLY USED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     INTEGER PARTMP
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE MODIFIED MODEL PARAMETERS
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PV
!        THE SCALAR IN WHICH THE PREDICTED VALUE FROM THE MODEL FOR
!        ROW   NROW   IS STORED.
!     INTEGER PVTEMP
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     DOUBLE PRECISION SCL
!        THE ACTUAL TYPICAL SIZE USED.
!     DOUBLE PRECISION TAU
!        THE AGREEMENT TOLERANCE.
!     LOGICAL WIDE
!       THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      NALL0 = STKST(1)
!
      FPLRS = D1MACH(4)
!
!     SELECT FIRST ROW OF INDEPENDENT VARIABLES WHICH CONTAINS NO ZEROS
!
      CALL SETROW(NROW, XM, N, M, IXM, NROWU)
!
!     SUBDIVIDE WORK AREA
!
      IFP = 4
!
      LMSG = NPAR + 1
!
      IFIXD = STKGET(NPAR,2)
      MSG = STKGET(LMSG,2)
      DTEMP = STKGET(N*NPAR,IFP)
      PARTMP = STKGET(NPAR,IFP)
      PVTEMP = STKGET(N,IFP)
!
      IF (IERR.EQ.1) RETURN
!
!     SET UP IFIXD
!
      IF (IFIXED(1).LT.0) CALL SETIV(ISTAK(IFIXD), NPAR, 0)
      IF (IFIXED(1).GE.0) CALL CPYVII(NPAR, IFIXED, 1, ISTAK(IFIXD), 1)
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      NDD = -LOG10(FPLRS)
!
      IF ((NETA.LT.2) .OR. (NETA.GT.NDD)) THEN
         CALL ETAMDL(MDL, PAR, NPAR, XM, N, M, IXM, ETA, NDGT1,
     +      RSTAK(PARTMP), RSTAK(PVTEMP), NROWU)
      ELSE
         ETA = 10.0D0**(-NETA)
         NDGT1 = NETA
      END IF
!
      IF ((NTAU.LT.1) .OR. (NTAU.GT.(NDGT1-1)/2)) THEN
         NDGT2 = (NDGT1+3)/4
      ELSE
         NDGT2 = NTAU
      END IF
!
      TAU = 10.0D0**(-NDGT2)
!
      INDXPV = PVTEMP + NROWU - 1
!
!     COMPUTE PREDICTED VALUE OF MODEL USING CURRENT PARAMETER
!     ESTIMATES, AND COMPUTE USER-SUPPLIED DERIVATIVE VALUES
!
      CALL MDL(PAR, NPAR, XM, N, M, IXM, RSTAK(PVTEMP))
      PV = RSTAK(INDXPV)
      CALL DRV(PAR, NPAR, XM, N, M, IXM, RSTAK(DTEMP))
!
      ISTAK(MSG) = 0
!
      DO 30 J=1,NPAR
!
         IF (SCALE(1).GT.0.0D0) THEN
            SCL = SCALE(J)
         ELSE
            SCL = PAR(J)
         END IF
         IF (SCL.EQ.0.0D0) SCL = 1.0D0
!
!     CALL ROUTINE TO CHECK USER SUPPLIED NUMERICAL DERIVATIVES
!     WITH RESPECT TO THE JTH PARAMETER.
!
         INDXD = DTEMP - 1 + N*(J-1) + NROWU
!
         D = RSTAK(INDXD)
         CALL DCKMN(J, D, PAR, SCL, NPAR, ETA, TAU, MDL, XM, N, NROWU,
     +      M, IXM, PV, RSTAK(PVTEMP), ISTAK(MSG), LMSG)
!
   30 CONTINUE
!
      IF (ISTAK(MSG).GE.1) IERR = ISTAK(MSG) + 1
!
!     PRINT RESULTS IF THEY ARE DESIRED
!
      HLFRPT = .FALSE.
!
      IF ((NPRT.NE.0) .OR. (IERR.NE.0)) THEN
         HLFRPT = .TRUE.
         CALL DCKOUT(XM,IXM,N,M,NROWU,NDGT1,NDGT2,NPAR,ISTAK(MSG),
     +      LMSG,PAR,SCALE,LSCALE,HDR,PAGE,WIDE,ISUBHD,PRTFXD,
     +      ISTAK(IFIXD))
      END IF
!
      CALL STKCLR(NALL0)
!
      RETURN
!
      END
!AOV1S
      SUBROUTINE AOV1S(Y, TAG, N, LDSTAK, NPRT, GSTAT, IGSTAT, NG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE -
!     1. CALLS OTHER ROUTINES TO CHECK THE INPUT PARAMETERS
!     2. SETS UP NEEDED STORAGE LOCATIONS AND
!     3. CALLS AOV1MN TO COMPUTE A COMPREHENSIVE SET OF RESULTS FOR A
!         ONEWAY ANALYSIS OF VARIANCE WITH OPTIONAL OUTPUT.
!
!     WRITTEN BY -
!       LINDA MITCHELL
!       STATISTICAL ENGINEERING DIVISION
!       NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!                       BASED ON EARLIER VERSION BY J. R. DONALDSON
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IGSTAT,LDSTAK,N,NG,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   GSTAT(*),TAG(*),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   B10,GPMAX,GPMIN,IFP,INDEX,INT,IPRT,ITEMP,NALL0,NZTAGS,
     +   RANKS,SRANK
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET
      EXTERNAL STKGET
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AOV1ER,AOV1HD,AOV1MN,IPRINT,STKCLR
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER B10
!        STARTING LOCATION IN THE STACK AREA FOR B10
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER GPMAX
!        THE STARTING LOCATION IN THE STACK AREA OF MAXIMUM
!        OBSERVATION
!     INTEGER GPMIN
!        THE STARTING LOCATION IN THE STACK AREA OF THE MINUMUM
!        OBSERVATION
!     DOUBLE PRECISION GSTAT(IGSTAT,4)
!        THE GROUP STATISTICS.  COLUMNS CORRESPOND TO THE TAG
!        VALUE, SAMPLE SIZE, GROUP MEAN, AND GROUP STANDARD DEVIATION.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG INDICATING WHETHER THERE
!        ARE ANY ERRORS, IF = 0 THEN NO ERRORS
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IGSTAT
!        THE FIRST DIMENSION OF GSTAT.
!     INTEGER INDEX
!        THE STARTING LOCATION IN THE STACK ARRAY OF THE INDEX FOR
!        THE SORTED TAGS
!     INTEGER INT
!        FRAMEWORK CODE VALUE FOR INTEGER NUMBERS
!     INTEGER IPRT
!        THE OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ITEMP
!        STARTING LOCATION IN THE STACK FOR THE
!        TEMPORARY STORAGE ARRAY
!     INTEGER LDSTAK
!         SIZE OF THE STACK AREA ALLOCATED IN THE USERS MAIN PROGRAM
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS TO BE ANALYZED
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT THIS
!        ROUTINE WAS CALLED.
!     INTEGER NG
!        THE COMPUTED NUMBER OF GROUPS WITH
!        DIFFERENT POSITIVE TAG VALUES
!     CHARACTER*1 NMSUB(6)
!        SUBROUTINE NAME
!     INTEGER NPRT
!        THE VARIABLE CONTROLLING AUTOMATIC PRINTOUT
!        IF =0, PRINTOUT IS SUPRESSED
!        OTHERWISE PRINTOUT IS PROVIDED
!     INTEGER NZTAGS
!        THE NUMBER OF OBSERVATIONS WITH POSITIVE NON-ZERO WIEGHTS
!     INTEGER RANKS
!        THE STARTING LOCATION IN STACK AREA FOR THE RANKS OF Y
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SRANK
!        THE STARTING LOCATION IN STACK FOR THE SUM OF RANKS
!     DOUBLE PRECISION TAG(N)
!        THE VECTOR OF TAG VALUES
!     DOUBLE PRECISION Y(N)
!        THE VECTOR OF OBSERVATIONS
!
      DATA   NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +     /      'A',      'O',      'V',      '1',      'S',      ' '/
!
!     SET UP FRAMEWORK VARIABLES FOR NUMBER TYPES
!
      INT = 2
      IFP = 4
!
      CALL IPRINT(IPRT)
!
!     CHECK FOR ERRORS IN PARAMETERS, INITIALIZE STACK, AND SET
!     NALL0.
!
      CALL AOV1ER(Y, TAG, N, IGSTAT, NZTAGS, NG, LDSTAK, NMSUB, INDEX,
     +   0, NALL0)
!
      IF (IERR.EQ.0) GO TO 20
!
!     PRINT CORRECT FORM OF CALL STATEMENT AND RETURN TO CALLER
!
      IERR = 1
      WRITE (IPRT,1000)
      RETURN
!
!     PRINT HEADING IF DESIRED
!
   20 IF (NPRT.EQ.0) GO TO 30
      CALL AOV1HD(IPRT)
!
!     SET UP ADDITIONAL WORK VECTORS FOR AOV1MN AS CALLED FROM AOV1S
!
   30 SRANK = STKGET(NG,IFP)
      GPMIN = STKGET(NG,IFP)
      GPMAX = STKGET(NG,IFP)
      B10 = STKGET(NG,IFP)
      RANKS = STKGET(NZTAGS,IFP)
      ITEMP = STKGET(NZTAGS,INT)
!
      CALL AOV1MN(Y, TAG, N,
     +            GSTAT(1), GSTAT(IGSTAT+1),
     +            GSTAT(2*IGSTAT+1), GSTAT(3*IGSTAT+1),
     +            NPRT, ISTAK(INDEX), RSTAK(SRANK), RSTAK(GPMIN),
     +            RSTAK(GPMAX), RSTAK(B10), RSTAK(RANKS),
     +            ISTAK(ITEMP), NG, NZTAGS)
!
!     RELEASE THE STACK AREA
!
      CALL STKCLR(NALL0)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL AOV1S (Y, TAG, N, LDSTAK, NPRT, GSTAT, IGSTAT, NG)')
      END
!CCFF
      SUBROUTINE CCFF (YFFT1, YFFT2, N, LYFFT, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
!     CORRELATIONS OF TWO TIME SERIES USING THE SINGLETON FFT
!     (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,LYFFT,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YFFT1(*),YFFT2(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   Y1MEAN,Y1SD,Y2MEAN,Y2SD
      INTEGER
     +   ICCOV,IFP,INLPPC,IPRT,IYM,IYMFFT,JCCOV,JNLPPC,LAGMAX,
     +   LDSMIN,M,NALL0,NFFT,WORK
      LOGICAL
     +   ISFFT,ISLONG
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCOV(101,2,2),RHOC(201),RSTAK(12),SDRHOC(201),STAK(12)
      INTEGER
     +   NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACVFF,CCFER,CCFMNF,CCFOUT,FFTLEN,IPRINT,LDSCMP,SETLAG,
     +   STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),STAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCOV(101, 2, 2)
!        THE CCVF MATRIX.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ICCOV
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INLPPC
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
!        IN THE USERS PROGRAM.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     LOGICAL ISLONG
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
!     INTEGER IYMFFT
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JCCOV
!        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
!        IN THE USERS PROGRAM.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE NUMBER OF LOCATIONS IN THE ARRAY YFFT1 AND YFFT2.
!     INTEGER M
!        THE NUMBER OF SERIES BEING COMPARED, IE THE
!        NUMBER OF COLUMNS OF DATA IN YM.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     INTEGER NDUM(1)
!        A DUMMY ARRAY.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     DOUBLE PRECISION RHOC(201)
!        THE ARRAY CONTAINING THE CCF.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION SDRHOC(201)
!        THE ARRAY CONTAINING THE SD OF THE CCF.
!     DOUBLE PRECISION STAK(12)
!        THE USED VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER WORK
!        THE STARTING LOCATION IN DSTAK FOR
!        THE WORK ARRAY NEEDED BY THE FFT.
!     DOUBLE PRECISION YFFT1(N), Y1MEAN, Y1SD
!        THE FIRST SERIES, AND ITS MEAN AND STANDARD DEVIATION.
!     DOUBLE PRECISION YFFT2(N), Y2MEAN, Y2SD
!        THE SECOND SERIES, AND ITS MEAN AND STANDARD DEVIATION.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'C',       'C',       'F',       'F',       ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      ICCOV = 101
      INLPPC = 1
      IYM = N
      JCCOV = 2
      JNLPPC = 1
      LAGMAX = 1
      IYMFFT = LYFFT
      M = 2
      NFFT = N
      ISFFT = .TRUE.
      ISLONG = .FALSE.
!
      IF (N.GE.3) THEN
!
!     SET LARGEST LAG VALUE TO BE USED
!
        CALL SETLAG(N, LAGMAX)
!
!     SET LENGTH OF THE EXTENDED SERIES
!
        CALL FFTLEN(N+LAGMAX, 4, NFFT)
      END IF
!
      CALL LDSCMP(1, 0, 0, 0, 0, 0, 'D', NFFT, LDSMIN)
!
      CALL CCFER(NMSUB, N, LAGMAX, LDSTAK, LDSMIN, ICCOV, JCCOV,
     +  INLPPC, JNLPPC, M, LYFFT, NFFT, IYM, IYMFFT, ISFFT, ISLONG)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      IF (IERR.EQ.0) THEN
!
!       SET UP THE WORK AREA.
!
        CALL STKSET (LDSTAK, 4)
        NALL0 = STKST(1)
!
        IFP = 4
!
        WORK = STKGET(NFFT, IFP)
!
        IF (IERR.EQ.0) THEN
!
!         COMPUTE THE SERIES ACVF AND SD
!
          CALL ACVFF (YFFT1, N, NFFT, Y1MEAN, CCOV(1,1,1), LAGMAX, 101,
     +       LYFFT, STAK(WORK), NFFT)
          Y1SD = SQRT(CCOV(1,1,1) * N / (N-1))
!
          CALL ACVFF (YFFT2, N, NFFT, Y2MEAN, CCOV(1,2,2), LAGMAX, 101,
     +       LYFFT, STAK(WORK), NFFT)
          Y2SD = SQRT(CCOV(1,2,2) * N / (N-1))
!
!         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
          IF (CCOV(1,1,1)*CCOV(1,2,2) .NE. 0.0D0)
     +       CALL CCFMNF (YFFT1, YFFT2, N, NFFT, LAGMAX, 2*LAGMAX+1,
     +       CCOV(1,1,1), CCOV(1,2,2), CCOV(1,1,2), CCOV(1,2,1), 101,
     +       RHOC, SDRHOC, 1, LYFFT, STAK(WORK), NFFT)
!
!         CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
          CALL CCFOUT (1, Y1MEAN, Y1SD, N, N, 2, Y2MEAN, Y2SD, N,
     +       N, LAGMAX, 2*LAGMAX+1, RHOC, SDRHOC, .FALSE., NDUM, NDUM,
     +       1, 0.0D0, 0.0D0, .FALSE.)
        END IF
!
        CALL STKCLR(NALL0)
      END IF
!
      IF (IERR.NE.0) THEN
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL CCFF (YFFT1, YFFT2, N, LYFFT, LDSTAK)')
      END
!PGORD
      SUBROUTINE PGORD (PER, NPTS, YAXIS, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES CO-ORDINATES FOR THE PERIODOGRAM PLOT.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   NPRT,NPTS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PER(NPTS),YAXIS(NPTS)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  INTRINSIC FUNCTIONS
      INTRINSIC IABS,LOG10
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .EQ.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
!        IF NPRT .GE.  2, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!     INTEGER NPTS
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
!        ARE ESTIMATED.
!     DOUBLE PRECISION PER(NPTS)
!        THE ARRAY CONTAINING THE PERIODOGRAM VALUES.
!     DOUBLE PRECISION YAXIS(NPTS)
!        THE Y CO-ORDINATES FOR THE PERIODOGRAM PLOTS.
!
      FPLM = D1MACH(2)
!
!     THE FIRST VALUE SHOULD BE ZERO, SO NO ATTEMPT IS MADE TO PLOT IT.
!
      YAXIS(1) = FPLM
!
      DO 10 I = 2, NPTS
         YAXIS(I) = FPLM
         IF (PER(I) .LE. 0.0D0) GO TO 10
            YAXIS(I) = PER(I)
            IF (IABS(NPRT) .EQ. 1) YAXIS(I) = 10.0D0*LOG10(YAXIS(I))
   10 CONTINUE
!
      RETURN
!
      END
!PGOUT
      SUBROUTINE PGOUT (YAXIS, XAXIS, NPTS, NPRT, NMSUB)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES THE PERIODOGRAM PLOTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   NPRT,NPTS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   XAXIS(NPTS),YAXIS(NPTS)
      CHARACTER
     +   NMSUB(6)*1
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM,XMISS,XMN,XMX,YMN,YMX
      INTEGER
     +   ILOG,IPRT
      LOGICAL
     +   ERROR
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMISS(1)
      INTEGER
     +   ISYM(1)
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPLMT,PPMN,VERSP,VPLMT,VPMN
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,IABS
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!       AN ERROR FLAG
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER ILOG
!        ...
!     INTEGER IPRT
!        THE LOGICAL UNIT NUMBER FOR THE OUTPUT.
!     INTEGER ISYM(1)
!        A DUMMY ARRAY FOR THE PAGE PLOTS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     DOUBLE PRECISION XAXIS(NPTS)
!        THE X CO-ORDINATES FOR THE PAGE PLOTS.
!     DOUBLE PRECISION XMISS
!        THE VALUE USED TO SPECIFY IF THE PERIODOGRAM VALUE WAS
!        LESS THAN OR EQUAL TO ZERO.
!     DOUBLE PRECISION XMN, XMX
!        ...
!     DOUBLE PRECISION YAXIS(NPTS)
!        THE Y CO-ORDINATES FOR THE SPECTRAL PLOTS.
!     DOUBLE PRECISION YMISS(1)
!        THE VALUE USED TO SPECIFY IF AN PERIODOGRAM VALUE WAS
!        LESS THAN OR EQUAL TO ZERO.
!     DOUBLE PRECISION YMN, YMX
!
!
      FPLM = D1MACH(2)
!
      XMISS = FPLM
      YMISS(1) = FPLM
!
!     SET LOGICAL UNIT NUMBER FOR OUTPUT AND SET OUTPUT WIDTH.
!
      CALL IPRINT (IPRT)
!
      CALL VERSP(.TRUE.)
      IF (IABS(NPRT).EQ.1) THEN
         WRITE (IPRT, 1010)
      ELSE
         WRITE (IPRT, 1000)
      END IF
!
      IF (ABS(NPRT).EQ.1) THEN
        ILOG = 0
      ELSE
        ILOG = 1
      END IF
      IF (NPRT.GE.1) THEN
!
!       PLOT VERTICAL PLOTS
!
        CALL VPLMT(YAXIS, YMISS, NPTS, 1, NPTS, 0.0D0, 0.0D0, YMN, YMX,
     +    ERROR, NMSUB, .TRUE., 1)
        IF (.NOT.ERROR)
     +    CALL VPMN(YAXIS(2), YMISS, NPTS-1, 1, NPTS, 1, 0, ISYM, 1, 0,
     +    YMN, YMX, 0.5D0/(NPTS-1), 0.5D0/(NPTS-1),
     +   .TRUE., ILOG, -1, 0)
      ELSE
!
!       PLOT PAGE PLOTS
!
        CALL PPLMT(YAXIS, YMISS, XAXIS, XMISS, NPTS, 1, NPTS,
     +    0.0D0, 0.0D0, YMN, YMX, 0.0D0, 0.5D0, XMN, XMX,
     +    ERROR, NMSUB, .TRUE.)
        IF (.NOT.ERROR) THEN
          CALL PPMN (YAXIS, YMISS, XAXIS, XMISS, NPTS, 1, NPTS, 0,
     +      ISYM, 1, 0, -1, YMN, YMX, XMN, XMX, .TRUE., ILOG)
          WRITE(IPRT, 1030)
        END IF
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (' SAMPLE PERIODOGRAM')
 1010 FORMAT (' SAMPLE PERIODOGRAM (IN DECIBELS)')
!1020 FORMAT (5H+FREQ/
!    1   7H PERIOD, 9X, 3HINF, 7X, 3H10., 4X, 2H5., 8X, 6H3.3333, 4X,
!    2   3H2.5, 4X, 2H2.)
 1030 FORMAT (5H+FREQ/
     +   7H PERIOD, 9X, 3HINF, 7X, 3H20., 7X, 3H10., 8X, 6H6.6667, 4X,
     +   2H5., 8X, 2H4., 8X, 6H3.3333, 4X, 6H2.8571, 4X, 3H2.5, 7X,
     +   6H2.2222, 4X, 2H2.)
!
      END
!XDCKLE
      SUBROUTINE XDCKLE(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA
      INTEGER
     +   I,IPRT,IXM,LDSMIN,M,N,NETA,NPAR,NPRT,NROW,NTAU,NTEST
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(10),SCALE(10),XM(200,2)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DCKLS,DCKLS1,DCKLSC,DRV4A,DRV4B,IPRINT,LDSCMP,MDL4
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        *
!     EXTERNAL DRV4A, DRV4B
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL4
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     DOUBLE PRECISION PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION SCALE(10)
!        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION XM(200,2)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      CALL IPRINT(IPRT)
!
!     SET PARAMETER VALUES
!
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
      CALL LDSCMP(5, 0, 2*NPAR+1, 0, 0, 0, 'D',
     +            N*NPAR+NPAR+N, LDSMIN)
!
      IF (LDSMIN.LE.LDSTAK) GO TO 5
!
      WRITE (IPRT, 1040) LDSMIN
      RETURN
!
    5 CONTINUE
!
!     CREATE INDEPENDENT VARIABLE
!
      DELTA = 0.0625D0
      XM(1,1) = 0.0D0
      DO 10 I=2,N
         XM(I,1) = XM(I-1,1) + DELTA
   10 CONTINUE
!
      NTEST = 0
!
!     CHECK ERROR HANDLING
!
!        TEST 1  -  MISCELANEOUS ERROR CHECKING
!
      N = -5
      M = -5
      IXM = -10
      NPAR = -10
!
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1020)
      WRITE (IPRT,1000)
      IERR = -1
      CALL DCKLS(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSTAK)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSTAK, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
!
!        TEST 2  -  MISCELANEOUS ERROR CHECKING (CONTINUED)
!
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
      SCALE(2) = 0.0D0
!
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1030)
      WRITE (IPRT,1000)
      IERR = -1
      CALL DCKLS(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSMIN-1)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSMIN-1,
     +   NETA, NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
!
      RETURN
!
!     FORMAT STATEMENTS
!
!
 1000 FORMAT (15H TEST OF DCKLS )
 1010 FORMAT (15H TEST OF DCKLSC)
 1020 FORMAT (32H CHECK ERROR HANDLING  -  TEST 1)
 1030 FORMAT (32H CHECK ERROR HANDLING  -  TEST 2)
 1040 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1050 FORMAT (29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1130 FORMAT (43H1DERIVATIVE CHECKING SUBROUTINE TEST NUMBER, I5)
      END
!DRV
      SUBROUTINE DRV(PAR, NPAR, XM, N, M, IXM, D)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DUMMY DERIVATIVE FUNCTION FOR NLS FAMILY
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PAR(NPAR),XM(IXM,M)
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION D(N,NPAR)
!        THE FIRST DERIVATIVE WITH RESPECT TO THE ITH PARAMETER
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLESC
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS
!     DOUBLE PRECISION PAR(NPAR)
!        MODEL PARAMETERS
!     DOUBLE PRECISION XM(IXM,M)
!        MODEL INDEPENDENT VARIABLE
!
!
      RETURN
!
      END
!AOS
      SUBROUTINE AOS (N, LAGMAX, ACOV, PRHO, IAR, OSPVAR, PHI, WORK,
     +   AIC, FTEST, LACOV, LAIC)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES AUTOREGRESSIVE MODEL ORDER SELECTION
!     STATISTICS. IT PERFORMS STEPWISE FITTING OF AUTOREGRESSIVE
!     COEFFICIENTS BY DURBINS METHOD USING AKAIKES AIC CRITERION
!     FOR SELECTING ORDER.   THE ROUTINE IS MODELED AFTER
!     SUBROUTINE UFPE WRITTEN BY DICK JONES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   OSPVAR
      INTEGER
     +   IAR,LACOV,LAGMAX,LAIC,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(LACOV),AIC(LAIC),FTEST(2,LAGMAX),PHI(LAGMAX),
     +   PRHO(LAGMAX),WORK(LAGMAX)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ACOV0,AICMIN,FPLM,RSS,RSSMIN,SQPACF
      INTEGER
     +   I,J
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFF,D1MACH
      EXTERNAL CDFF,D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ARCOEF
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG,DBLE
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV), ACOV0
!        THE AUTOCOVARIANCES FOR LAGS ZERO TO LAGMAX, AND THE
!        AUTOCOVARIANCE AT LAG ZERO.
!     DOUBLE PRECISION AIC(LAIC), AICMIN
!        THE ARRAY CONTAINING AKIAKES CRITERIA FOR EACH ORDER, WHERE
!        AIC(I+1) IS THE CRITERIA FOR ORDER I-1, AND THE MINIMUM
!        CRITERIA COMPUTED.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     DOUBLE PRECISION FTEST(2, LAGMAX)
!        THE ARRAY IN WHICH THE F PERCENTAGE POINT AND PROBABILITY ARE
!        STORED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     DOUBLE PRECISION OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
!     DOUBLE PRECISION PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     DOUBLE PRECISION PRHO(LAGMAX)
!        THE ARRAY CONTAINING THE PARTIAL AUTOCORRELATION
!        COEFFICIENTS.
!     DOUBLE PRECISION RSS, RSSMIN
!        THE ONE STEP PREDICTION RESIDUAL SUM OF SQUARES AND THE
!        MINIMUM ONE STEP PREDICTION RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION SQPACF
!        THE SQUARED VALUE OF THE PARTIAL AUTOCORRELATION FUNCTION AT
!        LAG I.
!     DOUBLE PRECISION WORK(LAGMAX)
!        A DOUBLE PRECISION WORK AREA.
!
      FPLM = D1MACH(2)
!
      RSS = ACOV(1) * N
      RSSMIN = RSS
      AIC(1) = N * LOG(RSS * (N+1) / (N-1))
      AICMIN = AIC(1)
      IAR = 0
!
!  START STEPWISE PROCEDURE
!
      WORK(1) = ACOV(2) / ACOV(1)
      PRHO(1) = WORK(1)
      RSS = RSS * (1.0D0 - WORK(1)*WORK(1))
      AIC(2) = N * LOG(RSS * (N+2) / (N-2))
!
      SQPACF = WORK(1) * WORK(1)
      FTEST(1, 1) = FPLM
      FTEST(2, 1) = 0.0D0
      IF (SQPACF .GE. 1.0D0) GO TO 5
!
      FTEST(1,1) = (N-2) * SQPACF / (1.0D0 - SQPACF)
!
      FTEST(2,1) = 1.0D0 - CDFF(FTEST(1,1), 1.0D0, DBLE(N-2))
!
    5 CONTINUE
!
      IF (AIC(2).GE.AICMIN) GO TO 10
      AICMIN = AIC(2)
      RSSMIN = RSS
      IAR = 1
      PHI(1) = WORK(1)
!
   10 IF (LAGMAX.LE.1) GO TO 40
!
      ACOV0 = ACOV(1)
!
      DO 30 I=2,LAGMAX
         CALL ARCOEF (ACOV(2), WORK, RSS, I, LAGMAX, ACOV0)
         PRHO(I) = WORK(I)
         AIC(I+1) = FPLM
         FTEST(1,I) = FPLM
         FTEST(2,I) = FPLM
         IF (I.EQ.N-1) GO TO 15
!
         AIC(I+1) = N * LOG(RSS * (N+I+1) / (N-I-1))
!
         SQPACF = WORK(I) * WORK(I)
         IF (SQPACF .GE. 1.0D0) GO TO 15
!
         FTEST(1,I) = (N-I-1) * SQPACF / (1.0D0 - SQPACF)
!
         FTEST(2,I) = 1.0D0 - CDFF(FTEST(1,I), 1.0D0, DBLE(N-I-1))
!
   15    CONTINUE
!
!     IF THIS AIC IS A MINIMUM AND ITS LAG DOES NOT EXCEED N/2,
!     SAVE THE COEFFICIENTS.
!
         IF ((AIC(I+1).GE.AICMIN) .OR. (I.GT.N/2)) GO TO 30
         AICMIN = AIC(I+1)
         RSSMIN = RSS
         IAR = I
         DO 20 J=1,I
            PHI(J) = WORK(J)
   20    CONTINUE
   30 CONTINUE
!
!   NORMALIZE AIC
!
   40 CONTINUE
      AIC(1) = AIC(1) - AICMIN
      DO 50 I=1,LAGMAX
         AIC(I+1) = AIC(I+1) - AICMIN
   50 CONTINUE
!
      OSPVAR = RSSMIN / (N-IAR-1)
!
      RETURN
      END
!PPC
      SUBROUTINE PPC(YM, X, N, ILOG, ISIZE, NOUT, YLB, YUB, XLB, XUB)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT (LONG CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   ILOG,ISIZE,N,NOUT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   IPRT,ISCHCK,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'P',       'P',       'C',       ' ',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      YMMISS(1) = 1.0D0
      XMISS = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      ISCHCK = 0
      MISS = .FALSE.
      LISYM = 1
!
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL PPC (Y, X, N, ILOG,'/
     +   '      +          ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      END
!SVP
      SUBROUTINE SVP(YM, N, NS, ISYM)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH USER CONTROL OF THE PLOT SYMBOLS USED (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
      INTEGER
     +   ISYM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IPRT,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'V',       'P',       ' ',       ' ',       ' '/
!
!     DEFINE CONSTANTS
!
!     SET DEFAULT VALUES
!
      M = 1
      IYM = N
      MULTI = .FALSE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 1
      ISIZE = -1
      MISS = .FALSE.
      LISYM = N
      IRLIN = -1
      IBAR = 0
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YM, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL SVP (Y, N, NS, ISYM)')
      END
!DCKLS
      SUBROUTINE DCKLS(XM, N, M, IXM, MDL, DRV, PAR, NPAR, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR CHECKING USER SUPPLIED
!     ANALYTIC DERIVATIVES AGAINST NUMERICAL DERIVATIVES
!     FOR THE NONLINEAR LEAST SQUARES ROUTINES (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),XM(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,LSCALE,NETA,NPRT,NROW,NTAU
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   SCALE(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DCKDRV,IPRINT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION SCALE(1)
!        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE INDEPENDENT VARIABLE MATRIX.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'D','C','K','L','S',' '/
!
!     SET DEFAULT VALUES
!
      NETA = 0
      NTAU = 0
      SCALE(1) = 0.0D0
      LSCALE = 1
      NPRT = 1
      NROW = 0
!
!     PASS CONTROL OF DERIVATIVE CHECKING TO DCKDRV
!
      CALL DCKDRV(NMSUB, LDSTAK, XM, N, M, IXM, MDL, DRV, PAR, NPAR,
     +   NETA, NTAU, SCALE, LSCALE, NROW, NPRT)
!
      IF (IERR.NE.1) RETURN
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL DCKLS (XM, N, M, IXM, NLSMDL, NLSDRV,'/
     +   '      +            PAR, NPAR, LDSTAK)')
      END
!ACFS
      SUBROUTINE ACFS(Y, N, LAGMAX, LACOV, ACOV, IAR, PHI, NPRT, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
!     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
!     WITH THE COMPUTED ACVF ESTIMATES RETURNED TO THE USERS
!     ROUTINE (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IAR,LACOV,LAGMAX,LDSTAK,N,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),PHI(*),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN,YSD
      INTEGER
     +   AIC,FTEST,I,IFP,IPRT,LDSMIN,LYFFT,NALL0,NFAC,NFFT,PRHO,
     +   SDRHO,WORK
      LOGICAL
     +   DIFFER,ISFFT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   IOD(1),ND(1),NDUM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACFER,ACFMN,ACFOUT,IPRINT,LDSCMP,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV)
!        THE AUTOCOVARIANCE VECTOR.
!     INTEGER AIC
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE AKAIKES CRITERION FOR EACH ORDER.
!     DOUBLE PRECISION CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     LOGICAL DIFFER
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER FTEST
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE PARTIAL F RATIO AND PROBABILITIES
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!     INTEGER IFP
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE FLOATING
!        POINT VARIABLES ARE SINGLE (IFP=3) OR DOUBLE (IFP=4) PRECISION.
!     INTEGER IOD(1)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
!     INTEGER ND(1)
!        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
!     INTEGER NDUM(1)
!        A DUMMY DIMENSIONED VARIABLE.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     DOUBLE PRECISION OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
!     DOUBLE PRECISION PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     INTEGER PRHO
!        THE STARTING LOCATION IN THE WORK AREA FOR PRHO.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SDRHO
!        THE STARTING LOCATION IN THE WORK AREA FOR SDRHO.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR WORK.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YSD
!        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'A',       'C',       'F',       'S',       ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      DIFFER = .FALSE.
      NFAC = 1
      ND(1) = 0
      IOD(1) = 0
      ISFFT = .FALSE.
      LYFFT = N
      NFFT = N
!
!
      CALL LDSCMP(4, 0, 0, 0, 0, 0, 'D', 5*LAGMAX+1, LDSMIN)
!
      CALL ACFER(NMSUB, N, LAGMAX, LACOV, LDSTAK, LDSMIN,
     +  DIFFER, NFAC, ND, IOD, ISFFT, LYFFT, NFFT)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      IF (IERR.EQ.0) THEN
!
!       SET UP THE WORK AREA.
!
        CALL STKSET(LDSTAK, 4)
        NALL0 = STKST(1)
!
        IFP = 4
!
        PRHO = STKGET(LAGMAX, IFP)
        AIC = STKGET(LAGMAX+1, IFP)
        FTEST = STKGET(2*LAGMAX, IFP)
        WORK = STKGET(LAGMAX, IFP)
        SDRHO = WORK
!
        IF (IERR.EQ.0) THEN
!
!         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
          CALL ACFMN (Y, N, LAGMAX, ACOV(2), RSTAK(SDRHO),
     +       YMEAN, RSTAK(PRHO), RSTAK(AIC), RSTAK(FTEST), PHI,
     +       IAR, OSPVAR, ACOV, LACOV, LAGMAX+1, CHIA, CHIAP,
     +       RSTAK(WORK), NPRT)
!
          YSD = SQRT (ACOV(1) * N / (N - 1))
!
!         CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
          IF ((NPRT.NE.0) .OR.  (ACOV(1).EQ.0.0D0)) CALL ACFOUT
     +       (YMEAN, YSD, N, N, LAGMAX, ACOV(2), RSTAK(SDRHO),
     +       RSTAK(PRHO), NDUM, RSTAK(AIC), LAGMAX+1, RSTAK(FTEST),
     +       IAR, PHI, OSPVAR, CHIA, CHIAP, LAGMAX, .FALSE., 0.0D0,
     +       .FALSE., .FALSE., 0, NDUM, NDUM, 0)
!
          IF (NPRT.NE.0) THEN
            DO 50 I = 1, LAGMAX
               ACOV(I+1) = ACOV(I+1) * ACOV(1)
   50       CONTINUE
          END IF
!
        END IF
!
        CALL STKCLR(NALL0)
!
      END IF
!
      IF (IERR.NE.0) THEN
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL ACFS (Y, N,'/
     + '      +           LAGMAX, LACOV, ACOV, IAR, PHI, NPRT, LDSTAK)')
      END
!NLSDS
      SUBROUTINE NLSDS(Y, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING ANALYTIC DERIVATIVES WITH USER
!     SUPPLIED CONTROL PARAMETERS, AND WITH COMPUTED VALUES RETURNED
!     TO THE USER.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IVAPRX,IVCV,IXM,LDSTAK,M,MIT,N,NPAR,NPARE,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),VCV(*),XM(*),
     +   Y(*)
      INTEGER
     +   IFIXED(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LWT,NNZW
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   WT(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTA
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE DERIVATIVES WE
!        CHECKED OR NOT.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(NPAR)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(1)
!        THE DUMMY ARRAY FOR THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','D','S',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      WEIGHT = .FALSE.
      SAVE = .TRUE.
!
      WT(1) = 1.0D0
      LIFIXD = NPAR
      LPV = N
      LSCALE = NPAR
      LSDPV = N
      LSDRES = N
      LWT = 1
!
      CALL NLCNTA(Y, WT, LWT, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, IDRVCK, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSDS (Y, XM, N, M, IXM, NLSMDL, NLSDRV,'/
     +   '      +            PAR, NPAR, RES, LDSTAK,'/
     +   '      +            IFIXED, IDRVCK, MIT, STOPSS, STOPP,'/
     +   '      +            SCALE, DELTA, IVAPRX, NPRT,'/
     +   '      +            NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)')
      END
!DIFSER
      SUBROUTINE DIFSER (Y, N, NDF, ND, IOD, YDIFF, NDIFF)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PERFORMS THE DIFFERENCING OPPERATION
!     DEFINED BY ND, IOD AND NDF ON THE SERIES Y, RESULTING IN
!     THE SERIES YDIFF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVIAION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N,NDF,NDIFF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*),YDIFF(*)
      INTEGER
     +   IOD(*),ND(*)
!
!  LOCAL SCALARS
      INTEGER
     +   I,J,K,L,NTIMES
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IOD(NDF)
!        THE VECTOR CONTAINING THE ORDERS OF EACH DIFFERENCE FACTOR.
!     INTEGER J, K, L
!        INDEX VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER ND(NDF)
!        THE VECTOR CONTAINING THE NUMBER OF TIMES EACH DIFFERENCING
!        FACTOR IS APPLIED.
!     INTEGER NDF
!        THE NUMBER OF DIFFERENCE FACTORS.
!     INTEGER NDIFF
!        THE NUMBER OF OBSERVATIONS REMAINING IN THE DIFFERENCED SERIES.
!     INTEGER NTIMES
!        THE NUMBER OF TIMES A GIVEN DIFFERENCE FACTOR IS TO BE APPLIED.
!     DOUBLE PRECISION Y(N), YDIFF(N)
!        THE VECTOR CONTAINING THE SERIES OBSERVATIONS AND THE VECTOR
!        IN WHICH THE DIFFERENCED SERIES IS RETURNED.
!
      DO 10 I = 1, N
         YDIFF(I) = Y(I)
   10 CONTINUE
!
      NDIFF = N
!
      IF (NDF .EQ. 0) RETURN
!
      DO 40 I = 1, NDF
         NTIMES = ND(I)
         DO 30 L = 1, NTIMES
            NDIFF = NDIFF - IOD(I)
            DO 20 J = 1, NDIFF
               K = J + IOD(I)
               YDIFF(J) = YDIFF(K) - YDIFF(J)
   20       CONTINUE
   30    CONTINUE
   40 CONTINUE
      RETURN
      END
!DCKCRV
      SUBROUTINE DCKCRV(J, D, PAR, NPAR, ETA, TAU, MDL, XM, N,
     +   NROW, M, IXM, PV, PVTEMP, MSG, LMSG, FD, PARMX, PVPSTP, STP)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS WHETHER HIGH CURVATURE COULD BE THE CAUSE
!     OF THE DISAGREEMENT BETWEEN THE NUMERICAL AND ANALYTIC DERIVATIVES
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   D,ETA,FD,PARMX,PV,PVPSTP,STP,TAU
      INTEGER
     +   IXM,J,LMSG,M,N,NPAR,NROW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PVTEMP(N),XM(IXM,M)
      INTEGER
     +   MSG(LMSG)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CURVE,FPLRS,PVMCRV,PVPCRV,STPCRV,TEMP,THIRD
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DCKFPA
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,SIGN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CURVE
!        A MEASURE OF THE CURVATURE IN THE MODEL.
!     DOUBLE PRECISION D
!        THE SCALAR IN WHICH ROW   NROW   OF THE DERIVATIVE
!        MATRIX WITH RESPECT TO THE JTH UNKNOWN PARAMETER
!        IS STORED.
!     DOUBLE PRECISION ETA
!        THE RELATIVE NOISE IN THE MODEL.
!     DOUBLE PRECISION FD
!        THE FORWARD DIFFERENCE QUOTIENT DERIVATIVE WITH RESPECT TO THE
!        JTH PARAMETER.
!     DOUBLE PRECISION FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARTIAL DERIVATIVE BEING EXAMINED.
!     INTEGER LMSG
!        THE LENGTH OF THE VECTOR MSG.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER MSG(LMSG)
!        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION PARMX
!        THE MAXIMUM OF THE CURRENT PARAMETER ESTIMATE.
!     DOUBLE PRECISION PV
!        THE SCALAR IN WHICH THE PREDICTED VALUE FROM THE MODEL FOR
!        ROW   NROW   IS STORED.
!     DOUBLE PRECISION PVMCRV
!        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
!        BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)-STPCRV.
!     DOUBLE PRECISION PVPCRV
!        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
!        BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCRV.
!     DOUBLE PRECISION PVPSTP
!        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
!        BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J) + STP.
!     DOUBLE PRECISION PVTEMP(N)
!        THE VECTOR OF PREDICTED VALUES FROM THE MODEL.
!     DOUBLE PRECISION STP
!        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FINITE DIFFERENC
!        DERIVATIVE
!     DOUBLE PRECISION STPCRV
!        THE STEP SIZE SELECTED TO CHECK FOR CURVATURE IN THE MODEL.
!     DOUBLE PRECISION TAU
!        THE AGREEMENT TOLERANCE.
!     DOUBLE PRECISION TEMP
!        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
!        PARAMETER IS STORED.
!     DOUBLE PRECISION THIRD
!        THE VALUE ONE THIRD.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      FPLRS = D1MACH(4)
!
      THIRD = 1.0D0/3.0D0
!
      STPCRV = (ETA**THIRD*PARMX*SIGN(1.0D0,PAR(J))+PAR(J)) - PAR(J)
!
      TEMP = PAR(J)
      PAR(J) = TEMP + STPCRV
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVTEMP)
!
      PVPCRV = PVTEMP(NROW)
!
      PAR(J) = TEMP - STPCRV
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVTEMP)
      PAR(J) = TEMP
!
      PVMCRV = PVTEMP(NROW)
!
!     ESTIMATE CURVATURE BY SECOND DERIVATIVE OF MODEL WITH RESPECT TO
!     PAR(J)
!
      CURVE = ((PVPCRV+PVMCRV)-2*PV) / (STPCRV*STPCRV)
      CURVE = CURVE + (ETA ** THIRD) * (ABS(PVPCRV) +
     +   ABS(PVMCRV) + 2.0D0 * ABS(PV)) / (PARMX * PARMX)
!
!     COMPARE NUMERICAL AND ANALYTICAL DERIVATIVES USING A FUDGE
!     FACTOR OF 10.0D0.
!
      IF (ABS(CURVE*STP)*5.0D0.LT.ABS(FD-D)) THEN
!
!     CURVATURE CANNOT ACCOUNT FOR DISCREPANCY.
!     CHECK IF FINITE PRECISION ARITHMETIC COULD BE THE CULPRIT.
!
         CALL DCKFPA(J,D,PAR,NPAR,ETA,TAU,MDL,XM,N,NROW,
     +      M,IXM,PV,PVTEMP,MSG,LMSG,FD,PARMX,STP,PVPSTP,CURVE)
!
      ELSE
!
!     HIGH CURVATURE COULD BE THE PROBLEM.  TRY A SMALLER STEP SIZE.
!     COMPUTE SMALLER STEPSIZE
!
         STP = (2.0D0*TAU*ABS(D)*SIGN(1.0D0,PAR(J))/ABS(CURVE)+PAR(J))
     +          - PAR(J)
!
         IF (ABS(STP).LE.FPLRS*ABS(PAR(J))) THEN
!
!     NEW STEP SIZE IS TOO SMALL TO USE.
!
            IF (MSG(1).EQ.0) MSG(1) = 1
            MSG(J+1) = 1
         ELSE
!
!     TRY NEW STEP SIZE
!
            TEMP = PAR(J)
            PAR(J) = TEMP + STP
            CALL MDL(PAR, NPAR, XM, N, M, IXM, PVTEMP)
            PAR(J) = TEMP
            PVPSTP = PVTEMP(NROW)
!
!     COMPUTE THE NEW NUMERICAL DERIVATIVE
!
            FD = (PVPSTP-PV)/STP
!
!     CHECK WHETHER THE NEW NUMERICAL DERIVATIVE IS NOT OK
!
            IF (ABS(FD-D).GT.2.0D0*TAU*ABS(D)) THEN
!
!     NUMERICAL DERIVATIVE COMPUTED USING NEW STEP SIZE DOES
!     NOT AGREE WITH ANALYTIC DERIVATIVE.
!
!     CHECK IF THE PROBLEM COULD BE THE FORWARD DIFFERENCE QUOTIENT
!     DERIVATIVE.
!     (FUDGE FACTOR IS 2)
!
               IF (ABS(STP*(FD-D)).GE.2.0D0*ETA*ABS(PV+PVPSTP)) THEN
!
!     FINITE PRECISION COULD NOT BE THE CULPRIT
!
                  MSG(1) = 2
                  MSG(J+1) = 2
               ELSE
!
!     FINITE PRECISION MAY BE THE CULPRIT
!
                  IF (MSG(1).EQ.0) MSG(1) = 1
                  MSG(J+1) = 1
               END IF
            END IF
         END IF
      END IF
      RETURN
!
      END
!HIPASS
      SUBROUTINE HIPASS (Y, N, FC, K, HHP, YF, NYF)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE CARRIES OUT HI-PASS FILTERING OF THE
!     SERIES.  THE FILTER IS THE K-TERM
!     LEAST SQUARES APPROXIMATION TO THE CUTOFF FILTER
!     WITH CUTOF FREQUENCY FC.  ITS TRANSFER FUNCTION
!     HAS A TRANSITION BAND OF WIDTH DELTA SURROUNDING FC,
!     WHERE DELTA = 4*PI/K.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC
      INTEGER
     +   K,N,NYF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   HHP(*),Y(*),YF(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,HEAD
!
!  LOCAL ARRAYS
      CHARACTER
     +   LFC(8)*1,LK(8)*1,LN(8)*1,NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,ERIODD,ERSII,ERSLFS,FLTSL,HPFLT,IPRINT,LPFLT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION FC
!        THE USER SUPPLIED CUTOFF FREQUENCY.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     DOUBLE PRECISION HHP(K)
!        THE ARRAY IN WHICH THE -IDEAL- HIGH PASS FILTER COEFFICIENTS
!        WILL BE RETURNED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS TO BE COMPUTED.
!     CHARACTER*1 LFC(8), LK(8), LN(8)
!        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES FC, K AND N.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'H',       'I',       'P',       'A',       'S',       'S'/
      DATA
     +  LFC(1), LFC(2), LFC(3), LFC(4), LFC(5), LFC(6), LFC(7), LFC(8)
     + /  'F',   'C',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 3, 1, HEAD, ERR01, LN)
!
      CALL ERSII(NMSUB, LFC, FC, 0.0D0,
     +           0.5D0, 2, HEAD, ERR02, LFC, LFC)
!
      CALL EISII(NMSUB, LK, K, 1, N, 2, HEAD, ERR03, LK, LK)
!
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR04)
      IF (ERR01 .OR. ERR02 .OR. ERR03 .OR. ERR04) GO TO 10
!
      CALL ERSLFS(NMSUB, FC, K, HEAD, ERR05)
!
      IF (ERR05) GO TO 10
      GO TO 20
!
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   20 CONTINUE
!
      CALL LPFLT (FC, K, HHP)
!
      CALL HPFLT (HHP, K, HHP)
!
      CALL FLTSL (Y, N, K, HHP, YF, NYF)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   46H       CALL HIPASS (Y, N, FC, K, HHP, YF, NYF))
      END
!IPGORD
      SUBROUTINE IPGORD (PERI, NF, N, FREQ, XAXIS, YAXIS, ISYM, NPTS,
     +   LPCV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES CO-ORDINATES FOR THE SPECTRAL PLOTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LPCV,N,NF,NPTS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),PERI(NF),XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISYM(LPCV)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CI,CIMID
      INTEGER
     +   I,II,NLIM
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   S(40)
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MOD,DBLE,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CI, CIMID
!        THE WIDTH AND MIDPOINT OF THE TEST INTERVAL FOR WHITE NOISE.
!     DOUBLE PRECISION FREQ(NF)
!        THE ARRAY IN WHICH THE FREQUENCIES AT WHICH THE PERIODOGRAM
!        WAS ESTIMATED ARE STORED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER II
!        AN INDEX VARIABLE
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER N
!        THE ACTUAL NUMBER OF OBSERVATIONS IN THE SERIES FROM WHICH
!        THE PERIODOGRAM WAS COMPUTED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
!        ARE ESTIMATED.
!     INTEGER NLIM
!        THE NUMBER OF POINTS AT WHICH THE WHITE NOISE LIMITS ARE TO
!        PLOTTED.
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     DOUBLE PRECISION PERI(NF)
!        THE ARRAY CONTAINING THE INTEGRATED PERIODOGRAM VALUES.
!     DOUBLE PRECISION S(40)
!        VALUES USED TO COMPUTE THE CONFIDENCE LIMITS.
!     DOUBLE PRECISION XAXIS(LPCV), YAXIS(LPCV)
!        THE X, Y CO-ORDINATES FOR THE SPECTRAL PLOTS.
!
      DATA S(1)/0.975D0/, S(2)/0.842D0/, S(3)/0.708D0/
      DATA S(4)/0.624D0/, S(5)/0.563D0/
      DATA S(6)/0.519D0/, S(7)/0.483D0/, S(8)/0.454D0/
      DATA S(9)/0.430D0/, S(10)/0.409D0/
      DATA S(11)/0.391D0/, S(12)/0.375D0/, S(13)/0.361D0/
      DATA S(14)/0.349D0/, S(15)/0.338D0/
      DATA S(16)/0.327D0/, S(17)/0.318D0/, S(18)/0.309D0/
      DATA S(19)/0.301D0/, S(20)/0.294D0/
      DATA S(21)/0.287D0/, S(22)/0.281D0/, S(23)/0.275D0/
      DATA S(24)/0.269D0/, S(25)/0.264D0/
      DATA S(26)/0.259D0/, S(27)/0.254D0/, S(28)/0.250D0/
      DATA S(29)/0.246D0/, S(30)/0.242D0/
      DATA S(31)/0.238D0/, S(32)/0.234D0/, S(33)/0.231D0/
      DATA S(34)/0.227D0/, S(35)/0.224D0/
      DATA S(36)/0.221D0/, S(37)/0.218D0/, S(38)/0.215D0/
      DATA S(39)/0.213D0/, S(40)/0.210D0/
!
      I = N + MOD(N,2) - 1
!
      IF (I .LE. 40) THEN
         CI = S(I)
      ELSE
         CI = 1.36D0 / SQRT(DBLE(I))
      END IF
!
      DO 10 I = 1, NF
         XAXIS(I) = FREQ(I)
         YAXIS(I) = PERI(I)
         ISYM(I) = 1
   10 CONTINUE
!
      NLIM = 101
!
      II = NF
!
      DO 30 I = 1, NLIM, 2
         CIMID = DBLE(I-1) / DBLE(NLIM-1)
         IF (CIMID - CI .LT. 0.0D0) GO TO 20
         II = II + 1
         XAXIS(II) = CIMID / 2.0D0
         YAXIS(II) = CIMID - CI
         ISYM(II) = 2
   20    IF (CIMID + CI .GT. 1.0D0) GO TO 30
         II = II + 1
         XAXIS(II) = CIMID / 2.0D0
         YAXIS(II) = CIMID + CI
         ISYM(II) = 2
   30 CONTINUE
!
      NPTS = II
!
      RETURN
      END
!MVPMC
      SUBROUTINE MVPMC(YM, YMMISS, N, M, IYM, NS, ILOG, ISIZE,
     +   YLB, YUB, XLB, XINC)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA AND MULTIPLE Y-AXIS VALUES (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   ILOG,ISIZE,IYM,M,N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IBAR,IPRT,IRLIN,ISCHCK,LISYM
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(M)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'M',       'V',       'P',       'M',       'C',       ' '/
!
!     SET DEFAULT VALUES
!
      MULTI = .TRUE.
      IRLIN = -1
      IBAR = -1
      ISCHCK = 2
      MISS = .TRUE.
      LISYM = 1
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL MVPMC (YM, YMMISS, N, M, IYM, NS, ILOG,'/
     +  '      +            ISIZE, YLB, YUB, XLB, XINC)')
      END
!SPPLTL
      SUBROUTINE SPPLTL (SPCMN, SPCMX, ALOW, AUP, YPLTMN, YPLTMX,
     +   CILOW, CIMID, CIUP)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SETS VARIOUS Y AXIS LIMITS FOR DECIBLE
!     SPECTRUM PLOTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALOW,AUP,CILOW,CIMID,CIUP,SPCMN,SPCMX,YPLTMN,YPLTMX
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RNGMN,YMAX,YMIN
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG10
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALOW, AUP
!        FACTORS USED TO COMPUTE THE CONFIDENCE INTERVALS.
!     DOUBLE PRECISION CILOW, CIMID, CIUP
!        THE Y CORDNATES FOR THE LOWER  MID AND UPPER CONFIDENCE
!        INTERVAL POINTS.
!     DOUBLE PRECISION RNGMN
!        THE MINIMUM Y AXIS RANGE FOR THE PLOT.
!     DOUBLE PRECISION SPCMN, SPCMX
!        THE MINIMUM AND MAXIMUM SPECTRAL VALUE TO BE PLOTTED.
!     DOUBLE PRECISION YMAX, YMIN
!        THE MAXIMUM AND MINIMUM ACTUAL SPECTRUM VALUE TO BE PLOTTED.
!     DOUBLE PRECISION YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VAUES TO BE PLOTTED FOR THE Y AXIS.
!
!     SET CO-ORDINATES FOR DECIBLE PLOTS
!
      YMAX = LOG10(SPCMX)
      YMIN = LOG10(SPCMN)
!
      YPLTMX = SPCMX
      YPLTMN = SPCMN
      RNGMN = 2.0D0 * (LOG10(AUP) - LOG10(ALOW))
      IF (YMAX - YMIN .GE. RNGMN) GO TO 10
!
      YPLTMX = 10.0D0 ** (YMAX + (RNGMN - YMAX + YMIN) * 0.5D0)
      YPLTMN = 10.0D0 ** (YMIN - (RNGMN - YMAX + YMIN) * 0.5D0)
!
   10 CIUP = YPLTMX
      CIMID = CIUP / AUP
      CILOW = CIMID * ALOW
!
      RETURN
      END
!VCVOUT
      SUBROUTINE VCVOUT(NP, VCV, IVCV, EST)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS THE VARIANCE COVARIANCE MATRIX.
!     IF EST IS TRUE, THE COVARIANCES ARE LISTED ABOVE THE
!     DIAGONAL, THE VARIANCES ON THE DIAGONAL, AND THE CORRELATION
!     COEFFICIENTS BELOW THE DIAGONAL.
!     IF EST IS FALSE, THE STANDARD DEVIATIONS ARE LISTED ON THE
!     DIAGONAL, AND THE CORRELATION COEFFICIENTS ARE BELOW THE
!     DIAGONAL.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IVCV,NP
      LOGICAL
     +   EST
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VCV(IVCV,NP)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DEN,SVCVII,SVCVJJ
      INTEGER
     +   I,IPRT,J,K,MODE
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,MATPRT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DEN
!        DENOMINATOR OF (I, J) CORRELATION COEFFICIENT
!     LOGICAL EST
!        AN INDICATOR USED TO DESIGNATE WHETHER THE VCV TO BE PRINTED
!        IS OF THE ESTIMATED PARAMETERS (TRUE) OR NOT (FALSE).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE EXACT FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER MODE
!        IF MODE IS 1, PRINT FULL MATRIX.
!        IF MODE IS 2, PRINT LOWER TRIANGLE WITH SQUARE ROOTS OF
!                      OF THE DIAGONAL.
!     INTEGER NP
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     DOUBLE PRECISION SVCVII, SVCVJJ
!        SQUARE ROOTS OF VCV(I, I) AND VCV(J, J)
!     DOUBLE PRECISION VCV(IVCV,NP)
!        THE VARIANCE COVARIANCE MATRIX.
!
!     COMMENCE BODY OF ROUTINE
!
      CALL IPRINT(IPRT)
!
!     DETERMINE WHETHER TO ISSUE NEGATIVE VARIANCE WARNING
!
      MODE = 2
      DO 10 I=1,NP
         IF (VCV(I,I).GT.0.0D0) GO TO 10
         WRITE (IPRT,1000)
         IF (EST) WRITE (IPRT,1050)
         WRITE (IPRT,1010)
         MODE = 0
         GO TO 70
   10 CONTINUE
!
      IF (EST) GO TO 20
!
!     PRINT HEADING FOR CORRELATION ROUTINES
!
      WRITE (IPRT,1040)
      WRITE (IPRT,1030)
      MODE = 2
      GO TO 30
!
   20 CONTINUE
!
!     PRINT HEADING FOR ESTIMATION ROUTINES
!
      WRITE (IPRT,1050)
      WRITE (IPRT,1020)
      MODE = 1
!
   30 CONTINUE
!
!     COMPUTE THE CORRELATION COEFFICIENTS AND STORE IN THE BOTTOM HALF
!     OF THE VARIANCE COVARIANCE MATRIX
!
      IF (NP.EQ.1) GO TO 60
      DO 50 J=2,NP
         K = J - 1
         SVCVJJ = 0.0D0
         IF (VCV(J,J).GT.0.0D0) SVCVJJ = SQRT(VCV(J,J))
         DO 40 I=1,K
            SVCVII = 0.0D0
            IF (VCV(I,I).GT.0.0D0) SVCVII = SQRT(VCV(I,I))
            DEN = SVCVII*SVCVJJ
            IF (DEN.LE.0.0D0) VCV(J,I) = 0.0D0
            IF (DEN.GT.0.0D0) VCV(J,I) = VCV(J,I)/DEN
   40    CONTINUE
   50 CONTINUE
!
   60 CONTINUE
!
   70 CALL MATPRT(VCV, VCV, NP, IPRT, MODE, 1, IVCV)
!
!     RESTORE THE VCV MATRIX
!
      IF (NP.EQ.1) RETURN
      DO 90 J=2,NP
         K = J - 1
         DO 80 I=1,K
            VCV(J,I) = VCV(I,J)
   80    CONTINUE
   90 CONTINUE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/18H COVARIANCE MATRIX)
 1010 FORMAT (/39H     NONPOSITIVE VARIANCES ENCOUNTERED./10H     CORRE,
     +   39HLATION COEFFICIENTS CANNOT BE COMPUTED.)
 1020 FORMAT (4X, 36H- COVARIANCES ARE ABOVE THE DIAGONAL/4X, 7H- VARIA,
     +   24HNCES ARE ON THE DIAGONAL/4X, 27H- CORRELATION COEFFICIENTS ,
     +   22HARE BELOW THE DIAGONAL)
 1030 FORMAT (4X, 41H- STANDARD DEVIATIONS ARE ON THE DIAGONAL/4X,
     +   49H- CORRELATION COEFFICIENTS ARE BELOW THE DIAGONAL)
 1040 FORMAT (/19H CORRELATION MATRIX)
 1050 FORMAT (/45H VARIANCE-COVARIANCE AND CORRELATION MATRICES,
     +   28H OF THE ESTIMATED PARAMETERS/ 1X, 72('-')/)
      END
!XNLSE
      SUBROUTINE XNLSE(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DEMONSTRATE THE USER CALLABLE ROUTINES IN THE NONLINEAR
!     LEAST SQUARES FAMILY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   I,IDRVCK,IPRT,IVAPRX,IVCV,IXM1,IXM3,LDSA1,LDSMIN,LDSN3A,
     +   M1,M3,MIT,N1,N3,NNZW,NPAR1,NPAR3,NPARE,NPRT,NTEST
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR1(10),PAR3(10),PV(100),RES(100),SCALE(10),SDPV(100),
     +   SDRES(100),STP(10),VCV(6,6),WT(100),XM1(10,2),XM3(101,5),
     +   Y1(10),Y3(100)
      INTEGER
     +   IFIXED(10)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DRV1A,DRV1B,IPRINT,LDSCMP,MDL1,MDL3,NLS,NLSC,NLSD,NLSDC,
     +   NLSDS,NLSS,NLSW,NLSWC,NLSWD,NLSWDC,NLSWDS,NLSWS,NLSX1,
     +   NLSX2,SETRV
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV1A, DRV1B
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
!        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(10)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM1, IXM3
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSA1, LDSN3A
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK
!        FOR THE ROUTINES WITH ANALYTIC DERIVATIVES AND
!        NUMERICAL DERIVATIVES, RESPECTIVELY.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M1, M3
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL1, MDL3
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N1, N3
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
!     INTEGER NPAR1, NPAR3
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     DOUBLE PRECISION PAR1(10), PAR3(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION PV(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(100)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     DOUBLE PRECISION SCALE(10)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     DOUBLE PRECISION SDPV(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF THE
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(10)
!        THE RCSTEP SIZE ARRAY.
!     DOUBLE PRECISION VCV(6,6)
!        THE COVARIANCE MATRIX.
!     DOUBLE PRECISION WT(100)
!        THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION XM1(10,2), XM3(101,5)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y1(10), Y3(100)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     DEFINE CONSTANTS
!
      DATA Y1(1), Y1(2), Y1(3), Y1(4), Y1(5), Y1(6)
     +   /2.138D0, 3.421D0, 3.597D0, 4.340D0, 4.882D0, 5.660D0/
!
      DATA XM1(1,1), XM1(2,1), XM1(3,1), XM1(4,1), XM1(5,1), XM1(6,1)
     +   /1.309D0, 1.471D0, 1.490D0, 1.565D0, 1.611D0, 1.680D0/
!
      DATA N3 /50/, M3 /5/, IXM3 /101/, NPAR3 /5/
!
      CALL IPRINT(IPRT)
!
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
!
      CALL SETRV(WT, N3, 1.0D0)
!
      CALL LDSCMP(6, 0, 60+2*NPAR1, 0, 0, 0,
     +   'D', 94+N1*(3+NPAR1)+NPAR1*(3*NPAR1+35)/2, LDSA1)
      CALL LDSCMP(14, 0, MAX(2*(N3+NPAR3),60+2*NPAR3), 0, 0, 0,
     +   'D', MAX(10*N3,94+N3*(3+NPAR3)+NPAR3*(3*NPAR3+37)/2), LDSN3A)
!
      LDSMIN = MAX(LDSA1, LDSN3A)
!
      IF (LDSMIN.LE.LDSTAK) GO TO 5
!
      WRITE (IPRT, 1190) LDSMIN
      RETURN
!
    5 CONTINUE
!
      DO 20 I=1,N3
         XM3(I,1) = 1.0D0
         XM3(I,2) = I
         XM3(I,3) = XM3(I,2)*XM3(I,2)
         XM3(I,4) = XM3(I,3)*XM3(I,2)
         XM3(I,5) = XM3(I,4)*XM3(I,2)
         Y3(I) = XM3(I,1) + XM3(I,2) + XM3(I,3) + XM3(I,4) + XM3(I,5)
   20 CONTINUE
!
      NTEST = 0
!
!
!
!     CHECK ERROR HANDLING
!
!        TEST 1  -  PROBLEM SPECIFICATION
!
      N1 = -5
      M1 = -1
      IXM1 = -10
      NPAR1 = 0
      IVCV = -10
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1140)
!
      WRITE (IPRT,1000)
      CALL NLS(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSTAK)
      WRITE (IPRT,1120) IERR
!
      WRITE (IPRT,1010)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSC(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
!
      NPAR1 = 8
      N1 = 2
      WRITE (IPRT,1020)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSS(Y1, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
!
      WRITE (IPRT,1030)
      CALL NLSW(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSTAK)
      WRITE (IPRT,1120) IERR
!
      WRITE (IPRT,1040)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWC(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
!
      WRITE (IPRT,1050)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWS(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
!
      WRITE (IPRT,1060)
      CALL NLSD(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSTAK)
      WRITE (IPRT,1120) IERR
!
      WRITE (IPRT,1070)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSDC(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
!
      N1 = 15
      WRITE (IPRT,1080)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSDS(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
!
      WRITE (IPRT,1090)
      CALL NLSWD(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK)
      WRITE (IPRT,1120) IERR
!
      WRITE (IPRT,1100)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWDC(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
!
      WRITE (IPRT,1110)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
!
!        TEST 2  -  WEIGHTS AND CONTROL VALUES
!
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
!
      WT(N1) = -1.0D0
      STP(1) = 1.0D0
      STP(2) = 0.0D0
      SCALE(1) = 1.0D0
      SCALE(2) = 0.0D0
      DO 30 I=1,NPAR1
         IFIXED(I) = 1
   30 CONTINUE
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1150)
!
      WRITE (IPRT,1050)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWS(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
!
      WRITE (IPRT,1090)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSWD(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK)
      CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
!
!
!        TEST 3  -  TOO FEW POSITIVE WEIGHTS
!
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
!
      CALL SETRV(WT(2), N1-1, 0.0D0)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1160)
!
      WRITE (IPRT,1030)
      CALL NLSW(Y1, WT, XM1, N1, M1, IXM1, MDL1, PAR1, NPAR1, RES,
     +   LDSTAK)
      WRITE (IPRT,1120) IERR
!
      WRITE (IPRT,1110)
      CALL NLSWDS(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1120) IERR
!
!
!        TEST 4  -  DEFINITE ERROR IN DERIVATIVE
!
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
!
      CALL SETRV(WT, N1, 1.0D0)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1170)
!
      WRITE (IPRT,1060)
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSD(Y1, XM1, N1, M1, IXM1, MDL1, DRV1B, PAR1, NPAR1, RES,
     +   LDSTAK)
      WRITE (IPRT,1120) IERR
!
!
!        TEST 5  -  POSSIBLE ERROR IN DERIVATIVE
!
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
      IDRVCK = 1
      NPRT = 10000
!
      CALL SETRV(WT, N1, 1.0D0)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1180)
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N1, IVCV,
     +   NNZW, NPARE, RSD)
      PAR1(1) = 0.0D0
      WRITE (IPRT,1070)
      WRITE (IPRT,1360) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL NLSDC(Y1, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1, RES,
     +   LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE, DELTA,
     +   IVAPRX, NPRT)
      WRITE (IPRT,1370) IFIXED(1), IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
!
!
!        TEST 6 -  INSUFFICIENT WORK AREA LENGTH
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1230)
      CALL NLSX2(N1, M1, IXM1, NPAR1, IFIXED, STP, IDRVCK, MIT, STOPSS,
     +   STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
!
      WRITE (IPRT,1000)
      CALL NLSX1(3, PAR3, NPAR3, PV, SDPV, RES, SDRES, VCV, N3, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLS(Y3, XM3, N3, M3, IXM3, MDL3, PAR3, NPAR3, RES, LDSN3A-1)
      WRITE (IPRT,1120) IERR
!
      WRITE (IPRT,1090)
      CALL NLSX1(1, PAR1, NPAR1, PV, SDPV, RES, SDRES, VCV, N3, IVCV,
     +   NNZW, NPARE, RSD)
      CALL NLSWD(Y1, WT, XM1, N1, M1, IXM1, MDL1, DRV1A, PAR1, NPAR1,
     +   RES, LDSA1-1)
      WRITE (IPRT,1120) IERR
!
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (14H TEST OF NLS  )
 1010 FORMAT (15H TEST OF NLSC  )
 1020 FORMAT (15H TEST OF NLSS  )
 1030 FORMAT (14H TEST OF NLSW )
 1040 FORMAT (15H TEST OF NLSWC )
 1050 FORMAT (15H TEST OF NLSWS )
 1060 FORMAT (14H TEST OF NLSD )
 1070 FORMAT (15H TEST OF NLSDC )
 1080 FORMAT (15H TEST OF NLSDS )
 1090 FORMAT (14H TEST OF NLSWD)
 1100 FORMAT (15H TEST OF NLSWDC)
 1110 FORMAT (15H TEST OF NLSWDS)
 1120 FORMAT (/29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1140 FORMAT (46H ERROR HANDLING TEST 1 - PROBLEM SPECIFICATION)
 1150 FORMAT (51H ERROR HANDLING TEST 2 - WEIGHTS AND CONTROL VALUES)
 1160 FORMAT (49H ERROR HANDLING TEST 3 - TOO FEW POSITIVE WEIGHTS)
 1170 FORMAT (53H ERROR HANDLING TEST 4 - DEFINITE ERROR IN DERIVATIVE)
 1180 FORMAT (53H ERROR HANDLING TEST 5 - POSSIBLE ERROR IN DERIVATIVE)
 1190 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1230 FORMAT (' ERROR HANDLING TEST 6 - INSUFFICIENT WORK AREA LENGTH')
 1330 FORMAT (54H1NONLINEAR LEAST SQUARES ESTIMATION SUBROUTINE TEST NU,
     +   4HMBER, I5/)
 1340 FORMAT (24H INPUT   -  IFIXED(1) = , I6, 9X, 11H, STP(1) = ,
     +   G15.8, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8, 10H, STOPP = ,
     +   G15.8/13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I5)
 1350 FORMAT (//24H OUTPUT  -  IFIXED(1) = , I6, 9X, 11H, STP(1) = ,
     +   G15.8, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8, 10H, STOPP = ,
     +   G15.8/13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I5//)
 1360 FORMAT (24H INPUT   -  IFIXED(1) = , I6, 9X, 11H, IDRVCK = ,
     +   I5, 10X, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8,
     +   10H, STOPP = , G15.8/
     +   13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I6)
 1370 FORMAT (//24H OUTPUT  -  IFIXED(1) = , I6, 9X, 11H, IDRVCK = ,
     +   I5, 10X, 11H,    MIT = ,I5, 11H, STOPSS = , G15.8,
     +   10H, STOPP = , G15.8/
     +   13X, 11HSCALE(1) = , G15.8, 11H,  DELTA = , G15.8,
     +   11H, IVAPRX = , I5, 11H,   NPRT = , I5//)
      END
!LSTVEC
      SUBROUTINE LSTVEC(N, VEC)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS THE INDICES AND ELEMENT VALUES
!     OF THE VECTOR VEC.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   VEC(N)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IMAX,IMIN,INDEX,IPRT,NPERL
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   INPERL
      EXTERNAL INPERL
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IMAX, IMIN
!        THE LARGEST AND SMALLEST INDEX VALUE TO BE PRINTED ON EACH
!        LINE.
!     INTEGER INDEX
!        THE INDEX VALUE TO BE PRINTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER N
!        THE NUMBER OF VALUES TO BE PRINTED IN THE INPUT VECTOR.
!     INTEGER NPERL
!        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
!     DOUBLE PRECISION VEC(N)
!        THE VECTOR OF VALUES TO BE PRINTED.
!
      CALL IPRINT(IPRT)
!
      NPERL = INPERL(0)
!
      DO 10 I = 1, N, NPERL
         IMIN = I
         IMAX = MIN(I+NPERL-1, N)
         WRITE(IPRT, 1010) (INDEX, INDEX = IMIN, IMAX)
         WRITE(IPRT, 1020) (VEC(INDEX), INDEX = IMIN, IMAX)
   10 CONTINUE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1010 FORMAT(10X, 5HINDEX, I5, 6I15)
 1020 FORMAT(10X, 5HVALUE, 7(1X, G14.7)/)
!
      END
!ACFOUT
      SUBROUTINE ACFOUT (YMEAN, YSD, N, NUSED, LAGMAX, RHO, SDRHO,
     +   PRHO, NLPPA, AIC, LAIC, FTEST, IAR, PHI, OSPVAR, CHIA, CHIAP,
     +   NDFCHI, IFMISS, YMISS, DIFFER, NEWPG, NFAC, ND, IOD, NTIMES)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRINTS THE AUTOCORRELATIONS AND THEIR
!     STANDARD ERRORS, AS WELL AND THE PARTIAL AUTOCORRELATIONS
!     AND MISCELLANEOUS SUMMARY INFORMATION.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CHIA,CHIAP,OSPVAR,YMEAN,YMISS,YSD
      INTEGER
     +   IAR,LAGMAX,LAIC,N,NDFCHI,NFAC,NTIMES,NUSED
      LOGICAL
     +   DIFFER,IFMISS,NEWPG
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AIC(LAIC),FTEST(2,LAGMAX),PHI(LAGMAX),PRHO(LAGMAX),
     +   RHO(LAGMAX),SDRHO(LAGMAX)
      INTEGER
     +   IOD(*),ND(*),NLPPA(LAGMAX)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM,PMISS
      INTEGER
     +   IPRT,NMISS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      INTEGER
     +   ISYM(1)
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACFDTL,ACFLST,AOSLST,IPRINT,VERSP,VPMN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AIC(LAIC)
!        THE ARRAY CONTAINING THE AKAIKES INFORMATION CRITERION.
!     DOUBLE PRECISION CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     LOGICAL DIFFER
!        THE VARIABLE USED TO DESIGNATE WHETHER OR NOT THE SERIES
!        ANALYZED WAS DIFFERENCED OR NOT.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     DOUBLE PRECISION FTEST(2, LAGMAX)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     LOGICAL IFMISS
!        THE INDICATOR VARIABLE USED TO DETERMINE
!        WHETHER THE INPUT SERIES HAS MISSING DATA OR NOT.
!     INTEGER IOD(NFAC)
!        THE ORDER OF EACH OF THE DIFFERENCING FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER OF THE DEVICE USED FOR PRINTED
!        OUTPUT.
!     INTEGER ISYM(1)
!        A DUMMY ARRAY.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER ND(NFAC)
!        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCING
!        FACTORS ARE TO BE APPLIED.
!     INTEGER NDFCHI
!        THE DEGREES OF FREEDOM FOR THE CHI SQUARED STATISTIC.
!     LOGICAL NEWPG
!        THE VARIABLE DESIGNATING WHETHER OR NOT THE OUTPUT IS TO
!        START ON A NEW PAGE.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS.
!     INTEGER NLPPA(LAGMAX)
!        THE ARRAY OF NUMBERS OF LAGGED PRODUCT PAIRS USED TO
!        COMPUTE EACH ACF ESTIMATE.
!     INTEGER NMISS
!        THE NUMBER OF MISSING OBSERVATIONS.
!     INTEGER NTIMES
!        THE NUMBER OF TIMES THE FIRST DIFFERENCE FACTOR HAS BEEN
!        APPLIED.
!     INTEGER NUSED
!        THE ACTIVE NUMBER OF OBSERVATIONS.
!     DOUBLE PRECISION OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
!     DOUBLE PRECISION PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     DOUBLE PRECISION PMISS
!        THE PERCENT OF MISSING OBSERVATIONS.
!     DOUBLE PRECISION PRHO(LAGMAX)
!        THE ARRAY IN WHICH THE PARTIAL AUTOCORRELATIONS ARE STORED
!     DOUBLE PRECISION RHO(LAGMAX)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
!     DOUBLE PRECISION SDRHO(LAGMAX)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!        ARE STORED
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE OBSERVED SERIES.
!     DOUBLE PRECISION YMISS, YMMISS(1)
!        THE MISSING VALUE CODE.
!     DOUBLE PRECISION YSD
!        THE STANDARD DEVIATION OF THE OBSERVED SERIES.
!
!
      FPLM = D1MACH(2)
!
      YMMISS(1) = FPLM
!
!     PRINT SUMMARY INFORMATION
!
      CALL IPRINT(IPRT)
!
      IF (NEWPG) WRITE(IPRT, 1004)
!
      CALL VERSP (.TRUE.)
      WRITE(IPRT, 1005)
      IF (DIFFER) CALL ACFDTL(NFAC, ND, IOD, NTIMES)
      WRITE(IPRT, 1000) YMEAN, YSD, N
      IF (.NOT. IFMISS) GO TO 10
      NMISS = N - NUSED
      PMISS = 100.0D0 * NMISS / N
      WRITE(IPRT, 1003) NMISS, PMISS
   10 WRITE(IPRT, 1006) LAGMAX
      IF (IFMISS) WRITE(IPRT, 1007) YMISS
!
      IF (YSD .GT. 0.0D0) GO TO 20
!
      WRITE (IPRT, 1010)
      RETURN
!
   20 CONTINUE
!
!     PRINT ACF INFORMATION
!
      WRITE(IPRT, 1008)
      WRITE(IPRT, 1001)
      CALL ACFLST (RHO, SDRHO, NLPPA, LAGMAX, IFMISS, CHIA, NDFCHI,
     +   CHIAP)
!
!     PLOT ACF INFORMATION
!
      WRITE(IPRT, 1004)
      CALL VERSP (.TRUE.)
      WRITE(IPRT, 1001)
      IF (DIFFER) CALL ACFDTL(NFAC, ND, IOD, NTIMES)
      CALL VPMN(RHO, YMMISS, LAGMAX, 1, LAGMAX, 1, 0, ISYM, 1, 0,
     +   -1.0D0, 1.0D0, 1.0D0, 1.0D0, IFMISS, 0, 0, 1)
!
!     CHECK WHETHER PACF HAVE BEEN COMPUTED
!
      IF (NUSED .LE. N-1) RETURN
!
!     PRINT PACF INFORMATION AND AUTOREGRESSIVE MODEL ORDER SELECTION
!     STATISTICS
!
      WRITE(IPRT, 1004)
      CALL VERSP (.TRUE.)
      WRITE(IPRT, 1002)
      WRITE (IPRT, 1009)
      IF (DIFFER) CALL ACFDTL(NFAC, ND, IOD, NTIMES)
      CALL AOSLST (PRHO, AIC, FTEST, LAGMAX, LAIC, IAR, PHI, OSPVAR,
     +   .TRUE., N)
!
!     PLOT PACF INFORMATION
!
      WRITE(IPRT, 1004)
      CALL VERSP (.TRUE.)
      WRITE(IPRT, 1002)
      IF (DIFFER) CALL ACFDTL(NFAC, ND, IOD, NTIMES)
      CALL VPMN(PRHO, YMMISS, NDFCHI, 1, NDFCHI, 1, 0, ISYM, 1, 0,
     +   -1.0D0, 1.0D0, 1.0D0, 1.0D0, IFMISS, 0, 0, 1)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/
     +   ' AVERAGE OF THE SERIES                 = ', G14.7/
     +   ' STANDARD DEVIATION OF THE SERIES      = ', G14.7/
     +   ' NUMBER OF TIME POINTS                 = ', I10)
 1001 FORMAT (40H AUTOCORRELATION FUNCTION ESTIMATE (ACF)/)
 1002 FORMAT (49H PARTIAL AUTOCORRELATION FUNCTION ESTIMATE (PACF)/)
 1003 FORMAT (
     +   ' NUMBER OF MISSING OBSERVATIONS        = ', I10/
     +   ' PERCENTAGE OF OBSERVATIONS MISSING    = ', F10.4)
 1004 FORMAT ('1')
 1005 FORMAT ( 25H AUTOCORRELATION ANALYSIS)
 1006 FORMAT(
     +   ' LARGEST LAG VALUE USED                = ', I10)
 1007 FORMAT(
     +   ' MISSING VALUE CODE                    = ', G14.7)
 1008 FORMAT(//)
 1009 FORMAT (46H AND AUTOREGRESSIVE ORDER SELECTION STATISTICS///)
 1010 FORMAT (///36H THE AUTOCORRELATIONS OF THIS SERIES,
     +   22H COULD NOT BE COMPUTED/
     +   50H BECAUSE THE LAG ZERO AUTOCOVARIANCE OF THE SERIES,
     +    9H IS ZERO.)
      END
!SPPMC
      SUBROUTINE SPPMC(YM, YMMISS, X, XMISS, N, ISYM, ILOG, ISIZE, NOUT,
     +   YLB, YUB, XLB, XUB)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH USER CONTROL OF PLOT SYMBOLS AND WITH MISSING
!     OBSERVATIONS (LONG CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   ILOG,ISIZE,N,NOUT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*),YMMISS(1)
      INTEGER
     +   ISYM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,ISCHCK,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'P',       'P',       'M',       'C',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      M = 1
      IYM = N
      MULTI = .FALSE.
      ISCHCK = 1
      MISS = .TRUE.
      LISYM = N
!
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL SPPMC (Y, YMISS, X, XMISS, N, ISYM, ILOG,'/
     +   '      +            ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      END
!XAIMD
      SUBROUTINE XAIMD(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DEMONSTRATE THE USER CALLABLE ROUTINES IN THE ARIMA FAMILY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  SEPTEMBER 1, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   I,IFCST,IPRT,IVAPRX,IVCV,MIT,MXFAC,MXFC,MXFCO,MXN,MXPAR,N,
     +   NFAC,NFCST,NFCSTO,NPAR,NPARE,NPRT,NTEST
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FCST(200,10),FCSTSD(200,10),PAR(10),PV(200),RES(200),
     +   SCALE(10),SDPV(200),SDRES(200),STP(10),VCV(10,10),Y(200)
      INTEGER
     +   IFCSTO(10),IFIXED(10),MSPEC(4,10)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AIME,AIMEC,AIMES,AIMF,AIMFS,AIMX1,FITXSP,IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FCST(200, 10)
!        THE FORECASTS.
!     DOUBLE PRECISION FCSTSD(200, 10)
!        THE STANDARD DEVIATIONS OF THE FORECASTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFCST
!        THE FIRST DIMENSION OF THE ARRAY FCST.
!     INTEGER IFCSTO(10)
!        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
!     INTEGER IFIXED(10)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER MSPEC(4,10)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH
!        FACTOR.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFCST
!        THE NUMBER OF FORECASTS.
!     INTEGER NFCSTO
!        THE NUMBER OF THE ORIGINS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     DOUBLE PRECISION PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION PV(200)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(200)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     DOUBLE PRECISION SCALE(10)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     DOUBLE PRECISION SDPV(200)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(200)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(10)
!        THE RCSTEP SIZE ARRAY.
!     DOUBLE PRECISION VCV(10,10)
!        THE COVARIANCE MATRIX.
!     DOUBLE PRECISION Y(200)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     DEFINE CONSTANTS
!
      DATA    Y(  1),   Y(  2),   Y(  3),   Y(  4),   Y(  5),   Y(  6)
     +    / 112.0D0, 118.0D0, 132.0D0, 129.0D0, 121.0D0, 135.0D0/
      DATA    Y(  7),   Y(  8),   Y(  9),   Y( 10),   Y( 11),   Y( 12)
     +    / 148.0D0, 148.0D0, 136.0D0, 119.0D0, 104.0D0, 118.0D0/
      DATA    Y( 13),   Y( 14),   Y( 15),   Y( 16),   Y( 17),   Y( 18)
     +    / 115.0D0, 126.0D0, 141.0D0, 135.0D0, 125.0D0, 149.0D0/
      DATA    Y( 19),   Y( 20),   Y( 21),   Y( 22),   Y( 23),   Y( 24)
     +    / 170.0D0, 170.0D0, 158.0D0, 133.0D0, 114.0D0, 140.0D0/
      DATA    Y( 25),   Y( 26),   Y( 27),   Y( 28),   Y( 29),   Y( 30)
     +    / 145.0D0, 150.0D0, 178.0D0, 163.0D0, 172.0D0, 178.0D0/
      DATA    Y( 31),   Y( 32),   Y( 33),   Y( 34),   Y( 35),   Y( 36)
     +    / 199.0D0, 199.0D0, 184.0D0, 162.0D0, 146.0D0, 166.0D0/
      DATA    Y( 37),   Y( 38),   Y( 39),   Y( 40),   Y( 41),   Y( 42)
     +    / 171.0D0, 180.0D0, 193.0D0, 181.0D0, 183.0D0, 218.0D0/
      DATA    Y( 43),   Y( 44),   Y( 45),   Y( 46),   Y( 47),   Y( 48)
     +    / 230.0D0, 242.0D0, 209.0D0, 191.0D0, 172.0D0, 194.0D0/
      DATA    Y( 49),   Y( 50),   Y( 51),   Y( 52),   Y( 53),   Y( 54)
     +    / 196.0D0, 196.0D0, 236.0D0, 235.0D0, 229.0D0, 243.0D0/
      DATA    Y( 55),   Y( 56),   Y( 57),   Y( 58),   Y( 59),   Y( 60)
     +    / 264.0D0, 272.0D0, 237.0D0, 211.0D0, 180.0D0, 201.0D0/
      DATA    Y( 61),   Y( 62),   Y( 63),   Y( 64),   Y( 65),   Y( 66)
     +    / 204.0D0, 188.0D0, 235.0D0, 227.0D0, 234.0D0, 264.0D0/
      DATA    Y( 67),   Y( 68),   Y( 69),   Y( 70),   Y( 71),   Y( 72)
     +    / 302.0D0, 293.0D0, 259.0D0, 229.0D0, 203.0D0, 229.0D0/
      DATA    Y( 73),   Y( 74),   Y( 75),   Y( 76),   Y( 77),   Y( 78)
     +    / 242.0D0, 233.0D0, 267.0D0, 269.0D0, 270.0D0, 315.0D0/
      DATA    Y( 79),   Y( 80),   Y( 81),   Y( 82),   Y( 83),   Y( 84)
     +    / 364.0D0, 347.0D0, 312.0D0, 274.0D0, 237.0D0, 278.0D0/
      DATA    Y( 85),   Y( 86),   Y( 87),   Y( 88),   Y( 89),   Y( 90)
     +    / 284.0D0, 277.0D0, 317.0D0, 313.0D0, 318.0D0, 374.0D0/
      DATA    Y( 91),   Y( 92),   Y( 93),   Y( 94),   Y( 95),   Y( 96)
     +    / 413.0D0, 405.0D0, 355.0D0, 306.0D0, 271.0D0, 306.0D0/
      DATA    Y( 97),   Y( 98),   Y( 99),   Y(100),   Y(101),   Y(102)
     +    / 315.0D0, 301.0D0, 356.0D0, 348.0D0, 355.0D0, 422.0D0/
      DATA    Y(103),   Y(104),   Y(105),   Y(106),   Y(107),   Y(108)
     +    / 465.0D0, 467.0D0, 404.0D0, 347.0D0, 305.0D0, 336.0D0/
      DATA    Y(109),   Y(110),   Y(111),   Y(112),   Y(113),   Y(114)
     +    / 340.0D0, 318.0D0, 362.0D0, 348.0D0, 363.0D0, 435.0D0/
      DATA    Y(115),   Y(116),   Y(117),   Y(118),   Y(119),   Y(120)
     +    / 491.0D0, 505.0D0, 404.0D0, 359.0D0, 310.0D0, 337.0D0/
      DATA    Y(121),   Y(122),   Y(123),   Y(124),   Y(125),   Y(126)
     +    / 360.0D0, 342.0D0, 406.0D0, 396.0D0, 420.0D0, 472.0D0/
      DATA    Y(127),   Y(128),   Y(129),   Y(130),   Y(131),   Y(132)
     +    / 548.0D0, 559.0D0, 463.0D0, 407.0D0, 362.0D0, 405.0D0/
      DATA    Y(133),   Y(134),   Y(135),   Y(136),   Y(137),   Y(138)
     +    / 417.0D0, 391.0D0, 419.0D0, 461.0D0, 472.0D0, 535.0D0/
      DATA    Y(139),   Y(140),   Y(141),   Y(142),   Y(143),   Y(144)
     +    / 622.0D0, 606.0D0, 508.0D0, 461.0D0, 390.0D0, 432.0D0/
!
      CALL IPRINT(IPRT)
!
      DO 10 I = 1, 144
        Y(I) = LOG(Y(I))
   10 CONTINUE
!
!     SET DIMENSIONS
!
      MXN = 200
      MXPAR = 10
      MXFC = 200
      MXFCO = 10
      MXFAC = 10
!
!
      NTEST = 0
!
!
!     **TEST ON NORMAL STATEMENT**
!
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1000)
      CALL AIMX1(MXN, MXPAR, MXFC, MXFCO, MXFAC,
     +   1, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV,
     +   NFCST, NFCSTO, IFCSTO, FCST, IFCST, FCSTSD)
      CALL AIME (Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK)
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV,
     +   N, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1010)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL AIMX1(MXN, MXPAR, MXFC, MXFCO, MXFAC,
     +   1, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV,
     +   NFCST, NFCSTO, IFCSTO, FCST, IFCST, FCSTSD)
      CALL AIMEC(Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV,
     +   N, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1020)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL AIMX1(MXN, MXPAR, MXFC, MXFCO, MXFAC,
     +   1, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV,
     +   NFCST, NFCSTO, IFCSTO, FCST, IFCST, FCSTSD)
      CALL AIMES(Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV,
     +   N, NPARE, RSD)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1030)
      CALL AIMX1(MXN, MXPAR, MXFC, MXFCO, MXFAC,
     +   1, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV,
     +   NFCST, NFCSTO, IFCSTO, FCST, IFCST, FCSTSD)
      CALL AIMF (Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK)
      WRITE (IPRT,1120) IERR
!
      NTEST = NTEST + 1
      WRITE (IPRT,1330) NTEST
      WRITE (IPRT,1130)
      WRITE (IPRT,1040)
      WRITE (IPRT,1340) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      CALL AIMX1(MXN, MXPAR, MXFC, MXFCO, MXFAC,
     +   1, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV,
     +   NFCST, NFCSTO, IFCSTO, FCST, IFCST, FCSTSD)
      CALL AIMFS(Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK,
     +   NFCST, NFCSTO, IFCSTO, NPRT, FCST, IFCST, FCSTSD)
      WRITE (IPRT,1350) IFIXED(1), STP(1), MIT, STOPSS, STOPP,
     +   SCALE(1), DELTA, IVAPRX, NPRT
      WRITE (IPRT,1120) IERR
      CALL FITXSP(PAR, FCST(1,1), FCST(1,2), FCST(1,3), FCSTSD, VCV,
     +  N, NPAR, IVCV, N, NPARE, RSD)
!
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (14H TEST OF AIM  )
 1010 FORMAT (15H TEST OF AIMC  )
 1020 FORMAT (15H TEST OF AIMS  )
 1030 FORMAT (14H TEST OF AIMF )
 1040 FORMAT (15H TEST OF AIMFS )
 1120 FORMAT (/29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1130 FORMAT (15H NORMAL PROBLEM)
 1330 FORMAT ('1ARIMA TEST NUMBER', I5)
 1340 FORMAT (//24H INPUT   -  IFIXED(1) = , I6, 9X, ', STP(1) = ',
     +   G15.8, ',    MIT = ',I5, ', STOPSS = ', G15.8, 10H, STOPP = ,
     +   G15.8/13X, 'SCALE(1) = ', G15.8, ',  DELTA = ', G15.8,
     +   ', IVAPRX = ', I5, ',   NPRT = ', I5//)
 1350 FORMAT (//24H OUTPUT  -  IFIXED(1) = , I6, 9X, ', STP(1) = ',
     +   G15.8, ',    MIT = ',I5, ', STOPSS = ', G15.8, 10H, STOPP = ,
     +   G15.8/13X, 'SCALE(1) = ', G15.8, ',  DELTA = ', G15.8,
     +   ', IVAPRX = ', I5, ',   NPRT = ', I5//)
      END
!UFSV
      SUBROUTINE UFSV(ACOV, LAGMAX, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS AND USER SUPPLIED ACVF VALUES (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LAGMAX,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS
      INTEGER
     +   IPRT,ISPCF,LACOV,LDSMIN,LDSTAK,LNLPPA,LPCV,LWORK,LY,NF,
     +   NPRT,NW
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FREQ(101),SPCF(101,4),WORK(101),XAXIS(106),Y(1),YAXIS(106)
      INTEGER
     +   ISORT(101),ISYM(106),LAGS(4),NLPPA(1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PARZEN,UFSDRV
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LAGMAX+1)
!        THE AUTOCOVARIANCE AT LAG ZERO (BIASED VARIANCE).
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISYM(106)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(1)
!        A DUMMY ARRAY FOR SERIES WITHOUT MISSING VALUES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION SPCF(101,4)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     DOUBLE PRECISION WORK(101)
!        THE VECTOR OF LAG WINDOWS.
!     DOUBLE PRECISION XAXIS(106)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION Y(1)
!        A DUMMY ARRAY.
!     DOUBLE PRECISION YAXIS(106)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YMISS
!        A DUMMY VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','V',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(4) = .FALSE.
      OPTION(3) = .TRUE.
      OPTION(2) = .FALSE.
      OPTION(1) = .FALSE.
!
      LDSTAK = 0
      LDSMIN = 0
!
      YMISS = 1.0D0
      LACOV = LAGMAX+1
!
      ISPCF = 101
      LY = 1
      LNLPPA = 1
      LPCV = 106
      LWORK = 101
      NF = 101
!
!     SET NUMBER OF LAG WINDOW TRUNCATION POINTS
!
      NW = 4
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!
      CALL UFSDRV(Y, LY, YMISS, ACOV, NLPPA, SPCF, ISPCF, NF, FMIN,
     +   FMAX, FREQ, N, NW, LAGMAX, LAGS, WORK, LACOV, LWORK, DELTA,
     +   ISORT, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, PARZEN, NMSUB,
     +   LDSMIN, LDSTAK, OPTION, LNLPPA, LY)
!
!     CHECK FOR ERRORS
!
      IF (IERR.EQ.0) RETURN
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL UFSV (ACOV, LAGMAX, N)')
      END
!NLSWDS
      SUBROUTINE NLSWDS (Y, WT, XM, N, M, IXM, MDL, DRV, PAR,
     +   NPAR, RES, LDSTAK, IFIXED, IDRVCK, MIT, STOPSS, STOPP, SCALE,
     +   DELTA, IVAPRX, NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV,
     +   IVCV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING ANALYTIC DERIVATIVES, WEIGHTS, AND
!     USER SUPPLIED CONTROL PARAMETERS, AND WITH COMPUTED VALUES
!     RETURNED TO THE USER.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IVAPRX,IVCV,IXM,LDSTAK,M,MIT,N,NNZW,NPAR,NPARE,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),VCV(*),WT(*),
     +   XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LWT
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTA
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
!        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF IFIXED(I).EQ
!        THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(NPAR)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL STANDARD DEVIATION (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE VARIANCE-COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(N)
!        THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'N',       'L',       'S',       'W',       'D',       'S'/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      WEIGHT = .TRUE.
      SAVE = .TRUE.
!
      LIFIXD = NPAR
      LPV = N
      LSCALE = NPAR
      LSDPV = N
      LSDRES = N
      LWT = N
!
      CALL NLCNTA(Y, WT, LWT, XM, N, M, IXM, MDL, DRV, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, IDRVCK, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSWDS (Y, WT, XM, N, M, IXM, NLSMDL, NLSDRV,'/
     +   '      +             PAR, NPAR, RES, LDSTAK,'/
     +   '      +             IFIXED, IDRVCK, MIT, STOPSS, STOPP,'/
     +   '      +             SCALE, DELTA, IVAPRX, NPRT,'/
     +   '      +             NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV,',
     +   ' IVCV)')
!
      END
!CCFMNM
      SUBROUTINE CCFMNM (Y1, Y1MISS, Y2, Y2MISS, N, LAGMAX, NCC,
     +   CCOV11, CCOV22, CCOV12, CCOV21, ICCOV, NLPP11, NLPP22,
     +   NLPP12, NLPP21, INLPPC, Y1MEAN, Y2MEAN, RHOC, SDRHOC, NPRT,
     +   LAGLST)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING CROSS CORRELATIONS AND
!     THEIR STANDARD ERRORS WHEN MISSING DATA ARE INVOLVED.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   Y1MEAN,Y1MISS,Y2MEAN,Y2MISS
      INTEGER
     +   ICCOV,INLPPC,LAGLST,LAGMAX,N,NCC,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV11(ICCOV),CCOV12(ICCOV),CCOV21(ICCOV),CCOV22(ICCOV),
     +   RHOC(NCC),SDRHOC(NCC),Y1(N),Y2(N)
      INTEGER
     +   NLPP11(INLPPC),NLPP12(INLPPC),NLPP21(INLPPC),
     +   NLPP22(INLPPC)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FAC,FPLM
      INTEGER
     +   I,I0,IM,IP
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CCFSDM,CCVFM
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCOV11(ICCOV), CCOV12(ICCOV)
!     DOUBLE PRECISION CCOV21(ICCOV), CCOV22(ICCOV)
!        THE ARRAY CONTAINING THE AUTOCOVARIANCE AND CROSS COVARIANCE
!        ESTIMATES FOR SERIES 1 AND 2.
!     DOUBLE PRECISION FAC
!        THE INVERSE OF THE SQUARE ROOT OF THE PRODUCT OF THE
!        AUTOCOVARIANCES AT LAG ZERO.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        THE INDEXING VARIABLE FOR THE LAG.
!     INTEGER ICCOV
!        THE DIMENSION OF THE COVARIANCE VECTORS.
!     INTEGER IM
!        THE LOCATIONS IN THE VARIOUS CCF RELATED ARRAYS OF LAG -I.
!     INTEGER INLPPC
!        THE DIMENSION OF THE LAGGED PRODUCT PAIR COUNT VECTORS.
!     INTEGER IP
!        THE LOCATION IF THE VARIOUS CCF RELATED ARRAYS OF LAG I.
!     INTEGER I0
!        THE LOCATION IF THE VARIOUS CCF RELATED ARRAYS OF LAG 0.
!     INTEGER LAGLST
!        THE LAST LAG BEFORE MISSING DATA CAUSED THE ACVF OF EITHER
!        SERIES 1 OR 2 NOT TO BE COMPUTED.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NCC
!        THE NUMBER OF CROSS CORRELATIONS TO BE COMPUTED.
!     INTEGER NLPP11(INLPPC), NLPP12(INLPPC), NLPP21(INLPPC),
!    +        NLPP22(INLPPC)
!        THE NUMBERS OF LAGGED PRODUCT PAIRS USED TO COMPUTE
!        THE AUTOCOVARIANCE AND CROSS COVARIANCE ESTIMATES.
!     INTEGER NPRT
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT.
!     DOUBLE PRECISION RHOC(NCC)
!        THE ARRAY IN WHICH THE AUTO AND CROSS CORRELATIONS ARE STORED
!     DOUBLE PRECISION SDRHOC(NCC)
!        THE ARRAY CONTAINING THE STD. ERRORS OF THE CROSS CORRELATIONS.
!        ARE STORED
!     DOUBLE PRECISION Y1(N), Y1MEAN, Y1MISS
!        THE FIRST SERIES, AND ITS MEAN, AND MISSING VALUE CODE.
!     DOUBLE PRECISION Y2(N), Y2MEAN, Y2MISS
!        THE SECOND SERIES, AND ITS MEAN, AND MISSING VALUE CODE.
!
      FPLM = D1MACH(2)
!
!     COMPUTE AUTOCORRELATIONS AND STANDARD DEVIATION OF THE SERIES.
!
      CALL CCVFM(Y1, Y1MISS, Y2, Y2MISS, N, LAGMAX, Y1MEAN, Y2MEAN,
     +   CCOV12, CCOV21, ICCOV, NLPP12, NLPP21)
!
      IF (NPRT .EQ. 0 .OR. NLPP11(1) .EQ. 0) RETURN
      IF (CCOV11(1) *CCOV22(1) .EQ. 0.0D0) RETURN
!
      FAC = 1.0D0 / SQRT(CCOV11(1) * CCOV22(1))
!
      I0 = LAGMAX + 1
      RHOC(I0) = FPLM
      IF (NLPP12(1).GE.1) RHOC(I0) = CCOV12(1) * FAC
!
      DO 10 I = 1, LAGMAX
         IP = I0 + I
         RHOC(IP) = FPLM
         IF (NLPP12(I+1).GE.1) RHOC(IP) = CCOV12(I+1) * FAC
!
         IM = I0 - I
         RHOC(IM) = FPLM
         IF (NLPP21(I+1).GE.1) RHOC(IM) = CCOV21(I+1) * FAC
   10 CONTINUE
!
!     COMPUTE STANDARD ERROR OF AUTOCORRELATIONS.
!
      CALL CCFSDM (CCOV11, CCOV22, SDRHOC, LAGMAX, NCC, LAGLST, N,
     +   NLPP12, NLPP21, ICCOV, INLPPC)
!
      RETURN
      END
!SVPMC
      SUBROUTINE SVPMC(YM, YMMISS, N, NS, ISYM, ILOG, ISIZE,
     +   IRLIN, IBAR, YLB, YUB, XLB, XINC)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA AND USER CONTROL OF THE PLOT SYMBOL USED
!     (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IRLIN,ISIZE,N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(*)
      INTEGER
     +   ISYM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,ISCHCK,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'V',       'P',       'M',       'C',       ' '/
!
!     SET DEFAULT VALUES
!
      M = 1
      IYM = N
      MULTI = .FALSE.
      ISCHCK = 1
      MISS = .TRUE.
      LISYM = N
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL SVPMC (Y, YMISS, N, NS, ISYM, ILOG,'/
     +  '      +            ISIZE, IRLIN, IBAR, YLB, YUB, XLB, XINC)')
      END
!NLDRVN
      SUBROUTINE NLDRVN (MDL, DRV, DONE, IFIXD, PAR, NPAR, XM, N, M,
     +   IXM, PVT, D, WEIGHT, WT, LWT, STPT, LSTPT, SCL, LSCL)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE NUMERICAL APPROXIMATIONS TO THE
!     DERIVATIVE MATRIX (JACOBIAN).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LSCL,LSTPT,LWT,M,N,NPAR
      LOGICAL
     +   DONE,WEIGHT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PAR(NPAR),PVT(N),SCL(LSCL),STPT(LSTPT),WT(LWT),
     +   XM(IXM,M)
      INTEGER
     +   IFIXD(NPAR)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   PJ,STPJ,WTSQRT
      INTEGER
     +   I,J,JPK
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,SIGN,SQRT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION D(N,NPAR)
!        THE FIRST DERIVATIVE OF THE MODEL (JACOBIAN).
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     LOGICAL DONE
!        THE VARIABLE USED TO INDICATE WHETHER THIS IS THE FINAL
!        COMPUTATION OF THE JACOBIAN OR NOT.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IXM
!        THE FIRST DIMENSION OF MATRIX XM.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER JPK
!        AN INDEX VARIABLE.
!     INTEGER LSCL
!        THE DIMENSION OF VECTOR SCL.
!     INTEGER LSTPT
!        THE DIMENSION OF VECTOR STPT.
!     INTEGER LWT
!        THE DIMENSION OF VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PJ
!        A TEMPORARY LOCATION FOR STORAGE OF THE JTH PARAMETER.
!     DOUBLE PRECISION PVT(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
!     DOUBLE PRECISION SCL(LSCL)
!        THE SCALE VALUES.
!     DOUBLE PRECISION STPT(LSTPT)
!        THE STEP SIZE ARRAY.
!     DOUBLE PRECISION STPJ
!        THE JTH STEP SIZE.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION WTSQRT
!        THE SQUARE ROOT OF THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!
!     COMPUTE FINITE-DIFFERENCE JACOBIAN OF THE OPTIMIZED PARAMETERS
!
      JPK = 0
!
      DO 20 J=1,NPAR
         IF (IFIXD(J).EQ.0) THEN
            JPK = JPK + 1
            PJ = PAR(J)
            IF (SCL(JPK).EQ.0.0D0) THEN
               IF (PAR(J).NE.0.0D0) THEN
                  STPJ = STPT(J)*SIGN(1.0D0,PAR(J))*ABS(PAR(J))
               ELSE
                  STPJ = STPT(J)
               END IF
            ELSE
               STPJ = STPT(J)*
     +                SIGN(1.0D0,PAR(J))*MAX(ABS(PAR(J)),1.0D0/
     +                ABS(SCL(JPK)))
            END IF
!
            STPJ = STPJ + PAR(J)
            STPJ = STPJ - PAR(J)
!
            PAR(J) = PJ + STPJ
            CALL MDL(PAR, NPAR, XM, N, M, IXM, D(1,J))
!
            DO 10 I=1,N
               WTSQRT = 1.0D0
               IF (WEIGHT .AND. (.NOT.DONE)) WTSQRT = SQRT(WT(I))
               D(I,JPK) = WTSQRT*(PVT(I)-D(I,J))/STPJ
   10       CONTINUE
!
            PAR(J) = PJ
         END IF
   20 CONTINUE
!
      RETURN
!
      END
!VPMN
      SUBROUTINE VPMN (YM, YMMISS, N, M, IYM, NSAMPL, ISCHCK, ISYM,
     +  LISYM, ISIZE, YMN, YMX, XLB, XINC, MISS, ILOG, IRLIN, IBAR)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES VERTICAL PLOTS
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XINC,XLB,YMN,YMX
      INTEGER
     +   IBAR,ILOG,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M,N,NSAMPL
      LOGICAL
     +   MISS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(IYM,M),YMMISS(M)
      INTEGER
     +   ISYM(LISYM)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   REFPT,XLABEL,YDMN,YDMX,YWIDTH,YY
      INTEGER
     +   I,IEND,ILOGY,IMAX,IMIN,IPOINT,IPRT,IPTSYM,IREFPT,J,NUMCOL,
     +   NUSED
      LOGICAL
     +   IFMISS
      CHARACTER
     +   I0*1,IBLANK*1,IM*1,IPLTCH*1,IREFCH*1,FMT*72
!
!  LOCAL ARRAYS
      INTEGER
     +   ICOUNT(103)
      CHARACTER
     +   LINE(103)*1
!
!  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN,AMEANM,IPRINT,PLINE,PLTPLX,PLTSYM,SETIV,VPHEAD
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG10,MAX,MIN
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     CHARACTER FMT*72
!        THE FORMAT FOR THE X-AXIS LABELS
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     CHARACTER*1 IBLANK
!        THE PLOT SYMBOL BLANK.
!     INTEGER ICOUNT(103)
!        THE NUMBER OF PLOT SYMBOLS AT EACH LOCATION.
!     INTEGER IEND
!        THE NUMBER OF LOCATIONS IN THE PLOT STRING.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     LOGICAL IFMISS
!        THE INDICATOR VARIABLE USED TO DETERMINE WHETHER THE
!        INPUT SERIES HAS MISSING DATA (TRUE) OR NOT (FALSE).
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER ILOGY
!        THE VALUE OF Q (SEE ILOG).
!     CHARACTER*1 IM
!        THE PLOT SYMBOL M.
!     INTEGER IMAX
!        THE LARGEST LOCATION IN THE PLOT STRING BEING DEFINED.
!     INTEGER IMIN
!        THE SMALLEST LOCATION IN THE PLOT STRING BEING DEFINED.
!     CHARACTER*1 IPLTCH
!        THE PLOT CHARACTER USED FOR A GIVEN LINE OF THE PLOT.
!     INTEGER IPOINT
!        THE LOCATION IN THE PLOT STRING OF THE VALUE BEING PLOTTED.
!     INTEGER IPRT
!        *
!     INTEGER IPTSYM
!        AN INDICATOR VARIABLE USED TO DESIGNATE THE TYPE
!        OF PLOT.  IF ISCHCK = 1, THE PLOT IS A SYMPLE PAGE
!        OR VERTICAL PLOT.  IF ISCHCK = 2, THE PLOT IS A SYMBOL
!        PLOT.  IF ISCHCK = 3, THE PLOT IS A MULTIVARIATE PLOT.
!     CHARACTER*1 IREFCH
!        THE PLOT SYMBOL USED TO IDENTIFY THE PLOT REFERENCE LINE.
!     INTEGER IREFPT
!        THE LOCATION IN THE PLOT STRING FOR THE VALUE ZERO, OR
!        SERIES MEAN, WHICH EVER WAS REQUESTED.
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(LISYM)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE EXACT VALUE OF THE FIRST DIMENSION OF THE MATRIX YM.
!     CHARACTER*1 I0
!        THE PLOT SYMBOL -0-.
!     INTEGER J
!        AN INDEX VARIABLE.
!     CHARACTER*1 LINE(103)
!        THE VECTOR USED FOR THE PLOT STRING.
!     INTEGER LISYM
!        *
!     INTEGER M
!        THE NUMBER OF COLUMNS OF DATA IN YM.
!     LOGICAL MISS
!        *
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS .
!     INTEGER NSAMPL
!        THE SAMPLING FREQUENCY ACTUALLY USED.
!     INTEGER NUMCOL
!        *
!     INTEGER NUSED
!        THE NUMBER OF ACTIVE OBSERVATIONS.
!     DOUBLE PRECISION REFPT
!        THE VALUE ZERO, OR THE MEAN OF THE SERIES, WHICH EVER IS
!        REQUESTED, USED AS A PLOT REFERENCE LINE.
!     DOUBLE PRECISION XINC
!        THE VARIABLE USED TO SPECIFY THE INCREMENT FOR XLABEL.
!     DOUBLE PRECISION XLABEL
!        THE VALUE USED FOR THE LABELS ON THE RIGHT SIDE OF THE PLOT.
!     DOUBLE PRECISION XLB
!        THE STARTING VALUE FOR LABELS ON THE RIGHT SIDE OF THE GRAPH.
!     DOUBLE PRECISION YDMN, YDMX
!        THE Y-AXIS DATA LIMITS ACTUALLY USED.
!     DOUBLE PRECISION YM(IYM,M)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     DOUBLE PRECISION YMMISS(M)
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF YM(I) = YMMISS
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!     DOUBLE PRECISION YMN, YMX
!        THE GRAPH AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
!     DOUBLE PRECISION YWIDTH
!        THE SCALE INTERVAL OF THE PLOT.
!     DOUBLE PRECISION YY
!        THE VALUE OF YM ACTUALLY BEING PLOTTED
!
!
      DATA IBLANK/' '/, IM/'M'/, I0/'0'/
!
!     PRINT PLOT HEADINGS
!
      CALL IPRINT(IPRT)
      CALL VPHEAD(NSAMPL, IRLIN, IBAR,
     +            REFPT, YWIDTH, YMN, YMX, ISIZE, ILOG,
     +            LINE, NUMCOL, ILOGY, YDMN, YDMX)
      IEND = NUMCOL + 2
!
!     COMPUTE REFERENCE POINT OF GRAPH, IF REQUIRED.
!
      IF (IRLIN.GE.0) THEN
        IF (IRLIN.EQ.0) THEN
!
!         REFERENCE POINT IS ZERO
!
          REFPT = 0.0D0
          IREFCH = I0
        ELSE
!
!         REFERENCE POINT IS MEAN
!
          IF (MISS) THEN
            CALL AMEANM(YM, YMMISS, N, NUSED, REFPT)
          ELSE
            CALL AMEAN(YM, N, REFPT)
          END IF
          IF (ILOGY.NE.0) REFPT = LOG10(REFPT)
          IREFCH = IM
        END IF
!
!       COMPUTE LOCATION OF REFPT IN PLOT STRING
!
        CALL PLTPLX(REFPT, YMN, YWIDTH, IREFPT, IEND)
      ELSE
        IREFPT = 1
      END IF
!
!     BEGIN PLOTTING
!
      IPTSYM = ISCHCK + 1
      XLABEL = XLB
      DO 50 I=1,N,NSAMPL
         CALL PLINE(1, IEND, IBLANK, LINE)
         CALL SETIV(ICOUNT, IEND, 0)
         IFMISS = .FALSE.
         IPOINT = 1
         DO 30 J=1,M
           IF (MISS) THEN
             IFMISS = (IFMISS .OR. (MVCHK(YM(I,J),YMMISS(J))))
             IF (.NOT.(MVCHK(YM(I,J),YMMISS(J)))) THEN
               IF (ILOGY.EQ.0) THEN
                 YY = YM(I,J)
               ELSE
                 YY = LOG10(YM(I,J))
               END IF
               IF ((YY.GE.YDMN) .AND. (YY.LE.YDMX)) THEN
                CALL PLTPLX(YY, YMN, YWIDTH, IPOINT, IEND)
                CALL PLTSYM(IPTSYM, I, J, ISYM, N, IPOINT, LINE, ICOUNT)
                IPLTCH = LINE(IPOINT)
               ELSE
                IPOINT = IREFPT
                IPLTCH = IBLANK
               END IF
             END IF
           ELSE
             IF (ILOGY.EQ.0) THEN
               YY = YM(I,J)
             ELSE
               YY = LOG10(YM(I,J))
             END IF
             IF ((YY.GE.YDMN) .AND. (YY.LE. YDMX)) THEN
                CALL PLTPLX(YY, YMN, YWIDTH, IPOINT, IEND)
                CALL PLTSYM(IPTSYM, I, J, ISYM, N, IPOINT, LINE, ICOUNT)
                IPLTCH = LINE(IPOINT)
             ELSE
                IPOINT = IREFPT
                IPLTCH = IBLANK
             END IF
           END IF
   30    CONTINUE
         IF ((IBAR.GE.1) .AND. (.NOT.IFMISS)) THEN
            IMIN = MIN(IPOINT,IREFPT)
            IMAX = MAX(IPOINT,IREFPT)
            CALL PLINE(IMIN, IMAX, IPLTCH, LINE)
         ELSE IF (IRLIN.GE.0) THEN
            LINE(IREFPT) = IREFCH
         END IF
!
         IF (IFMISS) THEN
           WRITE(FMT,1000) NUMCOL, '8H MISSING'
           WRITE(IPRT,FMT) XLABEL, (LINE(J), J=1,IEND)
         ELSE
           WRITE(FMT,1000) NUMCOL, '1X, G11.5 '
           IF (M.EQ.1) THEN
             WRITE(IPRT,FMT) XLABEL, (LINE(J),J=1,IEND), YM(I,1)
           ELSE
             WRITE(IPRT,FMT) XLABEL, (LINE(J),J=1,IEND)
           END IF
         END IF
         XLABEL = XLABEL + XINC*NSAMPL
   50 CONTINUE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT('(1X,G11.5,1X,A1,''I'',', I3, 'A1,''I'',A1,',A10,')')
      END
!MDL2
      SUBROUTINE MDL2(PAR, NPAR, XM, N, M, IXM, PV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     MODEL FUNCTION FOR NLS EXERCISER
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PV(N),XM(IXM,M)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        ROW INDEX
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     INTEGER M
!        NUMBER OF VARIABLES
!     INTEGER N
!        NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        NUMBER OF PARAMETERS
!     DOUBLE PRECISION PAR(NPAR)
!        MODEL PARAMETERS
!     DOUBLE PRECISION PV(N)
!        PREDICTED VALUES
!     DOUBLE PRECISION XM(IXM,M)
!        INDEPENDENT VARIABLES
!
      DO 10 I=1,N
         PV(I) = PAR(1)*XM(I,1) + PAR(2)*XM(I,2) + PAR(3)*XM(I,3)**3
   10 CONTINUE
      RETURN
      END
!XXCH12
      SUBROUTINE XXCH12(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE TIME SERIES CORRELATION AND SPECTRUM ANALYSIS
!     FAMILY OF ROUTINES.
!
!     DATA FOR ACF IS TAKEN FROM P. 362 OF JENKINS AND WATTS [1968]
!     DATA FOR CCF IS TAKEN FROM P. 361 OF JENKINS AND WATTS [1968]
!     DATA FOR UFS IS TAKEN FROM P. 318 OF JENKINS AND WATTS [1968]
!     DATA FOR UAS IS TAKEN FROM P. 318 OF JENKINS AND WATTS [1968]
!     DATA FOR TAPER, PGMS, MDFLT AND PPL IS
!           THE WOLF SUNSPOT NUMBERS FOR THE YEARS 1700 TO 1960 AS
!           TABULATED BY WALDMEIER [1961].
!     DATA FOR BFS IS TAKEN FROM PP. 387-388 OF JENKINS AND WATTS [1968]
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   TAPERP
      INTEGER
     +   IEXTND,ILOG,IPRT,LFREQ,LPER,LYFFT,NF,NFFT,NK,NPRT,NY1,NY2,
     +   NY3,NY4,NY5,NY6
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   FREQ(300),PER(300),PERF(300),Y1(100),Y2A(100),Y2B(100),
     +   Y3(50),Y4(50),Y5(300),Y6A(100),Y6B(100),YFFT(600)
      INTEGER
     +   KMD(10)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACF,BFS,CCF,IPRINT,MDFLT,PGMS,PPL,TAPER,UAS,UFS
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (Y3(1),Y4(1))
      EQUIVALENCE (Y2A(1),Y6A(1))
      EQUIVALENCE (Y2B(1),Y6B(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FREQ(300)
!        THE FREQUENCIES AT WHICH THE PERIODOGRAM IS COMPUTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER IEXTND
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE USED TO EXTEND THE SERIES.
!     INTEGER ILOG
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE PLOT IS
!        TO HAVE LOGARITHMIC AXIS OR NOT.
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER KMD(10)
!        THE VECTOR OF MODIFIED DANIEL FILTER LENGTHS.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER LFREQ
!        THE LENGTH OF VECTOR FREQ.
!     INTEGER LPER
!        THE LENGTH OF VECTOR PER.
!     INTEGER LYFFT
!        THE LENGTH OF VECTOR YFFT.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES.
!     INTEGER NFFT
!        THE EXTENDED SERIES LENGTH FOR THE FFT.
!     INTEGER NK
!        THE NUMBER OF DANIEL FILTERS TO APPLY.
!     INTEGER NPRT
!        THE PRINT CONTROL VARIABLE.
!     INTEGER NY1, NY2, NY3, NY4, NY5, NY6
!        THE NUMBER OF OBSERVATIONS.
!     DOUBLE PRECISION PER(300)
!        THE PERIODOGRAM.
!     DOUBLE PRECISION PERF(300)
!        THE FILTERED PERIODOGRAM.
!     DOUBLE PRECISION TAPERP
!        THE PERCENTAGE OF THE SERIES TO BE TAPERED.
!     DOUBLE PRECISION YFFT(600)
!        AN ARRAY FOR THE FFT COMPUTATIONS.
!     DOUBLE PRECISION Y1(100)
!        THE DATA FROM PAGE 362 OF JENKINS AND WATTS.
!     DOUBLE PRECISION Y2A(100), Y2B(100)
!        THE DATA FROM PAGE 361 OF JENKINS AND WATTS.
!     DOUBLE PRECISION Y3(50), Y4(50)
!        THE DATA FROM PAGE 318 OF JENKINS AND WATTS.
!     DOUBLE PRECISION Y5(300)
!        THE WOLF SUNSPOT DATA.
!     DOUBLE PRECISION Y6A(100), Y6B(100)
!        THE DATA FROM PAGE 387 AND 388 OF JENKINS AND WATTS.
!
!
      DATA   Y1(  1),  Y1(  2),  Y1(  3),  Y1(  4),  Y1(  5),  Y1(  6)
     +    / -2.07D0, -1.15D0,  0.69D0, -0.46D0, -1.49D0, -0.70D0/
      DATA   Y1(  7),  Y1(  8),  Y1(  9),  Y1( 10),  Y1( 11),  Y1( 12)
     +    / -1.07D0, -0.69D0, -0.68D0,  1.27D0, -1.05D0, -0.05D0/
      DATA   Y1( 13),  Y1( 14),  Y1( 15),  Y1( 16),  Y1( 17),  Y1( 18)
     +    / -0.84D0, -0.62D0, -0.49D0, -1.29D0, -0.49D0, -1.06D0/
      DATA   Y1( 19),  Y1( 20),  Y1( 21),  Y1( 22),  Y1( 23),  Y1( 24)
     +    / -0.38D0, -0.52D0, -0.13D0,  1.30D0, -1.51D0, -0.43D0/
      DATA   Y1( 25),  Y1( 26),  Y1( 27),  Y1( 28),  Y1( 29),  Y1( 30)
     +    / -1.33D0, -0.78D0,  0.31D0, -0.95D0, -0.90D0, -0.30D0/
      DATA   Y1( 31),  Y1( 32),  Y1( 33),  Y1( 34),  Y1( 35),  Y1( 36)
     +    / -1.02D0, -0.53D0,  0.15D0,  1.40D0,  1.22D0,  0.59D0/
      DATA   Y1( 37),  Y1( 38),  Y1( 39),  Y1( 40),  Y1( 41),  Y1( 42)
     +    /  0.70D0,  1.70D0,  2.78D0,  1.98D0,  1.39D0,  1.85D0/
      DATA   Y1( 43),  Y1( 44),  Y1( 45),  Y1( 46),  Y1( 47),  Y1( 48)
     +    /  2.60D0,  0.51D0,  2.77D0,  1.16D0,  1.07D0, -0.48D0/
      DATA   Y1( 49),  Y1( 50),  Y1( 51),  Y1( 52),  Y1( 53),  Y1( 54)
     +    / -0.52D0,  0.37D0,  0.00D0, -1.99D0, -1.75D0,  0.70D0/
      DATA   Y1( 55),  Y1( 56),  Y1( 57),  Y1( 58),  Y1( 59),  Y1( 60)
     +    /  0.73D0,  1.16D0,  0.06D0, -0.02D0,  1.10D0, -0.35D0/
      DATA   Y1( 61),  Y1( 62),  Y1( 63),  Y1( 64),  Y1( 65),  Y1( 66)
     +    / -1.67D0, -1.57D0,  1.16D0,  1.84D0,  3.35D0,  0.40D0/
      DATA   Y1( 67),  Y1( 68),  Y1( 69),  Y1( 70),  Y1( 71),  Y1( 72)
     +    /  0.45D0,  1.30D0,  0.93D0,  1.17D0, -1.74D0, -1.28D0/
      DATA   Y1( 73),  Y1( 74),  Y1( 75),  Y1( 76),  Y1( 77),  Y1( 78)
     +    / -0.07D0,  1.50D0,  0.53D0,  0.20D0, -0.42D0,  1.18D0/
      DATA   Y1( 79),  Y1( 80),  Y1( 81),  Y1( 82),  Y1( 83),  Y1( 84)
     +    /  0.82D0,  1.50D0,  2.92D0,  1.18D0,  1.23D0,  3.16D0/
      DATA   Y1( 85),  Y1( 86),  Y1( 87),  Y1( 88),  Y1( 89),  Y1( 90)
     +    /  0.79D0,  0.68D0,  1.14D0,  1.02D0,  1.02D0, -0.71D0/
      DATA   Y1( 91),  Y1( 92),  Y1( 93),  Y1( 94),  Y1( 95),  Y1( 96)
     +    / -0.17D0, -1.50D0, -0.26D0, -0.38D0,  0.93D0, -0.33D0/
      DATA   Y1( 97),  Y1( 98),  Y1( 99),  Y1(100)
     +    / -1.12D0, -2.95D0, -2.09D0, -1.11D0                    /
!
      DATA  Y2A(  1), Y2A(  2), Y2A(  3), Y2A(  4), Y2A(  5), Y2A(  6)
     +    /-0.88D0, -0.16D0, -1.87D0, -1.12D0,  1.38D0,  2.13D0/
      DATA  Y2A(  7), Y2A(  8), Y2A(  9), Y2A( 10), Y2A( 11), Y2A( 12)
     +    / 2.76D0,  0.56D0, -0.69D0, -1.79D0, -3.82D0, -2.38D0/
      DATA  Y2A( 13), Y2A( 14), Y2A( 15), Y2A( 16), Y2A( 17), Y2A( 18)
     +    / 1.00D0,  0.70D0, -0.15D0,  0.98D0,  0.11D0, -0.35D0/
      DATA  Y2A( 19), Y2A( 20), Y2A( 21), Y2A( 22), Y2A( 23), Y2A( 24)
     +    /-0.73D0,  0.89D0, -1.63D0, -0.44D0, -1.37D0, -1.71D0/
      DATA  Y2A( 25), Y2A( 26), Y2A( 27), Y2A( 28), Y2A( 29), Y2A( 30)
     +    /-1.22D0, -2.00D0, -0.22D0,  0.38D0,  1.31D0,  0.71D0/
      DATA  Y2A( 31), Y2A( 32), Y2A( 33), Y2A( 34), Y2A( 35), Y2A( 36)
     +    / 0.32D0,  0.48D0, -1.88D0, -0.94D0, -1.54D0, -0.13D0/
      DATA  Y2A( 37), Y2A( 38), Y2A( 39), Y2A( 40), Y2A( 41), Y2A( 42)
     +    / 1.02D0,  0.02D0, -0.77D0,  0.11D0, -0.60D0, -0.52D0/
      DATA  Y2A( 43), Y2A( 44), Y2A( 45), Y2A( 46), Y2A( 47), Y2A( 48)
     +    /-0.09D0,  1.23D0,  1.46D0,  0.61D0,  0.42D0,  2.16D0/
      DATA  Y2A( 49), Y2A( 50), Y2A( 51), Y2A( 52), Y2A( 53), Y2A( 54)
     +    / 3.18D0,  2.10D0,  0.37D0, -0.24D0,  0.57D0, -0.53D0/
      DATA  Y2A( 55), Y2A( 56), Y2A( 57), Y2A( 58), Y2A( 59), Y2A( 60)
     +    / 2.44D0,  1.02D0, -0.53D0, -2.49D0, -2.12D0, -1.04D0/
      DATA  Y2A( 61), Y2A( 62), Y2A( 63), Y2A( 64), Y2A( 65), Y2A( 66)
     +    /-0.12D0, -1.88D0, -1.50D0,  1.54D0,  3.33D0,  3.08D0/
      DATA  Y2A( 67), Y2A( 68), Y2A( 69), Y2A( 70), Y2A( 71), Y2A( 72)
     +    / 1.71D0,  0.79D0,  1.55D0,  0.89D0, -0.89D0, -1.18D0/
      DATA  Y2A( 73), Y2A( 74), Y2A( 75), Y2A( 76), Y2A( 77), Y2A( 78)
     +    / 0.89D0,  1.71D0,  3.05D0,  0.15D0, -1.04D0,  0.12D0/
      DATA  Y2A( 79), Y2A( 80), Y2A( 81), Y2A( 82), Y2A( 83), Y2A( 84)
     +    / 0.08D0,  0.11D0, -2.62D0, -1.28D0,  1.07D0,  3.20D0/
      DATA  Y2A( 85), Y2A( 86), Y2A( 87), Y2A( 88), Y2A( 89), Y2A( 90)
     +    / 1.92D0,  0.53D0, -1.08D0,  0.49D0, -0.58D0,  0.17D0/
      DATA  Y2A( 91), Y2A( 92), Y2A( 93), Y2A( 94), Y2A( 95), Y2A( 96)
     +    / 1.15D0, -0.97D0, -1.63D0,  1.14D0, -0.67D0, -0.88D0/
      DATA  Y2A( 97), Y2A( 98), Y2A( 99), Y2A(100)
     +    /-0.07D0,  0.24D0,  0.55D0, -2.16D0/
!
      DATA  Y2B(  1), Y2B(  2), Y2B(  3), Y2B(  4), Y2B(  5), Y2B(  6)
     +    / 0.79D0,  1.12D0, -1.10D0, -2.39D0, -1.75D0, -0.82D0/
      DATA  Y2B(  7), Y2B(  8), Y2B(  9), Y2B( 10), Y2B( 11), Y2B( 12)
     +    /-0.36D0,  1.27D0,  1.75D0,  2.44D0,  0.36D0, -2.10D0/
      DATA  Y2B( 13), Y2B( 14), Y2B( 15), Y2B( 16), Y2B( 17), Y2B( 18)
     +    /-1.93D0, -1.30D0, -1.75D0, -0.34D0,  0.74D0,  0.49D0/
      DATA  Y2B( 19), Y2B( 20), Y2B( 21), Y2B( 22), Y2B( 23), Y2B( 24)
     +    / 0.70D0,  0.71D0,  0.09D0,  0.59D0,  1.54D0,  0.14D0/
      DATA  Y2B( 25), Y2B( 26), Y2B( 27), Y2B( 28), Y2B( 29), Y2B( 30)
     +    / 0.55D0, -1.40D0, -2.55D0, -1.66D0, -0.43D0,  0.58D0/
      DATA  Y2B( 31), Y2B( 32), Y2B( 33), Y2B( 34), Y2B( 35), Y2B( 36)
     +    / 2.18D0, -0.24D0,  0.58D0, -0.18D0, -1.55D0, -0.64D0/
      DATA  Y2B( 37), Y2B( 38), Y2B( 39), Y2B( 40), Y2B( 41), Y2B( 42)
     +    /-1.09D0,  0.90D0, -0.66D0, -0.35D0,  0.48D0,  0.50D0/
      DATA  Y2B( 43), Y2B( 44), Y2B( 45), Y2B( 46), Y2B( 47), Y2B( 48)
     +    / 0.05D0, -0.68D0,  0.24D0,  0.58D0, -1.26D0, -0.25D0/
      DATA  Y2B( 49), Y2B( 50), Y2B( 51), Y2B( 52), Y2B( 53), Y2B( 54)
     +    / 0.25D0,  2.18D0,  2.96D0,  1.56D0, -0.36D0, -0.59D0/
      DATA  Y2B( 55), Y2B( 56), Y2B( 57), Y2B( 58), Y2B( 59), Y2B( 60)
     +    /-0.12D0,  3.03D0,  2.11D0,  0.78D0,  0.89D0, -1.45D0/
      DATA  Y2B( 61), Y2B( 62), Y2B( 63), Y2B( 64), Y2B( 65), Y2B( 66)
     +    /-0.36D0, -0.37D0, -1.39D0, -4.19D0, -0.73D0, -0.98D0/
      DATA  Y2B( 67), Y2B( 68), Y2B( 69), Y2B( 70), Y2B( 71), Y2B( 72)
     +    / 0.36D0,  0.06D0, -1.94D0, -0.08D0,  0.17D0,  1.00D0/
      DATA  Y2B( 73), Y2B( 74), Y2B( 75), Y2B( 76), Y2B( 77), Y2B( 78)
     +    /-0.05D0,  0.43D0,  0.15D0,  2.69D0,  0.57D0,  0.29D0/
      DATA  Y2B( 79), Y2B( 80), Y2B( 81), Y2B( 82), Y2B( 83), Y2B( 84)
     +    / 1.10D0,  0.48D0, -1.06D0, -2.28D0, -2.03D0, -0.75D0/
      DATA  Y2B( 85), Y2B( 86), Y2B( 87), Y2B( 88), Y2B( 89), Y2B( 90)
     +    / 1.00D0,  1.71D0,  0.58D0,  1.97D0,  0.99D0,  1.94D0/
      DATA  Y2B( 91), Y2B( 92), Y2B( 93), Y2B( 94), Y2B( 95), Y2B( 96)
     +    / 2.18D0,  3.14D0,  0.60D0,  0.51D0,  1.35D0,  0.56D0/
      DATA  Y2B( 97), Y2B( 98), Y2B( 99), Y2B(100)
     +    / 0.11D0,  0.00D0,  2.34D0,  1.88D0/
!
      DATA  Y3(  1),Y3(  2),Y3(  3),Y3(  4),Y3(  5),Y3(  6)
     +    /-0.88D0, -0.12D0, -0.89D0, -1.38D0, -0.07D0,  1.03D0/
      DATA  Y3(  7),Y3(  8),Y3(  9),Y3( 10),Y3( 11),Y3( 12)
     +    / 2.14D0,  0.35D0, -1.10D0, -1.78D0, -2.76D0, -1.77D0/
      DATA  Y3( 13),Y3( 14),Y3( 15),Y3( 16),Y3( 17),Y3( 18)
     +    / 0.98D0,  1.00D0, -0.70D0, -1.01D0, -1.30D0, -0.85D0/
      DATA  Y3( 19),Y3( 20),Y3( 21),Y3( 22),Y3( 23),Y3( 24)
     +    /-0.46D0,  1.63D0,  0.06D0, -0.17D0, -1.01D0, -1.04D0/
      DATA  Y3( 25),Y3( 26),Y3( 27),Y3( 28),Y3( 29),Y3( 30)
     +    /-0.66D0, -1.12D0, -0.51D0, -0.71D0, -0.20D0, -0.13D0/
      DATA  Y3( 31),Y3( 32),Y3( 33),Y3( 34),Y3( 35),Y3( 36)
     +    / 0.14D0,  1.59D0, -0.76D0, -1.08D0, -1.77D0, -1.20D0/
      DATA  Y3( 37),Y3( 38),Y3( 39),Y3( 40),Y3( 41),Y3( 42)
     +    / 0.45D0, -0.07D0, -0.63D0, -0.35D0, -0.87D0, -0.62D0/
      DATA  Y3( 43),Y3( 44),Y3( 45),Y3( 46),Y3( 47),Y3( 48)
     +    / 0.28D0,  1.90D0,  2.14D0,  1.05D0,  0.31D0,  1.07D0/
      DATA  Y3( 49),Y3( 50)
     +    / 2.67D0,  2.44D0/
!
      DATA  Y5(  1), Y5(  2), Y5(  3), Y5(  4), Y5(  5), Y5(  6)
     +    /     5.0D0, 11.0D0, 16.0D0, 23.0D0, 36.0D0, 58.0D0/
      DATA  Y5(  7), Y5(  8), Y5(  9), Y5( 10), Y5( 11), Y5( 12)
     +    /    29.0D0, 20.0D0, 10.0D0,  8.0D0,  3.0D0,  0.0D0/
      DATA  Y5( 13), Y5( 14), Y5( 15), Y5( 16), Y5( 17), Y5( 18)
     +    /     0.0D0, 2.0D0, 11.0D0, 27.0D0, 47.0D0, 63.0D0/
      DATA  Y5( 19), Y5( 20), Y5( 21), Y5( 22), Y5( 23), Y5( 24)
     +    /    60.0D0, 39.0D0, 28.0D0, 26.0D0, 22.0D0, 11.0D0/
      DATA  Y5( 25), Y5( 26), Y5( 27), Y5( 28), Y5( 29), Y5( 30)
     +    /    21.0D0, 40.0D0, 78.0D0,122.0D0,103.0D0, 73.0D0/
      DATA  Y5( 31), Y5( 32), Y5( 33), Y5( 34), Y5( 35), Y5( 36)
     +    /    47.0D0, 35.0D0, 11.0D0,  5.0D0, 16.0D0, 34.0D0/
      DATA  Y5( 37), Y5( 38), Y5( 39), Y5( 40), Y5( 41), Y5( 42)
     +    /    70.0D0, 81.0D0,111.0D0,101.0D0, 73.0D0, 40.0D0/
      DATA  Y5( 43), Y5( 44), Y5( 45), Y5( 46), Y5( 47), Y5( 48)
     +    /    20.0D0, 16.0D0,  5.0D0, 11.0D0, 22.0D0, 40.0D0/
      DATA  Y5( 49), Y5( 50), Y5( 51), Y5( 52), Y5( 53), Y5( 54)
     +    /    60.0D0, 80.9D0, 83.4D0, 47.7D0, 47.8D0, 30.7D0/
      DATA  Y5( 55), Y5( 56), Y5( 57), Y5( 58), Y5( 59), Y5( 60)
     +    /    12.2D0,  9.6D0, 10.2D0, 32.4D0, 47.6D0, 54.0D0/
      DATA  Y5( 61), Y5( 62), Y5( 63), Y5( 64), Y5( 65), Y5( 66)
     +    /    62.9D0, 85.9D0, 61.2D0, 45.1D0, 36.4D0, 20.9D0/
      DATA  Y5( 67), Y5( 68), Y5( 69), Y5( 70), Y5( 71), Y5( 72)
     +    /    11.4D0, 37.8D0, 69.8D0,106.1D0,100.8D0, 81.6D0/
      DATA  Y5( 73), Y5( 74), Y5( 75), Y5( 76), Y5( 77), Y5( 78)
     +    /    66.5D0, 34.8D0, 30.6D0,  7.0D0, 19.8D0, 92.5D0/
      DATA  Y5( 79), Y5( 80), Y5( 81), Y5( 82), Y5( 83), Y5( 84)
     +    /   154.4D0,125.9D0, 84.8D0, 68.1D0, 38.5D0, 22.8D0/
      DATA  Y5( 85), Y5( 86), Y5( 87), Y5( 88), Y5( 89), Y5( 90)
     +    /    10.2D0, 24.1D0, 82.9D0,132.0D0,130.9D0,118.1D0/
      DATA  Y5( 91), Y5( 92), Y5( 93), Y5( 94), Y5( 95), Y5( 96)
     +    /    89.9D0, 66.6D0, 60.0D0, 46.9D0, 41.0D0, 21.3D0/
      DATA  Y5( 97), Y5( 98), Y5( 99), Y5(100), Y5(101), Y5(102)
     +    /    16.0D0,  6.4D0,  4.1D0,  6.8D0, 14.5D0, 34.0D0/
      DATA  Y5(103), Y5(104), Y5(105), Y5(106), Y5(107), Y5(108)
     +    /    45.0D0, 43.1D0, 47.5D0, 42.2D0, 28.1D0, 10.1D0/
      DATA  Y5(109), Y5(110), Y5(111), Y5(112), Y5(113), Y5(114)
     +    /     8.1D0,  2.5D0,  0.0D0,  1.4D0,  5.0D0, 12.2D0/
      DATA  Y5(115), Y5(116), Y5(117), Y5(118), Y5(119), Y5(120)
     +    /    13.9D0, 35.4D0, 45.8D0, 41.1D0, 30.1D0, 23.9D0/
      DATA  Y5(121), Y5(122), Y5(123), Y5(124), Y5(125), Y5(126)
     +    /    15.6D0,  6.6D0,  4.0D0,  1.8D0,  8.5D0, 16.6D0/
      DATA  Y5(127), Y5(128), Y5(129), Y5(130), Y5(131), Y5(132)
     +    /    36.3D0, 49.6D0, 64.2D0, 67.0D0, 70.9D0, 47.8D0/
      DATA  Y5(133), Y5(134), Y5(135), Y5(136), Y5(137), Y5(138)
     +    /    27.5D0,  8.5D0, 13.2D0, 56.9D0,121.5D0,138.3D0/
      DATA  Y5(139), Y5(140), Y5(141), Y5(142), Y5(143), Y5(144)
     +    /   103.2D0, 85.7D0, 64.6D0, 36.7D0, 24.2D0, 10.7D0/
      DATA  Y5(145), Y5(146), Y5(147), Y5(148), Y5(149), Y5(150)
     +    /    15.0D0, 40.1D0, 61.5D0, 98.5D0,124.7D0, 96.3D0/
      DATA  Y5(151), Y5(152), Y5(153), Y5(154), Y5(155), Y5(156)
     +    /    66.6D0, 64.5D0, 54.1D0, 39.0D0, 20.6D0,  6.7D0/
      DATA  Y5(157), Y5(158), Y5(159), Y5(160), Y5(161), Y5(162)
     +    /     4.3D0, 22.7D0, 54.8D0, 93.8D0, 95.8D0, 77.2D0/
      DATA  Y5(163), Y5(164), Y5(165), Y5(166), Y5(167), Y5(168)
     +    /    59.1D0, 44.0D0, 47.0D0, 30.5D0, 16.3D0,  7.3D0/
      DATA  Y5(169), Y5(170), Y5(171), Y5(172), Y5(173), Y5(174)
     +    /    37.6D0, 74.0D0,139.0D0,111.2D0,101.6D0, 66.2D0/
      DATA  Y5(175), Y5(176), Y5(177), Y5(178), Y5(179), Y5(180)
     +    /    44.7D0, 17.0D0, 11.3D0, 12.4D0,  3.4D0,  6.0D0/
      DATA  Y5(181), Y5(182), Y5(183), Y5(184), Y5(185), Y5(186)
     +    /    32.3D0, 54.3D0, 59.7D0, 63.7D0, 63.5D0, 52.2D0/
      DATA  Y5(187), Y5(188), Y5(189), Y5(190), Y5(191), Y5(192)
     +    /    25.4D0, 13.1D0,  6.8D0,  6.3D0,  7.1D0, 35.6D0/
      DATA  Y5(193), Y5(194), Y5(195), Y5(196), Y5(197), Y5(198)
     +    /    73.0D0, 85.1D0, 78.0D0, 64.0D0, 41.8D0, 26.2D0/
      DATA  Y5(199), Y5(200), Y5(201), Y5(202), Y5(203), Y5(204)
     +    /    26.7D0, 12.1D0,  9.5D0,  2.7D0,  5.0D0, 24.4D0/
      DATA  Y5(205), Y5(206), Y5(207), Y5(208), Y5(209), Y5(210)
     +    /    42.0D0, 63.5D0, 53.8D0, 62.0D0, 48.5D0, 43.9D0/
      DATA  Y5(211), Y5(212), Y5(213), Y5(214), Y5(215), Y5(216)
     +    /    18.6D0,  5.7D0,  3.6D0,  1.4D0,  9.6D0, 47.4D0/
      DATA  Y5(217), Y5(218), Y5(219), Y5(220), Y5(221), Y5(222)
     +    /    57.1D0,103.9D0, 80.6D0, 63.6D0, 37.6D0, 26.1D0/
      DATA  Y5(223), Y5(224), Y5(225), Y5(226), Y5(227), Y5(228)
     +    /    14.2D0,  5.8D0, 16.7D0, 44.3D0, 63.9D0, 69.0D0/
      DATA  Y5(229), Y5(230), Y5(231), Y5(232), Y5(233), Y5(234)
     +    /    77.8D0, 64.9D0, 35.7D0, 21.2D0, 11.1D0,  5.7D0/
      DATA  Y5(235), Y5(236), Y5(237), Y5(238), Y5(239), Y5(240)
     +    /     8.7D0, 36.1D0, 79.7D0,114.4D0,109.6D0, 88.8D0/
      DATA  Y5(241), Y5(242), Y5(243), Y5(244), Y5(245), Y5(246)
     +    /    67.8D0, 47.5D0, 30.6D0, 16.3D0,  9.6D0, 33.2D0/
      DATA  Y5(247), Y5(248), Y5(249), Y5(250), Y5(251), Y5(252)
     +    /    92.6D0,151.6D0,136.3D0,134.7D0, 83.9D0, 69.4D0/
      DATA  Y5(253), Y5(254), Y5(255), Y5(256), Y5(257), Y5(258)
     +    /    31.5D0, 13.9D0,  4.4D0, 38.0D0,141.7D0,190.2D0/
      DATA  Y5(259), Y5(260), Y5(261)
     +    /   184.8D0,159.0D0,112.3D0/
!
!     DEFINE CONSTANTS
!
      CALL IPRINT(IPRT)
      LPER = 300
      LFREQ = 300
      LYFFT = 600
!
      NY1 = 100
      NY2 = 50
      NY3 = 50
      NY4 = 50
      NY5 = 261
      NY6 = 100
!
      NK = 3
      KMD(1) = 8
      KMD(2) = 8
      KMD(3) = 8
!
      TAPERP = 0.10
!
      NFFT = 514
      IEXTND = 0
      NPRT = -1
!
      ILOG = 1
!
!     WRITE HEADER
!
      WRITE(IPRT, 1000)
!
!     RUN SIMPLE TEST OF ACF
!
      WRITE(IPRT, 1100)
      CALL ACF (Y1, NY1)
      WRITE (IPRT,2000) IERR
!
!     RUN SIMPLE TEST OF CCF
!
      WRITE(IPRT, 1200)
      CALL CCF (Y2A, Y2B, NY2)
      WRITE (IPRT,2000) IERR
!
!     RUN SIMPLE TEST OF UFS
!
      WRITE(IPRT, 1300)
      CALL UFS (Y3, NY3)
      WRITE (IPRT,2000) IERR
!
!     RUN SIMPLE TEST OF UAS
!
      WRITE(IPRT, 1400)
      CALL UAS (Y4, NY4)
      WRITE (IPRT,2000) IERR
!
!     RUN SIMPLE TEST OF TAPER
!
      WRITE(IPRT, 1510)
      CALL TAPER (Y5, NY5, TAPERP, YFFT)
      WRITE (IPRT,2000) IERR
!
!     RUN SIMPLE TEST OF PGMS
!
      WRITE(IPRT, 1520)
      CALL PGMS(YFFT, NY5, NFFT, LYFFT,
     +          IEXTND, NF, PER, LPER, FREQ, LFREQ, NPRT)
      WRITE (IPRT,2000) IERR
!
!     RUN SIMPLE TEST OF MDFLT
!
      WRITE(IPRT, 1530)
      CALL MDFLT (PER, NF, NK, KMD, PERF, LDSTAK)
      WRITE (IPRT,2000) IERR
!
!     DISPLAY RESULTS OF MDFLT
!
      WRITE(IPRT, 1540)
      CALL PPL (PERF, FREQ, NF, ILOG)
      WRITE (IPRT,2000) IERR
!
!     RUN SIMPLE TEST OF BFS
!
      WRITE(IPRT, 1600)
      CALL BFS (Y6A, Y6B, NY6)
      WRITE (IPRT,2000) IERR
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT ('1*CH12')
 1100 FORMAT (' SIMPLE TEST OF ACF')
 1200 FORMAT ('1SIMPLE TEST OF CCF')
 1300 FORMAT ('1SIMPLE TEST OF UFS')
 1400 FORMAT ('1SIMPLE TEST OF UAS')
 1510 FORMAT ('1SIMPLE TEST OF TAPER (NO OUTPUT UNLESS ERROR FOUND)')
 1520 FORMAT ('1SIMPLE TEST OF PGMS')
 1530 FORMAT ('1SIMPLE TEST OF MDFLT (NO OUTPUT UNLESS ERROR FOUND)')
 1540 FORMAT ('1DISPLAY RESULTS OF MDFLT')
 1600 FORMAT ('1SIMPLE TEST OF BFS')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
!AIMES
      SUBROUTINE AIMES(Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK,
     +   IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT,
     +   NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR ARIMA ESTIMATION
!     (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IVAPRX,IVCV,LDSTAK,MIT,N,NFAC,NPAR,NPARE,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),STP(*),VCV(*),
     +   Y(*)
      INTEGER
     +   IFIXED(1),MSPEC(4,*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP
      LOGICAL
     +   SAVE
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMEDRV,IPRINT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!        IF IFIXED(1).LT.0, THEN IFIXED(I)=DEFAULT,I=1,...,NPAR, AND THE
!                           DIMENSION OF IFIXED WILL BE ASSUMED TO BE 1.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE FOR
!        IVAPRX LE 0, VCV = THE DEFAULT OPTION
!        IVAPRX EQ 1, VCV = INVERSE(TRANSPOSE(J)*J)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2, VCV = INVERSE(H)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4, VCV = INVERSE(TRANSPOSE(J)*J)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5, VCV = INVERSE(H)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7, VCV = THE DEFAULT OPTION
!        WITH J REPRESENTING THE JACOBIAN AND H THE HESSIAN.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE DIMENSION OF VECTOR IFIXED.
!     INTEGER LPV
!        THE DIMENSION OF VECTOR PV.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER LSDPV
!        THE DIMENSION OF VECTOR SDPV.
!     INTEGER LSDRES
!        THE DIMENSION OF VECTOR SDRES.
!     INTEGER LSTP
!        THE DIMENSION OF VECTOR STP.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER MSPEC(4,NFAC)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUE OF THE FIT.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(NPAR)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!        IF SCALE(1).LE.0, THEN SCALE(I)=DEFAULT,I=1,...,NPAR, AND THE
!                          DIMENSION OF SCALE WILL BE ASSUMED TO BE 1.
!     DOUBLE PRECISION SDPV(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(N)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(NPAR)
!        THE STEP SIZE ARRAY.
!        IF STP(1).LE.0, THEN STP(I)=DEFAULT,I=1,...,NPAR, AND THE
!                        DIMENSION OF STP WILL BE ASSUMED TO BE 1.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE VARIANCE-COVARIANCE MATRIX.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'A','I','M','E','S',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      SAVE = .TRUE.
!
      LIFIXD = NPAR
      IF (IFIXED(1).LE.-1) LIFIXD = 1
      LSCALE = NPAR
      IF (SCALE(1).LE.0.0D0) LSCALE = 1
      LSTP = NPAR
      IF (STP(1).LE.0.0D0) LSTP = 1
!
      CALL AMEDRV(Y, N, MSPEC, NFAC, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, SAVE, NPARE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/' THE CORRECT FORM OF THE CALL STATEMENT IS'//
     +  '       CALL AIMES (Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK,'/
     +  '      +            IFIXED, STP, MIT, STOPSS, STOPP, SCALE,'/
     +  '      +            DELTA, IVAPRX, NPRT,'/
     +  '      +            NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)')
      END
!STAT1W
      SUBROUTINE STAT1W(Y, WT, N, YMED, YMIN, YMAX, YMIDRG, YRANGE,
     +   NCELLS, YLB, YUB, YDISTR, NNZW)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS COMPUTES STATISTICS FOR A VECTOR Y THAT REQUIRE OR CAN
!     MAKE USE OF SORTEDNESS IN THE VECTOR.  WEIGHTS ARE USED.
!
!     THIS SUBROUTINE IS BASED ON A MODIFICATION OF THE STATIS
!     CODE USED IN OMNITAB, VERSION 5 (6/16/72), WRITTED BY
!     SALLY PEAVY.  THE ORIGINAL ADAPTATION TO STARPAC WAS MADE
!     BY JANET DONALDSON.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YLB,YMAX,YMED,YMIDRG,YMIN,YRANGE,YUB
      INTEGER
     +   N,NCELLS,NNZW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   WT(N),Y(N),YDISTR(NCELLS)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELY,YT
      INTEGER
     +   I,IC,IC1,KK,L,M,M1,MAX,MAXY,MINY,N2
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MOD
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELY
!        THE WIDTH OF AN INTERVAL ONE TENTH THE RANGE OF THE
!        DATA IN Y.
!     INTEGER I
!        A LOOP INDEX.
!     INTEGER IC
!        PREVIOUS SIGN IN RUNS CALCULATION.
!     INTEGER IC1
!        COUNT IN FREQUENCY DISTRIBUTION CALCULATIONS.
!     INTEGER KK
!        A BACKWARDS, BOULDER, COLORADO LOOP INDEX.
!     INTEGER L
!        A LOOP INDEX.
!     INTEGER M
!        A LOOP INDEX.
!     INTEGER MAX
!        INDEX OF A MAXIMUM ELEMENT.
!     INTEGER MAXY
!        LAST ELEMENT OF Y, THE LARGEST ONE.
!     INTEGER MINY
!        FIRST ELEMENT OF Y, THE LEAST ONE.
!     INTEGER M1
!        ...
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y AND WT.
!     INTEGER NCELLS
!        THE NUMBER OF CELLS IN THE FREQUENCY DISTRIBUTION.
!     INTEGER NNZW
!        INPUT PARAMETER.  THE NUMBER OF POSITIVE ELEMENTS IN WT.
!     INTEGER N2
!        (NNZW + 1)/2
!     DOUBLE PRECISION WT(N)
!        INPUT PARAMETER.  THE VECTOR OF WEIGHTS FOR THE
!        Y OBSERVATIONS.
!     DOUBLE PRECISION Y(N)
!        INPUT PARAMETER.  A SET OF N DATA POINTS, SORTED
!        INTO ASCENDING ORDER.
!     DOUBLE PRECISION YDISTR(NCELLS)
!        OUTPUT PARAMETER.  THE NUMBERS OF Y VALUES WITH
!        POSITIVE WEIGHTS IN EACH OF TEN EQUAL LENGTH INTERVALS.
!        THAT DIVIDE THE RANGE OF Y VALUES.
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE FREQUENCY DISTRIBUTION.
!        IF YLB = YUB, THE MINIMUM OBSERVATION WILL BE USED.
!     DOUBLE PRECISION YMAX
!        OUTPUT PARAMETER.  THE MAXIMUM OF THE OBSERVATIONS Y HAVING
!        POSITIVE WEIGHT.
!     DOUBLE PRECISION YMED
!        OUTPUT PARAMETER.  THE MEDIAN OF THE OBSERVATIONS Y.
!     DOUBLE PRECISION YMIDRG
!        OUTPUT PARAMETER.  THE MIDRANGE OF THE OBSERVATIONS Y.
!     DOUBLE PRECISION YMIN
!        OUTPUT PARAMETER.  THE MINIMUM OF THE OBSERVATIONS Y HAVING
!        POSITIVE WEIGHT.
!     DOUBLE PRECISION YRANGE
!        OUTPUT PARAMETER.  THE RANGE OF THE OBSERVATIONS Y.
!     DOUBLE PRECISION YT
!        THE MAXIMUM VALUE IN EACH INTERVAL IN THE FREQUENCY
!        DISTRIBUTIONS CALCULATIONS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE FREQUENCY DISTRIBUTION.
!        IF YLB = YUB, THE MAXIMUM OBSERVATION WILL BE USED.
!
!     CALCULATE THE MEDIAN.
!
      N2 = (NNZW+1)/2
      M = 1
      DO 10 I=1,N
         IF (I.GT.N2) GO TO 20
         M = I
         IF (WT(M).LE.0.0D0) N2 = N2 + 1
   10 CONTINUE
   20 M1 = M
      IF (MOD(NNZW,2).NE.0) GO TO 40
      DO 30 M1=M,N
         IF (WT(M1).GT.0.0D0) GO TO 40
   30 CONTINUE
   40 YMED = (Y(I)+Y(M1))/2.0D0
!
!     CALCULATE THE MIDRANGE, RANGE, MINIMUM, AND MAXIMUM.
!
      MAX = N - NNZW + 1
      DO 50 I=1,MAX
         MINY = I
         IF (WT(MINY).GT.0.0D0) GO TO 60
   50 CONTINUE
   60 DO 70 I=1,MAX
         KK = N + 1 - I
         MAXY = KK
         IF (WT(MAXY).GT.0.0D0) GO TO 80
   70 CONTINUE
   80 YMIDRG = (Y(MINY)+Y(MAXY))/2.0D0
      YRANGE = Y(MAXY) - Y(MINY)
      YMIN = Y(MINY)
      YMAX = Y(MAXY)
!
!     COMPUTE FREQUENCY DISTRIBUTION
!
      DELY = YRANGE
      YT = YMIN
      IF (YLB.GE.YUB) GO TO 5
         DELY = YUB - YLB
         YT = YLB
    5 CONTINUE
      DELY = DELY / NCELLS
      YT = YT + DELY
      L = 0
      IC1 = 0
      DO 110 I=2,NCELLS
         IC = 0
   90    L = L + 1
         IF (L.GT.N) GO TO 100
         IF (WT(L).LE.0.0D0) GO TO 90
         IF (Y(L).GT.YT) GO TO 100
         IC = IC + 1
         IC1 = IC1 + 1
         GO TO 90
  100    YDISTR(I-1) = IC
         L = L - 1
         YT = YT + DELY
  110 CONTINUE
      YDISTR(NCELLS) = NNZW - IC1
      RETURN
      END
!STATW
      SUBROUTINE STATW(Y, WT, N, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES 53 DIFFERENT STATISTICS FOR A
!     VECTOR Y, WITH WEIGHTS SPECIFIED.  ONE PAGE OF AUTOMATIC
!     PRINTOUT IS PRODUCED.
!
!     WRITTEN BY - JANET R. DONALDSON, JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!        (EXTENSIVE REVISION OF OLDER VERSION)
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   WT(*),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,SUM1,SUMD2,SUMD3,SUMD4,SUMDA,SUMDI,SUMT1,SUMW,SUMWD2,
     +   SUMWT1
      INTEGER
     +   IDP,IINT,IPRT,LSORT,MID,NALL0,NNZW
      LOGICAL
     +   STACK,WTS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   STS(53)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GENI,IPRINT,SRTIRR,SRTRRI,STAT1W,STAT2W,STATER,STKCLR,
     +   STKSET,SUMBS,SUMIDW,SUMOT,SUMWDS,SUMWSS,SUMWTS
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        THE PERCENTAGE OF POINTS TO BE TRIMMED FROM EITHER END OF
!        Y IN CALCULATING THE TRIMMED MEANS.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDP
!        FRAMEWORK CODE VALUE FOR DOUBLE PRECISION NUMBERS.
!     INTEGER IERR
!        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
!        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
!        SOME ERROR EXISTS.
!     INTEGER IINT
!        THE CODE VALUE FOR INTEGER FOR FRAMEWORK.
!     INTEGER IPRT
!        THE NUMBER OF THE STANDARD OUTPUT UNIT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
!        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
!     INTEGER LSORT
!        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION
!        VECTOR.
!     INTEGER MID
!        THE INDEX OF A ZERO ELEMENT IN THE SORTED Y, OR OF THE
!        ELEMENT CLOSEST TO ZERO.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
!        WAS CALLED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NNZW
!        NUMBER OF NONZERO WEIGHTS.
!     LOGICAL STACK
!        A FLAG INDICATING WHETHER THIS ROUTINE USES THE STACK (TRUE)
!        OR NOT (FALSE).
!     DOUBLE PRECISION STS(53)
!        THE VECTOR OF THE 53 STATISTICS COMPUTED.
!     DOUBLE PRECISION SUMDA
!        THE SUM OF THE ABSOLUTE DIFFERENCES FROM THE MEAN.
!     DOUBLE PRECISION SUMDI
!        THE SUM OF THE PRODUCTS OF THE INDICES AND THE
!        DIFFERENCES.
!     DOUBLE PRECISION SUMD2
!        THE SUM OF THE SQUARES OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMD3
!        THE SUM OF THE CUBES OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMD4
!        THE SUM OF THE 4TH POWERS OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMT1
!        THE SUM OF THE ALPHA TRIMMED ARRAY Y.
!     DOUBLE PRECISION SUMW
!        THE SUM OF THE WEIGHTS VECTOR WT.
!     DOUBLE PRECISION SUMWD2
!        THE WEIGHTED SUM OF THE SQUARES OF THE DIFFERENCES.
!     DOUBLE PRECISION SUMWT1
!        THE WEIGHTED SUM OF THE ALPHA TRIMMED ARRAY.
!     DOUBLE PRECISION SUM1
!        THE UNWEIGHTED SUM OF THE ELEMENTS OF Y.
!     DOUBLE PRECISION WT(N)
!        INPUT PARAMETER.  THE WEIGHTS VECTOR.
!     LOGICAL WTS
!        A FLAG INDICATING WHETHER THERE ARE WEIGHTS (TRUE)
!        OR NOT (FALSE).
!     DOUBLE PRECISION Y(N)
!        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
!        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
!        TO ITS ORIGINAL ORDER AFTERWARDS.
!
!
!     INITIALIZE NAME VECTORS
!
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'S',      'T',      'A',      'T',      'W',      ' '/
!
      DATA ALPHA /0.25D0/
      DATA IDP /4/
      DATA IINT /2/
      DATA WTS /.TRUE./
      DATA STACK /.TRUE./
!
!     CHECK FOR ERRORS IN THE INPUT PARAMETERS.
!
      CALL STATER(NMSUB, WT, N, LDSTAK, WTS, NNZW, STACK, IERR)
      IF (IERR.NE.0) THEN
!
!     PRINT ERROR MESSAGE.
!
         CALL IPRINT(IPRT)
         WRITE (IPRT,1000)
         RETURN
      END IF
!
!     SET UP FRAMEWORK AREA.
!
      CALL STKSET (LDSTAK, IDP)
      NALL0 = STKST(1)
!
!     SET UP LSORT, THE PERMUTATION VECTOR.
!
      LSORT = STKGET(N,IINT)
      CALL GENI(ISTAK(LSORT), N, 1, 1)
!
!     SORT THE VECTOR Y.
!
      CALL SRTIRR(ISTAK(LSORT), WT, N, Y)
!
!     COMPUTE THE STATISTICS WHICH USE A SORTED ARRAY.
!
      CALL STAT1W(Y, WT, N, STS(5), STS(34), STS(35), STS(6),
     +   STS(11), 10, 0.0D0, 0.0D0, STS(44), NNZW)
!
!     COMPUTED VARIOUS SUMS IN THE SORTED ARRAY Y.
!
      CALL SUMBS(Y, N, 1, MID, N)
      CALL SUMWSS(Y, WT, N, 1, MID, N, NNZW, SUM1, STS(38), STS(39),
     +   STS(42), SUMW, STS(3), STS(4))
      CALL SUMWTS(Y, WT, N, NNZW, ALPHA, SUMT1, SUMWT1, STS(7),
     +   STS(8))
      CALL SUMWDS(Y, WT, N, 1, MID, N, STS(4), SUMDA, SUMWD2, SUMD2,
     +   SUMD3, SUMD4)
!
!     RESTORE THE VECTOR Y TO ITS ORIGINAL ORDER.
!
      CALL SRTRRI(Y, WT, N, ISTAK(LSORT))
!
!     COMPUTE REST OF STATISTICS.
!
      CALL SUMIDW(Y, WT, N, STS(4), SUMDI)
      CALL STAT2W(Y, WT, N, NNZW, STS, SUMDA, SUMDI, SUMWD2, SUMD2,
     +   SUMD3, SUMD4, SUMW)
      CALL SUMOT(STS, N, NNZW, WTS)
!
!     RETURN THE VECTOR LSORT.
!
      CALL STKCLR(NALL0)
      RETURN
!
!     FORMAT STATEMENTS.
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL STATW (Y, WT, N, LDSTAK)')
      END
!DCKZRO
      SUBROUTINE DCKZRO(J, PAR, NPAR, MDL, XM, N, NROW, M, IXM, PV,
     +   PVTEMP, MSG, LMSG, FD, PARMX, PVPSTP, STP)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE RECHECKS THE DERIVATIES IN THE CASE WHERE THE FINITE
!     DIFFERENCE DERIVATIVE DISAGREES WITH THE ANALYTIC DERIVATIVE AND T
!     ANALYTIC DERIVATIVE IS ZERO.
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FD,PARMX,PV,PVPSTP,STP
      INTEGER
     +   IXM,J,LMSG,M,N,NPAR,NROW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PVTEMP(N),XM(IXM,M)
      INTEGER
     +   MSG(LMSG)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CD,FPLRS,PVMSTP,TEMP,THIRD
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CD
!        THE CENTRAL DIFFERENCE QUOTIENT DERIVATIVE WITH
!        RESPECT TO THE JTH PARAMETER.
!     DOUBLE PRECISION FD
!        THE FORWARD DIFFERENCE QUOTIENT DERIVATIVE WITH RESPECT TO THE
!        JTH PARAMETER.
!     DOUBLE PRECISION FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARTIAL DERIVATIVE BEING EXAMINED.
!     INTEGER LMSG
!        THE LENGTH OF THE VECTOR MSG.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER MSG(LMSG)
!        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION PARMX
!        THE MAXIMUM OF THE CURRENT PARAMETER ESTIMATE AND THE TYPICAL
!        VALUE OF THAT PARAMETER.
!     DOUBLE PRECISION PV
!        THE SCALAR IN WHICH THE PREDICTED VALUE FROM THE MODEL FOR
!        ROW   NROW   IS STORED.
!     DOUBLE PRECISION PVMSTP
!        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
!        BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J) - STP.
!     DOUBLE PRECISION PVPSTP
!        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
!        BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J) + STP.
!     DOUBLE PRECISION PVTEMP(N)
!        THE VECTOR OF PREDICTED VALUES FROM THE MODEL.
!     DOUBLE PRECISION STP
!        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FINITE DIFFERENC
!        DERIVATIVE
!     DOUBLE PRECISION TEMP
!        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
!        PARAMETER IS STORED.
!     DOUBLE PRECISION THIRD
!        THE VALUE 1/3.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      FPLRS = D1MACH(4)
!
!     RECALCULATE NUMERICAL DERIVATIVE USING CENTRAL DIFFERENCE AND STEP
!     SIZE OF 2*STP
!
      TEMP = PAR(J)
      PAR(J) = PAR(J) - STP
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVTEMP)
      PAR(J) = TEMP
!
      PVMSTP = PVTEMP(NROW)
!
      CD = (PVPSTP-PVMSTP)/(2.0D0*STP)
!
!     CHECK FOR DISAGREEMENT
!
      IF (CD.NE.0.0D0) GO TO 10
!
!     NUMERICAL AND ANALYTIC DERIVATIVES NOW AGREE, BUT BOTH EQUAL ZERO,
!     INDICATING THAT DERIVATIVES SHOULD BE RECHECKED AT ANOTHER POINT.
!
      IF (MSG(1).EQ.0) MSG(1) = 1
      MSG(J+1) = 3
      RETURN
!
   10 CONTINUE
!
!     NUMERICAL AND ANALYTIC DERIVATIVE STILL DO NOT AGREE.
!
!     CHECK IF NUMERICAL DERIVATIVE IS CLOSE TO ZERO.
!
      THIRD = 1.0D0/3.0D0
      IF (MIN(ABS(CD), ABS(FD))*PARMX .GT. ABS(PV*FPLRS**THIRD))
     +   GO TO 20
!
!     NUMERICAL DERIVATIVE IS CLOSE TO ZERO
!
      IF (MSG(1).EQ.0) MSG(1) = 1
      MSG(J+1) = 4
      RETURN
!
   20 CONTINUE
!
!     NUMERICAL DERIVATIVE NOT CLOSE TO ZERO
!
      MSG(1) = 2
      MSG(J+1) = 5
      RETURN
!
      END
!AXPBY
      SUBROUTINE AXPBY(N,SA,SX,INCX,SB,SY,INCY,SZ,INCZ)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE IS ADAPTED FROM BLAS SUBROUTINE DAXPY.
!
!     OVERWRITE DOUBLE PRECISION SZ WITH DOUBLE PRECISION SA*SX + SB*SY.
!     FOR I = 0 TO N-1, REPLACE  SZ(LZ+I*INCZ) WITH SA*SX(LX+I*INCX) +
!     SY(LY+I*INCY), WHERE LX = 1 IF INCX .GE. 0, ELSE LX = (-INCX)*N,
!     AND LY AND LZ ARE DEFINED IN A SIMILAR WAY USING INCY AND INCZ,
!     RESPECTIVELY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SA,SB
      INTEGER
     +   INCX,INCY,INCZ,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   SX(*),SY(*),SZ(*)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IX,IY,IZ,M,MP1,NS
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MOD
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION SX(N), SY(N), SZ(N)
!
      IF(N.LE.0) RETURN
      IF ((INCX .EQ. 1) .AND. (INCY .EQ. 1) .AND. (INCZ .EQ. 1))
     +   GO TO 20
      IF ((INCX .GE. 2) .AND. (INCX .EQ. INCY) .AND. (INCX .EQ. INCZ))
     +   GO TO 60
!
!        CODE FOR NONEQUAL OR NONPOSITIVE INCREMENTS.
!
      IX = 1
      IY = 1
      IZ = 1
      IF(INCX.LT.0)IX = (-N+1)*INCX + 1
      IF(INCY.LT.0)IY = (-N+1)*INCY + 1
      IF(INCZ.LT.0)IZ = (-N+1)*INCZ + 1
      DO 10 I = 1,N
        SZ(IZ) = SA*SX(IX) + SB*SY(IY)
        IX = IX + INCX
        IY = IY + INCY
        IZ = IZ + INCZ
   10 CONTINUE
      RETURN
!
!        CODE FOR BOTH INCREMENTS EQUAL TO 1
!
!
!        CLEAN-UP LOOP SO REMAINING VECTOR LENGTH IS A MULTIPLE OF 4.
!
   20 M = MOD(N,4)
      IF( M .EQ. 0 ) GO TO 40
      DO 30 I = 1,M
        SZ(I) = SA*SX(I) + SB*SY(I)
   30 CONTINUE
      IF( N .LT. 4 ) RETURN
   40 MP1 = M + 1
      DO 50 I = MP1,N,4
        SZ(I) = SA*SX(I) + SB*SY(I)
        SZ(I+1) = SA*SX(I+1) + SB*SY(I+1)
        SZ(I+2) = SA*SX(I+2) + SB*SY(I+2)
        SZ(I+3) = SA*SX(I+3) + SB*SY(I+3)
   50 CONTINUE
      RETURN
!
!        CODE FOR EQUAL, POSITIVE, NONUNIT INCREMENTS.
!
   60 CONTINUE
      NS = N*INCX
      DO 70 I=1,NS,INCX
        SZ(I) = SA*SX(I) + SB*SY(I)
   70 CONTINUE
      RETURN
      END
!UASV
      SUBROUTINE UASV (ACOV, LAGMAX, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
!     SPECTRUM ESTIMATION WHEN THE ACVF HAVE PREVIOUSLY BEEN
!     COMPUTED AND STORED (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LAGMAX,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,VAR
      INTEGER
     +   IAR,IPRT,LACOV,LAG,LAIC,LDSMIN,LDSTAK,LPCV,LPHI,LSPC,
     +   LWORK,NF,NPRT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   AIC(101),FREQ(101),FTEST(2,100),PHI(100),SPCA(101),SPCF(101),
     +   WORK(101),XAXIS(207),YAXIS(207)
      INTEGER
     +   ISORT(101),ISYM(207)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PARZEN,UASDV,UASER
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LAGMAX+1)
!        THE AUTOCOVARIANCE COMPUTED FROM THE LAG PRODUCT PAIRS.
!     DOUBLE PRECISION AIC(101)
!        THE ARRAY CONTAINING AKIAKES CRITERIA FOR EACH ORDER.
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
!        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     DOUBLE PRECISION FTEST(2, 100)
!        THE ARRAY CONTAINING THE F RATIO AND F TEST.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISYM(207)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE COVARIANCE ARRAYS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE ARRAY AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER LSPC
!         THE LENGTH OF THE SPECTRUM ARRAYS.
!     INTEGER LWORK
!        THE LENGTH OF THE WORK ARRAY.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
!        ARE TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE TYPE OF WINDOW TO BE USED.
!     DOUBLE PRECISION PHI(100)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     DOUBLE PRECISION SPCA(101)
!        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!     DOUBLE PRECISION SPCF(101)
!        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
!     DOUBLE PRECISION VAR
!        THE ONE STEP PREDICTION VARIANCE.
!     DOUBLE PRECISION WORK(101)
!        A WORK AREA USED FOR THE LAG WINDOWS AND FOR
!        COMPUTING THE AUTOREGRESSIVE COEFFICIENTS.
!     DOUBLE PRECISION XAXIS(207)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YAXIS(207)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'U',       'A',       'S',       'V',       ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(1) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(3) = .TRUE.
      OPTION(4) = .FALSE.
!
      LAG = 0
      IAR = 0
      NF = 101
      FMIN = 0.0D0
      FMAX = 0.5D0
      NPRT = -1
      LACOV = LAGMAX+1
      LDSTAK = 0
      LDSMIN = 0
!
!     CALL ERROR CHECKING ROUTINE
!
      CALL UASER(NMSUB, N, ACOV, IAR, PHI, LAGMAX, LAG, LACOV,
     +   NF, LDSTAK, LDSMIN, N, N, OPTION)
!
      IF (IERR.NE.0) THEN
         IERR = 1
         CALL IPRINT (IPRT)
         WRITE (IPRT, 1000)
         RETURN
      END IF
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      LPCV = 207
      LAIC = 101
      LSPC = 101
      LPHI = 100
      LWORK = 101
!
      ALPHA = 0.95D0
      DELTA = 1.0D0
!
!     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
!
      CALL UASDV(ACOV, SPCA, SPCF, LSPC, IAR, PHI, NF, FMIN, FMAX, FREQ,
     +   N, LAGMAX, FTEST, AIC, WORK, LACOV, LWORK, DELTA, ISORT,
     +   ISYM, XAXIS, YAXIS, LPCV, ALPHA, LAG, LAIC, LPHI, NPRT, VAR,
     +   PARZEN, NMSUB)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL UASV (ACOV, LAGMAX, N)')
      END
!VPHEAD
      SUBROUTINE VPHEAD(NSAMPL, IRLIN, IBAR,
     +                  REFPT, YWIDTH, YMN, YMX,
     +                  ISIZE, ILOG, LINE, NUMCOL, ILOGY, YDMN, YDMX)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRINTS THE HEADING FOR THE VERTICAL PLOT OUTPUT.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   REFPT,YDMN,YDMX,YMN,YMX,YWIDTH
      INTEGER
     +   IBAR,ILOG,ILOGY,IRLIN,ISIZE,NSAMPL,NUMCOL
!
!  ARRAY ARGUMENTS
      CHARACTER
     +   LINE(103)*1
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELY
      INTEGER
     +   I,ICOL,IK,IPRT,JCOL,NLABLY,NLU
      CHARACTER
     +   FMT*4,YLFMT*205,YLFMT2*205
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YLABEL(20)
      INTEGER
     +   ISPACE(20)
      INTEGER
     + ILOGY_(1)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LOGLMT,PRTCNT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,LOG10,MAX,MOD
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELY
!        THE SCALE INTERVAL OF THE PLOT.
!     CHARACTER FMT*4
!        *
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER ICOL, IK
!        *
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER ILOGY
!        THE VALUE OF Q (SEE ILOG)
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISIZE
!     INTEGER ISPACE(20)
!     INTEGER JCOL
!     CHARACTER*1 LINE(103)
!     INTEGER NLABLY
!     INTEGER NLU
!     INTEGER NSAMPL
!        THE SAMPLING FREQUENCY,
!        WHERE IF NSAMPL .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     INTEGER NUMCOL
!        *
!     DOUBLE PRECISION REFPT
!        THE VALUE ZERO, OR THE MEAN OF THE SERIES, WHICH EVER IS
!        REQUESTED, USED AS A PLOT REFERENCE LINE.
!     DOUBLE PRECISION YDMN, YDMX
!        THE Y-AXIS DATA LIMITS ACTUALLY USED.
!     DOUBLE PRECISION YLABEL(20)
!        THE Y-AXIS LABLES.
!     CHARACTER YLFMT*205, YLFMT2*205
!        THE FORMATS USED TO PRINT THE X-AXIS
!     DOUBLE PRECISION YMN, YMX
!        THE GRAPH AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
!     DOUBLE PRECISION YWIDTH
!        *
!
      CALL IPRINT(IPRT)
!
!     CHECK PLOT SEQUENCE.
!
      IF (NSAMPL.EQ.2) THEN
         WRITE(IPRT, 1003)
      ELSE IF (NSAMPL.EQ.3) THEN
         WRITE(IPRT, 1004)
      ELSE IF (NSAMPL.GE.4) THEN
         WRITE(IPRT, 1005) NSAMPL
      END IF
!
!     PRINT HEADINGS FOR Y
!
      IF (IBAR.EQ.0) THEN
         IF (IRLIN.GE.1) THEN
            WRITE(IPRT, 1006)
         ELSE IF (IRLIN.EQ.0) THEN
            WRITE(IPRT, 1007)
         END IF
      END IF
!
!     FIND SIZE OF PLOT TO BE CREATED
!
      IF (MOD(MAX(0,ISIZE),10).EQ.0) THEN
        NUMCOL=101
      ELSE
        NUMCOL = 51
      END IF
!
!     ADJUST FOR LOG PLOTS IF NECESSARY AND FIND AXIS LABELS
!
      CALL PRTCNT (MOD(MAX(0,ILOG),10),1,ILOGY_)
      ILOGY=ILOGY_(1)
      CALL LOGLMT (ILOGY, YMN, YMX, YLABEL, NUMCOL, 10, DELY, YWIDTH,
     +  NLABLY, YDMN, YDMX)
!
!     WRITE OUT THE HORIZONTAL AXIS AND THE AXIS LABELS.
!
      DO 330 ICOL=1,NUMCOL
         LINE(ICOL)='-'
  330 CONTINUE
      LINE(1)='I'
      IF (ILOGY.EQ.0) THEN
        NLU = NLABLY+1
        DO 340 ICOL=NUMCOL,1,-10
           LINE(ICOL)='I'
           NLU = NLU - 1
           ISPACE(NLU) = 1
  340   CONTINUE
      ELSE
        JCOL = 1
        LINE(JCOL) = 'I'
        NLU = NLABLY
        DO 345 IK = NLABLY,1,-1
          ICOL = ((LOG10(YLABEL(IK))-YMN)/YWIDTH)+1.5D0
          LINE(ICOL) = 'I'
          IF (ICOL-JCOL.GE.10) THEN
            ISPACE(NLU) = ICOL-JCOL-9
            NLU = NLU - 1
            YLABEL(NLU) = YLABEL(IK)
            JCOL = ICOL
          END IF
  345   CONTINUE
      END IF
      LINE(NUMCOL+1)='-'
      LINE(NUMCOL+2)=' '
!
!     CHECK X-AXIS LABELS FOR FORMAT
!
      FMT = 'F9.4'
      DO 350 I=1,NLABLY
         IF (((ABS(YLABEL(I)).GT.0.0D0).AND.
     +        (ABS(YLABEL(I)).LT.0.01D0)) .OR.
     +       ((YLABEL(I).GE.1.0D4).OR.(YLABEL(I).LE.(-1.0D3)))) THEN
           FMT = 'D9.3'
           GO TO 355
         END IF
  350 CONTINUE
  355 CONTINUE
      WRITE(YLFMT2,1000) NLABLY-NLU
      WRITE(YLFMT,YLFMT2) (FMT, ISPACE(I), I=NLABLY,NLU+1,-1), FMT
      WRITE(IPRT, YLFMT) (YLABEL(I),I=NLABLY,NLU,-1)
!
      WRITE(IPRT, 1001) '-', (LINE(ICOL), ICOL=1,NUMCOL+2)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT ('(''(11X'',', I2, '('', '', A4, '','', I2, ''X''),',
     +  ''', '', A4, '')'')')
 1001 FORMAT (' ',13X, A1, 105A1)
 1003 FORMAT(45H0NOTE THAT EVERY OTHER POINT HAS BEEN PLOTTED)
 1004 FORMAT(45H0NOTE THAT EVERY THIRD POINT HAS BEEN PLOTTED)
 1005 FORMAT(17H0NOTE THAT EVERY , I2, 25HTH POINT HAS BEEN PLOTTED)
 1006 FORMAT(/' LOCATION OF MEAN IS GIVEN BY PLOT CHARACTER M')
 1007 FORMAT(/' LOCATION OF ZERO IS GIVEN BY PLOT CHARACTER 0')
      END
!STPLSC
      SUBROUTINE STPLSC(XM, N, M, IXM, MDL, PAR, NPAR, LDSTAK, STP,
     +   NETA, EXMPT, SCALE, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR SELECTING STEP SIZES
!     TO BE USED IN COMPUTING FORWARD DIFFERENCE QUOTIENT ESTIMATES
!     OF THE NUMERICAL DERIVATIVES FOR THE NONLINEAR LEAST SQUARES
!     ROUTINES (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   EXMPT
      INTEGER
     +   IXM,LDSTAK,M,N,NETA,NPAR,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),SCALE(*),STP(*),XM(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,LSCALE
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,STPDRV
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION SCALE(NPAR)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION STP(NPAR)
!        THE SELECTED STEP SIZES.
!     DOUBLE PRECISION XM(IXM,M)
!        THE INDEPENDENT VARIABLE ARRAY
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'S','T','P','L','S','C'/
!
!     SET LENGTH OF VECTOR SCALE.
!
      LSCALE = NPAR
!
!     PASS CONTROL TO STEP SIZE SELECTION DRIVER
!
      CALL STPDRV(NMSUB, XM, N, M, IXM, MDL, PAR, NPAR, LDSTAK, STP,
     +   NETA, EXMPT, SCALE, LSCALE, NPRT)
!
      IF (IERR.NE.1) RETURN
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     + '       CALL STPLSC (XM, N, M, IXM, NLSMDL, PAR, NPAR, LDSTAK,',
     + ' STP,'/
     + '      +             NETA, EXMPT, SCALE, NPRT)')
      END
!SPPC
      SUBROUTINE SPPC(YM, X, N, ISYM, ILOG, ISIZE, NOUT, YLB, YUB,
     +  XLB, XUB)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH USER CONTROL OF PLOT SYMBOLS (LONG CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   XLB,XUB,YLB,YUB
      INTEGER
     +   ILOG,ISIZE,N,NOUT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
      INTEGER
     +   ISYM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XMISS
      INTEGER
     +   IPRT,ISCHCK,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'P',       'P',       'C',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      YMMISS(1) = 1.0D0
      XMISS = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      ISCHCK = 1
      MISS = .FALSE.
      LISYM = N
!
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL SPPC (Y, X, N, ISYM, ILOG,'/
     +  '      +           ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      END
!SUMIDW
      SUBROUTINE SUMIDW(X, W, N, XMEANW, SUMDI)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO CALCULATE THE SUM OF THE PRODUCTS OF I AND THE I TH
!     DIFFERENCE AMONG THE ELEMENTS OF THE VECTOR X - XMEANW WHICH
!     ARE NOT WEIGHTED ZERO.  (ELEMENTS WEIGHTED ZERO DO NOT
!     PRODUCE AN INCREMENT IN I.)
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SUMDI,XMEANW
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   W(N),X(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DIFF,I
      INTEGER
     +   K
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DIFF
!        THE DIFFERENCE OF A VALUE OF X AND THE WEIGHTED MEAN OF X.
!     DOUBLE PRECISION I
!        I COUNTS FROM 1 TO THE NUMBER OF NON-ZERO WEIGHTED ELEMENTS
!        FOUND IN X.
!     INTEGER K
!        A LOOP INDEX.
!     INTEGER N
!        INPUT PARAMETER.  THE NUMBER OF ELEMENTS IN X.
!     DOUBLE PRECISION SUMDI
!        OUTPUT PARAMETER.  THE SUM OF THE PRODUCTS OF I AND THE
!        NON-ZERO WEIGHTED ELEMENTS OF THE VECTOR X - XMEANW.
!     DOUBLE PRECISION W(N)
!        INPUT PARAMETER.  THE WEIGHTS VECTOR FOR X.
!     DOUBLE PRECISION X(N)
!        INPUT PARAMETER.  THE VECTOR OF N DATA VALUES.
!     DOUBLE PRECISION XMEANW
!        INPUT PARAMETER.  THE WEIGHTED MEAN OF X.
!
      I = 0.0D0
      SUMDI = 0.0D0
      DO 10 K=1,N
         IF (W(K).EQ.0.0D0) GO TO 10
         DIFF = X(K) - XMEANW
         I = I + 1.0D0
         SUMDI = SUMDI + I*DIFF
   10 CONTINUE
      RETURN
      END
!UFSMN
      SUBROUTINE UFSMN(ACOV, NLPPA, LAG, DF, NF, FREQ, ALPHA, BW, SPCF,
     +   ALOW, AUP, LACOV, ISPCF, WINDOW, W, LW, N, DELTA, MISS, LNLPPA)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING AUTOCORRELATIONS AND
!     PARTIAL AUTOCORRELATIONS OF A TIME SERIES
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALOW,ALPHA,AUP,BW,DELTA,DF
      INTEGER
     +   ISPCF,LACOV,LAG,LNLPPA,LW,N,NF
      LOGICAL
     +   MISS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(LACOV),FREQ(NF),SPCF(ISPCF),W(LW)
      INTEGER
     +   NLPPA(LNLPPA)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL WINDOW
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   PPFCHS
      EXTERNAL PPFCHS
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DFBW,DFBWM,UFSEST
!
!  INTRINSIC FUNCTIONS
      INTRINSIC NINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV)
!        THE AUTOCOVARIANCES OF THE SERIES.
!     DOUBLE PRECISION ALOW
!        A FACTOR USED TO COMPUTE THE LOWER CONFIDENCE LIMITS.
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION AUP
!        A FACTOR USED TO COMPUTE THE UPPER CONFIDENCE LIMITS.
!     DOUBLE PRECISION BW
!        THE BANDWIDTH.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER LACOV
!        THE LENGTH OF VECTOR ACOV.
!     INTEGER LAG
!        THE VARIABLE INDICATING THE LAG VALUE BEING EXAMINED.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     LOGICAL MISS
!        AN INDICATOR VARIABLE WHICH DESIGNATES WHETHER THERE ARE
!        MISSING VALUES (TRUE) OR NOT (FALSE)
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE TIME SERIES.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(LNLPPA)
!        THE NUMBERS OF LAGGED PRODUCT PAIRS IN EACH ACVF VALUE.
!     DOUBLE PRECISION SPCF(ISPCF)
!        THE ARRAY IN WHICH THE SPECTRUM IS STORED.
!     DOUBLE PRECISION W(LW)
!        THE VECTOR OF LAG WINDOWS.
!     EXTERNAL WINDOW
!        THE NAME OF THE WINDOW COMPUTING SUBROUTINE.
!
!     COMPUTE THE WINDOW, EFFECTIVE DEGREES OF FREEDOM AND
!     BANDWIDTH BASED ON THE WINDOW.
!
      CALL WINDOW(LAG, W, LW)
      IF (.NOT.MISS) CALL DFBW(N, LAG, W, LW, DF, BW)
      IF (MISS) CALL DFBWM(N, LAG, W, LW, NLPPA, NLPPA, LNLPPA, DF, BW)
!
!     COMPUTE THE SPECTRUM
!
      CALL UFSEST(ACOV, W, LAG, SPCF, ISPCF, LACOV, LW, NF, FREQ, DELTA)
!
!     COMPUTE -ALPHA- PERCENT POINT FUNCTION VALUE FOR
!     SPECTRUM WINDOW BEING USED.
!
      ALOW = DF/PPFCHS(0.5D0+ALPHA/2.0D0,NINT(DF))
      AUP = DF/PPFCHS(0.5D0-ALPHA/2.0D0,NINT(DF))
!
      RETURN
      END
!DRV1A
      SUBROUTINE DRV1A(COEF, NCOEF, XM, N, M, IXM, D)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DERIVATIVE FUNCTION FOR NLS FAMILY EXERCISER SUBROUTINE MDL1
!     CODED CORRECTLY.
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NCOEF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   COEF(NCOEF),D(N,NCOEF),XM(IXM,M)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION COEF(NCOEF)
!        MODEL COEFFICIENTS
!     DOUBLE PRECISION D(N,NCOEF)
!        THE FIRST DERIVATIVE WITH RESPECT TO THE ITH COEFFICIENT
!     INTEGER I
!        ROW MARKER
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLESC
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NCOEF
!        THE NUMBER OF COEFFICIENTS
!     DOUBLE PRECISION XM(IXM,M)
!        INDEPENDENT VARIABLES
!
!
      DO 10 I=1,N
         D(I,1) = XM(I,1)**COEF(2)
         D(I,2) = COEF(1)*(XM(I,1)**COEF(2))*LOG(XM(I,1))
   10 CONTINUE
!
      RETURN
!
      END
!SUMSS
      SUBROUTINE SUMSS(X, N, LO, MID, HI, SUM1, SUM2, SUMA, XMEAN)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO CALCULATE SUMS OF POWERS AND THE MEAN
!     FOR A SORTED VECTOR IN WHICH THE MIDTH ELEMENT IS
!     THE ELEMENT CLOSEST TO ZERO.  USED BY THE STAT
!     FAMILY.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SUM1,SUM2,SUMA,XMEAN
      INTEGER
     +   HI,LO,MID,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N)
!
!  LOCAL SCALARS
      INTEGER
     +   CURHI,CURLO,I,IREV
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CURHI
!        THE UPPER BOUND OF THE CURRENT INTERVAL.
!     INTEGER CURLO
!        THE LOWER BOUND OF THE CURRENT INTERVAL.
!     INTEGER HI
!        INPUT PARAMETER.  THE UPPER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER I
!        LOOP PARAMETER.
!     INTEGER IREV
!        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
!        IN THE REVERSE ORDER.
!     INTEGER LO
!        INPUT PARAMETER.  THE LOWER BOUND OF THE INITIAL INTERVAL.
!     INTEGER MID
!        INPUT PARAMETER.  THE INDEX OF THE ELEMENT IN X CLOSEST TO
!        ZERO IN VALUE.  THE POINT OUT FROM WHICH THE SUMMING IS
!        DONE.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
!     DOUBLE PRECISION SUMA
!        OUTPUT PARAMETER.  THE SUM OF THE ABSOLUTE VALUES OF THE
!        ELEMENTS OF X.
!     DOUBLE PRECISION SUM1
!        OUTPUT PARAMETER.  THE SUM OF THE ELEMENTS OF X.
!     DOUBLE PRECISION SUM2
!        OUTPUT PARAMETER.  THE SUM OF THE SQUARES OF THE
!        ELEMENTS OF X.
!     DOUBLE PRECISION X(N)
!        INPUT PARAMETER.  THE DATA ARRAY X OVER WHICH THE SUMS ARE
!        TAKEN.
!     DOUBLE PRECISION XMEAN
!        OUTPUT PARAMETER.  THE UNWEIGHTED MEAN OF X.
!
!     INITIALIZE SUMMATION VARIABLES.
!
      SUM1 = X(MID)
      SUM2 = X(MID)*X(MID)
      SUMA = ABS(X(MID))
      CURLO = MID - 1
      CURHI = MID + 1
!
!     SUM OUTWARDS FROM THE VALUE NEAREST ZERO.  THAT IS, SUM FROM
!     THE LEAST IN MAGNITUDE TO THE GREATEST.
!
   10 IF (CURHI.GT.HI .OR. CURLO.LT.LO) GO TO 30
      IF (ABS(X(CURHI)).LT.ABS(X(CURLO))) GO TO 20
      SUM1 = SUM1 + X(CURLO)
      SUM2 = SUM2 + X(CURLO)*X(CURLO)
      SUMA = SUMA + ABS(X(CURLO))
      CURLO = CURLO - 1
      GO TO 10
   20 SUM1 = SUM1 + X(CURHI)
      SUM2 = SUM2 + X(CURHI)*X(CURHI)
      SUMA = SUMA + ABS(X(CURHI))
      CURHI = CURHI + 1
      GO TO 10
!
!     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
!     CENTER ZERO POINT.
!
   30 IF (CURHI.GT.HI) GO TO 50
      DO 40 I=CURHI,HI
         SUM1 = SUM1 + X(I)
         SUM2 = SUM2 + X(I)*X(I)
         SUMA = SUMA + ABS(X(I))
   40 CONTINUE
   50 IF (CURLO.LT.LO) GO TO 70
      DO 60 IREV=LO,CURLO
         I = LO - IREV + CURLO
         SUM1 = SUM1 + X(I)
         SUM2 = SUM2 + X(I)*X(I)
         SUMA = SUMA + ABS(X(I))
   60 CONTINUE
   70 XMEAN = SUM1/(HI-LO+1)
      RETURN
      END
!NLSWC
      SUBROUTINE NLSWC(Y, WT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
!     AND WEIGHTS (CONTROL CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,STOPP,STOPSS
      INTEGER
     +   IVAPRX,IXM,LDSTAK,M,MIT,N,NPAR,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),RES(*),SCALE(*),STP(*),WT(*),XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,LWT,NNZW,
     +   NPARE
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PV(1),SDPV(1),SDRES(1),VCV(1,1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTN
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(NPAR)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(NPAR)
!        THE STEP SIZE ARRAY.
!     DOUBLE PRECISION VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(N)
!        THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','W','C',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      WEIGHT = .TRUE.
      SAVE = .FALSE.
!
      LIFIXD = NPAR
      LPV = 1
      LSCALE = NPAR
      LSTP = NPAR
      LSDPV = 1
      LSDRES = 1
      LWT = N
      IVCV = 1
!
      CALL NLCNTN(Y, WT, LWT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSWC (Y, WT, XM, N, M, IXM, NLSMDL,'/
     +   '      +            PAR, NPAR, RES, LDSTAK,'/
     +   '      +            IFIXED, STP, MIT, STOPSS, STOPP, SCALE,'/
     +   '      +            DELTA, IVAPRX, NPRT)')
      END
!LLCNT
      SUBROUTINE LLCNT(Y, WT, LWT, XM, N, M, IXM, NPAR, RES, LDSTAK,
     +   NPRT, PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV,
     +   IVCV, LLHDR, IFIT, NMSUB, WEIGHT, SAVE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR LINEAR LEAST
!     SQUARES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IFIT,IVCV,IXM,LDSTAK,LPAR,LPV,LSDPV,LSDRES,LWT,M,N,NPAR,
     +   NPRT
      LOGICAL
     +   SAVE,WEIGHT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SDPV(*),SDRES(*),VCV(*),WT(*),XM(*),Y(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL LLHDR
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   ACC,C,FC,IFP,NALL0,NDIGIT,NNZW,PAR1,PARI,PVI,RED,RESI,
     +   RSDI,SDPVI,SDRESI,T,VCVI,WTI,WY,XMW
      LOGICAL
     +   PAGE,WIDE
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   IPTOUT(4),ISTAK(12)
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CPYMSS,LLER,LLSMN,PRTCNT,DCOPY,SETRV,STKCLR,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER ACC
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE NUMBER OF ACCURATE DIGITS.
!     INTEGER C
!        *
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER FC
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ORTHONORMALIZATION MATRIX.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IFIT
!        THE INDICATOR VALUE DESIGNATING WHETHER THE FIT IS OF A
!        GENERAL MODEL (IFIT=3) OR A POLYNOMIAL MODEL (IFIT=1).
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IPTOUT(4)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     EXTERNAL LLHDR
!        THE NAME OF THE ROUTINE THAT PRODUCED THE HEADING.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        NUMBER OF ALLOCATIONS ON ENTRY.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(LPAR)
!        THE PARAMETERS TO BE ESTIMATED.
!     INTEGER PARI
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PARAMETERS TO BE ESTIMATED.
!     INTEGER PAR1
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE PARAMETERS TO BE ESTIMATED OMMITTING THE LAST
!        INDEPENDENT VARIABLE.
!     DOUBLE PRECISION PV(LPV)
!        THE PREDICTED VALUES.
!     INTEGER PVI
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE PREDICTED VALUES.
!     INTEGER RED
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE REDUCTION TO THE SUM OF SQUARES DUE TO EACH PARAMETER.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS.
!     INTEGER RESI
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE RESIDUALS.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     INTEGER RSDI
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE RESIDUAL STANDARD DEVIATION.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION SDPV(LSDPV)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     INTEGER SDPVI
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(LSDRES)
!        THE STANDARDIZED RESIDUALS.
!     INTEGER SDRESI
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE STANDARDIZED RESIDUALS.
!     INTEGER T
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE TRIANGULAR MATRIX FROM THE DECOMPOSITION.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     INTEGER VCVI
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE WEIGHTS.
!     INTEGER WTI
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE WEIGHTS.
!     INTEGER WY
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE VECTOR CONTAINING SQRT(WT)*Y.
!     DOUBLE PRECISION XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!     INTEGER XMW
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE MATRIX CONTAINING XM * SQRT(WT).
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!
      WIDE = .TRUE.
      PAGE = .FALSE.
      NDIGIT = 4
!
      IFP = 4
!
!     SET PRINT CONTROL VALUES
!
      CALL PRTCNT(NPRT, NDIGIT, IPTOUT)
!
!     CHECK FOR ERRORS
!
      CALL LLER(NMSUB, IXM, IVCV, N, NPAR, LPAR, LDSTAK, WT, LWT,
     +   WEIGHT, NNZW, IFIT, SAVE)
      IF (IERR.NE.0) RETURN
!
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
!
!     SET UP SUBDIVISION OF WORK AREAS
!
      WTI = STKGET(N,IFP)
      RESI = STKGET(N,IFP)
      RSDI = STKGET(1,IFP)
      PARI = STKGET(NPAR,IFP)
      PVI = STKGET(N,IFP)
      SDPVI = STKGET(N,IFP)
      SDRESI = STKGET(N,IFP)
      VCVI = STKGET(NPAR*NPAR,IFP)
!
      WY = STKGET(N,IFP)
      XMW = STKGET(N*NPAR,IFP)
      RED = STKGET(NPAR,IFP)
      T = STKGET(NPAR*NPAR,IFP)
      PAR1 = STKGET(NPAR,IFP)
      ACC = STKGET(NPAR,IFP)
      C = STKGET(NPAR,IFP)
!
!     EQUIVALENCED LOCATIONS WITHIN SCRAT
!
      FC = XMW
!
!     SET UP WEIGHTS VECTOR
!
      IF (WEIGHT) THEN
         CALL DCOPY(N, WT, 1, RSTAK(WTI), 1)
      ELSE
         CALL SETRV(RSTAK(WTI), N, 1.0D0)
      END IF
!
      CALL LLSMN(Y, XM, RSTAK(WTI), N, M, NPAR, IXM, RSTAK(RESI),
     +   RSTAK(PARI), NNZW, RSTAK(RSDI), RSTAK(PVI), RSTAK(SDPVI),
     +   RSTAK(SDRESI), IPTOUT, RSTAK(WY), RSTAK(XMW), RSTAK(VCVI),
     +   RSTAK(FC), RSTAK(RED), RSTAK(T), RSTAK(PAR1), RSTAK(ACC), IFIT,
     +   WEIGHT, RSTAK(C), LLHDR, PAGE, WIDE)
!
      CALL DCOPY(N, RSTAK(RESI), 1, RES, 1)
!
      IF (SAVE) THEN
         RSD = RSTAK(RSDI)
         CALL DCOPY(NPAR, RSTAK(PARI), 1, PAR, 1)
         CALL DCOPY(N, RSTAK(PVI), 1, PV, 1)
         CALL DCOPY(N, RSTAK(SDPVI), 1, SDPV, 1)
         CALL DCOPY(N, RSTAK(SDRESI), 1, SDRES, 1)
         CALL CPYMSS(NPAR, NPAR, RSTAK(VCVI), NPAR, VCV, IVCV)
      END IF
      CALL STKCLR(NALL0)
!
      IF (IERR.EQ.3) IERR = 2
      IF (IERR.EQ.4) IERR = 3
!
      RETURN
!
      END
!DOTC
      SUBROUTINE DOTC (Y, YMEAN, NY, X, XMEAN, NX, DOTXY, NDOTXY)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE DOT PRODUCT OF TWO
!     SERIES, CENTERED ABOUT THEIR RESPECTIVE MEANS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DOTXY,XMEAN,YMEAN
      INTEGER
     +   NDOTXY,NX,NY
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(NX),Y(NY)
!
!  LOCAL SCALARS
      INTEGER
     +   I,M
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DOTXY
!        THE DOT PRODUCT OF THE SERIES (Y(I) - YMEAN) AND
!        (X(I) - XMEAN).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER M
!        THE SMALLER OF THE NUMBER OF OBSERVATIONS IN X AND Y
!     INTEGER NDOTXY
!        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY
!     INTEGER NX, NY
!        THE NUMBER OF OBSERVATIONS IN SERIES X AND Y, RESPECTIVELY.
!     DOUBLE PRECISION X(NX)
!        THE VECTOR CONTAINING THE SECOND SERIES
!     DOUBLE PRECISION XMEAN
!        THE MEAN OF THE SECOND SERIES.
!     DOUBLE PRECISION Y(NY)
!        THE VECTOR CONTAINING THE FIRST SERIES
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE FIRST SERIES.
!
      NDOTXY = 0
      DOTXY = 0.0D0
      M = MIN(NY, NX)
      DO 10 I = 1, M
         DOTXY = DOTXY + (Y(I) - YMEAN) * (X(I) - XMEAN)
         NDOTXY = NDOTXY + 1
   10 CONTINUE
      RETURN
      END
!XXCH5
      SUBROUTINE XXCH5(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE STATISTICAL ANALYSIS FAMILY OF ROUTINES.
!
!     DATA SET IS FROM PAGE 39 OF MANDEL [1964]
!
!     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,N
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   Y(40)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,STAT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        ERROR FLAG
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER N
!        THE LENGTH OF THE VECTOR Y.
!     DOUBLE PRECISION Y(40)
!        DATA VECTOR FOR TESTS.
!
!     DATA INITIALIZATIONS.
!
      DATA N /39/
!
      DATA Y( 1), Y( 2), Y( 3), Y( 4)
     +    / 0.4, 0.6, 1.0, 1.0/
      DATA Y( 5), Y( 6), Y( 7), Y( 8)
     +    / 1.0, 0.5, 0.6, 0.7/
      DATA Y( 9), Y(10), Y(11), Y(12)
     +    / 1.0, 0.6, 0.2, 1.9/
      DATA Y(13), Y(14), Y(15), Y(16)
     +    / 0.2, 0.4, 0.0, -0.4/
      DATA Y(17), Y(18), Y(19), Y(20)
     +    / -0.3, 0.0, -0.4, -0.3/
      DATA Y(21), Y(22), Y(23), Y(24)
     +    / 0.1, -0.1, 0.2, -0.5/
      DATA Y(25), Y(26), Y(27), Y(28)
     +    / 0.3, -0.1, 0.2, -0.2/
      DATA Y(29), Y(30), Y(31), Y(32)
     +    / 0.8, 0.5, 0.6, 0.8/
      DATA Y(33), Y(34), Y(35), Y(36)
     +    / 0.7, 0.7, 0.2, 0.5/
      DATA Y(37), Y(38), Y(39)
     +    / 0.7, 0.8, 1.1/
!
!     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
!
      CALL IPRINT(IPRT)
!
!     PRINT HEADING
!
      WRITE (IPRT,1000)
!
!     PERFORM SIMPLE TEST OF STAT
!
      WRITE (IPRT,1100)
      CALL STAT(Y, N, LDSTAK)
      WRITE (IPRT,2000) IERR
!
      RETURN
!
!     FORMATS
!
 1000 FORMAT ('1*CH5')
 1100 FORMAT (' SIMPLE TEST OF STAT')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
!AMEOUT
      SUBROUTINE AMEOUT(Y, N, IFIXD,
     +   PAR, NPAR, NPARE, RES, IPTOUT, NDIGIT, PAGE, IDF, COND, RSS,
     +   RSD, YSS, EXACT, PVT, SDPVT, SDREST, VCVL, LVCVL, IVCVPT,
     +   ISKULL, AMEHDR, WIDE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS THE FINAL SUMMARY OUTPUT FROM THE
!     ARIMA ESTIMATION SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   COND,RSD,RSS,YSS
      INTEGER
     +   IDF,IVCVPT,LVCVL,N,NDIGIT,NPAR,NPARE
      LOGICAL
     +   EXACT,PAGE,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PVT(*),RES(*),SDPVT(*),SDREST(*),VCVL(*),Y(*)
      INTEGER
     +   IFIXD(*),IPTOUT(*),ISKULL(10)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL AMEHDR
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR,IFLAG,MBO,MBOL,MSPECT,NFACT,NPARAR,NPARDF,NPARMA,
     +   NRESTS,PARAR,PARDF,PARMA,T,TEMP
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,IAMHD,IPRT,ISUBHD
!
!  LOCAL ARRAYS
      INTEGER
     +   ISTAK(12)
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMEPT1,AMEPT2,AMLST,IPRINT,MODSUM,NLSKL,VCVOTF
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
      COMMON /MDLTSC/MSPECT,NFACT,PARDF,NPARDF,PARAR,NPARAR,PARMA,
     +   NPARMA,MBO,MBOL,T,TEMP,NRESTS,IFLAG
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION COND
!        THE CONDITION NUMBER OF D.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL EXACT
!        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
!        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     EXTERNAL AMEHDR
!        THE ROUTINE USED TO PRINT THE HEADING
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAMHD
!        THE INDICATOR VALUE USED TO DESIGNATE THE TYPE OF LIST
!        TO BE GENERATED
!        IF IAMHD=1, THE LIST IS FOR THE INITIAL SUMMARY OF THE
!                    ESTIMATION ROUTINES.
!        IF IAMHD=2, THE LIST IS FOR THE INITIAL REPORT OF THE
!                    FORECASTING ROUTINES.
!        IF IAMHD=3, THE LIST IS FOR THE FINAL REPORT OF THE
!                    ESTIMATION ROUTINES.
!     INTEGER IDF
!        THE DEGREES OF FREEDOM IN THE FIT.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IPTOUT(NDIGIT)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER ISKULL(10)
!        AN ERROR MESSAGE INDICATOR VARIABLE.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IVCVPT
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
!        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
!        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)
!        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                       *INVERSE(HESSIAN)
!     INTEGER LVCVL
!        THE DIMENSION OF VECTOR VCVL.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBOL
!        THE MAXIMUM BACK ORDER ON THE LEFT
!     INTEGER MSPECT
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     INTEGER NFACT
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARAR
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE AUTOREGRESSIVE PARAMETERS
!     INTEGER PARDF
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
!     INTEGER PARMA
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE MOVING AVERAGE PARAMETERS
!     DOUBLE PRECISION PVT(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     DOUBLE PRECISION RSS
!        THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION SDPVT(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDREST(N)
!        THE STANDARDIZED RESIDUALS.
!     INTEGER T
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR.
!     INTEGER TEMP
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR
!     DOUBLE PRECISION VCVL(LVCVL)
!        THE LOWER HALF OF THE VARIANCE-COVARIANCE MATRIX, STORED
!        ROW WISE.
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!     DOUBLE PRECISION YSS
!        THE SUM OF THE SQUARES ABOUT THE MEAN Y VALUE.
!
!
      FPLM = D1MACH(2)
!
      CALL IPRINT(IPRT)
!
      IF ((IERR.GE.1) .AND. (IERR.NE.4)) GO TO 60
!
!     TEST FOR EXACT FIT
!
      IF ((IDF.LE.0) .OR. EXACT) GO TO 70
!
!     PRINT ERROR HEADING IF NECESSARY
!
      IF (IERR.EQ.4) CALL NLSKL(ISKULL, PAGE, WIDE, AMEHDR)
!
!     PRINT PRIMARY REPORT
!
      IF ((IERR.EQ.0) .AND. (IPTOUT(3).EQ.0)) GO TO 10
      ISUBHD = 0
      CALL AMEHDR(PAGE, WIDE, ISUBHD)
      CALL AMEPT1(N, Y, PVT, SDPVT, RES, SDREST, IPTOUT, NDIGIT)
!
!     PRINT STANDARDIZED RESIDUAL PLOTS
!
   10 IF (IPTOUT(4).EQ.0) GO TO 20
      ISUBHD = 0
      CALL AMEHDR(PAGE, WIDE, ISUBHD)
!
      CALL AMEPT2 (RES, SDREST, N, RSS)
!
!     PRINT THE COVARIANCE AND CORRELATION MATRIX
!
   20 IF ((IERR.EQ.0) .AND. (IPTOUT(5).EQ.0)) RETURN
      ISUBHD = 0
      CALL AMEHDR(PAGE, WIDE, ISUBHD)
      CALL MODSUM(NFACT, ISTAK(MSPECT))
!
      IF ((IERR.EQ.0) .AND. (IPTOUT(5).LE.1)) GO TO 30
!
      CALL VCVOTF(NPARE, VCVL, LVCVL, .TRUE., NPAR, IFIXD, IVCVPT)
!
!     PRINT ANALYSIS SUMMARY
!
   30 WRITE (IPRT,1000)
      IAMHD = 3
      CALL AMLST(IAMHD, PAR, NPAR, NFACT, ISTAK(MSPECT), N, VCVL, LVCVL,
     +   PAR, NPAR, PAR, NPAR, IFIXD, RSS, RSD, NPARDF, NPARE, IDF)
      WRITE (IPRT,1050) COND
!
      IF (RSS.GT.YSS) WRITE (IPRT,1060)
!
      RETURN
!
!     PRINT OUT ERROR HEADING
!
   60 CALL NLSKL(ISKULL, PAGE, WIDE, AMEHDR)
!
      IF (IERR.LE.2) RETURN
!
!     PRINT SECONDARY REPORT
!
   70 CONTINUE
      ISUBHD = 0
      CALL AMEHDR(PAGE, WIDE, ISUBHD)
      CALL MODSUM(NFACT, ISTAK(MSPECT))
      IF (IERR.NE.0) WRITE (IPRT,1080)
      WRITE (IPRT,1000)
      IAMHD = 2
      CALL AMLST(IAMHD, PAR, NPAR, NFACT, ISTAK(MSPECT), N, VCVL, LVCVL,
     +   PAR, NPAR, PAR, NPAR, IFIXD, RSS, RSD, NPARDF, NPARE, IDF)
      IF (IERR.NE.3) WRITE (IPRT,1050) COND
!
      IF ((IERR.EQ.0) .AND. (.NOT.EXACT) .AND. (IDF.LE.0)) WRITE
     +   (IPRT,1070)
      IF ((IERR.EQ.0) .AND. EXACT) WRITE (IPRT,1090)
!
      IF (IERR.NE.0) GO TO 100
!
      DO 90 I=1,N
         SDREST(I) = 0.0D0
         SDPVT(I) = 0.0D0
   90 CONTINUE
!
      RETURN
!
  100 CONTINUE
!
      DO 110 I=1,N
         SDREST(I) = FPLM
         SDPVT(I) = FPLM
  110 CONTINUE
!
!     PRINT OUT ERROR EXIT STATISTICS
!
      CALL AMEPT1(N, Y, PVT, SDPVT, RES, SDREST, IPTOUT, NDIGIT)
!
!     WIPE OUT SDREST VECTOR
!
      DO 120 I=1,N
         SDREST(I) = FPLM
  120 CONTINUE
!
!     WIPE OUT VCV MATRIX
!
      DO 140 I=1,LVCVL
         VCVL(I) = FPLM
  140 CONTINUE
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (///33H ESTIMATES FROM LEAST SQUARES FIT/1X, 33('-'))
 1050 FORMAT (/29H APPROXIMATE CONDITION NUMBER, 10X, G15.7)
 1060 FORMAT (//52H THE RESIDUAL SUM OF SQUARES AFTER THE LEAST SQUARES,
     +   20H FIT IS GREATER THAN/35H THE SUM OF SQUARES ABOUT THE MEAN ,
     +   19HY OBSERVATION.  THE, 14H MODEL IS LESS/17H REPRESENTATIVE O,
     +   39HF THE DATA THAN A SIMPLE AVERAGE.  DATA, 15H AND MODEL SHOU,
     +   2HLD/48H BE CHECKED TO BE SURE THAT THEY ARE COMPATABLE.)
 1070 FORMAT (/49H THE DEGREES OF FREEDOM FOR THIS PROBLEM IS ZERO.,
     +   54H  STATISTICAL ANALYSIS OF THE RESULTS IS NOT POSSIBLE.)
 1080 FORMAT (//40H THE FOLLOWING SUMMARY SHOULD BE USED TO, 8H ANALYZE,
     +   30H THE ABOVE MENTIONED PROBLEMS.)
 1090 FORMAT (/50H THE LEAST SQUARES FIT OF THE DATA TO THE MODEL IS,
     +   35H EXACT TO WITHIN MACHINE PRECISION./20H STATISTICAL ANALYSI,
     +   33HS OF THE RESULTS IS NOT POSSIBLE.)
      END
!MDL3
      SUBROUTINE MDL3(PAR, NPAR, XM, N, M, IXM, PV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     MODEL FUNCTION FOR NLS EXERCISER
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PV(N),XM(IXM,M)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        ROW INDEX
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     INTEGER M
!        NUMBER OF VARIABLES
!     INTEGER N
!        NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        NUMBER OF PARAMETERS
!     DOUBLE PRECISION PAR(NPAR)
!        MODEL PARAMETERS
!     DOUBLE PRECISION PV(N)
!        PREDICTED VALUES
!     DOUBLE PRECISION XM(IXM,M)
!        INDEPENDENT VARIABLES
!
      DO 10 I=1,N
         PV(I) = PAR(1)*XM(I,1) + PAR(2)*XM(I,2) + PAR(3)*XM(I,3) +
     +      PAR(4)*XM(I,4) + PAR(5)*XM(I,5)
   10 CONTINUE
      RETURN
      END
!HSTER
      SUBROUTINE HSTER(NMSUB, Y, N, NCELLS, LDSTAK, YLB, YUB, IERR)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE CHECKS INPUT PARAMETERS TO THE USER
!     CALLABLE MEMBERS OF THE HIST FAMILY OF ROUTINES
!     FOR ERRORS AND REPORTS ANY THAT IT FINDS, BESIDES
!     RETURNING A FLAG INDICATING THAT ERRORS HAVE BEEN
!     FOUND.
!
!     WRITTEN BY - JOHN E. KOONTZ, JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YLB,YUB
      INTEGER
     +   IERR,LDSTAK,N,NCELLS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  LOCAL SCALARS
      INTEGER
     +   LDSMIN,NV
      LOGICAL
     +   HEAD,IER1,IER2,IER3,IER4
!
!  LOCAL ARRAYS
      CHARACTER
     +   LLDS(8)*1,LN(8)*1,LONE(8)*1,LY(8)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,ERVII,LDSCMP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        OUTPUT PARAMETER.  A FLAG INDICATING WHETHER OR
!        NOT AN ERROR HAS BEEN FOUND.  0 = OK, 1 = ERROR.
!     LOGICAL IER1
!        TRUE IF N .LT. 3
!     LOGICAL IER2
!        TRUE IF LDSTAK .LT. (N + 13)/2.
!     LOGICAL IER3
!        TRUE IF ALL Y VALUES ARE EQUAL.
!     LOGICAL IER4
!        TRUE IF NO DATA WITHIN USER LIMITS
!     INTEGER LDSMIN
!        MINIMUM LENGTH OF FRAMEWORK AREA IN DOUBLE
!        PRECISION ELEMENTS.
!     INTEGER LDSTAK
!        INPUT PARAMETER.  THE NUMBER OF LOCATIONS PROVIDED IN
!        THE FRAMEWORK AREA.
!     CHARACTER*1 LLDS(8), LN(8), LONE(8), LY(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) FO THE VARIALBE(S) CHECKED
!        FOR ERRORS
!     INTEGER N
!        INPUT PARAMETER.  THE NUMBER OF ELEMENTS IN Y.
!     INTEGER NCELLS
!        THE NUMBER OF CELLS IN THE HISTOGRAM.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE
!     INTEGER NV
!        THE NUMBER OF VALUES OUTSIDE USER SUPPLIED LIMITS.
!     DOUBLE PRECISION Y(N)
!        INPUT PARAMETER.  THE VECTOR OF N OBSERVATIONS.
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!
!     INITIALIZE NAME VECTORS
!
      DATA   LLDS(1),  LLDS(2),  LLDS(3),  LLDS(4),  LLDS(5),  LLDS(6),
     +  LLDS(7), LLDS(8) /'L', 'D', 'S', 'T', 'A', 'K', ' ', ' '/
      DATA     LN(1),    LN(2),    LN(3),    LN(4),    LN(5),    LN(6),
     +    LN(7),   LN(8) /'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA   LONE(1),  LONE(2),  LONE(3),  LONE(4),  LONE(5),  LONE(6),
     +  LONE(7), LONE(8) /'O', 'N', 'E', ' ', ' ', ' ', ' ', ' '/
      DATA     LY(1),    LY(2),    LY(3),    LY(4),    LY(5),    LY(6),
     +    LY(7),   LY(8) /'Y', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
!
!     INITIALIZE ERROR FLAGS
!
      IER1 = .FALSE.
      IER2 = .FALSE.
      IER3 = .FALSE.
      IER4 = .FALSE.
!
      IERR = 0
!
      HEAD = .TRUE.
!
!     CHECK TO SEE THAT THERE IS AT LEAST ONE DATA POINTS.
!
      CALL EISGE(NMSUB, LN, N, 1, 2, HEAD, IER1, LONE)
!
!     CHECK FOR SUFFICIENT WORK AREA
!
      CALL LDSCMP(2, 0, N, 0, 0, 0, 'D', NCELLS, LDSMIN)
!
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, IER2, LLDS)
!
!     CHECK WHETHER THERE IS ANY DATA BETWEEN USER SUPPLIED LIMITS
!
      IF ((YLB.LT.YUB) .AND. (N.GE.1))
     +  CALL ERVII (NMSUB, LY, Y, N, YLB, YUB, N-1, HEAD, 1, NV, IER4)
!
!     SEE IF ANY ERRORS WERE FOUND.
!
      IF (IER1 .OR. IER2 .OR. IER3 .OR. IER4) IERR = 1
      RETURN
      END
!FLTMD
      SUBROUTINE FLTMD (X, Y, N, KMD, SYM)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE APPLIES ONE MODIFIED DANIEL FILTERS TO A SYMMETRIC
!     SERIES.  THIS ROUTINE IS ADAPTED FROM BLOOMFIELDS ROUTINE MODDAN.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   SYM
      INTEGER
     +   KMD,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N),Y(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CON
      INTEGER
     +   I,J,KUSED,LIM
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   EXTEND
      EXTERNAL EXTEND
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MOD
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CON
!        A FACTOR USED IN THE COMPUTATIONS.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER J
!        AN INDEXING VARIABLE.
!     INTEGER KMD
!        THE INPUT FILTER LENGTH.
!     INTEGER KUSED
!        THE FILTER LENGTH ACTUALLY USED.
!     INTEGER LIM
!        A LOOP LIMIT.
!     INTEGER N
!        THE NUMBER OF POINTS IN THE SERIES TO BE FILTERED.
!     DOUBLE PRECISION SYM
!        AN INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE SERIES
!        IS SYMMETRIC (SYM = 1.0D0) OR NOT (SYM = -1.0D0).
!     DOUBLE PRECISION X(N)
!        ON INPUT, THE SERIES TO BE FILTERED.  ON OUTPUT, THE
!        SMOOTHED SERIES.
!     DOUBLE PRECISION Y(N)
!        ON INPUT, A WORK VECTOR.  ON OUTPUT, THE INPUT SERIES X.
!
!
      DO 10 I = 1, N
         Y(I) = X(I)
   10 CONTINUE
!
      IF (KMD .LE. 0) RETURN
!
      KUSED = KMD + MOD(KMD,2)
      IF (KUSED .GT. N) KUSED = KUSED - 2
!
      LIM = KUSED-1
      CON = 1.0D0 / (2*KUSED)
      DO 40 I = 1, N
         X(I) = Y(I)
         IF (LIM .EQ. 0) GO TO 30
         DO 20 J = 1, LIM
            X(I) = X(I) + EXTEND(Y, I-J, N, SYM)
     +         + EXTEND(Y, I+J, N, SYM)
   20    CONTINUE
   30    X(I) = (X(I) + (EXTEND(Y, I-KUSED, N, SYM)
     +      + EXTEND(Y, I+KUSED, N, SYM)) * 0.5D0) * CON
   40 CONTINUE
!
      RETURN
!
      END
!GENR
      SUBROUTINE GENR(RVECT, N, RINIT, RSTP)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     PUT VALUES RINIT STEP RSTP THROUGH RINIT + (N - 1)*RSTP INTO
!     A VECTOR RVECT OF LENGTH N.  NO ERROR CHECKING IS DONE.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING LAB/BOULDER
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RINIT,RSTP
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RVECT(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   R
      INTEGER
     +   J
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER J
!        LOOP PARAMETER.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF RVECT.
!     DOUBLE PRECISION R
!        INITIALIZATION VALUE.
!     DOUBLE PRECISION RINIT, RSTP
!        INPUT PARAMETERS.  THE INITIAL VALUE AND THE INCREMENT USED
!        IN CREATING THE INITIALIZATION VALUES.
!     DOUBLE PRECISION RVECT(N)
!        OUTPUT PARAMETER.  THE VECTOR INTO WHICH TO PUT THE VALUES
!        RINIT, RINIT + RSTP, ..., RINIT + (N - 1)*RSTP.
!
      R = RINIT
      DO 10 J=1,N
         RVECT(J) = R
         R = R + RSTP
   10 CONTINUE
      RETURN
      END
!SRTIR
      SUBROUTINE SRTIR(IR, LA, A)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!   FUNCTION     SRTIR  - SORT INTEGER ARRAY IR ON KEY ARRAY A.
!                           IF THE INTEGER ARRAY CONSISTS OF THE
!                           ORDERED SEQUENCE 1, 2, ... LA, THEN
!                           ON COMPLETION IR IS  A PERMUTATION
!                           VECTOR FOR THE SORT OF A.
!   USAGE               - CALL SRTIR (A,LA,IR)
!   PARAMETERS   A(LA)  - ON INPUT, CONTAINS THE ARRAY TO BE SORTED ON
!                         ON OUTPUT, A CONTAINS THE SORTED ARRAY
!                LA     - INPUT VARIABLE CONTAINING THE NUMBER OF
!                           ELEMENTS IN THE ARRAY TO BE SORTED
!                IR(LA) - IF ON INPUT, IR CONTAINS THE INTEGER VALUES
!                           1,2,...,LA.
!                       - THEN ON OUTPUT, IR CONTAINS A RECORD OF THE
!                           PERMUTATIONS MADE ON THE VECTOR A.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LA
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   A(LA)
      INTEGER
     +   IR(LA)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   R,T,TT
      INTEGER
     +   I,IJ,IT,ITT,J,K,L,M
!
!  LOCAL ARRAYS
      INTEGER
     +   IL(21),IU(21)
!
!  INTRINSIC FUNCTIONS
      INTRINSIC INT
!
!
      M = 1
      I = 1
      J = LA
      R = .375D0
   10 IF (I.EQ.J) GO TO 90
      IF (R.GT.0.5898437D0) GO TO 20
      R = R + 3.90625D-2
      GO TO 30
   20 R = R - .21875D0
   30 K = I
!                                  SELECT A CENTRAL ELEMENT OF THE
!                                  ARRAY AND SAVE IT IN LOCATION T
      IJ = I + INT((J-I)*R)
      T = A(IJ)
      IT = IR(IJ)
!                                  IF FIRST ELEMENT OF ARRAY IS GREATER
!                                  THAN T, INTERCHANGE WITH T
      IF (A(I).LE.T) GO TO 40
      A(IJ) = A(I)
      A(I) = T
      T = A(IJ)
      IR(IJ) = IR(I)
      IR(I) = IT
      IT = IR(IJ)
   40 L = J
!                                  IF LAST ELEMENT OF ARRAY IS LESS THAN
!                                  T, INTERCHANGE WITH T
      IF (A(J).GE.T) GO TO 60
      A(IJ) = A(J)
      A(J) = T
      T = A(IJ)
      IR(IJ) = IR(J)
      IR(J) = IT
      IT = IR(IJ)
!                                  IF FIRST ELEMENT OF ARRAY IS GREATER
!                                  THAN T, INTERCHANGE WITH T
      IF (A(I).LE.T) GO TO 60
      A(IJ) = A(I)
      A(I) = T
      T = A(IJ)
      IR(IJ) = IR(I)
      IR(I) = IT
      IT = IR(IJ)
      GO TO 60
   50 TT = A(L)
      A(L) = A(K)
      A(K) = TT
      ITT = IR(L)
      IR(L) = IR(K)
      IR(K) = ITT
!                                  FIND AN ELEMENT IN THE SECOND HALF OF
!                                  THE ARRAY WHICH IS SMALLER THAN T
   60 L = L - 1
      IF (A(L).GT.T) GO TO 60
!                                  FIND AN ELEMENT IN THE FIRST HALF OF
!                                  THE ARRAY WHICH IS GREATER THAN T
   70 K = K + 1
      IF (A(K).LT.T) GO TO 70
!                                  INTERCHANGE THESE ELEMENTS
      IF (K.LE.L) GO TO 50
!                                  SAVE UPPER AND LOWER SUBSCRIPTS OF
!                                  THE ARRAY YET TO BE SORTED
      IF (L-I.LE.J-K) GO TO 80
      IL(M) = I
      IU(M) = L
      I = K
      M = M + 1
      GO TO 100
   80 IL(M) = K
      IU(M) = J
      J = L
      M = M + 1
      GO TO 100
!                                  BEGIN AGAIN ON ANOTHER PORTION OF
!                                  THE UNSORTED ARRAY
   90 M = M - 1
      IF (M.EQ.0) RETURN
      I = IL(M)
      J = IU(M)
  100 IF (J-I.GE.1) GO TO 30
      IF (I.EQ.1) GO TO 10
      I = I - 1
  110 I = I + 1
      IF (I.EQ.J) GO TO 90
      T = A(I+1)
      IT = IR(I+1)
      IF (A(I).LE.T) GO TO 110
      K = I
  120 A(K+1) = A(K)
      IR(K+1) = IR(K)
      K = K - 1
      IF (T.LT.A(K)) GO TO 120
      A(K+1) = T
      IR(K+1) = IT
      GO TO 110
      END
!NLSWS
      SUBROUTINE NLSWS(Y, WT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, STP, MIT, STOPSS, STOPP, SCALE, DELTA, IVAPRX,
     +   NPRT, NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
!     AND WEIGHTS (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IVAPRX,IVCV,IXM,LDSTAK,M,MIT,N,NNZW,NPAR,NPARE,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),STP(*),VCV(*),
     +   WT(*),XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,LIFIXD,LPV,LSCALE,LSDPV,LSDRES,LSTP,LWT
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,NLCNTN
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF IFIXED(I).EQ
!        THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(NPAR)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     DOUBLE PRECISION SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(NPAR)
!        THE STEP SIZE ARRAY.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(N)
!        THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'N','L','S','W','S',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      WEIGHT = .TRUE.
      SAVE = .TRUE.
!
      LIFIXD = NPAR
      LPV = N
      LSCALE = NPAR
      LSTP = NPAR
      LSDPV = N
      LSDRES = N
      LWT = N
!
      CALL NLCNTN(Y, WT, LWT, XM, N, M, IXM, MDL, PAR, NPAR, RES,
     +   LDSTAK, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP, SCALE,
     +   LSCALE, DELTA, IVAPRX, NPRT, RSD, PV, LPV, SDPV, LSDPV, SDRES,
     +   LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL NLSWS (Y, WT, XM, N, M, IXM, NLSMDL,'/
     +   '      +            PAR, NPAR, RES, LDSTAK,'/
     +   '      +            IFIXED, STP, MIT, STOPSS, STOPP,'/
     +   '      +            SCALE, DELTA, IVAPRX, NPRT,'/
     +   '      +            NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV,',
     +   ' IVCV)')
      END
!UFSPCV
      SUBROUTINE UFSPCV (SPCF, SPCMN, SPCMX, FREQ, NF, XAXIS, YAXIS,
     +   ISYM, NPTS, ISPCF, LPCV, NSPC, BW, ALOW, AUP, XPLTMN, XPLTMX,
     +   YPLTMN, YPLTMX, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES CO-ORDINATES FOR THE SPECTRUM PLOTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALOW,AUP,BW,SPCMN,SPCMX,XPLTMN,XPLTMX,YPLTMN,YPLTMX
      INTEGER
     +   ISPCF,LPCV,NF,NPRT,NPTS,NSPC
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),SPCF(ISPCF),XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISYM(LPCV)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CILOW,CIMID,CIUP,YMAX
      INTEGER
     +   I,ISPCFW
!
!  EXTERNAL SUBROUTINES
      EXTERNAL SPPLTC,SPPLTD,SPPLTL
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG10
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALOW, AUP
!        FACTORS USED TO COMPUTE THE CONFIDENCE INTERVALS.
!     DOUBLE PRECISION BW
!       THE BANDWIDTH.
!     DOUBLE PRECISION CILOW, CIMID, CIUP
!        THE Y AXIS VALUES FOR THE LOWER  MID AND UPPER CONFIDENCE
!        INTERVAL POINTS.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISPCFW
!        AN INDEX VARIABLE.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NPTS
!        THE NUMBER OF CO-ORDINATES TO BE PLOTTED.
!     INTEGER NSPC
!        THE NUMBER OF VALID SPECTRUM VALUES.
!     DOUBLE PRECISION SPCF(ISPCF)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     DOUBLE PRECISION SPCMN, SPCMX
!        THE MINIMUM AND MAXIMUM SPECTRUM VALUE TO BE PLOTTED.
!     DOUBLE PRECISION XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     DOUBLE PRECISION YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YMAX
!        THE MAXIMUM ACTUAL SPECTRUM VALUE (IN DECIBELS) TO BE PLOTTED.
!     DOUBLE PRECISION YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VAUES TO BE PLOTTED FOR THE Y AXIS.
!
!
      ISPCFW = 0
!
      IF (NPRT .GE. 1) GO TO 30
!
!     SET VARIOUS Y AXIS VALUES FOR DECIBLE PLOTS
!
      CALL SPPLTD (SPCMN, SPCMX, ALOW, AUP, YPLTMN, YPLTMX,
     +   CILOW, CIMID, CIUP, YMAX)
!
!     SET CO-ORDINATES FOR DECIBLE PLOTS
!
      DO 10 I = 1, NF
         IF (SPCF(I) .LT. SPCMN) GO TO 10
         ISPCFW = ISPCFW + 1
         XAXIS(ISPCFW) = FREQ(I)
         YAXIS(ISPCFW) = 10.0D0 * LOG10(SPCF(I)) - YMAX
         ISYM(ISPCFW) = 1
   10 CONTINUE
!
      GO TO 70
!
   30 CONTINUE
!
!     SET VARIOUS Y AXIS VALUES FOR LOG PLOTS
!
      CALL SPPLTL (SPCMN, SPCMX, ALOW, AUP, YPLTMN, YPLTMX,
     +   CILOW, CIMID, CIUP)
!
!     SET CO-ORDINATES FOR LOG PLOTS
!
      DO 50 I = 1, NF
         IF (SPCF(I) .LT. SPCMN) GO TO 50
         ISPCFW = ISPCFW + 1
         XAXIS(ISPCFW) = FREQ(I)
         YAXIS(ISPCFW) = SPCF(I)
         ISYM(ISPCFW) = 1
   50 CONTINUE
!
   70 CONTINUE
!
      NPTS = NSPC
!
!     SET CO-ORDINATES FOR BANDWIDTH AND CONFIDENCE INTERVAL.
!
      CALL SPPLTC (XAXIS, YAXIS, ISYM, NPTS, XPLTMN, XPLTMX, BW, CILOW,
     +   CIMID, CIUP, LPCV)
!
      RETURN
      END
!PPFT
      DOUBLE PRECISION FUNCTION PPFT(P, IDF)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS FUNCTION IS A VERSION OF DATAPAC SUBROUTINE
!     TPPF, WITH MODIFICATIONS TO FACILITATE CONVERSION TO
!     DOUBLE PRECISION AUTOMATICALLY USING THE NAG, INC. CODE APT,
!     AND TO CORRESPOND TO STARPAC CONVENTIONS.
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE STUDENT"S T DISTRIBUTION
!              WITH INTEGER DEGREES OF FREEDOM PARAMETER = IDF.
!              THE STUDENT"S T DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL X,
!              AND ITS PROBABILITY DENSITY FUNCTION IS GIVEN
!              IN THE REFERENCES BELOW.
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     ERROR CHECKING--NONE
!     RESTRICTIONS--IDF SHOULD BE A POSITIVE INTEGER VARIABLE.
!                 --P SHOULD BE BETWEEN 0.0D0 (EXCLUSIVELY)
!                   AND 1.0D0 (EXCLUSIVELY).
!     COMMENT--FOR IDF = 1 AND IDF = 2, THE PERCENT POINT FUNCTION
!              FOR THE T DISTRIBUTION EXISTS IN SIMPLE CLOSED FORM
!              AND SO THE COMPUTED PERCENT POINTS ARE EXACT.
!            --FOR OTHER SMALL VALUES OF IDF (IDF BETWEEN 3 AND 6,
!              INCLUSIVELY), THE APPROXIMATION
!              OF THE T PERCENT POINT BY THE FORMULA
!              GIVEN IN THE REFERENCE BELOW IS AUGMENTED
!              BY 3 ITERATIONS OF NEWTON"S METHOD FOR
!              ROOT DETERMINATION.
!              THIS IMPROVES THE ACCURACY--ESPECIALLY FOR
!              VALUES OF P NEAR 0 OR 1.
!     REFERENCES--NATIONAL BUREAU OF STANDARDS APPLIED MATHMATICS
!                 SERIES 55, 1964, PAGE 949, FORMULA 26.7.5.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGE 102,
!                 FORMULA 11.
!               --FEDERIGHI, "EXTENDED TABLES OF THE
!                 PERCENTAGE POINTS OF STUDENT"S T
!                 DISTRIBUTION, JOURNAL OF THE
!                 AMERICAN STATISTICAL ASSOCIATION,
!                 1969, PAGES 683-688.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 120-123.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!     ORIGINAL VERSION--OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!
!     MODIFIED BY     --JANET R. DONALDSON, DECEMBER 7, 1981
!                       STATISTICAL ENGINEERING DIVISION
!                       NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   P
      INTEGER
     +   IDF
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ARG,B21,B31,B32,B33,B34,B41,B42,B43,B44,B45,
     +   B51,B52,B53,B54,B55,B56,C,CON,D1,D3,D5,D7,D9,DF,PI,PPFN,
     +   S,SQRT2,TERM1,TERM2,TERM3,TERM4,TERM5,Z
      INTEGER
     +   IPASS,MAXIT
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   PPFNML
      EXTERNAL PPFNML
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ATAN,COS,SIN,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ARG
!        *
!     DOUBLE PRECISION B21
!        *
!     DOUBLE PRECISION B31, B32, B33, B34
!        *
!     DOUBLE PRECISION B41, B42, B43, B44, B45
!        *
!     DOUBLE PRECISION B51, B52, B53, B54, B55, B56
!        *
!     DOUBLE PRECISION C, CON
!        *
!     DOUBLE PRECISION DF
!        THE DEGREES OF FREEDOM.
!     DOUBLE PRECISION D1, D3, D5, D7, D9
!        *
!     INTEGER IDF
!        THE (INTEGER) DEGREES OF FREEDOM.
!     INTEGER IPASS
!        *
!     INTEGER MAXIT
!        *
!     DOUBLE PRECISION P
!        THE PROBABILITY AT WHICH THE PERCENT POINT IS TO BE EVALUATED.
!     DOUBLE PRECISION PI
!        THE VALUE OF PI.
!     DOUBLE PRECISION PPFN
!        THE NORMAL PERCENT POINT VALUE.
!     DOUBLE PRECISION S
!        *
!     DOUBLE PRECISION SQRT2
!        THE SQUARE ROOT OF TWO.
!        *
!     DOUBLE PRECISION TERM1, TERM2, TERM3, TERM4, TERM5
!        *
!     DOUBLE PRECISION Z
!        *
!
!     DEFINE CONSTANTS USED IN THE APPROXIMATIONS
!
      DATA B21 /4.0D0/
      DATA B31, B32, B33, B34 /96.0D0, 5.0D0, 16.0D0, 3.0D0/
      DATA B41, B42, B43, B44, B45
     +  /384.0D0, 3.0D0, 19.0D0, 17.0D0, -15.0D0/
      DATA B51, B52, B53, B54, B55, B56
     +   /9216.0D0, 79.0D0, 776.0D0, 1482.0D0,
     +   -1920.0D0, -945.0D0/
!
      CALL GETPI(PI)
!
      SQRT2 = SQRT(2.0D0)
!
      DF = IDF
      MAXIT = 5
!
      IF (IDF.GE.3) GO TO 50
      IF (IDF.EQ.1) GO TO 30
      IF (IDF.EQ.2) GO TO 40
      PPFT = 0.0D0
      RETURN
!
!     TREAT THE IDF = 1 (CAUCHY) CASE
!
   30 ARG = PI*P
      PPFT = -COS(ARG)/SIN(ARG)
      RETURN
!
!     TREAT THE IDF = 2 CASE
!
   40 TERM1 = SQRT2/2.0D0
      TERM2 = 2.0D0*P - 1.0D0
      TERM3 = SQRT(P*(1.0D0-P))
      PPFT = TERM1*TERM2/TERM3
      RETURN
!
!     TREAT THE IDF GREATER THAN OR EQUAL TO 3 CASE
!
   50 PPFN = PPFNML(P)
      D1 = PPFN
      D3 = PPFN**3
      D5 = PPFN**5
      D7 = PPFN**7
      D9 = PPFN**9
      TERM1 = D1
      TERM2 = (1.0D0/B21)*(D3+D1)/DF
      TERM3 = (1.0D0/B31)*(B32*D5+B33*D3+B34*D1)/(DF**2)
      TERM4 = (1.0D0/B41)*(B42*D7+B43*D5+B44*D3+B45*D1)/(DF**3)
      TERM5 = (1.0D0/B51)*(B52*D9+B53*D7+B54*D5+B55*D3+B56*D1)/(DF**4)
      PPFT = TERM1 + TERM2 + TERM3 + TERM4 + TERM5
      IF (IDF.GE.7) RETURN
      IF (IDF.EQ.3) GO TO 60
      IF (IDF.EQ.4) GO TO 80
      IF (IDF.EQ.5) GO TO 100
      IF (IDF.EQ.6) GO TO 120
      RETURN
!
!     AUGMENT THE RESULTS FOR THE IDF = 3 CASE
!
   60 CON = PI*(P-0.5D0)
      ARG = PPFT/SQRT(DF)
      Z = ATAN(ARG)
      DO 70 IPASS=1,MAXIT
         S = SIN(Z)
         C = COS(Z)
         Z = Z - (Z+S*C-CON)/(2.0D0*C*C)
   70 CONTINUE
      PPFT = SQRT(DF)*S/C
      RETURN
!
!     AUGMENT THE RESULTS FOR THE IDF = 4 CASE
!
   80 CON = 2.0D0*(P-0.5D0)
      ARG = PPFT/SQRT(DF)
      Z = ATAN(ARG)
      DO 90 IPASS=1,MAXIT
         S = SIN(Z)
         C = COS(Z)
         Z = Z - ((1.0D0+0.5D0*C*C)*S-CON)/(1.5D0*C*C*C)
   90 CONTINUE
      PPFT = SQRT(DF)*S/C
      RETURN
!
!     AUGMENT THE RESULTS FOR THE IDF = 5 CASE
!
  100 CON = PI*(P-0.5D0)
      ARG = PPFT/SQRT(DF)
      Z = ATAN(ARG)
      DO 110 IPASS=1,MAXIT
         S = SIN(Z)
         C = COS(Z)
         Z = Z - (Z+(C+(2.0D0/3.0D0)*C*C*C)*S-CON)/((8.0D0/3.0D0)*C**4)
  110 CONTINUE
      PPFT = SQRT(DF)*S/C
      RETURN
!
!     AUGMENT THE RESULTS FOR THE IDF = 6 CASE
!
  120 CON = 2.0D0*(P-0.5D0)
      ARG = PPFT/SQRT(DF)
      Z = ATAN(ARG)
      DO 130 IPASS=1,MAXIT
         S = SIN(Z)
         C = COS(Z)
         Z = Z - ((1.0D0+0.5D0*C*C+0.375D0*C**4)*S-CON)/
     +           ((15.0D0/8.0D0)*C**5)
  130 CONTINUE
      PPFT = SQRT(DF)*S/C
      RETURN
!
      END
!CCFMS
      SUBROUTINE CCFMS (YM, YMMISS, N, M, IYM, LAGMAX, CCOV,
     +   CMISS, ICCOV, JCCOV, NLPPC, INLPPC, JNLPPC, NPRT, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
!     CORRELATIONS AND COVARIANCES OF A MULTIVARIATE SERIES (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CMISS
      INTEGER
     +   ICCOV,INLPPC,IYM,JCCOV,JNLPPC,LAGMAX,LDSTAK,M,N,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(*),YM(*),YMMISS(*)
      INTEGER
     +   NLPPC(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLM
      INTEGER
     +   I,IFP,IO,IPRT,IYMFFT,J,K,LDSMIN,LGLST,LGLSTJ,LGLSTK,LYFFT,
     +   NALL0,NFFT,RHOC,SDRHOC,YMEAN,YMEANJ,YMEANK,YSD,YSDJ,YSDK
      LOGICAL
     +   ISFFT,ISLONG,NEWPG
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      INTEGER
     +   STKGET,STKST
      EXTERNAL D1MACH,STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACVFM,CCFER,CCFMNM,CCFOUT,IPRINT,LDSCMP,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN,SQRT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  STATEMENT FUNCTIONS
      INTEGER
     +   I2,I3C,I3N
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCOV(ICCOV, JCCOV, M)
!        THE CROSS COVARIANCE MATRIX.
!     DOUBLE PRECISION CMISS
!        THE MISSING VALUE CODE FOR THE CCVF ESTIMATES.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER ICCOV
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INLPPC
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
!        IN THE USERS PROGRAM.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON WHETHER PRINTED OUTPUT IS DESIRED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     LOGICAL ISLONG
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IYM
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YM AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IYMFFT
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER I2
!        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN YM
!     INTEGER I3C
!        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN CCOV
!     INTEGER I3N
!        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN NLPPC
!     INTEGER J
!        THE INDEX OF -SERIES 1- IN THE ARRAY YM.
!     INTEGER JCCOV
!        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
!        IN THE USERS PROGRAM.
!     INTEGER K
!        THE INDEX OF -SERIES 2- IN THE ARRAY YM.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LGLST, LGLSTJ, LGLSTK
!        THE STARTING LOCATION IN ISTAK FOR THE ARRAY LGLST,
!        AND THE LOCATIONS IN LGLST IN EHICH THE NUMBER OF THE
!        LAG OF THE LAST ACVF WHICH COULD BE COMPUTED FOR SERIES
!        J AND K, RESPECTIVELY, BEFORE A MISSNG ACVF (DUE TO MISSING
!        DATA).
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER M
!        THE NUMBER OF SERIES BEING COMPARED, IE THE
!        NUMBER OF COLUMNS OF DATA IN YM.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     LOGICAL NEWPG
!        AN INDICATOR VARIABLE USED TO DETERMINE WHEN A NEW PAGE
!        IS APPROPRIATE FOR THE OUTPUT.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NLPPC(INLPPC, JNLPPC, M)
!        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
!        USED TO COMPUTE EACH ACVF ESTIMATE.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPEDIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS GIVEN.
!     INTEGER RHOC
!        THE STARTING LOCATION IN DSTAK OF THE ARRAY RHOC.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SDRHOC
!        THE STARTING LOCATION IN THE WORK AREA FOR SDRHOC.
!     DOUBLE PRECISION YM(IYM, M)
!        THE MATRIX CONTAINING THE OBSERVED TIME SERIES
!     INTEGER YMEAN, YMEANJ, YMEANK
!        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
!        MEANS OF EACH OF THE SERIES, AND THE LOCATION IN
!        THE ARRAY FOR THE MEAN OF THE JTH AND KTH SERIES,
!        RESPECTIVELY.
!     DOUBLE PRECISION YMMISS(M)
!        THE MISSING VALUE CODES FOR EACH OF THE SERIES IN YM.
!     INTEGER YSD, YSDJ, YSDK
!        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
!        STANDARD DEVIATIONS OF EACH OF THE SERIES, AND THE
!        LOCATION IN THE ARRAY FOR THE STANDARD DEVIATION OF
!        THE JTH AND KTH SERIES, RESPECTIVELY.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'C',       'C',       'F',       'M',       'S',       ' '/
!
      I2(I,J) = I + (J-1)*IYM
      I3C(I,J,K) = I + (J-1)*ICCOV + (K-1)*JCCOV*ICCOV
      I3N(I,J,K) = I + (J-1)*INLPPC + (K-1)*JNLPPC*INLPPC
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      LYFFT = N + LAGMAX
      IYMFFT = LYFFT
      NFFT = N
      ISFFT = .FALSE.
      ISLONG = .TRUE.
!
      IO = 1
      IF (NPRT .EQ. 0) IO = 0
!
      CALL LDSCMP(3+2*IO, 0, M, 0, 0, 0, 'D',
     +            2*M+IO*(4*LAGMAX+2), LDSMIN)
!
      CALL CCFER(NMSUB, N, LAGMAX, LDSTAK, LDSMIN, ICCOV, JCCOV,
     +  INLPPC, JNLPPC, M, LYFFT, NFFT, IYM, IYMFFT, ISFFT, ISLONG)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      IF (IERR.EQ.0) THEN
!
        FPLM = D1MACH(2)
!
!       SET UP THE WORK AREA.
!
        CALL STKSET (LDSTAK, 4)
        NALL0 = STKST(1)

        IFP = 4
!
        YMEAN = STKGET(M, IFP)
        YSD = STKGET(M, IFP)
        LGLST = STKGET(M, 2)
        IF (NPRT.EQ.0) THEN
          RHOC = YSD
          SDRHOC = YSD
        ELSE
          RHOC = STKGET(2*LAGMAX+1, IFP)
          SDRHOC = STKGET(2*LAGMAX+1, IFP)
        END IF
!
        IF (IERR.EQ.0) THEN
!
!         BEGIN LOOP FOR COMPUTATIONS
!
          NEWPG = .FALSE.
!
          DO 40 K = 1, M
!
             YMEANK = YMEAN + K - 1
             YSDK = YSD + K - 1
             LGLSTK = LGLST + K - 1
!
             CALL ACVFM (YM(I2(1,K)), YMMISS(K), N, RSTAK(YMEANK),
     +                   CCOV(I3C(1,K,K)), LAGMAX, ISTAK(LGLSTK),
     +                   NLPPC(I3N(1,K,K)), LAGMAX+1)
             RSTAK(YSDK) = SQRT(CCOV(I3C(1,K,K)) * N / (N - 1))
!
             IF ((K-1).LE.0) GO TO 40
!
             DO 30 J = 1, (K-1)
!
                YMEANJ = YMEAN + J - 1
                YSDJ = YSD + J - 1
                LGLSTJ = LGLST + J - 1
!
                CALL CCFMNM (YM(I2(1,J)), YMMISS(J),
     +                       YM(I2(1,K)), YMMISS(K),
     +                       N,  LAGMAX, 2*LAGMAX+1,
     +                       CCOV(I3C(1,J,J)), CCOV(I3C(1,K,K)),
     +                       CCOV(I3C(1,J,K)), CCOV(I3C(1,K,J)), ICCOV,
     +                       NLPPC(I3N(1,J,J)), NLPPC(I3N(1,K,K)),
     +                       NLPPC(I3N(1,J,K)), NLPPC(I3N(1,K,J)),
     +                       INLPPC,
     +                       RSTAK(YMEANJ), RSTAK(YMEANK), RSTAK(RHOC),
     +                       RSTAK(SDRHOC),
     +                       NPRT, MIN(ISTAK(LGLSTJ), ISTAK(LGLSTK)))
!
                IF (NPRT .EQ. 0) GO TO 30
!
!         CALL ROUTINE TO PRINT OUT CORRELATIONS
!
                CALL CCFOUT (J, RSTAK(YMEANJ), RSTAK(YSDJ), N,
     +                       NLPPC(I3N(1,J,J)), K, RSTAK(YMEANK),
     +                       RSTAK(YSDK), N, NLPPC(I3N(1,K,K)), LAGMAX,
     +                       2*LAGMAX+1, RSTAK(RHOC), RSTAK(SDRHOC),
     +                       .TRUE., NLPPC(I3N(1,J,K)),
     +                       NLPPC(I3N(1,K,J)),
     +                       INLPPC, YMMISS(J), YMMISS(K), NEWPG)
!
                NEWPG = .TRUE.
!
   30        CONTINUE
   40     CONTINUE
!
          CMISS = FPLM
        END IF
!
        CALL STKCLR(NALL0)
      END IF
!
      IF (IERR.NE.0) THEN
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL CCFMS (YM, YMMISS, N, M, IYM,'/
     +  '      +            LAGMAX, CCOV, CMISS, ICCOV, JCCOV,'/
     +  '      +            NLPPC, INLPPC, JNLPPC, NPRT, LDSTAK)')
      END
!HPFLT
      SUBROUTINE HPFLT (HLP, K, HHP)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE HIPASS FILTER COEFFICIENTS
!     CORRESPONDING TO THE INPUT LOW PASS FILTER.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   K
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   HHP(K),HLP(K)
!
!  LOCAL SCALARS
      INTEGER
     +   I,KMID
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION HHP(K)
!        THE ARRAY IN WHICH THE HIGH PASS FILTER COEFFICIENTS
!        WILL BE RETURNED.
!     DOUBLE PRECISION HLP(K)
!        THE ARRAY IN WHICH THE INPUT LOW PASS FILTER COEFFICIENTS
!        ARE STORED.
!     INTEGER I
!       AN INDEX VARIABLE.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS TO BE COMPUTED.
!     INTEGER KMID
!        THE MIDPOINT OF THE FILTER.
!
      DO 20 I = 1, K
         HHP(I) = -HLP(I)
   20 CONTINUE
!
      KMID = (K + 1) / 2
!
      HHP(KMID) = HHP(KMID) + 1.0D0
!
      RETURN
      END
!CDFCHI
      DOUBLE PRECISION FUNCTION CDFCHI(CHISQR, DF)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE CHI SQUARE CUMULATIVE DISTRIBUTION
!     FUNCTION FROM THE INCOMPLETE GAMMA FUNCTION RATIO AS DISCUSSED IN
!     CHAPTER 17 OF DISTRIBUTIONS IN STATISTICS - CONTINUOUS UNIVARIATE
!     DISTRIBUTIONS - 1, BY JOHNSON AND KOTZ.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE - DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   CHISQR,DF
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FPLPM
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   DGAMI,DGAMMA,D1MACH
      LOGICAL
     +   MVCHK
      EXTERNAL DGAMI,DGAMMA,D1MACH,MVCHK
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CHISQR
!        THE PERCENT POINT FROM THE CHI SQUARED DISTRIBUTION.
!     DOUBLE PRECISION DF
!        THE DEGREES OF FREEDOM.
!     DOUBLE PRECISION FPLPM
!        THE DOUBLE PRECISION FLOATING POINT LARGEST POSITIVE MAGNITUDE.
!
!     COMMENCE BODY OF ROUTINE
!
      FPLPM = D1MACH(2)
!
      CDFCHI = DGAMI(0.5D0*DF, 0.5D0*CHISQR)
      IF (MVCHK(CDFCHI,FPLPM)) THEN
         CDFCHI = 1.0D0
      ELSE
         CDFCHI = CDFCHI / DGAMMA(0.5D0*DF)
         IF (CDFCHI.LT.0.0D0) CDFCHI = 0.0D0
         IF (CDFCHI.GT.1.0D0) CDFCHI = 1.0D0
      END IF
!
      RETURN
      END
!UFSM
      SUBROUTINE UFSM(Y, YMISS, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS WITH MISSING DATA (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMISS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN
      INTEGER
     +   IPRT,ISPCF,LACOV,LAGMAX,LDSMIN,LDSTAK,LNLPPA,LPCV,LWORK,
     +   LY,NF,NPRT,NW
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   ACOV(101),FREQ(101),SPCF(101,4),WORK(101),XAXIS(106),
     +   YAXIS(106)
      INTEGER
     +   ISORT(101),ISYM(106),LAGS(4),NLPPA(101)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ECVF,IPRINT,PARZEN,SETLAG,UFSDRV
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(101)
!        THE AUTOCOVARIANCE AT LAG ZERO (BIASED VARIANCE).
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISYM(106)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(101)
!        THE ARRAY CONTAINING THE NUMBER OF LAG PRODUCT PAIRS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION SPCF(101,4)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     DOUBLE PRECISION WORK(101)
!        THE VECTOR OF LAG WINDOWS.
!     DOUBLE PRECISION XAXIS(106)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YAXIS(106)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','M',' ',' '/
!
!     SET UP
!
      OPTION(4) = .FALSE.
      OPTION(3) = .FALSE.
      OPTION(2) = .TRUE.
      OPTION(1) = .FALSE.
!
      LDSTAK = 0
      LDSMIN = 0
!
      ISPCF = 101
      LACOV = 101
      LNLPPA = 101
      LY = N
      LPCV = 106
      LWORK = 101
      NF = 101
!
!     SET MAXIMUM LAG VALUE TO BE USED.
!     AND NUMBER OF LAG WINDOW TRUNCATION POINTS TO USE.
!
      CALL SETLAG(N, LAGMAX)
      NW = 4
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!     FOR SERIES WITH MISSING DATA.
!
      CALL UFSDRV(Y, LY, YMISS, ACOV, NLPPA, SPCF, ISPCF, NF, FMIN,
     +   FMAX, FREQ, N, NW, LAGMAX, LAGS, WORK, LACOV, LWORK, DELTA,
     +   ISORT, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, PARZEN, NMSUB,
     +   LDSMIN, LDSTAK, OPTION, LNLPPA, LY)
!
!     CHECK FOR ERRORS
!
      IF (IERR.EQ.0) RETURN
!
      IF (IERR.EQ.2) CALL ECVF(NMSUB)
      IERR = 1
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL UFSM (Y, YMISS, N)')
      END
!IPGMN
      SUBROUTINE IPGMN (PER, NF, PERI, ISPCER)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE INTEGRATED PERIODOGRAM.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ISPCER,NF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PER(NF),PERI(NF)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   SM
      INTEGER
     +   I
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER ISPCER
!        AN ERROR INDICATOR FOR THE INTEGRATED PERIODOGRAM COMPUTATIONS.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        COMPUTED.
!     DOUBLE PRECISION PER(NF)
!        THE RAW PERIODOGRAM.
!     DOUBLE PRECISION PERI(NF)
!        THE ARRAY WHICH CONTAINS THE INTEGRATED PERIODOGRAM.
!     DOUBLE PRECISION SM
!        A VALUE USED TO COMPUTE THE INTEGRATED PERIODOGRAM ESTIMATES.
!
!
      SM = 0.0D0
!
      DO 30 I = 1, NF
         SM = SM + PER(I)
         PERI(I) = SM
   30 CONTINUE
!
      ISPCER = 1
      IF (SM .EQ. 0.0D0) RETURN
!
      ISPCER = 0
!
      DO 40 I = 1, NF
         PERI(I) = PERI(I)/SM
   40 CONTINUE
!
      RETURN
      END
!DRV1B
      SUBROUTINE DRV1B(PAR, NPAR, XM, N, M, IXM, D)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DERIVATIVE FUNCTION FOR NLS FAMILY EXERCISER SUBROUTINE MDL1
!     CODED INCORRECTLY.
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PAR(NPAR),XM(IXM,M)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION D(N,NPAR)
!        THE FIRST DERIVATIVE WITH RESPECT TO THE ITH COEFFICIENT
!     INTEGER I
!        ROW MARKER
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLESC
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        THE NUMBER OF COEFFICIENTS
!     DOUBLE PRECISION PAR(NPAR)
!        MODEL COEFFICIENTS
!     DOUBLE PRECISION XM(IXM,M)
!        INDEPENDENT VARIABLES
!
!
      DO 10 I=1,N
         D(I,1) = XM(I,1)*PAR(2)
         D(I,2) = PAR(1)*(XM(I,1)**PAR(2))*LOG(XM(I,1))
   10 CONTINUE
!
      RETURN
!
      END
!ABSCOM
      SUBROUTINE ABSCOM(N, V, W, ABSTOL, NFAIL)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES THE NUMBER OF TIMES THE
!     ABSOLUTE DIFFERENCE BETWEEN V(I) AND W(I), I = 1, 2, ..., N,
!     IS GREATER THAN   ABSTOL  .
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ABSTOL
      INTEGER
     +   N,NFAIL
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   V(*),W(*)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ABSTOL
!        THE ABSOLUTE TOLERANCE USED IN THE COMPARISON.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAIL
!        THE TOTAL NUMBER OF FAILURES.
!     DOUBLE PRECISION V(N), W(N)
!        THE VALUES BEING COMPARED.
!
      NFAIL = 0
!
      DO 10 I = 1, N
         IF (ABS(V(I) - W(I)) .GT. ABSTOL) NFAIL = NFAIL + 1
   10 CONTINUE
!
      RETURN
!
      END
!AOV1ER
      SUBROUTINE AOV1ER(Y, TAG, N, IGSTAT, NZTAGS, NG, LDSTAK, NMSUB,
     +   INDEX, ISAOV1, NALL0)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE DOES PRELIMINARY CHECKING FOR ERRORS IN THE INPUT
!     PARAMETERS OF THE ONEWAY FAMILY.
!
!     WRITTEN BY -
!        LINDA L. MITCHELL AND JANET R. DONALDSON
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IGSTAT,INDEX,ISAOV1,LDSTAK,N,NALL0,NG,NZTAGS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   TAG(*),Y(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT,J,LDSMIN,NV
      LOGICAL
     +   ERROR,HEAD
!
!  LOCAL ARRAYS
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   LIGSTA(8)*1,LLDS(8)*1,LN(8)*1,LNG(8)*1,LTAG(8)*1,
     +   LTWO(8)*1,LZERO(8)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,ERVGT,GENI,IPRINT,LDSCMP,SRTIRR,SRTRRI,
     +   STKCLR,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERROR
!        SET TRUE IF THE ERROR CHECKING ROUTINE FOUND ANY ERRORS
!     LOGICAL HEAD
!        INDICATES WHETHER HEADING NEEDS TO BE PRINTED
!        TRUE - YES, NEEDS TO BE PRINTED
!        FALSE - NO, HAS BEEN PRINTED
!     INTEGER I
!        *
!     INTEGER IERR
!        IF IERR .NE. 0, THEN ERRORS WHERE FOUND IN THE PARAMETERS
!     INTEGER IGSTAT
!        *
!     INTEGER INDEX
!        THE STARTING LOCATION IN THE STACH AREA OF THE INDEX FOR
!        THE SORTED TAGS.
!     INTEGER IPRT
!        THE OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISAOV1
!        AN INDICATOR VARIABLE USED FOR THE COMPUTATION OF WORK
!        SPACE.  IF ISAOV1 = 0, THE CALLING ROUTINE IS AOV1S.  IF
!        ISAOV1 = 1, THE CALLING ROUTINE IS AOV1.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER J
!        *
!     INTEGER LDSMIN
!        THE MINIMUM SIZE ALLOWED FOR THE STACK
!     INTEGER LDSTAK
!        SIZE OF STACK ALLOCATED IN THE USERS MAIN PROGRAM
!     CHARACTER*1 LIGSTA(8), LLDS(8), LN(8), LNG(8), LTAG(8),
!    *   LTWO(8), LZERO(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE VARIABLE(S) CHECKED
!        ERRORS
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NALL0
!        OUTPUT PARAMETER.  NUMBER OF STACK ALLOCATIONS AFTER
!        STACK IS INITIALIZED.
!     INTEGER NG
!        *
!     CHARACTER*1 NMSUB(6)
!        NAME OF THE CALLING SUBROUTINE
!     INTEGER NV
!        THE NUMBER OF VALUES LESS THAN OR EQUAL TO ZERO.
!     INTEGER NZTAGS
!        THE NUMBER OF POSITIVE NON-ZERO TAGS, TO BE DETERMINED BY
!        THIS ROUTINE
!     DOUBLE PRECISION TAG(N)
!        THE VECTOR OF TAGS.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR OF OBSERVATIONS.
!
      DATA  LIGSTA(1),LIGSTA(2),LIGSTA(3),LIGSTA(4),LIGSTA(5),LIGSTA(6),
     +      LIGSTA(7),LIGSTA(8)
     +     / 'I', 'G', 'S', 'T', 'A', 'T', ' ', ' '/
      DATA   LLDS(1),  LLDS(2),  LLDS(3),  LLDS(4),  LLDS(5),  LLDS(6),
     +       LLDS(7),  LLDS(8)
     +     / 'L', 'D', 'S', 'T', 'A', 'K', ' ', ' '/
      DATA     LN(1),    LN(2),    LN(3),    LN(4),    LN(5),    LN(6),
     +         LN(7),    LN(8)
     +     / 'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA    LNG(1),   LNG(2),   LNG(3),   LNG(4),   LNG(5),   LNG(6),
     +        LNG(7),   LNG(8)
     +     / 'N', 'G', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA   LTAG(1),  LTAG(2),  LTAG(3),  LTAG(4),  LTAG(5),  LTAG(6),
     +       LTAG(7),  LTAG(8)
     +     / 'T', 'A', 'G', ' ', ' ', ' ', ' ', ' '/
      DATA   LTWO(1),  LTWO(2),  LTWO(3),  LTWO(4),  LTWO(5),  LTWO(6),
     +       LTWO(7),  LTWO(8)
     +     / 'T', 'W', 'O', ' ', ' ', ' ', ' ', ' '/
      DATA  LZERO(1), LZERO(2), LZERO(3), LZERO(4), LZERO(5), LZERO(6),
     +      LZERO(7), LZERO(8)
     +     / 'Z', 'E', 'R', 'O', ' ', ' ', ' ', ' '/
!
!     COMMENCE BODY OF ROUTINE
!
      IERR = 0
      HEAD = .TRUE.
!
!     SET UP OUTPUT UNIT
      CALL IPRINT(IPRT)
!
!     BEGIN ERROR CHECKING.
!
!     NUMBER OF OBSERVATIONS LESS THAN 2
!
      CALL EISGE(NMSUB, LN, N, 2, 2, HEAD, ERROR, LTWO)
      IF (ERROR) GO TO 50
!
!     NUMBER OF NON-ZERO TAGS LESS THAN 2
!
      CALL ERVGT(NMSUB, LTAG, TAG, N, 0.0D0, (N-2), HEAD, 7, NV, ERROR,
     +   LZERO)
      IF (ERROR) GO TO 50
!
      NZTAGS = N - NV
!
!     STACK MUST BE LARGE ENOUGH FOR A VECTOR OF LENGTH N TO CONTINUE
!
      CALL LDSCMP(1, 0, N, 0, 0, 0, 'D', 0, LDSMIN)
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR, LLDS)
      IF (ERROR) WRITE(IPRT, 1000)
      IF (ERROR) GO TO 50
!
!     INITIALIZE STACK AND NALL0
!
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
!
      INDEX = STKGET(N,2)
!
!     SORT TAG VECTOR CARRYING ALONG INDEX TO ORIGINAL ORDER AND THE
!     VECTOR OF OBSERVATIONS
!
      CALL GENI(ISTAK(INDEX), N, 1, 1)
      CALL SRTIRR(ISTAK(INDEX), Y, N, TAG)
!
!     COUNT THE NUMBER OF DIFFERENT TAG VALUES
!
      J = N - NZTAGS + 2
      NG = 1
      DO 10 I=J,N
         IF (TAG(I).GT.TAG(I-1)) NG = NG + 1
   10 CONTINUE
!
!     LESS THAN 2 DIFFERENT TAG GROUPS
!
      CALL EISII(NMSUB, LNG, NG, 2, NZTAGS-1, 3, HEAD, ERROR,
     +  LTWO, LN)
      IF (ERROR) GO TO 40
!
!     CHECK THAT DIMENSION OF STATISTICS MATRIX IS SUFFICIENT
!
      CALL EISGE(NMSUB, LIGSTA, IGSTAT, NG, 3, HEAD, ERROR, LNG)
      IF (ERROR) GO TO 40
!
!     COMPUTE AND CHECK FOR SUFFICIENT STACK
!
      CALL LDSCMP(11, 0, N+NZTAGS, 0, 0, 0,
     +            'D', ISAOV1*4*NG+4*NG+NZTAGS, LDSMIN)
!
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR, LLDS)
      IF (.NOT.ERROR) RETURN
!
   40 CONTINUE
!
!     REORDER DATA
!
      CALL SRTRRI(TAG, Y, N, ISTAK(INDEX))
!
!     CLEAR STACK, IN CASE WHERE ERROR FOLLOWS ALLOCATION OF STACK.
!
      CALL STKCLR (NALL0)
!
   50 CONTINUE
      IERR = 1
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/' NOTE.  THE VALUE OF LDSTAK MENTIONED ABOVE IS THE',
     +  ' MINIMUM NECESSARY'/
     +  ' TO CONTINUE CHECKING FOR ERRORS AND',
     +  ' TO CALCULATE THE CORRECT VALUE'/
     +  ' OF LDSTAK.  THE CORRECT',
     +  ' VALUE WILL BE LARGER.  CONSULT THE DOCUMENTATION'/
     +  ' FOR THE FORMULAS USED TO CALCULATE LDSTAK.')
      END
!SUMOT
      SUBROUTINE SUMOT(STS, N, NNZW, WTS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE REPORTS THE RESULTS OF A STAT FAMILY
!     COMPUTATION OF 53 SELECTED STATISTICS.  THERE MAY OR
!     MAY NOT BE WEIGHTS.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N,NNZW
      LOGICAL
     +   WTS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   STS(53)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT
!
!  LOCAL ARRAYS
      INTEGER
     +   ITEMP(10)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VERSP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        LOOP INDEX.
!     INTEGER IPRT
!        THE OUTPUT UNIT.
!     INTEGER ITEMP(10)
!        A TEMPORARY VECTOR OF INTEGER STORAGE.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF THE ORIGINAL DATA VECTOR.
!     INTEGER NNZW
!        INPUT PARAMETER.  THE NUMBER OF VALUES IN THE ORIGINAL DATA
!        VECTOR WITH WEIGHTS GREATER THAN 0.0D0.
!     DOUBLE PRECISION STS(53)
!        INPUT PARAMETER.  THE VECTOR OF 53 STATISTICS COMPUTED.
!        ROW STATISTIC                    ROW STATISTIC
!         1  LENGTH OF VECTOR             TESTS FOR NONRANDOMNESS
!         2  NUMBER OF NONZERO WEIGHTS    23  NUMBER OF RUNS UP AND DOWN
!        MEASURES OF LOCATION             24  EXPECTED NUMBER OF RUNS
!         3  UNWEIGHTED MEAN              25  S.D. OF NUMBER OF RUNS
!         4  WEIGHTED MEAN                26  MEAN SQR. SUCCESSIVE DIFF.
!         5  MEDIAN                       27  MEAN SQR. SUCC. DIFF./VAR.
!         6  MID-RANGE                    DEVIATIONS FROM WTD MEAN
!         7  25 P.C. UNWTD. TRIMMED MEAN  28  NUMBER OF + SIGNS
!         8  25 P.C. WTD. TRIMMED MEAN    29  NUMBER OF - SIGNS
!        MEASURES OF DISPERSION           30  NUMBER OF RUNS
!         9  STANDARD DEVIATION (S.D.)    31  EXPECTED NUMBER OF RUNS
!        10  S.D. OF MEAN                 32  S.D. OF RUNS
!        11  RANGE                        33  DIFF./S.D. OF RUNS
!        12  MEAN VARIATION               OTHER STATISTICS
!        13  VARIANCE (VAR.)              34  MINIMUM
!        14  COEFFICIENT OF VARIATION     35  MAXIMUM
!        CONFIDENCE INTERVALS             36  BETA 1
!        15  LOWER CONFIDENCE LIMIT, MEAN 37  BETA 2
!        16  UPPER CONFIDENCE LIMIT, MEAN 38  WTD. SUM OF VALUES
!        17  LOWER CONFIDENCE LIMIT, S.D. 39  WTD. SUM OF SQUARES
!        18  UPPER CONFIDENCE LIMIT, S.D. 40  WTD. SUM OF SQRD. DEVS.
!        LINEAR TREND STATISTICS          41  STUDENTS T
!        19  SLOPE                        42  WTD. SUM OF ABS. VALUES
!        20  S.D. OF SLOPE                43  WTD. AVG. ABS. VALUES
!        21  SLOPE/S.D. OF SLOPE = T      44-53 FREQ. DISTRIBUTION
!        22  PROB ( X .GT. ABS(OBS. T))
!     LOGICAL WTS
!        INPUT PARAMETER.  A FLAG TO INDICATE WHETHER OR NOT THERE ARE
!        WEIGHTS.
!
!     BEGIN PRINTOUT
!
      CALL IPRINT(IPRT)
!
!     PRINT HEADING
!
      CALL VERSP(.TRUE.)
!
!     PRINT NUMBERS OF OBSERVATIONS, RAW AND NONZERO WEIGHTED.
!
      IF (.NOT.WTS) WRITE (IPRT,1000)
      IF (WTS) WRITE (IPRT,1010)
      IF (NNZW.NE.N) GO TO 10
      WRITE (IPRT,1020) NNZW
      GO TO 20
   10 WRITE (IPRT,1030) NNZW, N
      WRITE (IPRT,1040)
!
!     PRINT FREQUENCY DISTRIBUTIONS
!
   20 DO 30 I=1,10
         ITEMP(I) = STS(I+43)
   30 CONTINUE
      WRITE (IPRT,1050) (ITEMP(I),I=1,10)
!
!     PRINT MEASURES OF LOCATION AND DISPERSION
!
      WRITE (IPRT,1060)
      IF (STS(4).NE.0.0D0)
     +   WRITE (IPRT,1070) (STS(I+2),STS(I+8),I=1,6)
      IF (STS(4).EQ.0.0D0)
     +   WRITE (IPRT,1080) (STS(I+2),STS(I+8),I=1,5), STS(8)
!
!     PRINT CONFIDENCE INTERVALS
!
      WRITE (IPRT,1090) (STS(I),I=15,18)
!
!     PRINT LINEAR TREND AND OTHER STATISTICS, AND PRINT HEADING FOR
!     TESTS FOR NONRANDOMNESS
!
      WRITE (IPRT,1100)
     +   (STS(I),STS(I+15),I=19,22), (STS(I),I=38,41)
      ITEMP(1) = STS(23)
      ITEMP(2) = STS(28)
      ITEMP(3) = STS(29)
      ITEMP(4) = STS(30)
!
!     PRINT TESTS FOR NONRANDOMNESS
!
      WRITE (IPRT,1110) ITEMP(1), STS(42), STS(24), STS(43),
     +   (STS(I),I=25,27), (ITEMP(I),I=2,4), (STS(I),I=31,33)
!
!     PRINT FOOTNOTE
!
      WRITE (IPRT,1120)
      RETURN
!
 1000 FORMAT('+STATISTICAL ANALYSIS')
 1010 FORMAT('+WEIGHTED STATISTICAL ANALYSIS')
 1020 FORMAT(//5X, 4HN = , I5)
 1030 FORMAT(//5X, 4HN = , I5, 32H (NO. OF NON-ZERO WTS)    LENGTH,
     +   2H =, I5)
 1040 FORMAT(/5X, 45HALL COMPUTATIONS ARE BASED ON OBSERVATIONS WI,
     +   19HTH NON-ZERO WEIGHTS)
 1050 FORMAT(//5X, 28HFREQUENCY DISTRIBUTION (1-6), 7X, 10I6)
 1060 FORMAT(//5X, 26HMEASURES OF LOCATION (2-2), 34X, 10HMEASURES O,
     +   18HF DISPERSION (2-6))
 1070 FORMAT(/10X, 26HUNWEIGHTED MEAN          =, 1PD15.7, 20X,
     +   26HWTD STANDARD DEVIATION   =, D15.7/10X, 17HWEIGHTED MEAN    ,
     +   9H        =, D15.7, 20X, 26HWEIGHTED S.D. OF MEAN    =,
     +   D15.7/10X, 26HMEDIAN                   =, D15.7, 20X, 6HRANGE ,
     +   20H                   =, D15.7/10X, 23HMID-RANGE              ,
     +   3H  =, D15.7, 20X, 26HMEAN DEVIATION           =, D15.7/10X,
     +   26H25 PCT UNWTD TRIMMED MEAN=, D15.7, 20X, 16HVARIANCE        ,
     +   10H         =, D15.7/10X, 26H25 PCT WTD TRIMMED MEAN  =,
     +   D15.7, 20X, 26HCOEF. OF. VAR. (PERCENT) =, D15.7)
 1080 FORMAT(/10X, 26HUNWEIGHTED MEAN          =, 1PD15.7, 20X,
     +   26HWTD STANDARD DEVIATION   =, D15.7/10X, 17HWEIGHTED MEAN    ,
     +   9H        =, D15.7, 20X, 26HWEIGHTED S.D. OF MEAN    =,
     +   D15.7/10X, 26HMEDIAN                   =, D15.7, 20X, 6HRANGE ,
     +   20H                   =, D15.7/10X, 23HMID-RANGE              ,
     +   3H  =, D15.7, 20X, 26HMEAN DEVIATION           =, D15.7/10X,
     +   26H25 PCT UNWTD TRIMMED MEAN=, D15.7, 20X, 16HVARIANCE        ,
     +   10H         =, D15.7/10X, 26H25 PCT WTD TRIMMED MEAN  =,
     +   D15.7, 20X, 26HCOEFFICIENT OF VARIATION =, 13H    UNDEFINED/
     +   98X, 14H(MEAN IS ZERO))
 1090 FORMAT(///20X, 46HA TWO-SIDED 95 PCT CONFIDENCE INTERVAL FOR MEA,
     +   4HN IS, 1PD14.7, 4H TO , D14.7, 6H (2-2)/20X, 13HA TWO-SIDED 9,
     +   37H5 PCT CONFIDENCE INTERVAL FOR S.D. IS, D14.7, 4H TO ,
     +   D14.7, 6H (2-7))
 1100 FORMAT(///5X, 30HLINEAR TREND STATISTICS (5-1) , 30X, 6HOTHER ,
     +   10HSTATISTICS//10X, 5HSLOPE, 20X, 1H=, 1PD15.7, 20X, 7HMINIMUM,
     +   18X, 1H=, D15.7/10X, 13HS.D. OF SLOPE, 12X, 1H=, D15.7, 20X,
     +   7HMAXIMUM, 18X, 1H=, D15.7/10X, 26HSLOPE/S.D. OF SLOPE = T  =,
     +   D15.7, 20X, 8HBETA ONE, 17X, 1H=, D15.7/10X, 14HPROB EXCEEDING,
     +   21H ABS VALUE OF OBS T =, 0PF6.3, 20X, 8HBETA TWO, 17X, 1H=,
     + 1PD15.7/71X, 17HWTD SUM OF VALUES, 8X, 1H=, D15.7/71X, 7HWTD SUM,
     +   11H OF SQUARES, 7X, 1H=, D15.7/5X, 24HTESTS FOR NON-RANDOMNESS,
     +   42X, 22HWTD SUM OF DEV SQUARED, 4H   =, D15.7/71X, 9HSTUDENTS ,
     +   'T', 15X, 1H=, D15.7)
 1110 FORMAT(10X, 26HNO. OF RUNS UP AND DOWN  =, I5, 30X, 9HWTD SUM A,
     +   17HBSOLUTE VALUES  =, 1PD15.7/
     +   10X, 26HEXPECTED NO. OF RUNS     =,
     +   0PF7.1, 28X, 26HWTD AVE ABSOLUTE VALUES  =, 1PD15.7/
     +   10X, 26HS.D. OF NO. OF RUNS      =, 0PF8.2/
     +   10X, 26HMEAN SQ SUCCESSIVE DIFF  =, 1X, 1PD16.7/
     +   10X, 26HMEAN SQ SUCC DIFF/VAR    =, 0PF9.3///
     +   10X, 24HDEVIATIONS FROM WTD MEAN//
     +   15X, 21HNO. OF + SIGNS      =, I5/
     +   15X, 21HNO. OF - SIGNS      =, I5/
     +   15X, 21HNO. OF RUNS         =, I5/
     +   15X, 21HEXPECTED NO. OF RUNS=, F7.1/
     +   15X, 12HS.D. OF RUNS, 8X, 1H=, F8.2/
     +   15X, 21HDIFF./S.D. OF RUNS  =, F9.3)
 1120 FORMAT(///49H NOTE - ITEMS IN PARENTHESES REFER TO PAGE NUMBER,
     +   36H IN NBS HANDBOOK 91 (NATRELLA, 1966))
      END
!DEMOD
      SUBROUTINE DEMOD (Y, N, FD, FC, K, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE TO DEMODULATE SERIES
!     Y AT FREQUENCY FD, TO APPLY A LOW PASS FILTER WITH CUTOFF
!     FREQUENCY FC, AND TO EXTRACT THE AMPLITUDE AND PHASE COMPONENTS
!     OF THE RESULTING FILTERED SERIES (SHORT CALL).
!
!     WRITTEN BY  -  PETER BLOOMFIELD
!                    FOURIER ANALYSIS OF TIME SERIES- AN
!                       INTRODUCTION
!                    JOHN WILEY AND SONS, NEW YORK, 1976
!                    PAGE 147
!     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
!                                STATISTICAL ENGINEERING DIVISION
!                                NATIONAL BUREAU OF STANDARDS
!                                BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FC,FD
      INTEGER
     +   K,LDSTAK,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   TEMP
      INTEGER
     +   AMPL,HLP,IFP,IPRT,LDSMIN,NALL0,NDEM,PHASE
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,ERR06,ERR07,HEAD
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      CHARACTER
     +   LFC(8)*1,LFD(8)*1,LK(8)*1,LKIN(8)*1,LLDS(8)*1,LN(8)*1,
     +   LNM1(8)*1,LONE(8)*1,NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DEMDRV,EISGE,EISII,ERIODD,ERSII,ERSLFS,IPRINT,LDSCMP,
     +   STKCLR,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER AMPL
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05, ERR06, ERR07
!        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION FC
!        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
!     DOUBLE PRECISION FD
!        THE DEMODULATION FREQUENCY.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER HLP
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE ARRAY IN WHICH THE LOW PASS FILTER COEFFICIENTS ARE
!        STORED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER K
!        THE USER SUPPLIED NUMBER OF TERMS TO BE USED FOR THE LOW
!        PASS FILTER.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LFC(8), LFD(8), LK(8), LKIN(8), LLDS(8), LN(8),
!    *  LNM1(8), LONE(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
!        WAS CALLED.
!     INTEGER NDEM
!        THE NUMBER OF VALUES IN THE DEMODULATED SERIES, I.E., IN
!        THE AMPLITUDE AND PHASE ARRAYS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER PHASE
!        THE STARTING LOCATIONS IN RSTAK/DSTAK OF
!        THE ARRAY CONTAINING THE PRIMARY AND SECONDARY PHASE ESTIMATES.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION TEMP
!        A TEMPORARY VARIABLE USED FOR TYPE CONVERSION.
!     DOUBLE PRECISION Y(N)
!        THE INPUT ARRAY CONTAINING THE OBSERVED SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'D',       'E',       'M',       'O',       'D',       ' '/
      DATA
     +  LFC(1), LFC(2), LFC(3), LFC(4), LFC(5), LFC(6), LFC(7), LFC(8)
     + /  'F',   'C',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LFD(1), LFD(2), LFD(3), LFD(4), LFD(5), LFD(6), LFD(7), LFD(8)
     + /  'F',   'D',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LKIN(1), LKIN(2), LKIN(3), LKIN(4), LKIN(5), LKIN(6), LKIN(7),
     +  LKIN(8) /  '(',   '1',   '/',   'K',   ')',   ' ',   ' ',   ' '/
      DATA
     +  LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6), LLDS(7),
     +  LLDS(8) /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LNM1(1), LNM1(2), LNM1(3), LNM1(4), LNM1(5), LNM1(6), LNM1(7),
     +  LNM1(8) /  '(',   'N',   '-',   '1',   ')',   ' ',   ' ',   ' '/
      DATA
     +  LONE(1), LONE(2), LONE(3), LONE(4), LONE(5), LONE(6), LONE(7),
     +  LONE(8) /  'O',   'N',   'E',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     PERFORM ERROR CHECKING ON INPUT DATA.
!
      IERR = 0
      HEAD = .TRUE.
!
      CALL EISGE(NMSUB, LN, N, 17, 1, HEAD, ERR01, LN)
!
      CALL ERSII(NMSUB, LFD, FD,
     +           0.0D0, 0.5D0, 2, HEAD, ERR02, LFD, LFD)
!
      ERR03 = .TRUE.
      IF (.NOT. ERR01)
     +  CALL EISII(NMSUB, LK, K, 1, N-1, 1, HEAD, ERR03, LONE, LNM1)
!
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR04)
!
      ERR05 = .TRUE.
      IF ((.NOT. ERR02) .AND. (.NOT. ERR03) .AND. (.NOT. ERR04)) THEN
         TEMP = K
         CALL ERSII(NMSUB, LFC, FC, 1.0D0/TEMP, FD, 1, HEAD, ERR05,
     +              LKIN, LFD)
      END IF
!
      ERR06 = .TRUE.
      IF ((.NOT. ERR03) .AND. (.NOT. ERR04) .AND. (.NOT. ERR05))
     +   CALL ERSLFS(NMSUB, FC, K, HEAD, ERR06)
!
      IF (ERR01 .OR. ERR06) GO TO 10
!
      CALL LDSCMP(3, 0, 0, 0, 0, 0, 'D', K + 3*N, LDSMIN)
!
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR07, LLDS)
!
!
      IF (ERR02 .OR. ERR03 .OR. ERR04 .OR. ERR05 .OR. ERR07) GO TO 10
      GO TO 20
!
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   20 CONTINUE
      CALL STKSET (LDSTAK, 4)
      NALL0 = STKST(1)
!
      IFP = 4
!
      AMPL = STKGET(N, IFP)
      PHASE = STKGET(2*N, IFP)
      HLP = STKGET(K, IFP)
!
      IF (IERR .EQ. 1) GO TO 10
!
      CALL DEMDRV(Y, N, FD, FC, K, RSTAK(HLP), RSTAK(AMPL),
     +   RSTAK(PHASE), N, NDEM, 1, NMSUB)
!
      CALL STKCLR(NALL0)
!
      IF (IERR .EQ. 1) GO TO 10
!
      RETURN
!
!     FORMAT STATEMENT
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL DEMOD (Y, N, FD, FC, K, LDSTAK)')
!
      END
!AOV1
      SUBROUTINE AOV1(Y, TAG, N, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE -
!     1. CALLS OTHER ROUTINES TO CHECK THE INPUT PARAMETERS
!     2. SETS UP THE NEEDED STORAGE LOCATIONS, AND
!     3. CALLS AOV1MN TO COMPUTE A COMPREHENSIVE SET OF RESULTS FOR A
!     ONEWAY ANALYSIS OF VARIANCE WITH AUTOMATIC PRINTOUT.
!
!     WRITTEN BY -
!       LINDA MITCHELL
!       STATISTICAL ENGINEERING DIVISION
!       NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!                       BASED ON EARLIER VERSION BY J. R. DONALDSON
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   TAG(*),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   B10,DTMEAN,DTSD,DTSIZE,GPMAX,GPMIN,IFP,INDEX,INT,IPRT,
     +   ITEMP,NALL0,NG,NPRT,NZTAGS,RANKS,SRANK,TVAL
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET
      EXTERNAL STKGET
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AOV1ER,AOV1HD,AOV1MN,IPRINT,STKCLR
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER B10
!        STARTING LOCATION IN THE STACK AREA FOR B10
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER DTMEAN
!        THE STARTING LOCATION IN THE STACK AREA FOR THE MEANS
!        OF EACH GROUP
!     INTEGER DTSD
!        THE STARTING LOCATION IN THE STACK AREA OF THE
!        STANDARD DEVIATIONS
!     INTEGER DTSIZE
!        THE STARTING LOCATION IN THE STACK AREA OF THE SIZE OF THE
!        DIFFERENT GROUPS
!     INTEGER GPMAX
!        THE STARTING LOCATION IN THE STACK AREA OF MAXIMUM
!        OBSERVATION
!     INTEGER GPMIN
!        THE STARTING LOCATION IN THE STACK AREA OF THE MINUMUM
!        OBSERVATION
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG INDICATING WHETHER THERE
!        ARE ANY ERRORS, IF = 0 THEN NO ERRORS
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INDEX
!        THE STARTING LOCATION IN THE STACK ARRAY OF THE INDEX FOR
!        THE SORTED TAGS
!     INTEGER INT
!        FRAMEWORK CODE VALUE FOR INTEGER NUMBERS
!     INTEGER IPRT
!        THE OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ITEMP
!        STARTING LOCATION IN THE STACK FOR THE
!        TEMPORARY STORAGE ARRAY
!     INTEGER LDSTAK
!        SIZE OF THE STACK AREA ALLOCATED IN THE USERS MAIN PROGRAM
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS TO BE ANALYZED
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT THIS
!        ROUTINE WAS CALLED.
!     INTEGER NG
!        THE NUMBER OF GROUPS WITH DIFFERENT POSITIVE TAG VALUES
!     CHARACTER*1 NMSUB(6)
!        SUBROUTINE NAME
!     INTEGER NPRT
!        THE VARIABLE CONTROLLING AUTOMATIC PRINTOUT
!        IF =0, PRINTOUT IS SUPRESSED
!        OTHERWISE PRINTOUT IS PROVIDED
!     INTEGER NZTAGS
!        THE NUMBER OF OBSERVATIONS WITH POSITIVE NON-ZERO WIEGHTS
!     INTEGER RANKS
!        THE STARTING LOCATION IN WORK AREA FOR THE RANKS OF Y
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SRANK
!        THE STARTING LOCATION IN STACK FOR THE SUM OF RANKS
!     DOUBLE PRECISION TAG(N)
!        THE VECTOR OF TAG VALUES
!     INTEGER TVAL
!        THE STARTING LOCATION IN THE STACK FOR THE VECTOR OF
!        THE DIFFERENT POSITIVE TAG VALUES, FOR AOV1
!     DOUBLE PRECISION Y(N)
!        THE VECTOR OF OBSERVATIONS
!
      DATA   NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +     /      'A',      'O',      'V',      '1',      ' ',      ' '/
!
      CALL IPRINT(IPRT)
!
!     SET UP FRAMEWORK VARIABLES FOR NUMBER TYPES
!
      INT = 2
      IFP = 4
!
!     CHECK FOR ERRORS IN PARAMETERS, INITIALIZE STACK, AND SET NALL0.
!
      CALL AOV1ER(Y, TAG, N, N, NZTAGS, NG, LDSTAK, NMSUB, INDEX, 1,
     +   NALL0)
!
      IF (IERR.EQ.0) GO TO 20
!
!     PRINT CORRECT FORM OF CALL STATEMENT AND RETURN TO CALLER
!
      IERR = 1
      WRITE (IPRT,1000)
      RETURN
!
!     PRINT HEADING
!
   20 CALL AOV1HD(IPRT)
!
!     SET UP ADDITIONAL WORK VECTORS FOR AOV1MN AS CALLED FROM AOV1
!
      TVAL = STKGET(NG,IFP)
      DTSIZE = STKGET(NG,IFP)
      DTMEAN = STKGET(NG,IFP)
      DTSD = STKGET(NG,IFP)
      SRANK = STKGET(NG,IFP)
      GPMIN = STKGET(NG,IFP)
      GPMAX = STKGET(NG,IFP)
      B10 = STKGET(NG,IFP)
      RANKS = STKGET(NZTAGS,IFP)
      ITEMP = STKGET(NZTAGS,INT)
!
      NPRT = 1
!
      CALL AOV1MN(Y, TAG, N, RSTAK(TVAL), RSTAK(DTSIZE), RSTAK(DTMEAN),
     +   RSTAK(DTSD), NPRT, ISTAK(INDEX), RSTAK(SRANK), RSTAK(GPMIN),
     +   RSTAK(GPMAX), RSTAK(B10), RSTAK(RANKS),
     +   ISTAK(ITEMP), NG, NZTAGS)
!
!     RELEASE THE STACK AREA
!
      CALL STKCLR(NALL0)
!
      RETURN
!
!     FORMAT STATEMENT
!
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL AOV1 (Y, TAG, N, LDSTAK)')
      END
!NLSX1
      SUBROUTINE NLSX1(MOD, PAR, NPAR, PV, SDPV, RES, SDRES, VCV, N,
     +   IVCV, NNZW, NPARE, RSD)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     SET THE STARTING PARAMETER VALUES FOR NLSX
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,MOD,N,NNZW,NPAR,NPARE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PV(N),RES(N),SDPV(N),SDRES(N),VCV(IVCV,IVCV)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   I,J
!
!  EXTERNAL SUBROUTINES
      EXTERNAL SETRV
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IVCV
!        THE ACTUAL FIRST DIMENSION OF VCV.
!     INTEGER MOD
!        AN INDICATOR VALUE USED TO DESIGNATE THE MODEL FOR WHICH
!        THE PARAMETERS ARE TO BE SET.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!        TO BE PROVIDED.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
!     INTEGER NNZW
!        THE NUMBER OF NONZERO WEIGHTS.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUES.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     DOUBLE PRECISION SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(N)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION VCV(IVCV,IVCV)
!        THE VARIANCE COVARIANCE MATRIX.
!
!
!
      GO TO (10, 20, 30, 40, 50, 60), MOD
!
   10 PAR(1) = 0.725D0
      PAR(2) = 4.0D0
!
      GO TO 70
!
!
   20 PAR(1) = 1.0D0
      PAR(2) = 2.0D0
      PAR(3) = 3.0D0
!
      GO TO 70
!
!
   30 PAR(1) = 6.0D0
      PAR(2) = 5.0D0
      PAR(3) = 4.0D0
      PAR(4) = 3.0D0
      PAR(5) = 2.0D0
!
      GO TO 70
!
!
   40 CALL SETRV(PAR, NPAR, 0.0D0)
!
      GO TO 70
!
!
   50 CALL SETRV(PAR, NPAR, 0.5D0)
!
      GO TO 70
!
!
   60 PAR(1) = 100.0D0
      PAR(2) = 15.0D0
!
   70 CONTINUE
!
      DO 80 I=1,N
         RES(I) = -1.0D0
         PV(I) = -1.0D0
         SDPV(I) = -1.0D0
         SDRES(I) = -1.0D0
   80 CONTINUE
!
      DO 100 I=1,IVCV
         DO 90 J=1,IVCV
            VCV(I,J) = -1.0D0
   90    CONTINUE
  100 CONTINUE
!
      NNZW = -1
      NPARE = -1
      RSD = -1.0D0
!
      IERR = -1
!
      RETURN
!
      END
!ERVWT
      SUBROUTINE ERVWT (NMSUB, NMVAR1, WT, N, NNZWMN, HEAD, NNZW,
     +   NZW, MSGTYP, ERROR, NMVAR2)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS USER SUPPLIED WEIGHTS TO ASSURE THERE
!     ARE NO NEGATIVE WEIGHTS, AND THAT THERE ARE SUFFICIENT POSITIVE
!     WEIGHTS FOR THE TASK.  IT RETURNS ERROR SET TO TRUE
!     IF NO ERRORS ARE FOUND, AND SET TO FALSE OTHERWISE, AND IN
!     ADDITION, RETURNS THE NUMBER OF NONZERO WEIGHTS AND THE NUMBER
!     OF ZERO WEIGHTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   MSGTYP,N,NNZW,NNZWMN,NZW
      LOGICAL
     +   ERROR,HEAD
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   WT(*)
      CHARACTER
     +   NMSUB(6)*1,NMVAR1(8)*1,NMVAR2(8)*1
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
!        PRINTED, WHERE IF ERROR IS TRUE AND
!        MSGTYP = 1, THE INPUT VALUE WAS TOO SMALL BASED ON LIMITS
!                    IMPOSED BY STARPAC.
!        MSGTYP = 2, THE INPUT VALUE WAS TOO SMALL BASED ON OTHER
!                    INPUT ARGUMENTS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR1(8)
!        THE CHARACTERS OF THE NAME OF THE ARGUMENT BEING CHECKED.
!     CHARACTER*1 NMVAR2(8)
!        THE CHARACTERS OF THE NAME OF THE ARGUMENT BEING CHECKED
!        AGAINST.
!     INTEGER NNZW
!        THE NUMBER OF NONZERO WEIGHTS.
!     INTEGER NNZWMN
!        THE MINIMUM NUMBER OF NONZERO WEIGHTS WHICH IS ACCEPTABLE.
!     INTEGER NZW
!        THE NUMBER OF ZERO WEIGHTS.
!     DOUBLE PRECISION WT(N)
!        THE WEIGHT VECTOR.
!
      ERROR = .FALSE.
!
      IF (N.LE.0) RETURN
!
!     CHECK FOR NEGATIVE WEIGHTS AND COUNT NUMBER OF ZERO WEIGHTS.
!
      NZW = 0
      DO 10 I = 1, N
         IF (WT(I) .LT. 0.0D0) GO TO 20
         IF (WT(I) .EQ. 0.0D0) NZW = NZW + 1
   10 CONTINUE
!
      NNZW = N - NZW
      IF (NNZW .GE. NNZWMN) RETURN
!
!     INSUFFICIENT NUMBER OF POSITIVE WEIGHTS FOUND
!
      ERROR = .TRUE.
!
      CALL IPRINT(IPRT)
!
      CALL EHDR(NMSUB, HEAD)
!
      WRITE (IPRT, 1010) NNZW
      IF (MSGTYP.EQ.1) WRITE(IPRT, 1030) (NMVAR1(I), I=1,6), NNZWMN
      IF (MSGTYP.EQ.2) WRITE(IPRT,1040) (NMVAR1(I),I=1,6),
     +   (NMVAR2(I),I=1,8)
!
      RETURN
!
!     NEGATIVE WEIGHTS FOUND
!
   20 ERROR = .TRUE.
!
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
      WRITE(IPRT, 1020) (NMVAR1(I), I = 1, 6)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1010 FORMAT(/
     +   40H THE NUMBER OF NONZERO WEIGHTS FOUND IS , I6, '.')
 1020 FORMAT(/
     +   42H NEGATIVE VALUES WERE FOUND IN THE VECTOR , 6A1, '.'/
     +   51H ALL WEIGHTS MUST BE GREATER THAN OR EQUAL TO ZERO.)
 1030 FORMAT(
     +   34H THE NUMBER OF NONZERO WEIGHTS IN , 6A1,
     +   34H MUST BE GREATER THAN OR EQUAL TO , I6, '.')
 1040 FORMAT(
     +   34H THE NUMBER OF NONZERO WEIGHTS IN , 6A1,
     +   34H MUST BE GREATER THAN OR EQUAL TO , 8A1, '.')
!
      END
!DFBW
      SUBROUTINE DFBW (N, LAG, W, LW, DF, BW)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES AND STORES THE ASSOCIATED DEGREES OF
!     FREEDOM AND BANDWIDTH FOR A GIVEN LAG WINDOW.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   BW,DF
      INTEGER
     +   LAG,LW,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   W(LW)
!
!  LOCAL SCALARS
      INTEGER
     +   K
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION BW
!        THE BANDWIDTH.
!     DOUBLE PRECISION DF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     INTEGER K
!        AN INDEX VARIABLE
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES.
!     DOUBLE PRECISION W(LW)
!        THE VECTOR OF LAG WINDOWS.
!
      BW = 0.0_WP
      DO 10 K = 1, LAG
         BW = BW + W(K+1) * W(K+1) * (N-K)
   10 CONTINUE
!
      BW = 1.0_WP / (W(1)*W(1) + 2.0_WP*BW/N)
      DF = 2.0_WP * BW * N
      RETURN
      END
!CPYASF
      SUBROUTINE CPYASF (M, X, LX, Y, IY)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COPIES THE ELEMENTS OF SYMMETRIC MATRIX X,
!     STORED ROW WISE, TO MATRIX Y.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IY,LX,M
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),Y(IY,*)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IJ,J
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER IY
!        THE FIRST DIMENSION OF THE MATRIX Y.
!     INTEGER J
!        AN INDEX VALUE.
!     INTEGER LX
!        THE LENGTH OF SYMMETRIC MATRIX X, STORED ROW WISE.
!     INTEGER M
!        THE NUMBER OF COLUMNS OF DATA TO BE COPIED FROM MATRIX X.
!     DOUBLE PRECISION X(LX)
!        THE MATRIX TO BE COPIED FROM.
!     DOUBLE PRECISION Y(IY,M)
!        THE MATRIX TO BE COPIED TO.
!
      DO 20 I = 1, M
         DO 10 J = 1, I
            IJ = I*(I-1)/2 + J
            Y(I,J) = X(IJ)
            Y(J,I) = Y(I,J)
   10    CONTINUE
   20 CONTINUE
!
      RETURN
!
      END
!SRTRI
      SUBROUTINE SRTRI(A, LA, IR)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!   FUNCTION     SRTRI  - SORT ARRAY A ON AN INTEGER ARRAY IR.
!                           IF THE INTEGER ARRAY IS A PERMUTATION
!                           VECTOR FOR THE ARRAY, THEN THE
!                           ARRAY IS RESTORED TO ITS ORIGINAL
!                           (UNPERMUTED) ORDER.
!                           PERMUTATIONS RETURNED
!   USAGE               - CALL SRTRI (A,LA,IR)
!   PARAMETERS   A(LA)  - ON INPUT, CONTAINS THE ARRAY TO BE SORTED
!                         ON OUTPUT, A CONTAINS THE SORTED ARRAY
!                LA     - INPUT VARIABLE CONTAINING THE NUMBER OF
!                           ELEMENTS IN THE ARRAY TO BE SORTED
!                IR(LA) - ON INPUT, CONTAINS THE INTEGER KEY ARRAY
!                         ON OUTPUT, CONTAINS THE SORTED KEY ARRAY
!                           1,2,...,LA.
!                       - THEN ON OUTPUT, IR CONTAINS A RECORD OF THE
!                           PERMUTATIONS MADE ON THE VECTOR A.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LA
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   A(LA)
      INTEGER
     +   IR(LA)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   R,T,TT
      INTEGER
     +   I,IJ,IT,ITT,J,K,L,M
!
!  LOCAL ARRAYS
      INTEGER
     +   IL(21),IU(21)
!
!  INTRINSIC FUNCTIONS
      INTRINSIC INT
!
!
      M = 1
      I = 1
      J = LA
      R = .375D0
   10 IF (I.EQ.J) GO TO 90
      IF (R.GT.0.5898437D0) GO TO 20
      R = R + 3.90625D-2
      GO TO 30
   20 R = R - .21875D0
   30 K = I
!                                  SELECT A CENTRAL ELEMENT OF THE
!                                  ARRAY AND SAVE IT IN LOCATION IT
      IJ = I + INT((J-I)*R)
      T = A(IJ)
      IT = IR(IJ)
!                                  IF FIRST ELEMENT OF ARRAY IS GREATER
!                                  THAN IT, INTERCHANGE WITH IT
      IF (IR(I).LE.IT) GO TO 40
      A(IJ) = A(I)
      A(I) = T
      T = A(IJ)
      IR(IJ) = IR(I)
      IR(I) = IT
      IT = IR(IJ)
   40 L = J
!                                  IF LAST ELEMENT OF ARRAY IS LESS THAN
!                                  IT, INTERCHANGE WITH IT
      IF (IR(J).GE.IT) GO TO 60
      A(IJ) = A(J)
      A(J) = T
      T = A(IJ)
      IR(IJ) = IR(J)
      IR(J) = IT
      IT = IR(IJ)
!                                  IF FIRST ELEMENT OF ARRAY IS GREATER
!                                  THAN IT, INTERCHANGE WITH IT
      IF (IR(I).LE.IT) GO TO 60
      A(IJ) = A(I)
      A(I) = T
      T = A(IJ)
      IR(IJ) = IR(I)
      IR(I) = IT
      IT = IR(IJ)
      GO TO 60
   50 TT = A(L)
      A(L) = A(K)
      A(K) = TT
      ITT = IR(L)
      IR(L) = IR(K)
      IR(K) = ITT
!                                  FIND AN ELEMENT IN THE SECOND HALF OF
!                                  THE ARRAY WHICH IS SMALLER THAN IT
   60 L = L - 1
      IF (IR(L).GT.IT) GO TO 60
!                                  FIND AN ELEMENT IN THE FIRST HALF OF
!                                  THE ARRAY WHICH IS GREATER THAN IT
   70 K = K + 1
      IF (IR(K).LT.IT) GO TO 70
!                                  INTERCHANGE THESE ELEMENTS
      IF (K.LE.L) GO TO 50
!                                  SAVE UPPER AND LOWER SUBSCRIPTS OF
!                                  THE ARRAY YET TO BE SORTED
      IF (L-I.LE.J-K) GO TO 80
      IL(M) = I
      IU(M) = L
      I = K
      M = M + 1
      GO TO 100
   80 IL(M) = K
      IU(M) = J
      J = L
      M = M + 1
      GO TO 100
!                                  BEGIN AGAIN ON ANOTHER PORTION OF
!                                  THE UNSORTED ARRAY
   90 M = M - 1
      IF (M.EQ.0) RETURN
      I = IL(M)
      J = IU(M)
  100 IF (J-I.GE.1) GO TO 30
      IF (I.EQ.1) GO TO 10
      I = I - 1
  110 I = I + 1
      IF (I.EQ.J) GO TO 90
      T = A(I+1)
      IT = IR(I+1)
      IF (IR(I).LE.IT) GO TO 110
      K = I
  120 A(K+1) = A(K)
      IR(K+1) = IR(K)
      K = K - 1
      IF (IT.LT.IR(K)) GO TO 120
      A(K+1) = T
      IR(K+1) = IT
      GO TO 110
      END
!DCKLS1
      SUBROUTINE DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE,
     +   NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     SET UP PROBLEM SPECIFICATION FOR TESTING THE USER CALLABLE
!     ROUTINES IN THE (LEAST SQUARES) STEP SIZE SELECTION FAMILY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NETA,NPAR,NPRT,NROW,NTAU
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(10),SCALE(10)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
!     DOUBLE PRECISION PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION SCALE(10)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!
!
      PAR(1) = 1.0D0
      PAR(2) = 3.125D0
      PAR(3) = 1.0D0
      PAR(4) = 2.0D0
!
      N = 101
      M = 1
      IXM = 200
      NPAR = 4
      DO 10 I=1,10
         SCALE(I) = 1.0D0
   10 CONTINUE
      SCALE(2) = 0.01D0
      NETA = 0
      NTAU = 0
      NROW = 1
      NPRT = 1
!
      RETURN
!
      END
!LLSPW
      SUBROUTINE LLSPW(Y, WT, XM, N, NDEG, RES, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CALL FOR POLYNOMIAL MODEL LEAST SQUARES FIT
!     USER SUPPLIED WEIGHTS SPECIFIED
!     NO STORAGE OTHER THAN RESIDUALS
!     FOUR PAGES AUTOMATIC PRINTOUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK,N,NDEG
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RES(*),WT(*),XM(*),Y(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IPRT,IVCV,LPAR,LPV,LSDPV,LSDRES,LWT,NPAR,NPRT
      LOGICAL
     +   SAVE,WEIGHT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(1),PV(1),SDPV(1),SDRES(1),VCV(1,1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LLCNTP
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDEG
!        THE DEGREE OF THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     DOUBLE PRECISION PAR(1)
!        A DUMMY ARRAY FOR
!        THE PARAMETERS  TO BE ESTIMATED.
!     DOUBLE PRECISION PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUES.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(N)
!        A DUMMY ARRAY FOR
!        THE WEIGHTS.
!     DOUBLE PRECISION XM(N,1)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'L','L','S','P','W',' '/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      WEIGHT = .TRUE.
      SAVE = .FALSE.
      NPRT = 1111
      LPAR = 1
      LPV = 1
      LSDPV = 1
      LSDRES = 1
      IVCV = 1
      LWT = N
!
      CALL LLCNTP(Y, WT, LWT, XM, N, NDEG, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (//42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   50H       CALL LLSPW (Y, WT, X, N, NDEG, RES, LSDTAK))
      END
!PARZEN
      SUBROUTINE PARZEN (LAG, W, LW)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES AND STORES THE PARZEN LAG WINDOW
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LAG,LW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   W(LW)
!
!  LOCAL SCALARS
      INTEGER
     +   K,L
!
!  INTRINSIC FUNCTIONS
      INTRINSIC DBLE
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER K
!        AN INDEX VARIABLE
!     INTEGER L
!        THE VALUE LAG/2.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     DOUBLE PRECISION W(LW)
!        THE VECTOR OF LAG WINDOWS.
!
      L = LAG/2
      W(1) = 1.0D0
      IF (L.LE.0) GO TO 15
      DO 10 K = 1, L
         W(K+1) = DBLE(K) / DBLE(LAG)
         W(K+1) = 1.0D0 + 6.0D0 * W(K+1) * W(K+1) * (W(K+1) - 1.0D0)
   10 CONTINUE
!
   15 CONTINUE
      L = L + 1
      DO 20 K = L, LAG
         W(K+1) = 1.0D0 - DBLE(K) / DBLE(LAG)
         W(K+1) = 2.0D0 * W(K+1) * W(K+1) * W(K+1)
   20 CONTINUE
!
      RETURN
      END
!SUMBS
      SUBROUTINE SUMBS(X, N, LO, MID, HI)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO FIND A ZERO OR VALUE CLOSEST TO ZERO IN
!     A SORTED VECTOR.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   HI,LO,MID,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(N)
!
!  LOCAL SCALARS
      INTEGER
     +   CURHI,CURLO
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CURHI
!        THE UPPER BOUND OF THE CURRENT INTERVAL.
!     INTEGER CURLO
!        THE LOWER BOUND OF THE CURRENT INTERVAL.
!     INTEGER HI
!        INPUT PARAMETER.  THE UPPER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER LO
!        INPUT PARAMETER.  THE LOWER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER MID
!        OUTPUT PARAMETER.  THE MIDPOINT OF THE CURRENT
!        INTERVAL, AND ON EXIT THE POINT IN THE INITIAL
!        INTERVAL CLOSEST TO ZERO.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
!     DOUBLE PRECISION X(N)
!        INPUT PARAMETER.  THE ARRAY X IN WHICH THE SEARCH FOR
!        A (NEAR) ZERO VALUE IS MADE.
!
!     BINARY SEARCH OF X FOR 0.0D0 OR CLOSEST TO IT.
!
      CURLO = LO
      CURHI = HI
!
!     SEE IF ZERO IS OUT OF THE RANGE X(LO) TO X(HI).
!
      IF (X(CURLO).LT.0.0D0) GO TO 10
      MID = CURLO
      GO TO 50
   10 IF (X(CURHI).GT.0.0D0) GO TO 20
      MID = CURHI
      GO TO 50
!
!     LOCATE EITHER A ZERO OR A PAIR OF ADJACENT VALUES BETWEEN
!     WHICH THERE LIES A ZERO.
!
   20 IF (CURLO+1.EQ.CURHI) GO TO 30
      MID = (CURLO+CURHI)/2
      IF (0.0D0.LT.X(MID)) CURHI = MID
      IF (0.0D0.GT.X(MID)) CURLO = MID
      IF (0.0D0.EQ.X(MID)) GO TO 50
      GO TO 20
!
!     PICK AS MIDPOINT THE CURRENT ENDPOINT CLOSEST TO ZERO.
!
   30 IF (X(CURHI)+X(CURLO).GT.0.0D0) GO TO 40
      MID = CURHI
      GO TO 50
   40 MID = CURLO
   50 RETURN
      END
!FFTCT
      SUBROUTINE FFTCT(X, N2, IX)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     COSINE TRANSFORM OF N=2*N2 SYMMETRIC DATA POINTS
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IX,N2
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(IX)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   A2,AA,AB,CD,CN,EX,PI,SAVE,SD,SN
      INTEGER
     +   I,ISN,J,K,M,M1,N1,NK
!
!  EXTERNAL SUBROUTINES
      EXTERNAL FFT,GETPI,REALTR
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AA, AB, A2
!     DOUBLE PRECISION CD, CN
!     DOUBLE PRECISION EX
!     INTEGER I, ISN
!     INTEGER IX
!        THE DIMENSION OF X.
!     INTEGER J
!     INTEGER K
!     INTEGER M, M1
!     INTEGER NK, N1
!     INTEGER N2
!        THE HALF LENGTH OF THE SYMMETRIC DATA ARRAY.  N2 MUST BE EVEN.
!     DOUBLE PRECISION PI
!        THE VALUE OF PI.
!     DOUBLE PRECISION SAVE, SD, SN
!     DOUBLE PRECISION X(IX)
!        THE N2+2 VECTOR WITH FIRST HALF OF SYMMETRIC DATA STORED IN
!        THE FIRST N2+1 LOCATIONS.  LOCATION N2+2 USED ONLY FOR
!        WORKSPACE.  THE COSINE TRANSFORM COEFFICIENTS ARE RETURNED
!        IN THE FIRST N2+1 LOCATIONS OF X.
!
      CALL GETPI(PI)
!
      A2 = 0.0D0
      N1 = N2 + 1
      DO 10 J=2,N2,2
         A2 = A2 + X(J)
   10 CONTINUE
      A2 = 2.0D0*A2
      M = N2/2
      M1 = M + 1
      EX = X(2)
      X(2) = 0.0D0
      IF (N1.LT.4) GO TO 30
      DO 20 I=4,N1,2
         SAVE = EX - X(I)
         EX = X(I)
         X(I) = SAVE
   20 CONTINUE
   30 X(N2+2) = 0.0D0
      ISN = -2
      CALL REALTR(X, X(2), M, ISN)
      CALL FFT(X, X(2), M, M, M, ISN)
      SD = PI / (2*N2)
      CD = 2.0D0*SIN(SD)**2
      SD = SIN(SD+SD)
      SN = 0.0D0
      CN = 1.0D0
      NK = N2 + 2
      DO 40 J=2,M1
         K = NK - J
         AA = X(J) + X(K)
         AB = (X(J)-X(K))*0.5D0
         EX = CN - (CD*CN+SD*SN)
         SN = (SD*CN-CD*SN) + SN
         CN = 0.5D0/(EX*EX+SN*SN) + 0.5D0
         SN = CN*SN
         CN = CN*EX
         EX = AB/SN
         X(J) = (AA+EX)*0.5D0
         X(K) = (AA-EX)*0.5D0
   40 CONTINUE
      EX = X(1)
      X(1) = EX + A2
      X(N2+1) = EX - A2
      X(N2+2) = 0.0D0
      RETURN
      END
!CORRER
      SUBROUTINE CORRER(NMSUB, M, N, IYM, IVCV, LDSTAK, ICOR, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS FOR ERRORS IN THE INPUT
!     PARAMETERS.  IF ANY ARE FOUND A FLAG IS SET AND
!     COMPUTATION STOPS
!
!     WRITTEN BY -
!        LINDA L. MITCHELL
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ICOR,IVCV,IYM,LDSTAK,M,N,NPRT
!
!  ARRAY ARGUMENTS
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IP,IPRT,IS,LDSMIN
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,HEAD
!
!  LOCAL ARRAYS
      CHARACTER
     +   LIVCV(8)*1,LIYM(8)*1,LLDS(8)*1,LM(8)*1,LN(8)*1,
     +   LTHREE(8)*1,LTWO(8)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,IPRINT,LDSCMP
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
!                  VALUE(S) INDICATING WHETHER OR ERROR WAS DETECTED
!                  (TRUE) OR NOT (FALSE).
!     LOGICAL HEAD
!                  A FLAG INDICATING WHETHER THE HEADING SHOULD BE
!                  PRINTED (TRUE) OR NOT (FALSE).  IF A HEADING IS
!                  PRINTED, THE VALUE OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER ICOR
!                  DETERMINES WHICH SUBROUTINE CALLED CORRER
!                  IF =1, THEN CALLED BY CORR
!                     =2, THEN CALLED BY CORRS
!     INTEGER IERR
!                  A FLAG, THAT WHEN RETURNED BY THIS ROUTINE DESIGNATES
!                  WHETHER  ERRORS WERE DETECTED IN THE PARAMETER LIST
!                  IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!                  IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IP
!                  A TEMPORARY VARIABLE USED FOR COMPUTING LDSMIN.
!     INTEGER IPRT
!                  THE LOGICAL OUTPUT UNIT
!     INTEGER IS
!                  A TEMPORARY VARIABLE USED FOR COMPUTING LDSMIN.
!     INTEGER IVCV
!                  THE DIMENSION OF SC
!     INTEGER IYM
!                  ACTUAL ROW DIMENSION OF YM
!     INTEGER LDSMIN
!                  THE MINIMUM LENGTH ALLOWED FOR DSTAK
!     INTEGER LDSTAK
!                  THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK
!     CHARACTER*1 LIVCV(8), LIYM(8), LLDS(8), LM(8), LN(8), LTHREE(8),
!    *  LTWO(8)
!                  THE ARRAY(S) CONTAINING THE NAME(S) OF THE
!                  VARIABLE(S) CHECKED FOR ERRORS.
!     INTEGER M
!                  NUMBER OF VARIABLES
!     INTEGER N
!                  THE NUMBER OFOBSERVATIONS
!     CHARACTER*1 NMSUB(6)
!                  THE NAME OF THE CALLING SUBROUTINE.
!     INTEGER NPRT
!                  THE VARIABLE CONTROLLING THE PRINTED OUTPUT.
!                  IF NPRT=0, OUTPUT IS SUPPRESSED, OTHERWISE IT IS NOT
!
!
!     SET UP NAME ARRAYS
!
      DATA  LIVCV(1), LIVCV(2), LIVCV(3), LIVCV(4), LIVCV(5), LIVCV(6),
     +      LIVCV(7), LIVCV(8) / 'I', 'V', 'C', 'V', ' ', ' ', ' ', ' '/
      DATA   LIYM(1),  LIYM(2),  LIYM(3),  LIYM(4),  LIYM(5),  LIYM(6),
     +       LIYM(7),  LIYM(8) / 'I', 'Y', 'M', ' ', ' ', ' ', ' ', ' '/
      DATA   LLDS(1),  LLDS(2),  LLDS(3),  LLDS(4),  LLDS(5),  LLDS(6),
     +       LLDS(7),  LLDS(8) / 'L', 'D', 'S', 'T', 'A', 'K', ' ', ' '/
      DATA     LM(1),    LM(2),    LM(3),    LM(4),    LM(5),    LM(6),
     +         LM(7),    LM(8) / 'M', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA     LN(1),    LN(2),    LN(3),    LN(4),    LN(5),    LN(6),
     +         LN(7),    LN(8) / 'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA LTHREE(1),LTHREE(2),LTHREE(3),LTHREE(4),LTHREE(5),LTHREE(6),
     +     LTHREE(7),LTHREE(8) / 'T', 'H', 'R', 'E', 'E', ' ', ' ', ' '/
      DATA   LTWO(1),  LTWO(2),  LTWO(3),  LTWO(4),  LTWO(5),  LTWO(6),
     +       LTWO(7),  LTWO(8) / 'T', 'W', 'O', ' ', ' ', ' ', ' ', ' '/
!
      CALL IPRINT(IPRT)
!
      HEAD = .TRUE.
!
      IERR = 0
!
!     BEGIN ERROR CHECKING. THE COMMENTS STATE WHAT CONSTITUTES AN
!     ERROR. COMMENTS ENCLOSED BY STARS(**) INDICATE THE ERROR CONDITION
!
!     **NUMBER OF VARIABLES LESS THAN 2**
!
      CALL EISGE(NMSUB, LM, M, 2, 2, HEAD, ERR01, LTWO)
!
!     **NUMBER OF OBSERVATIONS LESS THAN 3**
!
      CALL EISGE(NMSUB, LN, N, 3, 2, HEAD, ERR02, LTHREE)
!
!     **OBSERVATION MATRIX DIMENSIONED LESS THAN N**
!
      ERR03 = .FALSE.
      IF (.NOT.ERR02) CALL EISGE(NMSUB, LIYM, IYM, N, 3, HEAD, ERR03,
     +   LN)
!
!     **SC MATRIX DIMENSIONED LESS THAN M**
!
      ERR04 = .FALSE.
      IF ((ICOR.EQ.2) .AND. (.NOT.ERR01)) CALL EISGE(NMSUB, LIVCV,
     +   IVCV, M, 3, HEAD, ERR04, LM)
!
      IF (ERR01 .OR. ERR02) GO TO 40
      IS = 0
      IF (ICOR.EQ.1) IS = 1
!
      IP = 1
      IF (NPRT.EQ.0) IP = 0
!
!
!     CHECK FOR ENOUGH COMMON FOR THIS PROBLEM
!
      CALL LDSCMP(12, 0, IP*MAX(N,M), 0, 0, 0, 'D',
     +   IS*M*M + IP*(MAX(N,M)+M+N*(M+3)+6*M*M), LDSMIN)
!
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR05, LLDS)
!
      IF (ERR01 .OR. ERR02 .OR. ERR03 .OR. ERR04 .OR. ERR05) GO TO 40
      RETURN
!
!     SET IERR TO INDICATE AN ERROR
!
   40 CONTINUE
      IERR = 1
      RETURN
      END
!XCORR
      SUBROUTINE XCORR(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE EXERCISES ALL ASPECTS OF THE CORRELATION
!     FAMILY ROUTINES
!
!     WRITTEN BY -
!        LINDA MITCHELL
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT,IVCV,IYM,J,LDSMIN,M,N
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   VCV(4,4),YM(10,4),Z(10,4)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CORR,CORRS,CORRXP,GENR,IPRINT,LDSCMP,MSGX,SETRA
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!         AN INDEX VARIABLE.
!     INTEGER IERR
!        COMMON FLAG INDICATING IF ANY ERRORS WERE DETECTED
!        IF IERR = 0, THEN NO ERRORS WERE FOUND
!     INTEGER IPRT
!        THE OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IVCV
!        THE ROW DIMENSION OF VCV
!     INTEGER IYM
!        THE ROW DIMENSION OF YM
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER LDSMIN
!        THE SMALLEST ACCEPTABLE SIZE OF COMMON AREA CSTAK
!     INTEGER LDSTAK
!        THE SIZE OF THE COMMON AREA CSTAK
!     INTEGER M
!        THE NUMBER OF VARIABLES
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     DOUBLE PRECISION VCV(4,4)
!        THE VARIANCE COVARIANCE MATRIX
!     DOUBLE PRECISION YM(10,4)
!        GENERAL DATA SET, FROM DRAPER AND SMITH
!     DOUBLE PRECISION Z(10,4)
!        TEST OBSERVATION MATRIX
!
!     THIS DATA SET TAKEN FROM
!        APPLIED REGRESSION ANALYSIS
!        DRAPER AND SMITH
!        PAGE 216
!
      DATA     YM(1,1),   YM(1,2),   YM(1,3),   YM(1,4)
     +    /      42.2D0,  11.2D0,  31.9D0, 167.1D0/
      DATA     YM(2,1),   YM(2,2),   YM(2,3),   YM(2,4)
     +    /      48.6D0,  10.6D0,  13.2D0, 174.4D0/
      DATA     YM(3,1),   YM(3,2),   YM(3,3),   YM(3,4)
     +    /      42.6D0,  10.6D0,  28.7D0, 160.8D0/
      DATA     YM(4,1),   YM(4,2),   YM(4,3),   YM(4,4)
     +    /      39.0D0,  10.4D0,  26.1D0, 162.0D0/
      DATA     YM(5,1),   YM(5,2),   YM(5,3),   YM(5,4)
     +    /      34.7D0,   9.3D0,  30.1D0, 140.8D0/
      DATA     YM(6,1),   YM(6,2),   YM(6,3),   YM(6,4)
     +    /      44.5D0,  10.8D0,   8.5D0, 174.6D0/
      DATA     YM(7,1),   YM(7,2),   YM(7,3),   YM(7,4)
     +    /      39.1D0,  10.7D0,  24.3D0, 163.7D0/
      DATA     YM(8,1),   YM(8,2),   YM(8,3),   YM(8,4)
     +    /      40.1D0,  10.0D0,  18.6D0, 174.5D0/
      DATA     YM(9,1),   YM(9,2),   YM(9,3),   YM(9,4)
     +    /      45.9D0,  12.0D0,  20.4D0, 185.7D0/
!
!     DETERMINE OUTPUT UNIT
!
      CALL IPRINT(IPRT)
!
      IVCV = 4
      IYM = 10
      M = 4
      N = 9
      IERR = 0
!
!**** TEST ROUTINES WITH CORRECT CALL STATEMENT *****
!
      WRITE (IPRT,1000)
      WRITE (IPRT,1010)
!
!     TEST CORR
!
      WRITE (IPRT,1020)
      WRITE (IPRT,1060)
      CALL CORR(YM, N, M, IYM, LDSTAK)
      CALL MSGX(0, IPRT)
!
!     TEST CORRS
!
!     PRINTOUT SUPPRESSED
!
      WRITE (IPRT,1030)
      WRITE (IPRT,1040)
      WRITE (IPRT,1060)
      CALL CORRS(YM, N, M, IYM, LDSTAK, 0, VCV, IVCV)
      CALL MSGX(0, IPRT)
!
!     PRINT STORED OUTPUT AND ZERO ARRAYS
!
      CALL CORRXP(M, VCV, IVCV, IPRT)
!
!     WITH PRINTOUT
!
      WRITE (IPRT,1050)
      WRITE (IPRT,1060)
      CALL CORRS(YM, N, M, IYM, LDSTAK, 1, VCV, IVCV)
      CALL MSGX(0, IPRT)
!
!     PRINT STORED OUTPUT
!
      CALL CORRXP(M, VCV, IVCV, IPRT)
!
!**** SPECIAL 2 COLUMN MATRIX ****
!
      WRITE (IPRT,1070)
      WRITE (IPRT,1060)
      CALL CORR(YM, N, 2, IYM, LDSTAK)
      CALL MSGX(0, IPRT)
!
!**** TEST WORK AREA REQUIREMENTS ****
!
!     TEST CORR
!
      CALL LDSCMP(12, 0, MAX(N,M), 0, 0, 0, 'D',
     +   M*M + (MAX(N,M)+M+N*(M+3)+6*M*M), LDSMIN)
      WRITE (IPRT,1090)
      CALL CORR(YM, N, M, IYM, LDSMIN-1)
      CALL MSGX(1, IPRT)
      WRITE (IPRT,1100)
      CALL CORR(YM, N, M, IYM, LDSMIN)
      CALL MSGX(0, IPRT)
!
!     TEST CORRS WITH PRINTOUT
!
      CALL LDSCMP(12, 0, MAX(N,M), 0, 0, 0, 'D',
     +   MAX(N,M)+M+N*(M+3)+6*M*M, LDSMIN)
      WRITE (IPRT,1090)
      CALL CORRS(YM, N, M, IYM, LDSMIN-1, 1, VCV, IVCV)
      CALL MSGX(1, IPRT)
      WRITE (IPRT,1100)
      CALL CORRS(YM, N, M, IYM, LDSMIN, 1, VCV, IVCV)
      CALL CORRXP(M, VCV, IVCV, IPRT)
      CALL MSGX(0, IPRT)
!
!     TEST CORRS WITHOUT PRINTOUT
!
      CALL LDSCMP(12, 0, 0, 0, 0, 0, 'D', 0, LDSMIN)
      WRITE (IPRT,1090)
      CALL CORRS(YM, N, M, IYM, LDSMIN-1, 0, VCV, IVCV)
      CALL MSGX(1, IPRT)
      WRITE (IPRT,1100)
      CALL CORRS(YM, N, M, IYM, LDSMIN, 0, VCV, IVCV)
      CALL CORRXP(M, VCV, IVCV, IPRT)
      CALL MSGX(0, IPRT)
!
!**** NUMBER OF VARIABLES LESS THAN 2 ****
!
      WRITE (IPRT,1110)
!
!     TEST CORR
!
      CALL CORR(YM, N, 1, IYM, LDSTAK)
      CALL MSGX(1, IPRT)
!
!     TEST CORRS
!
      CALL CORRS(YM, N, 1, IYM, LDSTAK, 1, VCV, IVCV)
      CALL MSGX(1, IPRT)
!
!**** NUMBER OF OBSERVATIONS LESS THAN 3 ****
!
      WRITE (IPRT,1120)
!
!     TEST CORR
!
      CALL CORR(YM, 2, 4, IYM, LDSTAK)
      CALL MSGX(1, IPRT)
!
!     TEST CORRS
!
      CALL CORRS(YM, 2, 4, IYM, LDSTAK, 1, VCV, IVCV)
      CALL MSGX(1, IPRT)
!
!**** OBSERVATION MATRIX DIMENSIONED LESS THAN N ****
!
      WRITE (IPRT,1150)
!
!     TEST CORR
!
      CALL CORR(YM, N, M, 8, LDSTAK)
      CALL MSGX(1, IPRT)
!
!     TEST CORRS
!
      CALL CORRS(YM, N, M, 8, LDSTAK, 1, VCV, IVCV)
      CALL MSGX(1, IPRT)
!
!**** VCV MATRIX DIMENSIONED LESS THAN M ****
!
      WRITE (IPRT,1130)
      CALL CORRS(YM, N, M, IYM, LDSTAK, 1, VCV, 2)
      CALL MSGX(1, IPRT)
!
!**** ALL OBSERVATIONS ON A SINGLE VARIABLE EQUAL TO ZERO ****
!
      WRITE (IPRT,1140)
      CALL SETRA(Z, 10, 4, 10, 0.0D0)
      CALL CORR(Z, 9, 4, 10, LDSTAK)
      CALL MSGX(1, IPRT)
      CALL CORRS(Z, 9, 4, 10, LDSTAK, 1, VCV, IVCV)
      CALL CORRXP(M, VCV, IVCV, IPRT)
      CALL MSGX(1, IPRT)
!
      DO 10 I=1,10
         Z(I,1) = I
         Z(I,2) = 0.0D0
   10 CONTINUE
      CALL CORR(Z, 10, 4, 10, LDSTAK)
      CALL MSGX(1, IPRT)
!
!**** ARRAY FILLED WITH A SINGLE VALUE ****
!
      WRITE (IPRT,1160)
      CALL SETRA(Z, 10, 4, 10, 4.0D0)
      CALL CORR(Z, 4, 10, 4, LDSTAK)
      CALL MSGX(1, IPRT)
!
!**** 2 COLUMNS THE SAME ****
!
      DO 20 I=1,3
         CALL GENR(Z(1,I), 5, 5.0D0*I, 5.0D0*I)
   20 CONTINUE
      DO 30 I=1,5
         Z(I,4) = Z(I,3)
   30 CONTINUE
      WRITE (IPRT,1170)
      CALL CORR(Z, 5, 4, 10, LDSTAK)
      CALL MSGX(1, IPRT)
!
!**** 2 COLUMNS INVERSELY RELATED ****
!
      J = 5
      DO 40 I=1,5
         J = J - 1
         Z(J,4) = Z(I,3)
   40 CONTINUE
      WRITE (IPRT,1170)
      CALL CORR(Z, 5, 4, 10, LDSTAK)
      CALL MSGX(1, IPRT)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT('1')
 1010 FORMAT(' ****TEST ROUTINES WITH CORRECT CALL****')
 1020 FORMAT(' TEST OF CORR')
 1030 FORMAT('1TEST OF CORRS')
 1040 FORMAT(' PRINTOUT SUPRESSED.')
 1050 FORMAT('1PRINTOUT NOT SUPRESSED.')
 1060 FORMAT(' DRAPER AND SMITH DATA SET (PAGE 216).')
 1070 FORMAT('1****SPECIAL CASE 2 COLUMN MATRIX****')
 1090 FORMAT('1****TEST WITH INSUFFICIENT WORK AREA****')
 1100 FORMAT('1****TEST WITH EXACTLY THE RIGHT AMOUNT OF WORK AREA****')
 1110 FORMAT('1****NUMBER OF VARIABLES LESS THAN 2****')
 1120 FORMAT(' ****NUMBER OF OBSERVATIONS LESS THAN 3****')
 1130 FORMAT(' ****INADEQUATE SPACE IN STORAGE ARRAYS****')
 1140 FORMAT('1****ALL OBSERVATIONS ON A VARIABLE EQUAL TO ZERO****')
 1150 FORMAT(' ****OBSERVATION MATRIX DIMENSIONED LESS THAN NUMBER',
     +       ' OF OBSERVATIONS DESIGNATED****')
 1160 FORMAT('1****ARRAY CONTAINING A SINGLE VALUE****')
 1170 FORMAT('1****2 COLUMNS RELATED****')
      END
!DEMODU
      SUBROUTINE DEMODU (Y, N, FD, AMPL, PHAS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE DEMODULATES THE SERIES Y AT FREQUENCY
!     FD.  THE REAL AND IMAGINARY PARTS OF THE DEMODULATED
!     SERIES ARE RETURNED IN AMPL AND PHAS, RESPECTIVELY.
!
!     WRITTEN BY  -  PETER BLOOMFIELD
!                    FOURIER ANALYSIS OF TIME SERIES- AN
!                       INTRODUCTION
!                    JOHN WILEY AND SONS, NEW YORK, 1976
!                    PAGE 148
!     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
!                                STATISTICAL ENGINEERING DEVISION
!                                NATIONAL BUREAU OF STANDARDS
!                                BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FD
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   AMPL(N),PHAS(N),Y(N)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ARG,PI
      INTEGER
     +   I
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GETPI
!
!  INTRINSIC FUNCTIONS
      INTRINSIC COS,SIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION AMPL(N)
!        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
!     DOUBLE PRECISION ARG
!        A VALUE USED IN COMPUTING THE DEMODULATED SERIES.
!     DOUBLE PRECISION FD
!        THE DEMODULATION FREQUENCY.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES BEING DEMODULATED.
!     DOUBLE PRECISION PHAS(N)
!        THE ARRAYS CONTAINING THE PRIMARY PHASE ESTIMATES.
!     DOUBLE PRECISION PI
!        THE VALUE OF PI.
!     DOUBLE PRECISION Y(N)
!        THE INPUT ARRAY ARRAY CONTAINING THE OBSERVED SERIES.
!
      CALL GETPI(PI)
!
      DO 10 I = 1, N
         IF (FD.EQ.0.25D0) THEN
            AMPL(I) = 0.0D0
            PHAS(I) = -2.0D0*Y(I)
         ELSE IF (FD.EQ.0.5D0) THEN
            AMPL(I) = -2.0D0*Y(I)
            PHAS(I) = 0.0D0
         ELSE
            ARG = (I-1) * FD * 2.0D0 * PI
            AMPL(I) = Y(I)*COS(ARG)*2.0D0
            PHAS(I) = -Y(I)*SIN(ARG)*2.0D0
         END IF
   10 CONTINUE
      RETURN
      END
!AIMFS
      SUBROUTINE AIMFS(Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK,
     +   NFCST, NFCSTO, IFCSTO, NPRT, FCST, IFCST, FCSTSD)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR ARIMA ESTIMATION
!     (CONTROL CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IFCST,LDSTAK,N,NFAC,NFCST,NFCSTO,NPAR,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FCST(*),FCSTSD(*),PAR(*),Y(*)
      INTEGER
     +   IFCSTO(*),MSPEC(4,*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,NFCSTU
      LOGICAL
     +   SAVE
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMFCNT,IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FCST(IFCST,NFCSTO)
!        THE STORAGE ARRAY FOR THE FORECASTS.
!     DOUBLE PRECISION FCSTSD(NFCST)
!        THE STORAGE ARRAY FOR THE STANDARD DEVIATIONS OF THE FORECASTS.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFCST
!        THE FIRST DIMENSION OF THE ARRAY FCST.
!     INTEGER IFCSTO(NFCSTO)
!        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER MSPEC(4,NFAC)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFCST
!        THE NUMBER OF FORECASTS.
!     INTEGER NFCSTO
!        THE NUMBER OF THE ORIGINS.
!     INTEGER NFCSTU
!        THE NUMBER OF FORCASTES ACTUALLY USED.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'A','I','M','F','S',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      SAVE = .TRUE.
!
      IF ((NFCST.GE.1) .AND. (NFCST.LE.N)) THEN
         NFCSTU = NFCST
      ELSE
         NFCSTU = (N/10)+1
      END IF
!
      CALL AMFCNT(Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK, NFCSTU,
     +   MAX(1,NFCSTO), IFCSTO, NPRT, FCST, IFCST, FCSTSD, NMSUB, SAVE)
!
      IF (IERR.NE.1) RETURN
!
!     PRINT PROPER CALL SEQUENCE
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/' THE CORRECT FORM OF THE CALL STATEMENT IS'//
     +  '       CALL AIMFS (Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK,'/
     +  '      +            NFCST, NFCSTO, IFCSTO, NPRT, FCST, IFCST,',
     +  ' FCSTSD)')
      END
!MAFLT
      SUBROUTINE MAFLT (Y, N, K, YF, NYF)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PERFORMS A SIMPLE MOVING AVERAGE FILTERING
!     OPERATION ON AN INPUT SERIES Y, RETURNING THE FILTERED SERIES
!     IN YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   K,N,NYF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*),YF(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   HMA
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD
!
!  LOCAL ARRAYS
      CHARACTER
     +   LK(8)*1,LN(8)*1,LONE(8)*1,NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,ERIODD,FLTMA,IPRINT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     DOUBLE PRECISION HMA
!        THE VALUE OF EACH OF THE SIMPLE MOVING AVERAGE LINEAR FILTER
!        COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS.
!     CHARACTER*1 LK(8), LN(8), LONE(8)
!        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES K AND N.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'M',       'A',       'F',       'L',       'T',       ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA
     +  LONE(1), LONE(2), LONE(3), LONE(4), LONE(5), LONE(6), LONE(7),
     +  LONE(8)  /  ' ', ' ', 'O', 'N', 'E', ' ', ' ', ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 3, 1, HEAD, ERR01, LN)
!
      CALL EISII(NMSUB, LK, K, 1, N, 1, HEAD, ERR02, LONE, LN)
!
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR03)
!
      IF (ERR01 .OR. ERR02 .OR. ERR03) GO TO 10
      GO TO 20
!
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   20 CONTINUE
!
!     COMPUTE THE SIMPLE MOVING AVERAGE COEFFICIENTS
!
      HMA = K
      HMA = 1.0D0/HMA
!
      CALL FLTMA (Y, N, K, HMA, YF, NYF)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL MAFLT (Y, N, K, YF, NYF)')
      END
!NLER
      SUBROUTINE NLER (NMSUB, WEIGHT, WT, LWT, N, M, IXM,
     +   IFIXED, LIFIXD, NPAR, NPARE,
     +   LDSTAK, LDSMIN, STP, LSTP, SCALE, LSCALE, IVCV, SAVE, NNZW)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE ERROR CHECKING ROUTINE FOR NONLINEAR LEAST SQUARES
!     ESTIMATION ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IVCV,IXM,LDSMIN,LDSTAK,LIFIXD,LSCALE,LSTP,LWT,M,N,NNZW,
     +   NPAR,NPARE
      LOGICAL
     +   SAVE,WEIGHT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   SCALE(*),STP(*),WT(*)
      INTEGER
     +   IFIXED(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   I,NFIX,NNFIX,NV,NZW
      LOGICAL
     +   HEAD
!
!  LOCAL ARRAYS
      LOGICAL
     +   ERROR(20)
      CHARACTER
     +   LIFIX(8)*1,LIVCV(8)*1,LIXM(8)*1,LLDS(8)*1,LM(8)*1,
     +   LN(8)*1,LNPAR(8)*1,LNPARE(8)*1,LONE(8)*1,LSCL(8)*1,
     +   LSTEP(8)*1,LWGT(8)*1,LZERO(8)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EIVEQ,ERVGT,ERVWT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR(20)
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1
!    +   LIFIX(8), LIVCV(8), LIXM(8), LLDS(8), LM(8), LN(8), LNPAR(8),
!    +   LNPARE(8), LONE(8), LSCL(8), LSTEP(8), LWGT(8), LZERO(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NZW
!        THE NUMBER OF ZERO WEIGHTS.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION STP(LSTP)
!        THE STEP SIZE ARRAY.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!
!
!     SET UP NAME ARRAYS
!
      DATA LIFIX(1), LIFIX(2), LIFIX(3), LIFIX(4), LIFIX(5),
     +   LIFIX(6), LIFIX(7), LIFIX(8) /'I','F','I','X','E','D',' ',' '/
      DATA LIVCV(1), LIVCV(2), LIVCV(3), LIVCV(4), LIVCV(5),
     +   LIVCV(6), LIVCV(7), LIVCV(8) /'I','V','C','V',' ',' ',' ',' '/
      DATA LIXM(1), LIXM(2), LIXM(3), LIXM(4), LIXM(5), LIXM(6),
     +   LIXM(7), LIXM(8) /'I','X','M',' ',' ',' ',' ',' '/
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +   LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA LM(1), LM(2), LM(3), LM(4), LM(5), LM(6), LM(7), LM(8) /'M',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8) /'N',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LNPAR(1), LNPAR(2), LNPAR(3), LNPAR(4), LNPAR(5),
     +   LNPAR(6), LNPAR(7), LNPAR(8) /'N','P','A','R',' ',' ',' ',
     +   ' '/
      DATA LNPARE(1), LNPARE(2), LNPARE(3), LNPARE(4), LNPARE(5),
     +   LNPARE(6), LNPARE(7), LNPARE(8) /'N','P','A','R','E',' ',' ',
     +   ' '/
      DATA LONE(1), LONE(2), LONE(3), LONE(4), LONE(5),
     +   LONE(6), LONE(7), LONE(8) /'O','N','E',' ',' ',' ',' ',' '/
      DATA LSCL(1), LSCL(2), LSCL(3), LSCL(4), LSCL(5),
     +   LSCL(6), LSCL(7), LSCL(8) /'S','C','A','L','E',' ',' ',
     +   ' '/
      DATA LSTEP(1), LSTEP(2), LSTEP(3), LSTEP(4), LSTEP(5),
     +   LSTEP(6), LSTEP(7), LSTEP(8) /'S','T','P',' ',' ',' ',' ',' '/
      DATA LWGT(1), LWGT(2), LWGT(3), LWGT(4), LWGT(5),
     +   LWGT(6), LWGT(7), LWGT(8) /'W','T',' ',' ',' ',' ',' ',' '/
      DATA LZERO(1), LZERO(2), LZERO(3), LZERO(4), LZERO(5),
     +   LZERO(6), LZERO(7), LZERO(8) /'Z','E','R','O',' ',' ',' ',' '/
!
!     ERROR CHECKING
!
      DO 10 I=1,20
         ERROR(I) = .FALSE.
   10 CONTINUE
!
      IERR = 0
      HEAD = .TRUE.
      NNZW = N
!
      CALL EISGE(NMSUB, LNPAR, NPAR, 1, 2, HEAD, ERROR(1), LONE)
      IF (ERROR(1)) THEN
        ERROR(7) = .TRUE.
      ELSE
        IF (IFIXED(1).LT.0) THEN
          CALL EISGE(NMSUB, LN, N, NPAR, 2, HEAD, ERROR(7), LNPAR)
          IF (WEIGHT) THEN
            CALL ERVWT(NMSUB, LWGT, WT, LWT, NPAR, HEAD, NNZW,
     +                 NZW, 2, ERROR(3), LNPAR)
          END IF
        ELSE
          CALL EIVEQ(NMSUB, LIFIX, IFIXED, NPAR, 0, 1, HEAD, NNFIX,
     +               NFIX, 1, ERROR(2), LZERO, LONE)
          IF (.NOT.ERROR(2)) THEN
            CALL EISGE(NMSUB, LN, N, NPARE, 2, HEAD, ERROR(7), LNPARE)
            IF (WEIGHT) THEN
              CALL ERVWT(NMSUB, LWGT, WT, LWT, NPARE, HEAD, NNZW,
     +                   NZW, 2, ERROR(3), LNPARE)
            END IF
          END IF
        END IF
      END IF
!
      CALL EISGE(NMSUB, LM, M, 1, 2, HEAD, ERROR(4), LONE)
!
      IF (.NOT.ERROR(7))
     +   CALL EISGE(NMSUB, LIXM, IXM, N, 3, HEAD, ERROR(5), LN)
!
!
      IF (.NOT.ERROR(1)) THEN
         IF ((.NOT.ERROR(2)) .AND. (.NOT.ERROR(7)))
     +      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR(6),
     +      LLDS)
!
         CALL ERVGT(NMSUB, LSTEP, STP, LSTP, 0.0D0, 0, HEAD, 6, NV,
     +      ERROR(8), LZERO)
!
         CALL ERVGT(NMSUB, LSCL, SCALE, LSCALE, 0.0D0, 0, HEAD, 6, NV,
     +      ERROR(12), LZERO)
!
         IF (SAVE)
     +      CALL EISGE(NMSUB, LIVCV, IVCV, NPARE, 3, HEAD, ERROR(15),
     +      LNPARE)
      END IF
!
!
      DO 20 I=1,20
         IF (ERROR(I)) GO TO 30
   20 CONTINUE
      RETURN
!
   30 CONTINUE
      IERR = 1
      RETURN
!
      END
!GFSLFS
      SUBROUTINE GFSLFS (H, K, NF, FMIN, FMAX, GAIN, FREQ, NPRT, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE
!     GAIN FUNCTION OF A SYMMETRIC LINEAR FILTER (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   K,LDSTAK,NF,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),GAIN(*),H(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA,FMN,FMX,YPLTMN,YPLTMX
      INTEGER
     +   IGFERR,IO,IPRT,ISORT,LDSMIN,NALL0,NORD,XORD,YORD
      LOGICAL
     +   ERR01,ERR02,ERR03,ERR04,ERR05,HEAD,SYM
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   LH(8)*1,LK(8)*1,LLDS(8)*1,LNF(8)*1,NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,ERIODD,ERSLF,GFORD,GFOUT,GFSEST,IPRINT,LDSCMP,
     +   SETFRQ,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION FMAX, FMIN
!        THE MINIMUM AND MAXIMUM FREQUENCY FOR WHICH THE GAIN
!        FUNCTION IS TO BE ESTIMATED.
!     DOUBLE PRECISION FMN, FMX
!        THE FREQUENCY RANGE ACTUALLY USED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        HAS BEEN ESTIMATED.
!     DOUBLE PRECISION GAIN(NF)
!        THE VECTOR IN WHICH THE GAIN FUNCTION ESTIMATES ARE
!        STORED.
!     DOUBLE PRECISION H(K)
!        THE ARRAY OF SYMMETRIC LINEAR FILTER COEFFICIENTS.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IGFERR
!        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
!        TO HAVE PRODUCED REASONABLE RESULTS.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION IN ISTAK FOR
!        THE ARRAY USED FOR SORTING.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LH(8), LK(8), LLDS(8), LNF(8)
!        THE ARRAYS CONTAINING THE NAMES OF THE CHECKED VARIABLES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        IS TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NORD
!        THE NUMBER OF POINTS TO BE PLOTTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL SYM
!        THE VARIABLE USED TO INDICATE WHETHER THE GAIN FUNCTION
!        COMPUTED WAS FOR A SYMMETRIC OR AUTOREGRESSIVE FILTER.
!     INTEGER XORD
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE X COORDINATES FOR THE GAIN FUNCTION PLOT
!     INTEGER YORD
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE Y COORDINATES FOR THE GAIN FUNCTION PLOT
!     DOUBLE PRECISION YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'G',       'F',       'S',       'L',       'F',       'S'/
      DATA
     +  LH(1), LH(2), LH(3), LH(4), LH(5), LH(6), LH(7), LH(8)
     + /  'H',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6),
     +  LK(7), LK(8) /'K', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
      DATA
     +  LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6), LLDS(7),
     +  LLDS(8) /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
      DATA
     +  LNF(1), LNF(2), LNF(3), LNF(4), LNF(5), LNF(6), LNF(7), LNF(8)
     + /  'N',   'F',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
      IO = 1
      IF (NPRT .EQ. 0) IO = 0
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LK, K, 1, 1, HEAD, ERR01, LK)
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR02)
      ERR03 = .TRUE.
      IF ((.NOT. ERR01) .AND. (.NOT. ERR02))
     +   CALL ERSLF(NMSUB, LH, K, H, HEAD, ERR03)
      CALL EISGE(NMSUB, LNF, NF, 1, 1, HEAD, ERR04, LNF)
!
      IF (ERR04) GO TO 10
!
      CALL LDSCMP(3*IO, 0, IO*NF, 0, 0, 0, 'D', 2*IO*NF, LDSMIN)
      CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERR05, LLDS)
!
      IF (ERR01 .OR. ERR02 .OR. ERR03 .OR. ERR05) GO TO 10
      GO TO 20
!
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   20 CONTINUE
!
      IF (NPRT .NE. 0) THEN
        CALL STKSET (LDSTAK, 4)
        NALL0 = STKST(1)
      ELSE
        NALL0 = 0
      END IF
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      SYM = .TRUE.
!
      DELTA = 1.0D0
!
!     SET FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO BE ESTIMATED
!
      FMN = MAX(FMIN, 0.0D0)
      FMX = MIN(FMAX, 0.5D0)
      IF (FMN.GE.FMX) THEN
        FMN = 0.0D0
        FMX = 0.5D0
      END IF
      CALL SETFRQ (FREQ, NF, 2, FMN, FMX, DELTA)
!
!     COMPUTE THE GAIN FUNCTION
!
      CALL GFSEST (H, K, NF, FREQ, GAIN, DELTA)
!
      IF (NPRT .EQ. 0) RETURN
!
!     SET VARIOUS POINTERS FOR THE PLOTTING ARRAYS
!
      XORD = STKGET(NF, 4)
      YORD = STKGET(NF, 4)
!
      ISORT = STKGET(NF, 2)
!
      IF (IERR .EQ. 1) GO TO 10
!
!     PLOT THE RESULTS
!
      CALL GFORD (FREQ, GAIN, ISTAK(ISORT), NF, RSTAK(XORD),
     +   RSTAK(YORD), NORD, YPLTMN, YPLTMX, NPRT, IGFERR)
      CALL GFOUT (RSTAK(XORD), RSTAK(YORD), NORD, FREQ, GAIN, NF, K,
     +   SYM, FMN, FMX, YPLTMN, YPLTMX, NPRT, IGFERR, NMSUB)
!
      CALL STKCLR(NALL0)
!
      IF (IERR .EQ. 1) GO TO 10
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL GFSLFS (H, K, NF, FMIN, FMAX, GAIN, FREQ, NPRT,',
     +   ' LDSTAK)')
      END
!STPADJ
      SUBROUTINE STPADJ(XM, N, M, IXM, MDL, PAR, NPAR,
     +   NEXMPT, STP, NFAIL, IFAIL, J, RELTOL, ABSTOL, STPLOW, STPMID,
     +   STPUP, ITEMP, FD, FDLAST, PV, PVNEW)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE ADJUSTS THE SELECTED STEP SIZES TO OPTIMAL
!     VALUES.
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ABSTOL,RELTOL,STP,STPLOW,STPMID,STPUP
      INTEGER
     +   IXM,J,M,N,NEXMPT,NFAIL,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FD(N),FDLAST(N),PAR(NPAR),PV(N),PVNEW(N),XM(IXM,M)
      INTEGER
     +   IFAIL(N),ITEMP(N)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  SCALARS IN COMMON
      DOUBLE PRECISION
     +   Q
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   FACTOR,STPNEW,TEMP
      INTEGER
     +   NCOUNT
      LOGICAL
     +   DONE,FIRST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CMPFD,ICOPY,RELCOM,DCOPY
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,SIGN
!
!  COMMON BLOCKS
      COMMON /NOTOPT/Q
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ABSTOL
!        THE ABSOLUTE AGREEMENT TOLERANCE.
!     LOGICAL DONE
!        THE VARIABLE USED TO INDICATE WHETHER THE ADJUSTMENT
!        PROCESS IS COMPLETE OR NOT.
!     DOUBLE PRECISION FACTOR
!        A FACTOR USED IN COMPUTING THE STEP SIZE.
!     DOUBLE PRECISION FD(N)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!     DOUBLE PRECISION FDLAST(N)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!        COMPUTED WITH THE MOST RECENT STEP SIZE SELECTED.
!     LOGICAL FIRST
!        THE VARIABLE USED TO INDICATE WHETHER THIS STEP SIZE
!        IS BEING USED FOR THE FIRST TIME OR WHETHER IT HAS BEEN
!        PREVIOUSLY ADJUSTED.
!     INTEGER IFAIL(N)
!        AN INDICATOR VECTOR USED TO DESIGNATE THOSE OBSERVATIONS
!        FOR WHICH THE STEP SIZE DOES NOT MEET THE CRITERIA.
!     INTEGER ITEMP(N)
!        A TEMPORARY VECTOR USED FOR STORING PAST VALUES OF ITEMP.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NCOUNT
!        THE NUMBER OF OBSERVATIONS AT WHICH THE NEW STEP SIZE DOES
!        SATISFY THE CRITERIA.
!     INTEGER NEXMPT
!        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
!        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
!        SIZE STILL BE CONSIDERED OK.
!     INTEGER NFAIL
!        A VECTOR CONTAINING FOR EACH OBSERVATION THE NUMBER OF
!        OBSERVATIONS FOR WHICH THE STEP SIZE DID NOT MEET THE CRITERIA.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION PVNEW(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCD.
!     DOUBLE PRECISION Q
!        A DUMMY VARIABLE WHICH IS USED, ALONG WITH COMMON NOTOPT (NO
!        OPTIMIZATION), TO COMPUTE THE STEP SIZE.
!     DOUBLE PRECISION RELTOL
!        THE RELATIVE AGREEMENT TOLERANCE.
!     DOUBLE PRECISION STP
!        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FORWARD
!        DIFFERENCE APPROXIMATION TO THE DERIVATIVE.
!     DOUBLE PRECISION STPLOW
!        THE LOWER LIMIT ON THE STEP SIZE.
!     DOUBLE PRECISION STPMID
!        THE MIDPOINT OF THE ACCEPTABLE RANGE OF THE STEP SIZE.
!     DOUBLE PRECISION STPNEW
!        THE VALUE OF THE NEW STEP SIZE BEING TESTED.
!     DOUBLE PRECISION STPUP
!        THE UPPER LIMIT ON THE STEP SIZE.
!     DOUBLE PRECISION TEMP
!        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
!        PARAMETER IS STORED.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      CALL ICOPY(N, IFAIL, 1, ITEMP, 1)
      NCOUNT = NFAIL
!
      IF ((STPLOW.LE.ABS(STP)) .AND. (ABS(STP).LE.STPUP)) RETURN
!
      IF (ABS(STP).GT.STPMID) THEN
!
            STPNEW = STPUP * SIGN(1.0D0, PAR(J))
            FACTOR = 10.0D0
      ELSE
!
            STPNEW = STPLOW * SIGN(1.0D0, PAR(J))
            FACTOR = 0.1D0
!
      END IF
!
      Q = STPNEW + PAR(J)
      STPNEW = Q - PAR(J)
!
      DONE = .FALSE.
      FIRST = .TRUE.
!
!     REPEAT STATEMENTS 60 TO 130 UNTIL (DONE)
!
   60 CONTINUE
!
         CALL DCOPY(N, FD, 1, FDLAST, 1)
!
         TEMP = PAR(J)
         PAR(J) = TEMP + STPNEW
         CALL MDL(PAR, NPAR, XM, N, M, IXM, PVNEW)
         PAR(J) = TEMP
!
         CALL CMPFD(N, STPNEW, PVNEW, PV, FD)
!
         CALL RELCOM(N, FD, FDLAST, RELTOL, ABSTOL, NCOUNT, ITEMP)
!
         IF (NCOUNT.LE.NEXMPT) THEN
               DONE = .TRUE.
               CALL ICOPY(N, ITEMP, 1, IFAIL, 1)
               NFAIL = NCOUNT
!
               IF (FIRST) THEN
                     STP = STPNEW
               ELSE
                     STP = STPNEW / FACTOR
               END IF
!
         ELSE
!
               FIRST = .FALSE.
               STPNEW = STPNEW * FACTOR
               Q = STPNEW + PAR(J)
               STPNEW = Q - PAR(J)
!
               IF ((FACTOR.GT.1.0D0 .AND. ABS(STPNEW).GT.ABS(STP))
     +            .OR.
     +            (FACTOR.LT.1.0D0 .AND. ABS(STPNEW).LT.ABS(STP)))
     +            DONE = .TRUE.
          END IF
!
      IF (DONE) THEN
         RETURN
      ELSE
         GO TO 60
      END IF
!
      END
!XHIST
      SUBROUTINE XHIST(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS PROGRAM TESTS FEATURES OF THE HIST FAMILY TO ENSURE THAT
!     ALL ASPECTS OF THE HIST FAMILY ROUTINES WORK CORRECTLY.
!
!     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   YLB,YUB
      INTEGER
     +   I,IPRT,LDSMIN,N,NCELL,NCONST,NPRTOF,NPRTON
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   Y(84),YCONST(10),YLONG(200),YPATH(10)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL HIST,HISTC,IPRINT,LDSCMP,NRAND
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ANINT,LOG10,MIN,NINT,DBLE
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        A LOOP INDEX.
!     INTEGER IERR
!        FLAG TO INDICATE PRESENCE OF ERROR DETECTED BY PRECEDING
!        STARPAC CALL.  (0 IS OK, 1 IS ERROR)
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER LDSMIN
!        THE MINIMUM AMOUNT OF WORK AREA NEEDED FOR A GIVEN PROBLEM.
!     INTEGER LDSTAK
!        AMOUNT OF WORK AREA.  SIZE OF DSTAK.
!     INTEGER N
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER NCELL
!        THE USER SUPPLIED VALUE FOR THE NUMBER OF CELLS IN THE
!        HISTOGRAM.  IF NCELL IS LESS THAN OR EQUAL TO ZERO, THE
!        NUMBER OF CELLS TO BE USED (NCELLS) WILL BE CALCULATED FROM
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NCONST
!        LENGTH OF THE VECTOR YCONST.
!     INTEGER NPRTOF
!        FLAG FOR NO OUTPUT (EXCEPT ERROR MESSAGES).
!     INTEGER NPRTON
!        FLAG FOR FULL PRINTOUT.
!     DOUBLE PRECISION Y(84)
!        DATA VECTOR FOR TESTS.
!     DOUBLE PRECISION YCONST(10)
!        VECTOR OF CONSTANT DATA.
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!     DOUBLE PRECISION YLONG(200)
!        LONG VECTOR OF DATA
!     DOUBLE PRECISION YPATH(10)
!        A VECTOR OF Y VALUES DESIGNED TO FORCE DIFFERENT PATHS
!        THROUGH THE SUMMATION ROUTINES.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!
!     DATA INITIALIZATIONS.
!
      DATA N /84/
      DATA NCONST /10/
      DATA NPRTON /1/
      DATA NPRTOF /0/
      DATA NCELL/10/
      DATA YLB/0.60D0/, YUB/0.63D0/
!
!     DAVIS-HARRISON R.H. DATA, PIKES PEAK.
!
!     THIS IS AN ARBITRARILY CHOSEN DATA SET.
!
      DATA Y( 1), Y( 2), Y( 3), Y( 4)
     +    / 0.6067D0, 0.6087D0, 0.6086D0, 0.6134D0/
      DATA Y( 5), Y( 6), Y( 7)
     +    / 0.6108D0, 0.6138D0, 0.6125D0/
      DATA Y( 8), Y( 9), Y(10), Y(11)
     +    / 0.6122D0, 0.6110D0, 0.6104D0, 0.7213D0/
      DATA Y(12), Y(13), Y(14)
     +    / 0.7078D0, 0.7021D0, 0.7004D0/
      DATA Y(15), Y(16), Y(17), Y(18)
     +    / 0.6981D0, 0.7242D0, 0.7268D0, 0.7418D0/
      DATA Y(19), Y(20), Y(21)
     +    / 0.7407D0, 0.7199D0, 0.6225D0/
      DATA Y(22), Y(23), Y(24), Y(25)
     +    / 0.6254D0, 0.6252D0, 0.6267D0, 0.6218D0/
      DATA Y(26), Y(27), Y(28)
     +    / 0.6178D0, 0.6216D0, 0.6192D0/
      DATA Y(29), Y(30), Y(31), Y(32)
     +    / 0.6191D0, 0.6250D0, 0.6188D0, 0.6233D0/
      DATA Y(33), Y(34), Y(35)
     +    / 0.6225D0, 0.6204D0, 0.6207D0/
      DATA Y(36), Y(37), Y(38), Y(39)
     +    / 0.6168D0, 0.6141D0, 0.6291D0, 0.6231D0/
      DATA Y(40), Y(41), Y(42)
     +    / 0.6222D0, 0.6252D0, 0.6308D0/
      DATA Y(43), Y(44), Y(45), Y(46)
     +    / 0.6376D0, 0.6330D0, 0.6303D0, 0.6301D0/
      DATA Y(47), Y(48), Y(49)
     +    / 0.6390D0, 0.6423D0, 0.6300D0/
      DATA Y(50), Y(51), Y(52), Y(53)
     +    / 0.6260D0, 0.6292D0, 0.6298D0, 0.6290D0/
      DATA Y(54), Y(55), Y(56)
     +    / 0.6262D0, 0.5952D0, 0.5951D0/
      DATA Y(57), Y(58), Y(59), Y(60)
     +    / 0.6314D0, 0.6440D0, 0.6439D0, 0.6326D0/
      DATA Y(61), Y(62), Y(63)
     +    / 0.6392D0, 0.6417D0, 0.6412D0/
      DATA Y(64), Y(65), Y(66), Y(67)
     +    / 0.6530D0, 0.6411D0, 0.6355D0, 0.6344D0/
      DATA Y(68), Y(69), Y(70)
     +    / 0.6623D0, 0.6276D0, 0.6307D0/
      DATA Y(71), Y(72), Y(73), Y(74)
     +    / 0.6354D0, 0.6197D0, 0.6153D0, 0.6340D0/
      DATA Y(75), Y(76), Y(77)
     +    / 0.6338D0, 0.6284D0, 0.6162D0/
      DATA Y(78), Y(79), Y(80), Y(81)
     +    / 0.6252D0, 0.6349D0, 0.6344D0, 0.6361D0/
      DATA Y(82), Y(83), Y(84)
     +    / 0.6373D0, 0.6337D0, 0.6383D0/
!
!     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
!
      CALL IPRINT(IPRT)
!
!     CHECK FOR SUFFICIENT WORK AREA LENGTH.
!
      IF (LDSTAK.LT.300) THEN
        WRITE (IPRT, 1000)
         RETURN
      END IF
!
      DO 20 I=1,NCONST
         YCONST(I) = 1.0D0
   20 CONTINUE
!
!     HEADING.
!
      WRITE (IPRT,1150)
!
!     TEST 1.  CHECK ALL ERROR MESSAGES.
!
      WRITE (IPRT,1160)
!
!     ERROR 1, ZERO OR FEWER ELEMENTS.
!
      WRITE (IPRT,1180)
      CALL HIST(Y, 0, LDSTAK)
      WRITE (IPRT, 1350)
      WRITE (IPRT, 1360) (Y(I), I = 1, N)
      WRITE (IPRT,1170) IERR
      CALL HISTC(Y, 0, NCELL, YLB, YUB, LDSTAK)
      WRITE (IPRT, 1350)
      WRITE (IPRT, 1360) (Y(I), I = 1, N)
      WRITE (IPRT,1170) IERR
!
!     ERROR 2, NOT ENOUGH SPACE IN CSTAK.
!
      WRITE (IPRT,1190)
      CALL LDSCMP(2, 0, N, 0, 0, 0, 'D',
     +            MIN(NINT(5.5+1.5*ANINT(LOG10(DBLE(N)))),25),LDSMIN)
      CALL HIST(Y, N, LDSMIN-1)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1195)
      CALL HIST(Y, N, LDSMIN)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1190)
      CALL LDSCMP(2, 0, N, 0, 0, 0, 'D', NCELL, LDSMIN)
      CALL HISTC(Y, N, NCELL, YLB, YUB, LDSMIN-1)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1195)
      CALL HISTC(Y, N, NCELL, YLB, YUB, LDSMIN)
      WRITE (IPRT,1170) IERR
!
!     CONSTANT Y. (NOT AN ERROR)
!
      WRITE (IPRT,1200)
      CALL HIST(YCONST, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT,1200)
      CALL HISTC(YCONST, NCONST, NCELL, YLB, YUB, LDSTAK)
      WRITE (IPRT,1170) IERR
!
!     ERROR 4, NO DATA WITHIN USER SUPPLIED LIMITS
!
      WRITE (IPRT, 1110)
      CALL HISTC(Y, N, 0, 4.0D0, 10.0D0, LDSTAK)
      WRITE (IPRT, 1170) IERR
!
!     TEST 2.  MAKE A WORKING RUN OF EACH ROUTINE TO CHECK
!     THE OUTPUT.
!
      WRITE (IPRT,1300)
      WRITE (IPRT,1310)
      CALL HIST(Y, N, LDSTAK)
      WRITE (IPRT, 1350)
      WRITE (IPRT, 1360) (Y(I), I = 1, N)
      WRITE (IPRT,1170) IERR
!
      WRITE (IPRT,1340)
      CALL HISTC(Y, N, NCELL, YLB, YUB, LDSTAK)
      WRITE (IPRT, 1350)
      WRITE (IPRT, 1360) (Y(I), I = 1, N)
      WRITE (IPRT,1170) IERR
!
!     RUN DATA SET 6.7.
!
      DO 90 I=1,10
         YPATH(I) = 0.0D0
   90 CONTINUE
      YPATH(1) = -1.0D0
      YPATH(10) = 1.0D0
      WRITE (IPRT,1130)
      CALL HIST(YPATH, NCONST, LDSTAK)
      WRITE (IPRT,1170) IERR
      WRITE (IPRT, 1130)
      CALL HISTC(YPATH, NCONST, 0, 0.0D0, 0.0D0, LDSTAK)
      WRITE (IPRT, 1130)
      CALL HISTC(YPATH, NCONST, 1, 0.0D0, 0.0D0, LDSTAK)
      WRITE (IPRT, 1130)
      CALL HISTC(YPATH, NCONST, 0, -0.5D0, 0.5D0, LDSTAK)
      WRITE (IPRT, 1130)
      CALL HISTC(YPATH, NCONST, 0, 1.0D0, 4.0D0, LDSTAK)
!
!     RUN DATA SET 6.8
!
      WRITE (IPRT, 1120)
      CALL NRAND (YLONG, 200, 3254767)
      CALL HIST (YLONG, 200, LDSTAK)
      RETURN
!
!     FORMATS
!
 1000 FORMAT ('1THE DIMENSION OF DSTAK AND THE VALUE OF LDSTAK NEEDED'/
     +  ' FOR HISTX MUST EQUAL OR EXCEED 300.  CHANGE DRIVER'/
     +  ' AND RECALL HISTX.')
 1110 FORMAT (41H1TRY NO DATA WITHIN USER SUPPLIED LIMITS.)
 1120 FORMAT (38H1RUN HIST ON 200 PSEUDO-RANDON NUMBERS)
 1130 FORMAT(24H1RUN HIST ON -1, 8*0, 1.)
 1150 FORMAT (48H1TEST RUNS FOR THE HISTOGRAM FAMILY OF ROUTINES.)
 1160 FORMAT(47H TEST 1.  GENERATE ONE OF EACH OF THE POSSIBLE ,
     +   15HERROR MESSAGES.)
 1170 FORMAT(22H THE VALUE OF IERR IS , I4)
 1180 FORMAT(28H TRY ZERO OR FEWER ELEMENTS.)
 1190 FORMAT('1TEST WITH INSUFFICIENT WORK AREA')
 1195 FORMAT(' TEST WITH EXACTLY THE RIGHT AMOUNT OF WORK AREA.')
 1200 FORMAT('1TRY CONSTANT Y. (NOT AN ERROR)')
 1300 FORMAT(52H1TEST 4.  MAKE WORKING RUNS OF ALL ROUTINES TO CHECK,
     +   12H THE OUTPUT.)
 1310 FORMAT(48H1RUN HIST ON THE DAVIS-HARRISON PIKES PEAK DATA.)
 1340 FORMAT(49H1RUN HISTC ON THE DAVIS-HARRISON PIKES PEAK DATA.)
 1350 FORMAT(/48H PRINT THE DATA TO INSURE THE ORIGINAL ORDER HAS,
     +   15H BEEN RESTORED.)
 1360 FORMAT (7F10.5)
      END
!CCFM
      SUBROUTINE CCFM (Y1, Y1MISS, Y2, Y2MISS, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
!     CORRELATIONS OF TWO TIME SERIES WITH MISSING OBSERVATIONS
!     (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   Y1MISS,Y2MISS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y1(*),Y2(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   Y1MEAN,Y1SD,Y2MEAN,Y2SD
      INTEGER
     +   ICCOV,INLPPC,IPRT,IYM,IYMFFT,JCCOV,JNLPPC,LAGMAX,LDSMIN,
     +   LDSTAK,LGLST1,LGLST2,LYFFT,M,NFFT,NUSED1,NUSED2
      LOGICAL
     +   ISFFT,ISLONG
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CCOV(101,2,2),RHOC(201),SDRHOC(201)
      INTEGER
     +   NLPPC(101,2,2)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACVFM,CCFER,CCFMNM,CCFOUT,IPRINT,SETLAG
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN,SQRT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCOV(101, 2, 2)
!        THE ARRAY USED FOR THE CCVF ESTIMATES.
!     INTEGER ICCOV
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER INLPPC
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
!        IN THE USERS PROGRAM.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     LOGICAL ISLONG
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
!     INTEGER IYM
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YM AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IYMFFT
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JCCOV
!        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
!        IN THE USERS PROGRAM.
!     INTEGER LAGMAX
!        THE NUMBER OF AUTOCORRELATIONS DESIRED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LGLST1, LGLST2
!        THE LAG VALUE OF THE LAST ACVF WHICH COULD BE COMPUTED
!        FOR SERIES 1 AND 2, RESPECTIVELY, BEFORE MISSING DATA
!        CAUSED A MISSING ACVF.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER M
!        THE NUMBER OF SERIES BEING COMPARED, IE THE
!        NUMBER OF COLUMNS OF DATA IN YM.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NLPPC(101, 2, 2)
!        THE NUMBER OF LAGGED PRODUCT PAIRS USED TO COMPUTE THE CCVF.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NUSED1, NUSED2
!        THE NUMBER OF ACTIVE (NON MISSING) OBSERVATIONS IN SERIES
!        1 AND 2, RESPECTIVELY.
!     DOUBLE PRECISION RHOC(201)
!        THE CCF ESTIMATES.
!     DOUBLE PRECISION SDRHOC(201)
!        THE ARRAY CONTAINING THE SD OF THE CCFM.
!     DOUBLE PRECISION Y1(N), Y1MEAN, Y1MISS, Y1SD
!        THE FIRST SERIES, AND ITS MEAN, MISSING VALUE CODE AND
!        STANDARD DEVIATION.
!     DOUBLE PRECISION Y2(N), Y2MEAN, Y2MISS, Y2SD
!        THE SECOND SERIES, AND ITS MEAN, MISSING VALUE CODE AND
!        STANDARD DEVIATION.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'C',       'C',       'F',       'M',       ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      ICCOV = 101
      INLPPC = 101
      IYM = N
      JCCOV = 2
      JNLPPC = 2
      LDSMIN = 0
      LDSTAK = 0
      LAGMAX = 1
      LYFFT = N + LAGMAX
      IYMFFT = LYFFT
      M = 2
      NFFT = N
      ISFFT = .FALSE.
      ISLONG = .FALSE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL CCFER(NMSUB, N, LAGMAX, LDSTAK, LDSMIN, ICCOV, JCCOV,
     +  INLPPC, JNLPPC, M, LYFFT, NFFT, IYM, IYMFFT, ISFFT, ISLONG)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      IF (IERR.EQ.0) THEN
!
!       SET THE MAXIMUM LAG VALUE TO BE USED.
!
        CALL SETLAG (N, LAGMAX)
!
!       COMPUTE THE SERIES ACVF AND SD
!
        CALL ACVFM (Y1, Y1MISS, N, Y1MEAN, CCOV(1,1,1), LAGMAX, LGLST1,
     +     NLPPC(1,1,1), 101)
!
        NUSED1 = NLPPC(1,1,1)
        Y1SD = SQRT(CCOV(1,1,1) * N / (NUSED1-1))
!
        CALL ACVFM (Y2, Y2MISS, N, Y2MEAN, CCOV(1,2,2), LAGMAX, LGLST2,
     +     NLPPC(1,2,2), 101)
!
        NUSED2 = NLPPC(1,2,2)
        Y2SD = SQRT(CCOV(1,2,2) * N / (NUSED2-1))
!
!       CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
        IF (CCOV(1,1,1)*CCOV(1,2,2) .NE. 0.0D0)
     +    CALL CCFMNM (Y1, Y1MISS, Y2, Y2MISS, N, LAGMAX, 201,
     +    CCOV(1,1,1),
     +    CCOV(1,2,2), CCOV(1,1,2), CCOV(1,2,1), 101, NLPPC(1,1,1),
     +    NLPPC(1,2,2), NLPPC(1,1,2), NLPPC(1,2,1), 101, Y1MEAN, Y2MEAN,
     +    RHOC, SDRHOC, 1, MIN(LGLST1, LGLST2))
!
!       CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
        CALL CCFOUT (1, Y1MEAN, Y1SD, N, NUSED1, 2, Y2MEAN, Y2SD, N,
     +     NUSED2, LAGMAX, 201, RHOC, SDRHOC, .TRUE., NLPPC(1,1,2),
     +     NLPPC(1,2,1), 101, Y1MISS, Y2MISS, .FALSE.)
      END IF
!
      IF (IERR.NE.0) THEN
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        IERR = 1
        CALL IPRINT (IPRT)
        WRITE (IPRT, 1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   44H       CALL CCFM (Y1, YMISS1, Y2, YMISS2, N))
      END
!VPLMT
      SUBROUTINE VPLMT (YM, YMMISS, N, M, IYM, YLB, YUB, YMN,
     +  YMX, ERROR, NMSUB, MISS, NSAMPL)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SETS THE PLOT LIMITS FOR VERTICAL PLOTS
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YLB,YMN,YMX,YUB
      INTEGER
     +   IYM,M,N,NSAMPL
      LOGICAL
     +   ERROR,MISS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(IYM,M),YMMISS(M)
      CHARACTER
     +   NMSUB(6)*1
!
!  LOCAL SCALARS
      INTEGER
     +   I,II,IPRT,J
      LOGICAL
     +   HEAD,SETLMT
!
!  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ADJLMT,EHDR,IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX,MIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        A VALUE INDICATING WHETHER AN ERROR WAS DETECTED (TRUE)
!        OR NOT (FALSE).
!     LOGICAL HEAD
!        PRINT HEADING (HEAD=TRUE) OR NOT (HEAD=FALSE).
!     INTEGER I, II
!        INDEXING VARIABLES.
!     INTEGER IPRT
!        *
!     INTEGER IYM
!        ACTUAL ROW DIMENSION OF YM DECLARED IN THE USERS MAIN PROGRAM
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER M
!        THE NUMBER OF VECTORS IN YM
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS .
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NSAMPL
!        *
!     LOGICAL SETLMT
!        AN INDICATOR VARIABLE USED TO DETERMINE IF STARTING VALUES
!        FOR XLB, XINC, YMN, YMX HAVE BEEN FOUND.
!     DOUBLE PRECISION YLB
!        THE USER SUPPLIED Y-AXIS LOWER BOUND.
!     DOUBLE PRECISION YM(IYM,M)
!        THE ARRAY CONTAINING THE DEPENDENT VARIABLE(S).
!     DOUBLE PRECISION YMMISS(M)
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IS MISSING.
!        IF YM(I,J) = YMMISS(J), THE VALUE IS ASSUMED MISSING, OTHERWISE
!        IT IS NOT.
!     DOUBLE PRECISION YMN, YMX
!        THE Y-AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
!     DOUBLE PRECISION YUB
!        THE USER SUPPLIED Y-AXIS UPPER BOUNDS.
!
      ERROR = .FALSE.
!
      IF (YLB.LT.YUB) THEN
!
!       SET LIMITS TO USER SPECIFIED VALUES
!
        YMN = YLB
        YMX = YUB
!
      ELSE
!
!       SET LIMITS TO RANGE OF VALUES WITHIN ANY USER SPECIFIED VALUES
!
        SETLMT = .FALSE.
        II = 1
!
!       FIND FIRST VALUE TO BE PLOTTED
!
        DO 20 I=1,N,NSAMPL
           DO 10 J=1,M
              IF (MISS .AND. MVCHK(YM(I,J),YMMISS(J))) GO TO 10
              IF ((YLB.LT.YUB) .AND. ((YM(I,J).LT.YLB) .OR.
     +           (YUB.LT.YM(I,J)))) GO TO 10
              IF (SETLMT) THEN
                YMN = MIN(YMN, YM(I,J))
                YMX = MAX(YMX, YM(I,J))
              ELSE
                YMN = YM(I,J)
                YMX = YM(I,J)
                SETLMT = .TRUE.
                II = I + NSAMPL
              END IF
   10      CONTINUE
           IF (SETLMT) GO TO 30
   20   CONTINUE
!
   30   IF (II.LE.1) THEN
!
!         NO VALUES TO BE PLOTTED.  PRINT ERROR MESSAGE
!
          ERROR = .TRUE.
          CALL IPRINT(IPRT)
          HEAD = .TRUE.
          CALL EHDR(NMSUB,HEAD)
          IF (YLB.GE.YUB) THEN
            WRITE (IPRT, 1010)
          ELSE
            WRITE (IPRT, 1020)
          END IF
          WRITE (IPRT, 1030)
!
        ELSE
!
!         FIND LIMITS FROM REMAINING VALUES
!
          IF (II.LE.N) THEN
            DO 50 I=II,N,NSAMPL
               DO 40 J=1,M
                  IF (MISS .AND. MVCHK(YM(I,J),YMMISS(J))) GO TO 40
                  IF ((YLB.LT.YUB) .AND. ((YM(I,J).LT.YLB) .OR.
     +               (YUB.LT.YM(I,J)))) GO TO 40
                  YMN = MIN(YMN, YM(I,J))
                  YMX = MAX(YMX, YM(I,J))
   40          CONTINUE
   50       CONTINUE
          END IF
        END IF
!
!       ADJUST Y AXIS LIMITS IF EQUAL
!
        IF (YMN .GE. YMX) CALL ADJLMT(YMN, YMX)
!
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1010 FORMAT (/
     +   44H NO NON-MISSING PLOT COORDINATES WERE FOUND.)
 1020 FORMAT (/
     +   40H NO NON-MISSING VALUES WERE FOUND WITHIN,
     +   26H THE USER SUPPLIED LIMITS.)
 1030 FORMAT (/
     +   30H THE PLOT HAS BEEN SUPPRESSED.)
      END
!AMEER
      SUBROUTINE AMEER(NMSUB, N, NPAR, NPARE, LDSTAK, LDSMIN,
     +  STP, LSTP, SCALE, LSCALE, IVCV, SAVE, MSPEC, NFAC)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE ERROR CHECKING ROUTINE FOR NONLINEAR LEAST SQUARES
!     ESTIMATION ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IVCV,LDSMIN,LDSTAK,LSCALE,LSTP,N,NFAC,NPAR,NPARE
      LOGICAL
     +   SAVE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   SCALE(*),STP(*)
      INTEGER
     +   MSPEC(4,*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   I,NP,NV
      LOGICAL
     +   HEAD
!
!  LOCAL ARRAYS
      LOGICAL
     +   ERROR(20)
      CHARACTER
     +   LIVCV(8)*1,LLDS(8)*1,LMSPEC(8)*1,LN(8)*1,LNFAC(8)*1,
     +   LNPAR(8)*1,LNPARE(8)*1,LONE(8)*1,LSCL(8)*1,LSTEP(8)*1,
     +   LZERO(8)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EIAGE,EISEQ,EISGE,ERVGT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR(20)
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        THE VARIABLE USED TO INDICATE WHETHER A HEADING IS TO BE
!        PRINTED DURING A GIVEN CALL TO THE ITERATION REPORT (TRUE)
!        OR NOT (FALSE).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF MATRIX VCV.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LIVCV(8), LLDS(8), LMSPEC(8), LN(8), LNFAC(8),
!    *   LNPAR(8), LNPARE(8), LONE(8), LSCL(8), LSTEP(8), LZERO(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER LSTP
!        THE DIMENSION OF VECTOR STP.
!     INTEGER MSPEC(4,*)
!        INTEGER MSPEC(4,NFAC)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
!     INTEGER NP
!        THE NUMBER OF PARAMETERS SPECIFIED BY MSPEC.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NV
!        *
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION STP(LSTP)
!        THE STEP SIZE ARRAY.
!
!     SET UP NAME ARRAYS
!
      DATA LIVCV(1), LIVCV(2), LIVCV(3), LIVCV(4), LIVCV(5),
     +   LIVCV(6), LIVCV(7), LIVCV(8) /'I','V','C','V',' ',' ',' ',' '/
      DATA LLDS(1), LLDS(2), LLDS(3), LLDS(4), LLDS(5), LLDS(6),
     +   LLDS(7), LLDS(8) /'L','D','S','T','A','K',' ',' '/
      DATA LMSPEC(1), LMSPEC(2), LMSPEC(3), LMSPEC(4), LMSPEC(5),
     +   LMSPEC(6), LMSPEC(7), LMSPEC(8)
     +  /'M','S','P','C',' ',' ',' ',' '/
      DATA LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8) /'N',
     +   ' ',' ',' ',' ',' ',' ',' '/
      DATA LNFAC(1), LNFAC(2), LNFAC(3), LNFAC(4), LNFAC(5),
     +   LNFAC(6), LNFAC(7), LNFAC(8) /'N','F','A','C',' ',' ',' ',' '/
      DATA LNPAR(1), LNPAR(2), LNPAR(3), LNPAR(4), LNPAR(5),
     +   LNPAR(6), LNPAR(7), LNPAR(8) /'N','P','A','R',' ',' ',' ',
     +   ' '/
      DATA LNPARE(1), LNPARE(2), LNPARE(3), LNPARE(4), LNPARE(5),
     +   LNPARE(6), LNPARE(7), LNPARE(8) /'N','P','A','R','E',' ',' ',
     +   ' '/
      DATA LONE(1), LONE(2), LONE(3), LONE(4), LONE(5),
     +   LONE(6), LONE(7), LONE(8) /'1',' ',' ',' ',' ',' ',' ',' '/
      DATA LSCL(1), LSCL(2), LSCL(3), LSCL(4), LSCL(5),
     +   LSCL(6), LSCL(7), LSCL(8) /'S','C','A','L','E',' ',' ',
     +   ' '/
      DATA LSTEP(1), LSTEP(2), LSTEP(3), LSTEP(4), LSTEP(5),
     +   LSTEP(6), LSTEP(7), LSTEP(8) /'S','T','P',' ',' ',' ',' ',' '/
      DATA LZERO(1), LZERO(2), LZERO(3), LZERO(4), LZERO(5),
     +   LZERO(6), LZERO(7), LZERO(8) /'Z','E','R','O',' ',' ',' ',' '/
!
!     ERROR CHECKING
!
      DO 10 I=1,20
         ERROR(I) = .FALSE.
   10 CONTINUE
!
      IERR = 0
      HEAD = .TRUE.
!
      CALL EISGE(NMSUB, LN, N, 1, 2, HEAD, ERROR(1), LONE)
!
      CALL EISGE(NMSUB, LNFAC, NFAC, 1, 2, HEAD, ERROR(2), LONE)
!
      IF (.NOT. ERROR(2))
     +  CALL EIAGE(NMSUB, LMSPEC, MSPEC, 4, NFAC, 4, 0, 0, HEAD, 1, NV,
     +  ERROR(3), LMSPEC)
!
      IF ((.NOT. ERROR(2)) .AND. (.NOT. ERROR(3))) THEN
        NP = 1
         DO 20 I = 1, NFAC
          NP = NP + MSPEC(1,I) + MSPEC(3,I)
   20   CONTINUE
        CALL EISEQ(NMSUB, LNPAR, NPAR, NP, 1, HEAD, ERROR(4), LNPAR)
!
        IF (.NOT.ERROR(4)) THEN
          CALL EISGE(NMSUB, LNPARE, NPARE, 1, 2, HEAD, ERROR(5), LONE)
          CALL ERVGT(NMSUB, LSTEP, STP, LSTP, 0.0D0, 0, HEAD, 6, NV,
     +      ERROR(8), LZERO)
          CALL ERVGT(NMSUB, LSCL, SCALE, LSCALE, 0.0D0, 0, HEAD, 6, NV,
     +      ERROR(12), LZERO)
          IF (SAVE .AND. (.NOT.ERROR(5)))
     +      CALL EISGE(NMSUB, LIVCV, IVCV, NPARE, 3, HEAD, ERROR(15),
     +      LNPARE)
        END IF
      END IF
!
      IF ((.NOT.ERROR(1)) .AND. (.NOT.ERROR(2)) .AND. (.NOT.ERROR(3))
     +   .AND. (.NOT.ERROR(4)) .AND. (.NOT.ERROR(5)))
     +   CALL EISGE(NMSUB, LLDS, LDSTAK, LDSMIN, 9, HEAD, ERROR(6),
     +   LLDS)
!
      DO 30 I=1,20
         IF (ERROR(I)) GO TO 40
   30 CONTINUE
      RETURN
!
   40 CONTINUE
      IERR = 1
      RETURN
!
      END
!NLDRVA
      SUBROUTINE NLDRVA (MDL, DRV, DONE, IFIXD, PAR, NPAR, XM, N, M,
     +   IXM, PV, D, WEIGHT, WT, LWT, STP, LSTP, SCL, LSCL)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE ANALYTIC DERIVATIVE MATRIX (JACOBIAN)
!     USING USER-SUPPLIED ROUTINE DERIV.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LSCL,LSTP,LWT,M,N,NPAR
      LOGICAL
     +   DONE,WEIGHT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   D(N,NPAR),PAR(NPAR),PV(N),SCL(LSCL),STP(LSTP),WT(LWT),
     +   XM(IXM,M)
      INTEGER
     +   IFIXD(NPAR)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   WTSQRT
      INTEGER
     +   I,J,JPK
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION D(N,NPAR)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     LOGICAL DONE
!        THE VARIABLE USED TO INDICATE WHETHER THIS IS THE FINAL
!        COMPUTATION OF THE JACOBIAN OR NOT.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER JPK
!        THE INDEX OF THE PACKED PARAMETERS.
!     INTEGER LSCL
!        THE ACTUAL LENGTH OF THE VECTOR SCL.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION SCL(LSCL)
!        THE SCALE VALUES.
!     DOUBLE PRECISION STP(LSTP)
!        THE SELECTED RELATIVE STEP SIZES.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION WTSQRT
!        THE SQUARE ROOT OF THE ITH WEIGHT.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
!     COMPUTE JACOBIAN
!
      CALL DRV(PAR, NPAR, XM, N, M, IXM, D)
!
      JPK = 0
!
      DO 20 J=1,NPAR
         IF (IFIXD(J).NE.0) GO TO 20
         JPK = JPK + 1
         DO 10 I=1,N
            WTSQRT = 1.0D0
            IF (WEIGHT .AND. (.NOT.DONE)) WTSQRT = SQRT(WT(I))
            D(I,JPK) = -WTSQRT*D(I,J)
   10    CONTINUE
   20 CONTINUE
!
      RETURN
!
      END
!SMPLY
      SUBROUTINE SMPLY (Y, N, NS, YS, NYS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE SAMPLES EVERY KTH OBSERVATION FROM THE INPUT
!     SERIES Y, STORING THE SAMPLED SERIES IN YS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N,NS,NYS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(N),YS(N)
!
!  LOCAL SCALARS
      INTEGER
     +   I,I1
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I, I1
!        INDEXING VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     INTEGER NS
!        THE SAMPLING RATE.
!     INTEGER NYS
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YS.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YS(N)
!        THE VECTOR IN WHICH THE SAMPLED SERIES IS RETURNED.
!
      NYS = 0
      DO 30 I = 1, N, NS
         NYS = NYS + 1
         YS(NYS) = Y(I)
   30 CONTINUE
      I1 = NYS + 1
      DO 40 I = I1, N
         YS(I) = 0.0D0
   40 CONTINUE
!
      RETURN
      END
!LLCNTG
      SUBROUTINE LLCNTG(Y, WT, LWT, XM, N, IXM, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   NMSUB, WEIGHT, SAVE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR GENERAL LINEAR LEAST
!     SQUARES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,IXM,LDSTAK,LPAR,LPV,LSDPV,LSDRES,LWT,N,NPAR,NPRT
      LOGICAL
     +   SAVE,WEIGHT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SDPV(*),SDRES(*),VCV(*),WT(*),XM(*),Y(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IFIT,M
!
!  EXTERNAL SUBROUTINES
      EXTERNAL LLCNT,LLHDRG
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IFIT
!        THE INDICATOR VALUE DESIGNATING WHETHER THE LLS IS OF A
!        GENERAL MODEL (IFIT=3) OR A POLYNOMIAL MODEL (IFIT=1).
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     EXTERNAL LLHDRG
!        THE NAME OF THE ROUTINE THAT PRODUCED THE HEADING.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     DOUBLE PRECISION PAR(LPAR)
!        THE PARAMETERS TO BE ESTIMATED.
!     DOUBLE PRECISION PV(LPV)
!        THE PREDICTED VALUES.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION SDPV(LSDPV)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(LSDRES)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
!     DOUBLE PRECISION XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!
!
      IFIT = 3
      M = NPAR
!
      CALL LLCNT(Y, WT, LWT, XM, N, M, IXM, NPAR, RES, LDSTAK, NPRT,
     +   PAR, LPAR, RSD, PV, LPV, SDPV, LSDPV, SDRES, LSDRES, VCV, IVCV,
     +   LLHDRG, IFIT, NMSUB, WEIGHT, SAVE)
!
      RETURN
!
      END
!SPPLTC
      SUBROUTINE SPPLTC (XAXIS, YAXIS, ISYM, NPTS, XPLTMN, XPLTMX, BW,
     +   CILOW, CIMID, CIUP, LPCV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES CONFIDENCE INTERVAL AND BANDWIDTH
!     CO-ORDINATES FOR THE SPECTRUM PLOTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   BW,CILOW,CIMID,CIUP,XPLTMN,XPLTMX
      INTEGER
     +   LPCV,NPTS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISYM(LPCV)
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION BW
!       THE BANDWIDTH.
!     DOUBLE PRECISION CILOW, CIMID, CIUP
!        THE Y CORDNATES FOR THE LOWER  MID AND UPPER CONFIDENCE
!        INTERVAL POINTS.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR THE PLOTS.
!     INTEGER NPTS
!        THE NUMBER OF CO-ORDINATES TO BE PLOTTED.
!     DOUBLE PRECISION XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     DOUBLE PRECISION YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!
      IF (XPLTMX - XPLTMN .GE. BW) GO TO 10
!
      XPLTMX = MAX(XPLTMX + (BW - XPLTMX + XPLTMN) / 2.0D0, 0.5D0)
      XPLTMN = XPLTMX - BW
!
   10 CONTINUE
!
      NPTS = NPTS + 1
!
      XAXIS(NPTS) = XPLTMX - 0.5D0 * BW
      YAXIS(NPTS) = CIUP
      ISYM(NPTS) = 7
!
      NPTS = NPTS + 1
!
      XAXIS(NPTS) = XPLTMX - 0.5D0 * BW
      YAXIS(NPTS) = CIMID
      ISYM(NPTS) = 3
!
      NPTS = NPTS + 1
!
      XAXIS(NPTS) = XPLTMX - 0.5D0 * BW
      YAXIS(NPTS) = CILOW
      ISYM(NPTS) = 13
!
      NPTS = NPTS + 1
!
      XAXIS(NPTS) = XPLTMX - BW
      YAXIS(NPTS)  = CIMID
      ISYM(NPTS) = 6
!
      NPTS = NPTS + 1
!
      XAXIS(NPTS) = XPLTMX
      YAXIS(NPTS)  = CIMID
      ISYM(NPTS) = 27
!
      RETURN
      END
!PLTPLX
      SUBROUTINE PLTPLX(POINT, YMN, SCALE, IPOINT, IEND)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE POINT LOCATION IN THE PLOT STRING.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   POINT,SCALE,YMN
      INTEGER
     +   IEND,IPOINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IEND
!        THE NUMBER OF LOCATIONS IN THE PLOT STRING.
!     INTEGER IPOINT
!        THE LOCATION IN THE PLOT STRING OF THE VALUE BEING PLOTTED.
!     DOUBLE PRECISION POINT
!        THE VALUE TO BE PLOTTED.
!     DOUBLE PRECISION SCALE
!        THE SCALE INTERVAL OF THE PLOT.
!     DOUBLE PRECISION YMN
!        THE GRAPH AXIS LOWER LIMITS ACTUALLY USED.
!
      IPOINT = (POINT-YMN)/SCALE + 2.5
      IF (IPOINT .LT. 2) IPOINT = 1
      IF (IPOINT .GT. IEND) IPOINT = IEND
      RETURN
      END
!CORR
      SUBROUTINE CORR(YM, N, M, IYM, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR THE CORRELATION FAMILY.
!     IT IS THE SHORT CALL FORM.
!     THIS PROCEDURE CALLS CORER TO CHECK FOR ERRORS IN THE PARAMETER
!     LIST.  IF NO PROBLEMS IT THEN ALLOCATES SPACE IN CSTAK FOR THE
!     VECTORS NEEDED AND CALLS THE MAIN ROUTINE , CORRMN, TO
!     DO THE CORRELATION ANALYSIS.
!
!     WRITTEN BY -
!        LINDA L. MITCHELL
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IYM,LDSTAK,M,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   AVG,CILO,CIUP,ICOR,IFP,IPRT,IWRK,LIWRK,LWRK,NALL0,NPRT,PC,
     +   QF,QUAD,RANK,SC,SCINV,SD,SLPC,SLSC,SRCC,T,VCV,WRK
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CORRER,CORRMN,IPRINT,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER AVG
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  AVERAGES OF YM
!     INTEGER CILO
!                  OCCUPIES THE SAME SPACE AS SLPC AND IS THE LOWER
!                  CONFIDENCE INTERVAL
!     INTEGER CIUP
!                  OCCUPIES THE SAME SPACE AS SLSC AND IS THE UPPER
!                  CONFIDENCE INTERVAL
!     DOUBLE PRECISION DSTAK(12)
!                  THE DOUBLE PRECISION VERSION OF
!                  THE /CSTAK/ WORK AREA.
!     INTEGER ICOR
!                  DETERMINES WHICH SUBROUTINE CALLED CORRMN
!                  IF =1, THEN CALLED BY CORR
!                     =2, THEN CALLED BY CORRS
!     INTEGER IERR
!                  A FLAG RETURNED TO THE USER INDICATING
!                  WHETHER  ERRORS WERE DETECTED IN THE PARAMETER LIST
!                  IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!                  IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!                  AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3
!                  INDICATES SINGLE PRECISION AND IFP=4 INDICATES
!                  DOUBLE PRECISION.
!     INTEGER IPRT
!                  LOGICAL OUTPUT UNIT
!     INTEGER ISTAK(12)
!                  THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IWRK
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  INTEGER WORK VECTOR.
!     INTEGER IYM
!                  THE ROW DIMENSION OF YM SPECIFIED IN THE USERS PROGRA
!     INTEGER LDSTAK
!                  SIZE OF WORK AREA ALLOCATED IN THE USERS PROGRAM
!     INTEGER LIWRK
!                  THE LENGTH OF THE INTEGER WORK VECTOR.
!     INTEGER LWRK
!                  THE LENGTH OF THE DOUBLE PRECISION WORK VECTOR.
!     INTEGER M
!                  THE NUMBER OF VARIABLES
!     INTEGER N
!                  THE NUMBER OF OBSERVATIONS
!     INTEGER NALL0
!                  THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE
!                  TIME THAT THIS ROUTINE WAS CALLED.
!     CHARACTER*1 NMSUB(6)
!                  THE SUBROUTINE NAME
!     INTEGER NPRT
!                  THE VARIABLE CONTROLLING THE AUTOMATIC PRINTOUT
!                       NPRT = 0, PRINTOUT IS SUPPRESSED
!                       OTHERWISE THE PRINTOUT IS PROVIDED.
!     INTEGER PC
!                  THE STARTING LOCATION IN THE WORK AREA
!                  OF THE PARTIAL CORRELATION COEFFICIENTS MATRIX
!     INTEGER QF
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  QUADRATIC FIT
!     INTEGER QUAD
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  DOUBLE PRECISION VERSION OF THE QUADRATIC FIT
!     INTEGER RANK
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  MATRIX CONTAINING THE RANKS OF YM
!     DOUBLE PRECISION RSTAK(12)
!                  THE DOUBLE PRECISION VERSION OF THE
!                  /CSTAK/ WORK AREA.
!     INTEGER SC
!                  THE STARTING LOCATION IN THE WORK AREA
!                  OF THE SIMPLE CORRELATION COEFFICIENTS MATRIX
!     INTEGER SCINV
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  INVERSE MATRIX OF SC
!     INTEGER SD
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  STANDARD DEVIATIONS OF YM
!     INTEGER SLPC
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  SIGNIFICANCE LEVELS OF PC
!     INTEGER SLSC
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  SIGNIFICANCE LEVELS OF SC
!     INTEGER SRCC
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  SPEARMAN RANK COEFFICIENTS
!     INTEGER T
!                  STARTING LOCATION IN THE WORK AREA
!                  FOR THE ARRAY T.
!     INTEGER VCV
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  VARIANCE COVARIANCE MATRIX.
!     INTEGER WRK
!                  THE STARTING LOCATION IN THE WORK AREA FOR
!                  WORK SPACE
!     DOUBLE PRECISION YM(IYM,M)
!                  THE MATRIX IN WHICH THE OBSERVATIONS ARE PASSED
!
!
!     SET UP NAME ARRAY
!
      DATA  NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6)
     +   /       'C',      'O',      'R',      'R',      ' ',      ' '/
!
!     SET UP FRAMEWORK VARIABLES FOR NUMBER TYPE
!
      IFP = 4
!
!     SET CALLER FLAG, THIS IS CORR
!
      ICOR = 1
!
!     PRINTOUT IS AUTOMATICALY PROVIDED
!
      NPRT = 1
!
!     CHECK FOR ERRORS IN PARAMETERS
!
      CALL CORRER(NMSUB, M, N, IYM, M, LDSTAK, ICOR, NPRT)
!
!     IF THERE IS AN ERROR RETURN TO THE CALLERS ROUTINE
!
      IF (IERR.EQ.0) GO TO 10
!
!     PRINT CORRECT FORM OF CALL STATEMENT AND RETURN TO CALLER
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     INITIALIZE THE STACK
!
   10 CALL STKSET (LDSTAK, 4)
      NALL0 = STKST(1)
!
!     ALLOCATE SPACE IN CSTAK FOR MATRICES.
!
      LIWRK = MAX(N,M)
      LWRK = LIWRK
!
      VCV = STKGET(M*M,IFP)
      IWRK = STKGET(LIWRK,2)
      WRK = STKGET(LWRK,IFP)
!
      T = STKGET(M,IFP)
      RANK = STKGET(N*M,IFP)
      SCINV = STKGET(M*M,IFP)
      SLSC = STKGET(M*M,IFP)
      SLPC = STKGET(M*M,IFP)
      SC = STKGET(M*M,IFP)
      PC = STKGET(M*M,IFP)
      QUAD = STKGET(3*N,IFP)
      QF = STKGET(M*M,IFP)
!
!     THE FOLLOWING VARIABLES HAVE BEEN INDIRECTLY EQUIVALENCED-
!
      CIUP = SLSC
      CILO = SLPC
      AVG = WRK
      SD = WRK
      SRCC = SCINV
!
!     CALL THE ROUTINE TO DO THE COMPUTATIONS
!
      CALL CORRMN(YM, N, M, IYM, RSTAK(AVG), RSTAK(SD), RSTAK(T),
     +   RSTAK(RANK), RSTAK(SC), RSTAK(PC), RSTAK(SCINV), ISTAK(IWRK),
     +   RSTAK(WRK), RSTAK(SLSC), RSTAK(SLPC), RSTAK(SRCC),
     +   RSTAK(QUAD), RSTAK(CIUP), RSTAK(CILO), RSTAK(QF),
     +   NPRT, RSTAK(VCV), M, LIWRK, LWRK)
!
!     RETURN AREA TO THE WORK ARRAY
!
      CALL STKCLR(NALL0)
!
      RETURN
!
!     FORMAT STATEMENT
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL CORR (YM, N, M, IYM, LDSTAK)')
      END
!VP
      SUBROUTINE VP(YM, N, NS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,ILOG,IPRT,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  ' ',       'V',       'P',       ' ',       ' ',       ' '/
!
!     DEFINE CONSTANTS
!
!     SET DEFAULT VALUES
!
      YMMISS(1) = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      ILOG = -1
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 0
      ISIZE = -1
      MISS = .FALSE.
      LISYM = 1
      IRLIN = -1
      IBAR = 0
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL VP (Y, N, NS)')
      END
!FITSXP
      SUBROUTINE FITSXP(PAR, PV, SDPV, RES, SDRES, VCV, N, NPAR, IVCV,
     +    RSD)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     GENERATES REPORTS FOR LEAST SQUARES EXERCISER RETURNED STORAGE
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IVCV,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(NPAR),PV(N),RES(N),SDPV(N),SDRES(N),VCV(IVCV,NPAR)
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LSTVEC,MATPRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        INDEX VARIABLE
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT
!     INTEGER IVCV
!        ACTUAL FIRST DIMENSION OF VCV
!     INTEGER N
!        NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        NUMBER OF PARAMETERS
!     DOUBLE PRECISION PAR(NPAR)
!        THE ESTIMATED PARAMETERS.
!     DOUBLE PRECISION PV(N)
!        PREDICTED VALUES
!     DOUBLE PRECISION RES(N)
!        RESIDUALS
!     DOUBLE PRECISION RSD
!        RESIDUAL STANDARD DEVIATION
!     DOUBLE PRECISION SDPV(N)
!        STANDARD DEVIATION OF PREDICTED VALUES
!     DOUBLE PRECISION SDRES(N)
!        STANDARD DEVIATION OF RESIDUALS
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        VARIANCE COVARANCE MATRIX
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      WRITE (IPRT,1002)
      CALL LSTVEC(NPAR, PAR)
      WRITE (IPRT,1001)
      DO 10 I=1,N
         WRITE (IPRT,1010) PV(I), SDPV(I), RES(I), SDRES(I)
   10 CONTINUE
      WRITE (IPRT,1020)
      CALL MATPRT(VCV, VCV, NPAR, IPRT, 1, 1, IVCV)
      WRITE (IPRT,1030) RSD
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(//40H RETURNED RESULTS FROM LEAST SQUARES FIT/ 1X, 39('-'))
 1001 FORMAT (//7X, 2HPV, 13X, 4HSDPV, 12X, 3HRES,12X, 5HSDRES)
 1002 FORMAT (//20H PARAMETERS FROM FIT)
 1010 FORMAT (1X, G14.7, 2X, G14.7, 2X, G14.7, 2X, G14.7)
 1020 FORMAT (//27H VARIANCE COVARIANCE MATRIX)
 1030 FORMAT (//6H RSD =, G14.7)
      END
!UFSLAG
      SUBROUTINE UFSLAG (ACOV, LAGMAX, LAGS, N, NW, NWUSED, LACOV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE LAG WINDOW TRUNCATION POINTS FOR
!     SPECTRUM ANALYSIS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LACOV,LAGMAX,N,NW,NWUSED
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(LACOV)
      INTEGER
     +   LAGS(NW)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ACOVMX,P95LIM
      INTEGER
     +   I,J,K,LAG,NWM1
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,DBLE,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LACOV)
!        THE ARRAY IN WHICH THE AUTOCOVARIANCES ARE STORED
!     DOUBLE PRECISION ACOVMX
!        THE MAXIMUM AUTOCOVARIANCE VALUE.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER J, K
!        INDEX VARIABLES.
!     INTEGER LACOV
!        THE LENGTH OF VECTOR ACOV.
!     INTEGER LAG, LAGMAX
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCOVARIANCE BEING COMPUTED AND THE MAXIMUM LAG TO BE USED,
!        RESPECTIVELY.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NW
!        THE NUMBER OF DIFFERENT BANDWIDTHS REQUESTED.
!     INTEGER NWM1, NWUSED
!        THE NUMBER OF DIFFERENT BANDWIDTHS MINUS 1, AND THE
!        ACTUAL NUMBER OF BANDWIDTHS ACTUALLY USED.
!     DOUBLE PRECISION P95LIM
!        THE 95 PERCENT CONFIDENT LIMIT FOR WHITE NOISE.
!
      LAGS(NW) = LAGMAX
      IF (LAGS(NW) .LE. 32) GO TO 30
!
!     COMPUTE 95 PERCENT CONFIDENCE LIMITS ON AUTOCOVARIANCES,
!     ASSUMING WHITE NOISE.
!
      P95LIM = 1.96D0 * ACOV(1) / SQRT(DBLE(N))
!
!     CHECK FOR FIRST ACVF EXCEEDING 95 PERCENT LIMIT ON WHITE NOISE
!
      DO 10 I = 1, LAGMAX
         LAG = LAGMAX + 1 - I
         IF (ABS(ACOV(LAG + 1)) .GE. P95LIM) GO TO 30
         LAGS(NW) = LAGS(NW) - 1
   10 CONTINUE
!
!     IF NO ACVF EXCEEDS WHITE NOISE LIMITS, CHECK FOR LARGEST ACVF.
!
      LAGS(NW) = 1
      ACOVMX = ABS(ACOV(2))
      DO 20 LAG = 1, LAGMAX
         IF (ABS(ACOV(LAG + 1)) .LE. ACOVMX) GO TO 20
         LAGS(NW) = LAG
         ACOVMX = ABS(ACOV(LAG + 1))
   20 CONTINUE
!
!     COMPUTE LAG WINDOW TRUNCATION POINTS
!
   30 LAGS(NW) = LAGS(NW) * 3.0D0 / 2.0D0
      IF (LAGS(NW) .LT. 32) LAGS(NW) = 32
      IF (LAGS(NW) .GT. LAGMAX) LAGS(NW) = LAGMAX
      NWUSED = NW
      IF (NW .EQ. 1) RETURN
      NWM1 = NW - 1
      DO 40 I = 1, NWM1
         K = NW - I
         LAGS(K) = LAGS(K + 1) / 2
   40 CONTINUE
!
!     CHECK WHETHER ALL NW LAG WINDOW TRUNCATION POINTS CAN BE USED.
!
      NWUSED = NW
      IF (LAGS(1) .GE. 4) RETURN
!
!     RECONSTURCT -LAGS- VECTOR IF NOT ALL TRUNCATION POINTS ARE
!     TO BE USED
!
      DO 50 I = 2, NW
         NWUSED = NWUSED - 1
         IF (LAGS(I) .GE. 4) GO TO 60
   50 CONTINUE
!
   60 DO 70 I = 1, NWUSED
         J = NW - NWUSED + I
         LAGS(I) = LAGS(J)
   70 CONTINUE
!
      RETURN
      END
!LLSMN
      SUBROUTINE LLSMN(Y, X, WT, N, M, NPAR, IX, RES, PAR, NNZW,
     +   RSD, PV, SDPV, SDRES, IPTOUT, WY, XW, VCV, FC, RED,
     +   T, PAR1, ACC, IFIT, WEIGHT, C, LLHDR, PAGE, WIDE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN PROGRAM FOR THE LINEAR LEAST SQUARES FITTING
!     PROGRAMS
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSD
      INTEGER
     +   IFIT,IX,M,N,NNZW,NPAR
      LOGICAL
     +   PAGE,WEIGHT,WIDE
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACC(NPAR),C(NPAR),FC(N,NPAR),PAR(NPAR),PAR1(NPAR),PV(N),
     +   RED(NPAR),RES(N),SDPV(N),SDRES(N),T(NPAR,NPAR),
     +   VCV(NPAR,NPAR),WT(N),WY(N),X(IX,M),XW(N,NPAR),Y(N)
      INTEGER
     +   IPTOUT(4)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL LLHDR
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   COND,DF,FPLM,FPLRS,FPSPM,PROBT,PROBT1,PX,R2,RATIO,RATIO1,
     +   RSD1,RSS,RSS1,RVAR,RVAR1,SDC,SDC1,SM,TD,WTSQRT,WTSUM,WTYM,YSUM
      INTEGER
     +   I,IDF,IDF1,IER,IPRT,IREFIT,ISUBHD,J,K,NC
      LOGICAL
     +   CONST
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   DET(2)
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   CDFT,D1MACH
      EXTERNAL CDFT,D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ACCDIG,FITPT1,FITPT2,IPRINT,MGS,OANOVA,VCVOUT
      EXTERNAL DTRCO,DTRDI
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,SQRT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACC(NPAR)
!        THE NUMBER OF ACCURATE DIGITS.
!     DOUBLE PRECISION C(NPAR)
!        A WORK VECTOR.
!     DOUBLE PRECISION COND
!        THE CONDITION NUMBER OF THE DESIGN MATRIX.
!     LOGICAL CONST
!        AN INDICATOR VALUE DESIGNATING WHETHER THE FIRST COLUMN OF
!        THE DESIGN MATRIX IS ALL ONES FOR A CONSTANT.
!     DOUBLE PRECISION DET(2)
!        THE DETERMINENT.
!     DOUBLE PRECISION DF
!        THE DEGREES OF FREEDOM.
!     DOUBLE PRECISION FC(N,NPAR)
!        THE ORTHONORMALIZATION MATRIX.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     DOUBLE PRECISION FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     DOUBLE PRECISION FPSPM
!        THE FLOATING POINT SMALLEST POSITIVE MAGNITUDE.
!     INTEGER I
!        AN INDEX.
!     INTEGER IDF
!        THE DEGREES OF FREEDOM
!     INTEGER IDF1
!        THE DEGREES OF FREEDOM FOR THE FIT WITHOUT THE LAST INDEPENDENT
!        VARIABLE.
!     INTEGER IER
!        THE ERROR FLAG RETURNED BY THE INVERSION ROUTINES.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IFIT
!        THE INDICATOR VALUE DESIGNATING WHETHER THE FIT IS OF A
!        GENERAL MODEL (IFIT=3) OR A POLYNOMIAL MODEL (IFIT=1).
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IPTOUT(4)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER IREFIT
!        AN INDICATOR USED TO DESIGNATE WHETHER THE FIT IS OF THE
!        FULL DESIGN MATRIX (IREFIT=0) OR IS OMITTING THE LAST
!        INDEPENDENT VARIABLE (IREFIT=1).
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IX
!        THE FIRST DIMENSION OF THE MATRIX X.
!     INTEGER J
!        AN INDEX.
!     INTEGER K
!        AN INDEX.
!     EXTERNAL LLHDR
!        THE NAME OF THE ROUTINE THAT PRODUCED THE HEADING.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NC
!        THE NUMBER OF PARAMETERS BEING FIT.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE PARAMETERS  TO BE ESTIMATED.
!     DOUBLE PRECISION PAR1(NPAR)
!        THE PARAMETERS TO BE ESTIMATED OMMITTING THE LAST
!        INDEPENDENT VARIABLE.
!     DOUBLE PRECISION PROBT
!        ...
!     DOUBLE PRECISION PROBT1
!        ...
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUES.
!     DOUBLE PRECISION PX
!        A WORK VARIABLE.
!     DOUBLE PRECISION RATIO
!        THE RATIO OF THE PARAMETERS TO THEIR STANDARD DEVIATIONS.
!     DOUBLE PRECISION RATIO1
!        THE RATIO OF THE PARAMETERS COMPUTED OMITTING THE LAST
!        INDEPENDENT VARIABLE TO THEIR STANDARD DEVIATIONS.
!     DOUBLE PRECISION RED(NPAR)
!        THE REDUCTION TO THE SUM OF SQUARES DUE TO EACH PARAMETER.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS.
!     DOUBLE PRECISION RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     DOUBLE PRECISION RSD1
!        THE RESIDUAL STANDARD DEVIATION FROM THE FIT OMITTING
!        THE LAST INDEPENDENT VARIABLE.
!     DOUBLE PRECISION RSS
!        THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION RSS1
!        THE RESIDUAL SUM OF SQUARES FROM THE FIT OMITTING
!        THE LAST INDEPENDENT VARIABLE.
!     DOUBLE PRECISION RVAR
!        THE RESIDUAL VARIANCE.
!     DOUBLE PRECISION RVAR1
!        THE RESIDUAL VARIANCE FROM THE FIT OMITTING
!        THE LAST INDEPENDENT VARIABLE.
!     DOUBLE PRECISION R2
!        THE MULTIPLE CORRELATION PARAMETER.
!     DOUBLE PRECISION SDC
!        THE ESTIMATED STANDARD DEVIATIONS OF THE PARAMETERS.
!     DOUBLE PRECISION SDC1
!        THE ESTIMATED STANDARD DEVIATIONS OF THE PARAMETERS OMITTING
!        THE LAST INDEPENDENT VARIABLE.
!     DOUBLE PRECISION SDPV(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(N)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION SM
!        A WORK VARIABLE.
!     DOUBLE PRECISION T(NPAR,NPAR)
!        THE TRIANGULAR MATRIX FROM THE DECOMPOSITION.
!     DOUBLE PRECISION TD
!        A WORK VARIABLE.
!     DOUBLE PRECISION VCV(NPAR,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(N)
!        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
!     DOUBLE PRECISION WTSQRT
!        THE SQUARE ROOT OF THE WEIGHT.
!     DOUBLE PRECISION WTSUM
!        THE SUM OF THE WEIGHTS.
!     DOUBLE PRECISION WTYM
!        THE SUM OF THE WEIGHTED DEPENDENT VARIABLES.
!     DOUBLE PRECISION WY(N)
!        THE VECTOR CONTAINING SQRT(WT)*Y.
!     DOUBLE PRECISION X(IX,M)
!        THE INDEPENDENT VARIABLE.
!     DOUBLE PRECISION XW(N,NPAR)
!        THE MATRIX CONTAINING X * SQRT(WT).
!     DOUBLE PRECISION Y(N)
!        THE DEPENDENT VARIABLE.
!     DOUBLE PRECISION YSUM
!        THE SUM OF THE WEIGHTED DEPENDENT VARIABLES SQUARED.
!
      CALL IPRINT(IPRT)
!
!     INITIALIZE VARIABLES
!
      FPLM = D1MACH(2)
      FPLRS = D1MACH(4)
      FPSPM = D1MACH(1)
      NC = NPAR
      IDF = NNZW - NC
      DF = IDF
!
      R2 = 0.0
      RVAR1 = 0.0
      RSD1 = 0.0
      J = 0
      IDF1 = 0
      CONST = .FALSE.
!
      YSUM = 0.0D0
      WTSUM = 0.0D0
      DO 10 I=1,N
         IF (WT(I).LE.0.0D0) GO TO 10
         YSUM = YSUM + WT(I)*Y(I)*Y(I)
         WTSUM = WTSUM + WT(I)
   10 CONTINUE
!
!     BEGIN FIT
!
      IREFIT = -1
!
!     IF IREFIT IS EQUAL TO 1 FIT IS OMITTING THE LAST VARIABLE
!
   50 IREFIT = IREFIT + 1
!
!     COMPUTE WORKING VECTORS
!
      WTYM = 0.0D0
      I = 0
      DO 70 K=1,N
         IF (WT(K).LE.0.0D0) GO TO 70
         WTSQRT = SQRT(WT(K))
         I = I + 1
         PX = WTSQRT
         DO 60 J=1,NC
            IF (IFIT.EQ.1 .AND. J.GE.2) PX = PX*X(K,1)
            IF (IFIT.EQ.3) PX = X(K,J)*WTSQRT
            XW(I,J) = PX
   60    CONTINUE
!
!     COMPUTE WY ( WEIGHTS * Y VECTOR )
!
         WY(I) = Y(K)*WTSQRT
         WTYM = WTYM + WT(K)*Y(K)
   70 CONTINUE
      WTYM = WTYM/WTSUM
!
!     COMPUTE ESTIMATED VALUES OF PARAMETERS
!
      IF (IREFIT.EQ.1) GO TO 80
      IER = 0
      CALL MGS(XW, WY, NNZW, NC, PAR, C, T(1,1), T, NPAR, N, IER)
      IF (IER.EQ.0) GO TO 90
      IERR = 3
      ISUBHD = 0
      CALL LLHDR(PAGE, WIDE, ISUBHD)
      WRITE (IPRT,1160)
      WRITE (IPRT,1150)
      RETURN
   80 CONTINUE
      IER = 0
      CALL MGS(XW, WY, NNZW, NC, PAR1, C, T(1,1), T, NPAR, N, IER)
!
!     COMPUTE PREDICTED VALUES (PV) AND RESIDUALS (RES)
!             RESIDUAL SUM OF SQUARES (RSS) AND
!             RESIDUAL STANDARD DEVIATION (RSD) AND
!             SUM OF WEIGHTS (WTSUM) AND
!             RESIDUAL VARAINCE (RVAR)
!
   90 RSS = 0.0D0
      RSS1 = 0.0D0
      DO 120 I=1,N
         SM = 0.0D0
         PX = 1.0D0
         DO 100 J=1,NC
            IF (IFIT.EQ.1 .AND. J.GE.2) PX = PX*X(I,1)
            IF (IFIT.EQ.3) PX = X(I,J)
            IF (IREFIT.EQ.0) SM = SM + PAR(J)*PX
            IF (IREFIT.EQ.1) SM = SM + PAR1(J)*PX
  100    CONTINUE
         IF (IREFIT.EQ.0) THEN
            PV(I) = SM
            RES(I) = Y(I) - PV(I)
            RSS = RSS + RES(I)*WT(I)*RES(I)
         ELSE
            RSS1 = RSS1 + (Y(I)-SM)*WT(I)*(Y(I)-SM)
         END IF
  120 CONTINUE
!
      IF (IREFIT.EQ.0) GO TO 130
      RVAR1 = RSS1/(DF+1.0D0)
      RSD1 = SQRT(RVAR1)
      GO TO 380
  130 RVAR = 0.0D0
      IF (DF.GT.0.0D0) RVAR = RSS/DF
      RSD = SQRT(RVAR)
!
!     COMPUTE MULTIPLE CORRELATION PARAMETER SQUARED (R2)
!
      SM = 0.0D0
      CONST = .TRUE.
      DO 140 I=1,N
         IF ((X(I,1).NE.1.0D0) .AND. (IFIT.EQ.3)) CONST = .FALSE.
         SM = SM + (Y(I)-WTYM)*WT(I)*(Y(I)-WTYM)
  140 CONTINUE
      R2 = 1.0D0
      IF (SM.GT.0.0D0) R2 = 1.0D0-RSS/SM
!
!     CHECK FOR -EXACT- FIT
!
      TD = 0.0D0
      IF (DF.GT.0.0D0) TD = SQRT(RSS)
      IF (YSUM.GT.0.0D0) TD = TD/SQRT(YSUM)
      IF (TD.GT.10.0D0*FPLRS) GO TO 180
!
      IERR = 0
      IF ((IPTOUT(1).EQ.0) .AND. (IPTOUT(2).EQ.0) .AND. (IPTOUT(3).EQ.0)
     +   .AND. (IPTOUT(4).EQ.0)) GO TO 145
      ISUBHD = 0
      CALL LLHDR(PAGE, WIDE, ISUBHD)
      WRITE (IPRT,1180)
      WRITE (IPRT,1020) (I,PAR(I),I=1,NPAR)
!
!     ZERO OUT VCV MATRIX AND SDRES AND SDPV VECTORS
!
  145 CONTINUE
      DO 150 I=1,N
         SDPV(I) = 0.0D0
         SDRES(I) = 0.0D0
  150 CONTINUE
      DO 170 I=1,NPAR
         DO 160 J=1,NPAR
            VCV(I,J) = 0.0D0
  160    CONTINUE
  170 CONTINUE
      RETURN
!
  180 CONTINUE
!
!     COMPUTE ORTHO NORMALIZATION
!
      DO 200 I=1,NC
         T(I,I) = SQRT(T(I,1))
         DO 190 J=I,NC
            IF (I.EQ.J) GO TO 190
            T(I,J) = T(I,J)*T(I,I)
  190    CONTINUE
  200 CONTINUE
!
      CALL DTRCO(T, NPAR, NC, COND, C, 1)
      IF (COND.NE.0.0D0) THEN
         COND = 1.0D0/COND
      ELSE
         COND = FPLM
      END IF
      CALL DTRDI(T, NPAR, NC, DET, 011, IER)
!
      IF (IER.EQ.0) GO TO 210
      IERR = 3
      ISUBHD = 0
      CALL LLHDR(PAGE, WIDE, ISUBHD)
      WRITE (IPRT,1160)
      WRITE (IPRT,1120)
      RETURN
  210 CONTINUE
      DO 240 I=1,N
         DO 230 J=1,NC
            SM = 0.0D0
            PX = 1.0D0
            DO 220 K=1,J
               IF (IFIT.EQ.1 .AND. K.GE.2) PX = PX*X(I,1)
               IF (IFIT.EQ.3) PX = X(I,K)
               SM = SM + PX*T(K,J)
  220       CONTINUE
            FC(I,J) = SM
  230    CONTINUE
  240 CONTINUE
!
!     COMPUTE REDUCTION TO RSS DUE TO FITTING
!
      DO 260 J=1,NC
         SM = 0.0D0
         DO 250 I=1,N
            SM = SM + (FC(I,J))*WT(I)*Y(I)
  250    CONTINUE
         RED(J) = (SM*SM)
  260 CONTINUE
!
!     COMPUTE ESTIMATED VARIANCE COVARIANCE MATRIX
!
      DO 290 I=1,NC
         DO 280 J=I,NC
            SM = 0.0D0
            DO 270 K=J,NC
               SM = SM + T(I,K)*T(J,K)
  270       CONTINUE
            IF (SQRT(ABS(SM))*SQRT(RVAR).GE.SQRT(FPSPM)) THEN
               VCV(I,J) = SM*RVAR
            ELSE
               VCV(I,J) = 0.0D0
            END IF
            VCV(J,I) = VCV(I,J)
  280    CONTINUE
  290 CONTINUE
!
!     REFIT TO PREDICTED VALUES
!
      I = 0
      DO 310 K=1,N
         IF (WT(K).LE.0.0D0) GO TO 310
         WTSQRT = SQRT(WT(K))
         I = I + 1
         PX = WTSQRT
         DO 300 J=1,NC
            IF (IFIT.EQ.1 .AND. J.GE.2) PX = PX*X(K,1)
            IF (IFIT.EQ.3) PX = X(K,J)*WTSQRT
            XW(I,J) = PX
  300    CONTINUE
         WY(I) = PV(K)*WTSQRT
  310 CONTINUE
!
      IER = 0
      CALL MGS(XW, WY, NNZW, NC, PAR1, C, T(1,1), T, NPAR, N, IER)
!
      CALL ACCDIG(PAR, PAR1, ACC, NC)
!
!     COMPUTE STANDARD DEVIATION OF PREDICTED VALUES (SDPV)
!     AND STANDARDIZED RESIDUALS (SDRES)
!
      DO 360 I=1,N
         SM = 0.0D0
         DO 330 J=1,NC
            SM = 0.0D0
            PX = 1.0D0
            DO 320 K=1,NC
               IF (IFIT.EQ.1 .AND. K.GE.2) PX = PX*X(I,1)
               IF (IFIT.EQ.3) PX = X(I,K)
               SM = SM + PX*VCV(J,K)
  320       CONTINUE
            XW(I,J) = SM
  330    CONTINUE
         SM = 0.0D0
         PX = 1.0D0
         DO 340 K=1,NC
            IF (IFIT.EQ.1 .AND. K.GE.2) PX = PX*X(I,1)
            IF (IFIT.EQ.3) PX = X(I,K)
            SM = SM + XW(I,K)*PX
  340    CONTINUE
         SM = MAX(0.0D0, SM)
         SDPV(I) = SQRT(SM)
         SDRES(I) = FPLM
         IF (WT(I).LE.0.0D0) GO TO 360
         IF ((RVAR/WT(I)-SM).LE.0.0D0) IERR = 4
         IF (RVAR/WT(I)-SM.GT.0.0D0)
     +      SDRES(I) = (RES(I)/SQRT(RVAR/WT(I)-SM))
  360 CONTINUE
!
!     CHECK FOR PRINTED OUTPUT
!
      IF ((IPTOUT(1).EQ.0) .AND. (IPTOUT(2).EQ.0) .AND.
     +   (IPTOUT(3).EQ.0) .AND. (IPTOUT(4).EQ.0)) RETURN
!
!     BEGIN PRINTED OUTPUT
!
      IF (IPTOUT(1).EQ.0) GO TO 370
!
!     PRINT FIRST PAGE OF OUTPUT
!
      ISUBHD = 0
      CALL LLHDR(PAGE, WIDE, ISUBHD)
      CALL FITPT1(N, M, X, Y, PV, SDPV, RES, SDRES, WT, IX, NNZW,
     +   WEIGHT, IPTOUT(1))
!
!     PRINT PLOTS
!
  370 CONTINUE
      IF (IPTOUT(2).EQ.0) GO TO 375
      ISUBHD = 0
      CALL LLHDR(PAGE, WIDE, ISUBHD)
      CALL FITPT2 (SDRES, PV, WT, N, NNZW, WEIGHT, RES, RSS)
!
  375 CONTINUE
      IF (IPTOUT(3).EQ.0) GO TO 376
!
!     PRINT ANALYSIS OF VARIANCE
!
      ISUBHD = 0
      CALL LLHDR(PAGE, WIDE, ISUBHD)
      CALL OANOVA(YSUM, RED, NPAR, RVAR, NNZW, PAR1, IPRT)
!
  376 CONTINUE
      IF (IPTOUT(4).EQ.0) RETURN
!
      IF (NPAR.EQ.1) GO TO 450
      NC = NC - 1
      IDF1 = NNZW - NC
      GO TO 50
  380 CONTINUE
      DO 400 I=1,NC
         T(I,I) = SQRT(T(I,1))
         DO 390 J=I,NC
            IF (I.EQ.J) GO TO 390
            T(I,J) = T(I,J)*T(I,I)
  390    CONTINUE
  400 CONTINUE
!
      CALL DTRDI(T, NPAR, NC, DET, 011, IER)
!
      IF (IER.EQ.0) GO TO 420
      WRITE (IPRT,1140)
      DO 410 I=1,NC
         PAR1(I) = 0.0D0
         T(I,I) = 0.0D0
  410 CONTINUE
      GO TO 450
  420 CONTINUE
      DO 440 I=1,NC
         SM = 0.0D0
         DO 430 K=I,NC
            SM = SM + T(I,K)*T(I,K)
  430    CONTINUE
         T(I,I) = SM
  440 CONTINUE
!
!     PRINT PAGE HEADINGS
!
  450 CONTINUE
      ISUBHD = 0
      CALL LLHDR(PAGE, WIDE, ISUBHD)
!
!     PRINT VARIANCE COVARIANCE MATRIX
!
      CALL VCVOUT(NPAR, VCV, NPAR, .TRUE.)
!
      WRITE (IPRT,1030)
      IF (NPAR.GT.1) WRITE (IPRT,1040)
      WRITE (IPRT,1050)
      IF (NPAR.GT.1) WRITE (IPRT,1060)
      WRITE (IPRT, 1170)
      IF (NPAR.GE.2) THEN
         DO 460 I=1,NC
            SDC = SQRT(VCV(I,I))
            RATIO = FPLM
            PROBT = 0.0D0
            IF (SDC.GT.0.0D0) RATIO = PAR(I)/SDC
            IF (SDC.GT.0.0D0)
     +         PROBT = (1.0D0-CDFT(ABS(RATIO), NNZW-NPAR)) * 2.0D0
            SDC1 = SQRT(T(I,I))*SQRT(RVAR1)
            RATIO1 = FPLM
            PROBT1 = 0.0D0
            IF (SDC1.GT.0.0D0) RATIO1 = PAR1(I)/SDC1
            IF (SDC1.GT.0.0D0)
     +         PROBT1 = (1.0D0 - CDFT(ABS(RATIO1), NNZW-NPAR+1)) * 2.0D0
            WRITE (IPRT,1070) I, PAR(I), SDC, RATIO, PROBT, ACC(I),
     +         PAR1(I), SDC1, RATIO1, PROBT1
  460    CONTINUE
      END IF
      SDC = SQRT(VCV(NPAR,NPAR))
      RATIO = FPLM
      PROBT = 0.0D0
      IF (SDC.GT.0.0D0) RATIO = PAR(NPAR)/SDC
      IF (SDC.GT.0.0D0)
     +   PROBT = (1.0D0 - CDFT(ABS(RATIO), NNZW-NPAR)) * 2.0D0
      WRITE (IPRT,1070) NPAR, PAR(NPAR), SDC, RATIO, PROBT, ACC(NPAR)
      IF (NPAR.EQ.1) WRITE (IPRT,1080) RSD
      IF (NPAR.GT.1) WRITE (IPRT,1080) RSD, RSD1
      WRITE (IPRT,1090) NNZW, NPAR, IDF
      IF (NPAR.GT.1) WRITE (IPRT,1100) NNZW, NC, IDF1
      IF (CONST) WRITE (IPRT,1010) R2
      WRITE (IPRT,1000) COND
      WRITE (IPRT,1110)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/29H APPROXIMATE CONDITION NUMBER, 10X, G15.7)
 1010 FORMAT (/44H MULTIPLE CORRELATION COEFFICIENT SQUARED   , F7.4)
 1020 FORMAT (//46H THE VALUES COMPUTED FOR THE PARAMETERS ARE - /(5X,
     +   4HPAR(, I3, 4H) = , G15.7))
 1030 FORMAT (////1X, 25('-'), 1X, 18HESTIMATES FROM FIT, 1X, 24('-'))
 1040 FORMAT ('+', 72X, 4('-'), 1X,
     +   48HESTIMATES FROM FIT OMITTING LAST PREDICTOR VALUE, 1X,
     +   4('-'))
 1050 FORMAT (/2X, 19HESTIMATED PARAMETER, 7X, 9HSD OF PAR, 5X,
     +   8HT(PAR=0), 3X, 7HPROB(T), 2X, 8HACC DIG*)
 1060 FORMAT ('+', 72X, 19HESTIMATED PARAMETER, 7X, 9HSD OF PAR, 5X,
     +   8HT(PAR=0), 3X, 7HPROB(T))
 1070 FORMAT (1X, I3, 2X, G16.9, 3X, G16.9, 2X, G10.4, 1X, F5.3, 2X,
     +   F7.1, 9X, G16.9, 3X, G16.9, 2X, G10.4, 1X, F5.3)
 1080 FORMAT (//1X, 30HRESIDUAL STANDARD DEVIATION   , 9X, G15.7, 56X,
     +   G15.7)
 1090 FORMAT (1X, 27HBASED ON DEGREES OF FREEDOM, 7X, I4, 3H - , I2,
     +   3H = , I4)
 1100 FORMAT ('+', 105X, I4, 3H - , I2, 3H = , I4)
 1110 FORMAT (//52H * THE NUMBER OF CORRECTLY COMPUTED DIGITS IN EACH P,
     +   56HARAMETER USUALLY DIFFERS BY LESS THAN 1 FROM THE VALUE G,
     +   10HIVEN HERE.)
 1120 FORMAT (/47H THE PROGRAM WAS UNABLE TO COMPUTE THE VARIANCE,
     +   19H-COVARIANCE MATRIX./
     +   52H THE DESIGN MATRIX IS EITHER NEARLY SINGULAR OR VERY,
     +   17H ILL CONDITIONED./
     +   29H CHECK YOUR INPUT FOR ERRORS.)
 1140 FORMAT (54H0ESTIMATES FOR THE STANDARD DEVIATION OF THE ESTIMATED,
     +   55HPARAMETERS OMITTING THE LAST INDEPENDENT VARIABLE COULD/
     +   59H NOT BE COMPUTED.  THE ZEROS PRINTED FOR THE ESTIMATES OF T,
     +   50HHE PARAMETERS, THEIR STANDARD DEVIATIONS AND THEIR/
     +   59H RATIOS FOR THE FIT OMITTING THE LAST VARIABLE ARE MEANINGL,
     +   4HESS.)
 1150 FORMAT (/30H THE DESIGN MATRIX IS SINGULAR,
     +   29H TO WITHIN MACHINE PRECISION./
     +   50H CHECK THE DESIGN MATRIX FOR A LINEAR RELATIONSHIP,
     +   29H BETWEEN SOME OF THE COLUMNS.)
 1160 FORMAT (//1X, 11('*')/ 1X, 11H*  ERROR  */ 1X, 11('*'))
 1170 FORMAT (' ')
 1180 FORMAT (/50H THE LEAST SQUARES FIT OF THE DATA TO THE MODEL IS,
     +   35H EXACT TO WITHIN MACHINE PRECISION./
     +   38H STATISTICAL ANALYSIS IS NOT POSSIBLE.)
      END
!HPCOEF
      SUBROUTINE HPCOEF (HLP, K, HHP)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTE THE HI-PASS FILTER CORRESPONDING
!     TO THE INPUT K TERM LOW PASS FILTER COEFFICIENTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   K
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   HHP(*),HLP(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,ERR02,ERR03,HEAD
!
!  LOCAL ARRAYS
      CHARACTER
     +   LHLP(8)*1,LK(8)*1,NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,ERIODD,ERSLF,HPFLT,IPRINT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     DOUBLE PRECISION HHP(K)
!        THE ARRAY IN WHICH THE HIGH PASS FILTER COEFFICIENTS
!        WILL BE RETURNED.
!     DOUBLE PRECISION HLP(K)
!        THE ARRAY IN WHICH THE INPUT LOW PASS FILTER COEFFICIENTS
!        ARE STORED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS TO BE COMPUTED.
!     CHARACTER*1 LHLP(8), LK(8)
!        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES HLP AND K.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'H',       'P',       'C',       'O',       'E',       'F'/
      DATA
     +  LK(1), LK(2), LK(3), LK(4), LK(5), LK(6), LK(7), LK(8)
     + /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LHLP(1), LHLP(2), LHLP(3), LHLP(4), LHLP(5), LHLP(6), LHLP(7),
     +  LHLP(8)
     + /  'H',   'L',   'P',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LK, K, 1, 1, HEAD, ERR01, LK)
!
      CALL ERIODD(NMSUB, LK, K, 1, HEAD, ERR02)
!
      IF (ERR01 .OR. ERR02) GO TO 10
!
      CALL ERSLF(NMSUB, LHLP, K, HLP, HEAD, ERR03)
!
      IF (ERR03) GO TO 10
      GO TO 20
!
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   20 CONTINUE
!
      CALL HPFLT (HLP, K, HHP)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   32H       CALL HPCOEF (HLP, K, HHP))
      END
!XXCH4
      SUBROUTINE XXCH4(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE HISTOGRAM FAMILY OF ROUTINES.
!
!     DATA SET IS FROM PAGE 39 OF MANDEL [1964]
!
!     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,N
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   Y(40)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL HIST,IPRINT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        ERROR FLAG
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER N
!        THE LENGTH OF THE VECTOR Y.
!     DOUBLE PRECISION Y(40)
!        DATA VECTOR FOR TESTS.
!
!
!     DATA INITIALIZATIONS.
!
      DATA N /39/
!
      DATA Y( 1), Y( 2), Y( 3), Y( 4)
     +    / 0.4, 0.6, 1.0, 1.0/
      DATA Y( 5), Y( 6), Y( 7), Y( 8)
     +    / 1.0, 0.5, 0.6, 0.7/
      DATA Y( 9), Y(10), Y(11), Y(12)
     +    / 1.0, 0.6, 0.2, 1.9/
      DATA Y(13), Y(14), Y(15), Y(16)
     +    / 0.2, 0.4, 0.0, -0.4/
      DATA Y(17), Y(18), Y(19), Y(20)
     +    / -0.3, 0.0, -0.4, -0.3/
      DATA Y(21), Y(22), Y(23), Y(24)
     +    / 0.1, -0.1, 0.2, -0.5/
      DATA Y(25), Y(26), Y(27), Y(28)
     +    / 0.3, -0.1, 0.2, -0.2/
      DATA Y(29), Y(30), Y(31), Y(32)
     +    / 0.8, 0.5, 0.6, 0.8/
      DATA Y(33), Y(34), Y(35), Y(36)
     +    / 0.7, 0.7, 0.2, 0.5/
      DATA Y(37), Y(38), Y(39)
     +    / 0.7, 0.8, 1.1/
!
!     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
!
      CALL IPRINT(IPRT)
!
!     PRINT HEADING
!
      WRITE (IPRT,1000)
!
!     PERFORM SIMPLE TEST OF HIST
!
      WRITE (IPRT,1100)
      CALL HIST(Y, N, LDSTAK)
      WRITE (IPRT,2000) IERR
!
      RETURN
!
!     FORMATS
!
 1000 FORMAT ('1*CH4')
 1100 FORMAT (' SIMPLE TEST OF HIST')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
!ERAGTM
      SUBROUTINE ERAGTM (NMSUB, NMVAR, YM, YMMISS, N, M, IYM, YMMN,
     +   NVMX, HEAD, MSGTYP, NV, ERROR, NMMIN)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS TO ENSURE THAT NO VALUES, OR ONLY A MAXIMUM
!     OF NVMX, ARE NOT GREATER THAN A SPECIFIED LOWER BOUND YMMN,
!     WITH NAME NMMIN.   THE CHECKING OPTION IS SPECIFIED
!     WITH MSGTYP.  IF AN ERROR IS FOUND, THE ERROR IS PRINTED AND
!     AN ERROR FLAG AND THE NUMBER OF VIOLATINS ARE RETURNED.
!     ELEMENTS OF YM(*, I) EQUAL TO YMMISS(I) ARE EXEMPT FROM CHECKING.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMMN
      INTEGER
     +   IYM,M,MSGTYP,N,NV,NVMX
      LOGICAL
     +   ERROR,HEAD
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(*)
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
!
!  LOCAL SCALARS
      INTEGER
     +   I,J
!
!  EXTERNAL FUNCTIONS
      LOGICAL
     +   MVCHK
      EXTERNAL MVCHK
!
!  EXTERNAL SUBROUTINES
      EXTERNAL ERAGTP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IYM
!        THE FIRST DIMENSION OF THE ARRAY YM.
!     INTEGER J
!        AN INDEXING VARIABLE.
!     INTEGER M
!        THE NUMBER OF COLUMNS OF DATA IN YM.
!     INTEGER MSGTYP
!        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
!        IF (MSGTYP.GE.3) THE MESSAGE PRINTED WILL USE NMMIN
!        OTHERWISE IT WILL USE YMMN.
!        IF (MSGTYP = 1 OR 3) NO VIOLATIONS ARE ALLOWED.
!        IF (MSGTYP = 2 OR 4) THE NUMBER OF VIOLATIONS MUST
!                             BE LESS THAN   NVMX   .
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE PARAMETERS NAME.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND.
!     INTEGER NVMX
!        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
!     DOUBLE PRECISION YM(IYM,M)
!        THE ARRAY BEING TESTED.
!     DOUBLE PRECISION YMMISS(M)
!        MISSING VALUE CODES FOR EACH COLUMN OF YM
!     DOUBLE PRECISION YMMN
!        THE MINIMUM ACCEPTABLE VALUE.
!
      ERROR = .FALSE.
!
      IF ((N.LE.0) .OR. (M.LE.0)) RETURN
!
!     CHECK FOR VIOLATIONS
!
      NV = 0
      DO 5 I = 1, N
         DO 1 J = 1, M
            IF (MVCHK(YM(I+(J-1)*IYM), YMMISS(J))) GO TO 1
            IF (YM(I+(J-1)*IYM) .LE. YMMN) NV = NV + 1
    1    CONTINUE
    5 CONTINUE
!
      IF (NV .LE. NVMX) RETURN
!
!     VIOLATIONS FOUND
!
      ERROR = .TRUE.
      CALL ERAGTP (NMSUB, NMVAR, YMMN, NVMX, HEAD, MSGTYP, NV,
     +   NMMIN)
!
      RETURN
!
      END
!SPPL
      SUBROUTINE SPPL(YM, X, N, ISYM, ILOG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH USER CONTROL OF PLOT SYMBOLS (LOG OPTION).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   X(*),YM(*)
      INTEGER
     +   ISYM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XLB,XMISS,XUB,YLB,YUB
      INTEGER
     +   IPRT,ISCHCK,ISIZE,IYM,LISYM,M,NOUT
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     DOUBLE PRECISION X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     DOUBLE PRECISION XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     DOUBLE PRECISION XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     DOUBLE PRECISION YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'P',       'P',       'L',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      YMMISS(1) = 1.0D0
      XMISS = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 0.0D0
      XUB = 0.0D0
      ISCHCK = 1
      ISIZE = -1
      NOUT = 0
      MISS = .FALSE.
      LISYM = N
!
      CALL PPCNT (YM, YMMISS, X, XMISS, N, M, IYM, MULTI, ILOG,
     +  YLB, YUB, XLB, XUB, NMSUB, ISCHCK, ISYM, ISIZE, NOUT, MISS,
     +  LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL SPPL (Y, X, N, ISYM, ILOG)')
      END
!ACFSD
      SUBROUTINE ACFSD (RHO, SDRHO, NC, N)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE STANDARD ERROR OF THE AUTOCORRELATIONS
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N,NC
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   RHO(*),SDRHO(*)
!
!  LOCAL SCALARS
      INTEGER
     +   K,KLAST,LAG
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN,DBLE,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER KLAST
!        THE LAST LAG VALUE TO BE USED.
!     INTEGER LAG
!        THE INDEX VARIABLE USED TO INDICATE THE AUTOCORRELATION
!        BEING EXAMINED.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NC
!        THE NUMBER OF AUTOCORRELATIONS COMPUTED
!     DOUBLE PRECISION RHO(NC)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
!     DOUBLE PRECISION SDRHO(NC)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!        ARE STORED
!
      SDRHO(1) = SQRT(DBLE(N - 1)) / N
      IF (NC .EQ. 1) RETURN
      DO 20 LAG = 2, NC
         SDRHO(LAG) = 0.0D0
         KLAST = MIN(LAG-1, N-LAG)
         DO 10 K = 1, KLAST
            SDRHO(LAG) = SDRHO(LAG) + (N-LAG-K) * RHO(K) * RHO(K)
   10    CONTINUE
         SDRHO(LAG) = SQRT((N-LAG) + 2.0D0 * SDRHO(LAG)) / N
   20 CONTINUE
      RETURN
      END
!UFSVS
      SUBROUTINE UFSVS(ACOV, LAGMAX, N, NW, LAGS, NF,
     +   FMIN, FMAX, NPRT, SPCF, ISPCF, FREQ, LDSTAK)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS AND USER SUPPLIED ACVF VALUES (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   ISPCF,LAGMAX,LDSTAK,N,NF,NPRT,NW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   ACOV(*),FREQ(*),SPCF(*)
      INTEGER
     +   LAGS(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,YMISS
      INTEGER
     +   IFP,IO,IPRT,ISORT,ISYM,LACOV,LDSMIN,LNLPPA,LPCV,LWORK,LY,
     +   NALL0,WORK,XAXIS,YAXIS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12),Y(1)
      INTEGER
     +   ISTAK(12),NLPPA(1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UFSDRV
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ACOV(LAGMAX+1)
!        THE AUTOCOVARIANCES OF THE SERIES.
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE SPECTRUM
!        IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF ERR01, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION FOR THE ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY ISYM.
!     INTEGER LACOV
!        THE LENGTH OF THE ACVF VECTORS.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
!        THIS ROUTINE WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(1)
!        A DUMMY ARRAY FOR SERIES WITHOUT MISSING VALUES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION SPCF(ISPCF,NW)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     INTEGER WORK
!        THE STARTING LOCATION IN RSTAK FOR
!        THE WORK VECTOR.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY XAXIS.
!     DOUBLE PRECISION Y(1)
!        A DUMMY ARRAY.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY YAXIS.
!     DOUBLE PRECISION YMISS
!        A DUMMY VARIABLE.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','V','S',' '/
!
!     SET UP
!
      OPTION(4) = .TRUE.
      OPTION(3) = .TRUE.
      OPTION(2) = .FALSE.
      OPTION(1) = .FALSE.
!
      LACOV = LAGMAX+1
!
!     COMPUTE MINIMUM ALLOWABLE STACK LENGTH
!
      IO = 1
      IF (NPRT.EQ.0) IO = 0
!
      CALL LDSCMP(4, 0, IO*(NF+5), 0, 0, 0, 'D',
     +   LAGMAX+1+IO*(2*NF+10), LDSMIN)
!
      YMISS = 1.0D0
!
      LY = 1
      LNLPPA = 1
      LPCV = NF + 5
      LWORK = LAGMAX+1
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!     SET THE STACK ALLOCATION TYPE.
!
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
!
      IFP = 4
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
!
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         WORK = 1
         XAXIS = 1
         YAXIS = 1
         ISYM = 1
         ISORT = 1
      ELSE
         WORK = STKGET(LWORK,IFP)
         IF (NPRT.NE.0) THEN
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
            ISYM = STKGET(LPCV,2)
            ISORT = ISYM
         ELSE
            XAXIS = WORK
            YAXIS = WORK
            ISYM = WORK
            ISORT = ISYM
         END IF
      END IF
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!
      CALL UFSDRV(Y, LY, YMISS, ACOV, NLPPA, SPCF, ISPCF, NF, FMIN,
     +   FMAX, FREQ, N, NW, LAGMAX, LAGS, RSTAK(WORK), LACOV, LWORK,
     +   DELTA, ISTAK(ISORT), ISTAK(ISYM), RSTAK(XAXIS), RSTAK(YAXIS),
     +   LPCV, ALPHA, NPRT, PARZEN, NMSUB, LDSMIN, LDSTAK, OPTION,
     +   LNLPPA, LY)
!
      CALL STKCLR(NALL0)
!
!     CHECK FOR ERRORS
!
      IF (IERR.EQ.0) RETURN
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL UFSVS (ACOV, LAGMAX, N,'/
     +   '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +   '      +            SPCF, ISPCF, FREQ, LDSTAK)')
      END
!CNTR
      SUBROUTINE CNTR (Y, N, YC)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CENTERS THE INPUT SERIES Y ABOUT ITS MEAN,
!     RETURNING THE CENTERED SERIES IN YC.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*),YC(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   YMEAN
      INTEGER
     +   I
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AMEAN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE INPUT SERIES.
!     DOUBLE PRECISION Y(N)
!        THE INPUT ARRAY OF OBSERVATIONS TO BE CENTERED.
!     DOUBLE PRECISION YC(N)
!        THE OUTPUT ARRAY OF CENTERED OBSERVATIONS.
!     DOUBLE PRECISION YMEAN
!        THE MEAN OF THE INPUT SERIES.
!
      CALL AMEAN (Y, N, YMEAN)
!
      DO 10 I = 1, N
         YC(I) = Y(I) - YMEAN
   10 CONTINUE
!
      RETURN
!
      END
!GFORD
      SUBROUTINE GFORD (FREQ, GAIN, ISORT, NF, XORD, YORD,
     +   NORD, YPLTMN, YPLTMX, NPRT, IGFERR)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES ORDANENTS FOR THE GAIN FUNCTION PLOTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YPLTMN,YPLTMX
      INTEGER
     +   IGFERR,NF,NORD,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),GAIN(NF),XORD(NF),YORD(NF)
      INTEGER
     +   ISORT(NF)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   GAINMN,GAINMX,YMAX
      INTEGER
     +   I,J
!
!  EXTERNAL SUBROUTINES
      EXTERNAL SPCCK
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG10
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     DOUBLE PRECISION GAIN(NF)
!        THE VECTOR IN WHICH THE GAIN FUNCTION IS STORED.
!     DOUBLE PRECISION GAINMN, GAINMX
!        THE MINIMUM AND MAXIMUM GAIN FUNCTION VALUE TO BE PLOTTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IGFERR
!        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
!        TO HAVE PRODUCED REASONABLE RESULTS.
!     INTEGER ISORT(NF)
!        THE ARRAY USED FOR SORTING.
!     INTEGER J
!        AN INDEXING VARIABLE.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
!        ARE TO BE ESTIMATED.
!     INTEGER NORD
!        THE NUMBER OF ORDINATES TO BE PLOTTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     DOUBLE PRECISION XORD(NF)
!        THE X ORDINATES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YMAX
!        THE MAXIMUM ACTUAL SPECTRUM VALUE (IN DECIBELS) TO BE PLOTTED.
!     DOUBLE PRECISION YORD(NF)
!        THE Y ORDINATES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VAUES TO BE PLOTTED FOR THE Y AXIS.
!
      IGFERR = 0
!
      CALL SPCCK (GAIN, ISORT, NF, GAINMN, GAINMX, NORD, IGFERR)
!
      IF (IGFERR .NE. 0) RETURN
!
      J = 0
!
      IF (NPRT.GE.1) GO TO 30
!
!     SET ORDINATES FOR DECIBLE PLOTS
!
      YMAX = 10.0D0 * LOG10(GAINMX)
!
      YPLTMX = 0.0D0
      YPLTMN = 10.0D0 * LOG10(GAINMN) - YMAX
!
      DO 10 I = 1, NF
         IF (GAIN(I) .LT. GAINMN) GO TO 10
         J = J + 1
         XORD(J) = FREQ(I)
         YORD(J) = 10.0D0 * LOG10(GAIN(I)) - YMAX
   10 CONTINUE
!
      RETURN
!
   30 CONTINUE
!
      YPLTMX = GAINMX
      YPLTMN = GAINMN
!
!     SET ORDINATES FOR LOG PLOTS
!
      DO 50 I = 1, NF
         IF (GAIN(I) .LT. GAINMN) GO TO 50
         J = J + 1
         XORD(J) = FREQ(I)
         YORD(J) = GAIN(I)
   50 CONTINUE
!
      RETURN
      END
!FITPT2
      SUBROUTINE FITPT2 (SDRES, PV, WT, N, NNZW, WEIGHT, RES, RSS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE, ADAPTED FROM OMNITAB II, PRINTS
!     THE FOUR STANDARDIZED RESIDUAL PLOTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   RSS
      INTEGER
     +   N,NNZW
      LOGICAL
     +   WEIGHT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PV(N),RES(N),SDRES(N),WT(N)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ANNZW,DOT,FAC1,FAC2,FPLM,GAMMA,PI,PVDIV,PVMAX,PVMID,PVMIN,
     +   RATIO,ROWDIV,ROWMAX,ROWMID,ROWMIN,W,XDIV,XMAX,XMIN,YLABEL,
     +   YMAX,YMIN
      INTEGER
     +   I,I1,I2,IDOT,IFIRST,IMID,IPLOT,IPRB,IPRT,IPV,IROW,IX,K,L,
     +   NCOL,NCOLP1,NCOLPL,NCOLT2,NDOT,NROW
      CHARACTER
     +   IBLANK*1,IMINUS*1,IPLUS*1,ISTAR*1
!
!  LOCAL ARRAYS
      CHARACTER
     +   LINE(102)*1
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      LOGICAL
     +   MVCHK
      EXTERNAL D1MACH,MVCHK
!
!  EXTERNAL SUBROUTINES
      EXTERNAL GETPI,IPRINT
!
!  INTRINSIC FUNCTIONS
      INTRINSIC INT,MAX,MIN,MOD
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ANNZW
!        THE NUMBER OF NONZERO WEIGHTS, USED IN COMPUTING
!        THE NORMAL PROBABILITY PLOT.
!     DOUBLE PRECISION DOT
!        ...
!     DOUBLE PRECISION FAC1, FAC2
!        FACTORS USED IN COMPUTING THE NORMAL PROBABILITY PLOT.
!     DOUBLE PRECISION FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     DOUBLE PRECISION GAMMA
!        A VALUE USED IN COMPUTING THE NORMAL PROBABILITY PLOT.
!     INTEGER I
!        AN INDEX VARIABLE.
!     CHARACTER*1 IBLANK
!        THE VALUE OF THE CHARACTER -BLANK-.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS HAVE
!        BEEN DETECTED.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED.
!     INTEGER IFIRST
!        THE FIRST ROW OF THE VARIABLES TO BE PLOTTED.
!     INTEGER IMID
!        THE MIDPOINT OF THE FIRST PLOT OF THE SECOND SET
!     CHARACTER*1 IMINUS
!        THE CHARACTER MINUS.
!     INTEGER IPLOT
!        AN INDICATOR VARIABLE DESIGNATING WHETHER THE FIRST OR
!        SECOND SET OF TWO PLOTS ARE BEING PRINTED.
!     CHARACTER*1 IPLUS
!        THE CHARACTER PLUS.
!     INTEGER IPRB
!        THE LOCATION IN THE PLOT STRING OF THE SYMBOL FOR THE
!        PROBABILITY PLOT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IPV
!        THE LOCATION IN THE PLOT STRING OF THE SYMBOL FOR THE PLOT
!        VERSUS PREDICTED VALUE.
!     INTEGER IROW
!        THE ROW OF THE VARIABLES BEING PLOTTED.
!     CHARACTER*1 ISTAR
!        THE CHARACTER STAR.
!     INTEGER IX
!        THE LOCATION IN THE PLOT STRING OF THE SYMBOL FOR THE PLOTS
!        VERSUS THE INDEPENDENT VARIABLE.
!     INTEGER I1, I2
!        ...
!     INTEGER K, L
!        INDEX VARIABLES.
!     CHARACTER*1 LINE(102)
!        THE SYMBOLS (BLANKS AND CHARACTERS) FOR A GIVEN LINE
!        OF THE PLOT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN EACH COLUMN OF DATA.
!     INTEGER NCOL, NCOLPL, NCOLP1, NCOLT2
!        THE NUMBER OF COLUMNS IN THE PLOT, NCOL+L, NCOL+1,
!        AND NCOL * 2.
!     INTEGER NDOT
!        ...
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NROW
!        THE NUMBER OF COLUMNS IN THE PLOT.
!     DOUBLE PRECISION PI
!        THE VALUE OF PI.
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT COEFFICIENT ESTIMATES
!     DOUBLE PRECISION PVDIV
!        THE VALUE OF A DIVISION ALONG THE -PREDICTED VALUE- AXIS.
!     DOUBLE PRECISION PVMAX
!        THE LARGEST VALUE IN THE VECTOR PV.
!     DOUBLE PRECISION PVMID
!        THE MIDPOINT OF THE RANGE OF VALUES IN THE VECTOR PV.
!     DOUBLE PRECISION PVMIN
!        THE SMALLEST VALUE IN THE VECTOR PV.
!     DOUBLE PRECISION RATIO
!        A VALUE USED TO PRODUCE THE NORMAL PROBABILITY PLOT.
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION ROWDIV
!        THE VALUE OF A DIVISION ALONG THE -ROW- AXIS.
!     DOUBLE PRECISION ROWMAX
!        THE LARGEST ROW VALUE.
!     DOUBLE PRECISION ROWMID
!        THE MIDPOINT OF THE RANGE OF THE ROWS PLOTTED.
!     DOUBLE PRECISION ROWMIN
!        THE SMALLEST ROW VALUE PLOTTED.
!     DOUBLE PRECISION RSS
!        THE RESIDUAL SUM OF SQUARES.
!     DOUBLE PRECISION SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     DOUBLE PRECISION W
!        THE VALUE OF THE WEIGHT FOR THE CURRENT VALUE BEING PLOTTED.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(N)
!        THE USER SUPPLIED WEIGHTS.
!     DOUBLE PRECISION XDIV
!        THE VALUE OF A DIVISION ALONG THE X AXIS.
!     DOUBLE PRECISION XMAX
!        THE LARGEST VALUE ALONG THE X AXIS.
!     DOUBLE PRECISION XMIN
!        THE SMALLEST VALUE ALONG THE X AXIS.
!     DOUBLE PRECISION YLABEL
!        THE LABEL TO BE PRINTED ALONG THE Y AXIS.
!     DOUBLE PRECISION YMAX
!        THE LARGEST VALUE ALONG THE Y AXIS
!     DOUBLE PRECISION YMIN
!        THE SMALLEST VALUE ALONG THE Y AXIS.
!
      DATA IPLUS/'+'/, IMINUS/'-'/, ISTAR/'*'/, IBLANK/' '/
!
      CALL IPRINT(IPRT)
!
      FPLM = D1MACH(2)
!
!     CHECK FOR INSUFFICIENT POINTS TO PLOT
!
      IF (IERR.EQ.4) THEN
         DO 1 I = 1, N
            IF (SDRES(I).NE.FPLM) GO TO 5
    1    CONTINUE
         WRITE (IPRT, 1090)
         RETURN
      END IF
    5 CONTINUE
!
!     INITIALIZE VARIABLES FOR PROBABILITY PLOT
!
      CALL GETPI(PI)
      GAMMA = PI/8.0D0
      ANNZW = NNZW
      FAC1 = 1.0D0 / (ANNZW - 2.0D0*GAMMA + 1.0D0)
      FAC2 = 10.0D0
!
!     INITIALIZE THE PLOT SIZE (IN PLOT UNITS)
!
      NROW = 26
      NCOL = 51
      NCOLP1 = NCOL + 1
      NCOLT2 = 2*NCOL
      IMID = (NCOL-1)/2
!
!     FIND THE FIRST ROW OF OBSERVATIONS WITH NONZERO WEIGHTS
!
      IFIRST = 1
      IF (.NOT. WEIGHT) GO TO 20
      DO 10 I=1,N
         IF (WT(I).LE.0.0D0) GO TO 10
         IFIRST = I
         GO TO 20
   10 CONTINUE
!
!     BEGIN COMPUTATIONS FOR FIRST SET OF PLOTS
!
   20 IPLOT = 1
!
!     SET X AXIS LIMITS FOR STANDARDIZED RESIDUAL VS ROW PLOT,
!     AND STANDARDIZED RESIDUALS VS PREDICTED VALUES PLOT.
!
      ROWMIN = IFIRST
      PVMIN = PV(IFIRST)
      PVMAX = PV(IFIRST)
      ROWMAX = IFIRST
      DO 30 I=IFIRST,N
         W = 1.0D0
         IF (WEIGHT) W = WT(I)
         IF (W.GT.0.0D0) THEN
            ROWMAX = I
            IF (PV(I).LT.PVMIN) PVMIN = PV(I)
            IF (PV(I).GT.PVMAX) PVMAX = PV(I)
         END IF
   30 CONTINUE
!
      IF (PVMIN.LT.PVMAX) GO TO 35
         IF (PVMIN.EQ.0.0D0) GO TO 33
            PVMIN = PVMIN - PVMIN/2.0D0
            PVMAX = PVMAX + PVMAX/2.0D0
         GO TO 35
   33    CONTINUE
            PVMIN = -0.5D0
            PVMAX = 0.5D0
   35 CONTINUE
!
      ROWMID = (ROWMAX+ROWMIN)/2.0D0
      ROWDIV = (ROWMAX-ROWMIN)/(NCOL-1)
      PVMID = (PVMAX+PVMIN)/2.0D0
      PVDIV = (PVMAX-PVMIN)/(NCOL-1)
!
!     PRINT TITLES FOR FIRST PLOTS
!
      WRITE (IPRT,1000)
      GO TO 90
!
!     BEGIN COMPUTATIONS FOR SECOND SET OF PLOTS
!
   40 IPLOT = 2
!
!     SET AXIS LIMITS FOR THE STANDARDIZED RESIDUALS VS
!     STANDARDIZED RESIDUALS LAGED BY ONE AND FOR PROBABILITY PLOT
!
      XMIN = -3.75D0
      XMAX = 3.75D0
      XDIV = (XMAX-XMIN)/(NCOL-1)
!
!     PRINT TITLES FOR SECOND PLOTS
!
      WRITE (IPRT,1050)
!
!     WRITE FIRST LINE OF PLOTS
!
   90 CONTINUE
!
!     PRINT PLOTS, ONE LINE AT A TIME
!
      YLABEL = 3.75D0
      YMAX = FPLM
      YMIN = 4.05D0
      DO 160 K=1,NROW
         YMIN = YMIN - 0.3D0
         IF (-3.70D0.GE.YMIN) YMIN = -FPLM
         DO 100 L=1,NCOL
            NCOLPL = L + NCOL
            LINE(L) = IBLANK
            LINE(NCOLPL) = IBLANK
            IF ((K.NE.1) .AND. (K.NE.NROW)) GO TO 100
               LINE(L) = IMINUS
               LINE(NCOLPL) = IMINUS
               IF ((MOD(L,10).NE.1) .AND. (L.NE.1+NCOL/2)) GO TO 100
                  LINE(L) = IPLUS
                  LINE(NCOLPL) = IPLUS
  100    CONTINUE
         DO 110 I=1,N
            IF (WEIGHT) THEN
               W = WT(I)
            ELSE
               W = 1.0D0
            END IF
            IF ((W.NE.0.0D0) .AND. (.NOT.MVCHK(SDRES(I),FPLM))) THEN
               IF ((SDRES(I).GT.YMIN) .AND. (SDRES(I).LE.YMAX)) THEN
                  IF (IPLOT.EQ.1) THEN
!
!     SET PLOT LINE FOR FIRST SET OF PLOTS
!
                     IROW = INT(((I-ROWMIN)/ROWDIV)+1.5D0)
                     LINE(IROW) = ISTAR
                     IPV = INT((PV(I)-PVMIN)/PVDIV+1.5D0) + NCOL
                     LINE(IPV) = ISTAR
                  ELSE
!
!     SET PLOT LINE FOR PROBABILITY PLOT
!
                     RATIO = (ANNZW-GAMMA) * FAC1
                     IPRB = INT(4.91D0*(RATIO**0.14D0-
     +                         (1.0D0-RATIO)**0.14D0)*FAC2) + 77
                     IF (IPRB.LE.NCOL) IPRB = NCOL+1
                     IF (IPRB.GE.103) IPRB = 102
                     LINE(IPRB) = ISTAR
                     ANNZW = ANNZW - 1.0D0
                     IF ((ANNZW.LT.2.0D0) .AND. (NNZW.LE.10)) THEN
                        GAMMA = 1.0D0/3.0D0
                     END IF
                  END IF
               END IF
            END IF
  110    CONTINUE
!
!     SET PLOT LINE FOR CORRELATION PLOT
!
         IF (IPLOT.EQ.2) THEN
            IF (K.LE.N-1) THEN
              DOT = 0.0D0
              IF (WEIGHT) THEN
                NDOT = 0
                DO 120 IDOT = 1, N-K
                  IF ((WT(IDOT).GT.0.0D0) .AND.
     +                (WT(IDOT+K).GT.0.0D0)) THEN
                    NDOT = NDOT + 1
                    DOT = DOT + RES(IDOT)*RES(IDOT+K)
                  END IF
  120           CONTINUE
                IF (NDOT.GE.1) THEN
                   DOT = DOT * (N-K) / NDOT
                END IF
              ELSE
                DO 130 IDOT = 1, N-K
                  DOT = DOT + RES(IDOT)*RES(IDOT+K)
  130           CONTINUE
              END IF
              IX = INT(IMID*DOT/RSS) + IMID + 1
              I1 = MIN(IX,IMID+1)
              I2 = MAX(IX,IMID+1)
              DO 140 IX=I1,I2
                LINE(IX) = ISTAR
  140         CONTINUE
            END IF
         END IF
         IF (MOD(K,5).EQ.1) THEN
            IF (IPLOT.EQ.1) THEN
               WRITE (IPRT,2020) YLABEL, (LINE(L),L=1,NCOL), YLABEL,
     +         (LINE(L),L=NCOLP1,NCOLT2)
            ELSE
               WRITE (IPRT,1020) K, (LINE(L),L=1,NCOL), YLABEL,
     +         (LINE(L),L=NCOLP1,NCOLT2)
            END IF
            YLABEL = YLABEL - 1.5
         ELSE
            WRITE (IPRT,1030) (LINE(L),L=1,102)
         END IF
         YMAX = YMIN
  160 CONTINUE
!
!     PRINT BOTTOM LINE OF GRAPHS
!
      IF (IPLOT.EQ.1) THEN
!
!     PRINT X AXIS LABELS FOR FIRST SET OF PLOTS
!
         WRITE (IPRT,1040) ROWMIN, ROWMID, ROWMAX, PVMIN, PVMID, PVMAX
         GO TO 40
      ELSE
!
!     PRINT X AXIS LABELS FOR SECOND SET OF PLOTS
!
         WRITE (IPRT,1070)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/20X, 23H STD RES VS ROW NUMBER , 35X,
     +   29H STD RES VS PREDICTED VALUES )
!1010 FORMAT (7X, 2('+', 9A1), '+', 4A1, 'X', 4A1, 2('+', 9A1), '+',
!    *   10X, 2('+', 9A1), '+', 4A1, 'X', 4A1, 2('+', 9A1), '+')
 1020 FORMAT (1X, I5, '+', 51A1, '+', 3X, F5.2, '+', 51A1, '+')
 1030 FORMAT (6X, '-', 51A1, '-', 8X, '-', 51A1, '-')
 1040 FORMAT (1X, F8.1, 17X, F8.1, 17X, F8.1, 4X, G11.4, 14X, G11.4,
     +   10X, G11.4)
 1050 FORMAT (/13X, 'AUTOCORRELATION FUNCTION OF RESIDUALS',
     +   23X, 36H NORMAL PROBABILITY PLOT OF STD RES )
!1060 FORMAT ('+', F5.2, '+', 51A1, '+', 3X, F5.2, '+', 51A1, '+')
 1070 FORMAT (4X, 5H-1.00, 22X, 3H0.0, 21X, 4H1.00, 5X, 4H-2.5, 23X,
     +   3H0.0, 22X, 3H2.5)
!1080 FORMAT ('+', 6X, 2('+', 9A1), '+', 4A1, 'X', 4A1, 2('+', 9A1),
!    *   '+', 10X, 2('+', 9A1), '+', 4A1, 'X', 4A1, 2('+', 9A1), '+')
 1090 FORMAT (// 1X, 13('*')/ 1X, 13H*  WARNING  */ 1X, 13('*')//
     +   54H THE STANDARDIZED RESIDUAL PLOTS HAVE BEEN SUPPRESSED.,
     +   45H  NONE OF THE STANDARDIZED RESIDUALS COULD BE,
     +   10H COMPUTED,/
     +   50H BECAUSE FOR EACH OBSERVATION EITHER THE WEIGHT OR,
     +   48H THE STANDARD DEVIATION OF THE RESIDUAL IS ZERO.)
 2020 FORMAT (1X, F5.2, '+', 51A1, '+', 3X, F5.2, '+', 51A1, '+')
      END
!SVPML
      SUBROUTINE SVPML(YM, YMMISS, N, NS, ISYM, ILOG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA AND USER CONTROL OF THE PLOT SYMBOL USED
!     (LOG PLOT OPTION).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*),YMMISS(*)
      INTEGER
     +   ISYM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,IPRT,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  'S',       'V',       'P',       'M',       'L',       ' '/
!
!     SET DEFAULT VALUES
!
      M = 1
      IYM = N
      MULTI = .FALSE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 1
      ISIZE = -1
      MISS = .TRUE.
      LISYM = N
      IRLIN = -1
      IBAR = 0
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +  '       CALL SVPML (Y, YMISS, N, NS, ISYM, ILOG)')
      END
!MVCHK
      LOGICAL FUNCTION MVCHK (X, XMISS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS WHETHER X = XMISS (MVCHK = TRUE) OR NOT
!     (MVCHK = FALSE) IN A MANNER WHICH WILL PREVENT VERY LARGE OR
!     VERY SMALL MISSING VALUE CODES FROM CAUSING AN OVERFLOW.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   X,XMISS
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION X
!        THE VALUE TO BE CHECKED.
!     DOUBLE PRECISION XMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IS MISSING.  IF X = XMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!
      IF ((X .GT. 0.0D0 .AND. XMISS .LT. 0.0D0) .OR.
     +    (X .LT. 0.0D0 .AND. XMISS .GT. 0.0D0)) GO TO 10
!
      IF (ABS(X) .EQ. ABS(XMISS)) GO TO 20
!
   10 MVCHK = .FALSE.
      RETURN
!
   20 MVCHK = .TRUE.
      RETURN
!
      END
!STPLS1
      SUBROUTINE STPLS1(N, M, IXM, PAR, NPAR, NETA, EXMPT, SCALE, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     SET UP PROBLEM SPECIFICATION FOR TESTING THE USER CALLABLE
!     ROUTINES IN THE (LEAST SQUARES) STEP SIZE SELECTION FAMILY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   EXMPT
      INTEGER
     +   IXM,M,N,NETA,NPAR,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(10),SCALE(10)
!
!  LOCAL SCALARS
      INTEGER
     +   I
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION SCALE(10)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!
      PAR(1) = 0.0D0
      PAR(2) = 3.125D0
      PAR(3) = 1.0D0
      PAR(4) = 2.0D0
!
      N = 101
      M = 1
      IXM = 200
      NPAR = 4
      DO 10 I=1,10
         SCALE(I) = 1.0D0
   10 CONTINUE
      NETA = 0
      EXMPT = 0.0D0
      NPRT = 1
!
      RETURN
!
      END
!STPMN
      SUBROUTINE STPMN(J,XM,N,M,IXM,MDL,PAR,NPAR,
     +   NEXMPT,ETA,RELTOL,SCALE,STP,NFAIL,IFAIL,CD,
     +   ITEMP,FD,FDLAST,FDSAVE,PV,PVMCD,PVNEW,PVPCD,PVSTP,PVTEMP)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR SELECTING THE STEP SIZE FOR
!     COMPUTING AGAINST NUMERICAL DERIVATIVES
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ETA,RELTOL,SCALE,STP
      INTEGER
     +   IXM,J,M,N,NEXMPT,NFAIL,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CD(N),FD(N),FDLAST(N),FDSAVE(N),PAR(NPAR),PV(N),PVMCD(N),
     +   PVNEW(N),PVPCD(N),PVSTP(N),PVTEMP(N),XM(IXM,M)
      INTEGER
     +   IFAIL(N),ITEMP(N)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  SCALARS IN COMMON
      DOUBLE PRECISION
     +   Q
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ABSTOL,CURVE,ETA3,FPLRS,PARMX,PVMEAN,PVTYP,STPCD,STPLOW,
     +   STPMID,STPUP,TAUABS,TEMP,THIRD
      INTEGER
     +   I
!
!  EXTERNAL FUNCTIONS
      DOUBLE PRECISION
     +   D1MACH
      EXTERNAL D1MACH
!
!  EXTERNAL SUBROUTINES
      EXTERNAL CMPFD,GMEAN,RELCOM,STPADJ,STPSEL
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,SIGN,SQRT
!
!  COMMON BLOCKS
      COMMON /NOTOPT/Q
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ABSTOL
!        THE ABSOLUTE AGREEMENT TOLERANCE.
!     DOUBLE PRECISION CD(N)
!        THE CENTRAL DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
!     DOUBLE PRECISION CURVE
!        A MEASURE OF THE CURVATURE OF THE MODEL.
!     DOUBLE PRECISION ETA
!        THE RELATIVE NOISE IN THE MODEL
!     DOUBLE PRECISION ETA3
!        THE CUBE ROOT OF ETA.
!     DOUBLE PRECISION FD(N)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!     DOUBLE PRECISION FDLAST(N)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!        COMPUTED WITH THE MOST RECENT STEP SIZE SELECTED.
!     DOUBLE PRECISION FDSAVE(N)
!        A VECTOR USED TO SAVE THE BEST OF THE
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATIONS TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!     DOUBLE PRECISION FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IFAIL(N)
!        THE VECTOR OF INDICATOR VARIABLES DESIGNATING WHETHER
!        THE STEP SIZE SELECTED WAS SATISFACTORY FOR A GIVEN
!        OBSERVATION AND PARAMETER.
!     INTEGER ITEMP(N)
!        A TEMPORARY STORAGE VECTOR.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NEXMPT
!        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
!        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
!        SIZE STILL BE CONSIDERED OK.
!     INTEGER NFAIL
!        THE VECTOR CONTAINING THE COUNTS FOR EACH PARAMETER
!        OF THE NUMBER OF OBSERVATIONS THE SELECTED STEP SIZE WAS
!        NOT SATISFACTORY.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION PARMX
!        THE MAXIMUM OF THE CURRENT PARAMETER ESTIMATE AND THE
!        TYPICAL VALUE OF THAT PARAMETER
!     DOUBLE PRECISION PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION PVMCD(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)-STPCD.
!     DOUBLE PRECISION PVMEAN
!        THE MEAN OF A FUNCTION OF THE PREDICTED VALUES.
!     DOUBLE PRECISION PVNEW(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPNEW.
!     DOUBLE PRECISION PVPCD(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCD.
!     DOUBLE PRECISION PVSTP(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STP.
!     DOUBLE PRECISION PVTEMP(N)
!        A TEMPORARY STORAGE VECTOR FOR PREDICTED VALUES.
!     DOUBLE PRECISION PVTYP
!        THE TYPICAL SIZE OF THE PREDICTED VALUES OF THE MODEL.
!     DOUBLE PRECISION Q
!        A DUMMY VARIABLE WHICH IS USED, ALONG WITH COMMON NOTOPT (NO
!        OPTIMIZATION), TO COMPUTE THE STEP SIZE.
!     DOUBLE PRECISION SCALE
!        THE TYPICAL SIZE OF THE JTH PARAMETER.
!     DOUBLE PRECISION STP
!        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FORWARD
!        DIFFERENCE APPROXIMATION TO THE DERIVATIVE.
!     DOUBLE PRECISION STPCD
!        THE STEP SIZE USED FOR THE CENTRAL DIFFERENCE QUOTIENT.
!     DOUBLE PRECISION STPLOW
!        THE LOWER LIMIT ON THE STEP SIZE.
!     DOUBLE PRECISION STPMID
!        THE MIDPOINT OF THE ACCEPTABLE RANGE OF THE STEP SIZE.
!     DOUBLE PRECISION STPUP
!        THE UPPER LIMIT ON THE STEP SIZE.
!     DOUBLE PRECISION RELTOL
!        THE RELATIVE AGREEMENT TOLERANCE.
!     DOUBLE PRECISION TAUABS
!        THE ABSOLUTE AGREEMENT TOLERANCE.
!     DOUBLE PRECISION TEMP
!        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
!        PARAMETER IS STORED.
!     DOUBLE PRECISION THIRD
!        THE VALUE ONE THIRD.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      FPLRS = D1MACH(4)
!
!     SET VARIOUS PARAMETERS NECESSARY FOR COMPUTING THE
!     OPTIMUM STEP SIZE
!
      THIRD = 1.0D0 / 3.0D0
!
      ETA3 = ETA ** THIRD
!
      PARMX = MAX(ABS(PAR(J)), ABS(SCALE))
      IF (PARMX .EQ. 0.0D0) PARMX = 1.0D0
!
      STPCD = ((3.0D0 ** THIRD) * ETA3 * PARMX * SIGN(1.0D0, PAR(J)))
!
      Q = STPCD + PAR(J)
      STPCD = Q - PAR(J)
!
      TEMP = PAR(J)
!
      PAR(J) = TEMP + STPCD
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVPCD)
!
      PAR(J) = TEMP - STPCD
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVMCD)
!
      PAR(J) = TEMP
!
!     ESTIMATE CURVATURE BY SECOND DERIVATIVE OF MODEL WITH RESPECT TO
!     PAR(J)
!
      DO 10 I = 1, N
         PVTEMP(I) = ABS((PVPCD(I)+PVMCD(I)) - 2*PV(I))
         IF (PVTEMP(I).EQ.0.0D0) THEN
            IF (PV(I).EQ.0.0D0) THEN
               PVTEMP(I) = FPLRS
            ELSE
               PVTEMP(I) = FPLRS*ABS(PV(I))
            END IF
         END IF
   10 CONTINUE
!
!     COMPUTE THE GEOMETRIC MEAN
!
      CALL GMEAN(PVTEMP, N, PVMEAN)
!
      CURVE = ABS(PVMEAN / STPCD / STPCD)
!
!     COMPUTE A TYPICAL VALUE OF THE MODEL
!
      DO 20 I = 1, N
         PVTEMP(I) = ABS(PVPCD(I) + PV(I) + PVMCD(I))
         IF (PVTEMP(I).EQ.0.0D0) THEN
            IF (PV(I).EQ.0.0D0) THEN
               PVTEMP(I) = FPLRS
            ELSE
               PVTEMP(I) = FPLRS*ABS(PV(I))
            END IF
         END IF
   20 CONTINUE
!
      CALL GMEAN(PVTEMP, N, PVMEAN)
!
      PVTYP = ABS(PVMEAN / 3.0D0)
!
!     SET VALUES REPRESENTATIVE OF THE RANGE THE STEP SIZE
!     CAN BE EXPECTED TO TAKE
!
      STPUP = (ETA3) * PARMX
      STPLOW = (ETA3) * STPUP
      STPMID = SQRT(STPLOW) * SQRT(STPUP)
!
!     SELECT AN OPTIMUM STARTING STEP SIZE
!
      IF (CURVE.EQ.0.0D0) THEN
         STP = PARMX * SIGN(1.0D0, PAR(J))
      ELSE
         STP = (2.0D0 * SQRT(ETA) * SQRT(PVTYP) / SQRT(CURVE)) *
     +         SIGN(1.0D0,PAR(J))
      END IF
!
      IF (ABS(STP).GT.PARMX) STP = PARMX * SIGN(1.0D0,PAR(J))
!
      Q = STP + PAR(J)
      STP = Q - PAR(J)
!
      IF (STP.EQ.0.0D0) THEN
         STP = FPLRS * PAR(J)
         IF (STP.EQ.0.0D0) STP = FPLRS
!
   30    CONTINUE
         Q = STP + PAR(J)
         STP = Q - PAR(J)
!
         IF (STP.EQ.0.0D0) THEN
            STP = 2.0D0 * STP
            GO TO 30
         END IF
      END IF
!
!     COMPUTE THE ABSOLUTE TOLERANCES
!
      ABSTOL = 10.0D0 * ETA * PVTYP
!
      TAUABS = 2.0D0 * SQRT(ETA) * SQRT(PVTYP)
      IF (CURVE .NE. 0.0D0) TAUABS = TAUABS * SQRT(CURVE)
!
      TEMP = PAR(J)
      PAR(J) = TEMP + STP
!
      CALL MDL(PAR, NPAR, XM, N, M, IXM, PVSTP)
!
      PAR(J) = TEMP
!
!     COMPUTE THE FORWARD AND CENTRAL DIFFERENCE QUOTIENT ESTIMATE
!     OF THE DERIVATIVE
!
      CALL CMPFD(N, STP, PVSTP, PV, FD)
!
      CALL CMPFD(N, 2.0D0*STPCD, PVPCD, PVMCD, CD)
!
!     COMPUTE THE NUMBER OF OBSERVATIONS FOR WHICH THE FD DOES NOT
!     AGREE WITH THE CD WITHIN THE TOLERANCE SPECIFIED.
!
      CALL RELCOM(N, FD, CD, RELTOL, ABSTOL, NFAIL, IFAIL)
!
!     IF THE FORWARD DIFFERENCE APPROXIMATION DOES NOT AGREE WITHIN
!     TOLERANCE FOR MORE THAN   NEXMPT   OBSERVATION, SELECT NEW
!     VALUE OF THE STEP SIZE, ELSE ADJUST THE STEP SIZE AND RETURN.
!
      IF (NFAIL.GT.NEXMPT) THEN
!
!        SELECT NEW VALUE OF THE STEP SIZE
!
            CALL STPSEL(XM, N, M, IXM, MDL, PAR, NPAR,
     +         NEXMPT, STP, NFAIL, IFAIL, J, ETA3, RELTOL, ABSTOL,
     +         TAUABS, STPLOW,
     +         STPMID, STPUP, ITEMP, FD, FDLAST, FDSAVE, PV, PVNEW)
      ELSE
!
!        ADJUST THE CURRENT STEP SIZE VALUE
!
            CALL STPADJ(XM, N, M, IXM, MDL, PAR, NPAR,
     +         NEXMPT, STP, NFAIL, IFAIL, J, RELTOL, ABSTOL, STPLOW,
     +         STPMID, STPUP, ITEMP, FD, FDLAST, PV, PVNEW)
!
      END IF
!
!     CONVERT SELECTED ABSOLUTE STEP SIZE TO RELATIVE STEP SIZE
!
      STP = ABS(STP) / PARMX
!
      RETURN
!
      END
!SAMPLE
      SUBROUTINE SAMPLE (Y, N, NS, YS, NYS)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE SAMPLES EVERY KTH OBSERVATION FROM THE INPUT
!     SERIES Y, STORING THE SAMPLED SERIES IN YS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   N,NS,NYS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   Y(*),YS(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT
      LOGICAL
     +   ERR01,ERR02,HEAD
!
!  LOCAL ARRAYS
      CHARACTER
     +   LN(8)*1,LNS(8)*1,LONE(8)*1,NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EISGE,EISII,IPRINT,SMPLY
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     CHARACTER*1 LN(8), LNS(8), LONE(8)
!        THE ARRAY CONTAINING THE NAME OF THE VARIABLE N AND NS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NS
!        THE SAMPLING RATE.
!     INTEGER NYS
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YS.
!     DOUBLE PRECISION Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     DOUBLE PRECISION YS(N)
!        THE VECTOR IN WHICH THE SAMPLED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     + /     'S',       'A',       'M',       'P',       'L',       'E'/
      DATA
     +  LN(1), LN(2), LN(3), LN(4), LN(5), LN(6), LN(7), LN(8)
     + /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LNS(1), LNS(2), LNS(3), LNS(4), LNS(5), LNS(6), LNS(7), LNS(8)
     + /  'N',   'S',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
      DATA
     +  LONE(1), LONE(2), LONE(3), LONE(4), LONE(5), LONE(6), LONE(7),
     +  LONE(8)
     + /  'O',   'N',   'E',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      HEAD = .TRUE.
!
!     CALL ERROR CHECKING ROUTINES
!
      CALL EISGE(NMSUB, LN, N, 3, 1, HEAD, ERR01, LN)
!
      CALL EISII(NMSUB, LNS, NS, 1, N, 1, HEAD, ERR02, LONE, LN)
!
      IF (ERR01 .OR. ERR02) GO TO 10
      GO TO 20
!
   10 CONTINUE
      IERR = 1
      CALL IPRINT (IPRT)
      WRITE (IPRT, 1000)
      RETURN
!
   20 CONTINUE
!
      CALL SMPLY (Y, N, NS, YS, NYS)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   38H       CALL SAMPLE (Y, N, NS, YS, NYS))
      END
!ERVGTP
      SUBROUTINE ERVGTP (NMSUB, NMVAR, VECLB, NVMN, NVMX, HEAD, MSGTYP,
     +  NV, NMMIN)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRINTS THE ERROR MESSAGES FOR ERVGT AND ERVGTM.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VECLB
      INTEGER
     +   MSGTYP,NV,NVMN,NVMX
      LOGICAL
     +   HEAD
!
!  ARRAY ARGUMENTS
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED (TRUE)
!        OR NOT (FALSE).
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
!        IF (MSGTYP.GE.4) THE MESSAGE PRINTED WILL USE NMMIN
!        OTHERWISE IT WILL USE VECLB.
!        IF (MSGTYP = 1 OR 4) NO VIOLATIONS ARE ALLOWED.
!        IF (MSGTYP = 2 OR 5) THE NUMBER OF VIOLATIONS MUST
!                             BE LESS THAN   NVMX   .
!        IF (MSGTYP = 3 OR 6) VIOLATIONS ARE COUNTED ONLY IF THE
!                             THE FIRST ELEMENT IS NOT IN VIOLATION.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE ARGUMENTS NAME.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND.
!     INTEGER NVMX
!        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
!     DOUBLE PRECISION VECLB
!        THE VALUE THAT THE VECTOR IS BEING TESTED AGAINST.
!
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
!
      IF (MSGTYP.LE.3) THEN
        WRITE (IPRT, 1000) (NMVAR(I),I=1,6), VECLB, NV
      ELSE
        IF (MSGTYP.GE.7) THEN
          WRITE (IPRT, 1001) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8), NV
        ELSE
          WRITE (IPRT, 1002) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8), NV
        END IF
      END IF
!
      GO TO (10, 20, 30, 40, 50, 60, 70), MSGTYP
!
   10 WRITE(IPRT, 1010) (NMVAR(I),I=1,6), VECLB
      RETURN
!
   20 WRITE(IPRT, 1020) (NMVAR(I),I=1,3), VECLB, NVMX
      RETURN
!
   30 WRITE(IPRT, 1030) (NMVAR(I),I=1,6), VECLB, VECLB
      RETURN
!
   40 WRITE(IPRT, 1040) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8)
      RETURN
!
   50 WRITE(IPRT, 1050) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8), NVMX
      RETURN
!
   60 WRITE(IPRT, 1060) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8),
     +   (NMMIN(I),I=1,8)
      RETURN
!
   70 WRITE(IPRT, 1070) NVMN, (NMVAR(I),I=1,6), (NMMIN(I),I=1,8)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/
     +   32H THE NUMBER OF VALUES IN VECTOR , 6A1,
     +   23H LESS THAN OR EQUAL TO , 1PE14.7, 4H IS , I6, '.')
 1001 FORMAT (/
     +   32H THE NUMBER OF VALUES IN VECTOR , 6A1,
     +  ' GREATER THAN ', 8A1, ' IS ', I2, '.')
 1002 FORMAT (/
     +   32H THE NUMBER OF VALUES IN VECTOR , 6A1,
     +   23H LESS THAN OR EQUAL TO , 8A1, 4H IS , I6, '.')
 1010 FORMAT(
     +   26H THE VALUES IN THE VECTOR , 6A1,
     +   26H MUST ALL BE GREATER THAN , 1PE14.7, '.')
 1020 FORMAT(
     +   36H THE NUMBER OF VALUES IN THE VECTOR , 6A1,
     +   23H LESS THAN OR EQUAL TO , 1PE14.7/
     +   19H MUST BE LESS THAN , I5, '.')
 1030 FORMAT(
     +   37H SINCE THE FIRST VALUE OF THE VECTOR , 6A1,
     +   17H IS GREATER THAN , 1PE14.7/
     +   40H ALL OF THE VALUES MUST BE GREATER THAN , 1PE14.7, '.')
 1040 FORMAT(
     +   26H THE VALUES IN THE VECTOR , 6A1,
     +   26H MUST ALL BE GREATER THAN , 8A1, '.')
 1050 FORMAT(
     +   36H THE NUMBER OF VALUES IN THE VECTOR , 6A1,
     +   23H LESS THAN OR EQUAL TO , 8A1/
     +   19H MUST BE LESS THAN , I5, '.')
 1060 FORMAT(
     +   37H SINCE THE FIRST VALUE OF THE VECTOR , 6A1,
     +   17H IS GREATER THAN , 8A1/
     +   40H ALL OF THE VALUES MUST BE GREATER THAN , 8A1, '.')
 1070 FORMAT(/' THERE MUST BE AT LEAST ', I2, ' VALUES IN VECTOR ', 6A1/
     +  ' GREATER THAN OR EQUAL TO ', 8A1, '.')
!
      END
!STPLS
      SUBROUTINE STPLS(XM, N, M, IXM, MDL, PAR, NPAR, LDSTAK, STP)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR SELECTING STEP SIZES
!     TO BE USED IN COMPUTING FORWARD DIFFERENCE QUOTIENT ESTIMATES
!     OF THE NUMERICAL DERIVATIVES FOR THE NONLINEAR LEAST SQUARES
!     ROUTINES (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,LDSTAK,M,N,NPAR
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),STP(*),XM(*)
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   EXMPT
      INTEGER
     +   IPRT,LSCALE,NETA,NPRT
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   SCALE(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,STPDRV
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXCEPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     DOUBLE PRECISION PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION SCALE(1)
!        A DUMMY VECTOR USED TO DESIGNATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION STP(NPAR)
!        THE SELECTED STEP SIZES.
!     DOUBLE PRECISION XM(IXM,M)
!        THE INDEPENDENT VARIABLE ARRAY
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'S','T','P','L','S',' '/
!
!     SET UP DEFAULT VALUES
!
      EXMPT = 0.1D0
      NETA = 0
      SCALE(1) = 0.0D0
      LSCALE = 1
      NPRT = 1
!
!     PASS CONTROL TO STEP SIZE SELECTION DRIVER
!
      CALL STPDRV(NMSUB, XM, N, M, IXM, MDL, PAR, NPAR, LDSTAK, STP,
     +   NETA, EXMPT, SCALE, LSCALE, NPRT)
!
      IF (IERR.NE.1) RETURN
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL STPLS (XM, N, M, IXM, NLSMDL, PAR, NPAR, LDSTAK,',
     +   ' STP)')
      END
!IPGOUT
      SUBROUTINE IPGOUT (XAXIS, YAXIS, ISYM, NPTS, LPCV, ISPCER)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES THE INTEGRATED PERIODOGRAM PLOTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ISPCER,LPCV,NPTS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISYM(LPCV)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,PPMN,VERSP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IPRT
!        THE LOGICAL UNIT NUMBER FOR THE OUTPUT.
!     INTEGER ISPCER
!        AN ERROR INDICATOR FOR THE INTEGRATED PERIODOGRAM COMPUTATIONS.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     DOUBLE PRECISION XAXIS(LPCV), YAXIS(LPCV)
!        THE X, Y CO-ORDINATES FOR THE SPECTRAL PLOTS.
!
!
!     SET LOGICAL UNIT NUMBER FOR OUTPUT AND SET OUTPUT WIDTH.
!
      CALL IPRINT (IPRT)
!
      CALL VERSP(.TRUE.)
      WRITE (IPRT, 1000)
!
      IF (ISPCER .EQ. 0) GO TO 5
!
      WRITE (IPRT, 1003)
      RETURN
!
    5 CONTINUE
!
      CALL PPMN (YAXIS, YAXIS, XAXIS, XAXIS, NPTS, 1, LPCV, 1, ISYM,
     +  LPCV, 0, -1, 0.0D0, 1.0D0, 0.0D0, 0.5D0, .FALSE., 0)
      WRITE(IPRT, 1002)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT(34H INTEGRATED SAMPLE PERIODOGRAM (+)/
     +   5X, 49H WITH 95 PER CENT TEST LIMITS FOR WHITE NOISE (.))
!1001 FORMAT(5H+FREQ/
!    1   7H PERIOD, 9X, 3HINF, 7X, 3H10., 4X, 2H5., 8X, 6H3.3333, 4X,
!    2   3H2.5, 4X, 2H2.)
 1002 FORMAT(5H+FREQ/
     +   7H PERIOD, 9X, 3HINF, 7X, 3H20., 7X, 3H10., 8X, 6H6.6667, 4X,
     +   2H5., 8X, 2H4., 8X, 6H3.3333, 4X, 6H2.8571, 4X, 3H2.5, 7X,
     +   6H2.2222, 4X, 2H2.)
 1003 FORMAT (///42H THE INTEGRATED PERIODOGRAM OF THIS SERIES,
     +   22H COULD NOT BE COMPUTED/
     +   44H BECAUSE THE VARIANCE OF THE SERIES IS ZERO.)
      END
!ERSEI
      SUBROUTINE ERSEI(NMSUB, NMVAR, VAL, VALMN, VALMX, MSGTYP, HEAD,
     +   ERROR, NMMIN, NMMAX)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THE ROUTINE CHECKS WHETHER THE VALUE   VAL   IS WITHIN THE
!     THE RANGE VALMN (EXCLUSIVE) TO VALMX (INCLUSIVE), AND PRINTS A
!     DIAGNOSTIC IF IT IS NOT.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VAL,VALMN,VALMX
      INTEGER
     +   MSGTYP
      LOGICAL
     +   ERROR,HEAD
!
!  ARRAY ARGUMENTS
      CHARACTER
     +   NMMAX(8)*1,NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
!        PRINTED, WHERE IF ERROR IS .TRUE. AND
!        MSGTYP = 1 THE INPUT VALUE WAS OUTSIDE THE RANGE DETERMINED
!                   FROM OTHER INPUT ARGUMENTS
!        MSGTYP = 2 THE INPUT VALUE WAS OUTSIDE THE RANGE IMPOSED BY
!                   STARPAC
!     CHARACTER*1 NMMAX(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MAXIMUM.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE ARGUMENTS NAME.
!     DOUBLE PRECISION VAL
!        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
!     DOUBLE PRECISION VALMN, VALMX
!        THE MINIMUM AND MAXIMUM OF THE RANGE WITHIN WHICH THE
!        ARGUMENT MUST LIE.
!
      ERROR = .FALSE.
!
      IF (((VALMN.LT.VAL) .AND. (VAL.LE.VALMX)) .OR.
     +   (VALMX.LT.VALMN)) RETURN
!
      ERROR = .TRUE.
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
!
      WRITE (IPRT, 1000) (NMVAR(I),I=1,6), VAL
!
!     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE DETERMINED FROM
!     OTHER INPUT ARGUMENTS.
!
      IF (MSGTYP .EQ. 1)
     +   WRITE (IPRT, 1010) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8),
     +      (NMMAX(I),I=1,8)
!
!     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE IMPOSED BY STARPAC
!
      IF (MSGTYP .EQ. 2)
     +   WRITE (IPRT, 1020) (NMVAR(I),I=1,6), VALMN, VALMX
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/20H THE INPUT VALUE OF , 6A1, 4H IS , G15.8, '.')
 1010 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   17H MUST LIE BETWEEN, 1X, 8A1, 12H (EXCLUSIVE)/
     +   5H AND , 8A1, 13H (INCLUSIVE).)
 1020 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   17H MUST LIE BETWEEN, 1X, G15.8, 12H (EXCLUSIVE)/
     +   5H AND , G15.8, 13H (INCLUSIVE).)
!
      END
!XDCKLD
      SUBROUTINE XDCKLD(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   DELTA
      INTEGER
     +   I,IPRT,IXM,LDSMIN,M,N,NETA,NPAR,NPRT,NROW,NTAU,NTEST
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   PAR(10),SCALE(10),XM(200,2)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DCKLS,DCKLS1,DCKLSC,DRV4A,IPRINT,LDSCMP,MDL4
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        *
!     EXTERNAL DRV4A
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL4
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     DOUBLE PRECISION PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     DOUBLE PRECISION SCALE(10)
!        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION XM(200,2)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      CALL IPRINT(IPRT)
!
!     SET PARAMETER VALUES
!
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
      CALL LDSCMP(5, 0, 2*NPAR+1, 0, 0, 0, 'D',
     +            N*NPAR+NPAR+N, LDSMIN)
!
      IF (LDSMIN.GT.LDSTAK) THEN
         WRITE (IPRT, 1020) LDSMIN
         RETURN
      END IF
!
!     CREATE INDEPENDENT VARIABLE
!
      DELTA = 0.0625D0
      XM(1,1) = 0.0D0
      DO 10 I=2,N
         XM(I,1) = XM(I-1,1) + DELTA
   10 CONTINUE
!
      NTEST = 0
!
!
!
!     CHECK RESULTS FROM VALID CALLS
!
!     SIMPLE EXAMPLE
!
!     CHECK RESULT FOR CORRECTLY COMPUTED DERIVATIVE
!
      CALL DCKLS1(N, M, IXM, PAR, NPAR, NETA, NTAU, NROW, SCALE, NPRT)
!
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1100)
      WRITE (IPRT,1040)
      WRITE (IPRT,1000)
      IERR = -1
      CALL DCKLS(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSMIN)
      WRITE (IPRT,1050) IERR
!
      NTEST = NTEST + 1
      WRITE (IPRT,1130) NTEST
      WRITE (IPRT,1100)
      WRITE (IPRT,1040)
      WRITE (IPRT,1060) NETA, NTAU, SCALE(1), NROW, NPRT
      WRITE (IPRT,1010)
      IERR = -1
      CALL DCKLSC(XM, N, M, IXM, MDL4, DRV4A, PAR, NPAR, LDSMIN, NETA,
     +   NTAU, SCALE, NROW, NPRT)
      WRITE (IPRT,1050) IERR
      WRITE (IPRT,1140) NETA, NTAU, SCALE(1), NROW, NPRT
!
!
      RETURN
!
!     FORMAT STATEMENTS
!
!
 1000 FORMAT (15H TEST OF DCKLS )
 1010 FORMAT (15H TEST OF DCKLSC)
 1020 FORMAT (45H1 *** LDSTAK MUST BE GREATER THAN OR EQUAL TO , I6)
 1040 FORMAT (15H SIMPLE EXAMPLE)
 1050 FORMAT (29H ***** RETURNED RESULTS *****, 5X, 15H (-1 INDICATES ,
     +   39HVALUE NOT CHANGED BY CALLED SUBROUTINE)//9H IERR IS , I3)
 1060 FORMAT (19H INPUT   -  NETA = , I5, 9H, NTAU = , I5,
     +   13H, SCALE(1) = , G15.8, 9H, NROW = , I5, 9H, NPRT = , I5)
 1100 FORMAT (27H CORRECTLY CODED DERIVATIVE)
 1130 FORMAT (43H1DERIVATIVE CHECKING SUBROUTINE TEST NUMBER, I5/)
 1140 FORMAT (19H OUTPUT  -  NETA = , I5, 9H, NTAU = , I5,
     +   13H, SCALE(1) = , G15.8, 9H, NROW = , I5, 9H, NPRT = , I5//)
      END
!SETROW
      SUBROUTINE SETROW (NROW, XM, N, M, IXM, NROWU)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SELECTS THE ROW USED BY THE DERIVATIVE CHECKING
!     PROCEDURE.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   IXM,M,N,NROW,NROWU
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   XM(IXM,M)
!
!  LOCAL SCALARS
      INTEGER
     +   I,J
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NROW, NROWU
!        THE USER-SUPPLIED NUMBER OF THE ROW OF THE INDEPENDENT
!        VARIABLE ARRAY AT WHICH THE DERIVATIVE IS TO BE CHECKED,
!        AND THE NUMBER OF THE ROW ACTUALLY USED.
!     DOUBLE PRECISION XM(IXM,M)
!        THE INDEPENDENT VARIABLE MATRIX.
!
      NROWU = NROW
!
      IF ((NROWU.GE.1) .AND. (NROWU.LE.N)) RETURN
!
!     SELECT FIRST ROW OF INDEPENDENT VARIABLES WHICH CONTAINS NO ZEROS
!     IF THERE IS ONE, OTHERWISE FIRST ROW IS USED.
!
      DO 20 I = 1, N
         DO 10 J = 1, M
            IF (XM(I,J) .EQ. 0.0D0) GO TO 20
   10    CONTINUE
         NROWU = I
         RETURN
   20 CONTINUE
!
      NROWU = 1
!
      RETURN
      END
!BFSMV
      SUBROUTINE BFSMV(CCOV, NLPPC, INDEX1, INDEX2, N, LAGMAX, ICCOV,
     +  JCCOV, INLPPC, JNLPPC)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
!     FOURIER SPECTRUM ANALYSIS OF SERIES WITH MISSING OBSERVATIONS
!     AND COVARIANCES INPUT RATHER THAN ORIGINAL SERIES
!     (SHORT CALL)
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,INDEX1,INDEX2,INLPPC,JCCOV,JNLPPC,LAGMAX,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(*)
      INTEGER
     +   NLPPC(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,FMAX,FMIN,YMISS1,YMISS2
      INTEGER
     +   ICSPC2,IPHAS,IPRT,LAGMX1,LAGMXU,LDSMIN,LDSTAK,LPCV,LW,LY,
     +   M,NF,NPRT,NW
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   CEVEN(101),CODD(101),CSPC2(101,4),FREQ(101),PHAS(101,4),
     +   SPCF1(101),SPCF2(101),W(101),XAXIS(404),Y1(1),Y2(1),
     +   YAXIS(404)
      INTEGER
     +   ISYM(404),LAGS(4)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL BFSDRV,ECVF,IPRINT,PARZEN,SETLAG
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MIN
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION CCOV(ICCOV,JCCOV,*)
!        THE COVARIANCES.
!     DOUBLE PRECISION CEVEN(101)
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CODD(101)
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     DOUBLE PRECISION CSPC2(101,4)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISYM(404)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC.
!     INTEGER LAGMAX, LAGMXU
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC(INLPPC,JNLPPC,*)
!        THE NUMBER OF OBSERVATIONS IN EACH COVARIANCE ESTIMATE
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION PHAS(101,4)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     DOUBLE PRECISION SPCF1(101), SPCF2(101)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     DOUBLE PRECISION W(101)
!        THE WINDOWS.
!     DOUBLE PRECISION XAXIS(404)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YAXIS(404)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     DOUBLE PRECISION YMISS1, YMISS2
!        THE MISSING VALUE CODES
!     DOUBLE PRECISION Y1(1)
!        THE FIRST TIME SERIES.
!     DOUBLE PRECISION Y2(1)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'B','F','S','M','V',' '/
!
!     SET UP FOR ERROR CHECKING
!
      OPTION(1) = .FALSE.
      OPTION(2) = .TRUE.
      OPTION(3) = .TRUE.
      OPTION(4) = .FALSE.
!
      M = 2
!
      ICSPC2 = 101
      IPHAS = 101
!
      LDSTAK = 0
      LDSMIN = 0
!
      NF = 101
      LW = 101
      LY = N
      LPCV = 404
!
!     SET MAXIMUM LAG VALUE USED (LAGMXU)
!     SET NUMBER OF LAG WINDOW TRUCCATION POINTS (NW)
!
      CALL SETLAG(N, LAGMXU)
      LAGMXU = MIN(LAGMXU,LAGMAX)
      NW = 4
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
      CALL BFSDRV(Y1, Y2, YMISS1, YMISS2, CCOV, NLPPC, SPCF1, SPCF2,
     +   NF, FMIN, FMAX, FREQ, N, NW, LAGMXU, LAGS, LAGMX1, W, LW,
     +   DELTA, ISYM, XAXIS, YAXIS, LPCV, ALPHA, NPRT, PARZEN, ICCOV,
     +   JCCOV, M, INDEX1, INDEX2, CSPC2, PHAS, ICSPC2, IPHAS, CODD,
     +   CEVEN, W, LW, NMSUB, LDSMIN, LDSTAK, OPTION, N, INLPPC,
     +   JNLPPC, LY)
!
      IF (IERR.NE.0) THEN
        IF (IERR.EQ.2) CALL ECVF(NMSUB)
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
!
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL BFSMV (CCOV, NLPPC, INDEX1, INDEX2, N, LAGMAX,'/
     +   '      +            ICCOV, JCCOV, INLPPC, JNLPPC)')
      END
!NLSX2
      SUBROUTINE NLSX2(N, M, IXM, NPAR, IFIXED, STP, IDRVCK, MIT,
     +   STOPSS, STOPP, SCALE, DELTA, IVAPRX, NPRT, IVCV)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     SET UP PROBLEM SPECIFICATION FOR TESTING THE USER CALLABLE
!     ROUTINES IN THE NONLINEAR  LEAST SQUARES FAMILY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IVAPRX,IVCV,IXM,M,MIT,N,NPAR,NPRT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   SCALE(10),STP(10)
      INTEGER
     +   IFIXED(10)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   SQMEPS
      INTEGER
     +   I
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!
!  INTRINSIC FUNCTIONS
      INTRINSIC SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
!        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
!     INTEGER IFIXED(10)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     DOUBLE PRECISION SCALE(10)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     DOUBLE PRECISION SQMEPS
!        THE SQUARE ROOT OF MACHINE PRECISION
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL STANDARD DEVIATION (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(10)
!        THE STEP SIZE ARRAY.
!
!
!     **SET UP FOR NORMAL STATEMENT**
!
      SQMEPS = SQRT(RMDCON(3,typ=0.0_wp))
!
      N = 6
      M = 1
      IXM = 10
      NPAR = 2
      MIT = 500
      DO 10 I=1,10
         STP(I) = SQMEPS
         SCALE(I) = 1.0D0
   10 CONTINUE
      IFIXED(1) = -1
      IDRVCK = 0
      STOPSS = 10.0D-5
      STOPP = 10.0D-5
      DELTA = 0.5D0
      NPRT = 11111
      IVAPRX = 3
      IVCV = 6
!
      RETURN
!
      END
!NLCNTA
      SUBROUTINE NLCNTA(Y, WT, LWT, XM, N, M, IXM, MDL, DRV, PAR, NPAR,
     +   RES, LDSTAK, IFIXED, LIFIXD, IDRVCK, MIT, STOPSS, STOPP,
     +   SCALE, LSCALE, DELTA, IVCVOP, NPRT, RSD, PV, LPV, SDPV, LSDPV,
     +   SDRES, LSDRES, VCV, IVCV, NMSUB, WEIGHT, SAVE, NNZW, NPARE)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING ANALYTIC (USER-SUPPLIED) DERIVATIVES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   DELTA,RSD,STOPP,STOPSS
      INTEGER
     +   IDRVCK,IVCV,IVCVOP,IXM,LDSTAK,LIFIXD,LPV,LSCALE,LSDPV,
     +   LSDRES,LWT,M,MIT,N,NNZW,NPAR,NPARE,NPRT
      LOGICAL
     +   SAVE,WEIGHT
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   PAR(*),PV(*),RES(*),SCALE(*),SDPV(*),SDRES(*),VCV(*),WT(*),
     +   XM(*),Y(*)
      INTEGER
     +   IFIXED(*)
      CHARACTER
     +   NMSUB(6)*1
!
!  SUBROUTINE ARGUMENTS
      EXTERNAL DRV,MDL
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   ISUBHD,LDSMIN,LSTP,NDIGIT,NETA,NROW,NTAU
      LOGICAL
     +   APRXDV,HLFRPT,PAGE,PRTFXD,WIDE
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   STP(1)
      INTEGER
     +   IPTOUT(5)
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   ICNTI
      EXTERNAL ICNTI
!
!  EXTERNAL SUBROUTINES
      EXTERNAL DCKCNT,LDSCMP,NLCNT,NLDRVA,NLER,NLHDRA,PRTCNT,STKSET
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
!        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPTOUT(5)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IVCVOP
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVCVOP LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVCVOP EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVCVOP EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVCVOP EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVCVOP EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVCVOP EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVCVOP EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVCVOP GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL RESULTS.
!     EXTERNAL NLDRVA
!        THE NAME OF THE ROUTINE WHICH CALCULATES THE DERIVATIVES.
!     EXTERNAL NLHDRA
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICALLY APPROXIMATED DERIVATIVES AND THE USER SUPPLIED
!        DRVITIVES.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION PV(LPV)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     DOUBLE PRECISION RES(N)
!        THE RESIDUALS FROM THE FIT.
!     DOUBLE PRECISION RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION SCALE(LSCALE)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     DOUBLE PRECISION SDPV(LSDPV)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     DOUBLE PRECISION SDRES(LSDRES)
!        THE STANDARDIZED RESIDUALS.
!     DOUBLE PRECISION STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     DOUBLE PRECISION STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     DOUBLE PRECISION STP(1)
!        THE DUMMY STEP SIZE ARRAY.
!     DOUBLE PRECISION VCV(IVCV,NPAR)
!        THE VARIANCE-COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     DOUBLE PRECISION WT(LWT)
!        THE WEIGHTS.
!     DOUBLE PRECISION XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     DOUBLE PRECISION Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET VARIOUS PROGRAM VALUES
!
      HLFRPT = .FALSE.
      APRXDV = .FALSE.
      PRTFXD = .TRUE.
      STP(1) = 0.0D0
      LSTP = 1
      NETA = 0
      NTAU = 0
      NROW = 0
!
      WIDE = .TRUE.
      PAGE = .FALSE.
!
      NDIGIT = 5
!
!     SET UP FOR ERROR CHECKING
!
      IERR = 0
      IF ((IFIXED(1).GE.0) .AND. (NPAR.GE.1)) THEN
         NPARE = ICNTI(IFIXED,NPAR,0)
      ELSE
         NPARE = NPAR
      END IF
!
      CALL LDSCMP(6, 0, 60+2*NPAR, 0, 0, 0, 'D',
     +            94+N*(3+NPAR)+NPARE*(3*NPARE+35)/2, LDSMIN)
!
      CALL NLER (NMSUB, WEIGHT, WT, LWT, N, M, IXM,
     +   IFIXED, LIFIXD, NPAR, NPARE,
     +   LDSTAK, LDSMIN, STP, LSTP, SCALE, LSCALE, IVCV, SAVE, NNZW)
!
      IF (IERR.NE.0) RETURN
!
      CALL STKSET(LDSTAK, 4)
!
!     SET PRINT CONTROL VALUES
!
      CALL PRTCNT(NPRT, NDIGIT, IPTOUT)
!
      IF (IDRVCK.EQ.0) GO TO 10
!
!     CHECK DERIVATIVES, IF DESIRED
!
      ISUBHD = 1
      CALL DCKCNT(XM, N, M, IXM, MDL, DRV, PAR, NPAR, NETA, NTAU,
     +   SCALE, LSCALE, NROW, IPTOUT(1), NLHDRA, PAGE, WIDE, ISUBHD,
     +   HLFRPT, PRTFXD, IFIXED, LIFIXD)
!
!     CHECK FOR DEFINITE ERROR IN DERIVATIVES
!
      IF (IERR.LE.2) GO TO 10
      IERR = 1
      RETURN
!
   10 CONTINUE
!
      IERR = 0
!
      CALL NLCNT(Y, WT, LWT, XM, N, M, IXM, MDL, NLDRVA, APRXDV, DRV,
     +   PAR, NPAR, RES, IFIXED, LIFIXD, STP, LSTP, MIT, STOPSS, STOPP,
     +   SCALE, LSCALE, DELTA, IVCVOP, RSD, PV, LPV, SDPV, LSDPV,
     +   SDRES, LSDRES, VCV, IVCV, WEIGHT, SAVE, NNZW, NPARE, NLHDRA,
     +   PAGE, WIDE, IPTOUT, NDIGIT, HLFRPT)
!
      RETURN
!
      END
!XXCH6
      SUBROUTINE XXCH6(LDSTAK,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE ONEWAY ANALYSIS OF VARIANCE FAMILY OF ROUTINES.
!
!     DATA SET IS FROM PAGES 314-316 OF BRWONLEE [1965].
!
!     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   LDSTAK
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      INTEGER
     +   IPRT,N
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   TAG(20),Y(20)
!
!  EXTERNAL SUBROUTINES
      EXTERNAL AOV1,IPRINT
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        ERROR FLAG
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER N
!        THE LENGTH OF THE VECTOR Y.
!     DOUBLE PRECISION TAG(20)
!        THE TAG VALUES FOR EACH OBSERVATION
!     DOUBLE PRECISION Y(20)
!        DATA VECTOR FOR TESTS.
!
!
!     DATA INITIALIZATIONS.
!
      DATA N /16/
!
      DATA Y( 1), Y( 2), Y( 3), Y( 4)
     +    / 83.0, 81.0, 76.0, 78.0/
      DATA Y( 5), Y( 6), Y( 7), Y( 8)
     +    / 79.0, 72.0, 61.0, 61.0/
      DATA Y( 9), Y(10), Y(11), Y(12)
     +    / 67.0, 67.0, 64.0, 78.0/
      DATA Y(13), Y(14), Y(15), Y(16)
     +    / 71.0, 75.0, 72.0, 74.0/
!
      DATA TAG( 1), TAG( 2), TAG( 3), TAG( 4)
     +    / 1.0, 1.0, 1.0, 1.0/
      DATA TAG( 5), TAG( 6), TAG( 7), TAG( 8)
     +    / 1.0, 1.0, 2.0, 2.0/
      DATA TAG( 9), TAG(10), TAG(11), TAG(12)
     +    / 2.0, 2.0, 2.0, 3.0/
      DATA TAG(13), TAG(14), TAG(15), TAG(16)
     +    / 3.0, 3.0, 3.0, 3.0/
!
!     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
!
      CALL IPRINT(IPRT)
!
!     PRINT HEADING
!
      WRITE (IPRT,1000)
!
!     PERFORM SIMPLE TEST OF AOV1
!
      WRITE (IPRT,1100)
      CALL AOV1(Y, TAG, N, LDSTAK)
      WRITE (IPRT,2000) IERR
!
      RETURN
!
!     FORMATS
!
 1000 FORMAT ('1*CH6')
 1100 FORMAT (' SIMPLE TEST OF AOV1')
 2000 FORMAT (/' THE VALUE OF IERR IS ', I4)
      END
!UFSFS
      SUBROUTINE UFSFS(YFFT, N, LYFFT, LDSTAK, NW, LAGS, NF, FMIN, FMAX,
     +   NPRT, SPCF, ISPCF, FREQ)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS USING THE FFT (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   FMAX,FMIN
      INTEGER
     +   ISPCF,LDSTAK,LYFFT,N,NF,NPRT,NW
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(*),SPCF(*),YFFT(*)
      INTEGER
     +   LAGS(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  ARRAYS IN COMMON
      DOUBLE PRECISION DSTAK(12)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   ALPHA,DELTA,YMISS
      INTEGER
     +   ACOV,I,IFP,IO,IPRT,ISORT,ISYM,LACOV,LAGMAX,LDSMIN,LNLPPA,
     +   LPCV,LWORK,NALL0,NFFT,WORK,XAXIS,YAXIS
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   RSTAK(12)
      INTEGER
     +   ISTAK(12),NLPPA(1)
      LOGICAL
     +   OPTION(4)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL FUNCTIONS
      INTEGER
     +   STKGET,STKST
      EXTERNAL STKGET,STKST
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,LDSCMP,PARZEN,SETESL,STKCLR,STKSET,UFSDRV
!
!  INTRINSIC FUNCTIONS
      INTRINSIC MAX
!
!  COMMON BLOCKS
      COMMON /CSTAK/DSTAK
      COMMON /ERRCHK/IERR
!
!  EQUIVALENCES
      EQUIVALENCE (DSTAK(1),RSTAK(1))
      EQUIVALENCE (DSTAK(1),ISTAK(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER ACOV
!        THE STARTING LOCATION IN RSTAK FOR THE ACVF VECTOR.
!     DOUBLE PRECISION ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     DOUBLE PRECISION DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE SPECTRUM
!        IS TO BE COMPUTED.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF ERR01, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION FOR THE ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY ISYM.
!     INTEGER LACOV
!        THE LENGTH OF VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
!        THIS ROUTINE WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(1)
!        A DUMMY ARRAY FOR SERIES WITHOUT MISSING VALUES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     DOUBLE PRECISION RSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     DOUBLE PRECISION SPCF(ISPCF,NW)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY WORK.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY XAXIS.
!     DOUBLE PRECISION YFFT(LYFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY YAXIS.
!     DOUBLE PRECISION YMISS
!        THE MISSING VALUE CODE FOR THE SERIES.
!
!     SET UP NAME ARRAYS
!
      DATA NMSUB(1), NMSUB(2), NMSUB(3), NMSUB(4), NMSUB(5), NMSUB(6) /
     +   'U','F','S','F','S',' '/
!
!     SET UP
!
      OPTION(4) = .TRUE.
      OPTION(3) = .FALSE.
      OPTION(2) = .FALSE.
      OPTION(1) = .TRUE.
!
!     SET MAXIMUM LAG VALUE TO BE USED.
!
      LAGMAX = N - 1
      IF (NW.LE.0) GO TO 20
      LAGMAX = LAGS(1)
      DO 10 I=1,NW
         LAGMAX = MAX(LAGMAX,LAGS(I))
   10 CONTINUE
   20 CONTINUE
      LACOV = LAGMAX + 1
      LNLPPA = 1
!
!     SET EXTENDED SERIES LENGTH
!
      CALL SETESL(N+LAGMAX, 4, NFFT)
!
!     COMPUTE MINIMUM ALLOWABLE STACK LENGTH
!
      IO = 1
      IF (NPRT.EQ.0) IO = 0
!
      CALL LDSCMP(5, 0, IO*(NF+5), 0, 0, 0, 'D',
     +   LAGMAX+1+NFFT+IO*(2*NF+10), LDSMIN)
!
      LPCV = NF + 5
      LWORK = NFFT
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!     SET THE STACK ALLOCATION TYPE.
!
      CALL STKSET(LDSTAK, 4)
      NALL0 = STKST(1)
!
      IFP = 4
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
!
      IF ((LDSMIN.GT.LDSTAK) .OR. (LDSMIN.LE.6)) THEN
         ACOV = 1
         WORK = 1
         XAXIS = 1
         YAXIS = 1
         ISYM = 1
         ISORT = 1
      ELSE
         ACOV = STKGET(LACOV,IFP)
         WORK = STKGET(LWORK,IFP)
         IF (NPRT.NE.0) THEN
            XAXIS = STKGET(LPCV,IFP)
            YAXIS = STKGET(LPCV,IFP)
            ISYM = STKGET(LPCV,2)
            ISORT = ISYM
         ELSE
            XAXIS = WORK
            YAXIS = WORK
            ISYM = WORK
            ISORT = ISYM
         END IF
      END IF
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!
      CALL UFSDRV(YFFT, LYFFT, YMISS, RSTAK(ACOV), NLPPA, SPCF, ISPCF,
     +   NF, FMIN, FMAX, FREQ, N, NW, LAGMAX, LAGS, RSTAK(WORK), LACOV,
     +   LWORK, DELTA, ISTAK(ISORT), ISTAK(ISYM), RSTAK(XAXIS),
     +   RSTAK(YAXIS), LPCV, ALPHA, NPRT, PARZEN, NMSUB, LDSMIN, LDSTAK,
     +   OPTION, LNLPPA, NFFT)
!
      CALL STKCLR(NALL0)
!
!     CHECK FOR ERRORS
!
      IF (IERR.EQ.0) RETURN
!
      CALL IPRINT(IPRT)
      WRITE (IPRT,1000)
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL UFSFS (YFFT, N, LYFFT, LDSTAK,'/
     +   '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/
     +   '      +            SPCF, ISPCF, FREQ)')
      END
!UASORD
      SUBROUTINE UASORD (SPCF, SPCA, SPCFMN, SPCFMX, SPCAMN, SPCAMX,
     +   FREQ, NF, XAXIS, YAXIS, ISYM, NPTS, ISPC, LPCV, NSPCF, NSPCA,
     +   BW, ALOW, AUP, XPLTMN, XPLTMX, YPLTMN, YPLTMX, NPRT)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES CO-ORDINATES FOR THE SPECTRUM PLOTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   ALOW,AUP,BW,SPCAMN,SPCAMX,SPCFMN,SPCFMX,XPLTMN,XPLTMX,YPLTMN,
     +   YPLTMX
      INTEGER
     +   ISPC,LPCV,NF,NPRT,NPTS,NSPCA,NSPCF
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   FREQ(NF),SPCA(ISPC),SPCF(ISPC),XAXIS(LPCV),YAXIS(LPCV)
      INTEGER
     +   ISYM(LPCV)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   CILOW,CIMID,CIUP,YMAX
      INTEGER
     +   I,ISPCA,ISPCF
!
!  EXTERNAL SUBROUTINES
      EXTERNAL SPPLTC,SPPLTD,SPPLTL
!
!  INTRINSIC FUNCTIONS
      INTRINSIC LOG10,MAX,MIN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION ALOW
!        THE FACTOR USED TO COMPUTE THE LOWER CONFIDENCE LIMITS.
!     DOUBLE PRECISION AUP
!        THE FACTOR USED TO COMPUTE THE UPPER CONFIDENCE LIMITS.
!     DOUBLE PRECISION BW
!        THE BANDWIDTH.
!     DOUBLE PRECISION CILOW, CIMID, CIUP
!        THE Y AXIS VALUES FOR THE LOWER, MID AND UPPER CONFIDENCE
!        INTERVAL POINTS.
!     DOUBLE PRECISION FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER ISPC
!         THE LENGTH OF THE SPECTRUM ARRAYS.
!     INTEGER ISPCA, ISPCF
!        THE INDEX FOR THE FOURIER AND AUTOREGRESSIVE  ESTIMATES,
!        RESPECTIVELY.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
!        ARE TO BE ESTIMATED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     INTEGER NSPCA, NSPCF
!        THE NUMBER OF VALID SPECTRUM ESTIMATES FOR THE AUTOREGRESSIVE
!        AND FOURIER SPECTRUMS, RESPECTIVELY.
!     DOUBLE PRECISION SPCA(ISPC)
!        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!     DOUBLE PRECISION SPCAMN, SPCAMX
!        THE MINIMUM AND MAXIMUM AUTOREGRESSIVE SPECTRUM VALUE TO BE
!        PLOTTED.
!     DOUBLE PRECISION SPCF(ISPC)
!        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
!     DOUBLE PRECISION SPCFMN, SPCFMX
!        THE MINIMUM AND MAXIMUM FOURIER SPECTRUM VALUE TO BE PLOTTED.
!     DOUBLE PRECISION XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     DOUBLE PRECISION YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     DOUBLE PRECISION YMAX
!        THE MAXIMUM  ACTUAL SPECTRUM VALUE (IN DECIBLES) TO BE PLOTTED.
!     DOUBLE PRECISION YPLTMN, YPLTMX
!        THE MINIMUM AND MAYIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!
      ISPCF = 0
      ISPCA = NSPCF
!
      IF (NPRT.GE.1) GO TO 30
!
!     SET VARIOUS Y AXIS VALUES FOR DECIBLE PLOTS
!
      CALL SPPLTD (MIN(SPCFMN, SPCAMN), MAX(SPCFMX, SPCAMX),
     +   ALOW, AUP, YPLTMN, YPLTMX, CILOW, CIMID, CIUP, YMAX)
!
!     SET CO-ORDINATES FOR DECIBLE PLOTS
!
      DO 20 I = 1, NF
         IF (SPCF(I) .LT. SPCFMN) GO TO 10
         ISPCF = ISPCF + 1
         XAXIS(ISPCF) = FREQ(I)
         YAXIS(ISPCF) = 10.0D0 * LOG10(SPCF(I)) - YMAX
         ISYM(ISPCF) = 1
!
   10    IF (SPCA(I) .LT. SPCAMN) GO TO 20
         ISPCA = ISPCA + 1
         XAXIS(ISPCA) = FREQ(I)
         YAXIS(ISPCA) = 10.0D0 * LOG10(SPCA(I)) - YMAX
         ISYM(ISPCA) = 2
   20 CONTINUE
!
      GO TO 70
   30 CONTINUE
!
!     SET VARIOUS Y AXIS VALUES FOR LOG PLOTS
!
      CALL SPPLTL (MIN(SPCFMN, SPCAMN), MAX(SPCFMX, SPCAMX),
     +   ALOW, AUP, YPLTMN, YPLTMX, CILOW, CIMID, CIUP)
!
!     SET CO-ORDINATES FOR LOG PLOTS
!
      DO 60 I = 1, NF
         IF (SPCF(I) .LT. SPCFMN) GO TO 50
         ISPCF = ISPCF + 1
         XAXIS(ISPCF) = FREQ(I)
         YAXIS(ISPCF) = SPCF(I)
         ISYM(ISPCF) = 1
!
   50    IF (SPCA(I) .LT. SPCAMN) GO TO 60
         ISPCA = ISPCA + 1
         XAXIS(ISPCA) = FREQ(I)
         YAXIS(ISPCA) = SPCA(I)
         ISYM(ISPCA) = 2
   60 CONTINUE
!
   70 CONTINUE
!
      NPTS = NSPCA + NSPCF
!
!     SET CO-ORDINATES FOR BANDWIDTH AND CONFIDENCE INTERVAL.
!
      CALL SPPLTC (XAXIS, YAXIS, ISYM, NPTS, XPLTMN, XPLTMX, BW, CILOW,
     +   CIMID, CIUP, LPCV)
!
      RETURN
      END
!ERSIE
      SUBROUTINE ERSIE(NMSUB, NMVAR, VAL, VALMN, VALMX, MSGTYP, HEAD,
     +   ERROR, NMMIN, NMMAX)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THE ROUTINE CHECKS WHETHER THE VALUE   VAL   IS WITHIN THE
!     THE RANGE VALMN (INCLUSIVE) TO VALMX (EXCLUSIVE), AND PRINTS A
!     DIAGNOSTIC IF IT IS NOT.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   VAL,VALMN,VALMX
      INTEGER
     +   MSGTYP
      LOGICAL
     +   ERROR,HEAD
!
!  ARRAY ARGUMENTS
      CHARACTER
     +   NMMAX(8)*1,NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
!        PRINTED, WHERE IF ERROR IS .TRUE. AND
!        MSGTYP = 1 THE INPUT VALUE WAS OUTSIDE THE RANGE DETERMINED
!                   FROM OTHER INPUT ARGUMENTS
!        MSGTYP = 2 THE INPUT VALUE WAS OUTSIDE THE RANGE IMPOSED BY
!                   STARPAC
!     CHARACTER*1 NMMAX(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MAXIMUM.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE ARGUMENTS NAME.
!     DOUBLE PRECISION VAL
!        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
!     DOUBLE PRECISION VALMN, VALMX
!        THE MINIMUM AND MAXIMUM OF THE RANGE WITHIN WHICH THE
!        ARGUMENT MUST LIE.
!
      ERROR = .FALSE.
!
      IF (((VALMN.LE.VAL) .AND. (VAL.LT.VALMX)) .OR.
     +   (VALMX.LT.VALMN)) RETURN
!
      ERROR = .TRUE.
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
!
      WRITE (IPRT, 1000) (NMVAR(I),I=1,6), VAL
!
!     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE DETERMINED FROM
!     OTHER INPUT ARGUMENTS.
!
      IF (MSGTYP .EQ. 1)
     +   WRITE (IPRT, 1010) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8),
     +      (NMMAX(I),I=1,8)
!
!     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE IMPOSED BY STARPAC
!
      IF (MSGTYP .EQ. 2)
     +   WRITE (IPRT, 1020) (NMVAR(I),I=1,6), VALMN, VALMX
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/20H THE INPUT VALUE OF , 6A1, 4H IS , G15.8, '.')
 1010 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   17H MUST LIE BETWEEN, 1X, 8A1, 12H (INCLUSIVE)/
     +   5H AND , 8A1, 13H (EXCLUSIVE).)
 1020 FORMAT(
     +   27H THE VALUE OF THE ARGUMENT , 6A1,
     +   17H MUST LIE BETWEEN, 1X, G15.8, 12H (INCLUSIVE)/
     +   5H AND , G15.8, 13H (EXCLUSIVE).)
!
      END
!DFBWM
      SUBROUTINE DFBWM (N, LAG, W, LW, NLPPA1, NLPPA2, LNLPPA, DF, BW)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES AND STORES THE ASSOCIATED DEGREES OF
!     FREEDOM AND BANDWIDTH FOR A GIVEN LAG WINDOW WHEN MISSING DATA ARE
!     INVOLVED.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   BW,DF
      INTEGER
     +   LAG,LNLPPA,LW,N
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   W(LW)
      INTEGER
     +   NLPPA1(LNLPPA),NLPPA2(LNLPPA)
!
!  LOCAL SCALARS
      INTEGER
     +   K
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION BW
!        THE BANDWIDTH.
!     DOUBLE PRECISION DF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     INTEGER K
!        AN INDEX VARIABLE
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NLPPA1(LNLPPA), NLPPA2(LNLPPA)
!        THE NUMBER OF LAGGED PRODUCT PAIRS USED FOR EACH ACVF
!        ESTIMATE.
!     DOUBLE PRECISION W(LW)
!        THE VECTOR OF LAG WINDOWS.
!
      BW = (W(1)*N)**2/NLPPA1(1)
      DO 10 K = 1, LAG
         BW = BW + (W(K+1)*(N-K))**2 *
     +      (1.0D0/NLPPA1(K+1) + 1.0D0/NLPPA2(K+1))
   10 CONTINUE
!
!
      BW = N / BW
      DF = 2.0D0 * BW * N
      RETURN
      END
!VPL
      SUBROUTINE VPL(YM, N, NS, ILOG)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT (LOG PLOT OPTION).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ILOG,N,NS
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   YM(*)
!
!  SCALARS IN COMMON
      INTEGER
     +   IERR
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   XINC,XLB,YLB,YUB
      INTEGER
     +   IBAR,IPRT,IRLIN,ISCHCK,ISIZE,IYM,LISYM,M
      LOGICAL
     +   MISS,MULTI
!
!  LOCAL ARRAYS
      DOUBLE PRECISION
     +   YMMISS(1)
      INTEGER
     +   ISYM(1)
      CHARACTER
     +   NMSUB(6)*1
!
!  EXTERNAL SUBROUTINES
      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      COMMON /ERRCHK/IERR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     DOUBLE PRECISION XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     DOUBLE PRECISION YLB
!        LOWER BOUND FOR Y-AXIS.
!     DOUBLE PRECISION YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     DOUBLE PRECISION YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     DOUBLE PRECISION YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
      DATA
     +  NMSUB(1),  NMSUB(2),  NMSUB(3),  NMSUB(4),  NMSUB(5),  NMSUB(6)
     +    /  ' ',       'V',       'P',       'L',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      YMMISS(1) = 1.0D0
      M = 1
      IYM = N
      MULTI = .FALSE.
      YLB = 0.0D0
      YUB = 0.0D0
      XLB = 1.0D0
      XINC = 1.0D0
      ISCHCK = 0
      ISIZE = -1
      MISS = .FALSE.
      LISYM = 1
      IRLIN = -1
      IBAR = 0
!
!     COMMENCE BODY OF ROUTINE
!
      CALL VPCNT (YM, YMMISS, N, M, IYM, MULTI, ILOG, YLB, YUB,
     +  XLB, XINC, NS, IRLIN, IBAR, NMSUB, ISCHCK, ISYM, ISIZE,
     +  MISS, LISYM)
!
      IF (IERR.NE.0) THEN
        IERR = 1
        CALL IPRINT(IPRT)
        WRITE (IPRT,1000)
      END IF
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/42H THE CORRECT FORM OF THE CALL STATEMENT IS//
     +   '       CALL VPL (Y, N, NS, ILOG)')
      END
!BFSLAG
      SUBROUTINE BFSLAG(CCOV, LAGMAX, LAGS, N, NW, NWUSED, ICCOV,
     +   JCCOV, INDEX1, INDEX2)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE LAG WINDOW TRUNCATION POINTS FOR
!     FOURIER BIVARIATE SPECTRUM ANALYSIS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      INTEGER
     +   ICCOV,INDEX1,INDEX2,JCCOV,LAGMAX,N,NW,NWUSED
!
!  ARRAY ARGUMENTS
      DOUBLE PRECISION
     +   CCOV(ICCOV,JCCOV,*)
      INTEGER
     +   LAGS(*)
!
!  LOCAL SCALARS
      DOUBLE PRECISION
     +   COVMX,COVMXI,FAC11,FAC12,FAC21,FAC22,P95LIM
      INTEGER
     +   I,J,K,LAG,NWM1
!
!  INTRINSIC FUNCTIONS
      INTRINSIC ABS,MAX,DBLE,SQRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION CCOV(ICCOV,JCCOV,*)
!        THE COVARIANCES.
!     DOUBLE PRECISION COVMX
!        THE MAXIMUM COVARIANCE VALUE.
!     DOUBLE PRECISION COVMXI
!        THE MAXIMUM COVARIANCE VALUE FOR THE ITH LAG.
!     DOUBLE PRECISION FAC11, FAC12, FAC21, FAC22
!        FACTORS USED TO COMPUTE THE CORRELATION COEFFICIENTS.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER J
!        AN INDEX VALUE.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER K
!        AN INDEX VALUE.
!     INTEGER LAG, LAGMAX
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        BIVARIATE COVARIANCE BEING COMPUTED AND THE MAXIMUM LAG
!        TO BE USED, RESPECTIVELY.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NW
!        THE NUMBER OF DIFFERENT BANDWIDTHS REQUESTED.
!     INTEGER NWM1, NWUSED
!        THE NUMBER OF DIFFERENT BANDWIDTHS MINUS 1, AND THE
!        ACTUAL NUMBER OF BANDWIDTHS ACTUALLY USED.
!     DOUBLE PRECISION P95LIM
!        THE 95 PERCENT CONFIDENT LIMIT FOR WHITE NOISE.
!
      LAGS(NW) = LAGMAX
      IF (LAGS(NW).LE.32) GO TO 30
!
!     COMPUTE 95 PERCENT CONFIDENCE LIMITS ON BIVARIATECOVARIANCES,
!     ASSUMING WHITE NOISE.
!
      P95LIM = 1.96D0/SQRT(DBLE(N))
!
      FAC11 = CCOV(1,INDEX1,INDEX1)
      FAC12 = SQRT(CCOV(1,INDEX1,INDEX1)*CCOV(1,INDEX2,INDEX2))
      FAC21 = FAC12
      FAC22 = CCOV(1,INDEX2,INDEX2)
!
!     CHECK FOR FIRST CVF EXCEEDING 95 PERCENT LIMIT ON WHITE NOISE
!
      DO 10 I=1,LAGMAX
         LAG = LAGMAX + 1 - I
         COVMXI = MAX(ABS(CCOV(LAG,INDEX1,INDEX1)*FAC11),ABS(CCOV(LAG,
     +      INDEX1,INDEX2)*FAC12),ABS(CCOV(LAG,INDEX2,INDEX1)*FAC21),
     +      ABS(CCOV(LAG,INDEX2,INDEX2)*FAC22))
         IF (COVMXI.GE.P95LIM) GO TO 30
         LAGS(NW) = LAGS(NW) - 1
   10 CONTINUE
!
!     IF NO ACVF EXCEEDS WHITE NOISE LIMITS, CHECK FOR LARGEST ACVF.
!
      LAGS(NW) = 1
      COVMX = ABS(CCOV(2,1,1)*FAC11)
      DO 20 LAG=1,LAGMAX
         COVMXI = MAX(ABS(CCOV(LAG,INDEX1,INDEX1)*FAC11),ABS(CCOV(LAG,
     +      INDEX1,INDEX2)*FAC12),ABS(CCOV(LAG,INDEX2,INDEX1)*FAC21),
     +      ABS(CCOV(LAG,INDEX2,INDEX2)*FAC22))
         IF (COVMXI.LE.COVMX) GO TO 20
         LAGS(NW) = LAG
         COVMX = COVMXI
   20 CONTINUE
!
!     COMPUTE LAG WINDOW TRUNCATION POINTS
!
   30 LAGS(NW) = LAGS(NW)*3.0D0/2.0D0
      IF (LAGS(NW).LT.32) LAGS(NW) = 32
      IF (LAGS(NW).GT.LAGMAX) LAGS(NW) = LAGMAX
      NWUSED = NW
      IF (NW.EQ.1) RETURN
      NWM1 = NW - 1
      DO 40 I=1,NWM1
         K = NW - I
         LAGS(K) = LAGS(K+1)/2
   40 CONTINUE
!
!     CHECK WHETHER ALL NW LAG WINDOW TRUNCATION POINTS CAN BE USED.
!
      NWUSED = NW
      IF (LAGS(1).GE.4) RETURN
!
!     RECONSTURCT -LAGS- VECTOR IF NOT ALL TRUNCATION POINTS ARE
!     TO BE USED
!
      DO 50 I=2,NW
         NWUSED = NWUSED - 1
         IF (LAGS(I).GE.4) GO TO 60
   50 CONTINUE
!
   60 DO 70 I=1,NWUSED
         J = NW - NWUSED + I
         LAGS(I) = LAGS(J)
   70 CONTINUE
!
      RETURN
      END
!ERAGTP
      SUBROUTINE ERAGTP (NMSUB, NMVAR, YMMN, NVMX, HEAD, MSGTYP, NV,
     +   NMMIN)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRINTS THE ERROR MESSAGES FOR ERAGT AND ERAGTM.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      DOUBLE PRECISION
     +   YMMN
      INTEGER
     +   MSGTYP,NV,NVMX
      LOGICAL
     +   HEAD
!
!  ARRAY ARGUMENTS
      CHARACTER
     +   NMMIN(8)*1,NMSUB(6)*1,NMVAR(8)*1
!
!  LOCAL SCALARS
      INTEGER
     +   I,IPRT
!
!  EXTERNAL SUBROUTINES
      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
!        IF (MSGTYP.GE.3) THE MESSAGE PRINTED WILL USE NMMIN
!        OTHERWISE IT WILL USE YMMN.
!        IF (MSGTYP = 1 OR 3) NO VIOLATIONS ARE ALLOWED.
!        IF (MSGTYP = 2 OR 4) THE NUMBER OF VIOLATIONS MUST
!                             BE LESS THAN   NVMX   .
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE PARAMETERS NAME.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND.
!     INTEGER NVMX
!        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
!     DOUBLE PRECISION YMMN
!        THE MINIMUM ACCEPTABLE VALUE.
!
      CALL IPRINT(IPRT)
      CALL EHDR(NMSUB, HEAD)
!
      IF (MSGTYP.LE.2)
     +   WRITE (IPRT, 1000) (NMVAR(I),I=1,6), YMMN, NV
      IF (MSGTYP.GE.3)
     +   WRITE (IPRT, 1005) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8), NV
!
      GO TO (10, 20, 30, 40), MSGTYP
!
   10 WRITE(IPRT, 1010) (NMVAR(I),I=1,6), YMMN
      RETURN
!
   20 WRITE(IPRT, 1020) (NMVAR(I),I=1,6), YMMN, NVMX
      RETURN
!
   30 WRITE(IPRT, 1030) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8)
      RETURN
!
   40 WRITE(IPRT, 1040) (NMVAR(I),I=1,6), (NMMIN(I),I=1,8), NVMX
      RETURN
!
!     FORMAT STATEMENTS
!
 1000 FORMAT (/
     +   31H THE NUMBER OF VALUES IN ARRAY , 6A1,
     +   23H LESS THAN OR EQUAL TO , 1PE14.7, 4H IS , I6, '.')
 1005 FORMAT (/
     +   31H THE NUMBER OF VALUES IN ARRAY , 6A1,
     +   23H LESS THAN OR EQUAL TO , 8A1, 4H IS , I6, '.')
 1010 FORMAT(
     +   25H THE VALUES IN THE ARRAY , 6A1,
     +   26H MUST ALL BE GREATER THAN , 1PE14.7, '.')
 1020 FORMAT(
     +   35H THE NUMBER OF VALUES IN THE ARRAY , 6A1,
     +   23H LESS THAN OR EQUAL TO , 8A1/
     +   19H MUST BE LESS THAN , I5, '.')
 1030 FORMAT(
     +   25H THE VALUES IN THE ARRAY , 6A1,
     +   26H MUST ALL BE GREATER THAN , 1PE14.7, '.')
 1040 FORMAT(
     +   35H THE NUMBER OF VALUES IN THE ARRAY , 6A1,
     +   23H LESS THAN OR EQUAL TO , 8A1/
     +   19H MUST BE LESS THAN , I5, '.')
!
      END

!QAPPLY
      subroutine qapply(nn, n, p, j, r, ierr)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  VARIABLE DECLARATIONS
!
!
!  SCALAR ARGUMENTS
      integer
     +   ierr,n,nn,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   j(nn,p),r(n)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   t
      integer
     +   i,k,l,nl1
!
!  EXTERNAL FUNCTIONS
      real(kind=wp) ::
     +   dotprd
      external dotprd
!
!  INTRINSIC FUNCTIONS
      intrinsic abs
!
!     *****PARAMETERS.
!     INTEGER NN, N, P, IERR
!     REAL(KIND=WP) :: J(NN,P), R(N)
!
!     =================================================================
!
!     *****PURPOSE.
!     THIS SUBROUTINE APPLIES TO R THE ORTHOGONAL TRANSFORMATIONS
!     STORED IN J BY QRFACT
!
!     *****PARAMETER DESCRIPTION.
!     ON INPUT.
!
!        NN IS THE ROW DIMENSION OF THE MATRIX J AS DECLARED IN
!             THE CALLING PROGRAM DIMENSION STATEMENT
!
!        N IS THE NUMBER OF ROWS OF J AND THE SIZE OF THE VECTOR R
!
!        P IS THE NUMBER OF COLUMNS OF J AND THE SIZE OF SIGMA
!
!        J CONTAINS ON AND BELOW ITS DIAGONAL THE COLUMN VECTORS
!             U WHICH DETERMINE THE HOUSEHOLDER TRANSFORMATIONS
!             IDENT - U*U.TRANSPOSE
!
!        R IS THE RIGHT HAND SIDE VECTOR TO WHICH THE ORTHOGONAL
!             TRANSFORMATIONS WILL BE APPLIED
!
!        IERR IF NON-ZERO INDICATES THAT NOT ALL THE TRANSFORMATIONS
!             WERE SUCCESSFULLY DETERMINED AND ONLY THE FIRST
!             ABS(IERR) - 1 TRANSFORMATIONS WILL BE USED
!
!     ON OUTPUT.
!
!        R HAS BEEN OVERWRITTEN BY ITS TRANSFORMED IMAGE
!
!     *****APPLICATION AND USAGE RESTRICTIONS.
!     NONE
!
!     *****ALGORITHM NOTES.
!     THE VECTORS U WHICH DETERMINE THE HOUSEHOLDER TRANSFORMATIONS
!     ARE NORMALIZED SO THAT THEIR 2-NORM SQUARED IS 2.  THE USE OF
!     THESE TRANSFORMATIONS HERE IS IN THE SPIRIT OF (1).
!
!     *****SUBROUTINES AND FUNCTIONS CALLED.
!
!     DOTPRD - FUNCTION, RETURNS THE INNER PRODUCT OF VECTORS
!
!     *****REFERENCES.
!     (1) BUSINGER, P. A., AND GOLUB, G. H. (1965), LINEAR LEAST SQUARES
!        SOLUTIONS BY HOUSEHOLDER TRANSFORMATIONS, NUMER. MATH. 7,
!        PP. 269-276.
!
!     *****HISTORY.
!     DESIGNED BY DAVID M. GAY, CODED BY STEPHEN C. PETERS (WINTER 1977)
!
!     *****GENERAL.
!
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!     MCS-7600324, DCR75-10143, 76-14311DSS, AND MCS76-11989.
!
!     =================================================================
!
!     *****LOCAL VARIABLES.
!     INTEGER I, K, L, NL1
!     REAL(KIND=WP) :: T
!/
!     *****FUNCTIONS.
!     EXTERNAL DOTPRD
!     REAL(KIND=WP) :: DOTPRD
!
      k = p
      if (ierr .ne. 0) k = abs(ierr) - 1
      if ( k .eq. 0) go to 999
!
      do 20 l = 1, k
         nl1 = n - l + 1
         t = -dotprd(nl1, j(l,l), r(l))
!
         do 10 i = l, n
            r(i) = r(i) + t*j(i,l)
 10      continue
 20   continue
 999  return

      end subroutine qapply
!LIVMUL
      subroutine livmul(n, x, l, y)
!
!  ***  SOLVE  L*X = Y, WHERE  L  IS AN  N X N  LOWER TRIANGULAR
!  ***  MATRIX STORED COMPACTLY BY ROWS.  X AND Y MAY OCCUPY THE SAME
!  ***  STORAGE.  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   n
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   l(1),x(n),y(n)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   t,zero
      integer
     +   i,j,k
!
!  EXTERNAL FUNCTIONS
      real(kind=wp) ::
     +   dotprd
      external dotprd
!
      data zero/0.0_wp/
!
      do 10 k = 1, n
         if (y(k) .ne. zero) go to 20
         x(k) = zero
 10      continue
      go to 999
 20   j = k*(k+1)/2
      x(k) = y(k) / l(j)
      if (k .ge. n) go to 999
      k = k + 1
      do 30 i = k, n
         t = dotprd(i-1, l(j+1), x)
         j = j + i
         x(i) = (y(i) - t)/l(j)
 30      continue
 999  return
      end subroutine livmul
!LSQRT
      subroutine lsqrt(n1, n, l, a, irc)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  COMPUTE ROWS N1 THROUGH N OF THE CHOLESKY FACTOR  L  OF
!  ***  A = L*(L**T),  WHERE  L  AND THE LOWER TRIANGLE OF  A  ARE BOTH
!  ***  STORED COMPACTLY BY ROWS (AND MAY OCCUPY THE SAME STORAGE).
!  ***  IRC = 0 MEANS ALL WENT WELL.  IRC = J MEANS THE LEADING
!  ***  PRINCIPAL  J X J  SUBMATRIX OF  A  IS NOT POSITIVE DEFINITE --
!  ***  AND  L(J*(J+1)/2)  CONTAINS THE (NONPOS.) REDUCED J-TH DIAGONAL.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   irc,n,n1
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   a(1),l(1)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   t,td,zero
      integer
     +   i,i0,ij,ik,im1,j,j0,jk,jm1,k
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!  ***  PARAMETERS  ***
!
!     INTEGER N1, N, IRC
!     REAL(KIND=WP) :: L(1), A(1)
!     DIMENSION L(N*(N+1)/2), A(N*(N+1)/2)
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER I, IJ, IK, IM1, I0, J, JK, JM1, J0, K
!     REAL(KIND=WP) :: T, TD, ZERO
!
!/
      data zero/0.0_wp/
!
!  ***  BODY  ***
!
      i0 = n1 * (n1 - 1) / 2
      do 50 i = n1, n
         td = zero
         if (i .eq. 1) go to 40
         j0 = 0
         im1 = i - 1
         do 30 j = 1, im1
              t = zero
              if (j .eq. 1) go to 20
              jm1 = j - 1
              do 10 k = 1, jm1
                   ik = i0 + k
                   jk = j0 + k
                   t = t + l(ik)*l(jk)
 10                continue
 20           ij = i0 + j
              j0 = j0 + j
              t = (a(ij) - t) / l(j0)
              l(ij) = t
              td = td + t*t
 30           continue
 40      i0 = i0 + i
         t = a(i0) - td
         if (t .le. zero) go to 60
         l(i0) = sqrt(t)
 50      continue
!
      irc = 0
      go to 999
!
 60   l(i0) = t
      irc = i
!
 999  return
!
      end subroutine lsqrt
!LINVRT
      subroutine linvrt(n, lin, l)
!
!  ***  COMPUTE  LIN = L**-1,  BOTH  N X N  LOWER TRIANG. STORED   ***
!  ***  COMPACTLY BY ROWS.  LIN AND L MAY SHARE THE SAME STORAGE.  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   n
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   l(*),lin(*)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   one,t,zero
      integer
     +   i,ii,im1,j0,j1,jj,k,k0,np1
!
!  ***  PARAMETERS  ***
!
!     INTEGER N
!     REAL(KIND=WP) :: L(*), LIN(*)
!     DIMENSION L(N*(N+1)/2), LIN(N*(N+1)/2)
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER I, II, IM1, JJ, J0, J1, K, K0, NP1
!     REAL(KIND=WP) :: ONE, T, ZERO
      data one/1.0_wp/, zero/0.0_wp/
!
!  ***  BODY  ***
!
      np1 = n + 1
      j0 = n*(np1)/2
      do 30 ii = 1, n
         i = np1 - ii
         lin(j0) = one/l(j0)
         if (i .le. 1) go to 999
         j1 = j0
         im1 = i - 1
         do 20 jj = 1, im1
              t = zero
              j0 = j1
              k0 = j1 - jj
              do 10 k = 1, jj
                   t = t - l(k0)*lin(j0)
                   j0 = j0 - 1
                   k0 = k0 + k - i
 10                continue
              lin(j0) = t/l(k0)
 20           continue
         j0 = j0 - 1
 30      continue
 999  return
      end subroutine linvrt
!VSCOPY
      subroutine vscopy(p, y, s)
!
!  ***  SET P-VECTOR Y TO SCALAR S  ***
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: s
      integer p
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: y(*)
!
!  LOCAL SCALARS
      integer i
!
      do i = 1, p
         y(i) = s
      enddo

      end subroutine vscopy
!LMSTEP
      subroutine lmstep(d, g, ierr, ipivot, ka, p, qtr, r, step, v, w)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!  ***  COMPUTE LEVENBERG-MARQUARDT STEP USING MORE-HEBDEN TECHNIQUE  **
!  ***  NL2SOL VERSION 2.2.  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   ierr,ka,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   d(p),g(p),qtr(p),r(1),step(p),v(21),w(1)
      integer
     +   ipivot(p)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   a,adi,alphak,b,d1,d2,dfac,dfacsq,dst,dtol,eight,half,lk,
     +   negone,oldphi,one,p001,phi,phimax,phimin,psifac,rad,si,sj,
     +   sqrtak,t,three,ttol,twopsi,uk,wl,zero
      integer
     +   dgnorm,dst0,dstnrm,dstsav,epslon,gtstep,i,i1,ip1,j1,k,
     +   kalim,l,lk0,nreduc,phipin,phmnfc,phmxfc,pp1o2,preduc,rad0,
     +   radius,res,res0,rmat,rmat0,stppar,uk0
!
!  EXTERNAL FUNCTIONS
      real(kind=wp) ::
     +   dotprd,v2norm
      external dotprd,v2norm
!
!  EXTERNAL SUBROUTINES
      external litvmu,livmul,vcopy
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max,min,sqrt
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER IERR, KA, P
!     INTEGER IPIVOT(P)
!     REAL(KIND=WP) :: D(P), G(P), QTR(P), R(1), STEP(P), V(21), W(1)
!     DIMENSION W(P*(P+5)/2 + 4)
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  ***  PURPOSE  ***
!
!        GIVEN THE R MATRIX FROM THE QR DECOMPOSITION OF A JACOBIAN
!     MATRIX, J, AS WELL AS Q-TRANSPOSE TIMES THE CORRESPONDING
!     RESIDUAL VECTOR, RESID, THIS SUBROUTINE COMPUTES A LEVENBERG-
!     MARQUARDT STEP OF APPROXIMATE LENGTH V(RADIUS) BY THE MORE-
!     TECHNIQUE.
!
!  ***  PARAMETER DESCRIPTION  ***
!
!      D (IN)  = THE SCALE VECTOR.
!      G (IN)  = THE GRADIENT VECTOR (J**T)*R.
!   IERR (I/O) = RETURN CODE FROM QRFACT OR QRFGS -- 0 MEANS R HAS
!             FULL RANK.
! IPIVOT (I/O) = PERMUTATION ARRAY FROM QRFACT OR QRFGS, WHICH COMPUTE
!             QR DECOMPOSITIONS WITH COLUMN PIVOTING.
!     KA (I/O).  KA .LT. 0 ON INPUT MEANS THIS IS THE FIRST CALL ON
!             LMSTEP FOR THE CURRENT R AND QTR.  ON OUTPUT KA CON-
!             TAINS THE NUMBER OF HEBDEN ITERATIONS NEEDED TO DETERMINE
!             STEP.  KA = 0 MEANS A GAUSS-NEWTON STEP.
!      P (IN)  = NUMBER OF PARAMETERS.
!    QTR (IN)  = (Q**T)*RESID = Q-TRANSPOSE TIMES THE RESIDUAL VECTOR.
!      R (IN)  = THE R MATRIX, STORED COMPACTLY BY COLUMNS.
!   STEP (OUT) = THE LEVENBERG-MARQUARDT STEP COMPUTED.
!      V (I/O) CONTAINS VARIOUS CONSTANTS AND VARIABLES DESCRIBED BELOW.
!      W (I/O) = WORKSPACE OF LENGTH P*(P+5)/2 + 4.
!
!  ***  ENTRIES IN V  ***
!
! V(DGNORM) (I/O) = 2-NORM OF (D**-1)*G.
! V(DSTNRM) (I/O) = 2-NORM OF D*STEP.
! V(DST0)   (I/O) = 2-NORM OF GAUSS-NEWTON STEP (FOR NONSING. J).
! V(EPSLON) (IN) = MAX. REL. ERROR ALLOWED IN TWONORM(R)**2 MINUS
!             TWONORM(R - J*STEP)**2.  (SEE ALGORITHM NOTES BELOW.)
! V(GTSTEP) (OUT) = INNER PRODUCT BETWEEN G AND STEP.
! V(NREDUC) (OUT) = HALF THE REDUCTION IN THE SUM OF SQUARES PREDICTED
!             FOR A GAUSS-NEWTON STEP.
! V(PHMNFC) (IN)  = TOL. (TOGETHER WITH V(PHMXFC)) FOR ACCEPTING STEP
!             (MORE*S SIGMA).  THE ERROR V(DSTNRM) - V(RADIUS) MUST LIE
!             BETWEEN V(PHMNFC)*V(RADIUS) AND V(PHMXFC)*V(RADIUS).
! V(PHMXFC) (IN)  (SEE V(PHMNFC).)
! V(PREDUC) (OUT) = HALF THE REDUCTION IN THE SUM OF SQUARES PREDICTED
!             BY THE STEP RETURNED.
! V(RADIUS) (IN)  = RADIUS OF CURRENT (SCALED) TRUST REGION.
! V(RAD0)   (I/O) = VALUE OF V(RADIUS) FROM PREVIOUS CALL.
! V(STPPAR) (I/O) = MARQUARDT PARAMETER (OR ITS NEGATIVE IF THE SPECIAL
!             CASE MENTIONED BELOW IN THE ALGORITHM NOTES OCCURS).
!
! NOTE -- SEE DATA STATEMENT BELOW FOR VALUES OF ABOVE SUBSCRIPTS.
!
!  ***  USAGE NOTES  ***
!
!     IF IT IS DESIRED TO RECOMPUTE STEP USING A DIFFERENT VALUE OF
!     V(RADIUS), THEN THIS ROUTINE MAY BE RESTARTED BY CALLING IT
!     WITH ALL PARAMETERS UNCHANGED EXCEPT V(RADIUS).  (THIS EXPLAINS
!     WHY MANY PARAMETERS ARE LISTED AS I/O).  ON AN INTIIAL CALL (ONE
!     WITH KA = -1), THE CALLER NEED ONLY HAVE INITIALIZED D, G, KA, P,
!     QTR, R, V(EPSLON), V(PHMNFC), V(PHMXFC), V(RADIUS), AND V(RAD0).
!
!  ***  APPLICATION AND USAGE RESTRICTIONS  ***
!
!     THIS ROUTINE IS CALLED AS PART OF THE NL2SOL (NONLINEAR LEAST-
!     SQUARES) PACKAGE (REF. 1).
!
!  ***  ALGORITHM NOTES  ***
!
!     THIS CODE IMPLEMENTS THE STEP COMPUTATION SCHEME DESCRIBED IN
!     REFS. 2 AND 4.  FAST GIVENS TRANSFORMATIONS (SEE REF. 3, PP. 60-
!     62) ARE USED TO COMPUTE STEP WITH A NONZERO MARQUARDT PARAMETER.
!        A SPECIAL CASE OCCURS IF J IS (NEARLY) SINGULAR AND V(RADIUS)
!     IS SUFFICIENTLY LARGE.  IN THIS CASE THE STEP RETURNED IS SUCH
!     THAT  TWONORM(R)**2 - TWONORM(R - J*STEP)**2  DIFFERS FROM ITS
!     OPTIMAL VALUE BY LESS THAN V(EPSLON) TIMES THIS OPTIMAL VALUE,
!     WHERE J AND R DENOTE THE ORIGINAL JACOBIAN AND RESIDUAL.  (SEE
!     REF. 2 FOR MORE DETAILS.)
!
!  ***  FUNCTIONS AND SUBROUTINES CALLED  ***
!
! DOTPRD - RETURNS INNER PRODUCT OF TWO VECTORS.
! LITVMU - APPLY INVERSE-TRANSPOSE OF COMPACT LOWER TRIANG. MATRIX.
! LIVMUL - APPLY INVERSE OF COMPACT LOWER TRIANG. MATRIX.
! VCOPY  - COPIES ONE VECTOR TO ANOTHER.
! V2NORM - RETURNS 2-NORM OF A VECTOR.
!
!  ***  REFERENCES  ***
!
! 1.  DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1980), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, (SUBMITTED TO ACM
!             TRANS. MATH. SOFTWARE).
! 2.  GAY, D.M. (1979), COMPUTING OPTIMAL ELLIPTICALLY CONSTRAINED
!             STEPS, MRC TECH. SUMMARY REPORT NO. 2013, MATH RESEARCH
!             CENTER, UNIV. OF WISCONSIN-MADISON.
! 3.  LAWSON, C.L., AND HANSON, R.J. (1974), SOLVING LEAST SQUARES
!             PROBLEMS, PRENTICE-HALL, ENGLEWOOD CLIFFS, N.J.
! 4.  MORE, J.J. (1978), THE LEVENBERG-MARQUARDT ALGORITHM, IMPLEMEN-
!             TATION AND THEORY, PP.105-116 OF SPRINGER LECTURE NOTES
!             IN MATHEMATICS NO. 630, EDITED BY G.A. WATSON, SPRINGER-
!             VERLAG, BERLIN AND NEW YORK.
!
!  ***  GENERAL  ***
!
!     CODED BY DAVID M. GAY.
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!     MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989, AND
!     MCS-7906671.
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER DSTSAV, I, IP1, I1, J1, K, KALIM, L, LK0, PHIPIN,
!    1        PP1O2, RES, RES0, RMAT, RMAT0, UK0
!     REAL(KIND=WP) :: A, ADI, ALPHAK, B, DFACSQ, DST, DTOL, D1, D2,
!    1                 LK, OLDPHI, PHI, PHIMAX, PHIMIN, PSIFAC, RAD,
!    2                 SI, SJ, SQRTAK, T, TWOPSI, UK, WL
!
!     ***  CONSTANTS  ***
!     REAL(KIND=WP) :: DFAC, EIGHT, HALF, NEGONE, ONE, P001, THREE,
!    1                 TTOL, ZERO
!
!/
!  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***
!
!     EXTERNAL DOTPRD, LITVMU, LIVMUL, VCOPY, V2NORM
!     REAL(KIND=WP) :: DOTPRD, V2NORM
!
!  ***  SUBSCRIPTS FOR V  ***
!
!     INTEGER DGNORM, DSTNRM, DST0, EPSLON, GTSTEP, NREDUC, PHMNFC,
!    1        PHMXFC, PREDUC, RADIUS, RAD0, STPPAR
      data dgnorm/1/, dstnrm/2/, dst0/3/, epslon/19/,
     +     gtstep/4/, nreduc/6/, phmnfc/20/,
     +     phmxfc/21/, preduc/7/, radius/8/,
     +     rad0/9/, stppar/5/
!
      data dfac/256.0_wp/, eight/8.0_wp/, half/0.5_wp/, negone/-1.0_wp/,
     +     one/1.0_wp/, p001/1.0e-3_wp/, three/3.0_wp/, ttol/2.5_wp/,
     +     zero/0.0_wp/
!
!  ***  BODY  ***
!
!     ***  FOR USE IN RECOMPUTING STEP, THE FINAL VALUES OF LK AND UK,
!     ***  THE INVERSE DERIVATIVE OF MORE*S PHI AT 0 (FOR NONSING. J)
!     ***  AND THE VALUE RETURNED AS V(DSTNRM) ARE STORED AT W(LK0),
!     ***  W(UK0), W(PHIPIN), AND W(DSTSAV) RESPECTIVELY.
      alphak = 0.0_wp
      psifac = 0.0_wp
      lk0 = p + 1
      phipin = lk0 + 1
      uk0 = phipin + 1
      dstsav = uk0 + 1
      rmat0 = dstsav
!     ***  A COPY OF THE R-MATRIX FROM THE QR DECOMPOSITION OF J IS
!     ***  STORED IN W STARTING AT W(RMAT), AND A COPY OF THE RESIDUAL
!     ***  VECTOR IS STORED IN W STARTING AT W(RES).  THE LOOPS BELOW
!     ***  THAT UPDATE THE QR DECOMP. FOR A NONZERO MARQUARDT PARAMETER
!     ***  WORK ON THESE COPIES.
      rmat = rmat0 + 1
      pp1o2 = p * (p + 1) / 2
      res0 = pp1o2 + rmat0
      res = res0 + 1
      rad = v(radius)
      if (rad .gt. zero)
     +   psifac = v(epslon)/((eight*(v(phmnfc) + one) + three) * rad**2)
      phimax = v(phmxfc) * rad
      phimin = v(phmnfc) * rad
!     ***  DTOL, DFAC, AND DFACSQ ARE USED IN RESCALING THE FAST GIVENS
!     ***  REPRESENTATION OF THE UPDATED QR DECOMPOSITION.
      dtol = one/dfac
      dfacsq = dfac*dfac
!     ***  OLDPHI IS USED TO DETECT LIMITS OF NUMERICAL ACCURACY.  IF
!     ***  WE RECOMPUTE STEP AND IT DOES NOT CHANGE, THEN WE ACCEPT IT.
      oldphi = zero
      lk = zero
      uk = zero
      kalim = ka + 12
!
!  ***  START OR RESTART, DEPENDING ON KA  ***
!
      if (ka) 10, 20, 370
!
!  ***  FRESH START -- COMPUTE V(NREDUC)  ***
!
 10   ka = 0
      kalim = 12
      k = p
      if (ierr .ne. 0) k = abs(ierr) - 1
      v(nreduc) = half*dotprd(k, qtr, qtr)
!
!  ***  SET UP TO TRY INITIAL GAUSS-NEWTON STEP  ***
!
 20   v(dst0) = negone
      if (ierr .ne. 0) go to 90
!
!  ***  COMPUTE GAUSS-NEWTON STEP  ***
!
!     ***  NOTE -- THE R-MATRIX IS STORED COMPACTLY BY COLUMNS IN
!     ***  R(1), R(2), R(3), ...  IT IS THE TRANSPOSE OF A
!     ***  LOWER TRIANGULAR MATRIX STORED COMPACTLY BY ROWS, AND WE
!     ***  TREAT IT AS SUCH WHEN USING LITVMU AND LIVMUL.
      call litvmu(p, w, r, qtr)
!     ***  TEMPORARILY STORE PERMUTED -D*STEP IN STEP.
      do 60 i = 1, p
         j1 = ipivot(i)
         step(i) = d(j1)*w(i)
 60      continue
      dst = v2norm(p, step)
      v(dst0) = dst
      phi = dst - rad
      if (phi .le. phimax) go to 410
!     ***  IF THIS IS A RESTART, GO TO 110  ***
      if (ka .gt. 0) go to 110
!
!  ***  GAUSS-NEWTON STEP WAS UNACCEPTABLE.  COMPUTE L0  ***
!
      do 70 i = 1, p
         j1 = ipivot(i)
         step(i) = d(j1)*(step(i)/dst)
 70      continue
      call livmul(p, step, r, step)
      t = one / v2norm(p, step)
      w(phipin) = (t/dst)*t
      lk = phi*w(phipin)
!
!  ***  COMPUTE U0  ***
!
 90   do 100 i = 1, p
 100     w(i) = g(i)/d(i)
      v(dgnorm) = v2norm(p, w)
      uk = v(dgnorm)/rad
      if (uk .le. zero) go to 390
!
!     ***  ALPHAK WILL BE USED AS THE CURRENT MARQUARDT PARAMETER.  WE
!     ***  USE MORE*S SCHEME FOR INITIALIZING IT.
      alphak = abs(v(stppar)) * v(rad0)/rad
!
!
!  ***  TOP OF LOOP -- INCREMENT KA, COPY R TO RMAT, QTR TO RES  ***
!
 110  ka = ka + 1
      call vcopy(pp1o2, w(rmat), r)
      call vcopy(p, w(res), qtr)
!
!  ***  SAFEGUARD ALPHAK AND INITIALIZE FAST GIVENS SCALE VECTOR.  ***
!
      if (alphak .le. zero .or. alphak .lt. lk .or. alphak .ge. uk)
     +             alphak = uk * max(p001, sqrt(lk/uk))
      sqrtak = sqrt(alphak)
      do 120 i = 1, p
 120     w(i) = one
!
!  ***  ADD ALPHAK*D AND UPDATE QR DECOMP. USING FAST GIVENS TRANS.  ***
!
      do 270 i = 1, p
!        ***  GENERATE, APPLY 1ST GIVENS TRANS. FOR ROW I OF ALPHAK*D.
!        ***  (USE STEP TO STORE TEMPORARY ROW)  ***
         l = i*(i+1)/2 + rmat0
         wl = w(l)
         d2 = one
         d1 = w(i)
         j1 = ipivot(i)
         adi = sqrtak*d(j1)
         if (adi .ge. abs(wl)) go to 150
 130     a = adi/wl
         b = d2*a/d1
         t = a*b + one
         if (t .gt. ttol) go to 150
         w(i) = d1/t
         d2 = d2/t
         w(l) = t*wl
         a = -a
         do 140 j1 = i, p
              l = l + j1
              step(j1) = a*w(l)
 140          continue
         go to 170
!
 150     b = wl/adi
         a = d1*b/d2
         t = a*b + one
         if (t .gt. ttol) go to 130
         w(i) = d2/t
         d2 = d1/t
         w(l) = t*adi
         do 160 j1 = i, p
              l = l + j1
              wl = w(l)
              step(j1) = -wl
              w(l) = a*wl
 160          continue
!
 170     if (i .eq. p) go to 280
!
!        ***  NOW USE GIVENS TRANS. TO ZERO ELEMENTS OF TEMP. ROW  ***
!
         ip1 = i + 1
         do 260 i1 = ip1, p
              l = i1*(i1+1)/2 + rmat0
              wl = w(l)
              si = step(i1-1)
              d1 = w(i1)
!
!             ***  RESCALE ROW I1 IF NECESSARY  ***
!
              if (d1 .ge. dtol) go to 190
                   d1 = d1*dfacsq
                   wl = wl/dfac
                   k = l
                   do 180 j1 = i1, p
                        k = k + j1
                        w(k) = w(k)/dfac
 180                    continue
!
!             ***  USE GIVENS TRANS. TO ZERO NEXT ELEMENT OF TEMP. ROW
!
 190          if (abs(si) .gt. abs(wl)) go to 220
              if (si .eq. zero) go to 260
 200          a = si/wl
              b = d2*a/d1
              t = a*b + one
              if (t .gt. ttol) go to 220
              w(l) = t*wl
              w(i1) = d1/t
              d2 = d2/t
              do 210 j1 = i1, p
                   l = l + j1
                   wl = w(l)
                   sj = step(j1)
                   w(l) = wl + b*sj
                   step(j1) = sj - a*wl
 210               continue
              go to 240
!
 220          b = wl/si
              a = d1*b/d2
              t = a*b + one
              if (t .gt. ttol) go to 200
              w(i1) = d2/t
              d2 = d1/t
              w(l) = t*si
              do 230 j1 = i1, p
                   l = l + j1
                   wl = w(l)
                   sj = step(j1)
                   w(l) = a*wl + sj
                   step(j1) = b*sj - wl
 230               continue
!
!             ***  RESCALE TEMP. ROW IF NECESSARY  ***
!
 240          if (d2 .ge. dtol) go to 260
                   d2 = d2*dfacsq
                   do 250 k = i1, p
 250                    step(k) = step(k)/dfac
 260          continue
 270     continue
!
!  ***  COMPUTE STEP  ***
!
 280  call litvmu(p, w(res), w(rmat), w(res))
!     ***  RECOVER STEP AND STORE PERMUTED -D*STEP AT W(RES)  ***
      do 290 i = 1, p
         j1 = ipivot(i)
         k = res0 + i
         t = w(k)
         step(j1) = -t
         w(k) = t*d(j1)
 290     continue
      dst = v2norm(p, w(res))
      phi = dst - rad
      if (phi .le. phimax .and. phi .ge. phimin) go to 430
      if (oldphi .eq. phi) go to 430
      oldphi = phi
!
!  ***  CHECK FOR (AND HANDLE) SPECIAL CASE  ***
!
      if (phi .gt. zero) go to 310
         if (ka .ge. kalim) go to 430
              twopsi = alphak*dst*dst - dotprd(p, step, g)
              if (alphak .ge. twopsi*psifac) go to 310
                   v(stppar) = -alphak
                   go to 440
!
!  ***  UNACCEPTABLE STEP -- UPDATE LK, UK, ALPHAK, AND TRY AGAIN  ***
!
 300  if (phi .lt. zero) uk = min(uk, alphak)
      go to 320
 310  if (phi .lt. zero) uk = alphak
 320  do 330 i = 1, p
         j1 = ipivot(i)
         k = res0 + i
         step(i) = d(j1) * (w(k)/dst)
 330     continue
      call livmul(p, step, w(rmat), step)
      do 340 i = 1, p
 340     step(i) = step(i) / sqrt(w(i))
      t = one / v2norm(p, step)
      alphak = alphak + t*phi*t/rad
      lk = max(lk, alphak)
      go to 110
!
!  ***  RESTART  ***
!
 370  lk = w(lk0)
      uk = w(uk0)
      if (v(dst0) .gt. zero .and. v(dst0) - rad .le. phimax) go to 20
      alphak = abs(v(stppar))
      dst = w(dstsav)
      phi = dst - rad
      t = v(dgnorm)/rad
      if (rad .gt. v(rad0)) go to 380
!
!        ***  SMALLER RADIUS  ***
         uk = t
         if (alphak .le. zero) lk = zero
         if (v(dst0) .gt. zero) lk = max(lk, (v(dst0)-rad)*w(phipin))
         go to 300
!
!     ***  BIGGER RADIUS  ***
 380  if (alphak .le. zero .or. uk .gt. t) uk = t
      lk = zero
      if (v(dst0) .gt. zero) lk = max(lk, (v(dst0)-rad)*w(phipin))
      go to 300
!
!  ***  SPECIAL CASE -- RAD .LE. 0 OR (G = 0 AND J IS SINGULAR)  ***
!
 390  v(stppar) = zero
      dst = zero
      lk = zero
      uk = zero
      v(gtstep) = zero
      v(preduc) = zero
      do 400 i = 1, p
 400     step(i) = zero
      go to 450
!
!  ***  ACCEPTABLE GAUSS-NEWTON STEP -- RECOVER STEP FROM W  ***
!
 410  alphak = zero
      do 420 i = 1, p
         j1 = ipivot(i)
         step(j1) = -w(i)
 420     continue
!
!  ***  SAVE VALUES FOR USE IN A POSSIBLE RESTART  ***
!
 430  v(stppar) = alphak
 440  v(gtstep) = dotprd(p, step, g)
      v(preduc) = half * (alphak*dst*dst - v(gtstep))
 450  v(dstnrm) = dst
      w(dstsav) = dst
      w(lk0) = lk
      w(uk0) = uk
      v(rad0) = rad
!
      end subroutine lmstep
!QRFACT
      subroutine qrfact(nm,m,n,qr,alpha,ipivot,ierr,nopivk,sum)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  COMPUTE THE QR DECOMPOSITION OF THE MATRIX STORED IN QR  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   ierr,m,n,nm,nopivk
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   alpha(n),qr(nm,n),sum(n)
      integer
     +   ipivot(n)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   alphak,beta,one,p01,p99,qrkk,qrkmax,rktol,rktol1,sigma,sumj,
     +   temp,ufeta,zero
      integer
     +   i,j,jbar,k,k1,minum,mk1
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
      real(kind=wp) ::
     +   dotprd,v2norm
      external dotprd,v2norm
!
!  EXTERNAL SUBROUTINES
      external vaxpy,vscopy
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,min,sqrt
!
!     *****PARAMETERS.
!     INTEGER NM,M,N,IPIVOT(N),IERR,NOPIVK
!     REAL(KIND=WP) :: QR(NM,N),ALPHA(N),SUM(N)
!     *****LOCAL VARIABLES.
!     INTEGER I,J,JBAR,K,K1,MINUM,MK1
!     REAL(KIND=WP) :: ALPHAK,BETA,QRKK,QRKMAX,SIGMA,TEMP,UFETA,RKTOL,
!    1        RKTOL1,SUMJ
!     *****FUNCTIONS.
!/+
!     INTEGER MIN
!     REAL(KIND=WP) ::             ABS,SQRT
!/
!     EXTERNAL DOTPRD, VAXPY, VSCOPY, V2NORM
!     REAL(KIND=WP) :: DOTPRD, V2NORM
! DOTPRD... RETURNS INNER PRODUCT OF TWO VECTORS.
! RMDCON... RETURNS MACHINE-DEPENDENT CONSTANTS.
! VAXPY... COMPUTES SCALAR TIMES ONE VECTOR PLUS ANOTHER.
! VSCOPY... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.
! V2NORM... RETURNS THE 2-NORM OF A VECTOR.
!
!     *****CONSTANTS.
!     REAL(KIND=WP) :: ONE, P01, P99, ZERO
      data one/1.0_wp/, p01/0.01_wp/, p99/0.99_wp/, zero/0.0_wp/
!
!
!     ==================================================================
!
!
!     *****PURPOSE.
!
!     THIS SUBROUTINE DOES A QR-DECOMPOSITION ON THE M X N MATRIX QR,
!        WITH AN OPTIONALLY MODIFIED COLUMN PIVOTING, AND RETURNS THE
!        UPPER TRIANGULAR R-MATRIX, AS WELL AS THE ORTHOGONAL VECTORS
!        USED IN THE TRANSFORMATIONS.
!
!     *****PARAMETER DESCRIPTION.
!     ON INPUT.
!
!        NM MUST BE SET TO THE ROW DIMENSION OF THE TWO DIMENSIONAL
!             ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
!             DIMENSION STATEMENT.
!
!        M MUST BE SET TO THE NUMBER OF ROWS IN THE MATRIX.
!
!        N MUST BE SET TO THE NUMBER OF COLUMNS IN THE MATRIX.
!
!        QR CONTAINS THE REAL RECTANGULAR MATRIX TO BE DECOMPOSED.
!
!     NOPIVK IS USED TO CONTROL PIVOTTING.  COLUMNS 1 THROUGH
!        NOPIVK WILL REMAIN FIXED IN POSITION.
!
!        SUM IS USED FOR TEMPORARY STORAGE FOR THE SUBROUTINE.
!
!     ON OUTPUT.
!
!        QR CONTAINS THE NON-DIAGONAL ELEMENTS OF THE R-MATRIX
!             IN THE STRICT UPPER TRIANGLE. THE VECTORS U, WHICH
!             DEFINE THE HOUSEHOLDER TRANSFORMATIONS   I - U*U-TRANSP,
!             ARE IN THE COLUMNS OF THE LOWER TRIANGLE. THESE VECTORS U
!             ARE SCALED SO THAT THE SQUARE OF THEIR 2-NORM IS 2.0.
!
!        ALPHA CONTAINS THE DIAGONAL ELEMENTS OF THE R-MATRIX.
!
!        IPIVOT REFLECTS THE COLUMN PIVOTING PERFORMED ON THE INPUT
!             MATRIX TO ACCOMPLISH THE DECOMPOSITION. THE J-TH
!             ELEMENT OF IPIVOT GIVES THE COLUMN OF THE ORIGINAL
!             MATRIX WHICH WAS PIVOTED INTO COLUMN J DURING THE
!             DECOMPOSITION.
!
!        IERR IS SET TO.
!             0 FOR NORMAL RETURN,
!             K IF NO NON-ZERO PIVOT COULD BE FOUND FOR THE K-TH
!                  TRANSFORMATION, OR
!             -K FOR AN ERROR EXIT ON THE K-TH THANSFORMATION.
!             IF AN ERROR EXIT WAS TAKEN, THE FIRST (K - 1)
!             TRANSFORMATIONS ARE CORRECT.
!
!
!     *****APPLICATIONS AND USAGE RESTRICTIONS.
!     THIS MAY BE USED WHEN SOLVING LINEAR LEAST-SQUARES PROBLEMS --
!     SEE SUBROUTINE QR1 OF ROSEPACK.  IT IS CALLED FOR THIS PURPOSE
!     BY LLSQST IN THE NL2SOL (NONLINEAR LEAST-SQUARES) PACKAGE.
!
!     *****ALGORITHM NOTES.
!     THIS VERSION OF QRFACT TRIES TO ELIMINATE THE OCCURRENCE OF
!     UNDERFLOWS DURING THE ACCUMULATION OF INNER PRODUCTS.  RKTOL1
!     IS CHOSEN BELOW SO AS TO INSURE THAT DISCARDED TERMS HAVE NO
!     EFFECT ON THE COMPUTED TWO-NORMS.
!
!     ADAPTED FROM THE ALGOL ROUTINE SOLVE (1).
!
!     *****REFERENCES.
!     (1)     BUSINGER,P. AND GOLUB,G.H., LINEAR LEAST SQUARES
!     SOLUTIONS BY HOUSHOLDER TRANSFORMATIONS, IN WILKINSON,J.H.
!     AND REINSCH,C.(EDS.), HANDBOOK FOR AUTOMATIC COMPUTATION,
!     VOLUME II. LINEAR ALGEBRA, SPRINGER-VERLAG, 111-118 (1971).
!     PREPUBLISHED IN NUMER.MATH. 7, 269-276 (1965).
!
!     *****HISTORY.
!     THIS AMOUNTS TO THE SUBROUTINE QR1 OF ROSEPACK WITH RKTOL1 USED
!     IN PLACE OF RKTOL BELOW, WITH V2NORM USED TO INITIALIZE (AND
!     SOMETIMES UPDATE) THE SUM ARRAY, AND WITH CALLS ON DOTPRD AND
!     VAXPY IN PLACE OF SOME LOOPS.
!
!     *****GENERAL.
!
!     DEVELOPMENT OF THIS PROGRAM SUPPORTED IN PART BY
!     NATIONAL SCIENCE FOUNDATION GRANT GJ-1154X3 AND
!     NATIONAL SCIENCE FOUNDATION GRANT DCR75-08802
!     TO NATIONAL BUREAU OF ECONOMIC RESEARCH, INC.
!
!
!
!     =================================================================
!     =================================================================
!
!
!     ==========  UFETA IS THE SMALLEST POSITIVE FLOATING POINT NUMBER
!        S.T. UFETA AND -UFETA CAN BOTH BE REPRESENTED.
!
!     ==========  RKTOL IS THE SQUARE ROOT OF THE RELATIVE PRECISION
!        OF FLOATING POINT ARITHMETIC (MACHEP).
      data rktol/0.0_wp/, ufeta/0.0_wp/
!     *****BODY OF PROGRAM.
      if (ufeta .gt. zero) go to 10
         ufeta = rmdcon(1,typ=0.0_wp)
         rktol = rmdcon(4,typ=0.0_wp)
   10 ierr = 0
      rktol1 = p01 * rktol
!
      do 20 j=1,n
         sum(j) = v2norm(m, qr(1,j))
         ipivot(j) = j
   20 continue
!
      minum = min(m,n)
!
      do 120 k=1,minum
         mk1 = m - k + 1
!        ==========K-TH HOUSEHOLDER TRANSFORMATION==========
         sigma = zero
         jbar = 0
!        ==========FIND LARGEST COLUMN SUM==========
      if (k .le. nopivk) go to 50
         do 30 j=k,n
              if (sigma .ge. sum(j))  go to 30
              sigma = sum(j)
              jbar = j
   30    continue
!
         if (jbar .eq. 0)  go to 220
         if (jbar .eq. k)  go to 50
!        ==========COLUMN INTERCHANGE==========
         i = ipivot(k)
         ipivot(k) = ipivot(jbar)
         ipivot(jbar) = i
         sum(jbar) = sum(k)
         sum(k) = sigma
!
         do 40 i=1,m
              sigma = qr(i,k)
              qr(i,k) = qr(i,jbar)
              qr(i,jbar) = sigma
   40    continue
!        ==========END OF COLUMN INTERCHANGE==========
   50    continue
!        ==========  SECOND INNER PRODUCT  ==========
         qrkmax = zero
!
         do 60 i=k,m
              if (abs( qr(i,k) ) .gt. qrkmax)  qrkmax = abs( qr(i,k) )
   60    continue
!
         if (qrkmax .lt. ufeta)  go to 210
         alphak = v2norm(mk1, qr(k,k)) / qrkmax
         sigma = alphak**2
!
!        ==========  END SECOND INNER PRODUCT  ==========
         qrkk = qr(k,k)
         if (qrkk .ge. zero)  alphak = -alphak
         alpha(k) = alphak * qrkmax
         beta = qrkmax * sqrt(sigma - (qrkk*alphak/qrkmax) )
         qr(k,k) = qrkk - alpha(k)
         do 65 i=k,m
   65         qr(i,k) =  qr(i,k) / beta
         k1 = k + 1
         if (k1 .gt. n) go to 120
!
         do 110 j = k1, n
              temp = -dotprd(mk1, qr(k,k), qr(k,j))
!
!             ***  SET QR(I,J) = QR(I,J) + TEMP*QR(I,K), I = K,...,M.
!
              call vaxpy(mk1, qr(k,j), temp, qr(k,k), qr(k,j))
!
              if (k1 .gt. m) go to 110
              sumj = sum(j)
              if (sumj .lt. ufeta) go to 110
              temp = abs(qr(k,j)/sumj)
              if (temp .lt. rktol1) go to 110
              if (temp .ge. p99) go to 90
                   sum(j) = sumj * sqrt(one - temp**2)
                   go to 110
   90         sum(j) = v2norm(m-k, qr(k1,j))
  110    continue
!        ==========END OF K-TH HOUSEHOLDER TRANSFORMATION==========
  120 continue
!
      go to 999
!     ==========ERROR EXIT ON K-TH TRANSFORMATION==========
  210 ierr = -k
      go to 230
!     ==========NO NON-ZERO ACCEPTABLE PIVOT FOUND==========
  220 ierr = k
  230 do 240 i = k, n
         alpha(i) = zero
         if (i .gt. k) call vscopy(i-k, qr(k,i), zero)
 240     continue
!     ==========RETURN TO CALLER==========
  999 return

      end subroutine qrfact
!NL2SNO
      subroutine nl2sno(n, p, x, calcr, iv, v, uiparm, urparm, ufparm)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  LIKE NL2SOL, BUT WITHOUT CALCJ -- MINIMIZE NONLINEAR SUM OF  ***
!  ***  SQUARES USING FINITE-DIFFERENCE JACOBIAN APPROXIMATIONS      ***
!  ***  (NL2SOL VERSION 2.2)  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   n,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   urparm(1),v(1),x(p)
      integer
     +   iv(1),uiparm(1)
!
!  SUBROUTINE ARGUMENTS
      external calcr,ufparm
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   h,hfac,hlim,negpt5,one,xk,zero
      integer
     +   covprt,covreq,d,d1,dk,dltfdj,dtype,i,j,j1,j1k,k,nf,nfcall,
     +   nfgcal,r,r1,rn,toobig
      logical
     +   strted
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!
!  EXTERNAL SUBROUTINES
      external dfault,itsmry,nl2itr,vscopy
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max
!
!     INTEGER N, P, IV(1), UIPARM(1)
!     REAL(KIND=WP) :: X(P), V(1), URPARM(1)
!     DIMENSION IV(60+P),  V(93 + N*P + 3*N + P*(3*P+33)/2)
!     EXTERNAL CALCR, UFPARM
!
!-----------------------------  DISCUSSION  ----------------------------
!
!        THE PARAMETERS FOR NL2SNO ARE THE SAME AS THOSE FOR NL2SOL
!     (WHICH SEE), EXCEPT THAT CALCJ IS OMITTED.  INSTEAD OF CALLING
!     CALCJ TO OBTAIN THE JACOBIAN MATRIX OF R AT X, NL2SNO COMPUTES
!     AN APPROXIMATION TO IT BY FINITE (FORWARD) DIFFERENCES -- SEE
!     V(DLTFDJ) BELOW.  NL2SNO USES FUNCTION VALUES ONLY WHEN COMPUT-
!     THE COVARIANCE MATRIX (RATHER THAN THE FUNCTIONS AND GRADIENTS
!     THAT NL2SOL MAY USE).  TO DO SO, NL2SNO SETS IV(COVREQ) TO -1 IF
!     IV(COVPRT) = 1 WITH IV(COVREQ) = 0 AND TO MINUS ITS ABSOLUTE
!     VALUE OTHERWISE.  THUS V(DELTA0) IS NEVER REFERENCED AND ONLY
!     V(DLTFDC) MATTERS -- SEE NL2SOL FOR A DESCRIPTION OF V(DLTFDC).
!        THE NUMBER OF EXTRA CALLS ON CALCR USED IN COMPUTING THE JACO-
!     BIAN APPROXIMATION ARE NOT INCLUDED IN THE FUNCTION EVALUATION
!     COUNT IV(NFCALL) AND ARE NOT OTHERWISE REPORTED.
!
! V(DLTFDJ)... V(36) HELPS CHOOSE THE STEP SIZE USED WHEN COMPUTING THE
!             FINITE-DIFFERENCE JACOBIAN MATRIX.  FOR DIFFERENCES IN-
!             VOLVING X(I), THE STEP SIZE FIRST TRIED IS
!                       V(DLTFDJ) * MAX(ABS(X(I)), 1/D(I)),
!             WHERE D IS THE CURRENT SCALE VECTOR (SEE REF. 1).  (IF
!             THIS STEP IS TOO BIG, I.E., IF CALCR SETS NF TO 0, THEN
!             SMALLER STEPS ARE TRIED UNTIL THE STEP SIZE IS SHRUNK BE-
!             LOW 1000 * MACHEP, WHERE MACHEP IS THE UNIT ROUNDOFF.
!             DEFAULT = MACHEP**0.5.
!
!  ***  REFERENCES  ***
!
! 1.  DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1980), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, SUBMITTED TO ACM TRANS.
!             MATH. SOFTWARE.
!
!  ***  GENERAL  ***
!
!     CODED BY DAVID M. GAY.
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!     MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989, AND
!     MCS-7906671.
!
!+++++++++++++++++++++++++++  DECLARATIONS  ++++++++++++++++++++++++++++
!
!/
!  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***
!
!     EXTERNAL DFAULT, ITSMRY, NL2ITR, VSCOPY
!
! DFAULT... SUPPLIES DEFAULT PARAMETER VALUES.
! ITSMRY... PRINTS ITERATION SUMMARY AND INFO ABOUT INITIAL AND FINAL X.
! NL2ITR... REVERSE-COMMUNICATION ROUTINE THAT CARRIES OUT NL2SOL ALGO-
!             RITHM.
! RMDCON... RETURNS MACHINE-DEPENDENT CONSTANTS.
! VSCOPY... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.
!
!     LOGICAL STRTED
!     INTEGER DK, D1, I, J1, J1K, K, NF, RN, R1
!     REAL(KIND=WP) :: H, HFAC, HLIM, NEGPT5, ONE, XK, ZERO
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER COVPRT, COVREQ, D, DLTFDJ, DTYPE, J, NFCALL, NFGCAL, R,
!    1        TOOBIG
!
      data hfac/1.0e3_wp/, hlim/0.0_wp/, negpt5/-0.5_wp/,
     +     one/1.0_wp/, zero/0.0_wp/
!
!  ***  IV SUBSCRIPT VALUES  ***
!
      data covprt/14/, covreq/15/, d/27/, dtype/16/, j/33/,
     +     nfcall/6/, nfgcal/7/, r/50/, toobig/2/
!
!  ***  V SUBSCRIPT VALUES  ***
!
      data dltfdj/36/
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
      d1 = 94 + 2*n + p*(3*p + 31)/2
      iv(d) = d1
      r1 = d1 + p
      iv(r) = r1
      j1 = r1 + n
      iv(j) = j1
      rn = j1 - 1
      if (iv(1) .eq. 0) call dfault(iv, v)
      iv(covreq) = -abs(iv(covreq))
      if (iv(covprt) .ne. 0 .and. iv(covreq) .eq. 0) iv(covreq) = -1
      strted = .true.
      if (iv(1) .ne. 12) go to 80
         strted = .false.
         iv(nfcall) = 1
         iv(nfgcal) = 1
!        ***  INITIALIZE SCALE VECTOR D TO ONES FOR COMPUTING
!        ***  INITIAL JACOBIAN.
         if (iv(dtype) .gt. 0) call vscopy(p, v(d1), one)
!
 10   nf = iv(nfcall)
      call calcr(n, p, x, nf, v(r1), uiparm, urparm, ufparm)
      if (strted) go to 20
         if (nf .gt. 0) go to 30
              iv(1) = 13
              go to 90
!
 20   if (nf .le. 0) iv(toobig) = 1
      go to 80
!
!  ***  COMPUTE FINITE-DIFFERENCE JACOBIAN  ***
!
 30   j1k = j1
      dk = d1
      do 70 k = 1, p
         xk = x(k)
         h = v(dltfdj) * max(abs(xk), one/v(dk))
         dk = dk + 1
 40      x(k) = xk + h
         nf = iv(nfgcal)
         call calcr (n, p, x, nf, v(j1k), uiparm, urparm, ufparm)
         if (nf .gt. 0) go to 50
              if (hlim .eq. zero) hlim = hfac * rmdcon(3,typ=0.0_wp)
!             ***  HLIM = HFAC TIMES THE UNIT ROUNDOFF  ***
              h = negpt5 * h
              if (abs(h) .ge. hlim) go to 40
                   iv(1) = 15
                   go to 90
 50      x(k) = xk
         do 60 i = r1, rn
              v(j1k) = (v(j1k) - v(i)) / h
              j1k = j1k + 1
 60           continue
 70      continue
!
      strted = .true.
!
 80   call nl2itr(v(d1), iv, v(j1), n, n, p, v(r1), v, x)
      if (iv(1) - 2) 10, 30, 999
!
 90   call itsmry(v(d1), iv, p, v, x)
!
 999  return

      end subroutine nl2sno
!MADR
      subroutine madr(n, p, x, nf, r, uiparm, urparm, ufparm)
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   n,nf,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   r(n),urparm(*),x(p)
      integer
     +   uiparm(*)
!
!  SUBROUTINE ARGUMENTS
      external ufparm
!
!  INTRINSIC FUNCTIONS
      intrinsic cos,sin
!
      r(1) = x(1)**2 + x(2)**2 + x(1)*x(2)
      r(2) = sin(x(1))
      r(3) = cos(x(2))

      end subroutine madr
!V2NORM
      real(kind=wp) function v2norm(p, x)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  RETURN THE 2-NORM OF THE P-VECTOR X, TAKING  ***
!  ***  CARE TO AVOID THE MOST LIKELY UNDERFLOWS.    ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   x(*)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   one,r,scale,sqteta,t,xi,zero
      integer
     +   i,j
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,sqrt
!
!
      data one/1.0_wp/, sqteta/0.0_wp/, zero/0.0_wp/
!
      if (p .gt. 0) go to 10
         v2norm = zero
         go to 999
 10   do 20 i = 1, p
         if (x(i) .ne. zero) go to 30
 20      continue
      v2norm = zero
      go to 999
!
 30   scale = abs(x(i))
      if (i .lt. p) go to 40
         v2norm = scale
         go to 999
 40   t = one
      if (sqteta .eq. zero) sqteta = rmdcon(2,typ=0.0_wp)
!
!     ***  SQTETA IS (SLIGHTLY LARGER THAN) THE SQUARE ROOT OF THE
!     ***  SMALLEST POSITIVE FLOATING POINT NUMBER ON THE MACHINE.
!     ***  THE TESTS INVOLVING SQTETA ARE DONE TO PREVENT UNDERFLOWS.
!
      j = i + 1
      do 60 i = j, p
         xi = abs(x(i))
         if (xi .gt. scale) go to 50
              r = xi / scale
              if (r .gt. sqteta) t = t + r*r
              go to 60
 50           r = scale / xi
              if (r .le. sqteta) r = zero
              t = one  +  t * r*r
         scale = xi
 60      continue
!
      v2norm = scale * sqrt(t)
 999  return

      end function v2norm
!ITSMRY
      subroutine itsmry(d, iv, p, v, x)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  PRINT NL2SOL (VERSION 2.2) ITERATION SUMMARY  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   d(p),v(*),x(p)
      integer
     +   iv(*)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   nreldf,oldf,preldf,reldf,zero
      integer
     +   cov1,covmat,covprt,covreq,dstnrm,f,f0,fdif,g,g1,i,i1,ich,
     +   ii,iv1,j,m,needhd,nf,nfcall,nfcov,ng,ngcall,ngcov,niter,
     +   nreduc,ol,outlev,preduc,prntit,prunit,pu,reldx,size,
     +   solprt,statpr,stppar,sused,x0prt
!
!  LOCAL ARRAYS
      character
     +   model1(3,6)*1,model2(4,6)*1
!
!  INTRINSIC FUNCTIONS
      intrinsic abs
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER IV(1), P
!     REAL(KIND=WP) :: D(P), V(1), X(P)
!     DIMENSION IV(*), V(*)
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER COV1, G1, I, II, IV1, I1, J, M, NF, NG, OL, PU
!     CHARACTER*1 MODEL1(3, 6), MODEL2(4, 6)
!     REAL(KIND=WP) :: NRELDF, OLDF, PRELDF, RELDF, ZERO
!
!/
!  ***  NO EXTERNAL FUNCTIONS OR SUBROUTINES  ***
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER COVMAT, COVPRT, COVREQ, DSTNRM, F, FDIF, F0, G,
!    1        NEEDHD, NFCALL, NFCOV, NGCOV, NGCALL, NITER, NREDUC,
!    2        OUTLEV, PREDUC, PRNTIT, PRUNIT, RELDX, SIZE, SOLPRT,
!    3        STATPR, STPPAR, SUSED, X0PRT
!
!  ***  IV SUBSCRIPT VALUES  ***
!
      data covmat/26/, covprt/14/, g/28/, covreq/15/,
     +     needhd/39/, nfcall/6/, nfcov/40/, ngcov/41/,
     +     ngcall/30/, niter/31/, outlev/19/, prntit/48/,
     +     prunit/21/, solprt/22/, statpr/23/, sused/57/,
     +     x0prt/24/
!
!  ***  V SUBSCRIPT VALUES  ***
!
      data dstnrm/2/, f/10/, f0/13/, fdif/11/, nreduc/6/,
     +     preduc/7/, reldx/17/, size/47/, stppar/5/
!
      data model1(1, 1), model1(2, 1), model1(3, 1)
     +   /        ' ',          ' ',          ' '  /
      data model1(1, 2), model1(2, 2), model1(3, 2)
     +   /        ' ',          ' ',          ' '  /
      data model1(1, 3), model1(2, 3), model1(3, 3)
     +   /        ' ',          ' ',          ' '  /
      data model1(1, 4), model1(2, 4), model1(3, 4)
     +   /        ' ',          ' ',          ' '  /
      data model1(1, 5), model1(2, 5), model1(3, 5)
     +   /        ' ',          'G',          ' '  /
      data model1(1, 6), model1(2, 6), model1(3, 6)
     +   /        ' ',          'S',          ' '  /
      data model2(1, 1), model2(2, 1), model2(3, 1), model2(4, 1)
     +    /       ' ',          'G',          ' ',          ' '  /
      data model2(1, 2), model2(2, 2), model2(3, 2), model2(4, 2)
     +   /        ' ',          'S',          ' ',          ' '  /
      data model2(1, 3), model2(2, 3), model2(3, 3), model2(4, 3)
     +   /        'G',          '-',          'S',          ' '  /
      data model2(1, 4), model2(2, 4), model2(3, 4), model2(4, 4)
     +   /        'S',          '-',          'G',          ' '  /
      data model2(1, 5), model2(2, 5), model2(3, 5), model2(4, 5)
     +   /        '-',          'S',          '-',          'G'  /
      data model2(1, 6), model2(2, 6), model2(3, 6), model2(4, 6)
     +   /        '-',          'G',          '-',          'S'  /
      data zero/0.0_wp/
!
!-----------------------------------------------------------------------
!
      pu = iv(prunit)
      if (pu .eq. 0) go to 999
      iv1 = iv(1)
      ol = iv(outlev)
      if (iv1 .lt. 2 .or. iv1 .gt. 15) go to 140
      if (ol .eq. 0) go to 20
      if (iv1 .ge. 12) go to 20
      if (iv1 .ge. 10 .and. iv(prntit) .eq. 0) go to 20
      if (iv1 .gt. 2) go to 10
         iv(prntit) = iv(prntit) + 1
         if (iv(prntit) .lt. abs(ol)) go to 999
 10   nf = iv(nfcall) - abs(iv(nfcov))
      iv(prntit) = 0
      reldf = zero
      preldf = zero
      oldf = v(f0)
      if (oldf .le. zero) go to 12
         reldf = v(fdif) / oldf
         preldf = v(preduc) / oldf
 12   if (ol .gt. 0) go to 15
!
!        ***  PRINT SHORT SUMMARY LINE  ***
!
         if (iv(needhd) .eq. 1) write(pu, 1010)
 1010 format(12h0   it    nf,6x,'F',8x,5hreldf,6x,6hpreldf,5x,5hreldx)
         iv(needhd) = 0
         write(pu,1017) iv(niter), nf, v(f), reldf, preldf, v(reldx)
         go to 20
!
!     ***  PRINT LONG SUMMARY LINE  ***
!
 15   if (iv(needhd) .eq. 1) write(pu,1015)
 1015 format(12h0   it    nf,6x,'F',8x,5hreldf,6x,6hpreldf,5x,5hreldx,
     +       4x,15hmodel    stppar,6x,4hsize,6x,6hd*step,5x,7hnpreldf)
      iv(needhd) = 0
      m = iv(sused)
      nreldf = zero
      if (oldf .gt. zero) nreldf = v(nreduc) / oldf
      write(pu,1017) iv(niter), nf, v(f), reldf, preldf, v(reldx),
     +               (model1(ich, m), ich = 1, 3),
     +               (model2(ich, m), ich = 1, 4),
     +               v(stppar), v(size), v(dstnrm), nreldf
 1017 format(1x,i5,i6,4e11.3,7a1,4e11.3)
!
 20   go to (999,999,30,35,40,45,50,60,70,80,90,150,110,120,130), iv1
!
 30   write(pu,1030)
 1030 format(26h0***** x-convergence *****)
      go to 180
!
 35   write(pu,1035)
 1035 format(42h0***** relative function convergence *****)
      go to 180
!
 40   write(pu,1040)
 1040 format(49h0***** x- and relative function convergence *****)
      go to 180
!
 45   write(pu,1045)
 1045 format(42h0***** absolute function convergence *****)
      go to 180
!
 50   write(pu,1050)
 1050 format(33h0***** singular convergence *****)
      go to 180
!
 60   write(pu,1060)
 1060 format(30h0***** false convergence *****)
      go to 180
!
 70   write(pu,1070)
 1070 format(38h0***** function evaluation limit *****)
      go to 180
!
 80   write(pu,1080)
 1080 format(28h0***** iteration limit *****)
      go to 180
!
 90   write(pu,1090)
 1090 format(18h0***** stopx *****)
      go to 180
!
 110  write(pu,1100)
 1100 format(45h0***** initial sum of squares overflows *****)
!
      go to 150
!
 120  write(pu,1120)
 1120 format(37h0***** bad parameters to assess *****)
      go to 999
!
 130  write(pu,1130)
 1130 format(36h0***** j could not be computed *****)
      if (iv(niter) .gt. 0) go to 190
      go to 150
!
 140  write(pu,1140) iv1
 1140 format(14h0***** iv(1) =,i5,6h *****)
      go to 999
!
!  ***  INITIAL CALL ON ITSMRY  ***
!
 150  if (iv(x0prt) .ne. 0) write(pu,1150) (i, x(i), d(i), i = 1, p)
 1150 format(23h0    i     initial x(i),7x,4hd(i)//(1x,i5,e17.6,e14.3))
      if (iv1 .ge. 13) go to 999
      iv(needhd) = 0
      iv(prntit) = 0
      if (ol .eq. 0) go to 999
      if (ol .lt. 0) write(pu,1010)
      if (ol .gt. 0) write(pu,1015)
      write(pu,1160) v(f)
 1160 format(12h0    0     1,e11.3,11x,e11.3)
      go to 999
!
!  ***  PRINT VARIOUS INFORMATION REQUESTED ON SOLUTION  ***
!
 180  iv(needhd) = 1
      if (iv(statpr) .eq. 0) go to 190
         oldf = v(f0)
         preldf = zero
         nreldf = zero
         if (oldf .le. zero) go to 185
              preldf = v(preduc) / oldf
              nreldf = v(nreduc) / oldf
 185     nf = iv(nfcall) - iv(nfcov)
         ng = iv(ngcall) - iv(ngcov)
         write(pu,1180) v(f), v(reldx), nf, ng, preldf, nreldf
 1180 format(9h0function,e17.6,8h   reldx,e20.6/12h func. evals,
     +   i8,9x,'GRAD. EVALS',i8/' PRELDF',e19.6,3x,'NPRELDF',e18.6)
!
         if (iv(nfcov) .gt. 0) write(pu,1185) iv(nfcov)
 1185    format('0',i4,' EXTRA FUNC. EVALS FOR COVARIANCE.')
         if (iv(ngcov) .gt. 0) write(pu,1186) iv(ngcov)
 1186    format(1x,i4,' EXTRA GRAD. EVALS FOR COVARIANCE.')
!
 190  if (iv(solprt) .eq. 0) go to 210
         iv(needhd) = 1
         g1 = iv(g)
         write(pu,1190)
 1190 format('0    I      FINAL X(I)',8x,'D(I)',10x,'G(I)'/)
         do 200 i = 1, p
              write(pu,1200) i, x(i), d(i), v(g1)
              g1 = g1 + 1
 200          continue
 1200    format(1x,i5,e17.6,2e14.3)
!
 210  if (iv(covprt) .eq. 0) go to 999
      cov1 = iv(covmat)
      iv(needhd) = 1
      if (cov1) 220, 230, 240
 220  if (-1 .eq. cov1) write(pu,1220)
 1220 format(43h0++++++ indefinite covariance matrix ++++++)
      if (-2 .eq. cov1) write(pu,1225)
 1225 format(52h0++++++ oversize steps in computing covariance +++++)
      go to 999
!
 230  write(pu,1230)
 1230 format(45h0++++++ covariance matrix not computed ++++++)
      go to 999
!
 240  i = abs(iv(covreq))
      if (i .le. 1) write(pu,1241)
 1241 format(48h0covariance = scale * h**-1 * (j**t * j) * h**-1/)
      if (i .eq. 2) write(pu,1242)
 1242 format(27h0covariance = scale * h**-1/)
      if (i .ge. 3) write(pu,1243)
 1243 format(36h0covariance = scale * (j**t * j)**-1/)
      ii = cov1 - 1
      if (ol .le. 0) go to 260
      do 250 i = 1, p
         i1 = ii + 1
         ii = ii + i
         write(pu,1250) i, (v(j), j = i1, ii)
 250     continue
 1250 format(' ROW',i3,2x,9e12.4/(9x,9e12.4))
      go to 999
!
 260  do 270 i = 1, p
         i1 = ii + 1
         ii = ii + i
         write(pu,1270) i, (v(j), j = i1, ii)
 270     continue
 1270 format(' ROW',i3,2x,5e12.4/(9x,5e12.4))
!
 999  return
      end subroutine itsmry
!VCOPY
      subroutine vcopy(p, y, x)
!
!  ***  SET Y = X, WHERE X AND Y ARE P-VECTORS  ***
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer p
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: x(*),y(*)
!
!  LOCAL SCALARS
      integer i
!
!
      do i = 1, p
        y(i) = x(i)
      enddo

      end subroutine vcopy
!PARCHK
      subroutine parchk(iv, n, nn, p, v)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!  ***  CHECK NL2SOL (VERSION 2.2) PARAMETERS, PRINT CHANGED VALUES  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   n,nn,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   v(33)
      integer
     +   iv(21)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   big,machep,tiny,vk,zero
      integer
     +   d0init,dtype,dtype0,epslon,i,ich,inits,iv1,jtinit,jtol0,
     +   jtol1,jtolp,k,l,m,nvdflt,oldn,oldnn,oldp,parprt,parsv1,
     +   prunit,pu
!
!  LOCAL ARRAYS
      real(kind=wp) ::
     +   vm(27),vx(27)
      character
     +   cngd(12)*1,dflt(12)*1,vn(8,27)*1,which(12)*1
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!
!  EXTERNAL SUBROUTINES
      external dfault,vcopy
!
!     INTEGER IV(21), N, NN, P
!     REAL(KIND=WP) :: V(33)
!     DIMENSION IV(*), V(*)
!
!     EXTERNAL DFAULT, VCOPY
! DFAULT -- SUPPLIES DFAULT PARAMETER VALUES.
! RMDCON -- RETURNS MACHINE-DEPENDENT CONSTANTS.
! VCOPY  -- COPIES ONE VECTOR TO ANOTHER.
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER I, IV1, JTOLP, K, L, M, NVDFLT, PU
!     CHARACTER*1 CNGD(12), WHICH(12)
!     CHARACTER*1 DFLT(12), VN(8,27)
!     REAL(KIND=WP) :: BIG, MACHEP, TINY, VK, VM(27), VX(27), ZERO
!
!  ***  IV AND V SUBSCRIPTS  ***
!
!     INTEGER DTYPE, DTYPE0, D0INIT, EPSLON, INITS, JTINIT, JTOL0,
!    1        JTOL1, OLDN, OLDNN, OLDP, PARPRT, PARSV1, PRUNIT
!
      data big/0.0_wp/, nvdflt/27/, tiny/1.0_wp/, zero/0.0_wp/
!
      data dtype/16/, dtype0/29/, d0init/37/, epslon/19/,
     +     inits/25/, jtinit/39/, jtol0/86/, jtol1/87/,
     +     oldn/45/, oldnn/46/, oldp/47/, parprt/20/,
     +     parsv1/51/, prunit/21/
!
      data
     + vn(1,1),vn(2,1),vn(3,1),vn(4,1),vn(5,1),vn(6,1),vn(7,1),vn(8,1)
     +   /'E',    'P',    'S',    'L',    'O',    'N',    '.',    '.'/
      data
     + vn(1,2),vn(2,2),vn(3,2),vn(4,2),vn(5,2),vn(6,2),vn(7,2),vn(8,2)
     +   /'P',    'H',    'M',    'N',    'F',    'C',    '.',    '.'/
      data
     + vn(1,3),vn(2,3),vn(3,3),vn(4,3),vn(5,3),vn(6,3),vn(7,3),vn(8,3)
     +   /'P',    'H',    'M',    'X',    'F',    'C',    '.',    '.'/
      data
     + vn(1,4),vn(2,4),vn(3,4),vn(4,4),vn(5,4),vn(6,4),vn(7,4),vn(8,4)
     +   /'D',    'E',    'C',    'F',    'A',    'C',    '.',    '.'/
      data
     + vn(1,5),vn(2,5),vn(3,5),vn(4,5),vn(5,5),vn(6,5),vn(7,5),vn(8,5)
     +   /'I',    'N',    'C',    'F',    'A',    'C',    '.',    '.'/
      data
     + vn(1,6),vn(2,6),vn(3,6),vn(4,6),vn(5,6),vn(6,6),vn(7,6),vn(8,6)
     +   /'R',    'D',    'F',    'C',    'M',    'N',    '.',    '.'/
      data
     + vn(1,7),vn(2,7),vn(3,7),vn(4,7),vn(5,7),vn(6,7),vn(7,7),vn(8,7)
     +   /'R',    'D',    'F',    'C',    'M',    'X',    '.',    '.'/
      data
     + vn(1,8),vn(2,8),vn(3,8),vn(4,8),vn(5,8),vn(6,8),vn(7,8),vn(8,8)
     +   /'T',    'U',    'N',    'E',    'R',    '1',    '.',    '.'/
      data
     + vn(1,9),vn(2,9),vn(3,9),vn(4,9),vn(5,9),vn(6,9),vn(7,9),vn(8,9)
     +   /'T',    'U',    'N',    'E',    'R',    '2',    '.',    '.'/
      data
     + vn(1,10),vn(2,10),vn(3,10),vn(4,10),vn(5,10),vn(6,10),vn(7,10),
     + vn(8,10)
     +   /'T',    'U',    'N',    'E',    'R',    '3',    '.',    '.'/
      data
     + vn(1,11),vn(2,11),vn(3,11),vn(4,11),vn(5,11),vn(6,11),vn(7,11),
     + vn(8,11)
     +   /'T',    'U',    'N',    'E',    'R',    '4',    '.',    '.'/
      data
     + vn(1,12),vn(2,12),vn(3,12),vn(4,12),vn(5,12),vn(6,12),vn(7,12),
     + vn(8,12)
     +   /'T',    'U',    'N',    'E',    'R',    '5',    '.',    '.'/
      data
     + vn(1,13),vn(2,13),vn(3,13),vn(4,13),vn(5,13),vn(6,13),vn(7,13),
     + vn(8,13)
     +   /'A',    'F',    'C',    'T',    'O',    'L',    '.',    '.'/
      data
     + vn(1,14),vn(2,14),vn(3,14),vn(4,14),vn(5,14),vn(6,14),vn(7,14),
     + vn(8,14)
     +   /'R',    'F',    'C',    'T',    'O',    'L',    '.',    '.'/
      data
     + vn(1,15),vn(2,15),vn(3,15),vn(4,15),vn(5,15),vn(6,15),vn(7,15),
     + vn(8,15)
     +   /'X',    'C',    'T',    'O',    'L',    '.',    '.',    '.'/
      data
     + vn(1,16),vn(2,16),vn(3,16),vn(4,16),vn(5,16),vn(6,16),vn(7,16),
     + vn(8,16)
     +   /'X',    'F',    'T',    'O',    'L',    '.',    '.',    '.'/
      data
     + vn(1,17),vn(2,17),vn(3,17),vn(4,17),vn(5,17),vn(6,17),vn(7,17),
     + vn(8,17)
     +   /'L',    'M',    'A',    'X',    '0',    '.',    '.',    '.'/
      data
     + vn(1,18),vn(2,18),vn(3,18),vn(4,18),vn(5,18),vn(6,18),vn(7,18),
     + vn(8,18)
     +   /'D',    'L',    'T',    'F',    'D',    'J',    '.',    '.'/
      data
     + vn(1,19),vn(2,19),vn(3,19),vn(4,19),vn(5,19),vn(6,19),vn(7,19),
     + vn(8,19)
     +   /'D',    '0',    'I',    'N',    'I',    'T',    '.',    '.'/
      data
     + vn(1,20),vn(2,20),vn(3,20),vn(4,20),vn(5,20),vn(6,20),vn(7,20),
     + vn(8,20)
     +   /'D',    'I',    'N',    'I',    'T',    '.',    '.',    '.'/
      data
     + vn(1,21),vn(2,21),vn(3,21),vn(4,21),vn(5,21),vn(6,21),vn(7,21),
     + vn(8,21)
     +   /'J',    'T',    'I',    'N',    'I',    'T',    '.',    '.'/
      data
     + vn(1,22),vn(2,22),vn(3,22),vn(4,22),vn(5,22),vn(6,22),vn(7,22),
     + vn(8,22)
     +   /'D',    'L',    'T',    'F',    'D',    'C',    '.',    '.'/
      data
     + vn(1,23),vn(2,23),vn(3,23),vn(4,23),vn(5,23),vn(6,23),vn(7,23),
     + vn(8,23)
     +   /'D',    'F',    'A',    'C',    '.',    '.',    '.',    '.'/
      data
     + vn(1,24),vn(2,24),vn(3,24),vn(4,24),vn(5,24),vn(6,24),vn(7,24),
     + vn(8,24)
     +   /'R',    'L',    'I',    'M',    'I',    'T',    '.',    '.'/
      data
     + vn(1,25),vn(2,25),vn(3,25),vn(4,25),vn(5,25),vn(6,25),vn(7,25),
     + vn(8,25)
     +   /'C',    'O',    'S',    'M',    'I',    'N',    '.',    '.'/
      data
     + vn(1,26),vn(2,26),vn(3,26),vn(4,26),vn(5,26),vn(6,26),vn(7,26),
     + vn(8,26)
     +   /'D',    'E',    'L',    'T',    'A',    '0',    '.',    '.'/
      data
     + vn(1,27),vn(2,27),vn(3,27),vn(4,27),vn(5,27),vn(6,27),vn(7,27),
     + vn(8,27)
     +   /'F',    'U',    'Z',    'Z',    '.',    '.',    '.',    '.'/
!
      data vm(1)/1.0e-3_wp/, vm(2)/-0.99_wp/, vm(3)/1.0e-3_wp/,
     +     vm(4)/1.0e-2_wp/,
     +     vm(5)/1.2_wp/, vm(6)/1.0e-2_wp/, vm(7)/1.2_wp/,
     +     vm(8)/0.0_wp/,
     +     vm(9)/0.0_wp/, vm(10)/1.0e-3_wp/, vm(11)/-1.0_wp/,
     +     vm(15)/0.0_wp/,
     +     vm(16)/0.0_wp/, vm(19)/0.0_wp/, vm(20)/-10.0_wp/,
     +     vm(21)/0.0_wp/,
     +     vm(23)/0.0_wp/, vm(24)/1.0e10_wp/, vm(27)/1.01_wp/
      data vx(1)/0.9_wp/, vx(2)/-1.0e-3_wp/, vx(3)/1.0e1_wp/,
     +     vx(4)/0.8_wp/,
     +     vx(5)/1.0e2_wp/, vx(6)/0.8_wp/, vx(7)/1.0e2_wp/,
     +     vx(8)/0.5_wp/,
     +     vx(9)/0.5_wp/, vx(10)/1.0_wp/, vx(11)/1.0_wp/,
     +     vx(14)/0.1_wp/,
     +     vx(15)/1.0_wp/, vx(16)/1.0_wp/, vx(18)/1.0_wp/,
     +     vx(22)/1.0_wp/,
     +     vx(23)/1.0_wp/, vx(25)/1.0_wp/, vx(26)/1.0_wp/,
     +     vx(27)/1.0e2_wp/
!
      data cngd(1), cngd(2), cngd(3), cngd(4), cngd(5), cngd(6)
     +   /     '-',     '-',     '-',     'C',     'H',     'A'/
      data cngd(7), cngd(8), cngd(9), cngd(10), cngd(11), cngd(12)
     +   /     'N',     'G',     'E',     'D',     ' ',     'V'/
      data dflt(1), dflt(2), dflt(3), dflt(4), dflt(5), dflt(6)
     +   /     'N',     'O',     'N',     'D',     'E',     'F'/
      data dflt(7), dflt(8), dflt(9), dflt(10), dflt(11), dflt(12)
     +   /     'A',     'U',     'L',     'T',     ' ',     'V'/
!
!.......................................................................
!
      if (iv(1) .eq. 0) call dfault(iv, v)
      pu = iv(prunit)
      iv1 = iv(1)
      if (iv1 .ne. 12) go to 30
         if (nn .ge. n .and. n .ge. p .and. p .ge. 1) go to 20
              iv(1) = 16
              if (pu .ne. 0) write(pu,10) nn, n, p
 10           format(30h0///// bad nn, n, or p... nn =,i5,5h, n =,i5,
     +               5h, p =,i5)
              go to 999
 20      k = iv(21)
         call dfault(iv(21), v(33))
         iv(21) = k
         iv(dtype0) = iv(dtype+20)
         iv(oldn) = n
         iv(oldnn) = nn
         iv(oldp) = p
         do 25 ich = 1, 12
            which(ich) = dflt(ich)
 25      continue
         go to 80
 30   if (n .eq. iv(oldn) .and. nn .eq. iv(oldnn) .and. p .eq. iv(oldp))
     +                       go to 50
         iv(1) = 17
         if (pu .ne. 0) write(pu,40) iv(oldnn), iv(oldn), iv(oldp), nn,
     +                               n, p
 40      format('0///// (NN,N,P) CHANGED FROM (',i5,',',i5,',',i3,
     +          ') TO (',i5,',',i5,',',i3,').')
         go to 999
!
 50   if (iv1 .le. 11 .and. iv1 .ge. 1) go to 70
         iv(1) = 50
         if (pu .ne. 0) write(pu,60) iv1
 60      format('0/////  IV(1) =',i5,' SHOULD BE BETWEEN 0 AND 12.')
         go to 999
!
 70   do 75 ich = 1, 12
         which(ich) = cngd(ich)
 75   continue
!
 80   if (big .gt. tiny) go to 90
         tiny = rmdcon(1,typ=0.0_wp)
         machep = rmdcon(3,typ=0.0_wp)
         big = rmdcon(6,typ=0.0_wp)
         vm(12) = machep
         vx(12) = big
         vm(13) = tiny
         vx(13) = big
         vm(14) = machep
         vm(17) = tiny
         vx(17) = big
         vm(18) = machep
         vx(19) = big
         vx(20) = big
         vx(21) = big
         vm(22) = machep
         vx(24) = rmdcon(5,typ=0.0_wp)
         vm(25) = machep
         vm(26) = machep
 90   m = 0
      if (iv(inits) .ge. 0 .and. iv(inits) .le. 2) go to 110
         m = 18
         if (pu .ne. 0) write(pu,100) iv(inits)
 100     format(25h0/////  inits... iv(25) =,i4,20h should be between 0,
     +          7h and 2.)
 110  k = epslon
      do 140 i = 1, nvdflt
         vk = v(k)
         if (vk .ge. vm(i) .and. vk .le. vx(i)) go to 130
              m = k
           if (pu .ne. 0) write(pu,120) (vn(ich, i), ich=1, 8),
     +                                  (vn(ich, i), ich=1, 8),
     +                                  k, vk, vm(i), vx(i)
 120          format(8h0/////  ,8a1,5h.. v(,i2,3h) =,e11.3,7h should,
     +               ' BE BETWEEN',e11.3,4h and,e11.3)
 130     k = k + 1
 140     continue
!
      if (iv1 .eq. 12 .and. v(jtinit) .gt. zero) go to 170
!
!  ***  CHECK JTOL VALUES  ***
!
      jtolp = jtol0 + p
      do 160 i = jtol1, jtolp
         if (v(i) .gt. zero) go to 160
         k = i - jtol0
         if (pu .ne. 0) write(pu,150) k, i, v(i)
 150     format(12h0///// jtol(,i3,6h) = v(,i3,3h) =,e11.3,
     +          20h should be positive.)
         m = i
 160     continue
!
 170  if (m .eq. 0) go to 180
         iv(1) = m
         go to 999
!
 180  if (pu .eq. 0 .or. iv(parprt) .eq. 0) go to 999
      if (iv1 .ne. 12 .or. iv(inits) .eq. 0) go to 200
         m = 1
         write(pu,190) iv(inits)
 190     format(22h0nondefault values..../20h inits..... iv(25) =,i3)
 200  if (iv(dtype) .eq. iv(dtype0)) go to  210
         if (m .eq. 0) write(pu,215) (which(ich), ich=1, 12)
         m = 1
         write(pu,205) iv(dtype)
 205     format(20h dtype..... iv(16) =,i3)
 210  k = epslon
      l = parsv1
      do 240 i = 1, nvdflt
         if (v(k) .eq. v(l)) go to 230
              if (m .eq. 0) write(pu,215) (which(ich), ich = 1, 12)
 215          format ('0',12a1,'ALUES....'/)
              m = 1
              write (pu,220) (vn(ich, i), ich = 1, 8), k, v(k)
 220          format (1x, 8a1, 5h.. v(, i2, 3h) =, e15.7)
 230     k = k + 1
         l = l + 1
 240     continue
      iv(dtype0) = iv(dtype)
      call vcopy(nvdflt, v(parsv1), v(epslon))
      if (iv1 .ne. 12) go to 999
         if (v(jtinit) .gt. zero) go to 260
              jtolp = jtol0 + p
              write(pu,250) (v(i), i = jtol1, jtolp)
 250          format(24h0(initial) jtol array.../(1x,6e12.3))
 260     if (v(d0init) .gt. zero) go to 999
              k = jtol1 + p
              l = k + p - 1
              write(pu,270) (v(i), i = k, l)
 270          format(22h0(initial) d0 array.../1x,6e12.3)
!
 999  return

      end subroutine parchk
!NL2X
      subroutine nl2x(typ)
      real(kind=wp),intent(in) :: typ
!     ***  TEST NL2SOL AND NL2SNO ON MADSEN EXAMPLE  ***
!
!  VARIABLE DECLARATIONS
!
!  LOCAL ARRAYS
      real(kind=wp) :: urparm(1),v(147),x(2)
      integer :: iv(62),uiparm(1)
!
!  EXTERNAL SUBROUTINES
      external madj,madr,nl2sno,nl2sol,ufparm
!
      x(1) = 3.0_wp
      x(2) = 1.0_wp
      iv(1) = 0
      call nl2sol(3, 2, x, madr, madj, iv, v, uiparm, urparm, ufparm)
      iv(1) = 12
      x(1) = 3.0_wp
      x(2) = 1.0_wp
      call nl2sno(3, 2, x, madr, iv, v, uiparm, urparm, ufparm)

      end subroutine nl2x
!COVCLC
      subroutine covclc(covirc, d, iv, j, n, nn, p, r, v, x)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  COMPUTE COVARIANCE MATRIX FOR NL2ITR (NL2SOL VERSION 2.2)  ***
!
!  ***  LET K = ABS(IV(COVREQ).  FOR K .LE. 2, A FINITE-DIFFERENCE
!  ***  HESSIAN H IS COMPUTED (USING FUNC. AND GRAD. VALUES IF
!  ***  IV(COVREQ) IS NONNEGATIVE, AND USING ONLY FUNC. VALUES IF
!  ***  IV(COVREQ) IS NEGATIVE).  FOR SCALE = 2*F(X) / MAX(1, N-P),
!  ***  WHERE 2*F(X) IS THE RESIDUAL SUM OF SQUARES, COVCLC COMPUTES...
!  ***             K = 0 OR 1...  SCALE * H**-1 * (J**T * J) * H**-1.
!  ***             K = 2...  SCALE * H**-1.
!  ***             K .GE. 3...  SCALE * (J**T * J)**-1.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   covirc,n,nn,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   d(p),j(nn,p),r(n),v(1),x(p)
      integer
     +   iv(1)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   del,half,negpt5,one,t,two,wk,zero
      integer
     +   cov,covmat,covreq,delta,delta0,dltfdc,f,fx,g,g1,gp,gsave1,
     +   h,hc,hmi,hpi,hpm,i,ierr,ip1,ipiv0,ipivi,ipivk,ipivot,irc,
     +   k,kagqt,kalm,kind,kl,l,lmat,m,mm1,mm1o2,mode,nfgcal,pp1o2,
     +   qtr,qtr1,rd,rd1,rsave,savei,stp0,stpi,stpm,switch,toobig,
     +   w,w0,w1,wl,xmsave
      logical
     +   havej
!
!  EXTERNAL SUBROUTINES
      external linvrt,litvmu,livmul,lsqrt,ltsqar,qrfact,vcopy,vscopy
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER COVIRC, IV(1), N, NN, P
!     REAL(KIND=WP) :: D(P), J(NN,P), R(N), V(1), X(P)
!     DIMENSION IV(*), V(*)
!
!  ***  LOCAL VARIABLES  ***
!
!     LOGICAL HAVEJ
!     INTEGER COV, GP, GSAVE1, G1, HC, HMI, HPI, HPM, I, IPIVI, IPIVK,
!    1        IP1, IRC, K, KIND, KL, L, M, MM1, MM1O2, PP1O2, QTR1,
!    2        RD1, STPI, STPM, STP0, WL, W0, W1
!     REAL(KIND=WP) :: DEL, HALF, NEGPT5, ONE, T, TWO, WK, ZERO
!
!/
!  ***  EXTERNAL SUBROUTINES  ***
!
!     EXTERNAL LINVRT, LITVMU, LIVMUL, LSQRT, LTSQAR, QRFACT,
!    1         VCOPY, VSCOPY
!
! LINVRT... INVERT LOWER TRIANGULAR MATRIX.
! LITVMU... APPLY INVERSE-TRANSPOSE OF COMPACT LOWER TRIANG. MATRIX.
! LIVMUL... APPLY INVERSE OF COMPACT LOWER TRIANG. MATRIX.
! LSQRT.... COMPUTE CHOLESKY FACTOR OF (LOWER TRINAG. OF) A SYM. MATRIX.
! LTSQAR... GIVEN LOWER TRIANG. MATRIX L, COMPUTE (L**T)*L.
! QRFACT... COMPUTE QR DECOMPOSITION OF A MATRIX.
! VCOPY.... COPY ONE VECTOR TO ANOTHER.
! VSCOPY... SET ALL ELEMENTS OF A VECTOR TO A SCALAR.
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER COVMAT, COVREQ, DELTA, DELTA0, DLTFDC, F, FX, G, H, IERR,
!    1        IPIVOT, IPIV0, KAGQT, KALM, LMAT, MODE, NFGCAL, QTR,
!    2        RD, RSAVE, SAVEI, SWITCH, TOOBIG, W, XMSAVE
!
      data half/0.5_wp/, negpt5/-0.5_wp/, one/1.0_wp/, two/2.0_wp/,
     +     zero/0.0_wp/
!
      data covmat/26/, covreq/15/, delta/50/, delta0/44/,
     +     dltfdc/40/, f/10/, fx/46/, g/28/, h/44/, ierr/32/,
     +     ipivot/61/, ipiv0/60/, kagqt/35/, kalm/36/,
     +     lmat/58/, mode/38/, nfgcal/7/, qtr/49/,
     +     rd/51/, rsave/52/, savei/54/, switch/12/,
     +     toobig/2/, w/59/, xmsave/49/
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
      cov = iv(lmat)
!
      covirc = 4
      kind = iv(covreq)
      m = iv(mode)
      if (m .gt. 0) go to 10
         iv(kagqt) = -1
         if (iv(kalm) .gt. 0) iv(kalm) = 0
         if (abs(kind) .ge. 3) go to 300
         v(fx) = v(f)
         k = iv(rsave)
         call vcopy(n, v(k), r)
 10   if (m .gt. p) go to 200
      if (kind .lt. 0) go to 100
!
!  ***  COMPUTE FINITE-DIFFERENCE HESSIAN USING BOTH FUNCTION AND
!  ***  GRADIENT VALUES.
!
      gsave1 = iv(w) + p
      g1 = iv(g)
      if (m .gt. 0) go to 15
!        ***  FIRST CALL ON COVCLC.  SET GSAVE = G, TAKE FIRST STEP  ***
         call vcopy(p, v(gsave1), v(g1))
         iv(switch) = iv(nfgcal)
         go to 80
!
 15   del = v(delta)
      x(m) = v(xmsave)
      if (iv(toobig) .eq. 0) go to 30
!
!     ***  HANDLE OVERSIZE V(DELTA)  ***
!
         if (del*x(m) .gt. zero) go to 20
!             ***  WE ALREADY TRIED SHRINKING V(DELTA), SO QUIT  ***
              iv(covmat) = -2
              go to 190
!
!        ***  TRY SHRINKING V(DELTA)  ***
 20      del = negpt5 * del
         go to 90
!
 30   cov = iv(lmat)
      gp = g1 + p - 1
!
!  ***  SET  G = (G - GSAVE)/DEL  ***
!
      do i = g1, gp
         v(i) = (v(i) - v(gsave1)) / del
         gsave1 = gsave1 + 1
      enddo
!
!  ***  ADD G AS NEW COL. TO FINITE-DIFF. HESSIAN MATRIX  ***
!
      k = cov + m*(m-1)/2
      l = k + m - 2
      if ( m .eq. 1) go to 60
!
!  ***  SET  H(I,M) = 0.5 * (H(I,M) + G(I))  FOR I = 1 TO M-1  ***
!
      do i = k, l
         v(i) = half * (v(i) + v(g1))
         g1 = g1 + 1
      enddo
!
!  ***  ADD  H(I,M) = G(I)  FOR I = M TO P  ***
!
 60   l = l + 1
      do i = m, p
         v(l) = v(g1)
         l = l + i
         g1 = g1 + 1
      enddo
!
 80   m = m + 1
      iv(mode) = m
      if (m .gt. p) go to 190
!
!  ***  CHOOSE NEXT FINITE-DIFFERENCE STEP, RETURN TO GET G THERE  ***
!
      del = v(delta0) * max(one/d(m), abs(x(m)))
      if (x(m) .lt. zero) del = -del
      v(xmsave) = x(m)
 90   x(m) = x(m) + del
      v(delta) = del
      covirc = 2
      go to 999
!
!  ***  COMPUTE FINITE-DIFFERENCE HESSIAN USING FUNCTION VALUES ONLY.
!
 100  stp0 = iv(w) + p - 1
      mm1 = m - 1
      mm1o2 = m*mm1/2
      if (m .gt. 0) go to 105
!        ***  FIRST CALL ON COVCLC.  ***
         iv(savei) = 0
         go to 180
!
 105  i = iv(savei)
      if (i .gt. 0) go to 160
      if (iv(toobig) .eq. 0) go to 120
!
!     ***  HANDLE OVERSIZE STEP  ***
!
         stpm = stp0 + m
         del = v(stpm)
         if (del*x(xmsave) .gt. zero) go to 110
!             ***  WE ALREADY TRIED SHRINKING THE STEP, SO QUIT  ***
              iv(covmat) = -2
              go to 999
!
!        ***  TRY SHRINKING THE STEP  ***
 110     del = negpt5 * del
         x(m) = x(xmsave) + del
         v(stpm) = del
         covirc = 1
         go to 999
!
!  ***  SAVE F(X + STP(M)*E(M)) IN H(P,M)  ***
!
 120  pp1o2 = p * (p-1) / 2
      cov = iv(lmat)
      hpm = cov + pp1o2 + mm1
      v(hpm) = v(f)
!
!  ***  START COMPUTING ROW M OF THE FINITE-DIFFERENCE HESSIAN H.  ***
!
      hmi = cov + mm1o2
      if (mm1 .eq. 0) go to 140
      hpi = cov + pp1o2
      do i = 1, mm1
         v(hmi) = v(fx) - (v(f) + v(hpi))
         hmi = hmi + 1
         hpi = hpi + 1
      enddo
 140  v(hmi) = v(f) - two*v(fx)
!
!  ***  COMPUTE FUNCTION VALUES NEEDED TO COMPLETE ROW M OF H.  ***
!
      i = 1
!
 150  iv(savei) = i
      stpi = stp0 + i
      v(delta) = x(i)
      x(i) = x(i) + v(stpi)
      if (i .eq. m) x(i) = v(xmsave) - v(stpi)
      covirc = 1
      go to 999
!
 160  x(i) = v(delta)
      if (iv(toobig) .eq. 0) go to 170
!        ***  PUNT IN THE EVENT OF AN OVERSIZE STEP  ***
         iv(covmat) = -2
         go to 999
!
!  ***  FINISH COMPUTING H(M,I)  ***
!
 170  stpi = stp0 + i
      hmi = cov + mm1o2 + i - 1
      stpm = stp0 + m
      v(hmi) = (v(hmi) + v(f)) / (v(stpi)*v(stpm))
      i = i + 1
      if (i .le. m) go to 150
      iv(savei) = 0
      x(m) = v(xmsave)
!
 180  m = m + 1
      iv(mode) = m
      if (m .gt. p) go to 190
!
!  ***  PREPARE TO COMPUTE ROW M OF THE FINITE-DIFFERENCE HESSIAN H.
!  ***  COMPUTE M-TH STEP SIZE STP(M), THEN RETURN TO OBTAIN
!  ***  F(X + STP(M)*E(M)), WHERE E(M) = M-TH STD. UNIT VECTOR.
!
      del = v(dltfdc) * max(one/d(m), abs(x(m)))
      if (x(m) .lt. zero) del = -del
      v(xmsave) = x(m)
      x(m) = x(m) + del
      stpm = stp0 + m
      v(stpm) = del
      covirc = 1
      go to 999
!
!  ***  RESTORE R, V(F), ETC.  ***
!
 190  k = iv(rsave)
      call vcopy(n, r, v(k))
      v(f) = v(fx)
      if (kind .lt. 0) go to 200
         iv(nfgcal) = iv(switch)
         qtr1 = iv(qtr)
         call vcopy(n, v(qtr1), r)
         if (iv(covmat) .lt. 0) go to 999
         covirc = 3
         go to 999
!
 200  cov = iv(lmat)
!
!  ***  THE COMPLETE FINITE-DIFF. HESSIAN IS NOW STORED AT V(COV).   ***
!  ***  USE IT TO COMPUTE THE REQUESTED COVARIANCE MATRIX.           ***
!
!     ***  COMPUTE CHOLESKY FACTOR C OF H = C*(C**T)  ***
!     ***  AND STORE IT AT V(HC).  ***
!
      hc = cov
      if (abs(kind) .eq. 2) go to 210
         hc = abs(iv(h))
         iv(h) = -hc
 210  call lsqrt(1, p, v(hc), v(cov), irc)
      iv(covmat) = -1
      if (irc .ne. 0) go to 999
!
      w1 = iv(w) + p
      if (abs(kind) .gt. 1) go to 350
!
!  ***  COVARIANCE = SCALE * H**-1 * (J**T * J) * H**-1  ***
!
      call vscopy(p*(p+1)/2, v(cov), zero)
      havej = iv(kalm) .eq. (-1)
!     ***  HAVEJ = .TRUE. MEANS J IS IN ITS ORIGINAL FORM, WHILE
!     ***  HAVEJ = .FALSE. MEANS QRFACT HAS BEEN APPLIED TO J.
!
      m = p
      if (havej) m = n
      w0 = w1 - 1
      rd1 = iv(rd)
      do 290 i = 1, m
         if (havej) go to 240
!
!        ***  SET W = IPIVOT * (ROW I OF R MATRIX FROM QRFACT).  ***
!
              call vscopy(p, v(w1), zero)
              ipivi = ipiv0 + i
              l = w0 + iv(ipivi)
              v(l) = v(rd1)
              rd1 = rd1 + 1
              if (i .eq. p) go to 260
              ip1 = i + 1
              do 230 k = ip1, p
                   ipivk = ipiv0 + k
                   l = w0 + iv(ipivk)
                   v(l) = j(i,k)
 230               continue
              go to 260
!
!        ***  SET W = (ROW I OF J).  ***
!
 240     l = w0
         do 250 k = 1, p
              l = l + 1
              v(l) = j(i,k)
 250          continue
!
!        ***  SET W = H**-1 * W.  ***
!
 260     call livmul(p, v(w1), v(hc), v(w1))
         call litvmu(p, v(w1), v(hc), v(w1))
!
!        ***  ADD  W * W**T  TO COVARIANCE MATRIX.  ***
!
         kl = cov
         do 280 k = 1, p
              l = w0 + k
              wk = v(l)
              do 270 l = 1, k
                   wl = w0 + l
                   v(kl) = v(kl)  +  wk * v(wl)
                   kl = kl + 1
 270               continue
 280          continue
 290     continue
      go to 380
!
!  ***  COVARIANCE = SCALE * (J**T * J)**-1.  ***
!
 300  rd1 = iv(rd)
      if (iv(kalm) .ne. (-1)) go to 310
!
!        ***  APPLY QRFACT TO J  ***
!
         qtr1 = iv(qtr)
         call vcopy(n, v(qtr1), r)
         w1 = iv(w) + p
         call qrfact(nn, n, p, j, v(rd1), iv(ipivot), iv(ierr), 0,
     +               v(w1))
         iv(kalm) = -2
 310  iv(covmat) = -1
      if (iv(ierr) .ne. 0) go to 999
      cov = iv(lmat)
      hc = abs(iv(h))
      iv(h) = -hc
!
!     ***  SET HC = (R MATRIX FROM QRFACT).  ***
!
      l = hc
      do 340 i = 1, p
         if (i .gt. 1) call vcopy(i-1, v(l), j(1,i))
         l = l + i - 1
         v(l) = v(rd1)
         l = l + 1
         rd1 = rd1 + 1
 340     continue
!
!  ***  THE CHOLESKY FACTOR C OF THE UNSCALED INVERSE COVARIANCE MATRIX
!  ***  (OR PERMUTATION THEREOF) IS STORED AT V(HC).
!
!  ***  SET C = C**-1.
!
 350  call linvrt(p, v(hc), v(hc))
!
!  ***  SET C = C**T * C.
!
      call ltsqar(p, v(hc), v(hc))
!
      if (hc .eq. cov) go to 380
!
!     ***  C = PERMUTED, UNSCALED COVARIANCE.
!     ***  SET COV = IPIVOT * C * IPIVOT**T.
!
         do i = 1, p
              m = ipiv0 + i
              ipivi = iv(m)
              kl = cov-1 + ipivi*(ipivi-1)/2
              do k = 1, i
                   m = ipiv0 + k
                   ipivk = iv(m)
                   l = kl + ipivk
                   if (ipivk .gt. ipivi)
     +                       l = l + (ipivk-ipivi)*(ipivk+ipivi-3)/2
                   v(l) = v(hc)
                   hc = hc + 1
              enddo
         enddo
!
 380  continue
      iv(covmat) = cov
!
!  ***  APPLY SCALE FACTOR = (RESID. SUM OF SQUARES) / MAX(1,N-P).
!
      t = v(f) / (half * max(1,n-p))
      k = cov - 1 + p*(p+1)/2
      do i = cov, k
         v(i) = t * v(i)
      enddo
!
 999  return
      end subroutine covclc
!LSVMIN
      real(kind=wp) function lsvmin(p, l, x, y)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  ESTIMATE SMALLEST SING. VALUE OF PACKED LOWER TRIANG. MATRIX L
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   l(1),x(p),y(p)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   b,half,one,psj,r9973,sminus,splus,t,xminus,xplus,zero
      integer
     +   i,ii,ix,j,j0,ji,jj,jjj,jm1,pplus1
!
!  EXTERNAL FUNCTIONS
      real(kind=wp) ::
     +   v2norm
      external v2norm
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,mod
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER P
!     REAL(KIND=WP) :: L(1), X(P), Y(P)
!     DIMENSION L(P*(P+1)/2)
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  ***  PURPOSE  ***
!
!     THIS FUNCTION RETURNS A GOOD OVER-ESTIMATE OF THE SMALLEST
!     SINGULAR VALUE OF THE PACKED LOWER TRIANGULAR MATRIX L.
!
!  ***  PARAMETER DESCRIPTION  ***
!
!  P (IN)  = THE ORDER OF L.  L IS A  P X P  LOWER TRIANGULAR MATRIX.
!  L (IN)  = ARRAY HOLDING THE ELEMENTS OF  L  IN ROW ORDER, I.E.
!             L(1,1), L(2,1), L(2,2), L(3,1), L(3,2), L(3,3), ETC.
!  X (OUT) IF LSVMIN RETURNS A POSITIVE VALUE, THEN X IS A NORMALIZED
!             APPROXIMATE LEFT SINGULAR VECTOR CORRESPONDING TO THE
!             SMALLEST SINGULAR VALUE.  THIS APPROXIMATION MAY BE VERY
!             CRUDE.  IF LSVMIN RETURNS ZERO, THEN SOME COMPONENTS OF X
!             ARE ZERO AND THE REST RETAIN THEIR INPUT VALUES.
!  Y (OUT) IF LSVMIN RETURNS A POSITIVE VALUE, THEN Y = (L**-1)*X IS AN
!             UNNORMALIZED APPROXIMATE RIGHT SINGULAR VECTOR CORRESPOND-
!             ING TO THE SMALLEST SINGULAR VALUE.  THIS APPROXIMATION
!             MAY BE CRUDE.  IF LSVMIN RETURNS ZERO, THEN Y RETAINS ITS
!             INPUT VALUE.  THE CALLER MAY PASS THE SAME VECTOR FOR X
!             AND Y (NONSTANDARD FORTRAN USAGE), IN WHICH CASE Y OVER-
!             WRITES X (FOR NONZERO LSVMIN RETURNS).
!
!  ***  APPLICATION AND USAGE RESTRICTIONS  ***
!
!     THERE ARE NO USAGE RESTRICTIONS.
!
!  ***  ALGORITHM NOTES  ***
!
!     THE ALGORITHM IS BASED ON (1), WITH THE ADDITIONAL PROVISION THAT
!     LSVMIN = 0 IS RETURNED IF THE SMALLEST DIAGONAL ELEMENT OF L
!     (IN MAGNITUDE) IS NOT MORE THAN THE UNIT ROUNDOFF TIMES THE
!     LARGEST.  THE ALGORITHM USES A RANDOM NUMBER GENERATOR PROPOSED
!     IN (4), WHICH PASSES THE SPECTRAL TEST WITH FLYING COLORS -- SEE
!     (2) AND (3).
!
!  ***  SUBROUTINES AND FUNCTIONS CALLED  ***
!
!        V2NORM - FUNCTION, RETURNS THE 2-NORM OF A VECTOR.
!
!  ***  REFERENCES  ***
!
!     (1) CLINE, A., MOLER, C., STEWART, G., AND WILKINSON, J.H.(1977),
!         AN ESTIMATE FOR THE CONDITION NUMBER OF A MATRIX, REPORT
!         TM-310, APPLIED MATH. DIV., ARGONNE NATIONAL LABORATORY.
!
!     (2) HOAGLIN, D.C. (1976), THEORETICAL PROPERTIES OF CONGRUENTIAL
!         RANDOM-NUMBER GENERATORS --  AN EMPIRICAL VIEW,
!         MEMORANDUM NS-340, DEPT. OF STATISTICS, HARVARD UNIV.
!
!     (3) KNUTH, D.E. (1969), THE ART OF COMPUTER PROGRAMMING, VOL. 2
!         (SEMINUMERICAL ALGORITHMS), ADDISON-WESLEY, READING, MASS.
!
!     (4) SMITH, C.S. (1971), MULTIPLICATIVE PSEUDO-RANDOM NUMBER
!         GENERATORS WITH PRIME MODULUS, J. ASSOC. COMPUT. MACH. 18,
!         PP. 586-593.
!
!  ***  HISTORY  ***
!
!     DESIGNED AND CODED BY DAVID M GAY (WINTER 1977/SUMMER 1978).
!
!  ***  GENERAL  ***
!
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!     MCS-7600324, DCR75-10143, 76-14311DSS, AND MCS76-11989.
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER I, II, IX, J, JI, JJ, JJJ, JM1, J0, PPLUS1
!     REAL(KIND=WP) :: B, PSJ, SMINUS, SPLUS, T, XMINUS, XPLUS
!
!  ***  CONSTANTS  ***
!
!     REAL(KIND=WP) :: HALF, ONE, R9973, ZERO
!
!/
!  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***
!
!     EXTERNAL V2NORM
!     REAL(KIND=WP) :: V2NORM
!
      data ix/2/
      data half/0.5_wp/, one/1.0_wp/, r9973/9973.0_wp/, zero/0.0_wp/
!
!  ***  BODY  ***
!
!  ***  FIRST CHECK WHETHER TO RETURN LSVMIN = 0 AND INITIALIZE X  ***
!
      ii = 0
      do 10 i = 1, p
         x(i) = zero
         ii = ii + i
         if (l(ii) .eq. zero) go to 300
 10      continue
      if (mod(ix, 9973) .eq. 0) ix = 2
      pplus1 = p + 1
!
!  ***  SOLVE (L**T)*X = B, WHERE THE COMPONENTS OF B HAVE RANDOMLY
!  ***  CHOSEN MAGNITUDES IN (.5,1) WITH SIGNS CHOSEN TO MAKE X LARGE.
!
!     DO J = P TO 1 BY -1...
      do 100 jjj = 1, p
         j = pplus1 - jjj
!       ***  DETERMINE X(J) IN THIS ITERATION. NOTE FOR I = 1,2,...,J
!       ***  THAT X(I) HOLDS THE CURRENT PARTIAL SUM FOR ROW I.
         ix = mod(3432*ix, 9973)
         b = half*(one + ix/r9973)
         xplus = (b - x(j))
         xminus = (-b - x(j))
         splus = abs(xplus)
         sminus = abs(xminus)
         jm1 = j - 1
         j0 = j*jm1/2
         jj = j0 + j
         xplus = xplus/l(jj)
         xminus = xminus/l(jj)
         if (jm1 .eq. 0) go to 30
         do 20 i = 1, jm1
              ji = j0 + i
              splus = splus + abs(x(i) + l(ji)*xplus)
              sminus = sminus + abs(x(i) + l(ji)*xminus)
 20           continue
 30      if (sminus .gt. splus) xplus = xminus
         x(j) = xplus
!       ***  UPDATE PARTIAL SUMS  ***
         if (jm1 .eq. 0) go to 100
         do 40 i = 1, jm1
              ji = j0 + i
              x(i) = x(i) + l(ji)*xplus
 40           continue
 100     continue
!
!  ***  NORMALIZE X  ***
!
      t = one/v2norm(p, x)
      do 110 i = 1, p
 110     x(i) = t*x(i)
!
!  ***  SOLVE L*Y = X AND RETURN SVMIN = 1/TWONORM(Y)  ***
!
      do 200 j = 1, p
         psj = zero
         jm1 = j - 1
         j0 = j*jm1/2
         if (jm1 .eq. 0) go to 130
         do 120 i = 1, jm1
              ji = j0 + i
              psj = psj + l(ji)*y(i)
 120          continue
 130     jj = j0 + j
         y(j) = (x(j) - psj)/l(jj)
 200     continue
!
      lsvmin = one/v2norm(p, y)
      go to 999
!
 300  lsvmin = zero
 999  return
      end function lsvmin
!DOTPRD
      real(kind=wp) function dotprd(p, x, y)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  RETURN THE INNER PRODUCT OF THE P-VECTORS X AND Y.  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   x(*),y(*)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   one,sqteta,t,zero
      integer
     +   i
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max
!
!     INTEGER P
!     REAL(KIND=WP) :: X(*), Y(*)
!
!     INTEGER I
!     REAL(KIND=WP) :: ONE, SQTETA, T, ZERO
!/+
!     REAL(KIND=WP) :: MAX, ABS
!/
!
!  ***  RMDCON(2) RETURNS A MACHINE-DEPENDENT CONSTANT, SQTETA, WHICH
!  ***  IS SLIGHTLY LARGER THAN THE SMALLEST POSITIVE NUMBER THAT
!  ***  CAN BE SQUARED WITHOUT UNDERFLOWING.
!
      data one/1.0_wp/, sqteta/0.0_wp/, zero/0.0_wp/
!
      dotprd = zero
      if (p .le. 0) go to 999
      if (sqteta .eq. zero) sqteta = rmdcon(2,typ=0.0_wp)
      do 20 i = 1, p
         t = max(abs(x(i)), abs(y(i)))
         if (t .gt. one) go to 10
         if (t .lt. sqteta) go to 20
         t = (x(i)/sqteta)*y(i)
         if (abs(t) .lt. sqteta) go to 20
 10      dotprd = dotprd + x(i)*y(i)
 20   continue
!
 999  return
      end function dotprd
!MADJ
      subroutine madj(n, p, x, nf, j, uiparm, urparm, ufparm)
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   n,nf,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   j(n,p),urparm(*),x(p)
      integer
     +   uiparm(*)
!
!  SUBROUTINE ARGUMENTS
      external ufparm
!
!  INTRINSIC FUNCTIONS
      intrinsic cos,sin
!
      j(1,1) = 2.0_wp*x(1) + x(2)
      j(1,2) = 2.0_wp*x(2) + x(1)
      j(2,1) = cos(x(1))
      j(2,2) = 0.0_wp
      j(3,1) = 0.0_wp
      j(3,2) = -sin(x(2))

      end subroutine madj
!VAXPY
      subroutine vaxpy(p, w, a, x, y)
!
!  ***  SET W = A*X + Y  --  W, X, Y = P-VECTORS, A = SCALAR  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: a
      integer p
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: w(*),x(*),y(*)
!
!  LOCAL SCALARS
      integer i
!
!
      do i = 1, p
         w(i) = a*x(i) + y(i)
      enddo

      end subroutine vaxpy
!RPTMUL
      subroutine rptmul(func, ipivot, j, nn, p, rd, x, y, z)
!
!  ***  FUNC = 1... SET  Y = RMAT * (PERM**T) * X.
!  ***  FUNC = 2... SET  Y = PERM * (RMAT**T) * RMAT * (PERM**T) * X.
!  ***  FUNC = 3... SET  Y = PERM * (RMAT**T) X.
!
!
!  ***  PERM = MATRIX WHOSE I-TH COL. IS THE IPIVOT(I)-TH UNIT VECTOR.
!  ***  RMAT IS THE UPPER TRIANGULAR MATRIX WHOSE STRICT UPPER TRIANGLE
!  ***       IS STORED IN  J  AND WHOSE DIAGONAL IS STORED IN RD.
!  ***  Z IS A SCRATCH VECTOR.
!  ***  X AND Y MAY SHARE STORAGE.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   func,nn,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   j(nn,p),rd(p),x(p),y(p),z(p)
      integer
     +   ipivot(p)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   zk
      integer
     +   i,im1,k,km1
!
!  EXTERNAL FUNCTIONS
      real(kind=wp) ::
     +   dotprd
      external dotprd
!
!
!-----------------------------------------------------------------------
!
      if (func .gt. 2) go to 50
!
!  ***  FIRST SET  Z = (PERM**T) * X  ***
!
      do 10 i = 1, p
         k = ipivot(i)
         z(i) = x(k)
 10      continue
!
!  ***  NOW SET  Y = RMAT * Z  ***
!
      y(1) = z(1) * rd(1)
      if (p .le. 1) go to 40
      do 30 k = 2, p
         km1 = k - 1
         zk = z(k)
         do 20 i = 1, km1
 20           y(i) = y(i) + j(i,k)*zk
         y(k) = zk*rd(k)
 30      continue
!
 40   if (func .le. 1) go to 999
      go to 70
!
 50   do 60 i = 1, p
 60      y(i) = x(i)
!
!  ***  SET  Z = (RMAT**T) * Y  ***
!
 70   z(1) = y(1) * rd(1)
      if (p .eq. 1) go to 90
      do 80 i = 2, p
         im1 = i - 1
         z(i) = y(i)*rd(i) + dotprd(im1, j(1,i), y)
 80      continue
!
!  ***  NOW SET  Y = PERM * Z  ***
!
 90   do 100 i = 1, p
         k = ipivot(i)
         y(k) = z(i)
 100     continue
!
 999  return

      end subroutine rptmul
!SLVMUL
      subroutine slvmul(p, y, s, x)
!
!  ***  SET  Y = S * X,  S = P X P SYMMETRIC MATRIX.  ***
!  ***  LOWER TRIANGLE OF  S  STORED ROWWISE.         ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   s(1),x(p),y(p)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   xi
      integer
     +   i,im1,j,k
!
!  EXTERNAL FUNCTIONS
      real(kind=wp) ::
     +   dotprd
      external dotprd
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER P
!     REAL(KIND=WP) :: S(1), X(P), Y(P)
!     DIMENSION S(P*(P+1)/2)
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER I, IM1, J, K
!     REAL(KIND=WP) :: XI
!
!  ***  EXTERNAL FUNCTION  ***
!
!     EXTERNAL DOTPRD
!     REAL(KIND=WP) :: DOTPRD
!
!-----------------------------------------------------------------------
!
      j = 1
      do 10 i = 1, p
         y(i) = dotprd(i, s(j), x)
         j = j + i
 10      continue
!
      if (p .le. 1) go to 999
      j = 1
      do 40 i = 2, p
         xi = x(i)
         im1 = i - 1
         j = j + 1
         do 30 k = 1, im1
              y(k) = y(k) + s(j)*xi
              j = j + 1
 30           continue
 40      continue
!
 999  return

      end subroutine slvmul
!LTSQAR
      subroutine ltsqar(n, a, l)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!  ***  SET A TO LOWER TRIANGLE OF (L**T) * L  ***
!
!  ***  L = N X N LOWER TRIANG. MATRIX STORED ROWWISE.  ***
!  ***  A IS ALSO STORED ROWWISE AND MAY SHARE STORAGE WITH L.  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   n
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   a(*),l(*)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   lii,lj
      integer
     +   i,i1,ii,iim1,j,k,m
!
!     INTEGER N
!     REAL(KIND=WP) :: A(1), L(1)
!     DIMENSION A(N*(N+1)/2), L(N*(N+1)/2)
!
!     INTEGER I, II, IIM1, I1, J, K, M
!     REAL(KIND=WP) :: LII, LJ
!
      ii = 0
      do 50 i = 1, n
         i1 = ii + 1
         ii = ii + i
         m = 1
         if (i .eq. 1) go to 30
         iim1 = ii - 1
         do 20 j = i1, iim1
              lj = l(j)
              do 10 k = i1, j
                   a(m) = a(m) + lj*l(k)
                   m = m + 1
 10                continue
 20           continue
 30      lii = l(ii)
         do 40 j = i1, ii
 40           a(j) = lii * l(j)
 50      continue
!
      end subroutine ltsqar
!LITVMU
      subroutine litvmu(n, x, l, y)
!
!  ***  SOLVE  (L**T)*X = Y,  WHERE  L  IS AN  N X N  LOWER TRIANGULAR
!  ***  MATRIX STORED COMPACTLY BY ROWS.  X AND Y MAY OCCUPY THE SAME
!  ***  STORAGE.  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   n
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   l(1),x(n),y(n)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   xi,zero
      integer
     +   i,i0,ii,ij,im1,j,np1
!
      data zero/0.0_wp/
!
      do 10 i = 1, n
 10      x(i) = y(i)
      np1 = n + 1
      i0 = n*(n+1)/2
      do 30 ii = 1, n
         i = np1 - ii
         xi = x(i)/l(i0)
         x(i) = xi
         if (i .le. 1) go to 999
         i0 = i0 - i
         if (xi .eq. zero) go to 30
         im1 = i - 1
         do 20 j = 1, im1
              ij = i0 + j
              x(j) = x(j) - xi*l(ij)
 20           continue
 30      continue
 999  return
      end subroutine litvmu
!GQTSTP
      subroutine gqtstp(d, dig, dihdi, ka, l, p, step, v, w)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  *** COMPUTE GOLDFELD-QUANDT-TROTTER STEP BY MORE-HEBDEN TECHNIQUE ***
!  ***  (NL2SOL VERSION 2.2)  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   ka,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   d(p),dig(p),dihdi(1),l(1),step(p),v(21),w(1)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   aki,akk,alphak,delta,dgxfac,dst,epsfac,epso6,four,half,kappa,
     +   lk,negone,oldphi,one,p001,phi,phimax,phimin,psifac,rad,root,
     +   si,six,sk,sw,t,t1,three,two,twopsi,uk,wi,zero
      integer
     +   dggdmx,dgnorm,diag,diag0,dst0,dstnrm,dstsav,emax,emin,
     +   epslon,gtstep,i,im1,inc,irc,j,k,k1,kalim,lk0,nreduc,
     +   phipin,phmnfc,phmxfc,preduc,q,q0,rad0,radius,stppar,uk0,x,
     +   x0
      logical
     +   restrt
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
      real(kind=wp) ::
     +   dotprd,lsvmin,v2norm
      external dotprd,lsvmin,v2norm
!
!  EXTERNAL SUBROUTINES
      external litvmu,livmul,lsqrt
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max,min,sqrt
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER KA, P
!     REAL(KIND=WP) :: D(P), DIG(P), DIHDI(1), L(1), V(21), STEP(P),
!    1                 W(1)
!     DIMENSION DIHDI(P*(P+1)/2), L(P*(P+1)/2), W(4*P+7)
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  ***  PURPOSE  ***
!
!        GIVEN THE (COMPACTLY STORED) LOWER TRIANGLE OF A SCALED
!     HESSIAN (APPROXIMATION) AND A NONZERO SCALED GRADIENT VECTOR,
!     THIS SUBROUTINE COMPUTES A GOLDFELD-QUANDT-TROTTER STEP OF
!     APPROXIMATE LENGTH V(RADIUS) BY THE MORE-HEBDEN TECHNIQUE.  IN
!     OTHER WORDS, STEP IS COMPUTED TO (APPROXIMATELY) MINIMIZE
!     PSI(STEP) = (G**T)*STEP + 0.5*(STEP**T)*H*STEP  SUCH THAT THE
!     2-NORM OF D*STEP IS AT MOST (APPROXIMATELY) V(RADIUS), WHERE
!     G  IS THE GRADIENT,  H  IS THE HESSIAN, AND  D  IS A DIAGONAL
!     SCALE MATRIX WHOSE DIAGONAL IS STORED IN THE PARAMETER D.
!     (GQTSTP ASSUMES  DIG = D**-1 * G  AND  DIHDI = D**-1 * H * D**-1.)
!     IF G = 0, HOWEVER, STEP = 0 IS RETURNED (EVEN AT A SADDLE POINT).
!
!  ***  PARAMETER DESCRIPTION  ***
!
!     D (IN)  = THE SCALE VECTOR, I.E. THE DIAGONAL OF THE SCALE
!              MATRIX  D  MENTIONED ABOVE UNDER PURPOSE.
!   DIG (IN)  = THE SCALED GRADIENT VECTOR, D**-1 * G.  IF G = 0, THEN
!              STEP = 0  AND  V(STPPAR) = 0  ARE RETURNED.
! DIHDI (IN)  = LOWER TRIANGLE OF THE SCALED HESSIAN (APPROXIMATION),
!              I.E., D**-1 * H * D**-1, STORED COMPACTLY BY ROWS., I.E.,
!              IN THE ORDER (1,1), (2,1), (2,2), (3,1), (3,2), ETC.
!    KA (I/O) = THE NUMBER OF HEBDEN ITERATIONS (SO FAR) TAKEN TO DETER-
!              MINE STEP.  KA .LT. 0 ON INPUT MEANS THIS IS THE FIRST
!              ATTEMPT TO DETERMINE STEP (FOR THE PRESENT DIG AND DIHDI)
!              -- KA IS INITIALIZED TO 0 IN THIS CASE.  OUTPUT WITH
!              KA = 0  (OR V(STPPAR) = 0)  MEANS  STEP = -(H**-1)*G.
!     L (I/O) = WORKSPACE OF LENGTH P*(P+1)/2 FOR CHOLESKY FACTORS.
!     P (IN)  = NUMBER OF PARAMETERS -- THE HESSIAN IS A  P X P  MATRIX.
!  STEP (I/O) = THE STEP COMPUTED.
!     V (I/O) CONTAINS VARIOUS CONSTANTS AND VARIABLES DESCRIBED BELOW.
!     W (I/O) = WORKSPACE OF LENGTH 4*P + 6.
!
!  ***  ENTRIES IN V  ***
!
! V(DGNORM) (I/O) = 2-NORM OF (D**-1)*G.
! V(DSTNRM) (OUTPUT) = 2-NORM OF D*STEP.
! V(DST0)   (I/O) = 2-NORM OF D*(H**-1)*G (FOR POS. DEF. H ONLY), OR
!             OVERESTIMATE OF SMALLEST EIGENVALUE OF (D**-1)*H*(D**-1).
! V(EPSLON) (IN)  = MAX. REL. ERROR ALLOWED FOR PSI(STEP).  FOR THE
!             STEP RETURNED, PSI(STEP) WILL EXCEED ITS OPTIMAL VALUE
!             BY LESS THAN -V(EPSLON)*PSI(STEP).  SUGGESTED VALUE = 0.1.
! V(GTSTEP) (OUT) = INNER PRODUCT BETWEEN G AND STEP.
! V(NREDUC) (OUT) = PSI(-(H**-1)*G) = PSI(NEWTON STEP)  (FOR POS. DEF.
!             H ONLY -- V(NREDUC) IS SET TO ZERO OTHERWISE).
! V(PHMNFC) (IN)  = TOL. (TOGETHER WITH V(PHMXFC)) FOR ACCEPTING STEP
!             (MORE*S SIGMA).  THE ERROR V(DSTNRM) - V(RADIUS) MUST LIE
!             BETWEEN V(PHMNFC)*V(RADIUS) AND V(PHMXFC)*V(RADIUS).
! V(PHMXFC) (IN)  (SEE V(PHMNFC).)
!             SUGGESTED VALUES -- V(PHMNFC) = -0.25, V(PHMXFC) = 0.5.
! V(PREDUC) (OUT) = PSI(STEP) = PREDICTED OBJ. FUNC. REDUCTION FOR STEP.
! V(RADIUS) (IN)  = RADIUS OF CURRENT (SCALED) TRUST REGION.
! V(RAD0)   (I/O) = VALUE OF V(RADIUS) FROM PREVIOUS CALL.
! V(STPPAR) (I/O) IS NORMALLY THE MARQUARDT PARAMETER, I.E. THE ALPHA
!             DESCRIBED BELOW UNDER ALGORITHM NOTES.  IF H + ALPHA*D**2
!             (SEE ALGORITHM NOTES) IS (NEARLY) SINGULAR, HOWEVER,
!             THEN V(STPPAR) = -ALPHA.
!
!  ***  USAGE NOTES  ***
!
!     IF IT IS DESIRED TO RECOMPUTE STEP USING A DIFFERENT VALUE OF
!     V(RADIUS), THEN THIS ROUTINE MAY BE RESTARTED BY CALLING IT
!     WITH ALL PARAMETERS UNCHANGED EXCEPT V(RADIUS).  (THIS EXPLAINS
!     WHY STEP AND W ARE LISTED AS I/O).  ON AN INTIIAL CALL (ONE WITH
!     KA .LT. 0), STEP AND W NEED NOT BE INITIALIZED AND ONLY COMPO-
!     NENTS V(EPSLON), V(STPPAR), V(PHMNFC), V(PHMXFC), V(RADIUS), AND
!     V(RAD0) OF V MUST BE INITIALIZED.  TO COMPUTE STEP FROM A SADDLE
!     POINT (WHERE THE TRUE GRADIENT VANISHES AND H HAS A NEGATIVE
!     EIGENVALUE), A NONZERO G WITH SMALL COMPONENTS SHOULD BE PASSED.
!
!  ***  APPLICATION AND USAGE RESTRICTIONS  ***
!
!     THIS ROUTINE IS CALLED AS PART OF THE NL2SOL (NONLINEAR LEAST-
!     SQUARES) PACKAGE (REF. 1), BUT IT COULD BE USED IN SOLVING ANY
!     UNCONSTRAINED MINIMIZATION PROBLEM.
!
!  ***  ALGORITHM NOTES  ***
!
!        THE DESIRED G-Q-T STEP (REF. 2, 3, 4) SATISFIES
!     (H + ALPHA*D**2)*STEP = -G  FOR SOME NONNEGATIVE ALPHA SUCH THAT
!     H + ALPHA*D**2 IS POSITIVE SEMIDEFINITE.  ALPHA AND STEP ARE
!     COMPUTED BY A SCHEME ANALOGOUS TO THE ONE DESCRIBED IN REF. 5.
!     ESTIMATES OF THE SMALLEST AND LARGEST EIGENVALUES OF THE HESSIAN
!     ARE OBTAINED FROM THE GERSCHGORIN CIRCLE THEOREM ENHANCED BY A
!     SIMPLE FORM OF THE SCALING DESCRIBED IN REF. 6.  CASES IN WHICH
!     H + ALPHA*D**2 IS NEARLY (OR EXACTLY) SINGULAR ARE HANDLED BY
!     THE TECHNIQUE DISCUSSED IN REF. 2.  IN THESE CASES, A STEP OF
!     (EXACT) LENGTH V(RADIUS) IS RETURNED FOR WHICH PSI(STEP) EXCEEDS
!     ITS OPTIMAL VALUE BY LESS THAN -V(EPSLON)*PSI(STEP).
!
!  ***  FUNCTIONS AND SUBROUTINES CALLED  ***
!
! DOTPRD - RETURNS INNER PRODUCT OF TWO VECTORS.
! LITVMU - APPLIES INVERSE-TRANSPOSE OF COMPACT LOWER TRIANG. MATRIX.
! LIVMUL - APPLIES INVERSE OF COMPACT LOWER TRIANG. MATRIX.
! LSQRT  - FINDS CHOLESKY FACTOR (OF COMPACTLY STORED LOWER TRIANG.).
! LSVMIN - RETURNS APPROX. TO MIN. SING. VALUE OF LOWER TRIANG. MATRIX.
! RMDCON - RETURNS MACHINE-DEPENDENT CONSTANTS.
! V2NORM - RETURNS 2-NORM OF A VECTOR.
!
!  ***  REFERENCES  ***
!
! 1.  DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1980), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, (SUBMITTED TO ACM
!             TRANS. MATH. SOFTWARE).
! 2.  GAY, D.M. (1979), COMPUTING OPTIMAL ELLIPTICALLY CONSTRAINED
!             STEPS, MRC TECH. SUMMARY REPORT NO. 2013, MATH. RESEARCH
!             CENTER, UNIV. OF WISCONSIN-MADISON.
! 3.  GOLDFELD, S.M., QUANDT, R.E., AND TROTTER, H.F. (1966),
!             MAXIMIZATION BY QUADRATIC HILL-CLIMBING, ECONOMETRICA 34,
!             PP. 541-551.
! 4.  HEBDEN, M.D. (1973), AN ALGORITHM FOR MINIMIZATION USING EXACT
!             SECOND DERIVATIVES, REPORT T.P. 515, THEORETICAL PHYSICS
!             DIV., A.E.R.E. HARWELL, OXON., ENGLAND.
! 5.  MORE, J.J. (1978), THE LEVENBERG-MARQUARDT ALGORITHM, IMPLEMEN-
!             TATION AND THEORY, PP.105-116 OF SPRINGER LECTURE NOTES
!             IN MATHEMATICS NO. 630, EDITED BY G.A. WATSON, SPRINGER-
!             VERLAG, BERLIN AND NEW YORK.
! 6.  VARGA, R.S. (1965), MINIMAL GERSCHGORIN SETS, PACIFIC J. MATH. 15,
!             PP. 719-729.
!
!  ***  GENERAL  ***
!
!     CODED BY DAVID M. GAY.
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!     MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989, AND
!     MCS-7906671.
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  ***  LOCAL VARIABLES  ***
!
!     LOGICAL RESTRT
!     INTEGER DGGDMX, DIAG, DIAG0, DSTSAV, EMAX, EMIN, I, IM1, INC, IRC,
!    1        J, K, KALIM, K1, LK0, PHIPIN, Q, Q0, UK0, X, X0
!     REAL(KIND=WP) :: ALPHAK, AKI, AKK, DELTA, DST, EPSO6, LK,
!    1                 OLDPHI, PHI, PHIMAX, PHIMIN, PSIFAC, RAD,
!    2                 ROOT, SI, SK, SW, T, TWOPSI, T1, UK, WI
!
!     ***  CONSTANTS  ***
!     REAL(KIND=WP) :: DGXFAC, EPSFAC, FOUR, HALF, KAPPA, NEGONE, ONE,
!    1                 P001, SIX, THREE, TWO, ZERO
!
!/
!  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***
!
!     EXTERNAL DOTPRD, LITVMU, LIVMUL, LSQRT, LSVMIN, V2NORM
!     REAL(KIND=WP) :: DOTPRD, LSVMIN, V2NORM
!
!  ***  SUBSCRIPTS FOR V  ***
!
!     INTEGER DGNORM, DSTNRM, DST0, EPSLON, GTSTEP, STPPAR, NREDUC,
!    1        PHMNFC, PHMXFC, PREDUC, RADIUS, RAD0
      data dgnorm/1/, dstnrm/2/, dst0/3/, epslon/19/,
     +     gtstep/4/, nreduc/6/, phmnfc/20/,
     +     phmxfc/21/, preduc/7/, radius/8/,
     +     rad0/9/, stppar/5/
!
      data dgxfac/0.0_wp/, epsfac/50.0_wp/, four/4.0_wp/, half/0.5_wp/,
     +     kappa/2.0_wp/, negone/-1.0_wp/, one/1.0_wp/, p001/1.0e-3_wp/,
     +     six/6.0_wp/, three/3.0_wp/, two/2.0_wp/, zero/0.0_wp/
!
!  ***  BODY  ***
!
!     ***  STORE LARGEST ABS. ENTRY IN (D**-1)*H*(D**-1) AT W(DGGDMX).
      dggdmx = p + 1
!     ***  STORE GERSCHGORIN OVER- AND UNDERESTIMATES OF THE LARGEST
!     ***  AND SMALLEST EIGENVALUES OF (D**-1)*H*(D**-1) AT W(EMAX)
!     ***  AND W(EMIN) RESPECTIVELY.
      emax = dggdmx + 1
      emin = emax + 1
!     ***  FOR USE IN RECOMPUTING STEP, THE FINAL VALUES OF LK, UK, DST,
!     ***  AND THE INVERSE DERIVATIVE OF MORE*S PHI AT 0 (FOR POS. DEF.
!     ***  H) ARE STORED IN W(LK0), W(UK0), W(DSTSAV), AND W(PHIPIN)
!     ***  RESPECTIVELY.
      uk = 0.0_wp
      phi = 0.0_wp
      dst = 0.0_wp
      alphak = 0.0_wp
      lk0 = emin + 1
      phipin = lk0 + 1
      uk0 = phipin + 1
      dstsav = uk0 + 1
!     ***  STORE DIAG OF (D**-1)*H*(D**-1) IN W(DIAG),...,W(DIAG0+P).
      diag0 = dstsav
      diag = diag0 + 1
!     ***  STORE -D*STEP IN W(Q),...,W(Q0+P).
      q0 = diag0 + p
      q = q0 + 1
      rad = v(radius)
!     ***  PHITOL = MAX. ERROR ALLOWED IN DST = V(DSTNRM) = 2-NORM OF
!     ***  D*STEP.
      phimax = v(phmxfc) * rad
      phimin = v(phmnfc) * rad
!     ***  EPSO6 AND PSIFAC ARE USED IN CHECKING FOR THE SPECIAL CASE
!     ***  OF (NEARLY) SINGULAR H + ALPHA*D**2 (SEE REF. 2).
      psifac = two * v(epslon) / (three * (four * (v(phmnfc) + one) *
     +                       (kappa + one)  +  kappa  +  two) * rad**2)
!     ***  OLDPHI IS USED TO DETECT LIMITS OF NUMERICAL ACCURACY.  IF
!     ***  WE RECOMPUTE STEP AND IT DOES NOT CHANGE, THEN WE ACCEPT IT.
      oldphi = zero
      epso6 = v(epslon)/six
      irc = 0
      restrt = .false.
      kalim = ka + 50
!
!  ***  START OR RESTART, DEPENDING ON KA  ***
!
      if (ka .ge. 0) go to 310
!
!  ***  FRESH START  ***
!
      k = 0
      uk = negone
      ka = 0
      kalim = 50
!
!     ***  STORE DIAG(DIHDI) IN W(DIAG0+1),...,W(DIAG0+P)  ***
!
      j = 0
      do 20 i = 1, p
         j = j + i
         k1 = diag0 + i
         w(k1) = dihdi(j)
 20      continue
!
!     ***  DETERMINE W(DGGDMX), THE LARGEST ELEMENT OF DIHDI  ***
!
      t1 = zero
      j = p * (p + 1) / 2
      do 30 i = 1, j
         t = abs(dihdi(i))
         if (t1 .lt. t) t1 = t
 30      continue
      w(dggdmx) = t1
!
!  ***  TRY ALPHA = 0  ***
!
 40   call lsqrt(1, p, l, dihdi, irc)
      if (irc .eq. 0) go to 60
!        ***  INDEF. H -- UNDERESTIMATE SMALLEST EIGENVALUE, USE THIS
!        ***  ESTIMATE TO INITIALIZE LOWER BOUND LK ON ALPHA.
         j = irc*(irc+1)/2
         t = l(j)
         l(j) = one
         do 50 i = 1, irc
 50           w(i) = zero
         w(irc) = one
         call litvmu(irc, w, l, w)
         t1 = v2norm(irc, w)
         lk = -t / t1 / t1
         v(dst0) = -lk
         if (restrt) go to 210
         v(nreduc) = zero
         go to 70
!
!     ***  POSITIVE DEFINITE H -- COMPUTE UNMODIFIED NEWTON STEP.  ***
 60   lk = zero
      call livmul(p, w(q), l, dig)
      v(nreduc) = half * dotprd(p, w(q), w(q))
      call litvmu(p, w(q), l, w(q))
      dst = v2norm(p, w(q))
      v(dst0) = dst
      phi = dst - rad
      if (phi .le. phimax) go to 280
      if (restrt) go to 210
!
!  ***  PREPARE TO COMPUTE GERSCHGORIN ESTIMATES OF LARGEST (AND
!  ***  SMALLEST) EIGENVALUES.  ***
!
 70   v(dgnorm) = v2norm(p, dig)
      if (v(dgnorm) .eq. zero) go to 450
      k = 0
      do 100 i = 1, p
         wi = zero
         if (i .eq. 1) go to 90
         im1 = i - 1
         do 80 j = 1, im1
              k = k + 1
              t = abs(dihdi(k))
              wi = wi + t
              w(j) = w(j) + t
 80           continue
 90      w(i) = wi
         k = k + 1
 100     continue
!
!  ***  (UNDER-)ESTIMATE SMALLEST EIGENVALUE OF (D**-1)*H*(D**-1)  ***
!
      k = 1
      t1 = w(diag) - w(1)
      if (p .le. 1) go to 120
      do 110 i = 2, p
         j = diag0 + i
         t = w(j) - w(i)
         if (t .ge. t1) go to 110
              t1 = t
              k = i
 110     continue
!
 120  sk = w(k)
      j = diag0 + k
      akk = w(j)
      k1 = k*(k-1)/2 + 1
      inc = 1
      t = zero
      do 150 i = 1, p
         if (i .eq. k) go to 130
         aki = abs(dihdi(k1))
         si = w(i)
         j = diag0 + i
         t1 = half * (akk - w(j) + si - aki)
         t1 = t1 + sqrt(t1*t1 + sk*aki)
         if (t .lt. t1) t = t1
         if (i .lt. k) go to 140
 130     inc = i
 140     k1 = k1 + inc
 150     continue
!
      w(emin) = akk - t
      uk = v(dgnorm)/rad - w(emin)
!
!  ***  COMPUTE GERSCHGORIN (OVER-)ESTIMATE OF LARGEST EIGENVALUE  ***
!
      k = 1
      t1 = w(diag) + w(1)
      if (p .le. 1) go to 170
      do 160 i = 2, p
         j = diag0 + i
         t = w(j) + w(i)
         if (t .le. t1) go to 160
              t1 = t
              k = i
 160     continue
!
 170  sk = w(k)
      j = diag0 + k
      akk = w(j)
      k1 = k*(k-1)/2 + 1
      inc = 1
      t = zero
      do 200 i = 1, p
         if (i .eq. k) go to 180
         aki = abs(dihdi(k1))
         si = w(i)
         j = diag0 + i
         t1 = half * (w(j) + si - aki - akk)
         t1 = t1 + sqrt(t1*t1 + sk*aki)
         if (t .lt. t1) t = t1
         if (i .lt. k) go to 190
 180     inc = i
 190     k1 = k1 + inc
 200     continue
!
      w(emax) = akk + t
      lk = max(lk, v(dgnorm)/rad - w(emax))
!
!     ***  ALPHAK = CURRENT VALUE OF ALPHA (SEE ALG. NOTES ABOVE).  WE
!     ***  USE MORE*S SCHEME FOR INITIALIZING IT.
      alphak = abs(v(stppar)) * v(rad0)/rad
!
      if (irc .ne. 0) go to 210
!
!  ***  COMPUTE L0 FOR POSITIVE DEFINITE H  ***
!
      call livmul(p, w, l, w(q))
      t = v2norm(p, w)
      w(phipin) = dst / t / t
      lk = max(lk, phi*w(phipin))
!
!  ***  SAFEGUARD ALPHAK AND ADD ALPHAK*I TO (D**-1)*H*(D**-1)  ***
!
 210  ka = ka + 1
      if (-v(dst0) .ge. alphak .or. alphak .lt. lk .or. alphak .ge. uk)
     +                      alphak = uk * max(p001, sqrt(lk/uk))
      k = 0
      do 220 i = 1, p
         k = k + i
         j = diag0 + i
         dihdi(k) = w(j) + alphak
 220     continue
!
!  ***  TRY COMPUTING CHOLESKY DECOMPOSITION  ***
!
      call lsqrt(1, p, l, dihdi, irc)
      if (irc .eq. 0) go to 250
!
!  ***  (D**-1)*H*(D**-1) + ALPHAK*I  IS INDEFINITE -- OVERESTIMATE
!  ***  SMALLEST EIGENVALUE FOR USE IN UPDATING LK  ***
!
      j = (irc*(irc+1))/2
      t = l(j)
      l(j) = one
      do 230 i = 1, irc
 230     w(i) = zero
      w(irc) = one
      call litvmu(irc, w, l, w)
      t1 = v2norm(irc, w)
      lk = alphak - t/t1/t1
      v(dst0) = -lk
      go to 210
!
!  ***  ALPHAK MAKES (D**-1)*H*(D**-1) POSITIVE DEFINITE.
!  ***  COMPUTE Q = -D*STEP, CHECK FOR CONVERGENCE.  ***
!
 250  call livmul(p, w(q), l, dig)
      call litvmu(p, w(q), l, w(q))
      dst = v2norm(p, w(q))
      phi = dst - rad
      if (phi .le. phimax .and. phi .ge. phimin) go to 290
      if (phi .eq. oldphi) go to 290
      oldphi = phi
      if (phi .gt. zero) go to 260
!        ***  CHECK FOR THE SPECIAL CASE OF  H + ALPHA*D**2  (NEARLY)
!        ***  SINGULAR.  DELTA IS .GE. THE SMALLEST EIGENVALUE OF
!        ***  (D**-1)*H*(D**-1) + ALPHAK*I.
         if (v(dst0) .gt. zero) go to 260
         delta = alphak + v(dst0)
         twopsi = alphak*dst*dst + dotprd(p, dig, w(q))
         if (delta .lt. psifac*twopsi) go to 270
!
!  ***  UNACCEPTABLE ALPHAK -- UPDATE LK, UK, ALPHAK  ***
!
 260  if (ka .ge. kalim) go to 290
      call livmul(p, w, l, w(q))
      t1 = v2norm(p, w)
!     ***  THE FOLLOWING MIN IS NECESSARY BECAUSE OF RESTARTS  ***
      if (phi .lt. zero) uk = min(uk, alphak)
      alphak = alphak  +  (phi/t1) * (dst/t1) * (dst/rad)
      lk = max(lk, alphak)
      go to 210
!
!  ***  DECIDE HOW TO HANDLE (NEARLY) SINGULAR H + ALPHA*D**2  ***
!
!     ***  IF NOT YET AVAILABLE, OBTAIN MACHINE DEPENDENT VALUE DGXFAC.
 270  if (dgxfac .eq. zero) dgxfac = epsfac * rmdcon(3,typ=0.0_wp)
!
!     ***  NOW DECIDE.  ***
      if (delta .gt. dgxfac*w(dggdmx)) go to 350
!        ***  DELTA IS SO SMALL WE CANNOT HANDLE THE SPECIAL CASE IN
!        ***  THE AVAILABLE ARITHMETIC.  ACCEPT STEP AS IT IS.
         go to 290
!
!  ***  ACCEPTABLE STEP ON FIRST TRY  ***
!
 280  alphak = zero
!
!  ***  SUCCESSFUL STEP IN GENERAL.  COMPUTE STEP = -(D**-1)*Q  ***
!
 290  do 300 i = 1, p
         j = q0 + i
         step(i) = -w(j)/d(i)
 300     continue
      v(gtstep) = -dotprd(p, dig, w(q))
      v(preduc) = half * (abs(alphak)*dst*dst - v(gtstep))
      go to 430
!
!
!  ***  RESTART WITH NEW RADIUS  ***
!
 310  if (v(dst0) .le. zero .or. v(dst0) - rad .gt. phimax) go to 330
!
!     ***  PREPARE TO RETURN NEWTON STEP  ***
!
         restrt = .true.
         ka = ka + 1
         k = 0
         do 320 i = 1, p
              k = k + i
              j = diag0 + i
              dihdi(k) = w(j)
 320          continue
         uk = negone
         go to 40
!
 330  if (ka .eq. 0) go to 60
!
      dst = w(dstsav)
      alphak = abs(v(stppar))
      phi = dst - rad
      t = v(dgnorm)/rad
      if (rad .gt. v(rad0)) go to 340
!
!        ***  SMALLER RADIUS  ***
         uk = t - w(emin)
         lk = zero
         if (alphak .gt. zero) lk = w(lk0)
         lk = max(lk, t - w(emax))
         if (v(dst0) .gt. zero) lk = max(lk, (v(dst0)-rad)*w(phipin))
         go to 260
!
!     ***  BIGGER RADIUS  ***
 340  uk = t - w(emin)
      if (alphak .gt. zero) uk = min(uk, w(uk0))
      lk = max(zero, -v(dst0), t - w(emax))
      if (v(dst0) .gt. zero) lk = max(lk, (v(dst0)-rad)*w(phipin))
      go to 260
!
!  ***  HANDLE (NEARLY) SINGULAR H + ALPHA*D**2  ***
!
!     ***  NEGATE ALPHAK TO INDICATE SPECIAL CASE  ***
 350  alphak = -alphak
!     ***  ALLOCATE STORAGE FOR SCRATCH VECTOR X  ***
      x0 = q0 + p
      x = x0 + 1
!
!  ***  USE INVERSE POWER METHOD WITH START FROM LSVMIN TO OBTAIN
!  ***  APPROXIMATE EIGENVECTOR CORRESPONDING TO SMALLEST EIGENVALUE
!  ***  OF (D**-1)*H*(D**-1).
!
      delta = kappa*delta
      t = lsvmin(p, l, w(x), w)
!
      k = 0
!     ***  NORMALIZE W  ***
 360  do 370 i = 1, p
 370     w(i) = t*w(i)
!     ***  COMPLETE CURRENT INV. POWER ITER. -- REPLACE W BY (L**-T)*W.
      call litvmu(p, w, l, w)
      t1 = one/v2norm(p, w)
      t = t1*t
      if (t .le. delta) go to 390
      if (k .gt. 30) go to 290
      k = k + 1
!     ***  START NEXT INV. POWER ITER. BY STORING NORMALIZED W IN X.
      do 380 i = 1, p
         j = x0 + i
         w(j) = t1*w(i)
 380     continue
!     ***  COMPUTE W = (L**-1)*X.
      call livmul(p, w, l, w(x))
      t = one/v2norm(p, w)
      go to 360
!
 390  do 400 i = 1, p
 400     w(i) = t1*w(i)
!
!  ***  NOW W IS THE DESIRED APPROXIMATE (UNIT) EIGENVECTOR AND
!  ***  T*X = ((D**-1)*H*(D**-1) + ALPHAK*I)*W.
!
      sw = dotprd(p, w(q), w)
      t1 = (rad + dst) * (rad - dst)
      root = sqrt(sw*sw + t1)
      if (sw .lt. zero) root = -root
      si = t1 / (sw + root)
!     ***  ACCEPT CURRENT STEP IF ADDING SI*W WOULD LEAD TO A
!     ***  FURTHER RELATIVE REDUCTION IN PSI OF LESS THAN V(EPSLON)/3.
      v(preduc) = half*twopsi
      t1 = zero
      t = si*(alphak*sw - half*si*(alphak + t*dotprd(p,w(x),w)))
      if (t .lt. epso6*twopsi) go to 410
         v(preduc) = v(preduc) + t
         dst = rad
         t1 = -si
 410  do 420 i = 1, p
         j = q0 + i
         w(j) = t1*w(i) - w(j)
         step(i) = w(j) / d(i)
 420     continue
      v(gtstep) = dotprd(p, dig, w(q))
!
!  ***  SAVE VALUES FOR USE IN A POSSIBLE RESTART  ***
!
 430  v(dstnrm) = dst
      v(stppar) = alphak
      w(lk0) = lk
      w(uk0) = uk
      v(rad0) = rad
      w(dstsav) = dst
!
!     ***  RESTORE DIAGONAL OF DIHDI  ***
!
      j = 0
      do 440 i = 1, p
         j = j + i
         k = diag0 + i
         dihdi(j) = w(k)
 440     continue
      go to 999
!
!  ***  SPECIAL CASE -- G = 0  ***
!
 450  v(stppar) = zero
      v(preduc) = zero
      v(dstnrm) = zero
      v(gtstep) = zero
      do 460 i = 1, p
 460     step(i) = zero
!
 999  return
!
      end subroutine gqtstp
!DUPDAT
      subroutine dupdat(d, iv, j, n, nn, p, v)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  UPDATE SCALE VECTOR D FOR NL2ITR (NL2SOL VERSION 2.2)  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   n,nn,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   d(p),j(nn,p),v(1)
      integer
     +   iv(1)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   sii,t,vdfac,zero
      integer
     +   d0,dfac,dtype,i,jtol0,jtoli,niter,s,s1
!
!  EXTERNAL FUNCTIONS
      real(kind=wp) ::
     +   v2norm
      external v2norm
!
!  INTRINSIC FUNCTIONS
      intrinsic max,sqrt
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER IV(1), N, NN, P
!     REAL(KIND=WP) :: D(P), J(NN,P), V(1)
!     DIMENSION IV(*), V(*)
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER D0, I, JTOLI, S1
!     REAL(KIND=WP) :: SII, T, VDFAC
!
!     ***  CONSTANTS  ***
!     REAL(KIND=WP) :: ZERO
!
!/
!  ***  EXTERNAL FUNCTION  ***
!
!     EXTERNAL V2NORM
!     REAL(KIND=WP) :: V2NORM
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER DFAC, DTYPE, JTOL0, NITER, S
      data dfac/41/, dtype/16/, jtol0/86/, niter/31/, s/53/
!
      data zero/0.0_wp/
!
!-----------------------------------------------------------------------
!
      i = iv(dtype)
      if (i .eq. 1) go to 20
         if (iv(niter) .gt. 0) go to 999
!
 20   vdfac = v(dfac)
      d0 = jtol0 + p
      s1 = iv(s) - 1
      do 30 i = 1, p
         s1 = s1 + i
         sii = v(s1)
         t = v2norm(n, j(1,i))
         if (sii .gt. zero) t = sqrt(t*t + sii)
         jtoli = jtol0 + i
         d0 = d0 + 1
         if (t .lt. v(jtoli)) t = max(v(d0), v(jtoli))
         d(i) = max(vdfac*d(i), t)
 30      continue
!
 999  return
      end subroutine dupdat
!DFAULT
      subroutine dfault(iv, v)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!
!  VARIABLE DECLARATIONS
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   v(45)
      integer
     +   iv(25)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   machep,mepcrt,one,sqteps,three
      integer
     +   afctol,cosmin,covprt,covreq,d0init,decfac,delta0,dfac,
     +   dinit,dltfdc,dltfdj,dtype,epslon,fuzz,incfac,inits,jtinit,
     +   lmax0,mxfcal,mxiter,outlev,parprt,phmnfc,phmxfc,prunit,
     +   rdfcmn,rdfcmx,rfctol,rlimit,solprt,statpr,tuner1,tuner2,
     +   tuner3,tuner4,tuner5,x0prt,xctol,xftol
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
      integer
     +   imdcon
      external imdcon
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  ***  SUPPLY NL2SOL (VERSION 2.2) DEFAULT VALUES TO IV AND V  ***
!
!     INTEGER IV(25)
!     REAL(KIND=WP) :: V(45)
!/+
!     REAL(KIND=WP) :: MAX
!/
!     EXTERNAL IMDCON
!     INTEGER IMDCON
!
!     REAL(KIND=WP) :: MACHEP, MEPCRT, ONE, SQTEPS, THREE
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER AFCTOL, COSMIN, COVPRT, COVREQ, DECFAC, DELTA0, DFAC,
!    1        DINIT, DLTFDC, DLTFDJ, DTYPE, D0INIT, EPSLON, FUZZ,
!    2        INCFAC, INITS, JTINIT, LMAX0, MXFCAL, MXITER, OUTLEV,
!    3        PARPRT, PHMNFC, PHMXFC, PRUNIT, RDFCMN, RDFCMX,
!    4        RFCTOL, RLIMIT, SOLPRT, STATPR, TUNER1, TUNER2, TUNER3,
!    5        TUNER4, TUNER5, XCTOL, XFTOL, X0PRT
!
      data one/1.0_wp/, three/3.0_wp/
!
!  ***  IV SUBSCRIPT VALUES  ***
!
      data covprt/14/, covreq/15/, dtype/16/, inits/25/,
     +     mxfcal/17/, mxiter/18/, outlev/19/,
     +     parprt/20/, prunit/21/, solprt/22/,
     +     statpr/23/, x0prt/24/
!
!  ***  V SUBSCRIPT VALUES  ***
!
      data afctol/31/, cosmin/43/, decfac/22/,
     +     delta0/44/, dfac/41/, dinit/38/, dltfdc/40/,
     +     dltfdj/36/, d0init/37/, epslon/19/, fuzz/45/,
     +     incfac/23/, jtinit/39/, lmax0/35/, phmnfc/20/,
     +     phmxfc/21/, rdfcmn/24/, rdfcmx/25/,
     +     rfctol/32/, rlimit/42/, tuner1/26/,
     +     tuner2/27/, tuner3/28/, tuner4/29/,
     +     tuner5/30/, xctol/33/, xftol/34/
!
!-----------------------------------------------------------------------
!
      iv(1) = 12
      iv(covprt) = 1
      iv(covreq) = 1
      iv(dtype) = 1
      iv(inits) = 0
      iv(mxfcal) = 200
      iv(mxiter) = 150
      iv(outlev) = 1
      iv(parprt) = 1
      iv(prunit) = imdcon(1)
      iv(solprt) = 1
      iv(statpr) = 1
      iv(x0prt) = 1
!
      machep = rmdcon(3,typ=0.0_wp)
      v(afctol) = 1.0e-20_wp
      if (machep .gt. 1.0e-10_wp) v(afctol) = machep**2
      v(cosmin) = max(1.0e-6_wp, 1.0e2_wp * machep)
      v(decfac) = 0.5_wp
      sqteps = rmdcon(4,typ=0.0_wp)
      v(delta0) = sqteps
      v(dfac) = 0.6_wp
      v(dinit) = 0.0_wp
      mepcrt = machep ** (one/three)
      v(dltfdc) = mepcrt
      v(dltfdj) = sqteps
      v(d0init) = 1.0_wp
      v(epslon) = 0.1_wp
      v(fuzz) = 1.5_wp
      v(incfac) = 2.0_wp
      v(jtinit) = 1.0e-6_wp
      v(lmax0) = 100.0_wp
      v(phmnfc) = -0.1_wp
      v(phmxfc) = 0.1_wp
      v(rdfcmn) = 0.1_wp
      v(rdfcmx) = 4.0_wp
      v(rfctol) = max(1.0e-10_wp, mepcrt**2)
      v(rlimit) = rmdcon(5,typ=0.0_wp)
      v(tuner1) = 0.1_wp
      v(tuner2) = 1.0e-4_wp
      v(tuner3) = 0.75_wp
      v(tuner4) = 0.5_wp
      v(tuner5) = 0.75_wp
      v(xctol) = sqteps
      v(xftol) = 1.0e2_wp * machep

      end subroutine dfault
!RELDST
      real(kind=wp) function reldst(p, d, x, x0)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!  ***  COMPUTE AND RETURN RELATIVE DIFFERENCE BETWEEN X AND X0  ***
!  ***  NL2SOL VERSION 2.2  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer
     +   p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   d(p),x(p),x0(p)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   emax,t,xmax,zero
      integer
     +   i
!
!  INTRINSIC FUNCTIONS
      intrinsic abs
!
      data zero/0.0_wp/
!
      emax = zero
      xmax = zero
      do 10 i = 1, p
         t = abs(d(i) * (x(i) - x0(i)))
         if (emax .lt. t) emax = t
         t = d(i) * (abs(x(i)) + abs(x0(i)))
         if (xmax .lt. t) xmax = t
 10      continue
      reldst = zero
      if (xmax .gt. zero) reldst = emax / xmax

      end function reldst
!SLUPDT
      subroutine slupdt(a, cosmin, p, size, step, u, w, wchmtd, wscale,
     +                  y)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!  ***  UPDATE SYMMETRIC  A  SO THAT  A * STEP = Y  ***
!  ***  (LOWER TRIANGLE OF  A  STORED ROWWISE       ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) ::
     +   cosmin,size,wscale
      integer
     +   p
!
!  ARRAY ARGUMENTS
      real(kind=wp) ::
     +   a(1),step(p),u(p),w(p),wchmtd(p),y(p)
!
!  LOCAL SCALARS
      real(kind=wp) ::
     +   denmin,half,one,sdotwm,t,ui,wi,zero
      integer
     +   i,j,k
!
!  EXTERNAL FUNCTIONS
      real(kind=wp) ::
     +   dotprd,v2norm
      external dotprd,v2norm
!
!  EXTERNAL SUBROUTINES
      external slvmul
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,min
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER P
!     REAL(KIND=WP) :: A(1), COSMIN, SIZE, STEP(P), U(P), W(P),
!    1                 WCHMTD(P), WSCALE, Y(P)
!     DIMENSION A(P*(P+1)/2)
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER I, J, K
!     REAL(KIND=WP) :: DENMIN, SDOTWM, T, UI, WI
!
!     ***  CONSTANTS  ***
!     REAL(KIND=WP) :: HALF, ONE, ZERO
!
!/
!  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***
!
!     EXTERNAL DOTPRD, SLVMUL, V2NORM
!     REAL(KIND=WP) :: DOTPRD, V2NORM
!
      data half/0.5_wp/, one/1.0_wp/, zero/0.0_wp/
!
!-----------------------------------------------------------------------
!
      sdotwm = dotprd(p, step, wchmtd)
      denmin = cosmin * v2norm(p,step) * v2norm(p,wchmtd)
      wscale = one
      if (denmin .ne. zero) wscale = min(one, abs(sdotwm/denmin))
      t = zero
      if (sdotwm .ne. zero) t = wscale / sdotwm
      do 10 i = 1, p
 10      w(i) = t * wchmtd(i)
      call slvmul(p, u, a, step)
      t = half * (size * dotprd(p, step, u)  -  dotprd(p, step, y))
      do 20 i = 1, p
 20      u(i) = t*w(i) + y(i) - size*u(i)
!
!  ***  SET  A = A + U*(W**T) + W*(U**T)  ***
!
      k = 1
      do 40 i = 1, p
         ui = u(i)
         wi = w(i)
         do 30 j = 1, i
              a(k) = size*a(k) + ui*w(j) + wi*u(j)
              k = k + 1
 30           continue
 40      continue
!
      end subroutine slupdt

!ASSESS
      subroutine assess (d, iv, p, step, stlstg, v, x, x0)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!  ***  ASSESS CANDIDATE STEP (NL2SOL VERSION 2.2)  ***
!
!  ***  PURPOSE  ***
!
!        This subroutine is called by an unconstrained minimization
!     routine to assess the next candidate step.  It may recommend one
!     of several courses of action, such as accepting the step, recomputing
!     it using the same or a new quadratic model, or halting due
!     to convergence or false convergence.  See the return code listing
!     below.
!
!
!  Variable Declarations
!
!  SCALAR ARGUMENTS
      integer p
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: d(p),step(p),stlstg(p),v(*),x(p),x0(p)
      integer iv(*)
!
!  LOCAL SCALARS
      real(kind=wp) :: emax,gts,half,one,reldx1,rfac1,temp,two,xmax,zero
      integer
     +   afctol,decfac,dst0,dstnrm,dstsav,f,f0,fdif,flstgd,gtslst,
     +   gtstep,i,incfac,irc,lmax0,mlstgd,model,nfc,nfcall,nfgcal,
     +   nreduc,plstgd,preduc,radfac,radinc,rdfcmn,rdfcmx,reldx,
     +   restor,rfctol,stage,stglim,stppar,switch,toobig,tuner1,
     +   tuner2,tuner3,xctol,xftol,xirc
      logical goodx
!
!  EXTERNAL FUNCTIONS
      real(kind=wp),external :: reldst
!     real(kind=wp) :: mach
!
!  EXTERNAL SUBROUTINES
      external vcopy
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max
!
!--------------------------  PARAMETER USAGE  --------------------------
!
!     IV (I/O) INTEGER PARAMETER AND SCRATCH VECTOR -- SEE DESCRIPTION
!             BELOW OF IV VALUES REFERENCED.
!      D (IN)  SCALE VECTOR USED IN COMPUTING V(RELDX) -- SEE BELOW.
!      P (IN)  NUMBER OF PARAMETERS BEING OPTIMIZED.
!   STEP (I/O) ON INPUT, STEP IS THE STEP TO BE ASSESSED.  IT IS UN-
!             CHANGED ON OUTPUT UNLESS A PREVIOUS STEP ACHIEVED A
!             BETTER OBJECTIVE FUNCTION REDUCTION, IN WHICH CASE STLSTG
!             WILL HAVE BEEN COPIED TO STEP.
! STLSTG (I/O) WHEN ASSESS RECOMMENDS RECOMPUTING STEP EVEN THOUGH THE
!             CURRENT (OR A PREVIOUS) STEP YIELDS AN OBJECTIVE FUNC-
!             TION DECREASE, IT SAVES IN STLSTG THE STEP THAT GAVE THE
!             BEST FUNCTION REDUCTION SEEN SO FAR (IN THE CURRENT ITERA-
!             TION).  IF THE RECOMPUTED STEP YIELDS A LARGER FUNCTION
!             VALUE, THEN STEP IS RESTORED FROM STLSTG AND
!             X = X0 + STEP IS RECOMPUTED.
!      V (I/O) REAL(KIND=WP) PARAMETER AND SCRATCH VECTOR -- SEE DESCRIPTION
!             BELOW OF V VALUES REFERENCED.
!      X (I/O) ON INPUT, X = X0 + STEP IS THE POINT AT WHICH THE OBJEC-
!             TIVE FUNCTION HAS JUST BEEN EVALUATED.  IF AN EARLIER
!             STEP YIELDED A BIGGER FUNCTION DECREASE, THEN X IS
!             RESTORED TO THE CORRESPONDING EARLIER VALUE.  OTHERWISE,
!             IF THE CURRENT STEP DOES NOT GIVE ANY FUNCTION DECREASE,
!             THEN X IS RESTORED TO X0.
!     X0 (IN)  INITIAL OBJECTIVE FUNCTION PARAMETER VECTOR (AT THE
!             START OF THE CURRENT ITERATION).
!
!  ***  IV VALUES REFERENCED  ***
!
!    IV(IRC) (I/O) ON INPUT FOR THE FIRST STEP TRIED IN A NEW ITERATION,
!             IV(IRC) SHOULD BE SET TO 3 OR 4 (THE VALUE TO WHICH IT IS
!             SET WHEN STEP IS DEFINITELY TO BE ACCEPTED).  ON INPUT
!             AFTER STEP HAS BEEN RECOMPUTED, IV(IRC) SHOULD BE
!             UNCHANGED SINCE THE PREVIOUS RETURN OF ASSESS.
!                ON OUTPUT, IV(IRC) IS A RETURN CODE HAVING ONE OF THE
!             FOLLOWING VALUES...
!                  1 = SWITCH MODELS OR TRY SMALLER STEP.
!                  2 = SWITCH MODELS OR ACCEPT STEP.
!                  3 = ACCEPT STEP AND DETERMINE V(RADFAC) BY GRADIENT
!                       TESTS.
!                  4 = ACCEPT STEP, V(RADFAC) HAS BEEN DETERMINED.
!                  5 = RECOMPUTE STEP (USING THE SAME MODEL).
!                  6 = RECOMPUTE STEP WITH RADIUS = V(LMAX0) BUT DO NOT
!                       EVAULATE THE OBJECTIVE FUNCTION.
!                  7 = X-CONVERGENCE (SEE V(XCTOL)).
!                  8 = RELATIVE FUNCTION CONVERGENCE (SEE V(RFCTOL)).
!                  9 = BOTH X- AND RELATIVE FUNCTION CONVERGENCE.
!                 10 = ABSOLUTE FUNCTION CONVERGENCE (SEE V(AFCTOL)).
!                 11 = SINGULAR CONVERGENCE (SEE V(LMAX0)).
!                 12 = FALSE CONVERGENCE (SEE V(XFTOL)).
!                 13 = IV(IRC) WAS OUT OF RANGE ON INPUT.
!             RETURN CODE I HAS PRECDENCE OVER I+1 FOR I = 9, 10, 11.
! IV(MLSTGD) (I/O) SAVED VALUE OF IV(MODEL).
!  IV(MODEL) (I/O) ON INPUT, IV(MODEL) SHOULD BE AN INTEGER IDENTIFYING
!             THE CURRENT QUADRATIC MODEL OF THE OBJECTIVE FUNCTION.
!             IF A PREVIOUS STEP YIELDED A BETTER FUNCTION REDUCTION,
!             THEN IV(MODEL) WILL BE SET TO IV(MLSTGD) ON OUTPUT.
! IV(NFCALL) (IN)  INVOCATION COUNT FOR THE OBJECTIVE FUNCTION.
! IV(NFGCAL) (I/O) VALUE OF IV(NFCALL) AT STEP THAT GAVE THE BIGGEST
!             FUNCTION REDUCTION THIS ITERATION.  IV(NFGCAL) REMAINS
!             UNCHANGED UNTIL A FUNCTION REDUCTION IS OBTAINED.
! IV(RADINC) (I/O) THE NUMBER OF RADIUS INCREASES (OR MINUS THE NUMBER
!             OF DECREASES) SO FAR THIS ITERATION.
! IV(RESTOR) (OUT) SET TO 0 UNLESS X AND V(F) HAVE BEEN RESTORED, IN
!             WHICH CASE ASSESS SETS IV(RESTOR) = 1.
!  IV(STAGE) (I/O) COUNT OF THE NUMBER OF MODELS TRIED SO FAR IN THE
!             CURRENT ITERATION.
! IV(STGLIM) (IN)  MAXIMUM NUMBER OF MODELS TO CONSIDER.
! IV(SWITCH) (OUT) SET TO 0 UNLESS A NEW MODEL IS BEING TRIED AND IT
!             GIVES A SMALLER FUNCTION VALUE THAN THE PREVIOUS MODEL,
!             IN WHICH CASE ASSESS SETS IV(SWITCH) = 1.
! IV(TOOBIG) (IN)  IS NONZERO IF STEP WAS TOO BIG (E.G. IF IT CAUSED
!             OVERFLOW).
!   IV(XIRC) (I/O) VALUE THAT IV(IRC) WOULD HAVE IN THE ABSENCE OF
!             CONVERGENCE, FALSE CONVERGENCE, AND OVERSIZED STEPS.
!
!  ***  V VALUES REFERENCED  ***
!
! V(AFCTOL) (IN)  ABSOLUTE FUNCTION CONVERGENCE TOLERANCE.  IF THE
!             ABSOLUTE VALUE OF THE CURRENT FUNCTION VALUE V(F) IS LESS
!             THAN V(AFCTOL), THEN ASSESS RETURNS WITH IV(IRC) = 10.
! V(DECFAC) (IN)  FACTOR BY WHICH TO DECREASE RADIUS WHEN IV(TOOBIG) IS
!             NONZERO.
! V(DSTNRM) (IN)  THE 2-NORM OF D*STEP.
! V(DSTSAV) (I/O) VALUE OF V(DSTNRM) ON SAVED STEP.
!   V(DST0) (IN)  THE 2-NORM OF D TIMES THE NEWTON STEP (WHEN DEFINED,
!             I.E., FOR V(NREDUC) .GE. 0).
!      V(F) (I/O) ON BOTH INPUT AND OUTPUT, V(F) IS THE OBJECTIVE FUNC-
!             TION VALUE AT X.  IF X IS RESTORED TO A PREVIOUS VALUE,
!             THEN V(F) IS RESTORED TO THE CORRESPONDING VALUE.
!   V(FDIF) (OUT) THE FUNCTION REDUCTION V(F0) - V(F) (FOR THE OUTPUT
!             VALUE OF V(F) IF AN EARLIER STEP GAVE A BIGGER FUNCTION
!             DECREASE, AND FOR THE INPUT VALUE OF V(F) OTHERWISE).
! V(FLSTGD) (I/O) SAVED VALUE OF V(F).
!     V(F0) (IN)  OBJECTIVE FUNCTION VALUE AT START OF ITERATION.
! V(GTSLST) (I/O) VALUE OF V(GTSTEP) ON SAVED STEP.
! V(GTSTEP) (IN)  INNER PRODUCT BETWEEN STEP AND GRADIENT.
! V(INCFAC) (IN)  MINIMUM FACTOR BY WHICH TO INCREASE RADIUS.
!  V(LMAX0) (IN)  MAXIMUM REASONABLE STEP SIZE (AND INITIAL STEP BOUND).
!             IF THE ACTUAL FUNCTION DECREASE IS NO MORE THAN TWICE
!             WHAT WAS PREDICTED, IF A RETURN WITH IV(IRC) = 7, 8, 9,
!             OR 10 DOES NOT OCCUR, IF V(DSTNRM) .GT. V(LMAX0), AND IF
!             V(PREDUC) .LE. V(RFCTOL) * ABS(V(F0)), THEN ASSESS RE-
!             TURNS WITH IV(IRC) = 11.  IF SO DOING APPEARS WORTHWHILE,
!             THEN ASSESS REPEATS THIS TEST WITH V(PREDUC) COMPUTED FOR
!             A STEP OF LENGTH V(LMAX0) (BY A RETURN WITH IV(IRC) = 6).
! V(NREDUC) (I/O)  FUNCTION REDUCTION PREDICTED BY QUADRATIC MODEL FOR
!             NEWTON STEP.  IF ASSESS IS CALLED WITH IV(IRC) = 6, I.E.,
!             IF V(PREDUC) HAS BEEN COMPUTED WITH RADIUS = V(LMAX0) FOR
!             USE IN THE SINGULAR CONVERVENCE TEST, THEN V(NREDUC) IS
!             SET TO -V(PREDUC) BEFORE THE LATTER IS RESTORED.
! V(PLSTGD) (I/O) VALUE OF V(PREDUC) ON SAVED STEP.
! V(PREDUC) (I/O) FUNCTION REDUCTION PREDICTED BY QUADRATIC MODEL FOR
!             CURRENT STEP.
! V(RADFAC) (OUT) FACTOR TO BE USED IN DETERMINING THE NEW RADIUS,
!             WHICH SHOULD BE V(RADFAC)*DST, WHERE  DST  IS EITHER THE
!             OUTPUT VALUE OF V(DSTNRM) OR THE 2-NORM OF
!             DIAG(NEWD)*STEP  FOR THE OUTPUT VALUE OF STEP AND THE
!             UPDATED VERSION, NEWD, OF THE SCALE VECTOR D.  FOR
!             IV(IRC) = 3, V(RADFAC) = 1.0 IS RETURNED.
! V(RDFCMN) (IN)  MINIMUM VALUE FOR V(RADFAC) IN TERMS OF THE INPUT
!             VALUE OF V(DSTNRM) -- SUGGESTED VALUE = 0.1.
! V(RDFCMX) (IN)  MAXIMUM VALUE FOR V(RADFAC) -- SUGGESTED VALUE = 4.0.
!  V(RELDX) (OUT) SCALED RELATIVE CHANGE IN X CAUSED BY STEP, COMPUTED
!             BY FUNCTION  RELDST  AS
!                 MAX (D(I)*ABS(X(I)-X0(I)), 1 .LE. I .LE. P) /
!                    MAX (D(I)*(ABS(X(I))+ABS(X0(I))), 1 .LE. I .LE. P).
!             IF AN ACCEPTABLE STEP IS RETURNED, THEN V(RELDX) IS COM-
!             PUTED USING THE OUTPUT (POSSIBLY RESTORED) VALUES OF X
!             AND STEP.  OTHERWISE IT IS COMPUTED USING THE INPUT
!             VALUES.
! V(RFCTOL) (IN)  RELATIVE FUNCTION CONVERGENCE TOLERANCE.  IF THE
!             ACTUAL FUNCTION REDUCTION IS AT MOST TWICE WHAT WAS PRE-
!             DICTED AND  V(NREDUC) .LE. V(RFCTOL)*ABS(V(F0)),  THEN
!             ASSESS RETURNS WITH IV(IRC) = 8 OR 9.  SEE ALSO V(LMAX0).
! V(STPPAR) (IN)  MARQUARDT PARAMETER -- 0 MEANS FULL NEWTON STEP.
! V(TUNER1) (IN)  TUNING CONSTANT USED TO DECIDE IF THE FUNCTION
!             REDUCTION WAS MUCH LESS THAN EXPECTED.  SUGGESTED
!             VALUE = 0.1.
! V(TUNER2) (IN)  TUNING CONSTANT USED TO DECIDE IF THE FUNCTION
!             REDUCTION WAS LARGE ENOUGH TO ACCEPT STEP.  SUGGESTED
!             VALUE = 10**-4.
! V(TUNER3) (IN)  TUNING CONSTANT USED TO DECIDE IF THE RADIUS
!             SHOULD BE INCREASED.  SUGGESTED VALUE = 0.75.
!  V(XCTOL) (IN)  X-CONVERGENCE CRITERION.  IF STEP IS A NEWTON STEP
!             (V(STPPAR) = 0) HAVING V(RELDX) .LE. V(XCTOL) AND GIVING
!             AT MOST TWICE THE PREDICTED FUNCTION DECREASE, THEN
!             ASSESS RETURNS IV(IRC) = 7 OR 9.
!  V(XFTOL) (IN)  FALSE CONVERGENCE TOLERANCE.  IF STEP GAVE NO OR ONLY
!             A SMALL FUNCTION DECREASE AND V(RELDX) .LE. V(XFTOL),
!             THEN ASSESS RETURNS WITH IV(IRC) = 12.
!
!-------------------------------  NOTES  -------------------------------
!
!  ***  APPLICATION AND USAGE RESTRICTIONS  ***
!
!        THIS ROUTINE IS CALLED AS PART OF THE NL2SOL (NONLINEAR
!     LEAST-SQUARES) PACKAGE.  IT MAY BE USED IN ANY UNCONSTRAINED
!     MINIMIZATION SOLVER THAT USES DOGLEG, GOLDFELD-QUANDT-TROTTER,
!     OR LEVENBERG-MARQUARDT STEPS.
!
!  ***  ALGORITHM NOTES  ***
!
!        SEE (1) FOR FURTHER DISCUSSION OF THE ASSESSING AND MODEL
!     SWITCHING STRATEGIES.  WHILE NL2SOL CONSIDERS ONLY TWO MODELS,
!     ASSESS IS DESIGNED TO HANDLE ANY NUMBER OF MODELS.
!
!  ***  USAGE NOTES  ***
!
!        ON THE FIRST CALL OF AN ITERATION, ONLY THE I/O VARIABLES
!     STEP, X, IV(IRC), IV(MODEL), V(F), V(DSTNRM), V(GTSTEP), AND
!     V(PREDUC) NEED HAVE BEEN INITIALIZED.  BETWEEN CALLS, NO I/O
!     VALUES EXECPT STEP, X, IV(MODEL), V(F) AND THE STOPPING TOLER-
!     ANCES SHOULD BE CHANGED.
!        AFTER A RETURN FOR CONVERGENCE OR FALSE CONVERGENCE, ONE CAN
!     CHANGE THE STOPPING TOLERANCES AND CALL ASSESS AGAIN, IN WHICH
!     CASE THE STOPPING TESTS WILL BE REPEATED.
!
!  ***  REFERENCES  ***
!
!     (1) DENNIS, J.E., JR., GAY, D.M., AND WELSCH, R.E. (1980),
!        AN ADAPTIVE NONLINEAR LEAST-SQUARES ALGORITHM,
!        SUBMITTED TO ACM TRANS. MATH. SOFTWARE.
!
!     (2) POWELL, M.J.D. (1970)  A FORTRAN SUBROUTINE FOR SOLVING
!        SYSTEMS OF NONLINEAR ALGEBRAIC EQUATIONS, IN NUMERICAL
!        METHODS FOR NONLINEAR ALGEBRAIC EQUATIONS, EDITED BY
!        P. RABINOWITZ, GORDON AND BREACH, LONDON.
!
!  ***  HISTORY  ***
!
!        JOHN DENNIS DESIGNED MUCH OF THIS ROUTINE, STARTING WITH
!     IDEAS IN (2). ROY WELSCH SUGGESTED THE MODEL SWITCHING STRATEGY.
!        DAVID GAY AND STEPHEN PETERS CAST THIS SUBROUTINE INTO A MORE
!     PORTABLE FORM (WINTER 1977), AND DAVID GAY CAST IT INTO ITS
!     PRESENT FORM (FALL 1978).
!
!  ***  GENERAL  ***
!
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!     MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989, AND
!     MCS-7906671.
!
!------------------------  EXTERNAL QUANTITIES  ------------------------
!
!  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***
!
!     EXTERNAL RELDST, VCOPY
!     REAL(KIND=WP) :: RELDST
!
! VCOPY.... COPIES ONE VECTOR TO ANOTHER.
!
!/
!  ***  NO COMMON BLOCKS  ***
!
!--------------------------  LOCAL VARIABLES  --------------------------
!
!     LOGICAL GOODX
!     INTEGER I, NFC
!     REAL(KIND=WP) :: EMAX, GTS, HALF, ONE, RELDX1, RFAC1,
!    +                 TEMP, TWO, XMAX, ZERO
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER AFCTOL, DECFAC, DSTNRM, DSTSAV, DST0, F, FDIF, FLSTGD, F0,
!    1        GTSLST, GTSTEP, INCFAC, IRC, LMAX0, MLSTGD, MODEL, NFCALL,
!    2        NFGCAL, NREDUC, PLSTGD, PREDUC, RADFAC, RADINC, RDFCMN,
!    3        RDFCMX, RELDX, RESTOR, RFCTOL, STAGE, STGLIM, STPPAR,
!    4        SWITCH, TOOBIG, TUNER1, TUNER2, TUNER3, XCTOL, XFTOL,
!    5        XIRC
!
!  ***  DATA INITIALIZATIONS  ***
!
      data half/0.5_wp/, one/1.0_wp/, two/2.0_wp/, zero/0.0_wp/
!
      data irc/3/, mlstgd/4/, model/5/, nfcall/6/,
     +     nfgcal/7/, radinc/8/, restor/9/, stage/10/,
     +     stglim/11/, switch/12/, toobig/2/, xirc/13/
      data afctol/31/, decfac/22/, dstnrm/2/, dst0/3/,
     +     dstsav/18/, f/10/, fdif/11/, flstgd/12/, f0/13/,
     +     gtslst/14/, gtstep/4/, incfac/23/,
     +     lmax0/35/, nreduc/6/, plstgd/15/, preduc/7/,
     +     radfac/16/, rdfcmn/24/, rdfcmx/25/,
     +     reldx/17/, rfctol/32/, stppar/5/, tuner1/26/,
     +     tuner2/27/, tuner3/28/, xctol/33/, xftol/34/
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
      nfc = iv(nfcall)
      iv(switch) = 0
      iv(restor) = 0
      rfac1 = one
      goodx = .true.
      i = iv(irc)
      if (i .ge. 1 .and. i .le. 12)
     +             go to (20,30,10,10,40,360,290,290,290,290,290,140), i
         iv(irc) = 13
         go to 999
!
!  ***  INITIALIZE FOR NEW ITERATION  ***
!
 10   iv(stage) = 1
      iv(radinc) = 0
      v(flstgd) = v(f0)
      if (iv(toobig) .eq. 0) go to 90
         iv(stage) = -1
         iv(xirc) = i
         go to 60
!
!  ***  STEP WAS RECOMPUTED WITH NEW MODEL OR SMALLER RADIUS  ***
!  ***  FIRST DECIDE WHICH  ***
!
 20   if (iv(model) .ne. iv(mlstgd)) go to 30
!        ***  OLD MODEL RETAINED, SMALLER RADIUS TRIED  ***
!        ***  DO NOT CONSIDER ANY MORE NEW MODELS THIS ITERATION  ***
         iv(stage) = iv(stglim)
         iv(radinc) = -1
         go to 90
!
!  ***  A NEW MODEL IS BEING TRIED.  DECIDE WHETHER TO KEEP IT.  ***
!
 30   iv(stage) = iv(stage) + 1
!
!     ***  NOW WE ADD THE POSSIBILTIY THAT STEP WAS RECOMPUTED WITH  ***
!     ***  THE SAME MODEL, PERHAPS BECAUSE OF AN OVERSIZED STEP.     ***
!
 40   if (iv(stage) .gt. 0) go to 50
!
!        ***  STEP WAS RECOMPUTED BECAUSE IT WAS TOO BIG.  ***
!
         if (iv(toobig) .ne. 0) go to 60
!
!        ***  RESTORE IV(STAGE) AND PICK UP WHERE WE LEFT OFF.  ***
!
         iv(stage) = -iv(stage)
         i = iv(xirc)
         go to (20, 30, 90, 90, 70), i
!
 50   if (iv(toobig) .eq. 0) go to 70
!
!  ***  HANDLE OVERSIZE STEP  ***
!
      if (iv(radinc) .gt. 0) go to 80
         iv(stage) = -iv(stage)
         iv(xirc) = iv(irc)
!
 60      v(radfac) = v(decfac)
         iv(radinc) = iv(radinc) - 1
         iv(irc) = 5
         go to 999
!
 70   if (v(f) .lt. v(flstgd)) go to 90
!
!     *** THE NEW STEP IS A LOSER.  RESTORE OLD MODEL.  ***
!
      if (iv(model) .eq. iv(mlstgd)) go to 80
         iv(model) = iv(mlstgd)
         iv(switch) = 1
!
!     ***  RESTORE STEP, ETC. ONLY IF A PREVIOUS STEP DECREASED V(F).
!
 80   if (v(flstgd) .ge. v(f0)) go to 90
         iv(restor) = 1
         v(f) = v(flstgd)
         v(preduc) = v(plstgd)
         v(gtstep) = v(gtslst)
         if (iv(switch) .eq. 0) rfac1 = v(dstnrm) / v(dstsav)
         v(dstnrm) = v(dstsav)
         nfc = iv(nfgcal)
         goodx = .false.
!
!
!  ***  COMPUTE RELATIVE CHANGE IN X BY CURRENT STEP  ***
!
 90   reldx1 = reldst(p, d, x, x0)
!
!  ***  RESTORE X AND STEP IF NECESSARY  ***
!
      if (goodx) go to 105
      do 100 i = 1, p
         step(i) = stlstg(i)
         x(i) = x0(i) + stlstg(i)
 100     continue
!
 105  v(fdif) = v(f0) - v(f)
      temp = 0.0
      if (v(preduc).gt.mach(1)/v(tuner2)) temp = v(tuner2) * v(preduc)
      if (v(fdif).gt.temp) go to 120
!
!        ***  NO (OR ONLY A TRIVIAL) FUNCTION DECREASE
!        ***  -- SO TRY NEW MODEL OR SMALLER RADIUS
!
         v(reldx) = reldx1
         if (v(f) .lt. v(f0)) go to 110
              iv(mlstgd) = iv(model)
              v(flstgd) = v(f)
              v(f) = v(f0)
              call vcopy(p, x, x0)
              iv(restor) = 1
              go to 115
 110     iv(nfgcal) = nfc
 115     iv(irc) = 1
         if (iv(stage) .lt. iv(stglim)) go to 130
              iv(irc) = 5
              iv(radinc) = iv(radinc) - 1
              go to 130
!
!  ***  NONTRIVIAL FUNCTION DECREASE ACHIEVED  ***
!
 120  iv(nfgcal) = nfc
      rfac1 = one
      if (goodx) v(reldx) = reldx1
      v(dstsav) = v(dstnrm)
      if (v(fdif) .gt. v(preduc)*v(tuner1)) go to 200
!
!  ***  DECREASE WAS MUCH LESS THAN PREDICTED -- EITHER CHANGE MODELS
!  ***  OR ACCEPT STEP WITH DECREASED RADIUS.
!
      if (iv(stage) .ge. iv(stglim)) go to 125
!        ***  CONSIDER SWITCHING MODELS  ***
         iv(irc) = 2
         go to 130
!
!     ***  ACCEPT STEP WITH DECREASED RADIUS  ***
!
 125  iv(irc) = 4
!
!  ***  SET V(RADFAC) TO FLETCHER*S DECREASE FACTOR  ***
!
 130  iv(xirc) = iv(irc)
      emax = v(gtstep) + v(fdif)
      v(radfac) = half * rfac1
      if (emax .lt. v(gtstep)) v(radfac) = rfac1 * max(v(rdfcmn),
     +                                           half * v(gtstep)/emax)
!
!  ***  DO FALSE CONVERGENCE TEST  ***
!
 140  if (v(reldx) .le. v(xftol)) go to 160
         iv(irc) = iv(xirc)
         if (v(f) .lt. v(f0)) go to 230
              go to 300
!
 160  iv(irc) = 12
      go to 310
!
!  ***  HANDLE GOOD FUNCTION DECREASE  ***
!
 200  if (v(fdif) .lt. (-v(tuner3) * v(gtstep))) go to 260
!
!     ***  INCREASING RADIUS LOOKS WORTHWHILE.  SEE IF WE JUST
!     ***  RECOMPUTED STEP WITH A DECREASED RADIUS OR RESTORED STEP
!     ***  AFTER RECOMPUTING IT WITH A LARGER RADIUS.
!
      if (iv(radinc) .lt. 0) go to 260
      if (iv(restor) .eq. 1) go to 260
!
!        ***  WE DID NOT.  TRY A LONGER STEP UNLESS THIS WAS A NEWTON
!        ***  STEP.
!
         v(radfac) = v(rdfcmx)
         gts = v(gtstep)
         if (v(fdif) .lt. (half/v(radfac) - one) * gts)
     +            v(radfac) = max(v(incfac), half*gts/(gts + v(fdif)))
         iv(irc) = 4
         if (v(stppar) .eq. zero) go to 300
!             ***  STEP WAS NOT A NEWTON STEP.  RECOMPUTE IT WITH
!             ***  A LARGER RADIUS.
              iv(irc) = 5
              iv(radinc) = iv(radinc) + 1
!
!  ***  SAVE VALUES CORRESPONDING TO GOOD STEP  ***
!
 230  v(flstgd) = v(f)
      iv(mlstgd) = iv(model)
      call vcopy(p, stlstg, step)
      v(dstsav) = v(dstnrm)
      iv(nfgcal) = nfc
      v(plstgd) = v(preduc)
      v(gtslst) = v(gtstep)
      go to 300
!
!  ***  ACCEPT STEP WITH RADIUS UNCHANGED  ***
!
 260  v(radfac) = one
      iv(irc) = 3
      go to 300
!
!  ***  COME HERE FOR A RESTART AFTER CONVERGENCE  ***
!
 290  iv(irc) = iv(xirc)
      if (v(dstsav) .ge. zero) go to 310
         iv(irc) = 12
         go to 310
!
!  ***  PERFORM CONVERGENCE TESTS  ***
!
 300  iv(xirc) = iv(irc)
 310  if (abs(v(f)) .lt. v(afctol)) iv(irc) = 10
      if (half * v(fdif) .gt. v(preduc)) go to 999
      emax = 0.0
      if (abs(v(f0)).gt.mach(1)/v(rfctol))
     +   emax = v(rfctol) * abs(v(f0))
      if (v(dstnrm) .gt. v(lmax0) .and. v(preduc) .le. emax)
     +                       iv(irc) = 11
      if (v(dst0) .lt. zero) go to 320
      i = 0
      if ((v(nreduc) .gt. zero .and. v(nreduc) .le. emax) .or.
     +    (v(nreduc) .eq. zero. and. v(preduc) .eq. zero))  i = 2
      if (v(stppar) .eq. zero .and. v(reldx) .le. v(xctol)) i = i + 1
      if (i .gt. 0) iv(irc) = i + 6
!
!  ***  CONSIDER RECOMPUTING STEP OF LENGTH V(LMAX0) FOR SINGULAR
!  ***  CONVERGENCE TEST.
!
 320  if (abs(iv(irc)-3) .gt. 1 .and. iv(irc) .ne. 12) go to 999
      if (v(dstnrm) .gt. v(lmax0)) go to 330
         if (v(preduc) .ge. emax) go to 999
              if (v(dst0) .lt. zero) go to 340
                   if (half * v(dst0) .le. v(lmax0)) go to 999
                        go to 340
 330  if (half * v(dstnrm) .le. v(lmax0)) go to 999
      xmax = v(lmax0) / v(dstnrm)
      if (xmax * (two - xmax) * v(preduc) .ge. emax) go to 999
 340  if (v(nreduc) .lt. zero) go to 370
!
!  ***  RECOMPUTE V(PREDUC) FOR USE IN SINGULAR CONVERGENCE TEST  ***
!
      v(gtslst) = v(gtstep)
      v(dstsav) = v(dstnrm)
      if (iv(irc) .eq. 12) v(dstsav) = -v(dstsav)
      v(plstgd) = v(preduc)
      iv(irc) = 6
      call vcopy(p, stlstg, step)
      go to 999
!
!  ***  PERFORM SINGULAR CONVERGENCE TEST WITH RECOMPUTED V(PREDUC)  ***
!
 360  v(gtstep) = v(gtslst)
      v(dstnrm) = abs(v(dstsav))
      call vcopy(p, step, stlstg)
      iv(irc) = iv(xirc)
      if (v(dstsav) .le. zero) iv(irc) = 12
      v(nreduc) = -v(preduc)
      v(preduc) = v(plstgd)
 370  if (-v(nreduc) .le. v(rfctol) * abs(v(f0))) iv(irc) = 11
!
 999  return
!
!  ***  LAST CARD OF ASSESS FOLLOWS  ***
      end
!NL2ITR
      subroutine nl2itr (d, iv, j, n, nn, p, r, v, x)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!  ***  CARRY OUT NL2SOL (NONLINEAR LEAST-SQUARES) ITERATIONS  ***
!  ***  (NL2SOL VERSION 2.2)  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer n,nn,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: d(p),j(nn,p),r(n),v(*),x(p)
      integer iv(*)
!
!  LOCAL SCALARS
      real(kind=wp) :: e,half,negone,one,rdof1,sttsst,t,t1,zero
      integer
     +   cnvcod,cosmin,covmat,covprt,covreq,d0init,dgnorm,dig,dig1,
     +   dinit,dstnrm,dtype,dummy,f,f0,fdif,fuzz,g,g01,g1,gtstep,h,
     +   h0,h1,i,ierr,im1,incfac,inits,ipiv0,ipiv1,ipivi,ipivk,
     +   ipivot,ipk,irc,jtinit,jtol1,k,kagqt,kalm,km1,l,lky,lky1,
     +   lmat,lmat1,lmax0,lstgst,m,mode,model,mxfcal,mxiter,nfcall,
     +   nfcov,nfgcal,ngcall,ngcov,niter,nvsave,phmxfc,pp1o2,
     +   preduc,qtr,qtr1,rad0,radfac,radinc,radius,rd,rd0,rd1,rdk,
     +   restor,rlimit,rsave,rsave1,s,s1,size,smh,sstep,step,step1,
     +   stglim,stlstg,stpmod,stppar,sused,switch,temp1,temp2,
     +   toobig,tuner4,tuner5,vsave1,w,w1,wscale,x0,x01,xirc
!
!  EXTERNAL FUNCTIONS
      real(kind=wp) :: dotprd,v2norm
      logical stopx
      external dotprd,v2norm,stopx
!
!  EXTERNAL SUBROUTINES
      external assess,covclc,dupdat,gqtstp,itsmry,lmstep,parchk,qapply,
     +   qrfact,rptmul,slupdt,slvmul,vaxpy,vcopy,vscopy
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,sqrt
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER IV(1), N, NN, P
!     REAL(KIND=WP) :: D(P), J(NN,P), R(N), V(1), X(P)
!     DIMENSION IV(60+P), V(93 + 2*N + P*(3*P+31)/2)
!
!
!--------------------------  PARAMETER USAGE  --------------------------
!
! D.... SCALE VECTOR.
! IV... INTEGER VALUE ARRAY.
! J.... N BY P JACOBIAN MATRIX (LEAD DIMENSION NN).
! N.... NUMBER OF OBSERVATIONS (COMPONENTS IN R).
! NN... LEAD DIMENSION OF J.
! P.... NUMBER OF PARAMETERS (COMPONENTS IN X).
! R.... RESIDUAL VECTOR.
! V.... FLOATING-POINT VALUE ARRAY.
! X.... PARAMETER VECTOR.
!
!  ***  DISCUSSION  ***
!
!        PARAMETERS IV, N, P, V, AND X ARE THE SAME AS THE CORRESPOND-
!     ING ONES TO NL2SOL (WHICH SEE), EXCEPT THAT V CAN BE SHORTER
!     (SINCE THE PART OF V THAT NL2SOL USES FOR STORING D, J, AND R IS
!     NOT NEEDED).  MOREOVER, COMPARED WITH NL2SOL, IV(1) MAY HAVE THE
!     TWO ADDITIONAL OUTPUT VALUES 1 AND 2, WHICH ARE EXPLAINED BELOW,
!     AS IS THE USE OF IV(TOOBIG) AND IV(NFGCAL).  THE VALUES IV(D),
!     IV(J), AND IV(R), WHICH ARE OUTPUT VALUES FROM NL2SOL (AND
!     NL2SNO), ARE NOT REFERENCED BY NL2ITR OR THE SUBROUTINES IT CALLS.
!        ON A FRESH START, I.E., A CALL ON NL2ITR WITH IV(1) = 0 OR 12,
!     NL2ITR ASSUMES THAT R = R(X), THE RESIDUAL AT X, AND J = J(X),
!     THE CORRESPONDING JACOBIAN MATRIX OF R AT X.
!
! IV(1) = 1 MEANS THE CALLER SHOULD SET R TO R(X), THE RESIDUAL AT X,
!             AND CALL NL2ITR AGAIN, HAVING CHANGED NONE OF THE OTHER
!             PARAMETERS.  AN EXCEPTION OCCURS IF R CANNOT BE EVALUATED
!             AT X (E.G. IF R WOULD OVERFLOW), WHICH MAY HAPPEN BECAUSE
!             OF AN OVERSIZED STEP.  IN THIS CASE THE CALLER SHOULD SET
!             IV(TOOBIG) = IV(2) TO 1, WHICH WILL CAUSE NL2ITR TO IG-
!             NORE R AND TRY A SMALLER STEP.  THE PARAMETER NF THAT
!             NL2SOL PASSES TO CALCR (FOR POSSIBLE USE BY CALCJ) IS A
!             COPY OF IV(NFCALL) = IV(6).
! IV(1) = 2 MEANS THE CALLER SHOULD SET J TO J(X), THE JACOBIAN MATRIX
!             OF R AT X, AND CALL NL2ITR AGAIN.  THE CALLER MAY CHANGE
!             D AT THIS TIME, BUT SHOULD NOT CHANGE ANY OF THE OTHER
!             PARAMETERS.  THE PARAMETER NF THAT NL2SOL PASSES TO
!             CALCJ IS IV(NFGCAL) = IV(7).  IF J CANNOT BE EVALUATED
!             AT X, THEN THE CALLER MAY SET IV(NFGCAL) TO 0, IN WHICH
!             CASE NL2ITR WILL RETURN WITH IV(1) = 15.
!
!  ***  GENERAL  ***
!
!     CODED BY DAVID M. GAY.
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!
!     MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989, AND
!     MCS-7906671.
!        (SEE NL2SOL FOR REFERENCES.)
!
!+++++++++++++++++++++++++++  DECLARATIONS  ++++++++++++++++++++++++++++
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER DUMMY, DIG1, G1, G01, H0, H1, I, IM1, IPIVI, IPIVK, IPIV1,
!    1        IPK, K, KM1, L, LKY1, LMAT1, LSTGST, M, PP1O2, QTR1,
!    2        RDK, RD0, RD1, RSAVE1, SMH, SSTEP, STEP1, STPMOD, S1,
!    3        TEMP1, TEMP2, W1, X01
!     REAL(KIND=WP) :: E, RDOF1, STTSST, T, T1
!
!     ***  CONSTANTS  ***
!
!     REAL(KIND=WP) :: HALF, NEGONE, ONE, ZERO
!
!/
!  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***
!
!     EXTERNAL ASSESS, COVCLC, DOTPRD, DUPDAT, GQTSTP, ITSMRY, LMSTEP,
!    1         PARCHK, QAPPLY, QRFACT, RPTMUL, SLUPDT, SLVMUL, STOPX,
!    2         VAXPY, VCOPY, VSCOPY, V2NORM
!     LOGICAL STOPX
!     REAL(KIND=WP) :: DOTPRD, V2NORM
!
! ASSESS... ASSESSES CANDIDATE STEP.
! COVCLC... COMPUTES COVARIANCE MATRIX.
! DOTPRD... RETURNS INNER PRODUCT OF TWO VECTORS.
! DUPDAT... UPDATES SCALE VECTOR D.
! GQTSTP... COMPUTES GOLDFELD-QUANDT-TROTTER STEP (AUGMENTED MODEL).
! ITSMRY... PRINTS ITERATION SUMMARY AND INFO ABOUT INITIAL AND FINAL X.
! LMSTEP... COMPUTES LEVENBERG-MARQUARDT STEP (GAUSS-NEWTON MODEL).
! PARCHK... CHECKS VALIDITY OF INPUT IV AND V VALUES.
! QAPPLY... APPLIES ORTHOGONAL MATRIX Q FROM QRFACT TO A VECTOR.
! QRFACT... COMPUTES QR DECOMPOSITION OF A MATRIX VIA HOUSEHOLDER TRANS.
! RPTMUL... MULTIPLIES VECTOR BY THE R MATRIX (AND/OR ITS TRANSPOSE)
!             STORED BY QRFACT.
! SLUPDT... PERFORMS QUASI-NEWTON UPDATE ON COMPACTLY STORED LOWER TRI-
!             ANGLE OF A SYMMETRIC MATRIX.
! STOPX.... RETURNS .TRUE. IF THE BREAK KEY HAS BEEN PRESSED.
! VAXPY.... COMPUTES SCALAR TIMES ONE VECTOR PLUS ANOTHER.
! VCOPY.... COPIES ONE VECTOR TO ANOTHER.
! VSCOPY... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.
! V2NORM... RETURNS THE 2-NORM OF A VECTOR.
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER CNVCOD, COSMIN, COVMAT, COVPRT, COVREQ, DGNORM, DIG,
!    1        DINIT, DSTNRM, DTYPE, D0INIT, F, FDIF, FUZZ,
!    2        F0, G, GTSTEP, H, IERR, INCFAC, INITS, IPIVOT, IPIV0, IRC,
!    3        JTINIT, JTOL1, KAGQT, KALM, LKY, LMAT, LMAX0, MODE, MODEL,
!    4        MXFCAL, MXITER, NFCALL, NFGCAL, NFCOV, NGCOV, NGCALL,
!    5        NITER, NVSAVE, PHMXFC, PREDUC, QTR, RADFAC, RADINC,
!    6        RADIUS, RAD0, RD, RESTOR, RLIMIT, RSAVE, S, SIZE, STEP,
!    7        STGLIM, STLSTG, STPPAR, SUSED, SWITCH, TOOBIG, TUNER4,
!    8        TUNER5, VSAVE1, W, WSCALE, XIRC, X0
!
!  ***  IV SUBSCRIPT VALUES  ***
!
      data cnvcod/34/, covmat/26/, covprt/14/,
     +     covreq/15/, dig/43/, dtype/16/, g/28/, h/44/,
     +     ierr/32/, inits/25/, ipivot/61/, ipiv0/60/,
     +     irc/3/, kagqt/35/, kalm/36/, lky/37/, lmat/58/,
     +     mode/38/, model/5/, mxfcal/17/, mxiter/18/,
     +     nfcall/6/, nfgcal/7/, nfcov/40/, ngcov/41/,
     +     ngcall/30/, niter/31/, qtr/49/,
     +     radinc/8/, rd/51/, restor/9/, rsave/52/, s/53/,
     +     step/55/, stglim/11/, stlstg/56/, sused/57/,
     +     switch/12/, toobig/2/, w/59/, xirc/13/, x0/60/
!
!  ***  V SUBSCRIPT VALUES  ***
!
      data cosmin/43/, dgnorm/1/, dinit/38/, dstnrm/2/,
     +     d0init/37/, f/10/, fdif/11/, fuzz/45/,
     +     f0/13/, gtstep/4/, incfac/23/,
     +     jtinit/39/, jtol1/87/, lmax0/35/,
     +     nvsave/9/, phmxfc/21/, preduc/7/,
     +     radfac/16/, radius/8/, rad0/9/, rlimit/42/,
     +     size/47/, stppar/5/, tuner4/29/, tuner5/30/,
     +     vsave1/78/, wscale/48/
!
!
      data half/0.5_wp/, negone/-1.0_wp/, one/1.0_wp/, zero/0.0_wp/
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
      i = iv(1)
      if (i .eq. 1) go to 20
      if (i .eq. 2) go to 50
!
!  ***  CHECK VALIDITY OF IV AND V INPUT VALUES  ***
!
!     ***  NOTE -- IF IV(1) = 0, THEN PARCHK CALLS DFAULT(IV, V)  ***
      call parchk(iv, n, nn, p, v)
      i = iv(1) - 2
      if (i .gt. 10) go to 999
      go to (350, 350, 350, 350, 350, 350, 195, 160, 195, 10), i
!
!  ***  INITIALIZATION AND STORAGE ALLOCATION  ***
!
 10   iv(niter) = 0
      iv(nfcall) = 1
      iv(ngcall) = 1
      iv(nfgcal) = 1
      iv(mode) = -1
      iv(stglim) = 2
      iv(toobig) = 0
      iv(cnvcod) = 0
      iv(covmat) = 0
      iv(nfcov) = 0
      iv(ngcov) = 0
      iv(kalm) = -1
      iv(radinc) = 0
      iv(s) = jtol1 + 2*p
      pp1o2 = p * (p + 1) / 2
      iv(x0) = iv(s) + pp1o2
      iv(step) = iv(x0) + p
      iv(stlstg) = iv(step) + p
      iv(dig) = iv(stlstg) + p
      iv(g) = iv(dig) + p
      iv(lky) = iv(g) + p
      iv(rd) = iv(lky) + p
      iv(rsave) = iv(rd) + p
      iv(qtr) = iv(rsave) + n
      iv(h) = iv(qtr) + n
      iv(w) = iv(h) + pp1o2
      iv(lmat) = iv(w) + 4*p + 7
!     +++ LENGTH OF W = P*(P+9)/2 + 7.  LMAT IS CONTAINED IN W.
      if (v(dinit) .ge. zero) call vscopy(p, d, v(dinit))
      if (v(jtinit) .gt. zero) call vscopy(p, v(jtol1), v(jtinit))
      i = jtol1 + p
      if (v(d0init) .gt. zero) call vscopy(p, v(i), v(d0init))
      v(rad0) = zero
      v(stppar) = zero
      v(radius) = v(lmax0) / (one + v(phmxfc))
!
!  ***  SET INITIAL MODEL AND S MATRIX  ***
!
      iv(model) = 1
      if (iv(inits) .eq. 2) iv(model) = 2
      s1 = iv(s)
      if (iv(inits) .eq. 0) call vscopy(pp1o2, v(s1), zero)
!
!  ***  COMPUTE FUNCTION VALUE (HALF THE SUM OF SQUARES)  ***
!
 20   t = v2norm(n, r)
      if (t .gt. v(rlimit)) iv(toobig) = 1
      if (iv(toobig) .ne. 0) go to 30
      v(f) = 0.0
      if (t.gt.sqrt(mach(1))) v(f) = half * t**2
 30   if (iv(mode)) 40, 350, 730
!
 40   if (iv(toobig) .eq. 0) go to 60
         iv(1) = 13
         go to 900
!
!  ***  MAKE SURE JACOBIAN COULD BE COMPUTED  ***
!
 50   if (iv(nfgcal) .ne. 0) go to 60
         iv(1) = 15
         go to 900
!
!  ***  COMPUTE GRADIENT  ***
!
 60   iv(kalm) = -1
      g1 = iv(g)
      do 70 i = 1, p
         v(g1) = dotprd(n, r, j(1,i))
         g1 = g1 + 1
 70      continue
      if (iv(mode) .gt. 0) go to 710
!
!  ***  UPDATE D AND MAKE COPIES OF R FOR POSSIBLE USE LATER  ***
!
      if (iv(dtype) .gt. 0) call dupdat(d, iv, j, n, nn, p, v)
      rsave1 = iv(rsave)
      call vcopy(n, v(rsave1), r)
      qtr1 = iv(qtr)
      call vcopy(n, v(qtr1), r)
!
!  ***  COMPUTE  D**-1 * GRADIENT  ***
!
      g1 = iv(g)
      dig1 = iv(dig)
      k = dig1
      do 80 i = 1, p
         v(k) = v(g1) / d(i)
         k = k + 1
         g1 = g1 + 1
 80      continue
      v(dgnorm) = v2norm(p, v(dig1))
!
      if (iv(cnvcod) .ne. 0) go to 700
      if (iv(mode) .eq. 0) go to 570
      iv(mode) = 0
!
!
!-----------------------------  MAIN LOOP  -----------------------------
!
!
!  ***  PRINT ITERATION SUMMARY, CHECK ITERATION LIMIT  ***
!
 150  call itsmry(d, iv, p, v, x)
 160  k = iv(niter)
      if (k .lt. iv(mxiter)) go to 170
         iv(1) = 10
         go to 900
 170  iv(niter) = k + 1
!
!  ***  UPDATE RADIUS  ***
!
      if (k .eq. 0) go to 185
      step1 = iv(step)
      do 180 i = 1, p
         v(step1) = d(i) * v(step1)
         step1 = step1 + 1
 180     continue
      step1 = iv(step)
      v(radius) = v(radfac) * v2norm(p, v(step1))
!
!  ***  INITIALIZE FOR START OF NEXT ITERATION  ***
!
 185  x01 = iv(x0)
      v(f0) = v(f)
      iv(kagqt) = -1
      iv(irc) = 4
      iv(h) = -abs(iv(h))
      iv(sused) = iv(model)
!
!     ***  COPY X TO X0  ***
!
      call vcopy(p, v(x01), x)
!
!  ***  CHECK STOPX AND FUNCTION EVALUATION LIMIT  ***
!
 190  if (.not. stopx(dummy)) go to 200
         iv(1) = 11
         go to 205
!
!     ***  COME HERE WHEN RESTARTING AFTER FUNC. EVAL. LIMIT OR STOPX.
!
 195  if (v(f) .ge. v(f0)) go to 200
         v(radfac) = one
         k = iv(niter)
         go to 170
!
 200  if (iv(nfcall) .lt. iv(mxfcal) + iv(nfcov)) go to 210
         iv(1) = 9
 205     if (v(f) .ge. v(f0)) go to 900
!
!        ***  IN CASE OF STOPX OR FUNCTION EVALUATION LIMIT WITH
!        ***  IMPROVED V(F), EVALUATE THE GRADIENT AT X.
!
              iv(cnvcod) = iv(1)
              go to 560
!
!. . . . . . . . . . . . .  COMPUTE CANDIDATE STEP  . . . . . . . . . .
!
 210  step1 = iv(step)
      w1 = iv(w)
      if (iv(model) .eq. 2) go to 240
!
!  ***  COMPUTE LEVENBERG-MARQUARDT STEP  ***
!
         qtr1 = iv(qtr)
         if (iv(kalm) .ge. 0) go to 215
              rd1 = iv(rd)
              if (-1 .eq. iv(kalm)) call qrfact(nn, n, p, j, v(rd1),
     +                                   iv(ipivot), iv(ierr), 0, v(w1))
              call qapply(nn, n, p, j, v(qtr1), iv(ierr))
 215     h1 = iv(h)
         if (h1 .gt. 0) go to 230
!
!        ***  COPY R MATRIX TO H  ***
!
              h1 = -h1
              iv(h) = h1
              k = h1
              rd1 = iv(rd)
              v(k) = v(rd1)
              if (p .eq. 1) go to 230
              do 220 i = 2, p
                   call vcopy(i-1, v(k+1), j(1,i))
                   k = k + i
                   rd1 = rd1 + 1
                   v(k) = v(rd1)
 220               continue
!
 230     g1 = iv(g)
         call lmstep(d, v(g1), iv(ierr), iv(ipivot), iv(kalm), p,
     +               v(qtr1), v(h1), v(step1), v, v(w1))
         go to 310
!
!  ***  COMPUTE GOLDFELD-QUANDT-TROTTER STEP (AUGMENTED MODEL)  ***
!
 240  if (iv(h) .gt. 0) go to 300
!
!     ***  SET H TO  D**-1 * ( (J**T)*J + S) ) * D**-1.  ***
!
         h1 = -iv(h)
         iv(h) = h1
         s1 = iv(s)
         if (iv(kalm) .ge. 0) go to 270
!
!        ***  J IS IN ITS ORIGINAL FORM  ***
!
              do 260 i = 1, p
                   t = one / d(i)
                   do 250 k = 1, i
                        v(h1) = t*(dotprd(n,j(1,i),j(1,k))+v(s1)) / d(k)
                        h1 = h1 + 1
                        s1 = s1 + 1
 250                    continue
 260               continue
              go to 300
!
!  ***  LMSTEP HAS APPLIED QRFACT TO J  ***
!
 270     smh = s1 - h1
         h0 = h1 - 1
         ipiv1 = iv(ipivot)
         t1 = one / d(ipiv1)
         rd0 = iv(rd) - 1
         rdof1 = v(rd0 + 1)
         do 290 i = 1, p
              l = ipiv0 + i
              ipivi = iv(l)
              h1 = h0 + ipivi*(ipivi-1)/2
              l = h1 + ipivi
              m = l + smh
!             ***  V(L) = H(IPIVOT(I), IPIVOT(I))  ***
!             ***  V(M) = S(IPIVOT(I), IPIVOT(I))  ***
              t = one / d(ipivi)
              rdk = rd0 + i
              e = v(rdk)**2
              if (i .gt. 1) e = e + dotprd(i-1, j(1,i), j(1,i))
              v(l) = (e + v(m)) * t**2
              if (i .eq. 1) go to 290
              l = h1 + ipiv1
              if (ipivi .lt. ipiv1) l = l +
     +                               ((ipiv1-ipivi)*(ipiv1+ipivi-3))/2
              m = l + smh
!             ***  V(L) = H(IPIVOT(I), IPIVOT(1))  ***
!             ***  V(M) = S(IPIVOT(I), IPIVOT(1))  ***
              v(l) = t * (rdof1 * j(1,i)  +  v(m)) * t1
              if (i .eq. 2) go to 290
              im1 = i - 1
              do 280 k = 2, im1
                   ipk = ipiv0 + k
                   ipivk = iv(ipk)
                   l = h1 + ipivk
                   if (ipivi .lt. ipivk) l = l +
     +                               ((ipivk-ipivi)*(ipivk+ipivi-3))/2
                   m = l + smh
!                  ***  V(L) = H(IPIVOT(I), IPIVOT(K))  ***
!                  ***  V(M) = S(IPIVOT(I), IPIVOT(K))  ***
                   km1 = k - 1
                   rdk = rd0 + k
                   v(l) = t * (dotprd(km1, j(1,i), j(1,k)) +
     +                            v(rdk)*j(k,i) + v(m)) / d(ipivk)
 280               continue
 290          continue
!
!  ***  COMPUTE ACTUAL GOLDFELD-QUANDT-TROTTER STEP  ***
!
 300  h1 = iv(h)
      dig1 = iv(dig)
      lmat1 = iv(lmat)
      call gqtstp(d, v(dig1), v(h1), iv(kagqt), v(lmat1), p, v(step1),
     +            v, v(w1))
!
!
!  ***  COMPUTE R(X0 + STEP)  ***
!
 310  if (iv(irc) .eq. 6) go to 350
      x01 = iv(x0)
      step1 = iv(step)
      call vaxpy(p, x, one, v(step1), v(x01))
      iv(nfcall) = iv(nfcall) + 1
      iv(1) = 1
      iv(toobig) = 0
      go to 999
!
!. . . . . . . . . . . . .  ASSESS CANDIDATE STEP  . . . . . . . . . . .
!
 350  step1 = iv(step)
      lstgst = iv(stlstg)
      x01 = iv(x0)
      call assess(d, iv, p, v(step1), v(lstgst), v, x, v(x01))
!
!  ***  IF NECESSARY, SWITCH MODELS AND/OR RESTORE R  ***
!
      if (iv(switch) .eq. 0) go to 360
         iv(h) = -abs(iv(h))
         iv(sused) = iv(sused) + 2
         call vcopy(nvsave, v, v(vsave1))
 360  if (iv(restor) .eq. 0) go to 390
         rsave1 = iv(rsave)
         call vcopy(n, r, v(rsave1))
 390  l = iv(irc) - 4
      stpmod = iv(model)
      if (l .gt. 0) go to (410,440,450,450,450,450,450,450,640,570), l
!
!  ***  DECIDE WHETHER TO CHANGE MODELS  ***
!
      e = v(preduc) - v(fdif)
      sstep = iv(lky)
      s1 = iv(s)
      call slvmul(p, v(sstep), v(s1), v(step1))
      sttsst = half * dotprd(p, v(step1), v(sstep))
      if (iv(model) .eq. 1) sttsst = -sttsst
      if (abs(e + sttsst) * v(fuzz) .ge. abs(e)) go to 400
!
!     ***  SWITCH MODELS  ***
!
         iv(model) = 3 - iv(model)
         if (iv(model) .eq. 1) iv(kagqt) = -1
         if (iv(model) .eq. 2 .and. iv(kalm) .gt. 0) iv(kalm) = 0
         if (-2 .lt. l) go to 480
              iv(h) = -abs(iv(h))
              iv(sused) = iv(sused) + 2
              call vcopy(nvsave, v(vsave1), v)
              go to 420
!
 400  if (-3 .lt. l) go to 480
!
!     ***  RECOMPUTE STEP WITH DECREASED RADIUS  ***
!
         v(radius) = v(radfac) * v(dstnrm)
         go to 190
!
!  ***  RECOMPUTE STEP, SAVING V VALUES AND R IF NECESSARY  ***
!
 410  v(radius) = v(radfac) * v(dstnrm)
 420  if (v(f) .ge. v(f0)) go to 190
      rsave1 = iv(rsave)
      call vcopy(n, v(rsave1), r)
      go to 190
!
!  ***  COMPUTE STEP OF LENGTH V(LMAX0) FOR SINGULAR CONVERGENCE TEST
!
 440  v(radius) = v(lmax0)
      go to 210
!
!  ***  CONVERGENCE OR FALSE CONVERGENCE  ***
!
 450  iv(cnvcod) = l
      if (v(f) .ge. v(f0)) go to 700
         if (iv(xirc) .eq. 14) go to 700
              iv(xirc) = 14
!
!. . . . . . . . . . . .  PROCESS ACCEPTABLE STEP  . . . . . . . . . . .
!
 480  iv(covmat) = 0
!
!  ***  SET  LKY = (J(X0)**T) * R(X)  ***
!
      lky1 = iv(lky)
      if (iv(kalm) .ge. 0) go to 500
!
!     ***  JACOBIAN HAS NOT BEEN MODIFIED  ***
!
         do 490 i = 1, p
              v(lky1) = dotprd(n, j(1,i), r)
              lky1 = lky1 + 1
 490          continue
         go to 510
!
!  ***  QRFACT HAS BEEN APPLIED TO J.  STORE COPY OF R IN QTR AND  ***
!  ***  APPLY Q TO IT.                                             ***
!
 500  qtr1 = iv(qtr)
      call vcopy(n, v(qtr1), r)
      call qapply(nn, n, p, j, v(qtr1), iv(ierr))
!
!  ***  MULTIPLY TOP P-VECTOR IN QTR BY PERMUTED UPPER TRIANGLE    ***
!  ***  STORED BY QRFACT IN J AND RD.                              ***
!
      rd1 = iv(rd)
      temp1 = iv(stlstg)
      call rptmul(3, iv(ipivot), j, nn, p, v(rd1), v(qtr1), v(lky1),
     +            v(temp1))
!
!  ***  SEE WHETHER TO SET V(RADFAC) BY GRADIENT TESTS  ***
!
 510  if (iv(irc) .ne. 3) go to 560
         step1 = iv(step)
         temp1 = iv(stlstg)
         temp2 = iv(x0)
!
!     ***  SET  TEMP1 = HESSIAN * STEP  FOR USE IN GRADIENT TESTS  ***
!
         if (stpmod .eq. 2) go to 530
!
!        ***  STEP COMPUTED USING GAUSS-NEWTON MODEL  ***
!        ***  -- QRFACT HAS BEEN APPLIED TO J         ***
!
              rd1 = iv(rd)
              call rptmul(2, iv(ipivot), j, nn, p, v(rd1),
     +                    v(step1), v(temp1), v(temp2))
              go to 560
!
!     ***  STEP COMPUTED USING AUGMENTED MODEL  ***
!
 530     h1 = iv(h)
         k = temp2
         do 540 i = 1, p
              v(k) = d(i) * v(step1)
              k = k + 1
              step1 = step1 + 1
 540          continue
         call slvmul(p, v(temp1), v(h1), v(temp2))
         do 550 i = 1, p
              v(temp1) = d(i) * v(temp1)
              temp1 = temp1 + 1
 550          continue
!
!  ***  SAVE OLD GRADIENT AND COMPUTE NEW ONE  ***
!
 560  iv(ngcall) = iv(ngcall) + 1
      g1 = iv(g)
      g01 = iv(w)
      call vcopy(p, v(g01), v(g1))
      iv(1) = 2
      go to 999
!
!  ***  INITIALIZATIONS -- G0 = G - G0, ETC.  ***
!
 570  g01 = iv(w)
      g1 = iv(g)
      call vaxpy(p, v(g01), negone, v(g01), v(g1))
      step1 = iv(step)
      temp1 = iv(stlstg)
      temp2 = iv(x0)
      if (iv(irc) .ne. 3) go to 600
!
!  ***  SET V(RADFAC) BY GRADIENT TESTS  ***
!
!     ***  SET  TEMP1 = D**-1 * (HESSIAN * STEP  +  (G(X0) - G(X)))  ***
!
         k = temp1
         l = g01
         do 580 i = 1, p
              v(k) = (v(k) - v(l)) / d(i)
              k = k + 1
              l = l + 1
 580          continue
!
!        ***  DO GRADIENT TESTS  ***
!
         if (v2norm(p, v(temp1)) .le. v(dgnorm) * v(tuner4))  go to 590
              if (dotprd(p, v(g1), v(step1))
     +                  .ge. v(gtstep) * v(tuner5))  go to 600
 590               v(radfac) = v(incfac)
!
!  ***  FINISH COMPUTING LKY = ((J(X) - J(X0))**T) * R  ***
!
!     ***  CURRENTLY LKY = (J(X0)**T) * R  ***
!
 600  lky1 = iv(lky)
      call vaxpy(p, v(lky1), negone, v(lky1), v(g1))
!
!  ***  DETERMINE SIZING FACTOR V(SIZE)  ***
!
!     ***  SET TEMP1 = S * STEP  ***
      s1 = iv(s)
      call slvmul(p, v(temp1), v(s1), v(step1))
!
      t1 = abs(dotprd(p, v(step1), v(temp1)))
      t = abs(dotprd(p, v(step1), v(lky1)))
      v(size) = one
      if (t .lt. t1) v(size) = t / t1
!
!  ***  UPDATE S  ***
!
      call slupdt(v(s1), v(cosmin), p, v(size), v(step1), v(temp1),
     +            v(temp2), v(g01), v(wscale), v(lky1))
      iv(1) = 2
      go to 150
!
!. . . . . . . . . . . . . .  MISC. DETAILS  . . . . . . . . . . . . . .
!
!  ***  BAD PARAMETERS TO ASSESS  ***
!
 640  iv(1) = 14
      go to 900
!
!  ***  CONVERGENCE OBTAINED -- COMPUTE COVARIANCE MATRIX IF DESIRED ***
!
 700  if (iv(covreq) .eq. 0 .and. iv(covprt) .eq. 0) go to 760
      if (iv(covmat) .ne. 0) go to 760
      if (iv(cnvcod) .ge. 7) go to 760
      iv(mode) = 0
 710  call covclc(i, d, iv, j, n, nn, p, r, v, x)
      go to (720, 720, 740, 750), i
 720  iv(nfcov) = iv(nfcov) + 1
      iv(nfcall) = iv(nfcall) + 1
      iv(restor) = i
      iv(1) = 1
      go to 999
!
 730  if (iv(restor) .eq. 1 .or. iv(toobig) .ne. 0) go to 710
      iv(nfgcal) = iv(nfcall)
 740  iv(ngcov) = iv(ngcov) + 1
      iv(ngcall) = iv(ngcall) + 1
      iv(1) = 2
      go to 999
!
 750  iv(mode) = 0
      if (iv(niter) .eq. 0) iv(mode) = -1
!
 760  iv(1) = iv(cnvcod)
      iv(cnvcod) = 0
!
!  ***  PRINT SUMMARY OF FINAL ITERATION AND OTHER REQUESTED ITEMS  ***
!
 900  call itsmry(d, iv, p, v, x)
!
 999  return
!
!  ***  LAST CARD OF NL2ITR FOLLOWS  ***
      end
!NL2SOL
      subroutine nl2sol(n, p, x, calcr, calcj, iv, v, uiparm, urparm,
     +                  ufparm)
!
!  ***  MINIMIZE NONLINEAR SUM OF SQUARES USING ANALYTIC JACOBIAN  ***
!  ***  (NL2SOL VERSION 2.2)  ***
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer n,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: urparm(*),v(*),x(p)
      integer iv(*),uiparm(*)
!
!  SUBROUTINE ARGUMENTS
      external calcj,calcr,ufparm
!
!  LOCAL SCALARS
      integer d,d1,j,j1,nf,nfcall,nfgcal,r,r1,toobig
      logical strted
!
!  EXTERNAL SUBROUTINES
      external itsmry,nl2itr
!
!
!     INTEGER N, P, IV(1), UIPARM(1)
!     REAL(KIND=WP) :: X(P), V(1), URPARM(1)
!     DIMENSION IV(60+P),  V(93 + N*P + 3*N + P*(3*P+33)/2)
!     DIMENSION UIPARM(*), URPARM(*)
!     EXTERNAL CALCR, CALCJ, UFPARM
!
!  ***  PURPOSE  ***
!
!        GIVEN A P-VECTOR X OF PARAMETERS, CALCR COMPUTES AN N-VECTOR
!     R = R(X) OF RESIDUALS CORRESPONDING TO X.  (R(X) PROBABLY ARISES
!     FROM A NONLINEAR MODEL INVOLVING P PARAMETERS AND N OBSERVATIONS.)
!     THIS ROUTINE INTERACTS WITH NL2ITR TO SEEK A PARAMETER VECTOR X
!     THAT MINIMIZES THE SUM OF THE SQUARES OF (THE COMPONENTS OF) R(X),
!     I.E., THAT MINIMIZES THE SUM-OF-SQUARES FUNCTION
!     F(X) = (R(X)**T) * R(X) / 2.  R(X) IS ASSUMED TO BE A TWICE CONTINUOUSLY
!     DIFFERENTIABLE FUNCTION OF X.
!
!--------------------------  PARAMETER USAGE  --------------------------
!
! N........ (INPUT) THE NUMBER OF OBSERVATIONS, I.E., THE NUMBER OF
!                  COMPONENTS IN R(X).  N MUST BE .GE. P.
! P........ (INPUT) THE NUMBER OF PARAMETERS (COMPONENTS IN X).  P MUST
!                  BE POSITIVE.
! X........ (INPUT/OUTPUT).  ON INPUT, X IS AN INITIAL GUESS AT THE
!                  DESIRED PARAMETER ESTIMATE.  ON OUTPUT, X CONTAINS
!                  THE BEST PARAMETER ESTIMATE FOUND.
! CALCR.... (INPUT) A SUBROUTINE WHICH, GIVEN X, COMPUTES R(X).  CALCR
!                  MUST BE DECLARED EXTERNAL IN THE CALLING PROGRAM.
!                  IT IS INVOKED BY
!                       CALL CALCR(N,P,X,NF,R,UIPARM,URPARM,UFPARM)
!                  WHEN CALCR IS CALLED, NF IS THE INVOCATION COUNT
!                  FOR CALCR.  IT IS INCLUDED FOR POSSIBLE USE WITH
!                  CALCJ.  IF X IS OUT OF BOUNDS (E.G. IF IT WOULD
!                  CAUSE OVERFLOW IN COMPUTING R(X)), THEN CALCR SHOULD
!                  SET NF TO 0.  THIS WILL CAUSE A SHORTER STEP TO BE
!                  ATTEMPTED.  THE OTHER PARAMETERS ARE AS DESCRIBED
!                  ABOVE AND BELOW.  CALCR SHOULD NOT CHANGE N, P, OR X.
! CALCJ.... (INPUT) A SUBROUTINE WHICH, GIVEN X, COMPUTES THE JACOBIAN
!                  MATRIX J OF R AT X, I.E., THE N BY P MATRIX WHOSE
!                  (I,K) ENTRY IS THE PARTIAL DERIVATIVE OF THE I-TH
!                  COMPONENT OF R WITH RESPECT TO X(K).  CALCJ MUST BE
!                  DECLARED EXTERNAL IN THE CALLING PROGRAM.  IT IS
!                  INVOKED BY
!                       CALL CALCJ(N,P,X,NF,J,UIPARM,URPARM,UFPARM)
!                  NF IS THE INVOCATION COUNT FOR CALCR AT THE TIME
!                  R(X) WAS EVALUATED.  THE X PASSED TO CALCJ IS
!                  USUALLY THE ONE PASSED TO CALCR ON EITHER ITS MOST
!                  RECENT INVOCATION OR THE ONE PRIOR TO IT.  IF CALCR
!                  SAVES INTERMEDIATE RESULTS FOR USE BY CALCJ, THEN IT
!                  IS POSSIBLE TO TELL FROM NF WHETHER THEY ARE VALID
!                  FOR THE CURRENT X (OR WHICH COPY IS VALID IF TWO
!                  COPIES ARE KEPT).  IF J CANNOT BE COMPUTED AT X,
!                  THEN CALCJ SHOULD SET NF TO 0.  IN THIS CASE, NL2SOL
!                  WILL RETURN WITH IV(1) = 15.  THE OTHER PARAMETERS
!                  TO CALCJ ARE AS DESCRIBED ABOVE AND BELOW.  CALCJ
!                  SHOULD NOT CHANGE N, P, OR X.
! IV....... (INPUT/OUTPUT) AN INTEGER VALUE ARRAY OF LENGTH AT LEAST
!                  60 + P THAT HELPS CONTROL THE NL2SOL ALGORITHM AND
!                  THAT IS USED TO STORE VARIOUS INTERMEDIATE QUANTITIES.
!                  OF PARTICULAR INTEREST ARE THE INITIALIZATION/
!                  RETURN CODE IV(1) AND THE ENTRIES IN IV THAT CONTROL
!                  PRINTING AND LIMIT THE NUMBER OF ITERATIONS AND FUNCTION
!                  EVALUATIONS.  SEE THE SECTION ON IV INPUT
!                  VALUES BELOW.
! V........ (INPUT/OUTPUT) A FLOATING-POINT VALUE ARRAY OF LENGTH AT
!                  LEAST 93 + N*P + 3*N + P*(3*P+33) THAT HELPS CONTROL
!                  THE NL2SOL ALGORITHM AND THAT IS USED TO STORE
!                  VARIOUS INTERMEDIATE QUANTITIES.  OF PARTICULAR INTEREST
!                  ARE THE ENTRIES IN V THAT LIMIT THE LENGTH OF
!                  THE FIRST STEP ATTEMPTED (LMAX0), SPECIFY CONVERGENCE
!                  TOLERANCES (AFCTOL, RFCTOL, XCTOL, XFTOL),
!                  AND HELP CHOOSE THE STEP SIZE USED IN COMPUTING THE
!                  COVARIANCE MATRIX (DELTA0).  SEE THE SECTION ON
!                  (SELECTED) V INPUT VALUES BELOW.
! UIPARM... (INPUT) USER INTEGER PARAMETER ARRAY PASSED WITHOUT CHANGE
!                  TO CALCR AND CALCJ.
! URPARM... (INPUT) USER FLOATING-POINT PARAMETER ARRAY PASSED WITHOUT
!                  CHANGE TO CALCR AND CALCJ.
! UFPARM... (INPUT) USER EXTERNAL SUBROUTINE OR FUNCTION PASSED WITHOUT
!                  CHANGE TO CALCR AND CALCJ.
!
!  ***  IV INPUT VALUES (FROM SUBROUTINE DFAULT)  ***
!
! IV(1)...  ON INPUT, IV(1) SHOULD HAVE A VALUE BETWEEN 0 AND 12......
!             0 AND 12 MEAN THIS IS A FRESH START.  0 MEANS THAT
!             DFAULT(IV, V) IS TO BE CALLED TO PROVIDE ALL DEFAULT
!             VALUES TO IV AND V.  12 (THE VALUE THAT DFAULT ASSIGNS TO
!             IV(1)) MEANS THE CALLER HAS ALREADY CALLED DFAULT(IV, V)
!             AND HAS POSSIBLY CHANGED SOME IV AND/OR V ENTRIES TO NON-
!             DEFAULT VALUES.  DEFAULT = 12.
! IV(COVPRT)... IV(14) = 1 MEANS PRINT A COVARIANCE MATRIX AT THE SOLUTION.
!             (THIS MATRIX IS COMPUTED JUST BEFORE A RETURN WITH
!             IV(1) = 3, 4, 5, 6.)
!             IV(COVPRT) = 0 MEANS SKIP THIS PRINTING.  DEFAULT = 1.
! IV(COVREQ)... IV(15) = NONZERO MEANS COMPUTE A COVARIANCE MATRIX
!             JUST BEFORE A RETURN WITH IV(1) = 3, 4, 5, 6.  IN
!             THIS CASE, AN APPROXIMATE COVARIANCE MATRIX IS OBTAINED
!             IN ONE OF SEVERAL WAYS.  LET K = ABS(IV(COVREQ)) AND LET
!             SCALE = 2*F(X)/MAX(1,N-P),  WHERE 2*F(X) IS THE RESIDUAL
!             SUM OF SQUARES.  IF K = 1 OR 2, THEN A FINITE-DIFFERENCE
!             HESSIAN APPROXIMATION H IS OBTAINED.  IF H IS POSITIVE
!             DEFINITE (OR, FOR K = 3, IF THE JACOBIAN MATRIX J AT X
!             IS NONSINGULAR), THEN ONE OF THE FOLLOWING IS COMPUTED...
!                  K = 1....  SCALE * H**-1 * (J**T * J) * H**-1.
!                  K = 2....  SCALE * H**-1.
!                  K = 3....  SCALE * (J**T * J)**-1.
!             (J**T IS THE TRANSPOSE OF J, WHILE **-1 MEANS INVERSE.)
!             IF IV(COVREQ) IS POSITIVE, THEN BOTH FUNCTION AND GRADIENT
!             VALUES (CALLS ON CALCR AND CALCJ) ARE USED IN COMPUTING
!             H (WITH STEP SIZES DETERMINED USING V(DELTA0) --
!             SEE BELOW), WHILE IF IV(COVREQ) IS NEGATIVE, THEN ONLY
!             FUNCTION VALUES (CALLS ON CALCR) ARE USED (WITH STEP
!             SIZES DETERMINED USING V(DLTFDC) -- SEE BELOW).  IF
!             IV(COVREQ) = 0, THEN NO ATTEMPT IS MADE TO COMPUTE A
!             COVARIANCE MATRIX (UNLESS IV(COVPRT) = 1, IN WHICH CASE
!             IV(COVREQ) = 1 IS ASSUMED).  SEE IV(COVMAT) BELOW.
!             DEFAULT = 1.
! IV(DTYPE).... IV(16) TELLS HOW THE SCALE VECTOR D (SEE REF. 1) SHOULD
!             BE CHOSEN.  IV(DTYPE) .GE. 1 MEANS CHOOSE D AS DESCRIBED
!             BELOW WITH V(DFAC).  IV(DTYPE) .LE. 0 MEANS THE CALLER
!             HAS CHOSEN D AND HAS STORED IT IN V STARTING AT
!             V(94 + 2*N + P*(3*P + 31)/2).  DEFAULT = 1.
! IV(INITS).... IV(25) TELLS HOW THE S MATRIX (SEE REF. 1) SHOULD BE
!             INITIALIZED.  0 MEANS INITIALIZE S TO 0 (AND START WITH
!             THE GAUSS-NEWTON MODEL).  1 AND 2 MEAN THAT THE CALLER
!             HAS STORED THE LOWER TRIANGLE OF THE INITIAL S ROWWISE IN
!             V STARTING AT V(87+2*P).  IV(INITS) = 1 MEANS START WITH
!             THE GAUSS-NEWTON MODEL, WHILE IV(INITS) = 2 MEANS START
!             WITH THE AUGMENTED MODEL (SEE REF. 1).  DEFAULT = 0.
! IV(MXFCAL)... IV(17) GIVES THE MAXIMUM NUMBER OF FUNCTION EVALUATIONS
!             (CALLS ON CALCR, EXCLUDING THOSE USED TO COMPUTE THE
!             COVARIANCE MATRIX) ALLOWED.  IF THIS NUMBER DOES NOT SUFFICE,
!             THEN NL2SOL RETURNS WITH IV(1) = 9.  DEFAULT = 200.
! IV(MXITER)... IV(18) GIVES THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!             IT ALSO INDIRECTLY LIMITS THE NUMBER OF GRADIENT EVALUATIONS
!             (CALLS ON CALCJ, EXCLUDING THOSE USED TO COMPUTE
!             THE COVARIANCE MATRIX) TO IV(MXITER) + 1.  IF IV(MXITER)
!             ITERATIONS DO NOT SUFFICE, THEN NL2SOL RETURNS WITH
!             IV(1) = 10.  DEFAULT = 150.
! IV(OUTLEV)... IV(19) CONTROLS THE NUMBER AND LENGTH OF ITERATION SUMMARY
!             LINES PRINTED (BY ITSMRY).  IV(OUTLEV) = 0 MEANS DO
!             NOT PRINT ANY SUMMARY LINES.  OTHERWISE, PRINT A SUMMARY
!             LINE AFTER EACH ABS(IV(OUTLEV)) ITERATIONS.  IF IV(OUTLEV)
!             IS POSITIVE, THEN SUMMARY LINES OF LENGTH 117 (PLUS CARRIAGE
!             CONTROL) ARE PRINTED, INCLUDING THE FOLLOWING...  THE
!             ITERATION AND FUNCTION EVALUATION COUNTS, CURRENT FUNCTION
!             VALUE (V(F) = HALF THE SUM OF SQUARES), RELATIVE
!             DIFFERENCE IN FUNCTION VALUES ACHIEVED BY THE LATEST STEP
!             (I.E., RELDF = (F0-V(F))/F0, WHERE F0 IS THE FUNCTION
!             VALUE FROM THE PREVIOUS ITERATION), THE RELATIVE FUNCTION
!             REDUCTION PREDICTED FOR THE STEP JUST TAKEN (I.E.,
!             PRELDF = V(PREDUC) / F0, WHERE V(PREDUC) IS DESCRIBED
!             BELOW), THE SCALED RELATIVE CHANGE IN X (SEE V(RELDX)
!             BELOW), THE MODELS USED IN THE CURRENT ITERATION (G =
!             GAUSS-NEWTON, S=AUGMENTED), THE MARQUARDT PARAMETER
!             STPPAR USED IN COMPUTING THE LAST STEP, THE SIZING FACTOR
!             USED IN UPDATING S, THE 2-NORM OF THE SCALE VECTOR D
!             TIMES THE STEP JUST TAKEN (SEE REF. 1), AND NPRELDF, I.E.,
!             V(NREDUC)/F0, WHERE V(NREDUC) IS DESCRIBED BELOW -- IF
!             NPRELDF IS POSITIVE, THEN IT IS THE RELATIVE FUNCTION
!             REDUCTION PREDICTED FOR A NEWTON STEP (ONE WITH
!             STPPAR = 0).  IF NPRELDF IS ZERO, EITHER THE GRADIENT
!             VANISHES (AS DOES PRELDF) OR ELSE THE AUGMENTED MODEL
!             IS BEING USED AND ITS HESSIAN IS INDEFINITE (WITH PRELDF
!             POSITIVE).  IF NPRELDF IS NEGATIVE, THEN IT IS THE NEGATIVE
!             OF THE RELATIVE FUNCTION REDUCTION PREDICTED FOR A STEP
!             COMPUTED WITH STEP BOUND V(LMAX0) FOR USE IN TESTING FOR
!             SINGULAR CONVERGENCE.
!                  IF IV(OUTLEV) IS NEGATIVE, THEN LINES OF MAXIMUM
!             LENGTH 79 (OR 55 IS IV(COVPRT) = 0) ARE PRINTED, INCLUDING
!             ONLY THE FIRST 6 ITEMS LISTED ABOVE (THROUGH RELDX).
!             DEFAULT = 1.
! IV(PARPRT)... IV(20) = 1 MEANS PRINT ANY NONDEFAULT V VALUES ON A
!             FRESH START OR ANY CHANGED V VALUES ON A RESTART.
!             IV(PARPRT) = 0 MEANS SKIP THIS PRINTING.  DEFAULT = 1.
! IV(PRUNIT)... IV(21) IS THE OUTPUT UNIT NUMBER ON WHICH ALL PRINTING
!             IS DONE.  IV(PRUNIT) = 0 MEANS SUPPRESS ALL PRINTING.
!             (SETTING IV(PRUNIT) TO 0 IS THE ONLY WAY TO SUPPRESS THE
!             ONE-LINE TERMINATION REASON MESSAGE PRINTED BY ITSMRY.)
!             DEFAULT = STANDARD OUTPUT UNIT (UNIT 6 ON MOST SYSTEMS).
! IV(SOLPRT)... IV(22) = 1 MEANS PRINT OUT THE VALUE OF X RETURNED (AS
!             WELL AS THE CORRESPONDING GRADIENT AND SCALE VECTOR D).
!             IV(SOLPRT) = 0 MEANS SKIP THIS PRINTING.  DEFAULT = 1.
! IV(STATPR)... IV(23) = 1 MEANS PRINT SUMMARY STATISTICS UPON RETURNING.
!             THESE CONSIST OF THE FUNCTION VALUE (HALF THE SUM
!             OF SQUARES) AT X, V(RELDX) (SEE BELOW), THE NUMBER OF
!             FUNCTION AND GRADIENT EVALUATIONS (CALLS ON CALCR AND
!             CALCJ RESPECTIVELY, EXCLUDING ANY CALLS USED TO COMPUTE
!             THE COVARIANCE), THE RELATIVE FUNCTION REDUCTIONS PREDICTED
!             FOR THE LAST STEP TAKEN AND FOR A NEWTON STEP (OR PERHAPS
!             A STEP BOUNDED BY V(LMAX0) -- SEE THE DESCRIPTIONS
!             OF PRELDF AND NPRELDF UNDER IV(OUTLEV) ABOVE), AND (IF AN
!             ATTEMPT WAS MADE TO COMPUTE THE COVARIANCE) THE NUMBER OF
!             CALLS ON CALCR AND CALCJ USED IN TRYING TO COMPUTE THE
!             COVARIANCE.  IV(STATPR) = 0 MEANS SKIP THIS PRINTING.
!             DEFAULT = 1.
! IV(X0PRT).... IV(24) = 1 MEANS PRINT THE INITIAL X AND SCALE VECTOR D
!             (ON A FRESH START ONLY).  IV(X0PRT) = 0 MEANS SKIP THIS
!             PRINTING.  DEFAULT = 1.
!
!  ***  (SELECTED) IV OUTPUT VALUES  ***
!
! IV(1)........ ON OUTPUT, IV(1) IS A RETURN CODE....
!             3 = X-CONVERGENCE.  THE SCALED RELATIVE DIFFERENCE BETWEEN
!                  THE CURRENT PARAMETER VECTOR X AND A LOCALLY
!                  OPTIMAL PARAMETER VECTOR IS VERY LIKELY AT MOST
!                  V(XCTOL).
!             4 = RELATIVE FUNCTION CONVERGENCE.  THE RELATIVE DIFFERENCE
!                  BETWEEN THE CURRENT FUNCTION VALUE AND ITS LOCALLY
!                  OPTIMAL VALUE IS VERY LIKELY AT MOST V(RFCTOL).
!             5 = BOTH X- AND RELATIVE FUNCTION CONVERGENCE (I.E., THE
!                  CONDITIONS FOR IV(1) = 3 AND IV(1) = 4 BOTH HOLD).
!             6 = ABSOLUTE FUNCTION CONVERGENCE.  THE CURRENT FUNCTION
!                  VALUE IS AT MOST V(AFCTOL) IN ABSOLUTE VALUE.
!             7 = SINGULAR CONVERGENCE.  THE HESSIAN NEAR THE CURRENT
!                  ITERATE APPEARS TO BE SINGULAR OR NEARLY SO, AND A
!                  STEP OF LENGTH AT MOST V(LMAX0) IS UNLIKELY TO YIELD
!                  A RELATIVE FUNCTION DECREASE OF MORE THAN V(RFCTOL).
!             8 = FALSE CONVERGENCE.  THE ITERATES APPEAR TO BE CONVERGING
!                  TO A NONCRITICAL POINT.  THIS MAY MEAN THAT THE
!                  CONVERGENCE TOLERANCES (V(AFCTOL), V(RFCTOL),
!                  V(XCTOL)) ARE TOO SMALL FOR THE ACCURACY TO WHICH
!                  THE FUNCTION AND GRADIENT ARE BEING COMPUTED, THAT
!                  THERE IS AN ERROR IN COMPUTING THE GRADIENT, OR THAT
!                  THE FUNCTION OR GRADIENT IS DISCONTINUOUS NEAR X.
!             9 = FUNCTION EVALUATION LIMIT REACHED WITHOUT OTHER CONVERGENCE
!                  (SEE IV(MXFCAL)).
!            10 = ITERATION LIMIT REACHED WITHOUT OTHER CONVERGENCE
!                  (SEE IV(MXITER)).
!            11 = STOPX RETURNED .TRUE. (EXTERNAL INTERUPT).  SEE THE
!                  USAGE NOTES BELOW.
!            13 = F(X) CANNOT BE COMPUTED AT THE INITIAL X.
!            14 = BAD PARAMETERS PASSED TO ASSESS (WHICH SHOULD NOT
!                  OCCUR).
!            15 = THE JACOBIAN COULD NOT BE COMPUTED AT X (SEE CALCJ
!                  ABOVE).
!            16 = N OR P (OR PARAMETER NN TO NL2ITR) OUT OF RANGE --
!                  P .LE. 0 OR N .LT. P OR NN .LT. N.
!            17 = RESTART ATTEMPTED WITH N OR P (OR PAR. NN TO NL2ITR)
!                  CHANGED.
!            18 = IV(INITS) IS OUT OF RANGE.
!            19...45 = V(IV(1)-18) IS OUT OF RANGE.
!            50 = IV(1) WAS OUT OF RANGE.
!            87...(86+P) = JTOL(IV(1)-86) (I.E., V(IV(1)) IS NOT
!                  POSITIVE (SEE V(DFAC) BELOW).
! IV(COVMAT)... IV(26) TELLS WHETHER A COVARIANCE MATRIX WAS COMPUTED.
!             IF (IV(COVMAT) IS POSITIVE, THEN THE LOWER TRIANGLE OF
!             THE COVARIANCE MATRIX IS STORED ROWWISE IN V STARTING AT
!             V(IV(COVMAT)).  IF IV(COVMAT) = 0, THEN NO ATTEMPT WAS
!             MADE TO COMPUTE THE COVARIANCE.  IF IV(COVMAT) = -1,
!             THEN THE FINITE-DIFFERENCE HESSIAN WAS INDEFINITE.  AND
!             AND IF IV(COVMAT) = -2, THEN A SUCCESSFUL FINITE-DIFFERENCING
!             STEP COULD NOT BE FOUND FOR SOME COMPONENT OF X
!             (I.E., CALCR SET NF TO 0 FOR EACH OF TWO TRIAL STEPS).
!             NOTE THAT IV(COVMAT) IS RESET TO 0 AFTER EACH SUCCESSFUL
!             STEP, SO IF SUCH A STEP IS TAKEN AFTER A RESTART, THEN
!             THE COVARIANCE MATRIX WILL BE RECOMPUTED.
! IV(D)........ IV(27) IS THE STARTING SUBSCRIPT IN V OF THE CURRENT
!             SCALE VECTOR D.
! IV(G)........ IV(28) IS THE STARTING SUBSCRIPT IN V OF THE CURRENT
!             LEAST-SQUARES GRADIENT VECTOR (J**T)*R.
! IV(NFCALL)... IV(6) IS THE NUMBER OF CALLS SO FAR MADE ON CALCR (I.E.,
!             FUNCTION EVALUATIONS, INCLUDING THOSE USED IN COMPUTING
!             THE COVARIANCE).
! IV(NFCOV).... IV(40) IS THE NUMBER OF CALLS MADE ON CALCR WHEN
!             TRYING TO COMPUTE COVARIANCE MATRICES.
! IV(NGCALL)... IV(30) IS THE NUMBER OF GRADIENT EVALUATIONS (CALLS ON
!             CALCJ) SO FAR DONE (INCLUDING THOSE USED FOR COMPUTING
!             THE COVARIANCE).
! IV(NGCOV).... IV(41) IS THE NUMBER OF CALLS MADE ON CALCJ WHEN
!             TRYING TO COMPUTE COVARIANCE MATRICES.
! IV(NITER).... IV(31) IS THE NUMBER OF ITERATIONS PERFORMED.
! IV(R)........ IV(50) IS THE STARTING SUBSCRIPT IN V OF THE RESIDUAL
!             VECTOR R CORRESPONDING TO X.
!
!  ***  (SELECTED) V INPUT VALUES (FROM SUBROUTINE DFAULT)  ***
!
! V(AFCTOL)... V(31) IS THE ABSOLUTE FUNCTION CONVERGENCE TOLERANCE.
!             IF NL2SOL FINDS A POINT WHERE THE FUNCTION VALUE (HALF
!             THE SUM OF SQUARES) IS LESS THAN V(AFCTOL), AND IF NL2SOL
!             DOES NOT RETURN WITH IV(1) = 3, 4, OR 5, THEN IT RETURNS
!             WITH IV(1) = 6.  DEFAULT = MAX(10**-20, MACHEP**2), WHERE
!             MACHEP IS THE UNIT ROUNDOFF.
! V(DELTA0)... V(44) IS A FACTOR USED IN CHOOSING THE FINITE-DIFFERENCE
!             STEP SIZE USED IN COMPUTING THE COVARIANCE MATRIX WHEN
!             IV(COVREQ) = 1 OR 2.  FOR COMPONENT I, STEP SIZE
!                  V(DELTA0) * MAX(ABS(X(I)), 1/D(I)) * SIGN(X(I))
!             IS USED, WHERE D IS THE CURRENT SCALE VECTOR (SEE REF. 1).
!             (IF THIS STEP RESULTS IN CALCR SETTING NF TO 0, THEN -0.5
!             TIMES THIS STEP IS ALSO TRIED.)  DEFAULT = MACHEP**0.5,
!             WHERE MACHEP IS THE UNIT ROUNDOFF.
! V(DFAC)..... V(41) AND THE D0 AND JTOL ARRAYS (SEE V(D0INIT) AND
!             V(JTINIT)) ARE USED IN UPDATING THE SCALE VECTOR D WHEN
!             IV(DTYPE) .GT. 0.  (D IS INITIALIZED ACCORDING TO
!             V(DINIT).)  LET D1(I) =
!               MAX(SQRT(JCNORM(I)**2 + MAX(S(I,I),0)), V(DFAC)*D(I)),
!             WHERE JCNORM(I) IS THE 2-NORM OF THE I-TH COLUMN OF THE
!             CURRENT JACOBIAN MATRIX AND S IS THE S MATRIX OF REF. 1.
!             IF IV(DTYPE) = 1, THEN D(I) IS SET TO D1(I) UNLESS
!             D1(I) .LT. JTOL(I), IN WHICH CASE D(I) IS SET TO
!                                MAX(D0(I), JTOL(I)).
!             IF IV(DTYPE) .GE. 2, THEN D IS UPDATED DURING THE FIRST
!             ITERATION AS FOR IV(DTYPE) = 1 (AFTER ANY INITIALIZATION
!             DUE TO V(DINIT)) AND IS LEFT UNCHANGED THEREAFTER.
!             DEFAULT = 0.6.
! V(DINIT).... V(38), IF NONNEGATIVE, IS THE VALUE TO WHICH THE SCALE
!             VECTOR D IS INITIALIZED.  DEFAULT = 0.
! V(DLTFDC)... V(40) HELPS CHOOSE THE STEP SIZE USED WHEN COMPUTING THE
!             COVARIANCE MATRIX WHEN IV(COVREQ) = -1 OR -2.  FOR
!             DIFFERENCES INVOLVING X(I), THE STEP SIZE FIRST TRIED IS
!                       V(DLTFDC) * MAX(ABS(X(I)), 1/D(I)),
!             WHERE D IS THE CURRENT SCALE VECTOR (SEE REF. 1).  (IF
!             THIS STEP IS TOO BIG THE FIRST TIME IT IS TRIED, I.E., IF
!             CALCR SETS NF TO 0, THEN -0.5 TIMES THIS STEP IS ALSO
!             TRIED.)  DEFAULT = MACHEP**(1/3), WHERE MACHEP IS THE
!             UNIT ROUNDOFF.
! V(D0INIT)... V(37), IF POSITIVE, IS THE VALUE TO WHICH ALL COMPONENTS
!             OF THE D0 VECTOR (SEE V(DFAC)) ARE INITIALIZED.  IF
!             V(DFAC) = 0, THEN IT IS ASSUMED THAT THE CALLER HAS
!             STORED D0 IN V STARTING AT V(P+87).  DEFAULT = 1.0.
! V(JTINIT)... V(39), IF POSITIVE, IS THE VALUE TO WHICH ALL COMPONENTS
!             OF THE JTOL ARRAY (SEE V(DFAC)) ARE INITIALIZED.  IF
!             V(JTINIT) = 0, THEN IT IS ASSUMED THAT THE CALLER HAS
!             STORED JTOL IN V STARTING AT V(87).  DEFAULT = 10**-6.
! V(LMAX0).... V(35) GIVES THE MAXIMUM 2-NORM ALLOWED FOR D TIMES THE
!             VERY FIRST STEP THAT NL2SOL ATTEMPTS.  IT IS ALSO USED
!             IN TESTING FOR SINGULAR CONVERGENCE -- IF THE FUNCTION
!             REDUCTION PREDICTED FOR A STEP OF LENGTH BOUNDED BY
!             V(LMAX0) IS AT MOST V(RFCTOL) * ABS(F0), WHERE  F0  IS
!             THE FUNCTION VALUE AT THE START OF THE CURRENT ITERATION,
!             AND IF NL2SOL DOES NOT RETURN WITH IV(1) = 3, 4, 5, OR 6,
!             THEN IT RETURNS WITH IV(1) = 7.    DEFAULT = 100.
! V(RFCTOL)... V(32) IS THE RELATIVE FUNCTION CONVERGENCE TOLERANCE.
!             IF THE CURRENT MODEL PREDICTS A MAXIMUM POSSIBLE FUNCTION
!             REDUCTION (SEE V(NREDUC)) OF AT MOST V(RFCTOL)*ABS(F0) AT
!             THE START OF THE CURRENT ITERATION, WHERE  F0  IS THE
!             THEN CURRENT FUNCTION VALUE, AND IF THE LAST STEP ATTEMPTED
!             ACHIEVED NO MORE THAN TWICE THE PREDICTED FUNCTION
!             DECREASE, THEN NL2SOL RETURNS WITH IV(1) = 4 (OR 5).
!             DEFAULT = MAX(10**-10, MACHEP**(2/3)), WHERE MACHEP IS
!             THE UNIT ROUNDOFF.
! V(TUNER1)... V(26) HELPS DECIDE WHEN TO CHECK FOR FALSE CONVERGENCE
!             AND TO CONSIDER SWITCHING MODELS.  THIS IS DONE IF THE
!             ACTUAL FUNCTION DECREASE FROM THE CURRENT STEP IS NO MORE
!             THAN V(TUNER1) TIMES ITS PREDICTED VALUE.  DEFAULT = 0.1.
! V(XCTOL).... V(33) IS THE X-CONVERGENCE TOLERANCE.  IF A NEWTON STEP
!             (SEE V(NREDUC)) IS TRIED THAT HAS V(RELDX) .LE. V(XCTOL)
!             AND IF THIS STEP YIELDS AT MOST TWICE THE PREDICTED FUNCTION
!             DECREASE, THEN NL2SOL RETURNS WITH IV(1) = 3 (OR 5).
!             (SEE THE DESCRIPTION OF V(RELDX) BELOW.)
!             DEFAULT = MACHEP**0.5, WHERE MACHEP IS THE UNIT ROUNDOFF.
! V(XFTOL).... V(34) IS THE FALSE CONVERGENCE TOLERANCE.  IF A STEP IS
!             TRIED THAT GIVES NO MORE THAN V(TUNER1) TIMES THE PREDICTED
!             FUNCTION DECREASE AND THAT HAS V(RELDX) .LE. V(XFTOL),
!             AND IF NL2SOL DOES NOT RETURN WITH IV(1) = 3, 4, 5, 6, OR
!             7, THEN IT RETURNS WITH IV(1) = 8.  (SEE THE DESCRIPTION
!             OF V(RELDX) BELOW.)  DEFAULT = 100*MACHEP, WHERE
!             MACHEP IS THE UNIT ROUNDOFF.
! V(*)........ DFAULT SUPPLIES TO V A NUMBER OF TUNING CONSTANTS, WITH
!             WHICH IT SHOULD ORDINARILY BE UNNECESSARY TO TINKER.  SEE
!             VERSION 2.2 OF THE NL2SOL USAGE SUMMARY (WHICH IS AN
!             APPENDIX TO REF. 1).
!
!  ***  (SELECTED) V OUTPUT VALUES  ***
!
! V(DGNORM)... V(1) IS THE 2-NORM OF (D**-1)*G, WHERE G IS THE MOST RECENTLY
!             COMPUTED GRADIENT AND D IS THE CORRESPONDING SCALE
!             VECTOR.
! V(DSTNRM)... V(2) IS THE 2-NORM OF D*STEP, WHERE STEP IS THE MOST RECENTLY
!             COMPUTED STEP AND D IS THE CURRENT SCALE VECTOR.
! V(F)........ V(10) IS THE CURRENT FUNCTION VALUE (HALF THE SUM OF
!             SQUARES).
! V(F0)....... V(13) IS THE FUNCTION VALUE AT THE START OF THE CURRENT
!             ITERATION.
! V(NREDUC)... V(6), IF POSITIVE, IS THE MAXIMUM FUNCTION REDUCTION
!             POSSIBLE ACCORDING TO THE CURRENT MODEL, I.E., THE FUNCTION
!             REDUCTION PREDICTED FOR A NEWTON STEP (I.E.,
!             STEP = -H**-1 * G,  WHERE  G = (J**T) * R  IS THE CURRENT
!             GRADIENT AND H IS THE CURRENT HESSIAN APPROXIMATION --
!             H = (J**T)*J  FOR THE GAUSS-NEWTON MODEL AND
!             H = (J**T)*J + S  FOR THE AUGMENTED MODEL).
!                  V(NREDUC) = ZERO MEANS H IS NOT POSITIVE DEFINITE.
!                  IF V(NREDUC) IS NEGATIVE, THEN IT IS THE NEGATIVE OF
!             THE FUNCTION REDUCTION PREDICTED FOR A STEP COMPUTED WITH
!             A STEP BOUND OF V(LMAX0) FOR USE IN TESTING FOR SINGULAR
!             CONVERGENCE.
! V(PREDUC)... V(7) IS THE FUNCTION REDUCTION PREDICTED (BY THE CURRENT
!             QUADRATIC MODEL) FOR THE CURRENT STEP.  THIS (DIVIDED BY
!             V(F0)) IS USED IN TESTING FOR RELATIVE FUNCTION
!             CONVERGENCE.
! V(RELDX).... V(17) IS THE SCALED RELATIVE CHANGE IN X CAUSED BY THE
!             CURRENT STEP, COMPUTED AS
!                  MAX(ABS(D(I)*(X(I)-X0(I)), 1 .LE. I .LE. P) /
!                     MAX(D(I)*(ABS(X(I))+ABS(X0(I))), 1 .LE. I .LE. P),
!             WHERE X = X0 + STEP.
!
!-------------------------------  NOTES  -------------------------------
!
!  ***  ALGORITHM NOTES  ***
!
!     SEE REF. 1 FOR A DESCRIPTION OF THE ALGORITHM USED.
!     ON PROBLEMS WHICH ARE NATURALLY WELL SCALED, BETTER PERFORMANCE
!     MAY BE OBTAINED BY SETTING V(D0INIT) = 1.0 AND IV(DTYPE) = 0,
!     WHICH WILL CAUSE THE SCALE VECTOR D TO BE SET TO ALL ONES.
!
!  ***  USAGE NOTES  ***
!
!        AFTER A RETURN WITH IV(1) .LE. 11, IT IS POSSIBLE TO RESTART,
!     I.E., TO CHANGE SOME OF THE IV AND V INPUT VALUES DESCRIBED ABOVE
!     AND CONTINUE THE ALGORITHM FROM THE POINT WHERE IT WAS INTERRUPTED.
!     IV(1) SHOULD NOT BE CHANGED, NOR SHOULD ANY ENTRIES OF IV
!     AND V OTHER THAN THE INPUT VALUES (THOSE SUPPLIED BY DFAULT).
!        THOSE WHO DO NOT WISH TO WRITE A CALCJ WHICH COMPUTES THE JACOBIAN
!     MATRIX ANALYTICALLY SHOULD CALL NL2SNO RATHER THAN NL2SOL.
!     NL2SNO USES FINITE DIFFERENCES TO COMPUTE AN APPROXIMATE JACOBIAN.
!        THOSE WHO WOULD PREFER TO PROVIDE R AND J (THE RESIDUAL AND
!     JACOBIAN) BY REVERSE COMMUNICATION RATHER THAN BY WRITING SUBROUTINES
!     CALCR AND CALCJ MAY CALL ON NL2ITR DIRECTLY.  SEE THE COMMENTS
!     AT THE BEGINNING OF NL2ITR.
!        THOSE WHO USE NL2SOL INTERACTIVELY MAY WISH TO SUPPLY THEIR
!     OWN STOPX FUNCTION, WHICH SHOULD RETURN .TRUE. IF THE BREAK KEY
!     HAS BEEN PRESSED SINCE STOPX WAS LAST INVOKED.  THIS MAKES IT POSSIBLE
!     TO EXTERNALLY INTERRUPT NL2SOL (WHICH WILL RETURN WITH
!     IV(1) = 11 IF STOPX RETURNS .TRUE.).
!        STORAGE FOR J IS ALLOCATED AT THE END OF V.  THUS THE CALLER
!     MAY MAKE V LONGER THAN SPECIFIED ABOVE AND MAY ALLOW CALCJ TO USE
!     ELEMENTS OF J BEYOND THE FIRST N*P AS SCRATCH STORAGE.
!
!  ***  PORTABILITY NOTES  ***
!
!        THE NL2SOL DISTRIBUTION TAPE CONTAINS BOTH SINGLE- AND DOUBLE-
!     PRECISION VERSIONS OF THE NL2SOL SOURCE CODE, SO IT SHOULD BE
!     UNNECESSARY TO CHANGE PRECISIONS.
!        ONLY THE FUNCTIONS IMDCON AND RMDCON CONTAIN MACHINE-DEPENDENT
!     CONSTANTS.  TO CHANGE FROM ONE MACHINE TO ANOTHER, IT SHOULD
!     SUFFICE TO CHANGE THE (FEW) RELEVANT LINES IN THESE FUNCTIONS.
!
!  ***  REFERENCES  ***
!
! 1.  DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1980), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, SUBMITTED TO ACM TRANS.
!             MATH. SOFTWARE.
!
!  ***  GENERAL  ***
!
!     CODED BY DAVID M. GAY (WINTER 1979 - WINTER 1980).
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!     MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989, AND
!     MCS-7906671.
!
!----------------------------  DECLARATIONS  ---------------------------
!
!     EXTERNAL ITSMRY, NL2ITR
! ITSMRY... PRINTS ITERATION SUMMARY AND INFO ABOUT INITIAL AND FINAL X.
! NL2ITR... REVERSE-COMMUNICATION ROUTINE THAT CARRIES OUT NL2SOL ALGORITHM.
!
!     LOGICAL STRTED
!     INTEGER D1, J1, NF, R1
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER D, J, NFCALL, NFGCAL, R, TOOBIG
!
!  ***  IV SUBSCRIPT VALUES  ***
!
      data nfcall/6/, nfgcal/7/, toobig/2/
!
!  ***  V SUBSCRIPT VALUES  ***
!
      data d/27/, j/33/, r/50/
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
      d1 = 94 + 2*n + p*(3*p + 31)/2
      iv(d) = d1
      r1 = d1 + p
      iv(r) = r1
      j1 = r1 + n
      iv(j) = j1
      strted = .true.
      if (iv(1) .ne. 0 .and. iv(1) .ne. 12) go to 40
         strted = .false.
         iv(nfcall) = 1
         iv(nfgcal) = 1
!
 10   nf = iv(nfcall)
      call calcr(n, p, x, nf, v(r1), uiparm, urparm, ufparm)
      if (strted) go to 20
         if (nf .gt. 0) go to 30
              iv(1) = 13
              go to 60
!
 20   if (nf .le. 0) iv(toobig) = 1
      go to 40
!
 30   call calcj(n, p, x, iv(nfgcal), v(j1), uiparm, urparm, ufparm)
      if (iv(nfgcal) .eq. 0) go to 50
      strted = .true.
!
 40   call nl2itr(v(d1), iv, v(j1), n, n, p, v(r1), v, x)
      if (iv(1) - 2) 10, 30, 999
!
 50   iv(1) = 15
 60   call itsmry(v(d1), iv, p, v, x)
!
 999  return
!  ***  LAST CARD OF NL2SOL FOLLOWS  ***
      end
!RMDCON
      real(kind=wp) function rmdcon(k,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer k
!
!  LOCAL SCALARS
      real(kind=wp) :: big,eta,machep,one001,pt999
!
!  EXTERNAL FUNCTIONS
!     real(kind=wp) :: mach
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!
!  ***  RETURN MACHINE DEPENDENT CONSTANTS USED BY NL2SOL  ***
!
! +++  COMMENTS BELOW CONTAIN DATA STATEMENTS FOR VARIOUS MACHINES.  +++
! +++  TO CONVERT TO ANOTHER MACHINE, PLACE A C IN COLUMN 1 OF THE   +++
! +++  DATA STATEMENT LINE(S) THAT CORRESPOND TO THE CURRENT MACHINE +++
! +++  AND REMOVE THE C FROM COLUMN 1 OF THE DATA STATEMENT LINE(S)  +++
! +++  THAT CORRESPOND TO THE NEW MACHINE.                           +++
!
!     INTEGER K
!
!  ***  THE CONSTANT RETURNED DEPENDS ON K...
!
!  ***        K = 1... SMALLEST POS. ETA SUCH THAT -ETA EXISTS.
!  ***        K = 2... SQUARE ROOT OF 1.001*ETA.
!  ***        K = 3... UNIT ROUNDOFF = SMALLEST POS. NO. MACHEP SUCH
!  ***                 THAT 1 + MACHEP .GT. 1 .AND. 1 - MACHEP .LT. 1.
!  ***        K = 4... SQUARE ROOT OF 0.999*MACHEP.
!  ***        K = 5... SQUARE ROOT OF 0.999*BIG (SEE K = 6).
!  ***        K = 6... LARGEST MACHINE NO. BIG SUCH THAT -BIG EXISTS.
!
!
      data one001/1.001_wp/, pt999/0.999_wp/
!
      big = mach(2)
      eta = mach(1)
      machep = mach(4)
!
!-------------------------------  BODY  --------------------------------
!
      go to (10, 20, 30, 40, 50, 60), k
!
 10   rmdcon = eta
      go to 999
!
 20   rmdcon = sqrt(one001*eta)
      go to 999
!
 30   rmdcon = machep
      go to 999
!
 40   rmdcon = sqrt(pt999*machep)
      go to 999
!
 50   rmdcon = sqrt(pt999*big)
      go to 999
!
 60   rmdcon = big
!
 999  return
!  ***  LAST CARD OF RMDCON FOLLOWS  ***
      end

      end module M_starpac_d
