      module M_starpac_s
      use M_starpac_g
      implicit none
      private
      integer,parameter,private :: wp=kind(0.0)

      private ::  mach
      private ::  correr
      private ::  randu

      interface  abscom;  module  procedure  abscom;  end  interface
      interface  accdig;  module  procedure  accdig;  end  interface
      interface  acfd;    module  procedure  acfd;    end  interface
      interface  acff;    module  procedure  acff;    end  interface
      interface  acffs;   module  procedure  acffs;   end  interface
      interface  acflst;  module  procedure  acflst;  end  interface
      interface  acfm;    module  procedure  acfm;    end  interface
      interface  acfmnf;  module  procedure  acfmnf;  end  interface
      interface  acfmnm;  module  procedure  acfmnm;  end  interface
      interface  acfmn;   module  procedure  acfmn;   end  interface
      interface  acf;     module  procedure  acf;     end  interface
      interface  acfms;   module  procedure  acfms;   end  interface
      interface  acfout;  module  procedure  acfout;  end  interface
      interface  acfsdm;  module  procedure  acfsdm;  end  interface
      interface  acfsd;   module  procedure  acfsd;   end  interface
      interface  acfs;    module  procedure  acfs;    end  interface
      interface  acvff;   module  procedure  acvff;   end  interface
      interface  acvfm;   module  procedure  acvfm;   end  interface
      interface  acvf;    module  procedure  acvf;    end  interface
      interface  adjlmt;  module  procedure  adjlmt;  end  interface
      interface  aimec;   module  procedure  aimec;   end  interface
      interface  aime;    module  procedure  aime;    end  interface
      interface  aimes;   module  procedure  aimes;   end  interface
      interface  aimf;    module  procedure  aimf;    end  interface
      interface  aimfs;   module  procedure  aimfs;   end  interface
      interface  aimx1;   module  procedure  aimx1;   end  interface
      interface  amdrv;   module  procedure  amdrv;   end  interface
      interface  ameanm;  module  procedure  ameanm;  end  interface
      interface  amean;   module  procedure  amean;   end  interface
      interface  amecnt;  module  procedure  amecnt;  end  interface
      interface  amedrv;  module  procedure  amedrv;  end  interface
      interface  ameer;   module  procedure  ameer;   end  interface
      interface  amefin;  module  procedure  amefin;  end  interface
      interface  ameism;  module  procedure  ameism;  end  interface
      interface  amemn;   module  procedure  amemn;   end  interface
      interface  ameout;  module  procedure  ameout;  end  interface
      interface  amept1;  module  procedure  amept1;  end  interface
      interface  amept2;  module  procedure  amept2;  end  interface
      interface  amestp;  module  procedure  amestp;  end  interface
      interface  amfcnt;  module  procedure  amfcnt;  end  interface
      interface  amfmn;   module  procedure  amfmn;   end  interface
      interface  amfout;  module  procedure  amfout;  end  interface
      interface  amlst1;  module  procedure  amlst1;  end  interface
      interface  amlst;   module  procedure  amlst;   end  interface
      interface  aoslst;  module  procedure  aoslst;  end  interface
      interface  aos;     module  procedure  aos;     end  interface
      interface  aov1er;  module  procedure  aov1er;  end  interface
      interface  aov1mn;  module  procedure  aov1mn;  end  interface
      interface  aov1;    module  procedure  aov1;    end  interface
      interface  aov1s;   module  procedure  aov1s;   end  interface
      interface  aov1xp;  module  procedure  aov1xp;  end  interface
      interface  arcoef;  module  procedure  arcoef;  end  interface
      interface  arflt;   module  procedure  arflt;   end  interface
      interface  assess;  module  procedure  assess;  end  interface
      interface  axpby;   module  procedure  axpby;   end  interface
      interface  bfsdrv;  module  procedure  bfsdrv;  end  interface
      interface  bfsf;    module  procedure  bfsf;    end  interface
      interface  bfsfs;   module  procedure  bfsfs;   end  interface
      interface  bfslag;  module  procedure  bfslag;  end  interface
      interface  bfsm;    module  procedure  bfsm;    end  interface
      interface  bfsmn;   module  procedure  bfsmn;   end  interface
      interface  bfs;     module  procedure  bfs;     end  interface
      interface  bfsms;   module  procedure  bfsms;   end  interface
      interface  bfsmv;   module  procedure  bfsmv;   end  interface
      interface  bfsmvs;  module  procedure  bfsmvs;  end  interface
      interface  bfss;    module  procedure  bfss;    end  interface
      interface  bfsv;    module  procedure  bfsv;    end  interface
      interface  bfsvs;   module  procedure  bfsvs;   end  interface
      interface  ccff;    module  procedure  ccff;    end  interface
      interface  ccffs;   module  procedure  ccffs;   end  interface
      interface  ccflst;  module  procedure  ccflst;  end  interface
      interface  ccfm;    module  procedure  ccfm;    end  interface
      interface  ccfmnf;  module  procedure  ccfmnf;  end  interface
      interface  ccfmnm;  module  procedure  ccfmnm;  end  interface
      interface  ccfmn;   module  procedure  ccfmn;   end  interface
      interface  ccf;     module  procedure  ccf;     end  interface
      interface  ccfms;   module  procedure  ccfms;   end  interface
      interface  ccfout;  module  procedure  ccfout;  end  interface
      interface  ccfsdm;  module  procedure  ccfsdm;  end  interface
      interface  ccfsd;   module  procedure  ccfsd;   end  interface
      interface  ccfs;    module  procedure  ccfs;    end  interface
      interface  ccfxp;   module  procedure  ccfxp;   end  interface
      interface  ccvff;   module  procedure  ccvff;   end  interface
      interface  ccvfm;   module  procedure  ccvfm;   end  interface
      interface  ccvf;    module  procedure  ccvf;    end  interface
      interface  cdfchi;  module  procedure  cdfchi;  end  interface
      interface  cdff;    module  procedure  cdff;    end  interface
      interface  cdfnml;  module  procedure  cdfnml;  end  interface
      interface  cdft;    module  procedure  cdft;    end  interface
      interface  center;  module  procedure  center;  end  interface
      interface  chirho;  module  procedure  chirho;  end  interface
      interface  cmpfd;   module  procedure  cmpfd;   end  interface
      interface  cntr;    module  procedure  cntr;    end  interface
      interface  corrmn;  module  procedure  corrmn;  end  interface
      interface  corr;    module  procedure  corr;    end  interface
      interface  corrs;   module  procedure  corrs;   end  interface
      interface  corrxp;  module  procedure  corrxp;  end  interface
      interface  covclc;  module  procedure  covclc;  end  interface
      interface  cpyasf;  module  procedure  cpyasf;  end  interface
      interface  cpymss;  module  procedure  cpymss;  end  interface
      interface  dckcnt;  module  procedure  dckcnt;  end  interface
      interface  dckcrv;  module  procedure  dckcrv;  end  interface
      interface  dckdrv;  module  procedure  dckdrv;  end  interface
      interface  dcker;   module  procedure  dcker;   end  interface
      interface  dckfpa;  module  procedure  dckfpa;  end  interface
      interface  dckls1;  module  procedure  dckls1;  end  interface
      interface  dcklsc;  module  procedure  dcklsc;  end  interface
      interface  dckls;   module  procedure  dckls;   end  interface
      interface  dckmn;   module  procedure  dckmn;   end  interface
      interface  dckout;  module  procedure  dckout;  end  interface
      interface  dckzro;  module  procedure  dckzro;  end  interface
      interface  dcoef;   module  procedure  dcoef;   end  interface
      interface  demdrv;  module  procedure  demdrv;  end  interface
      interface  demod;   module  procedure  demod;   end  interface
      interface  demods;  module  procedure  demods;  end  interface
      interface  demodu;  module  procedure  demodu;  end  interface
      interface  demord;  module  procedure  demord;  end  interface
      interface  demout;  module  procedure  demout;  end  interface
      interface  dfault;  module  procedure  dfault;  end  interface
      interface  dfbwm;   module  procedure  dfbwm;   end  interface
      interface  dfbw;    module  procedure  dfbw;    end  interface
      interface  difc;    module  procedure  difc;    end  interface
      interface  difmc;   module  procedure  difmc;   end  interface
      interface  difm;    module  procedure  difm;    end  interface
      interface  dif;     module  procedure  dif;     end  interface
      interface  difser;  module  procedure  difser;  end  interface
      interface  dotcm;   module  procedure  dotcm;   end  interface
      interface  dotc;    module  procedure  dotc;    end  interface
      interface  dotprd;  module  procedure  dotprd;  end  interface
      interface  drv1a;   module  procedure  drv1a;   end  interface
      interface  drv1b;   module  procedure  drv1b;   end  interface
      interface  drv2;    module  procedure  drv2;    end  interface
      interface  drv3;    module  procedure  drv3;    end  interface
      interface  drv4a;   module  procedure  drv4a;   end  interface
      interface  drv4b;   module  procedure  drv4b;   end  interface
      interface  drv;     module  procedure  drv;     end  interface
      interface  dupdat;  module  procedure  dupdat;  end  interface
      interface  eragtm;  module  procedure  eragtm;  end  interface
      interface  eragt;   module  procedure  eragt;   end  interface
      interface  eragtp;  module  procedure  eragtp;  end  interface
      interface  ersei;   module  procedure  ersei;   end  interface
      interface  ersge;   module  procedure  ersge;   end  interface
      interface  ersgt;   module  procedure  ersgt;   end  interface
      interface  ersie;   module  procedure  ersie;   end  interface
      interface  ersii;   module  procedure  ersii;   end  interface
      interface  erslf;   module  procedure  erslf;   end  interface
      interface  erslfs;  module  procedure  erslfs;  end  interface
      interface  ervgtm;  module  procedure  ervgtm;  end  interface
      interface  ervgt;   module  procedure  ervgt;   end  interface
      interface  ervgtp;  module  procedure  ervgtp;  end  interface
      interface  ervii;   module  procedure  ervii;   end  interface
      interface  ervwt;   module  procedure  ervwt;   end  interface
      interface  etamdl;  module  procedure  etamdl;  end  interface
      interface  extend;  module  procedure  extend;  end  interface
      interface  fftct;   module  procedure  fftct;   end  interface
      interface  fft;     module  procedure  fft;     end  interface
      interface  fftr;    module  procedure  fftr;    end  interface
      interface  fitext;  module  procedure  fitext;  end  interface
      interface  fitpt1;  module  procedure  fitpt1;  end  interface
      interface  fitpt2;  module  procedure  fitpt2;  end  interface
      interface  fitsxp;  module  procedure  fitsxp;  end  interface
      interface  fitxsp;  module  procedure  fitxsp;  end  interface
      interface  fltarm;  module  procedure  fltarm;  end  interface
      interface  fltar;   module  procedure  fltar;   end  interface
      interface  fltma;   module  procedure  fltma;   end  interface
      interface  fltmd;   module  procedure  fltmd;   end  interface
      interface  fltsl;   module  procedure  fltsl;   end  interface
      interface  genr;    module  procedure  genr;    end  interface
      interface  getpi;   module  procedure  getpi;   end  interface
      interface  gfaest;  module  procedure  gfaest;  end  interface
      interface  gfarf;   module  procedure  gfarf;   end  interface
      interface  gfarfs;  module  procedure  gfarfs;  end  interface
      interface  gford;   module  procedure  gford;   end  interface
      interface  gfout;   module  procedure  gfout;   end  interface
      interface  gfsest;  module  procedure  gfsest;  end  interface
      interface  gfslf;   module  procedure  gfslf;   end  interface
      interface  gfslfs;  module  procedure  gfslfs;  end  interface
      interface  gmean;   module  procedure  gmean;   end  interface
      interface  gqtstp;  module  procedure  gqtstp;  end  interface
      interface  hipass;  module  procedure  hipass;  end  interface
      interface  histc;   module  procedure  histc;   end  interface
      interface  hist;    module  procedure  hist;    end  interface
      interface  hpcoef;  module  procedure  hpcoef;  end  interface
      interface  hpflt;   module  procedure  hpflt;   end  interface
      interface  hster;   module  procedure  hster;   end  interface
      interface  hstmn;   module  procedure  hstmn;   end  interface
      interface  ipgdv;   module  procedure  ipgdv;   end  interface
      interface  ipgm;    module  procedure  ipgm;    end  interface
      interface  ipgmn;   module  procedure  ipgmn;   end  interface
      interface  ipgmp;   module  procedure  ipgmp;   end  interface
      interface  ipgmps;  module  procedure  ipgmps;  end  interface
      interface  ipgms;   module  procedure  ipgms;   end  interface
      interface  ipgord;  module  procedure  ipgord;  end  interface
      interface  ipgout;  module  procedure  ipgout;  end  interface
      interface  itsmry;  module  procedure  itsmry;  end  interface
      interface  linvrt;  module  procedure  linvrt;  end  interface
      interface  litvmu;  module  procedure  litvmu;  end  interface
      interface  livmul;  module  procedure  livmul;  end  interface
      interface  llcntg;  module  procedure  llcntg;  end  interface
      interface  llcnt;   module  procedure  llcnt;   end  interface
      interface  llcntp;  module  procedure  llcntp;  end  interface
      interface  ller;    module  procedure  ller;    end  interface
      interface  llsmn;   module  procedure  llsmn;   end  interface
      interface  lls;     module  procedure  lls;     end  interface
      interface  llsp;    module  procedure  llsp;    end  interface
      interface  llsps;   module  procedure  llsps;   end  interface
      interface  llspw;   module  procedure  llspw;   end  interface
      interface  llspws;  module  procedure  llspws;  end  interface
      interface  llss;    module  procedure  llss;    end  interface
      interface  llsw;    module  procedure  llsw;    end  interface
      interface  llsws;   module  procedure  llsws;   end  interface
      interface  lmstep;  module  procedure  lmstep;  end  interface
      interface  loglmt;  module  procedure  loglmt;  end  interface
      interface  lopass;  module  procedure  lopass;  end  interface
      interface  lpcoef;  module  procedure  lpcoef;  end  interface
      interface  lpflt;   module  procedure  lpflt;   end  interface
      interface  lsqrt;   module  procedure  lsqrt;   end  interface
      interface  lstvcf;  module  procedure  lstvcf;  end  interface
      interface  lstvec;  module  procedure  lstvec;  end  interface
      interface  lsvmin;  module  procedure  lsvmin;  end  interface
      interface  ltsqar;  module  procedure  ltsqar;  end  interface
      interface  madj;    module  procedure  madj;    end  interface
      interface  madr;    module  procedure  madr;    end  interface
      interface  maflt;   module  procedure  maflt;   end  interface
      interface  matprf;  module  procedure  matprf;  end  interface
      interface  matprt;  module  procedure  matprt;  end  interface
      interface  mdflt;   module  procedure  mdflt;   end  interface
      interface  mdl1;    module  procedure  mdl1;    end  interface
      interface  mdl2;    module  procedure  mdl2;    end  interface
      interface  mdl3;    module  procedure  mdl3;    end  interface
      interface  mdl4;    module  procedure  mdl4;    end  interface
      interface  mdlts1;  module  procedure  mdlts1;  end  interface
      interface  mdlts2;  module  procedure  mdlts2;  end  interface
      interface  mdlts3;  module  procedure  mdlts3;  end  interface
      interface  mgs;     module  procedure  mgs;     end  interface
      interface  mppc;    module  procedure  mppc;    end  interface
      interface  mppl;    module  procedure  mppl;    end  interface
      interface  mppmc;   module  procedure  mppmc;   end  interface
      interface  mppml;   module  procedure  mppml;   end  interface
      interface  mppm;    module  procedure  mppm;    end  interface
      interface  mpp;     module  procedure  mpp;     end  interface
      interface  multbp;  module  procedure  multbp;  end  interface
      interface  mvchk;   module  procedure  mvchk;   end  interface
      interface  mvpc;    module  procedure  mvpc;    end  interface
      interface  mvpl;    module  procedure  mvpl;    end  interface
      interface  mvpmc;   module  procedure  mvpmc;   end  interface
      interface  mvpml;   module  procedure  mvpml;   end  interface
      interface  mvpm;    module  procedure  mvpm;    end  interface
      interface  mvp;     module  procedure  mvp;     end  interface
      interface  nl2itr;  module  procedure  nl2itr;  end  interface
      interface  nl2sno;  module  procedure  nl2sno;  end  interface
      interface  nl2sol;  module  procedure  nl2sol;  end  interface
      interface  nl2x;    module  procedure  nl2x;    end  interface
      interface  nlcmp;   module  procedure  nlcmp;   end  interface
      interface  nlcnta;  module  procedure  nlcnta;  end  interface
      interface  nlcnt;   module  procedure  nlcnt;   end  interface
      interface  nlcntn;  module  procedure  nlcntn;  end  interface
      interface  nldrva;  module  procedure  nldrva;  end  interface
      interface  nldrvn;  module  procedure  nldrvn;  end  interface
      interface  nler;    module  procedure  nler;    end  interface
      interface  nlfin;   module  procedure  nlfin;   end  interface
      interface  nlinit;  module  procedure  nlinit;  end  interface
      interface  nlism;   module  procedure  nlism;   end  interface
      interface  nlitrp;  module  procedure  nlitrp;  end  interface
      interface  nlmn;    module  procedure  nlmn;    end  interface
      interface  nlout;   module  procedure  nlout;   end  interface
      interface  nlsc;    module  procedure  nlsc;    end  interface
      interface  nlsdc;   module  procedure  nlsdc;   end  interface
      interface  nlsd;    module  procedure  nlsd;    end  interface
      interface  nlsds;   module  procedure  nlsds;   end  interface
      interface  nls;     module  procedure  nls;     end  interface
      interface  nlspk;   module  procedure  nlspk;   end  interface
      interface  nlss;    module  procedure  nlss;    end  interface
      interface  nlsupk;  module  procedure  nlsupk;  end  interface
      interface  nlswc;   module  procedure  nlswc;   end  interface
      interface  nlswdc;  module  procedure  nlswdc;  end  interface
      interface  nlswd;   module  procedure  nlswd;   end  interface
      interface  nlswds;  module  procedure  nlswds;  end  interface
      interface  nlsw;    module  procedure  nlsw;    end  interface
      interface  nlsws;   module  procedure  nlsws;   end  interface
      interface  nlsx1;   module  procedure  nlsx1;   end  interface
      interface  nlsx2;   module  procedure  nlsx2;   end  interface
      interface  nrandc;  module  procedure  nrandc;  end  interface
      interface  nrand;   module  procedure  nrand;   end  interface
      interface  oanova;  module  procedure  oanova;  end  interface
      interface  obssm2;  module  procedure  obssm2;  end  interface
      interface  obssum;  module  procedure  obssum;  end  interface
      interface  parchk;  module  procedure  parchk;  end  interface
      interface  parzen;  module  procedure  parzen;  end  interface
      interface  pgmest;  module  procedure  pgmest;  end  interface
      interface  pgmmn;   module  procedure  pgmmn;   end  interface
      interface  pgm;     module  procedure  pgm;     end  interface
      interface  pgms;    module  procedure  pgms;    end  interface
      interface  pgord;   module  procedure  pgord;   end  interface
      interface  pgout;   module  procedure  pgout;   end  interface
      interface  pltchk;  module  procedure  pltchk;  end  interface
      interface  pltplx;  module  procedure  pltplx;  end  interface
      interface  polar;   module  procedure  polar;   end  interface
      interface  ppc;     module  procedure  ppc;     end  interface
      interface  ppcnt;   module  procedure  ppcnt;   end  interface
      interface  ppfchs;  module  procedure  ppfchs;  end  interface
      interface  ppff;    module  procedure  ppff;    end  interface
      interface  ppfnml;  module  procedure  ppfnml;  end  interface
      interface  ppft;    module  procedure  ppft;    end  interface
      interface  ppl;     module  procedure  ppl;     end  interface
      interface  pplmt;   module  procedure  pplmt;   end  interface
      interface  ppmc;    module  procedure  ppmc;    end  interface
      interface  ppml;    module  procedure  ppml;    end  interface
      interface  ppm;     module  procedure  ppm;     end  interface
      interface  ppmn;    module  procedure  ppmn;    end  interface
      interface  pp;      module  procedure  pp;      end  interface
      interface  qapply;  module  procedure  qapply;  end  interface
      interface  qrfact;  module  procedure  qrfact;  end  interface
      interface  randn;   module  procedure  randn;   end  interface
      interface  ranko;   module  procedure  ranko;   end  interface
      interface  realtr;  module  procedure  realtr;  end  interface
      interface  relcom;  module  procedure  relcom;  end  interface
      interface  reldst;  module  procedure  reldst;  end  interface
      interface  repck;   module  procedure  repck;   end  interface
      interface  rmdcon;  module  procedure  rmdcon;  end  interface
      interface  rptmul;  module  procedure  rptmul;  end  interface
      interface  sample;  module  procedure  sample;  end  interface
      interface  setfrq;  module  procedure  setfrq;  end  interface
      interface  setra;   module  procedure  setra;   end  interface
      interface  setrow;  module  procedure  setrow;  end  interface
      interface  setrv;   module  procedure  setrv;   end  interface
      interface  slflt;   module  procedure  slflt;   end  interface
      interface  slupdt;  module  procedure  slupdt;  end  interface
      interface  slvmul;  module  procedure  slvmul;  end  interface
      interface  smply;   module  procedure  smply;   end  interface
      interface  spcck;   module  procedure  spcck;   end  interface
      interface  sppc;    module  procedure  sppc;    end  interface
      interface  sppl;    module  procedure  sppl;    end  interface
      interface  sppltc;  module  procedure  sppltc;  end  interface
      interface  sppltd;  module  procedure  sppltd;  end  interface
      interface  sppltl;  module  procedure  sppltl;  end  interface
      interface  sppmc;   module  procedure  sppmc;   end  interface
      interface  sppml;   module  procedure  sppml;   end  interface
      interface  sppm;    module  procedure  sppm;    end  interface
      interface  spp;     module  procedure  spp;     end  interface
      interface  srtir;   module  procedure  srtir;   end  interface
      interface  srtirr;  module  procedure  srtirr;  end  interface
      interface  srtri;   module  procedure  srtri;   end  interface
      interface  srtrri;  module  procedure  srtrri;  end  interface
      interface  stat1;   module  procedure  stat1;   end  interface
      interface  stat1w;  module  procedure  stat1w;  end  interface
      interface  stat2;   module  procedure  stat2;   end  interface
      interface  stat2w;  module  procedure  stat2w;  end  interface
      interface  stater;  module  procedure  stater;  end  interface
      interface  stat;    module  procedure  stat;    end  interface
      interface  stats;   module  procedure  stats;   end  interface
      interface  statw;   module  procedure  statw;   end  interface
      interface  statws;  module  procedure  statws;  end  interface
      interface  stpadj;  module  procedure  stpadj;  end  interface
      interface  stpamo;  module  procedure  stpamo;  end  interface
      interface  stpcnt;  module  procedure  stpcnt;  end  interface
      interface  stpdrv;  module  procedure  stpdrv;  end  interface
      interface  stper;   module  procedure  stper;   end  interface
      interface  stpls1;  module  procedure  stpls1;  end  interface
      interface  stpls2;  module  procedure  stpls2;  end  interface
      interface  stplsc;  module  procedure  stplsc;  end  interface
      interface  stpls;   module  procedure  stpls;   end  interface
      interface  stpmn;   module  procedure  stpmn;   end  interface
      interface  stpout;  module  procedure  stpout;  end  interface
      interface  stpsel;  module  procedure  stpsel;  end  interface
      interface  sumbs;   module  procedure  sumbs;   end  interface
      interface  sumds;   module  procedure  sumds;   end  interface
      interface  sumid;   module  procedure  sumid;   end  interface
      interface  sumidw;  module  procedure  sumidw;  end  interface
      interface  sumot;   module  procedure  sumot;   end  interface
      interface  sumss;   module  procedure  sumss;   end  interface
      interface  sumts;   module  procedure  sumts;   end  interface
      interface  sumwds;  module  procedure  sumwds;  end  interface
      interface  sumwss;  module  procedure  sumwss;  end  interface
      interface  sumwts;  module  procedure  sumwts;  end  interface
      interface  svpc;    module  procedure  svpc;    end  interface
      interface  svpl;    module  procedure  svpl;    end  interface
      interface  svpmc;   module  procedure  svpmc;   end  interface
      interface  svpml;   module  procedure  svpml;   end  interface
      interface  svpm;    module  procedure  svpm;    end  interface
      interface  svp;     module  procedure  svp;     end  interface
      interface  taper;   module  procedure  taper;   end  interface
      interface  uascft;  module  procedure  uascft;  end  interface
      interface  uasdv;   module  procedure  uasdv;   end  interface
      interface  uaser;   module  procedure  uaser;   end  interface
      interface  uasest;  module  procedure  uasest;  end  interface
      interface  uasf;    module  procedure  uasf;    end  interface
      interface  uasfs;   module  procedure  uasfs;   end  interface
      interface  uas;     module  procedure  uas;     end  interface
      interface  uasord;  module  procedure  uasord;  end  interface
      interface  uasout;  module  procedure  uasout;  end  interface
      interface  uass;    module  procedure  uass;    end  interface
      interface  uasvar;  module  procedure  uasvar;  end  interface
      interface  uasv;    module  procedure  uasv;    end  interface
      interface  uasvs;   module  procedure  uasvs;   end  interface
      interface  ufsdrv;  module  procedure  ufsdrv;  end  interface
      interface  ufsest;  module  procedure  ufsest;  end  interface
      interface  ufsf;    module  procedure  ufsf;    end  interface
      interface  ufsfs;   module  procedure  ufsfs;   end  interface
      interface  ufslag;  module  procedure  ufslag;  end  interface
      interface  ufsm;    module  procedure  ufsm;    end  interface
      interface  ufsmn;   module  procedure  ufsmn;   end  interface
      interface  ufs;     module  procedure  ufs;     end  interface
      interface  ufsms;   module  procedure  ufsms;   end  interface
      interface  ufsmv;   module  procedure  ufsmv;   end  interface
      interface  ufsmvs;  module  procedure  ufsmvs;  end  interface
      interface  ufsout;  module  procedure  ufsout;  end  interface
      interface  ufspcv;  module  procedure  ufspcv;  end  interface
      interface  ufss;    module  procedure  ufss;    end  interface
      interface  ufsv;    module  procedure  ufsv;    end  interface
      interface  ufsvs;   module  procedure  ufsvs;   end  interface
      interface  v2norm;  module  procedure  v2norm;  end  interface
      interface  vaxpy;   module  procedure  vaxpy;   end  interface
      interface  vcopy;   module  procedure  vcopy;   end  interface
      interface  vcvotf;  module  procedure  vcvotf;  end  interface
      interface  vcvout;  module  procedure  vcvout;  end  interface
      interface  vpc;     module  procedure  vpc;     end  interface
      interface  vpcnt;   module  procedure  vpcnt;   end  interface
      interface  vphead;  module  procedure  vphead;  end  interface
      interface  vpl;     module  procedure  vpl;     end  interface
      interface  vplmt;   module  procedure  vplmt;   end  interface
      interface  vpmc;    module  procedure  vpmc;    end  interface
      interface  vpml;    module  procedure  vpml;    end  interface
      interface  vpm;     module  procedure  vpm;     end  interface
      interface  vpmn;    module  procedure  vpmn;    end  interface
      interface  vp;      module  procedure  vp;      end  interface
      interface  vscopy;  module  procedure  vscopy;  end  interface
      interface  xacf;    module  procedure  xacf;    end  interface
      interface  xaimd;   module  procedure  xaimd;   end  interface
      interface  xaimt;   module  procedure  xaimt;   end  interface
      interface  xaov1;   module  procedure  xaov1;   end  interface
      interface  xbfs;    module  procedure  xbfs;    end  interface
      interface  xccf;    module  procedure  xccf;    end  interface
      interface  xcorr;   module  procedure  xcorr;   end  interface
      interface  xdckld;  module  procedure  xdckld;  end  interface
      interface  xdckle;  module  procedure  xdckle;  end  interface
      interface  xdcklt;  module  procedure  xdcklt;  end  interface
      interface  xdemod;  module  procedure  xdemod;  end  interface
      interface  xdflt;   module  procedure  xdflt;   end  interface
      interface  xhist;   module  procedure  xhist;   end  interface
      interface  xlls;    module  procedure  xlls;    end  interface
      interface  xnlsd;   module  procedure  xnlsd;   end  interface
      interface  xnlse;   module  procedure  xnlse;   end  interface
      interface  xnlst;   module  procedure  xnlst;   end  interface
      interface  xnrand;  module  procedure  xnrand;  end  interface
      interface  xpgm;    module  procedure  xpgm;    end  interface
      interface  xpp;     module  procedure  xpp;     end  interface
      interface  xstat;   module  procedure  xstat;   end  interface
      interface  xstpld;  module  procedure  xstpld;  end  interface
      interface  xstple;  module  procedure  xstple;  end  interface
      interface  xstplt;  module  procedure  xstplt;  end  interface
      interface  xuas;    module  procedure  xuas;    end  interface
      interface  xufs;    module  procedure  xufs;    end  interface
      interface  xvp;     module  procedure  xvp;     end  interface
      interface  xxch10;  module  procedure  xxch10;  end  interface
      interface  xxch11;  module  procedure  xxch11;  end  interface
      interface  xxch12;  module  procedure  xxch12;  end  interface
      interface  xxch13;  module  procedure  xxch13;  end  interface
      interface  xxch1;   module  procedure  xxch1;   end  interface
      interface  xxch2;   module  procedure  xxch2;   end  interface
      interface  xxch3;   module  procedure  xxch3;   end  interface
      interface  xxch4;   module  procedure  xxch4;   end  interface
      interface  xxch5;   module  procedure  xxch5;   end  interface
      interface  xxch6;   module  procedure  xxch6;   end  interface
      interface  xxch7;   module  procedure  xxch7;   end  interface
      interface  xxch8;   module  procedure  xxch8;   end  interface
      interface  xxch9;   module  procedure  xxch9;   end  interface

      contains
      function mach(i)
!*****************************************************************************80
! CAN REPLACE THIS WITH AN ARRAY OF CONSTANTS OR DIRECT CALLS
!*****************************************************************************80
!
!! MACH returns double precision real machine constants.
!
!  Discussion:
!
!    Assuming that the internal representation of a double precision real
!    number is in base B, with T the number of base-B digits in the mantissa,
!    and EMIN the smallest possible exponent and EMAX the largest possible
!    exponent, then
!
!      MACH(1) = B**(EMIN-1), the smallest positive magnitude.
!      MACH(2) = B**EMAX*(1-B**(-T)), the largest magnitude.
!      MACH(3) = B**(-T), the smallest relative spacing.
!      MACH(4) = B**(1-T), the largest relative spacing.
!      MACH(5) = log10(B).
!
!  Modified:
!
!    24 April 2007
!    14 May   2022
!
!  Author:
!
!    Phyllis Fox, Andrew Hall, Norman Schryer
!    John S. Urban
!
!  Reference:
!
!    Phyllis Fox, Andrew Hall, Norman Schryer,
!    Algorithm 528:
!    Framework for a Portable Library,
!    ACM Transactions on Mathematical Software,
!    Volume 4, Number 2, June 1978, page 176-188.
!
!  Parameters:
!
!    Input, integer I, chooses the parameter to be returned.
!    1 <= I <= 5.
!
!    Output, real ( kind = wp ) MACH, the value of the chosen parameter.
!
!===============================================================================
! intrinsics
! exponent     -  Exponent function
! fraction     -  Fractional part of the model representation
! nearest      -  Nearest representable number
! rrspacing    -  Reciprocal of the relative spacing
! scale        -  Scale a real value
! set_exponent -  Set the exponent of the model
!
! spacing      -  Smallest distance between two numbers of a given type
! digits       -  Significant digits function
! epsilon      -  Epsilon function
! maxexponent  -  Maximum exponent of a real kind
! minexponent  -  Minimum exponent of a real kind
! precision    -  Decimal precision of a real kind
! radix        -  Base of a model number
! range        -  Decimal exponent range of a real kind
! tiny         -  Smallest positive number of a real kind
! huge         -  Largest number of a kind
!====================================================================================================================================
      implicit none
      integer,parameter       :: b = radix(0.0_wp)
      integer,parameter       :: t = digits (0.0_wp )
      real(kind=wp),parameter :: emin=minexponent(0.0_wp)
      real(kind=wp),parameter :: emax=maxexponent(0.0_wp)
      real ( kind = wp ) mach
      integer i

      select case(i)
      case(1); mach = tiny(0.0_wp)               ! B**(EMIN-1), the smallest positive magnitude.
      case(2); mach = huge(0.0_wp)               ! B**EMAX*(1-B**(-T)), the largest magnitude.
                                                 ! calculating this by formula could cause overflow without using a larger type
      case(3); mach = real(b,kind=wp)**(-t)      ! B**(-T), the smallest relative spacing.
      case(4); mach = epsilon(0.0_wp)            ! B**(1-T), the largest relative spacing.
      case(5); mach = log10(real(b,kind=wp))     ! log10(B).
      case default
         write ( *, '(a)' ) ' '
         write ( *, '(a)' ) 'MACH - Fatal error!'
         write ( *, '(a)' ) '  The input argument I is out of bounds.'
         write ( *, '(a)' ) '  Legal values satisfy 1 <= I <= 5.'
         write ( *, '(a,i12)' ) '  I = ', i
         mach = 0.0d+00
         stop
      end select

      end function mach

!AMECNT
     subroutine amecnt(y, wt, lwt, xm, n, m, ixm, mdl, nldrv, aprxdv,&
    &   drv, par, npar, res, ifixed, lifixd, stp, lstp, mit, stopss,&
    &   stopp, scale, lscale, delta, ivaprx, rsd, pv, lpv, sdpv,&
    &   lsdpv, sdres, lsdres, vcv, ivcv, weight, save, nnzw, npare,&
     &   nlhdr, page, wide, iptout, ndigit, hlfrpt, nrests)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: delta,rsd,stopp,stopss
     integer&
    &   ivaprx,ivcv,ixm,lifixd,lpv,lscale,lsdpv,lsdres,lstp,lwt,m,&
     &   mit,n,ndigit,nnzw,npar,npare,nrests
      logical :: aprxdv,hlfrpt,page,save,weight,wide
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   par(*),pv(*),res(*),scale(*),sdpv(*),sdres(*),stp(*),&
     &   vcv(ivcv,*),wt(*),xm(ixm,*),y(*)
      integer :: ifixed(*),iptout(5)
!
!  SUBROUTINE ARGUMENTS
       external drv,mdl,nldrv,nlhdr
!
!  SCALARS IN COMMON
      integer :: ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
    &   d,ifixd,ifp,iiwork,irwork,iwork,lvcvl,nall0,pare,pvi,&
     &   rests,rwork,sdpvi,sdresi,vcvl
!
!  LOCAL ARRAYS
      real(kind=wp) :: rstak(12)
      integer :: istak(12)
!
!  EXTERNAL FUNCTIONS
      integer,external :: stkst
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL AMEMN,CPYASF,CPYVII,SETIV,STKCLR
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     INTEGER D
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE ARRAY IN WHICH THE NUMERICAL DERIVATIVES WITH RESPECT TO
!        EACH PARAMETER ARE STORED.
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD
!        THE STARTING LOCATION IN ISTAK OF
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF IFIXED(I).EQ
!        THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IIWORK
!        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
!     INTEGER IPTOUT(5)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER IRWORK
!        THE DIMENSION OF THE REAL WORK VECTOR RWORK.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IWORK
!        THE STARTING LOCATION IN ISTAK OF
!        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LVCVL
!        THE LENGTH OF THE VECTOR CONTAINING
!        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        NUMBER OF ALLOCATIONS ON ENTRY.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     EXTERNAL NLDRV
!        THE NAME OF THE ROUTINE WHICH CALCULATES THE DERIVATIVES.
!     EXTERNAL NLHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARE
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE CURRENT ESTIMATES OF THE PARAMETERS, BUT ONLY
!        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
!     REAL PV(LPV)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     INTEGER PVI
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE PREDICTED VALUES.
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     INTEGER RESTS
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE RESIDUALS FROM THE ARIMA MODEL.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER RWORK
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE REAL WORK VECTOR USED BY THE NL2 SUBROUTINES.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(LSCALE)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(LSDPV)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     INTEGER SDPVI
!        THE STARTING LOCATION IN RWORK OF
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(LSDRES)
!        THE STANDARDIZED RESIDUALS.
!     INTEGER SDRESI
!        THE STARTING LOCATION IN RWORK OF THE
!        THE STANDARDIZED RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(LSTP)
!        THE STEP SIZE ARRAY.
!     REAL VCV(IVCV,NPAR)
!        THE VARIANCE-COVARIANCE MATRIX.
!     INTEGER VCVL
!        THE STARTING LOCATION IN RWORK OF
!        THE VARIANCE-COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET VARIOUS PROGRAM VALUES
!
      nall0 = stkst(1)
!
      ifp = 3
!
      ierr = 0
!
!     SUBDIVIDE WORK AREA FOR LEAST SQUARES ANALYSIS
!
      iiwork = npare + 60
      irwork = 94 + 2*nrests + npare*(3*npare+33)/2
!
      ifixd = stkget(npar,2)
      iwork = stkget(iiwork,2)
!
      d = stkget(nrests*npar,ifp)
      pare = stkget(npare,ifp)
      rests = stkget(nrests,ifp)
      pvi = rests
      rwork = stkget(irwork,ifp)
!
      if (ierr.eq.1) return
!
!     SET VALUES FOR IFIXD
!
      if (ifixed(1).ge.0) call cpyvii(npar, ifixed, 1, istak(ifixd), 1)
      if (ifixed(1).lt.0) call setiv(istak(ifixd), npar, 0)
!
     call amemn(y, weight, nnzw, wt, lwt, xm, n, m, ixm, nrests,&
    &   aprxdv, istak(ifixd), par, rstak(pare), npar, res, page,&
    &   wide, hlfrpt, stp, lstp, mit, stopss, stopp, scale, lscale,&
    &   delta, ivaprx, iptout, ndigit, rsd, rstak(rests), sdpvi,&
    &   sdresi, vcvl, lvcvl, rstak(d), istak(iwork), iiwork,&
     &   rstak(rwork), irwork, nlhdr, npare, rstak(pvi))
!
      if (.not.save) go to 10
!
      sdpvi = rwork + sdpvi - 1
      sdresi = rwork + sdresi - 1
      vcvl = rwork + vcvl - 1
!
      call scopy(n, rstak(pvi), 1, pv, 1)
      call scopy(n, rstak(sdpvi), 1, sdpv, 1)
      call scopy(n, rstak(sdresi), 1, sdres, 1)
      call cpyasf(npare, rstak(vcvl), lvcvl, vcv, ivcv)
!
   10 call stkclr(nall0)
!
      return
!
      end
!GFSEST
      subroutine gfsest (h, k, nf, freq, gain, delta)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE GAIN FUNCTION OF AN INPUT SYMMETRIC
!     LINEAR FILTER AT THE FREQUENCIES SPECIFIED IN FREQ USING THE
!     TRANSFORM ALGORITHM SHOWN ON PAGE 311 OF JENKINS AND WATTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta
     integer&
     &   k,nf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(nf),gain(nf),h(k)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   c,pi,v0,v1,v2
     integer&
     &   i,j,khalf,kmid
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL GETPI
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,cos
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL C
!        A VALUE USED TO COMPUTE THE GAIN FUNCTION.
!     REAL DELTA
!        THE SAMPLING INTERVAL OF THE ORIGINAL SERIES.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO BE
!        ESTIMATED.
!     REAL GAIN(NF)
!        THE ARRAY IN WHICH THE GAIN FUNCTION ESTIMATES ARE RETURNED.
!     REAL H(K)
!        THE SYMMETRIC LINEAR FILTER WEIGHTS.
!     INTEGER I, J
!        INDEX VARIABLES.
!     INTEGER K
!        THE NUMBER OF TERMS IN THE SYMMETRIC LINEAR FILTER.
!     INTEGER KHALF, KMID
!        HALF THE FILTER LENGTH, AND THE MIDPOINT OF THE FILTER,
!        RESPECTIVELY.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE GAIN FUNCTION ESTIMATES
!        ARE TO BE ESTIMATED.
!     REAL PI
!        THE VALUE OF PI.
!     REAL V0, V1, V2
!        CONSTANTS USED FOR COMPUTING THE GAIN FUNCTION ESTIMATES.
!
      call getpi(pi)
!
!        COMPUTE GAIN FUNCTION ESTIMATES AND THEIR CONFIDENCE LIMITS.
!
      kmid = (k+1) / 2
      khalf = kmid - 1
!
      do 30 i = 1, nf
         c = cos(2.0e0 * pi * freq(i))
         v0 = 0.0e0
         v1 = 0.0e0
         do 20 j = 1, khalf
            v2 = 2.0e0 * c * v1 - v0 + h(j)
            v0 = v1
            v1 = v2
   20    continue
         gain(i) = abs(delta * (h(kmid) + 2.0e0 * (v1 * c - v0)))
   30 continue
      return
      end
!VPM
      subroutine vpm(ym, ymiss, n, ns)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: ymiss
     integer&
     &   n,ns
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ibar,ilog,iprt,irlin,ischck,isize,iym,lisym,m
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
      real(kind=wp) :: ymmiss(1)
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMISS
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  ' ',       'V',       'P',       'M',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      ymmiss=ymiss
      m = 1
      iym = n
      multi = .false.
      ilog = -1
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 1.0e0
      xinc = 1.0e0
      ischck = 0
      isize = -1
      miss = .true.
      lisym = 1
      irlin = -1
      ibar = 0
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ymmiss, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &  '       CALL VPM (Y, YMISS, N, NS)')
      end
!MDL1
      subroutine mdl1(par, npar, xm, n, m, ixm, pv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     MODEL FUNCTION FOR NLS EXERCISER
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),pv(n),xm(ixm,m)
!
!  LOCAL SCALARS
     integer&
     &   i
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL PAR(NPAR)
!        MODEL PARAMETERS
!     INTEGER I
!        ROW INDEX
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     INTEGER M
!        NUMBER OF VARIABLES
!     INTEGER N
!        NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        NUMBER OF PARAMETERS
!     REAL PV(N)
!        PREDICTED VALUES
!     REAL XM(IXM,M)
!        INDEPENDENT VARIABLES
!
      do 10 i=1,n
         pv(i) = par(1)*xm(i,1)**par(2)
   10 continue
      return
      end
!STPAMO
     subroutine stpamo(head, n, exm, nexmpt, neta, j, par, npar, stp,&
    &   nfail, ifail, scale, lscale, hdr, page, wide, isubhd, nprt,&
     &   prtfxd, ifixd)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS A DUMMY ROUTINE FOR THE ARIMA ESTIMATION ROUTINES
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   exm
     integer&
     &   isubhd,j,lscale,n,neta,nexmpt,npar,nprt
     logical&
     &   head,page,prtfxd,wide
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),scale(lscale),stp(npar)
     integer&
     &   ifail(n),ifixd(npar),nfail(npar)
!
!  SUBROUTINE ARGUMENTS
       external hdr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL EXM
!        THE PROPORTION OF OBSERVATIONS ACTUALLY USED FOR WHICH THE
!        COMPUTED NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE
!        EXEMPTED FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     EXTERNAL HDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IFAIL(N)
!        THE ARRAY OF INDICATOR VARIABLES DESIGNATING WHETHER
!        THE STEP SIZE SELECTED WAS SATISFACTORY FOR A GIVEN
!        OBSERVATION AND PARAMETER.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXD(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXD(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER ISUBHD
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NEXMPT
!        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
!        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
!        SIZE STILL BE CONSIDERED OK.
!     INTEGER NFAIL(NPAR)
!        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP
!        SIZE DOES NOT MEET THE CRITERIA.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE OUTPUT
!        IS TO BEGIN ON A NEW PAGE.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
!        PARAMETERS ARE STORED.
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL STP(NPAR)
!        THE SELECTED STEP SIZE.
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!
      return
!
      end
!NLINIT
     subroutine nlinit (n, ifixd, par, npar, pare, npare, mit,&
    &   stopss, stopp, scale, lscale, delta, ivaprx, aprxdv, ivcvpt,&
     &   iwork, iiwork, rwork, irwork, scl)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PERFORMS INITIALIZATION FOR THE NONLINEAR
!     LEAST SQUARES ROUTINES.
!
!     REFERENCES
!
!     DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1979), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, (BEING REVISED).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,stopp,stopss
     integer&
     &   iiwork,irwork,ivaprx,ivcvpt,lscale,mit,n,npar,npare,scl
     logical&
     &   aprxdv
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),pare(npar),rwork(irwork),scale(lscale)
     integer&
     &   ifixd(npar),iwork(iiwork)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
    &   afctol,cnvcod,covprt,covreq,dinit,dtype,iscl,j,lmax0,&
    &   mxfcal,mxiter,niter,outlev,prunit,rfctol,sclj,solprt,&
     &   statpr,x0prt,xctol
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL DFAULT,NLSPK
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,iabs,max
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER AFCTOL
!        THE LOCATION IN RWORK OF THE ABSOLUTE CONVERGENCE TOLERANCE.
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     INTEGER CNVCOD
!        A VALUE USED TO CONTROL THE PRINTING OF ITERATION REPORTS.
!     INTEGER COVPRT
!        THE LOCATION IN IWORK OF THE VARIABLE USED TO INDICATE WHETHER
!        THE COVARIANCE MATRIX IS TO BE PRINTED BY THE NL2 CODE, WHERE
!        IWORK(COVPRT) = 0 INDICATES IT IS NOT.
!     INTEGER COVREQ
!        THE LOCATION IN IWORK OF THE VARIABLE USED TO INDICATE HOW
!        THE COVARIANCE MATRIX IS TO BE COMPUTED BY THE NL2 CODE, WHERE
!        IWORK(COVREQ) = 3 INDICATES THE COVARIANCE MATRIX IS TO BE COMP
!        AS THE RESIDUAL VARIANCE TIMES THE INVERSE OF THE JACOBIAN MATR
!        TRANSPOSED TIMES THE JACOBIAN MATRIX .
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     INTEGER DINIT
!        THE LOCATION IN IWORK OF THE VALUE USED TO INDICATE
!        WHETHER OR NOT USER SUPPLIED SCALE VALUES ARE TO BE
!        USED, WHERE THE (NL2) DEFAULT VALUE OF RWORK(DINIT) = 0.0E0
!        INIDCATES NO, AND THE VALUE RWORK(DINIT) = -1.0E0 INDICATES
!        YES.
!     INTEGER DTYPE
!        THE LOCATION IN IWORK OF THE VALUE INDICATING WHETHER THE
!        SCALE VALUES HAVE BEEN SUPPLIED BY THE USER (IWORK(DTYPE) .LE.
!        OR THE DEFAULT VALUES ARE TO BE USED (IWORK(DTYPE) .GT. 0).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IIWORK
!        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
!     INTEGER IRWORK
!        THE DIMENSION OF THE REAL WORK VECTOR RWORK.
!     INTEGER ISCL
!        THE LOCATION IN IWORK INDICATING THE STARTING LOCATION IN
!         RWORK OF THE SCALE VECTOR.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCVPT
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
!        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
!        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)
!        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                       *INVERSE(HESSIAN)
!     INTEGER IWORK(IIWORK)
!        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER LMAX0
!        THE LOCATION IN RWORK OF THE VALUE INDICATING THE
!        MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER MXFCAL
!        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
!        MAXIMUM NUMBER OF FUNCTION CALLS ALLOWED, EXCLUDING
!        CALLS NECESSARY TO COMPUTE THE DERIVATIVES AND VARIANCE
!        COVARIANCE MATRIX.
!     INTEGER MXITER
!        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
!        MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NITER
!        THE LOCATION IN IWORK OF THE NUMBER OF THE CURRENT ITERATION.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF UNKNOWN PARAMETERS TO BE OPTIMIZED.
!     INTEGER OUTLEV
!        THE LOCATION IN IWORK OF THE PARAMETER USED TO CONTROL THE
!        PRINTING OF THE ITERATION REPORTS BY NL2.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL PARE(NPAR)
!        THE CURRENT ESTIMATES OF THE UNKNOWN PARAMETERS, BUT ONLY
!        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
!     INTEGER PRUNIT
!        THE LOCATION IN IWORK OF THE PARAMETER USED TO CONTROL
!        THE PRINT UNIT USED BY NL2.  IWORK(PRUNIT) = 0 MEANS
!        DONT PRINT ANYTHING.
!     INTEGER RFCTOL
!        THE LOCATION IN RWORK OF THE RELATIVE FUNCTION CONVERGENCE
!        TOLERANCE.
!     REAL RWORK(IRWORK)
!        THE REAL WORK VECTOR USED BY THE NL2 SUBROUTINES.
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     INTEGER SCL
!        THE INDEX IN RWORK OF THE 1ST VALUE OF THE USER SUPPLIED SCALE
!        VALUE.
!     INTEGER SCLJ
!        THE INDEX IN RWORK OF THE JTH VALUE OF THE USER SUPPLIED SCALE
!        VALUE.
!     INTEGER SOLPRT
!        THE LOCATION IN IWORK OF THE PARAMETER USED TO CONTROL PRINTING
!        BY NL2 OF THE FINAL SOLUTION.
!     INTEGER STATPR
!        THE LOCATION IN IWORK OF THE PARAMETER USED TO CONTROL PRINTING
!        BY NL2 OF SUMMARY STATISTICS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     INTEGER XCTOL
!        THE LOCATION IN RSTAK/DSTAK OF THE P CONVERGENCE TOLERANCE.
!     INTEGER X0PRT
!         THE LOCATION IN IWORK OF THE PARAMETER USED TO CONTROL PRINTIN
!        BY NL2 OF THE INITIAL PARAMETER AND SCALE VALUES.
!
!     IWORK SUBSCRIPT VALUES
!
     data cnvcod /34/, covprt /14/, covreq /15/, dinit /38/, dtype&
    &   /16/, iscl /27/, mxfcal /17/, mxiter /18/,&
    &   niter /31/, outlev /19/, prunit /21/, solprt /22/, statpr&
     &   /23/, x0prt /24/
!
!     RWORK SUBSCRIPT VALUES
!
      data afctol /31/, lmax0 /35/, rfctol /32/, xctol /33/
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
!     PACK PARAMETERS INTO PARE
!
      call nlspk(par, ifixd, npar, pare, npar)
!
!     SET NL2SOL DEFAULT VALUES
!
      call dfault(iwork, rwork)
!
!     SET NON NL2 DEFAULT VALUES
!
      iwork(mxiter) = mit
      if (mit.le.0) iwork(mxiter) = 21
!
      iwork(mxfcal) = 2*iwork(mxiter)
!
!     SET STOPPING CRITERION
!
      rwork(afctol) = rmdcon(1,typ=0.0_wp)
     if ((stopss.ge.rmdcon(3,typ=0.0_wp)) .and. (stopss.le.0.1))&
     & rwork(rfctol) = stopss
!
     if ((stopp.ge.0.0e0) .and. (stopp.le.1.0e0))&
     &   rwork(xctol) = stopp
!
!     SET SCALE VALUES
!
      scl = 94 + 2*n + npare*(3*npare+31)/2
      iwork(iscl) = scl
      if (scale(1).gt.0.0e0) go to 40
!
      iwork(dtype) = 1
!
!     INITIALIZE SCALE VALUES FOR FIRST ITERATION
!
      sclj = scl - 1
      do 30 j=1,npar
         if (ifixd(j).ne.0) go to 30
         sclj = sclj + 1
         if (par(j).eq.0.0e0) rwork(sclj) = 1.0e0
         if (par(j).ne.0.0e0) rwork(sclj) = 1.0e0/abs(par(j))
   30 continue
!
      go to 60
!
   40 iwork(dtype) = 0
      rwork(dinit) = -1.0e0
      sclj = scl - 1
      do 50 j=1,npar
         if (ifixd(j).ne.0) go to 50
         sclj = sclj + 1
         rwork(sclj) = 1.0e0/max(abs(scale(j)),abs(par(j)))
   50 continue
!
   60 if (delta.le.0.0e0) rwork(lmax0) = 100.0e0
      if (delta.gt.0.0e0) rwork(lmax0) = delta
!
!     SET NL2 COVARIANCE COMPUTATION CONTROL PARAMETER
!
     if ((ivaprx.le.1) .or. (ivaprx.eq.4) .or. (ivaprx.ge.7))&
     &   iwork(covreq) = 3
      if ((ivaprx.eq.2) .or. (ivaprx.eq.5)) iwork(covreq) = 2
      if ((ivaprx.eq.3) .or. (ivaprx.eq.6)) iwork(covreq) = 1
     if ((ivaprx.ge.4) .and. (ivaprx.le.6))&
     &   iwork(covreq) = -iwork(covreq)
      if (aprxdv) iwork(covreq) = -iabs(iwork(covreq))
     if ((ivaprx.le.1) .or. (ivaprx.eq.4) .or. (ivaprx.ge.7))&
     &   ivcvpt = 1
      if ((ivaprx.eq.2) .or. (ivaprx.eq.5)) ivcvpt = 2
      if ((ivaprx.eq.3) .or. (ivaprx.eq.6)) ivcvpt = 3
!
!     INITIALIZE THE ITERATION COUNTER
!
      iwork(niter) = 0
!
!     SET NL2 PRINT CONTROL PARAMETERS
!
      iwork(cnvcod) = 0
      iwork(covprt) = 0
      iwork(outlev) = 0
      iwork(prunit) = 0
      iwork(solprt) = 0
      iwork(statpr) = 0
      iwork(x0prt) = 0
!
      return
!
      end
!AMFMN
     subroutine amfmn (par, pv, y, npar, n, nfac, mspect,&
    &  pardf, npardf, t, temp, parar, parma, mbo, mbol, n1, n2, nprt,&
    &  save, nfcst, nfcsto, ifcsto, fcst, ifcst, fcstsd, f,&
     &  fsd, nparar, nparma)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN ROUTINE FOR COMPUTING AND PRINTING THE ARIMA
!     FORECASTS
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
    &   ifcst,mbo,mbol,n,n1,n2,nfac,nfcst,nfcsto,npar,nparar,&
     &   npardf,nparma,nprt
     logical&
     &   save
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   f(*),fcst(ifcst,*),fcstsd(*),fsd(*),par(:),parar(*),pardf(*),&
     &   parma(*),pv(n1:n2),t(*),temp(*),y(*)
     integer&
     &   ifcsto(*),mspect(nfac,4)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   const,pmu,rsd,rss,t975,wsum,wsumt
     integer&
     &   i,i1,idf,if,ifc,iflag,ifo,ifomin,iprt,j,k,nt
     logical&
     &   page
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   PPFT,SDOT
!      EXTERNAL PPFT,SDOT
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AMFHDR,AMFOUT,AMLST,DCOEF,IPRINT,MDLTS2,MODSUM,MULTBP
!
!  INTRINSIC FUNCTIONS
      intrinsic min,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CONST
!        THE CONSTANT TERM IN THE MODEL, MODELING EITHER THE SERIES
!        MEAN OR A DETERMINISTIC TREND.
!     REAL F(NFCST)
!        THE FORECASTS.
!     REAL FCST(IFCST,NFCSTO)
!        THE STORAGE ARRAY FOR THE FORECASTS.
!     REAL FCSTSD(NFCST)
!        THE STORAGE ARRAY FOR THE STANDARD DEVIATIONS OF THE FORECASTS.
!     REAL FSD(NFCST)
!        THE STANDARD DEVIATIONS OF THE FORECASTS.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IF
!        AN INDEX VARIABLE.
!     INTEGER IFCST
!        THE FIRST DIMENSION OF THE ARRAY FCST.
!     INTEGER IFCSTO(NFCSTO)
!        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
!     INTEGER IFLAG
!        AN INDICATOR VARIABLE DESIGNATING WHETHER THE BACK FORECASTS
!        WERE ESSENTIALLY ZERO (IFLAG=0) OR NOT (IFLAG=1).
!     INTEGER IFO
!        THE INDEX OF THE ORIGIN BEING USED.
!     INTEGER IFOMIN
!        THE SMALLEST ORIGIN USED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER I1
!        AN INDEX VALUE.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBOL
!        THE MAXIMUM BACK ORDER ON THE LEFT
!     INTEGER MSPECT(NFAC,4)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFCST
!        THE NUMBER OF FORECASTS.
!     INTEGER NFCSTO
!        THE NUMBER OF THE ORIGINS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NT
!        THE NUMBER OF PARAMETERS IN T, WHERE NT = MBOL
!     INTEGER N1
!        THE LOWER BOUND FOR PV.
!     INTEGER N2
!        THE UPPER BOUND FOR PV.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PARAR(MBO)
!        THE AUTOREGRESSIVE PARAMETERS
!     REAL PARDF(NPARDF)
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS.
!     REAL PARMA(MBO)
!        THE MOVING AVERAGE PARAMETERS
!     REAL PMU
!        THE VALUE OF MU, I.E., THE TREND OR MEAN.
!     REAL PV(N1:N2)
!        THE PREDICTED VALUE OF THE FIT.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     REAL RSS
!        THE RESIDUAL SUM OF SQUARES.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL T(2*MBO)
!        A TEMPORARY WORK VECTOR.
!     REAL TEMP(MBO)
!        A TEMPORARY WORK VECTOR
!     REAL T975
!        THE VALUE OF THE 97.5 PERCENT POINT FUNCTION FOR THE
!        T DISTRIBUTION.
!     REAL WSUM
!        THE SUM OF THE WEIGHTS SQUARED, USED TO COMPUTE THE
!        STANDARD DEVIATION OF THE FORECAST.
!     REAL WSUMT
!        A TEMPORARY STORAGE LOCATION FOR WSUM.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
      call iprint (iprt)
!
!     COMPUTE DIFFERENCING PARAMETERS
!
      call dcoef (nfac, mspect(1,2), mspect(1,4), npardf, pardf, mbo, t)
!
!     COMPUTE RESIDUALS, GIVEN VALUES OF PARAMETERS
!
     call mdlts2 (par, pv, y, npar, n, nfac, mspect, pmu,&
     &  pardf, npardf, t, temp, parar, parma, mbo, n1, n2, iflag)
      idf = n - npardf - npar
      rss = sdot(n, pv(1), 1, pv(1), 1)
      rsd = sqrt(rss / idf)
!
!     PRINT INITIAL SUMMARY
!
      page = .false.
      if (nprt.eq.0) go to 10
      call amfhdr(page, .true., 2)
      call modsum(nfac, mspect)
!AMLST(iamhd,PAR(*),npar,nfac,MSPECT(nfac,4),n,VCVL(*),lvcvl,SCALE(*),lscale,STPT(*),lstpt,IFIXD(*),rss,rsd,npardf,npare,idf)
! This call uses PAR over and over, messed up. Added int() function to can even build for now
      write(*,*)'BAD CALL OF AMLST'
     call amlst(2, par, npar, nfac, mspect, n, par, npar, par,&
     &  npar, par, npar, int(par), rss, rsd, npardf, npar, idf)
      page = .true.
!
   10 continue
!
!     COMBINE PARDF AND PARAR INTO T
!
      nt = nparar + npardf
      call multbp(parar, nparar, pardf, npardf, t, nt, mbo)
!
!     COMPUTE CONSTANT
!
      const = 0.0e0
      if (pmu.ne.0.0e0) then
        if (nparar.ge.1) then
          do 20 j = 1, nparar
            const = const - parar(j)
   20     continue
        end if
        const = (1.0e0 + const) * pmu
      end if
!
!     FIND LOWEST ORIGIN
!
      ifomin = ifcsto(1)
      do 30 ifo = 1, nfcsto
        ifomin = min(ifomin, ifcsto(ifo))
   30 continue
!
!     SET TEMP TO BACKFORECAST OF Y IF NECESSARY
!
      if ((mbol.ge.1) .and. (ifomin.lt.mbol)) then
        i1 = ifomin-mbol+1
        do 60 i = 0, i1, -1
          k = 1-i
          temp(k) = const
          do 40 j = 1, mbol
            if (i+j.le.n) then
              if (i+j.ge.1) then
                temp(k) = temp(k) + t(j)*y(i+j)
              else
                temp(k) = temp(k) + t(j)*temp(mbol-i-j)
              end if
            end if
   40     continue
          if (nparma.ge.1) then
            do 50 j =1, nparma
              if (i+j.le.n) temp(k) = temp(k) - parma(j)*pv(i+j)
   50       continue
          end if
   60   continue
      end if
!
!      COMPUTE WEIGHTS FOR COMPUTING STANDARD DEVIATIONS OF THE FORECAST
!
      do 65 j = 1, nfcst
        fsd(j) = 0.0e0
        if (mbol.ge.1) then
          do 64 i = 1, mbol
            if (j-i.ge.1) then
              fsd(j) = fsd(j) + t(i)*fsd(j-i)
            else
              if (j-i.eq.0) fsd(j) = fsd(j) + t(i)
            end if
   64     continue
        end if
        if (j.le.nparma) fsd(j) = fsd(j) - parma(j)
   65 continue
!
!     COMPUTE STANDARD DEVIATIONS OF FORECASTS
!
      wsum = 1.0e0
      do 66 i = 1, nfcst
        wsumt =wsum
        wsum = wsum + fsd(i)*fsd(i)
        fsd(i) = sqrt(wsumt)*rsd
   66 continue
!
!     SET PERCENT POINT VALUE FOR 95 PERCENT CONFIDENCE LIMITS
!
      t975 = ppft(0.975e0, n-npar)
!
!     COMPUTE FORECASTS FOR EACH ORIGIN
!
      do 100 ifo = 1, nfcsto
        ifc = ifcsto(ifo)
        if ((ifc.lt.1) .or. (ifc.gt.n)) ifc = n
        do 90 if = 1, nfcst
          f(if) = const
          if (mbol.ge.1) then
            do 70 j = 1, mbol
              k = if + ifc-j
              if (k.le.0) then
                f(if) = f(if) + t(j)*temp(1-k)
              else
                if (k.le.ifc) then
                  f(if) = f(if) + t(j)*y(k)
                else
                  f(if) = f(if) + t(j)*f(if-j)
                end if
              end if
   70       continue
          end if
          if (nparma.ge.1) then
            do 80 j = 1, nparma
              k = if + ifc - j
              if (k.le.ifc) f(if) = f(if) - parma(j)*pv(k)
   80       continue
          end if
          if (save) fcst(if,ifo) = f(if)
   90   continue
!
!     PRINT RESULTS FROM THIS ORIGIN
!
       if (nprt.ne.0)&
    &    call amfout(f, fsd, n, nfcst, ifcsto, ifo, nfcsto, y, t975,&
     &    page)
!
  100 continue
!
      return
!
      end
!ACFFS
     subroutine acffs (yfft, n, lyfft, ldstak, lagmax, lacov, acov,&
     &   iar, phi, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
!     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
!     USING A FFT WITH THE COMPUTED ACVF ESTIMATES RETURNED TO THE USERS
!     ROUTINE (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iar,lacov,lagmax,ldstak,lyfft,n,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(*),phi(*),yfft(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   chia,chiap,ospvar,ymean,ysd
     integer&
    &   aic,ftest,i,ifp,iprt,ldsmin,nall0,nfac,nfft,prho,sdrho,&
     &   work
     logical&
     &   differ,isfft
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   iod(1),nd(1),ndum(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACFER,ACFMNF,ACFOUT,FFTLEN,IPRINT,LDSCMP,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV)
!        THE AUTOCOVARIANCE VECTOR.
!     INTEGER AIC
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE AKAIKES CRITERION FOR EACH ORDER.
!     REAL CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     LOGICAL DIFFER
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER FTEST
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE PARTIAL F RATIO AND PROBABILITIES
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!     INTEGER IFP
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE FLOATING
!        POINT VARIABLES ARE SINGLE (IFP=3) OR DOUBLE (IFP=4) PRECISION.
!     INTEGER IOD(1)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     INTEGER ND(1)
!        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
!     INTEGER NDUM(1)
!        A DUMMY DIMENSIONED VARIABLE.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     REAL OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
!     REAL PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     INTEGER PRHO
!        THE STARTING LOCATION IN THE WORK AREA FOR PRHO.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SDRHO
!        THE STARTING LOCATION IN THE WORK AREA FOR SDRHO.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR WORK.
!     REAL YFFT(LYFFT)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     REAL YSD
!        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'A',       'C',       'F',       'F',       'S',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      differ = .false.
      nfac = 1
      nd(1) = 0
      iod(1) = 0
      isfft = .true.
!
!     SET LENGTH OF EXTENDED SERIES
!
      nfft = 0
      if ((n.ge.3) .and. (lagmax.ge.1)) call fftlen(n+lagmax, 4, nfft)
!
      call ldscmp(4, 0, 0, 0, 0, 0, 'S', (4*lagmax+1) + nfft, ldsmin)
!
     call acfer(nmsub, n, lagmax, lacov, ldstak, ldsmin,&
     &  differ, nfac, nd, iod, isfft, lyfft, nfft)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      if (ierr.eq.0) then
!
!       SET UP THE WORK AREA.
!
        call stkset(ldstak, 4)
        nall0 = stkst(1)
!
        ifp = 3
!
        work = stkget(nfft, ifp)
        prho = stkget(lagmax, ifp)
        aic = stkget(lagmax+1, ifp)
        ftest = stkget(2*lagmax, ifp)
        sdrho = work
!
        if (ierr.eq.0) then
!
!         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
         call acfmnf (yfft, n, nfft, lagmax, acov(2), rstak(sdrho),&
    &       ymean, rstak(prho), rstak(aic), rstak(ftest), phi,&
    &       iar, ospvar, acov, lacov, lagmax+1, chia, chiap,&
     &       lyfft, rstak(work), nfft, nprt)
!
          ysd = sqrt (acov(1) * n / (n - 1))
!
!         CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
         if ((nprt.ne.0) .or. (acov(1).eq.0.0e0))&
    &       call acfout (ymean, ysd, n, n, lagmax, acov(2),&
    &       rstak(sdrho),&
    &       rstak(prho), ndum, rstak(aic), lagmax+1, rstak(ftest), iar,&
    &       phi, ospvar, chia, chiap, lagmax, .false., 0.0e0, .false.,&
     &       .false., 0, ndum, ndum, 0)
!
          if (nprt.ne.0) then
            do 50 i = 1, lagmax
               acov(i+1) = acov(i+1) * acov(1)
   50       continue
          end if
!
        end if
!
        call stkclr(nall0)
      end if
!
      if (ierr.ne.0) then
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        ierr = 1
        call iprint (iprt)
        write (iprt, 1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format(/42h the correct form of the call statement is//&
    &  '       CALL ACFFS (YFFT, N, LYFFT, LDSTAK,'/&
     &  '      +            LAGMAX, LACOV, ACOV, IAR, PHI, NPRT)')
      end
!UASDV
     subroutine uasdv(acov, spca, spcf, lspc, iar, phi, nf, fmin, fmax,&
    &   freq, n, lagmax, ftest, aic, work, lacov, lwork, delta, isort,&
    &   isym, xaxis, yaxis, lpcv, alpha, lag, laic, lphi, nprt, var,&
     &   window, nmsub)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN DRIVER FOR COMPUTING THE AUTOREGRESSIVE
!     (AND FOURIER) SPECTRUMS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   alpha,delta,fmax,fmin,var
     integer&
     &   iar,lacov,lag,lagmax,laic,lpcv,lphi,lspc,lwork,n,nf,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   acov(lacov),aic(laic),freq(nf),ftest(2,lagmax),phi(lphi),&
     &   spca(lspc),spcf(lspc),work(lwork),xaxis(lpcv),yaxis(lpcv)
     integer&
     &   isort(nf),isym(lpcv)
     character&
     &   nmsub(6)*1
!
!  SUBROUTINE ARGUMENTS
       external window
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   alow,aup,bw,df,spcamn,spcamx,spcfmn,spcfmx,xpltmn,xpltmx,&
     &   ypltmn,ypltmx
     integer&
     &   ispcer,npts,nspca,nspcf,nw
     logical&
     &   aicprt
!
!  LOCAL ARRAYS
     integer&
     &   lags(1),nlppa(1)
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL AOS,SETFRQ,SPCCK,UASCFT,UASEST,UASORD,UASOUT,UFSLAG,UFSMN
!
!  INTRINSIC FUNCTIONS
      intrinsic iabs,int
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV)
!        THE AUTOCOVARIANCE COMPUTED FROM THE LAG PRODUCT PAIRS.
!     REAL AIC(LAIC)
!        THE ARRAY CONTAINING THE AKAIKES CRITERIA FOR EACH ORDER(?).
!     LOGICAL AICPRT
!        AN INDICATOR VARIABLE USED TO DETERMINE IF THE AKIAKE
!        INFORMATION CRITERIA AND CHI SQUARED STATISTICS SHOULD
!        BE PRINTED.
!     REAL ALOW
!        A FACTOR USED TO COMPUTE THE LOWER CONFIDENCE LIMITS.
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL AUP
!        A FACTOR USED TO COMPUTE THE UPPER CONFIDENCE LIMITS.
!     REAL BW
!        THE BANDWIDTH.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL DF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
!        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     REAL FTEST(2,LAGMAX)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER ISORT(NF)
!        AN ARRAY USED FOR SORTING.
!     INTEGER LSPC
!         THE ACTUAL FIRST DIMENSION FOR THE SPECTRUM ARRAYS.
!     INTEGER ISPCER
!        AN ERROR FLAG USED FOR THE SPECTRUM PLOTS.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE COVARIANCE ARRAYS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(1)
!        THE LAG WINDOW TRUNCATION POINT RETURNED FROM UFSLAG.
!     INTEGER LAIC
!        THE LENGTH OF THE ARRAY AIC.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER LWORK
!        THE ACTUAL LENGTH OF THE WORK ARRAY.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
!        ARE TO BE ESTIMATED.
!     INTEGER NLPPA(1)
!        A DUMMY ARRAY
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     INTEGER NSPCA, NSPCF
!        THE NUMBER OF VALID SPECTRUM ESTIMATES FOR THE AUTOREGRESSIVE
!        AND FOURIER SPECTRUMS, RESPECTIVELY.
!     INTEGER NW
!        THE NUMBER OF LAG WINDOW TRUNCATION POINTS SELCTED.
!     REAL PHI(LPHI)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     REAL SPCA(LSPC)
!        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!     REAL SPCAMN, SPCAMX
!        THE MINIMUM AND MAXIMUM AUTOREGRESSIVE SPECTRUM VALUE TO BE
!        PLOTTED.
!     REAL SPCF(LSPC)
!        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
!     REAL SPCFMN, SPCFMX
!        THE MINIMUM AND MAXIMUM FOURIER SPECTRUM VALUE TO BE PLOTTED.
!     REAL VAR
!        THE ONE STEP PREDICTION VARIANCE.
!     EXTERNAL WINDOW
!        THE TYPE OF WINDOW TO BE USED.
!     REAL WORK(LWORK)
!        THE WORK ARRAY.
!     REAL XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     REAL YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
      nw = 1
!
      if (lag.le.0) then
!
!     SET THE LAG WINDOW TRUNCATION POINT TO BE USED FOR THE
!     FOURIER SPECTRUM ESTIMATES.
!
         call ufslag(acov, lagmax, lags, n, nw, nw, lacov)
         lag = lags(1)/2
      end if
!
!     SET FREQUENCIES FOR THE SPECTRUM.
!
      call setfrq(freq, nf, 1, fmin, fmax, delta)
!
!     COMPUTE THE FOURIER SPECTRUM ESTIMATES
!
     call ufsmn(acov, nlppa, lag, df, nf, freq, alpha, bw, spcf,&
    &  alow, aup, lacov, lspc, window, work, lwork, n, delta,&
     &  .false., 1)
!
      aicprt = .false.
!
      if (iar.lt.0) then
!
!     USER HAS CHOSEN ORDER.
!     COMPUTE COEFFICIENTS AND VARIANCE USING DURBINS RECURSIVE METHOD.
!
         call uascft(acov, lagmax, lacov, iabs(iar), phi, n, var)
!
      else if (iar.eq.0) then
!
!     SELECT MODEL ORDER AND COMPUTE COEFFICIENTS AND VARIANCE.
!
         aicprt = .true.
        call aos(n, lagmax, acov, work, iar, var, phi,&
     &            work, aic, ftest, lacov, laic)
      end if
!
!     COMPUTE THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!
     call uasest(iabs(iar), var, phi, nf, freq, delta, spca, lphi,&
     &   lspc)
!
      if (nprt.eq.0) return
!
!     SET PLOTTING VECTORS.
!
      xpltmn = fmin
      xpltmx = fmax
!
      ypltmn = 0.0e0
      ypltmx = 0.0e0
!
      call spcck(spcf, isort, nf, spcfmn, spcfmx, nspcf, ispcer)
      if (ispcer.ne.0) go to 40
      call spcck(spca, isort, nf, spcamn, spcamx, nspca, ispcer)
      if (ispcer.ne.0) go to 40
!
     call uasord(spcf, spca, spcfmn, spcfmx, spcamn, spcamx, freq, nf,&
    &   xaxis, yaxis, isym, npts, lspc, lpcv, nspcf, nspca, bw, alow,&
     &   aup, xpltmn, xpltmx, ypltmn, ypltmx, nprt)
!
!     PRINT RESULTS
!
  40 call uasout(xaxis, yaxis, isym, npts, bw, int(df+0.5e0), lag,&
    &   iabs(iar), phi, ispcer, lpcv, xpltmn, xpltmx, ypltmn, ypltmx,&
     &   ftest, aic, laic, var, nprt, lagmax, aicprt, n, nmsub)
!
      return
      end
!PGMS
     subroutine pgms (yfft, n, nfft, lyfft, iextnd, nf, per, lper,&
     &   freq, lfreq, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
!     THE (RAW) PERIODOGRAM OF A SERIES (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iextnd,lfreq,lper,lyfft,n,nf,nfft,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(*),per(*),yfft(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iprt,nfft2
     logical&
     &   err01,err02,err03,err04,err05,head
!
!  LOCAL ARRAYS
     character&
     &   llfreq(8)*1,llper(8)*1,llyfft(8)*1,ln(8)*1,nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,ENFFT,IPRINT,PGMMN
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     REAL FREQ(LFREQ)
!        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
!        INTEGRATED SPECTRUM VALUES ARE STORED.
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IEXTND
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
!        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
!        USED TO EXTEND THE SERIES.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER LFREQ
!        THE LENGTH OF THE ARRAY FREQ.
!     CHARACTER*1 LLFREQ(8), LLPER(8), LLYFFT(8), LN(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER LPER
!        THE LENGTH OF THE ARRAY PER.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
!     INTEGER NFFT2
!        THE EFFECTIVE SERIES LENGTH ACTUALLY USED.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .EQ.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
!        IF NPRT .GE.  2, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     REAL PER(LPER)
!        THE ARRAY IN WHICH THE PERIODOGRAM IS STORED.
!     REAL YFFT(LYFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'P',       'G',       'M',       'S',       ' ',       ' '/
     data&
    & llfreq(1), llfreq(2), llfreq(3), llfreq(4), llfreq(5),&
    &  llfreq(6), llfreq(7), llfreq(8)&
     &  /'L','F','R','E','Q',' ',' ',' '/
     data&
    & llper(1), llper(2), llper(3), llper(4), llper(5),&
     &  llper(6), llper(7), llper(8) /'L','P','E','R',' ',' ',' ',' '/
     data&
    & llyfft(1), llyfft(2), llyfft(3), llyfft(4), llyfft(5),&
    &  llyfft(6), llyfft(7), llyfft(8)&
     &  /'L','Y','F','F','T',' ',' ',' '/
     data&
    & ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /'N',' ',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 17, 1, head, err01, ln)
      if (err01) go to 5
!
      call enfft(nmsub, nfft, 2, n, lyfft, nfft2, head, err02)
      nf = nfft2/2
!
      call eisge(nmsub, llyfft, lyfft, nfft2, 9, head, err03, llyfft)
!
      call eisge(nmsub, llper, lper, nf, 9, head, err04, llper)
!
      call eisge(nmsub, llfreq, lfreq, nf, 9, head, err05, llfreq)
!
      if (err02 .or. err03 .or. err04 .or. err05) go to 5
      go to 10
!
    5 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   10 continue
!
     call pgmmn (yfft, n, nfft2, iextnd, nf, per, lper, yfft, freq,&
     &   lfreq, nprt, nmsub)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &  '       CALL PGMS (YFFT, N, NFFT, LYFFT,'/&
     &  '      +           IEXTND, NF, PER, LPER, FREQ, LFREQ, NPRT)')
      end
!LLCNTP
     subroutine llcntp(y, wt, lwt, xm, n, ndeg, npar, res, ldstak,&
    &   nprt, par, lpar, rsd, pv, lpv, sdpv, lsdpv, sdres, lsdres, vcv,&
     &   ivcv, nmsub, weight, save)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR POLYNOMIAL LINEAR LEAST
!     SQUARES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   ivcv,ldstak,lpar,lpv,lsdpv,lsdres,lwt,n,ndeg,npar,nprt
     logical&
     &   save,weight
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),pv(*),res(*),sdpv(*),sdres(*),vcv(*),wt(*),xm(*),y(*)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   ifit,ixm,m
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL LLCNT,LLHDRP
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IFIT
!        THE INDICATOR VALUE DESIGNATING WHETHER THE LLS IS OF A
!        GENERAL MODEL (IFIT=3) OR A POLYNOMIAL MODEL (IFIT=1).
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     EXTERNAL LLHDRP
!        THE NAME OF THE ROUTINE THAT PRODUCED THE HEADING.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDEG
!        THE DEGREE OF THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     REAL PAR(LPAR)
!        THE PARAMETERS TO BE ESTIMATED.
!     REAL PV(LPV)
!        THE PREDICTED VALUES.
!     REAL RES(N)
!        THE RESIDUALS.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     REAL SDPV(LSDPV)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(LSDRES)
!        THE STANDARDIZED RESIDUALS.
!     REAL VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(LWT)
!        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
!     REAL XM(N,1)
!        THE INDEPENDENT VARIABLE.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!
      ifit = 1
      npar = ndeg + 1
      m = 1
      ixm = n
!
     call llcnt(y, wt, lwt, xm, n, m, ixm, npar, res, ldstak, nprt,&
    &   par, lpar, rsd, pv, lpv, sdpv, lsdpv, sdres, lsdres, vcv, ivcv,&
     &   llhdrp, ifit, nmsub, weight, save)
!
      return
!
      end
!UFSOUT
     subroutine ufsout(xaxis, yaxis, isym, npts, bw, idf, lag, laglst,&
    &   newpg, ispcer, lpcv, xpltmn, xpltmx, ypltmn, ypltmx, ilog,&
     &   phas, freq, nf, univar, nmsub)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES THE FOURIER BIVARIATE SPECTRUM OUTPUT.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   bw,xpltmn,xpltmx,ypltmn,ypltmx
     integer&
     &   idf,ilog,ispcer,lag,laglst,lpcv,nf,npts
     logical&
     &   newpg,univar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(nf),phas(nf),xaxis(lpcv),yaxis(lpcv)
     integer&
     &   isym(lpcv)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   pi,xmn,xmx,ymn,ymx
     integer&
     &   i,iprt
     logical&
     &   error
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL GETPI,IPRINT,PPLMT,PPMN,VERSP
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL BW
!        THE BANDWIDTH.
!     LOGICAL ERROR
!        AN ERROR FLAG
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER IDF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     INTEGER IERR
!        THE ERROR FLAG.
!     INTEGER ILOG
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        ILOG = 0 THE PLOT IS LINEAR/LINEAR, IF
!        ILOG = 1 THE PLOT IS LOG/LINEAR, IF
!        ILOG = 2 THE PLOT IS LINEAR/LOG, AND IF
!        ILOG = 3 THE PLOT IS LOG/LOG.
!     INTEGER IPRT
!        THE LOGICAL UNIT NUMBER FOR THE OUTPUT.
!     INTEGER ISPCER
!        A VARIABLE USED TO DESIGNATE AN ERROR IN THE SPECTRUM
!        VALUES.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT.
!     INTEGER LAGLST
!        THE LAST LAG BEFORE MISSING DATA CAUSED THE ACVF OF EITHER
!        SERIES 1 OR 2 NOT TO BE COMPUTED.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     LOGICAL NEWPG
!        THE LOGICAL VARIABLE USED TO DETERMINE IF OUTPUT
!        WILL BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE.
!     INTEGER NPTS
!        THE NUMBER OF CO-ORDINATES TO BE PLOTTED.
!     REAL PHAS(NF)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL PI
!        THE VALUE OF PI.
!     LOGICAL UNIVAR
!        THE LOGICAL VARIABLE USED TO DETERMINE IF THE OUTPUT
!        IS FOR UNIVARIATE (TRUE) OR BIVARIATE (FALSE) SPECTRA.
!     REAL XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL XMN, XMX
!        *
!     REAL XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     REAL YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL YMN, YMX
!        *
!     REAL YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
!      SET LOGICAL UNIT NUMBER FOR OUTPUT AND SET OUTPUT WIDTH.
!
      call iprint(iprt)
!
      call getpi(pi)
!
      if (newpg) write (iprt,1010)
      if (ispcer.le.1) go to 10
      call versp(.true.)
      write (iprt,1060) laglst, lag
      return
!
   10 continue
      call versp(.true.)
      if (.not.univar) write (iprt,1070)
      if (univar) write (iprt,1080)
      write (iprt,1020) lag, bw, idf
      if (ispcer.eq.0) go to 20
      write (iprt,1050)
      go to 30
!
   20 continue
!
!     PRINT PLOTS
!
!     PLOT SQUARED COHERENCY COMPONENT OF SPECTRUM
!
     call pplmt(yaxis,yaxis,xaxis,xaxis(1),npts,1,lpcv,ypltmn,&
    &  ypltmx, ymn, ymx, xpltmn, xpltmx, xmn, xmx, error, nmsub,&
     &  .false.)
     if (.not.error)&
    &  call ppmn(yaxis,yaxis,xaxis,xaxis(1),npts,1,lpcv,1,isym,&
     &  lpcv, 0, -1, ymn, ymx, xmn, xmx, .false., ilog)
      if (xpltmn.eq.0.0e0 .and. xpltmx.eq.0.5e0) write (iprt, 1030)
!
   30 if (univar) return
      do 40 i=1,nf
         xaxis(i) = freq(i)
         xaxis(nf+i) = freq(i)
         yaxis(i) = phas(i)
         if (phas(i).gt.0.0e0) then
            yaxis(nf+i) = phas(i) - 2*pi
         else if (phas(i).lt.0.0e0) then
            yaxis(nf+i) = phas(i) + 2*pi
         else
            yaxis(nf+i) = 0.0e0
         end if
   40 continue
!
!     PLOT SMOOTHED PHASE COMPONENT OF SPECTRUM
!
      write (iprt,1010)
      call versp(.true.)
      write (iprt,1000)
      write (iprt,1020) lag, bw, idf
     call pplmt(yaxis,yaxis,xaxis,xaxis(1),2*nf,1,2*nf,-2*pi,2*pi,&
     &  ymn, ymx, xpltmn, xpltmx, xmn, xmx, error, nmsub, .false.)
      if (error) then
        ierr = 1
      else
       call ppmn(yaxis,yaxis,xaxis,xaxis(1),&
    &            2*nf, 1, 2*nf, 0, isym, lpcv,&
     &            0, -1, ymn, ymx, xmn, xmx, .false., ilog)
        if (xpltmn.eq.0.0e0 .and. xpltmx.eq.0.5e0) write (iprt, 1030)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (50h -- smoothed fourier spectrum (phase component) --)
 1010 format ('1')
1020 format (45h    (parzen window with lag wind. trunc. pt.=, i5, 1x,&
     &   5h/ bw=, f6.4, 1x, 6h/ edf=, i6, ')')
1030 format (5h+freq/7h period, 9x, 3hinf, 7x, 3h20., 7x, 3h10., 8x,&
    &   6h6.6667, 4x, 2h5., 8x, 2h4., 8x, 6h3.3333, 4x, 6h2.8571, 4x,&
     &   3h2.5, 7x, 6h2.2222, 4x, 2h2.)
!1040 FORMAT (5H+FREQ/7H PERIOD, 9X, 3HINF, 7X, 3H10., 7X, 2H5., 8X,
!    *   6H3.3333, 4X, 3H2.5, 7X, 2H2.)
1050 format (//39h the plot has been supressed because no/&
     &   40h positive spectrum values were computed.)
1060 format (//50h the largest lag window truncation point which can/&
    &   12h be used is , i5, '.'/34h the spectrum for the requested la,&
    &   8hg window, 10h point of , i5, ','/24h therefore, cannot be co,&
     &   7hmputed.)
1070 format (48h -- smoothed fourier spectrum (squared coherency,&
    &   46h component) (+), 95 pct. confidence limits (.),&
     &   38h and 95 pct. significance level (-) --)
 1080 format (32h -- smoothed fourier spectrum --)
      end
!SETRV
subroutine setrv(vector, n, value)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SETS THE FIRST N ELEMENTS OF VECTOR
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
real(kind=wp) :: value
integer :: n
!
!  ARRAY ARGUMENTS
real(kind=wp) :: vector(n)
!
!  LOCAL SCALARS
integer :: i
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        *
!     INTEGER N
!        NUMBER OF ELEMENTS TO SET
!     REAL(KIND=WP) :: VALUE
!        VALUE TO WHICH THE ELEMENTS ARE TO BE SET
!     REAL(KIND=WP) :: VECTOR(N)
!        VECTOR WHOSE FIRST N ELEMENTS ARE TO BE SET.
!
   do i=1,n
      vector(i) = value
   enddo
!
end subroutine setrv
!NLOUT
     subroutine nlout(y, weight, nnzw, wt, lwt, xm, n, m, ixm, ifixd,&
    &   par, npar, npare, res, iptout, ndigit, page, idf, cond, rss,&
    &   rsd, yss, exact, pv, sdpv, sdres, vcvl, lvcvl, ivcvpt, iskull,&
     &   nlhdr, wide)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS THE FINAL SUMMARY OUTPUT FROM THE
!     NONLINEAR LEAST SQUARES SUBOUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   cond,rsd,rss,yss
     integer&
     &   idf,ivcvpt,ixm,lvcvl,lwt,m,n,ndigit,nnzw,npar,npare
     logical&
     &   exact,page,weight,wide
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   par(npar),pv(n),res(n),sdpv(n),sdres(n),vcvl(lvcvl),wt(lwt),&
     &   xm(ixm,m),y(n)
     integer&
     &   ifixd(npar),iptout(ndigit),iskull(10)
!
!  SUBROUTINE ARGUMENTS
       external nlhdr
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm,pll,pul,ratio,sdpar,t
     integer&
     &   i,ipk,ipk2,iprt,isubhd
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   PPFT,R1MACH
!      EXTERNAL PPFT,R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL FITPT1,FITPT2,IPRINT,NLSKL,VCVOTF
!
!  INTRINSIC FUNCTIONS
      intrinsic max,sqrt
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL COND
!        THE CONDITION NUMBER OF D.
!     LOGICAL EXACT
!        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
!        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IDF
!        THE DEGREES OF FREEDOM IN THE FIT.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IPK
!        AN INDEX.
!     INTEGER IPK2
!        THE INDEX OF THE "DIAGONAL" ELEMENT OF THE VCV
!        MATRIX.
!     INTEGER IPRT
!        THE LOGICAL UNIT FOR PRINTED OUTPUT.
!     INTEGER IPTOUT(NDIGIT)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER ISKULL(10)
!        AN ERROR MESSAGE INDICATOR VARIABLE.
!     INTEGER ISUBHD
!        AN INTEGER VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IVCVPT
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
!        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
!        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)
!        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                       *INVERSE(HESSIAN)
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LVCVL
!        THE LENGTH OF THE VECTOR CONTAINING
!        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     EXTERNAL NLHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     REAL PAR(NPAR)
!        THE PARAMETER ESTIMATES.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE OUTPUT
!        IS TO BEGIN ON A NEW PAGE.
!     REAL PLL, PUL
!        THE LOWER AND UPPER CONFIDENCE LIMITS FOR A GIVEN PARAMETER.
!     REAL PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RATIO
!        THE RATIO OF A GIVEN PARAMETER VALUE TO ITS STANDARD ERROR.
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     REAL RSS
!        THE RESIDUAL SUM OF SQUARES.
!     REAL SDPAR
!        THE STANDARD DEVIATION OF A GIVEN PARAMETER VALUE.
!     REAL SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL T
!        THE VALUE OF THE 97.5 PERCENT POINT FUNCTION FOR THE
!        T DISTRIBUTION.
!     REAL VCVL(LVCVL)
!        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!     REAL YSS
!        THE SUM OF SQUARES OF THE DEPENDENT VARIABLE Y.
!
!
      fplm = r1mach(2)
!
      call iprint(iprt)
!
      if ((ierr.ge.1) .and. (ierr.ne.4)) go to 60
!
!     TEST FOR EXACT FIT
!
      if ((idf.le.0) .or. exact) go to 70
!
!     PRINT ERROR HEADING IF NECESSARY
!
      if (ierr.eq.4) call nlskl(iskull, page, wide, nlhdr)
!
!     PRINT PRIMARY REPORT
!
      if ((ierr.eq.0) .and. (iptout(3).eq.0)) go to 10
      isubhd = 0
      call nlhdr(page, wide, isubhd)
     call fitpt1(n, m, xm, y, pv, sdpv, res, sdres, wt, ixm, nnzw,&
     &   weight, max(1, iptout(3)))
!
!     PRINT STANDARDIZED RESIDUAL PLOTS
!
   10 if (iptout(4).eq.0) go to 20
      isubhd = 0
      call nlhdr(page, wide, isubhd)
!
      call fitpt2 (sdres, pv, wt, n, nnzw, weight, res, rss)
!
!     PRINT THE COVARIANCE AND CORRELATION MATRIX
!
   20 if ((ierr.eq.0) .and. (iptout(5).eq.0)) return
      isubhd = 0
      call nlhdr(page, wide, isubhd)
!
      if ((ierr.eq.0) .and. (iptout(5).le.1)) go to 30
!
      call vcvotf(npare, vcvl, lvcvl, .true., npar, ifixd, ivcvpt)
!
!     PRINT ANALYSIS SUMMARY
!
   30 write (iprt,1000)
      write (iprt,1010)
!
      t = ppft(0.975e0,idf)
      ipk = 0
      do 50 i=1,npar
!
         if (ifixd(i).eq.0) go to 40
!
         write (iprt,1030) i, par(i)
         go to 50
!
   40    ipk = ipk + 1
         ipk2 = ipk*(ipk-1)/2 + ipk
         ratio = fplm
         sdpar = sqrt(vcvl(ipk2))
         if (sdpar.gt.0.0e0) ratio = par(i)/sdpar
         pll = par(i) - t*sdpar
         pul = par(i) + t*sdpar
         write (iprt,1020) i, par(i), sdpar, ratio, pll, pul
   50 continue
      write (iprt,1040) rss, rsd, nnzw, npare, idf
      write (iprt,1050) cond
!
      if (rss.gt.yss) write (iprt,1060)
!
      return
!
!     PRINT OUT ERROR HEADING
!
   60 call nlskl(iskull, page, wide, nlhdr)
!
      if (ierr.le.2) return
!
!     PRINT SECONDARY REPORT
!
   70 continue
      isubhd = 0
      call nlhdr(page, wide, isubhd)
      if (ierr.ne.0) write (iprt,1080)
      write (iprt,1000)
      write (iprt,1100)
      do 80 i=1,npar
         if (ifixd(i).eq.0) write (iprt,1110) i, par(i)
         if (ifixd(i).ne.0) write (iprt,1120) i, par(i)
   80 continue
      write (iprt,1040) rss, rsd, nnzw, npare, idf
      if (ierr.ne.3) write (iprt,1050) cond
!
     if ((ierr.eq.0) .and. (.not.exact) .and. (idf.le.0)) write&
     &   (iprt,1070)
      if ((ierr.eq.0) .and. exact) write (iprt,1090)
!
      if (ierr.ne.0) go to 100
!
      do 90 i=1,n
         sdres(i) = 0.0e0
         sdpv(i) = 0.0e0
   90 continue
!
      return
!
  100 continue
!
      do 110 i=1,n
         sdres(i) = fplm
         sdpv(i) = fplm
  110 continue
!
!     PRINT OUT ERROR EXIT STATISTICS
!
     call fitpt1(n, m, xm, y, pv, sdpv, res, sdres, wt, ixm, nnzw,&
     &   weight, max(iptout(3),1))
!
!
!     WIPE OUT SDRES VECTOR
!
      do 120 i=1,n
         sdres(i) = fplm
  120 continue
!
!     WIPE OUT VCV MATRIX
!
      do 140 i=1,lvcvl
         vcvl(i) = fplm
  140 continue
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (///33h estimates from least squares fit/1x, 33('-'))
1010 format (//69x, 11happroximate/61x, 28h95 percent confidence limits&
    &   /1x, 5hindex, 2x, 5hfixed, 3x, 9hparameter, 8x, 9hsd of par,&
     &   7x, 5hratio, 12x, 5hlower, 12x, 5hupper/)
 1020 format (1x, i3, 5x, 3h no, 2g17.8, 2x, g10.4, 2g17.8)
1030 format (1x, i3, 5x, 3hyes, g17.8, 10x, 3h---, 8x, 3h---, 15x,&
     &   3h---, 14x, 3h---)
1040 format (//31h residual sum of squares       , 8x, g15.7//6h resid,&
    &   25hual standard deviation   , 8x, g15.7/19h based on degrees o,&
     &   9hf freedom, 5x, i4, 3h - , i3, 3h = , i4)
 1050 format (/29h approximate condition number, 10x, g15.7)
1060 format (52h the residual sum of squares after the least squares,&
    &   20h fit is greater than/35h the sum of squares about the mean ,&
    &   19hy observation.  the, 14h model is less/17h representative o,&
    &   39hf the data than a simple average.  data, 15h and model shou,&
     &   2hld/48h be checked to be sure that they are compatable.)
1070 format (/49h the degrees of freedom for this problem is zero.,&
     &   54h  statistical analysis of the results is not possible.)
1080 format (//40h the following summary should be used to, 8h analyze,&
     &   30h the above mentioned problems.)
1090 format (/50h the least squares fit of the data to the model is,&
    &   35h exact to within machine precision./20h statistical analysi,&
     &   33hs of the results is not possible.)
 1100 format (//1x, 5hindex, 2x, 5hfixed, 3x, 9hparameter)
 1110 format (1x, i3, 5x, 3h no, g17.8)
 1120 format (1x, i3, 5x, 3hyes, g17.8)
      end
!MATPRF
      subroutine matprf(x, y, nc, mode, code, length, mask, lmask)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THISROUTINE PRINTS A SQUARE MATRIX STORED IN SYMMETRIC
!     FORM.
!
!     WRITTEN BY - JOHN E. KOONTZ
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!        BASED ON THE JULY 1982 VERSION OF MATPRT, BY LINDA L. MITCHELL.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   code,length,lmask,mode,nc
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(length),y(length)
     integer&
     &   mask(lmask)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   sqxii,sqyii
     integer&
    &   i,i0,ii,ik,imask,iprt,j,jmask,k,ki,kk,km,kmax,kn,l,nf,&
     &   nline
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   xline(10),yline(10)
     integer&
     &   indw(10)
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   INPERL
!      EXTERNAL INPERL
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic min,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CODE
!        IF 1 -SINGLE PRINTED, X ONLY (Y IS DUMMY ARG)
!           2 -DOUBLE PRINTED LINE, BOTH X AND Y
!     INTEGER I
!        ROW NUMBER
!     INTEGER II
!        THE INDEX OF THE (I,I)TH ELEMENT OF THE VCV MATRIX
!     INTEGER IK
!        THE INDEX OF THE (I,K)TH ELEMENT OF THE VCV MATRIX
!     INTEGER I0
!        THE INDEX OF THE ((I,I)-1)TH ELEMENT OF THE VCV MATRIX
!     INTEGER IMASK
!        INDEX IN MASK FOR LABELLING OF THE ROW DIMENSION.
!     INTEGER INDW(10)
!        A WORK VECTOR FOR THE INDICES TO BE PRINTED FOR THE
!        MATRIX.
!     INTEGER IPRT
!        THE OUTPUT UNIT NUMBER
!     INTEGER J
!        FIRST COLUMN IN THE SET TO BE PRINTED
!     INTEGER JMASK
!        INDEX IN MASK FOR LABELLING OF THE COLUMN DIMENSION.
!     INTEGER K
!        COLUMN NUMBER IN THE POSSIBLE SET OF NF
!     INTEGER KI
!        THE INDEX OF THE (K,I)TH ELEMENT OF THE VCV MATRIX
!     INTEGER KK
!        THE INDEX OF THE (K,K)TH ELEMENT OF THE VCV MATRIX
!     INTEGER KM
!        LAST COLUMN IN THE SET
!        LIMITED TO VALUES OF J-1 PLUS A NUMBER BETWEEN 1 AND
!        NF (INCLUSIVE)
!     INTEGER KMAX
!        INDEX IN INDW OF THE LARGEST INDEX TO BE PRINTED FOR
!        MATRIX.
!     INTEGER KN
!        LAST COLUMN TO PRINT WHEN PRINTING LOWER TRIANGLE
!     INTEGER L
!        FIRST ROW TO PRINT FOR THIS SET
!     INTEGER LMASK
!        LENGTH OF MASK.
!     INTEGER LENGTH
!        LENGTH OF X AND Y
!     INTEGER MASK(LMASK)
!        MASK VECTOR FOR VCV.  THE INDEX OF THE ITH ELEMENT OF
!        MASK EQUAL TO ZERO IS THE LABEL IN THE OUTPUT OF VCV
!        IN OF THE ITH ROW AND ITH COLUMN.
!     INTEGER MODE
!        IF 0, LOWER TRIANGULAR PART PRINTED
!           1, LOWER TRIANGULAR PART IS PRINTED WITH
!              SQUARE ROOTS OF THE DIAGONAL
!           2, LOWER TRIANGLE PRINTED AS CORRELATION MATRIX
!              WITH SQUARE ROOTS ON THE DIAGONAL
!           3, FULL MATRIX PRINTED
!           4, FULL MATRIX PRINTED WITH CORRELATION MATRIX
!              PRINTED BELOW THE DIAGONAL
!     INTEGER NC
!        ROW AND COLUMN DIMENSION OF X
!     INTEGER NF
!        THE NUMBER OF COLUMNS THAT CAN BE PRINTED, GIVEN
!        THE WIDTH IWIDTH OF THE OUTPUT DEVICE.
!     INTEGER NLINE
!        THE NUMBER OF VALUES TO BE PRINTED EACH LINE.
!     REAL SQXII, SQYII
!        THE SQUARE ROOT OF THE (I,I)TH ELEMENT OF X AND Y.
!     REAL X(LENGTH)
!        INPUT SYMMETRIC ARRAY STORED ROW WISE
!     REAL XLINE(10)
!        THE CURRENT VALUES BEING PRINTED FROM ARRAY X.
!     REAL Y(LENGTH)
!        ARRAY TO BE PRINTED ON THE SECOND LEVEL IF CODE=2
!     REAL YLINE(10)
!        THE CURRENT VALUES BEING PRINTED FROM ARRAY Y.
!
!     BODY OF ROUTINE
!
      call iprint(iprt)
!
      nf = inperl(0)
!
      l = 1
      jmask = 0
!
!     SELECT INITIAL COLUMN TO PRINT THIS PASS OF THE REPORT
!
      do 90 j=1,nc,nf
         kn = min(nc,j+nf-1)
         kmax = min(nc-j+1,nf)
!
!     GENERATE VECTOR OF COLUMN HEAD LABELS
!
         do 20 k=1,kmax
   10       if (jmask.ge.lmask) go to 100
            jmask = jmask + 1
            if (mask(jmask).ne.0) go to 10
            indw(k) = jmask
   20    continue
!
!     PRINT VECTOR OF COLUMN HEAD LABELS
!
         write (iprt,1000) (indw(k),k=1,kmax)
         write (iprt,1030)
         if (mode.le.2) l = indw(1)
!
!     PRINT ALL ROWS IN COLUMN RANGE FOR THIS PASS
!
         imask = l - 1
         do 80 i=l,nc
            km = kn
            if (mode.le.2) km = j + min(i-l,nf-1)
            nline = 0
            i0 = i*(i-1)/2
            ii = i0 + i
            sqxii = sqrt(x(ii))
            if (code.eq.2) then
               sqyii = sqrt(y(ii))
            else
               sqyii = 1.0e0
            end if
            do 60 k=j,km
               nline = nline + 1
               if (k.gt.i) go to 30
               ik = i0 + k
               xline(nline) = x(ik)
               if (code.eq.2) yline(nline) = y(ik)
               go to 40
   30          ki = k*(k-1)/2 + i
               xline(nline) = x(ki)
               if (code.eq.2) yline(nline) = y(ki)
  40          if (((mode.ne.1) .and. (mode.ne.2)) .or. (i.ne.k)) go to&
     &            50
               xline(nline) = sqxii
               if (code.eq.2) yline(nline) = sqxii
  50          if (((mode.ne.2) .and. (mode.ne.4)) .or. (k.ge.i)) go to&
     &            60
               kk = k*(k-1)/2 + k
               xline(nline) = xline(nline)/(sqxii*sqrt(x(kk)))
              if (code.eq.2)&
     &            yline(nline) = yline(nline)/(sqyii*sqrt(y(kk)))
   60       continue
   70       if (imask.ge.lmask) go to 100
            imask = imask + 1
            if (mask(imask).ne.0) go to 70
            write (iprt,1010) imask, (xline(k),k=1,nline)
            if (code.eq.2) write (iprt,1020) (yline(k),k=1,nline)
            if (code.eq.2) write (iprt,1030)
   80    continue
   90 continue
      return
!
  100 write (iprt,1040)
      return
!
!     FORMAT STATEMENTS
!
!
 1000 format (/' ', 7hcolumn , 7(i9, 8x))
 1010 format (' ', i6, 1x, 7(3x, g14.7))
 1020 format (' ', 5x, 7(3x, g14.7))
 1030 format (' ')
1040 format (/47h error in starpac.  matprf tries to access more,&
     &   29h elements than exist in mask.)
      end
!SUMWTS
     subroutine sumwts(x, w, n, nnzw, alpha, sumt1, sumtw1, xtrm,&
     &   xtrmw)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO CALCULATE THE WEIGHTED AND UNWEIGHTED MEANS
!     FOR A SORTED VECTOR IN WHICH THE MIDTH ELEMENT IS THE
!     ELEMENT CLOSEST TO ZERO.  USED BY THE STAT FAMILY.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   alpha,sumt1,sumtw1,xtrm,xtrmw
     integer&
     &   n,nnzw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   w(n),x(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   sumw
     integer&
     &   curhi,curlo,i,irev,ithi,itlo,mid,nalpha,num
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL SUMBS
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max,min
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        INPUT PARAMETER.  THE PERCENTAGE OF POINTS TO TRIM
!        FROM EACH END OF THE ARRAY X FOR THE TRIMMED MEAN.
!     INTEGER CURHI
!        THE UPPER BOUND OF THE CURRENT INTERVAL.
!     INTEGER CURLO
!        THE LOWER BOUND OF THE CURRENT INTERVAL.
!     INTEGER I
!        LOOP PARAMETER.
!     INTEGER IREV
!        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
!        IN THE REVERSE ORDER.
!     INTEGER ITHI
!        THE COMPUTED UPPER BOUND SUCH THAT ALPHA PER
!        CENT OF THE POSITIVELY WEIGHTED POINTS ARE
!        OMITTED.
!     INTEGER ITLO
!        THE COMPUTED LOWER BOUND SUCH THAT ALPHA PER
!        CENT OF THE POSITIVELY WEIGHTED POINTS ARE
!        OMITTED.
!     INTEGER MID
!        THE INDEX OF THE ELEMENT IN X CLOSEST TO ZERO IN VALUE.
!        THE POINT OUT FROM WHICH THE SUMMING IS DONE.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
!     INTEGER NALPHA
!          THE INTEGER WHICH IS ALPHA PER CENT OF N.
!     INTEGER NNZW
!        INPUT PARAMETER.  THE NUMBER OF POSITIVELY WEIGHTED
!        VALUES IN X.
!     INTEGER NUM
!        THE NUMBER OF POINTS OMITTED SO FAR.
!     REAL SUMTW1
!        OUTPUT PARAMETER.  THE WEIGHTED SUM OF THE TRIMMED ARRAY
!        X.
!     REAL SUMT1
!        OUTPUT PARAMETER.  THE UNWEIGHTED SUM OF THE TRIMMED
!        ARRAY.  ZERO-WEIGHTED ELEMENTS ARE OMITTED.
!     REAL SUMW
!        THE SUM OF THE WEIGHTS W(I).
!     REAL W(N)
!        INPUT PARAMETER.  THE ARRAY OF WEIGHTS.
!     REAL X(N)
!        INPUT PARAMETER.  THE DATA ARRAY X IN WHICH THE SUMS ARE TAKEN.
!     REAL XTRM
!        OUTPUT PARAMETER.  THE UNWEIGHTED, TRIMMED MEAN OF X.
!     REAL XTRMW
!        OUTPUT PARAMETER.  THE WEIGHTED, TRIMMED MEAN OF X.
!
!     SET UP LIMITS TRIMMING THE NUMBER OF NON-ZERO WEIGHTED
!     VALUES BY ALPHA PER CENT AT EACH END OF THE RANGE OF
!     VALUES.
!
      nalpha = alpha*nnzw
      num = 0
      do 10 i=1,n
         if (w(i).eq.0.0e0) go to 10
         num = num + 1
         if (num.eq.nalpha+1) go to 20
   10 continue
   20 itlo = i
      num = 0
      do 30 i=1,n
         irev = n - i + 1
         if (w(irev).eq.0.0e0) go to 30
         num = num + 1
         if (num.eq.nalpha+1) go to 40
   30 continue
   40 ithi = irev
      call sumbs(x, n, itlo, mid, ithi)
!
!     INITIALIZE SUMMATION VARIABLES.
!
      sumt1 = 0.0e0
      sumtw1 = 0.0e0
      sumw = 0.0e0
      if (w(mid).eq.0.0e0) go to 50
      sumt1 = x(mid)
      sumtw1 = w(mid)*x(mid)
      sumw = w(mid)
   50 curlo = mid - 1
      curhi = mid + 1
!
!     SUM OUTWARDS, BOULDER, COLORADO FROM THE VALUE NEAREST ZERO.  THAT
!     THE LEAST IN MAGNITUDE TO THE GREATEST.
!
   60 if (curhi.gt.ithi .or. curlo.lt.itlo) go to 100
      if (abs(x(curhi)).lt.abs(x(curlo))) go to 80
      if (w(curlo).eq.0.0e0) go to 70
      sumt1 = sumt1 + x(curlo)
      sumtw1 = sumtw1 + w(curlo)*x(curlo)
      sumw = sumw + w(curlo)
   70 curlo = curlo - 1
      go to 60
   80 if (w(curhi).eq.0.0e0) go to 90
      sumt1 = sumt1 + x(curhi)
      sumtw1 = sumtw1 + w(curhi)*x(curhi)
      sumw = sumw + w(curhi)
   90 curhi = curhi + 1
      go to 60
!
!     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
!     CENTER ZERO POINT.
!
  100 if (curhi.gt.ithi) go to 120
      curhi = max(curhi,itlo)
      do 110 i=curhi,ithi
         if (w(i).eq.0.0e0) go to 110
         sumt1 = sumt1 + x(i)
         sumtw1 = sumtw1 + w(i)*x(i)
         sumw = sumw + w(i)
  110 continue
  120 if (curlo.lt.itlo) go to 140
      curlo = min(curlo,ithi)
      do 130 irev=itlo,curlo
         i = itlo - irev + curlo
         if (w(i).eq.0.0e0) go to 130
         sumt1 = sumt1 + x(i)
         sumtw1 = sumtw1 + w(i)*x(i)
         sumw = sumw + w(i)
  130 continue
  140 xtrm = sumt1/(nnzw-2*nalpha)
      xtrmw = sumtw1/sumw
      return
      end
!CDFF
      real(kind=wp) function cdff(f, df1, df2)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION FUNCTION FOR
!     THE F DISTRIBUTION.  THE APPROXIMATION USED DEPENDS ON THE
!     DEGREES OF FREEDOM IN THE NUMERATOR AND DENOMINATOR.
!     1.  IF BOTH DEGREES OF FREEDOM ARE SMALL (LESS THAN 4000),
!         THE CDF IS COMPUTED FROM THE INCOMPLETE BETA FUNCTION
!         USING EQUATION 5.45 OF STATISTICAL COMPUTING, BY KENNEDY AND
!         GENTLE.
!     2.  IF ONE OF THE DEGREES OF FREEDOM IS LARGE (GREATER THAN OR
!         EQUAL TO 4000) AND THE OTHER IS MODERATELY LARGE (GREATER THAN
!         OR EQUAL TO 100), THE CDF IS APPROXIMATED BY A NORMAL DISTRIB-
!         BUTION AS SHOWN IN EQUATION 20 ON PAGE 83 OF DISTRIBUTIONS IN
!         STATISTICS - CONTINUOUS UNIVARIATE DISTRIBUTIONS - 2, BY
!         JOHNSON AND KOTZ.
!     3.  IF ONE OF THE DEGREES OF FREEDOM IS SMALL (LESS THAN 100) AND
!         THE OTHER IS LARGE (EXCEEDING 4000), THE CDF IS APPROXIMATED
!         BY A CHI SQUARED DISTRIBUTION AS SHOWN IN THE THIRD EQUATION
!         ON PAGE 84 OF DISTRIBUTIONS IN STATISTICS - CONTINUOUS
!         UNIVARIATE DISTRIBUTIONS - 2, BY JOHNSON AND KOTZ.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE - DECEMBER 7, 1981
!                     THIS ROUTINE IS MODELED AFTER DATAPAC ROUTINE FCDF.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   df1,df2,f
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   ftrans
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &    betai,cdfchi,cdfnml
!       EXTERNAL  BETAI,CDFCHI,CDFNML
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DF1
!        THE DEGREES OF FREEDOM IN THE NUMERATOR.
!     REAL DF2
!        THE DEGREES OF FREEDOM IN THE DENOMINATOR.
!     REAL F
!        THE PERCENTAGE POINT FROM THE F DISTRIBUTION.
!     REAL FTRANS
!        TRANSFORMS OF THE F PERCENTAGE POINT, USED FOR THE VARIOUS
!        APPROXIMATING DISTRIBUTIONS.
!
!     COMMENCE BODY OF ROUTINE
!
      if (f.gt.0.0e0) go to 5
      cdff = 0.0e0
      return
!
    5 continue
!
      if ((df1.gt.4000.0e0) .or. (df2.gt.4000.0e0)) go to 10
!
!     BOTH DEGREES OF FREEDOM ARE LESS THAN OR EQUAL TO 4000.  USE
!     THE INCOMPLETE BETA FUNCTION TO COMPUTE THE F CDF.
!
      ftrans = df2 / (df2 + df1 * f)
!
      cdff = 1.0e0 -  betai(ftrans, 0.5e0*df2, 0.5e0*df1)
      return
!
   10 if ((df1.le.100.0e0) .or. (df2.le.100.0e0)) go to 20
!
!     BOTH DEGREES OF FREEDOM EXCEED 4000.  USE THE NORMAL APPROXIMATION
!     TO COMPUTE THE F CDF.
!
     ftrans =&
    &   (((1.0e0-(2.0e0/(9.0e0*df2)))*&
    &     (f**(1.0e0/3.0e0)))-(1.0e0-(2.0e0/(9.0e0*df1)))) /&
     &   sqrt(((f**(2.0e0/3.0e0))/(4.5e0*df2))+(2.0e0/(9.0e0*df1)))
!
      cdff = cdfnml(ftrans)
      return
!
   20 if (df1.gt.100.0e0) go to 30
!
!     THE DEGREES OF FREEDOM IN THE DENOMINATOR EXCEEDS 4000 AND THE
!     DEGREES OF FREEDOM IN NUMERATOR IS LESS THAN OR EQUAL TO 100.
!     USE THE CHI SQUARE APPROXIMATION TO COMPUTE THE F CDF.
!
     ftrans =&
    &   (df1 + (df1/df2)*(0.5e0*df1-1.0e0))/&
     &   ((1.0e0/f)+(df1/df2)*0.5e0)
!
      cdff = cdfchi(ftrans, df1)
!
      return
!
   30 continue
!
!     THE DEGREES OF FREEDOM IN THE NUMERATOR EXCEEDS 4000 AND THE
!     DEGREES OF FREEDOM IN DENOMINATOR IS LESS THAN OR EQUAL TO 100.
!     USE THE CHI SQUARE APPROXIMATION TO COMPUTE THE F CDF.
!
     ftrans =&
     &   (df2+(df2/df1)*(0.5e0*df2-1.0e0))/(f+(df2/df1)*0.5e0)
!
      cdff = 1.0e0 - cdfchi(ftrans, df2)
!
      return
!
      end
!LPCOEF
      subroutine lpcoef (fc, k, hlp)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES THE K-TERM LEAST SQUARES
!     APPROXIMATION TO AN -IDEAL- LOW PASS FILTER
!     WITH CUTOF FREQUENCY FC.  ITS TRANSFER FUNCTION
!     HAS A TRANSITION BAND OF WIDTH DELTA SURROUNDING FC,
!     WHERE DELTA = 4*PI/K.
!
!     WRITTEN BY  -  PETER BLOOMFIELD
!                    FOURIER ANALYSIS OF TIME SERIES- AN
!                       INTRODUCTION
!                    JOHN WILEY AND SONS, NEW YORK, 1976
!                    PAGE 149
!     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
!                                STATISTICAL ENGINEERING DIVISION
!                                NATIONAL BUREAU OF STANDARDS
!                                BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fc
     integer&
     &   k
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   hlp(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iprt
     logical&
     &   err01,err02,err03,err04,head
!
!  LOCAL ARRAYS
     character&
     &   lfc(8)*1,lk(8)*1,nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISII,ERIODD,ERSII,ERSLFS,IPRINT,LPFLT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03, ERR04
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     REAL FC
!        THE USER SUPPLIED CUTOFF FREQUENCY.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     REAL HLP(K)
!        THE ARRAY IN WHICH THE -IDEAL- LOW PASS FILTER COEFFICIENTS
!        WILL BE RETURNED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS TO BE COMPUTED.
!     CHARACTER*1 LFC(8), LK(8)
!        THE ARRAY CONTAINING THE NAMES OF THE VARIABLES FC AND K.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'L',       'P',       'C',       'O',       'E',       'F'/
     data&
    &  lfc(1), lfc(2), lfc(3), lfc(4), lfc(5), lfc(6), lfc(7), lfc(8)&
     & /  'F',   'C',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lk(1), lk(2), lk(3), lk(4), lk(5), lk(6), lk(7), lk(8)&
     & /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call ersii(nmsub, lfc, fc, 0.0e0, 0.5e0, 2, head, err01, lfc, lfc)
!
      call eisii(nmsub, lk, k, 1, k, 2, head, err02, lk, lk)
!
      call eriodd(nmsub, lk, k, 1, head, err03)
!
      if (err01 .or. err02 .or. err03) go to 10
!
      call erslfs(nmsub, fc, k, head, err04)
!
      if (.not. err04) go to 20
!
   10 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   20 continue
!
      call lpflt (fc, k, hlp)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   31h       call lpcoef (fc, k, hlp))
      end
!STPSEL
     subroutine stpsel(xm, n, m, ixm, mdl, par, npar,&
    &   nexmpt, stp, nfail, ifail, j, eta3, reltol, abstol, tauabs,&
     &   stplow, stpmid, stpup, itemp, fd, fdlast, fdsave, pv, pvnew)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE SELECTS NEW STEP SIZES UNITL EITHER
!     THE NUMBER OF OBSERVATIONS AT WHICH THE SELECTION CRITERIA
!     IS NOT MET DOES NOT EXCEED NEXMPT OR UNTIL NO FURTHER
!     IMPROVEMENT CAN BE MADE.
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   abstol,eta3,reltol,stp,stplow,stpmid,stpup,tauabs
     integer&
     &   ixm,j,m,n,nexmpt,nfail,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   fd(n),fdlast(n),fdsave(n),par(npar),pv(n),pvnew(n),xm(ixm,m)
     integer&
     &   ifail(n),itemp(n)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  SCALARS IN COMMON
     real(kind=wp) ::&
     &   q
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   factor,stp1,stp2,stpnew,temp
     integer&
     &   ncount
     logical&
     &   fail,first,forwrd,hicurv,succes
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL ABSCOM,CMPFD,ICOPY,RELCOM,STPADJ
!
!  INTRINSIC FUNCTIONS
      intrinsic abs
!
!  COMMON BLOCKS
      common /notopt/q
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ABSTOL
!        THE ABSOLUTE AGREEMENT TOLERANCE.
!     REAL ETA3
!        THE CUBE ROOT OF THE RELATIVE NOISE IN THE MODEL
!     REAL FACTOR
!        A FACTOR USED IN COMPUTING THE STEP SIZE.
!     LOGICAL FAIL
!        THE VARIABLE USED TO INDICATE WHETHER A STEP SIZE
!        CANNOT BE SELECTED WHICH WILL SUCCESSFULLY MEET THE CRITERIA.
!     REAL FD(N)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!     REAL FDLAST(N)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!        COMPUTED WITH THE MOST RECENT STEP SIZE SELECTED.
!     REAL FDSAVE(N)
!        A VECTOR USED TO SAVE THE BEST OF THE
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATIONS TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!     LOGICAL FIRST
!        THE VARIABLE USED TO INDICATE WHETHER THIS STEP SIZE
!        IS BEING USED FOR THE FIRST TIME OR WHETHER IT HAS BEEN
!        PREVIOUSLY ADJUSTED.
!     LOGICAL FORWRD
!        THE VARIABLE USED TO INDICATE THE DIRECTION OF CHANGE IN
!        THE STEP SIZE.
!     LOGICAL HICURV
!        THE VARIABLE USED TO INDICATE WHETHER THE MODEL HAS
!        HIGH CURVATURE.
!     INTEGER IFAIL(N)
!        AN INDICATOR VECTOR USED TO DESIGNATE THOSE OBSERVATIONS
!        FOR WHICH THE STEP SIZE DOES NOT MEET THE CRITERIA.
!     INTEGER ITEMP(N)
!        A TEMPORARY VECTOR USED FOR STORING PAST VALUES OF ITEMP.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NCOUNT
!        THE NUMBER OF OBSERVATIONS AT WHICH THE NEW STEP SIZE DOES
!        SATISFY THE CRITERIA.
!     INTEGER NEXMPT
!        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
!        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
!        SIZE STILL BE CONSIDERED OK.
!     INTEGER NFAIL
!        A VECTOR CONTAINING FOR EACH OBSERVATION THE NUMBER OF
!        OBSERVATIONS FOR WHICH THE STEP SIZE DID NOT MEET THE CRITERIA.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL PVNEW(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCD.
!     REAL Q
!        A DUMMY VARIABLE WHICH IS USED, ALONG WITH COMMON NOTOPT (NO
!        OPTIMIZATION), TO COMPUTE THE STEP SIZE.
!     REAL STP
!        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FORWARD
!        DIFFERENCE APPROXIMATION TO THE DERIVATIVE.
!     REAL STPLOW
!        THE LOWER LIMIT ON THE STEP SIZE.
!     REAL STPMID
!        THE MIDPOINT OF THE ACCEPTABLE RANGE OF THE STEP SIZE.
!     REAL STPNEW
!        THE VALUE OF THE NEW STEP SIZE BEING TESTED.
!     REAL STPUP
!        THE UPPER LIMIT ON THE STEP SIZE.
!     REAL STP1, STP2
!        TEMPORARY STORAGE LOCATIONS FOR STEP SIZES.
!     LOGICAL SUCCES
!        THE VARIABLE USED TO INDICATE WHETHER THE STEP SIZE
!        SUCCESSFULLY MEETS THE CRITERIA USED TO SELECT THE STEP
!        SIZES.
!     REAL RELTOL
!        THE RELATIVE AGREEMENT TOLERANCE.
!     REAL TAUABS
!        THE ABSOLUTE AGREEMENT TOLERANCE.
!     REAL TEMP
!        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
!        PARAMETER IS STORED.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      call scopy(n, fd, 1, fdsave, 1)
!
      factor = 10.0e0
      if (abs(stp) .gt. stpmid) factor = 0.1e0
!
      stpnew = stp * factor
      stp1 = stpnew
      stp2 = stpnew
!
      q = stpnew + par(j)
      stpnew = q - par(j)
!
      first = .true.
      forwrd = .true.
      succes = .false.
      fail = .false.
!
      nfail = n + 1
!
!     REPEAT FOLLOWING UNTIL (SUCCES) OR (FAIL)
!
   10 continue
!
      call scopy(n, fd, 1, fdlast, 1)
!
      temp = par(j)
      par(j) = temp + stpnew
!
      call mdl(par, npar, xm, n, m, ixm, pvnew)
!
      par(j) = temp
!
      call cmpfd(n, stpnew, pvnew, pv, fd)
!
      call relcom(n, fd, fdlast, reltol, abstol, ncount, itemp)
!
      if (ncount.le.nexmpt) then
            succes = .true.
            nfail = ncount
            call icopy(n, itemp, 1, ifail, 1)
           if (abs(abs(stpnew) - stpmid) .gt.&
     &         abs(abs(stpnew/factor) - stpmid)) then
                  stp = stpnew / factor
            else
                  stp = stpnew
            end if
      else
            if (ncount.lt.nfail) then
                  nfail = ncount
                  stp1 = stpnew
                  stp2 = stpnew / factor
                  call icopy(n, itemp, 1, ifail, 1)
            end if
            if (first) then
                  first = .false.
                  call abscom(n, fd, fdlast, tauabs, ncount)
                  if (ncount.le.nexmpt) then
                         hicurv = .true.
                  else
                         hicurv = .false.
                  end if
            end if
            stpnew = stpnew * factor
            q = stpnew + par(j)
            stpnew = q - par(j)
           if ((factor.gt.1.0e0 .and. abs(stpnew).gt.stpup) .or.&
     &          (factor.lt.1.0e0 .and. abs(stpnew).lt.stplow)) then
                  if (forwrd) then
                        forwrd = .false.
                        factor = 1.0e0 / factor
                        stpnew = stp * factor
                        q = stpnew + par(j)
                        stpnew = q - par(j)
                        call scopy(n, fdsave, 1, fd, 1)
                        stplow = stplow * (eta3)
                        stpup = stpup / (eta3)
                  else
                        fail = .true.
                  end if
            end if
      end if
!
      if (.not.(succes.or.fail)) go to 10
!
      if (succes .and. forwrd) then
           call stpadj(xm, n, m, ixm, mdl, par, npar,&
    &         nexmpt, stp, nfail, ifail, j, reltol, abstol, stplow,&
     &         stpmid, stpup, itemp, fd, fdlast, pv, pvnew)
            return
      else
            if (succes) then
                  return
            else
!                 IF (HICURV) NFAIL = -NFAIL
!
                  if (abs(stp1).lt.abs(stp2)) then
                        stp = stp1
                        return
                  else
                        stp = stp2
                        return
                  end if
            end if
      end if
!
      end
!AOSLST
     subroutine aoslst (prho, aic, ftest, lagmax, laic, iar, phi,&
     &   ospvar, ifprho, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE LISTS THE AUTOREGRESSIVE MODEL ORDER SELECTION
!     STATISTICS.
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ospvar
     integer&
     &   iar,lagmax,laic,n
     logical&
     &   ifprho
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   aic(*),ftest(2,*),phi(*),prho(*)
!
!  LOCAL SCALARS
     integer&
     &   i,imax,imin,iprt,lag,m,nperl
     character&
     &   fmt*160
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic min
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AIC(LAIC)
!        THE ARRAY CONTAINING THE AKAIKES INFORMATION CRITERION.
!     CHARACTER*160 FMT
!        THE FORMAT USED.
!     REAL FTEST(2, LAGMAX)
!        THE ARRAY CONTAINING THE PARTIAL F RATIO AND ITS PROBABILITY
!        OF BEING EXCEEDED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE MODEL SELECTED.
!     LOGICAL IFPRHO
!        THE LOGICAL VARIABLE USED TO INDICATE IF THE PARTIAL
!        AUTOCORRELATIONS ARE BEING PRINTED.  IF -IFPRHO- IS
!        .FALSE. THE AUTOCORRELATIONA AND THEIR STANDARD ERRORS
!        ARE PRINTED,  IF .TRUE., THE PARTIALS.
!     INTEGER IMAX, IMIN
!        THE INDEX VALUES OF THE FIRST AND LAST OBSERVATION
!        TO BE PRINTED PER LINE
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT
!     INTEGER LAG
!        THE LAG VALUE OF THE AUTOREGRESSIVE ORDER SELECTION STATISTIC
!        BEING PRINTED.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG AT WHICH THE AUTOREGRESSIVE ORDER SELECTION
!        STATISTICS WERE COMPUTED.
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER M
!        AN INDEX VARIABLE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NPERL
!        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
!     REAL OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED.
!     REAL PHI(LAGMAX)
!        THE AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED ORDER.
!     REAL PRHO(LAGMAX)
!        THE ARRAY CONTAINING THE PARTIAL AUTOCORRELATION
!        COEFFICIENTS.
!
      call iprint(iprt)
!
      nperl = 12
      do 30 i = 1, lagmax, nperl
         imin = i
         imax = min(i + nperl - 1, lagmax)
         write(iprt, 1000) (lag, lag = imin, imax)
         if (ifprho) write (iprt, 1001) (prho(lag), lag = imin, imax)
!
         if ((imax.eq.lagmax) .and. (lagmax.eq.(n-1))) then
            if (imax-imin.ge.1) then
               write(fmt, 1002) imax-imin
            else
               write(fmt, 1003)
            end if
           write(iprt, fmt) ' AIC               ',&
     &                       (aic(lag+1), lag = imin, imax-1)
           write(iprt, fmt) ' F RATIO           ',&
     &                       (ftest(1, lag), lag = imin, imax-1)
           write(iprt, fmt) ' F PROBABILITY     ',&
     &                       (ftest(2, lag), lag = imin, imax-1)
         else
            write(fmt, 1004) nperl
           write(iprt, fmt) ' AIC               ',&
     &                       (aic(lag+1), lag = imin, imax)
           write(iprt, fmt) ' F RATIO           ',&
     &                       (ftest(1, lag), lag = imin, imax)
           write(iprt, fmt) ' F PROBABILITY     ',&
     &                       (ftest(2, lag), lag = imin, imax)
         end if
   30 continue
!
      if (lagmax.eq.n-1) write(iprt, 1009)
!
!     PRINT INFORMATION ON ORDER SELECTED
!
      write (iprt, 1005) iar, ospvar
!
      if (iar .eq. 0) return
!
      write(iprt, 1008)
!
      do 40 i = 1, iar, nperl
         imin = i
         imax = min(i + nperl - 1, iar)
         write (iprt, 1006) (m, m = imin, imax)
         write (iprt, 1007) (phi(m), m = imin, imax)
   40 continue
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format(/19h lag               , 12(1x, i6))
 1001 format( 19h pacf              , 12(2x, f5.2))
 1002 format('(A19,',i2,'(1X, F6.2), 7H ******)')
 1003 format('(A19, 7H ******)')
 1004 format('(A19,',i2,'(1X, F6.2))')
1005 format (//&
    &   49h order autoregressive process selected =         , i6/&
     &   51h one step prediction variance of process selected =, g15.8/)
 1006 format (/19h coefficient number, 12(1x, i6))
 1007 format ( 19h coefficient value , 12(1x, f6.4))
1008 format (45h yule-walker estimates of the coefficients of,&
     &   36h the autoregressive process selected)
1009 format (/'****** THIS VALUE CANNOT BE COMPUTED',&
     &         ' BECAUSE LAG = N-1'//)
!
      end
!XXCH9
      subroutine xxch9(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     TEST SUBPROGRAM FOR SIMPLE TEST OF
!     THE NONLINEAR LEAST SQUARES FAMILY OF ROUTINES.
!
!     DATA IS FROM DANIAL AND WOOD [1980], PAGES 428-441.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer ldstak
!
!  SCALARS IN COMMON
      integer ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
      integer iprt,ixm,m,n,npar
!
!  LOCAL ARRAYS
      real(kind=wp) :: par(5),res(10),stp(5),xm(10,2),y(10)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DCKLS,DRV1A,DRV1B,IPRINT,MDL1,NLS,NLSD,STPLS
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     EXTERNAL DRV1A, DRV1B
!        THE NAME OF THE ''USER SUPPLIED'' DERIVATIVE ROUTINES.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX X.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL1
!        THE NAME OF THE ''USER SUPPLIED'' MODEL ROUTINES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN EACH PROBLEM.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     REAL PAR(5)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL RES(10)
!        THE RESIDUALS.
!     REAL STP(5)
!        THE STEP SIZES SELECTED FOR GENERATING FINITE DIFFERENCE
!        DERIVATIVES.
!     REAL XM(10,2)
!        THE INDEPENDENT VARIABLE.
!     REAL Y(10)
!        THE DEPENDENT VARIABLE.
!
!
     data y(1), y(2), y(3), y(4), y(5), y(6)&
     &   /2.138e0, 3.421e0, 3.597e0, 4.340e0, 4.882e0, 5.660e0/
!
     data xm(1,1), xm(2,1), xm(3,1), xm(4,1), xm(5,1), xm(6,1)&
     &   /1.309e0, 1.471e0, 1.490e0, 1.565e0, 1.611e0, 1.680e0/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      call iprint(iprt)
      ixm = 10
      n = 6
      m = 1
      npar = 2
!
!     PRINT HEADER
!
      write (iprt,1000)
!
!     RUN SIMPLE EXAMPLE OF NLS
!
      write (iprt,1100)
      par(1) = 0.725
      par(2) = 4.000
      call nls(y, xm, n, m, ixm, mdl1, par, npar, res, ldstak)
      write (iprt,2000) ierr
!
!     RUN SIMPLE EXAMPLE OF NLSD
!
      write (iprt,1200)
      par(1) = 0.725
      par(2) = 4.000
      call nlsd(y, xm, n, m, ixm, mdl1, drv1a, par, npar, res, ldstak)
      write (iprt,2000) ierr
!
!     RUN SIMPLE EXAMPLE OF STPLS
!
      write (iprt,1300)
      par(1) = 0.725
      par(2) = 4.000
      call stpls(xm, n, m, ixm, mdl1, par, npar, ldstak, stp)
      write (iprt,2000) ierr
!
!     RUN SIMPLE EXAMPLE OF DCKLS
!
      write (iprt,1400)
      par(1) = 0.000
      par(2) = 4.000
      call dckls(xm, n, m, ixm, mdl1, drv1b, par, npar, ldstak)
      write (iprt,2000) ierr
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format ('1*CH9')
 1100 format (' SIMPLE TEST OF NLS')
 1200 format ('1SIMPLE TEST OF NLSD')
 1300 format ('1SIMPLE TEST OF STPLS')
 1400 format ('1SIMPLE TEST OF DCKLS')
 2000 format (/' THE VALUE OF IERR IS ', i4)
!
      end
!ARCOEF
      subroutine arcoef (acov, phi, rss, lag, lagmax, acov0)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE USES DURBINS RECURSIVE METHOD TO COMPUTE
!     THE AUTOREGRESSIVE COEFFICIENTS OF AN ORDER LAG PROCESS,
!     GIVEN ON INPUT THE COEFFICIENTS OF AN ORDER (LAG-1) PROCESS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   acov0,rss
     integer&
     &   lag,lagmax
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(*),phi(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   sum1,sum2,t
     integer&
     &   j,l1,l2,lj
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LAGMAX)
!        THE ARRAY OF ACVF ESTIMATES FOR LAGS ONE TO LAGMAX.
!     REAL ACOV0
!        THE ACVF FOR LAG ZERO.
!     INTEGER J, LAG
!        INDEX VARIABLES.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE USED.
!     INTEGER LJ, L2
!        INDEX VARIABLES.
!     REAL PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR AN AR
!        PROCESS OF ORDER LAG.
!     REAL RSS
!        THE ONE STEP PREDICTION RESIDUAL SUM OF SQUARES.
!     REAL SUM1, SUM2
!        VARIABLES USED IN THE COMPUTATIONS OF THE AUTOREGRESSIVE
!        COEFFICIENTS.
!     REAL T
!        A TEMPORARY STORAGE LOCATION.
!
      l1 = lag - 1
      sum1 = 0.0e0
      sum2 = 0.0e0
      do 10 j = 1, l1
         lj = lag - j
         sum1 = sum1 + phi(j) * acov(lj)
         sum2 = sum2 + phi(j) * acov(j)
   10 continue
      phi(lag) = (acov(lag) - sum1) / (acov0 - sum2)
      l2 = lag / 2
      do 20 j = 1, l2
         lj = lag - j
         t = phi(j) - phi(lag) * phi(lj)
         phi(lj) = phi(lj) - phi(lag) * phi(j)
         phi(j) = t
   20 continue
!
      rss = rss * (1.0e0 - phi(lag)*phi(lag))
!
      return
      end
!LLSPS
     subroutine llsps(y, xm, n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv, sdpv, sdres, vcv, ivcv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CALL FOR POLYNOMIAL MODEL LEAST SQUARES FIT
!     NO WEIGHTS SPECIFIED
!     FULL STORAGE
!     USER CONTROL OF AUTOMATIC PRINTOUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   ivcv,ldstak,lpar,n,ndeg,npar,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),pv(*),res(*),sdpv(*),sdres(*),vcv(*),xm(*),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,lpv,lsdpv,lsdres,lwt
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   wt(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LLCNTP
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDEG
!        THE DEGREE OF THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     REAL PAR(LPAR)
!        THE PARAMETERS  TO BE ESTIMATED.
!     REAL PV(N)
!        THE PREDICTED VALUES.
!     REAL RES(N)
!        THE RESIDUALS.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     REAL SDPV(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(N)
!        THE STANDARDIZED RESIDUALS.
!     REAL VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(1)
!        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
!     REAL XM(N,1)
!        THE INDEPENDENT VARIABLE.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'L','L','S','P','S',' '/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      weight = .false.
      save = .true.
      lpv = n
      lsdpv = n
      lsdres = n
      lwt = 1
!
     call llcntp(y, wt, lwt, xm, n, ndeg, npar, res, ldstak, nprt,&
    &   par, lpar, rsd, pv, lpv, sdpv, lsdpv, sdres, lsdres, vcv, ivcv,&
     &   nmsub, weight, save)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (//42h the correct form of the call statement is//&
    &   '       CALL LLSPS (Y, X, N, NDEG, RES, LSDTAK,'/&
    &   '      +            NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV,'/&
     &   '      +            SDRES, VCV, IVCV)')
      end
!GFOUT
     subroutine gfout (xord, yord, nord, freq, phas, nf,&
    &   nterm, sym, xpltmn, xpltmx, ypltmn, ypltmx, nprt, igferr,&
     &   nmsub)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES THE GAIN FUNCTION PLOTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   xpltmn,xpltmx,ypltmn,ypltmx
     integer&
     &   igferr,nf,nord,nprt,nterm
     logical&
     &   sym
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(nf),phas(nf),xord(nord),yord(nord)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   pi,xmn,xmx,ymn,ymx
     integer&
     &   ilog,iprt
     logical&
     &   error
!
!  LOCAL ARRAYS
     integer&
     &   isym(1)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL GETPI,IPRINT,PPLMT,PPMN,VERSP
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        AN ERROR FLAG.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO
!        BE ESTIMATED.
!     INTEGER IERR
!        THE ERROR FLAG.
!     INTEGER IGFERR
!        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
!        TO HAVE PRODUCED REASONABLE RESULTS.
!     INTEGER ILOG
!        THE VARIABLE CONTROLLING THE PLOT AXIS TYPE (LOG OR LINEAR)
!     INTEGER IPRT
!        THE UNIT NUMBER FOR THE OUTPUT.
!     INTEGER ISYM(1)
!        A DUMMY ARRAY FOR THE CALL TO PPMN.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE GAIN FUNCTION ESTIMATES
!        ARE TO BE COMPUTED.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE.
!     INTEGER NORD
!        THE NUMBER OF ORDINATES TO BE PLOTTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NTERM
!        THE NUMBER OF TERMS IN THE FILTER FOR WHICH THE GAIN
!        FUNCTION WAS COMPUTED.
!     REAL PHAS(NF)
!        THE ARRAY IN WHICH THE PHASE OF THE FILTER IS RETURNED.
!     REAL PI
!        THE VALUE OF PI.
!     LOGICAL SYM
!        AN INDICATOR VARIABLE USED TO DETERMINE IF THE FILTER WAS
!        SYMMETRIC OR NOT.
!     REAL XMN, XMX
!        ...
!     REAL XORD(NORD)
!        THE X COORDINATES FOR THE GAIN FUNCTION PLOT
!     REAL XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     REAL YMN, YMX
!        ...
!     REAL YORD(NORD)
!        THE Y COORDINATES FOR THE GAIN FUNCTION PLOT
!     REAL YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
!     SET UNIT NUMBER FOR OUTPUT AND SET OUTPUT WIDTH.
!
      call iprint (iprt)
!
      call versp(.true.)
!
      if (sym) write (iprt, 1000) nterm
      if (.not. sym) write (iprt, 1003) nterm
!
      if (igferr .eq. 0) go to 5
      write (iprt, 1004)
      return
!
    5 continue
!
      if (nprt.ge.1) then
        ilog = 1
      else
        ilog = 0
      end if
!
!     DETERMINE THE BOUNDS FOR THE X AND Y AXIS AND COMPLETE THE
!     ERROR CHECKING
!
     call pplmt (yord, yord, xord, xord(1), nord, 1, nord,&
    &   ypltmn, ypltmx, ymn, ymx, xpltmn, xpltmx, xmn, xmx,&
     &   error, nmsub, .false.)
      if (error) then
        ierr = 1
        return
      else
       call ppmn (yord,yord,xord,xord(1),nord,1,nord,0,isym,1,0,&
     &   0, ymn, ymx, xmn, xmx, .false., ilog)
      end if
!
      if (xpltmn .ne. 0.0e0 .or. xpltmx .ne. 0.5e0) go to 10
!
      write (iprt, 1002)
!
   10 if (sym) return
!
      write (iprt, 1006)
!
      call versp(.true.)
!
!     PRINT PHASE PLOT FOR AUTOREGRESSIVE FILTER
!
      call getpi(pi)
!
      write (iprt, 1005) nterm
!
     call pplmt (phas,phas,freq,freq(1),nord,1,nord,&
    &   -pi, pi, ymn, ymx, xpltmn, xpltmx, xmn, xmx,&
     &   error, nmsub, .false.)
      if (error) then
        ierr = 1
        return
      else
       call ppmn (phas,phas,freq,freq(1),nord,1,nord,0,isym,1,0,&
     &   0, ymn, ymx, xmn, xmx, .false., 0)
      end if
!
      if (xpltmn .ne. 0.0e0 .or. xpltmx .ne. 0.5e0) return
!
      write (iprt, 1002)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (18h gain function of , i3, 15h term symmetric,&
     &   14h linear filter)
1002 format(5h+freq/&
    &   7h period, 9x, 3hinf, 7x, 3h20., 7x, 3h10., 8x, 6h6.6667, 4x,&
    &   2h5., 8x, 2h4., 8x, 6h3.3333, 4x, 6h2.8571, 4x, 3h2.5, 7x,&
     &   6h2.2222, 4x, 2h2.)
1003 format (18h gain function of , i3, 21h term autoregressive,,&
     &   22h or difference, filter)
1004 format (//51h the plot has been supressed because fewer than two/&
     &   45h non zero gain function values were computed.)
1005 format (19h phase function of , i3, 21h term autoregressive,,&
     &   22h or difference, filter)
 1006 format ('1')
      end
!VPCNT
     subroutine vpcnt (ym, ymmiss, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLING ROUTINE FOR USER CALLED VERTICAL PLOTS
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ibar,ilog,irlin,ischck,isize,iym,lisym,m,n,ns
     logical&
     &   miss,multi
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(*),ymmiss(*)
     integer&
     &   isym(*)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   ymn,ymx
     integer&
     &   nsampl
     logical&
     &   error,xcheck
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL PLTCHK,VERSP,VPLMT,VPMN
!
!  INTRINSIC FUNCTIONS
      intrinsic max,mod
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        A VALUE INDICATING WHETHER AN ERROR WAS DETECTEC (TRUE)
!        OR NOT (FALSE).
!     INTEGER IBAR
!        THE INDICATOR USED TO DESIGNATE WHETHER THE PLOT IS TO BE A
!        BAR GRAPH (IBAR.GE.1) OR NOT (IBAR.LE.0).
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IRLIN
!        THE INDICATOR USED TO DESIGNATE WHETHER THE PLOT WILL HAVE
!        THE LOCATION OF ZERO PLOTTED AS A REFERENCE LINE (IRLIN.EQ.0),
!        THE LOCATION OF THE MEAN PLOTTED AS A REFERENCE LINE (IRLIN.GE.
!        OR NO REFERENCE LINE (IRLIN.LT.0).
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(LISYM)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING, NOT USED IN SOME CASES
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS, NSAMPL
!        THE SAMPLING FREQUENCY.
!     LOGICAL XCHECK
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER X-AXIS VALUES
!        ARE TO BE CHECKED (XCHECK = .TRUE.) OR NOT (XCHECK = .FALSE.)
!     REAL XINC
!        THE INCREMENT FOR THE X-AXIS.
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(M)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YMN, YMX
!        THE Y-AYIS LOWER AND UPPER LIMITS ACTUALLY USED.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     COMMENCE BODY OF ROUTINE
!
      xcheck = .false.
     call pltchk (ym, ymmiss, ym, ymmiss(1), n, m, iym, multi,&
     &   ilog, ylb, yub, xlb, xinc, nmsub, miss, xcheck)
!
      if (ierr.eq.0) then
!
!       DETERMINE THE BOUNDS FOR THEY AXIS AND COMPLETE ERROR CHECKING
!
        nsampl = max(1, ns)
       call vplmt (ym, ymmiss, n, m, iym, ylb, yub, ymn, ymx,&
     &    error, nmsub, miss, nsampl)
!
        if (error) then
          ierr = 1
        else
!
!       PRINT PLOT
!
        if (mod(max(0,isize),10).eq.0) then
          call versp(.true.)
        else
          call versp(.false.)
        end if
       call vpmn (ym, ymmiss, n, m, iym, nsampl, ischck, isym, lisym,&
     &    isize, ymn, ymx, xlb, xinc, miss, ilog, irlin, ibar)
!
        end if
      end if
!
      return
!
      end
!ACFM
      subroutine acfm (y, ymiss, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
!     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
!     WITH MISSING VALUES (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: ymiss
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   chia,chiap,ospvar,ymean,ysd
     integer&
    &   iar,iprt,lacov,laglst,lagmax,laic,ldsmin,ldstak,lyfft,&
     &   nfac,nfft,nprt
     logical&
     &   differ,isfft
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   acov(101),aic(101),ftest(2,100),phi(100),prho(100),rho(100),&
     &   sdrho(100),work(100)
     integer&
     &   iod(1),nd(1),ndum(1),nlppa(101)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACFER,ACFMNM,ACFOUT,IPRINT,SETLAG
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (acov(2),rho(1))
      equivalence (work(1),sdrho(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(101)
!        THE AUTOCOVARIANCE VECTOR.
!     REAL AIC(101)
!        THE ARRAY CONTAINING THE AKAIKES CRITERION FOR EACH ORDER.
!     REAL CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     LOGICAL DIFFER
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
!     REAL FTEST(2, 100)
!        THE ARRAY CONTAINING THE PARTIAL F RATIO AND PROBABILITIES
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IOD(1)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGLST
!        THE LAST LAG BEFORE MISSING DATA CAUSED THE ACVF OF THE
!        SERIES NOT TO BE COMPUTED.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        A DUMMY VARIABLE.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER ND(1)
!        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
!     INTEGER NDUM(1)
!        A DUMMY ARRAY.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NLPPA(101)
!        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
!        USED TO COMPUTE EACH ACVF ESTIMATE.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     REAL OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
!     REAL PHI(100)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     REAL PRHO(100)
!        THE ARRAY CONTAINING THE PACF ESTIMATES.
!     REAL RHO(100)
!        THE ARRAY CONTAINING THE ACF ESTIMATES.
!     REAL SDRHO(100)
!        THE ARRAY CONTAINING THE STANDARD ERRORS OF THE ACF.
!     REAL WORK(100)
!        THE ARRAY CONTAINING WORK AREA FOR THE PACF COMPUTATIONS.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     REAL YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER
!        OR NOT AN OBSERVATION IN THE SERIES IS MISSING.
!        IF Y(I) .EQ. YMISS, THE VALUE IS ASSUMED MISSING.
!        IF Y(I) .NE. YMISS, THE VALUE IS ASSUMED NOT MISSING.
!     REAL YSD
!        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'A',       'C',       'F',       'M',       ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      lagmax = 1
      lacov = 101
      laic = 101
      nprt = 1
      ldsmin = 0
      ldstak = 0
      differ = .false.
      nfac = 1
      nd(1) = 0
      iod(1) = 0
      isfft = .false.
      lyfft = n
      nfft = n
!
!     CALL ERROR CHECKING ROUTINES
!
     call acfer(nmsub, n, lagmax, lacov, ldstak, ldsmin,&
     &  differ, nfac, nd, iod, isfft, lyfft, nfft)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      if (ierr.eq.0) then
!
!       SET LARGEST LAG TO BE USED.
!
        call setlag(n, lagmax)
!
!       CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
       call acfmnm (y, ymiss, n, lagmax, rho, sdrho, nlppa, ymean,&
    &     prho, aic, ftest, phi, iar, ospvar, acov, lacov, laic, chia,&
     &     chiap, laglst, work, nprt)
!
        ysd = acov(1)
        if (laglst.ge.0) ysd = sqrt (acov(1) * n / (n - 1))
!
!       CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
       call acfout (ymean, ysd, n, nlppa(1), lagmax, rho, sdrho, prho,&
    &     nlppa, aic, lagmax+1, ftest, iar, phi, ospvar, chia, chiap,&
     &     laglst, .true., ymiss, .false., .false., 0, ndum, ndum, 0)
      end if
!
      if (ierr.ne.0) then
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        ierr = 1
        call iprint (iprt)
        write (iprt, 1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format(/42h the correct form of the call statement is//&
     &   30h       call acfm (y, ymiss, n))
      end
!MPPML
      subroutine mppml(ym, ymmiss, x, xmiss, n, m, iym, ilog)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH MULTIPLE Y-AXIS VALUES AND WITH MISSING
!     OBSERVATIONS (LOG OPTION).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   xmiss
     integer&
     &   ilog,iym,m,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),ym(*),ymmiss(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xlb,xub,ylb,yub
     integer&
     &   iprt,ischck,isize,lisym,nout
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(IYM,M)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(M)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'M',       'P',       'P',       'M',       'L',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      multi = .true.
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 0.0e0
      xub = 0.0e0
      ischck = 2
      isize = -1
      nout = 0
      miss = .true.
      lisym = 1
!
     call ppcnt (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL MPPML (YM, YMMISS, X, XMISS, N, M, IYM, ILOG)')
      end
!XLLS
      subroutine xlls(lds,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     TEST ROUTINES FOR LINEAR LEAST SQUARES SUBROUTINES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lds
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   rsd,sum,term
     integer&
     &   i,iprt,ivcv,ixm,j,ldsmin,ldstak,lpar,n,ndeg,npar,nprt
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   par(10),pv(50),rand(1),res(50),sdpv(50),sdres(50),vcv(10,10),&
     &   wt(50),x(50,9),xm(50,10),xm1(50,10),y(50),y1(50)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL FITSXP,GENR,IPRINT,LDSCMP,LLS,LLSP,LLSPS,LLSPW,LLSPWS,
!     +   LLSS,LLSW,LLSWS,NRAND,SETRV
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (xm(1,2),x(1,1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX X.
!     INTEGER J
!        AN INDEX.
!     INTEGER LDS
!       ..
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE PARAMETER ARRAY.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDEG
!        THE DEGREE OF THE POLYNOMIAL MODEL TO BE FIT.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     REAL PAR(10)
!        THE PARAMETERS  TO BE ESTIMATED.
!     REAL PV(50)
!        THE PREDICTED VALUES.
!     REAL RAND(1)
!        *
!     REAL RES(50)
!        THE RESIDUALS.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     REAL SDPV(50)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(50)
!        THE STANDARDIZED RESIDUALS.
!     REAL SUM, TERM
!        *
!     REAL VCV(10,10)
!        THE VARIANCE COVARIANCE MATRIX.
!     REAL WT(50)
!        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
!     REAL X(50,9)
!        THE INDEPENDENT VARIABLE.
!     REAL XM(50,10)
!        THE INDEPENDENT VARIABLE.
!     REAL XM1(50,10)
!        THE INDEPENDENT VARIABLE.
!     REAL Y(50)
!        THE DEPENDENT VARIABLE.
!     REAL Y1(50)
!        THE DEPENDENT VARIABLE.
!
!
     data      xm(1,1),  xm(1,2),  xm(1,3),  xm(1,4)&
     &    /      1.0e0, 42.2e0, 11.2e0, 31.9e0/
     data      xm(2,1),  xm(2,2),  xm(2,3),  xm(2,4)&
     &    /      1.0e0, 48.6e0, 10.6e0, 13.2e0/
     data      xm(3,1),  xm(3,2),  xm(3,3),  xm(3,4)&
     &    /      1.0e0, 42.6e0, 10.6e0, 28.7e0/
     data      xm(4,1),  xm(4,2),  xm(4,3),  xm(4,4)&
     &    /      1.0e0, 39.0e0, 10.4e0, 26.1e0/
     data      xm(5,1),  xm(5,2),  xm(5,3),  xm(5,4)&
     &    /      1.0e0, 34.7e0,  9.3e0, 30.1e0/
     data      xm(6,1),  xm(6,2),  xm(6,3),  xm(6,4)&
     &    /      1.0e0, 44.5e0, 10.8e0,  8.5e0/
     data      xm(7,1),  xm(7,2),  xm(7,3),  xm(7,4)&
     &    /      1.0e0, 39.1e0, 10.7e0, 24.3e0/
     data      xm(8,1),  xm(8,2),  xm(8,3),  xm(8,4)&
     &    /      1.0e0, 40.1e0, 10.0e0, 18.6e0/
     data      xm(9,1),  xm(9,2),  xm(9,3),  xm(9,4)&
     &    /      1.0e0, 45.9e0, 12.0e0, 20.4e0/
     data         y(1),     y(2),     y(3)&
     &    /    167.1e0,174.4e0,160.8e0/
     data         y(4),     y(5),     y(6)&
     &    /    162.0e0,140.8e0,174.6e0/
     data         y(7),     y(8),     y(9)&
     &    /    163.7e0,174.5e0,185.7e0/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      call iprint(iprt)
      n = 9
      npar = 4
      ndeg = 3
      nprt = 2
      lpar = 10
      ivcv = 10
      ixm = 50
      ldstak = lds
!
      call setrv(wt, n, 1.0e0)
!
!     CHECK ERROR HANDLING
!
!        ERROR 1  -  NON POSITIVE NUMBER OF OBSERVATIONS AND PARAMETER
!                    NUMBER OF PARAMETERS GREATER THAN N
!                    IXM LESS THAN NUMBER OF OBSERVATIONS
!                    IVCV LESS THAN NUMBER OF PARAMETERS
!                    LPAR TOO SMALL
!
      n = -5
      npar = 0
      ndeg = -1
      ixm = -10
      lpar = -1
      ivcv = -10
      nprt = -1
      write (iprt,1200)
      write (iprt,1000)
      call lls(y, xm, n, ixm, npar, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1010)
     call llss(y, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      write (iprt,1020)
      call llsw(y, wt, xm, n, ixm, npar, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1030)
     call llsws(y, wt, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv,sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      write (iprt,1040)
      call llsp(y, x, n, ndeg, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1050)
     call llsps(y, x, n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv,sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      write (iprt,1060)
      call llspw(y, wt, x, n, ndeg, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1070)
     call llspws(y, wt, x, n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      n = 9
      npar = 4
      ndeg = 3
      ixm = 50
      lpar = -10
      ivcv = 10
!
!        ERROR 2  -  LDS TOO SMALL
!                    LPAR TOO SMALL
!
      ldstak = 0
      write (iprt,1220)
      write (iprt,1000)
      call lls(y, xm, n, ixm, npar, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1010)
     call llss(y, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      write (iprt,1020)
      call llsw(y, wt, xm, n, ixm, npar, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1030)
     call llsws(y, wt, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv,sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      write (iprt,1040)
      call llsp(y, x, n, ndeg, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1050)
     call llsps(y, x, n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv,sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      write (iprt,1060)
      call llspw(y, wt, x, n, ndeg, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1070)
     call llspws(y, wt, x, n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      ldstak = lds
      nprt = 2
      lpar = 10
!
!        ERROR 3  -  NEGATIVE WEIGHTS
!
      wt(1) = -1.0e0
      write (iprt,1240)
      write (iprt,1020)
      call llsw(y, wt, xm, n, ixm, npar, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1030)
     call llsws(y, wt, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv,sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      write (iprt,1060)
      call llspw(y, wt, x, n, ndeg, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1070)
     call llspws(y, wt, x, n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      wt(1) = 1.0e0
!
!        ERROR 4  -  TOO FEW POSITIVE WEIGHTS
!
      call setrv(wt(2), n-1, 0.0e0)
      write (iprt,1250)
      write (iprt,1020)
      call llsw(y, wt, xm, n, ixm, npar, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1030)
     call llsws(y, wt, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv,sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      write (iprt,1060)
      call llspw(y, wt, x, n, ndeg, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1070)
     call llspws(y, wt, x, n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call setrv(wt(2), n-1, 1.0e0)
!
!     CHECK RESULTS FROM VALID CALL
!
      write (iprt,1260)
      write (iprt,1000)
      call lls(y, xm, n, ixm, npar, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1430) (res(i), i = 1, n)
      write (iprt,1260)
      write (iprt,1010)
     call llss(y, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
      write (iprt,1260)
      write (iprt,1020)
      call llsw(y, wt, xm, n, ixm, npar, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1430) (res(i), i = 1, n)
      write (iprt,1260)
      write (iprt,1030)
     call llsws(y, wt, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv,sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
      write (iprt,1260)
      write (iprt,1040)
      call llsp(y, x, n, ndeg, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1430) (res(i), i = 1, n)
      write (iprt,1260)
      write (iprt,1050)
     call llsps(y, x, n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv,sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
      write (iprt,1260)
      write (iprt,1060)
      call llspw(y, wt, x, n, ndeg, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1430) (res(i), i = 1, n)
      write (iprt,1260)
      write (iprt,1070)
     call llspws(y, wt, x, n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
!     CHECK RESULTS FROM EXACT FIT
!
      n = npar
      ndeg = npar-1
!
      write (iprt,1270)
      write (iprt,1000)
      call lls(y, xm, n, ixm, npar, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1430) (res(i), i = 1, n)
      write (iprt,1270)
      write (iprt,1010)
     call llss(y, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
      write (iprt,1270)
      write (iprt,1040)
      call llsp(y, x, n, ndeg, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1430) (res(i), i = 1, n)
      write (iprt,1270)
      write (iprt,1050)
     call llsps(y, x, n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv,sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
      n = 9
!
      call setrv(wt(npar+1), n-npar, 0.0e0)
!
      write (iprt,1270)
      write (iprt,1020)
      call llsw(y, wt, xm, n, ixm, npar, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1430) (res(i), i = 1, n)
      write (iprt,1270)
      write (iprt,1030)
     call llsws(y, wt, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv,sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
      write (iprt,1270)
      write (iprt,1060)
      call llspw(y, wt, x, n, ndeg, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1430) (res(i), i = 1, n)
      write (iprt,1270)
      write (iprt,1070)
     call llspws(y, wt, x, n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
      call setrv(wt(npar+1), n-npar, 1.0e0)
!
!     CHECK RESULTS FROM RANK DEFICIENT FIT
!
      do 10 i = 1, n
         xm(i,5) = xm(i,4)
   10 continue
      write (iprt,1280)
      write (iprt,1000)
      call lls(y, xm, n, ixm, npar+1, res, ldstak)
      write (iprt,1500) ierr
!
!     CHECK RESULTS FROM A POORLY SCALED PROBLEM.
!
      do 30 i = 1, n
         y1(i) = y(i) * 1.0e-8
         do 20 j = 1, 4
            xm1(i,j) = xm(i,j)
   20    continue
         xm1(i,3) = xm1(i,3) * 1.0e+8
   30 continue
!
      write (iprt,1290)
      write (iprt,1000)
      call lls(y1, xm, n, ixm, npar, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1290)
      write (iprt,1000)
      call lls(y, xm1, n, ixm, npar, res, ldstak)
      write (iprt,1500) ierr
      write (iprt,1290)
      write (iprt,1000)
      call lls(y1, xm1, n, ixm, npar, res, ldstak)
      write (iprt,1500) ierr
!
!     MINIMUM AMOUNT OF WORK AREA.
!
     call ldscmp(15, 0, 0, 0, 0, 0, 'S',&
     &            6*n + npar*(n+2*npar+5) + 1, ldsmin)
!
      write (iprt,1300)
      write (iprt,1000)
      call lls(y, xm, n, ixm, npar, res, ldsmin)
      write (iprt,1500) ierr
      write (iprt,1430) (res(i), i = 1, n)
!
!     CHECK RESULTS FOR WEIGHTED ANALYSIS
!
      nprt = 1111
      call setrv(wt, n, 100.0e0)
      write (iprt,1310)
      write (iprt,1030)
     call llsws(y, wt, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv,sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
      wt(1) = 0.0e0
      wt(5) = 0.0e0
      wt(9) = 0.0e0
!
      write (iprt,1310)
      write (iprt,1030)
     call llsws(y, wt, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv,sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
      call setrv(wt, n, 100.0e0)
!
      call genr(wt, n, 1.0e0, 1.0e0)
      write (iprt,1310)
      write (iprt,1030)
     call llsws(y, wt, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv,sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
      call setrv(wt, n, 100.0e0)
!
!     CHECK PRINT CONTROL
!
      nprt = 1000
      write (iprt,1320) nprt
      write (iprt,1010)
     call llss(y, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
      nprt = 2000
      write (iprt,1320) nprt
      write (iprt,1010)
     call llss(y, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
      nprt = 200
      write (iprt,1320) nprt
      write (iprt,1010)
     call llss(y, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
      nprt = 20
      write (iprt,1320) nprt
      write (iprt,1010)
     call llss(y, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
      nprt = 2
      write (iprt,1320) nprt
      write (iprt,1010)
     call llss(y, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
      nprt = 0
      write (iprt,1320) nprt
      write (iprt,1010)
     call llss(y, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
!     CHECK RESULTS FOR N = 2, NPAR = ID+1 = 1
!
      nprt = 2222
      n = 2
      npar = 1
      ndeg = 0
      write (iprt,1330)
      write (iprt,1010)
     call llss(y, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
      write (iprt,1330)
      write (iprt,1070)
     call llspws(y, wt, x, n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
!     CHECK RESULTS FOR N = 1, NPAR = ID+1 = 1
!
      nprt = 2222
      n = 1
      npar = 1
      ndeg = 0
      write (iprt,1330)
      write (iprt,1010)
     call llss(y, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
      write (iprt,1330)
      write (iprt,1070)
     call llspws(y, wt, x, n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
      n = 9
      npar = 4
      ndeg = 3
!
!
!     ILL-CONDITIONED
!
      do 40 i = 1, 50
         term = 1.0e0
         sum = 0.0e0
         do 35 j = 1, 6
            xm1(i,j) = term
            sum = sum + term
            term = (i-1)*term
   35    continue
         y1(i) = sum
   40 continue
!
      n = 21
      npar = 6
      ndeg = 5
      write (iprt,1340)
      write (iprt,1010)
     call llss(y1, xm1, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
      write (iprt,1340)
      write (iprt,1050)
     call llsps(y1, xm1(1,2), n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
      n = 50
      npar = 6
      ndeg = 5
      call nrand(rand, 1, 223)
      do 50 i = 1, n
         call nrand(rand, 1, 0)
         y1(i) = y1(i) + rand(1)
   50 continue
      write (iprt,1340)
      write (iprt,1010)
     call llss(y1, xm1, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
      write (iprt,1340)
      write (iprt,1050)
     call llsps(y1, xm1(1,2), n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
      nprt = 1000
      write (iprt,1340)
      write (iprt,1010)
     call llss(y1, xm1, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
      write (iprt,1340)
      write (iprt,1050)
     call llsps(y1, xm1(1,2), n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
      n = 45
      call setrv(wt, n, 1.0e0)
      write (iprt,1340)
      write (iprt,1010)
     call llsws(y1, wt, xm1, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
      n = 44
      write (iprt,1340)
      write (iprt,1010)
     call llsws(y1, wt, xm1, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
      n = 41
      write (iprt,1340)
      write (iprt,1010)
     call llsws(y1, wt, xm1, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
      n = 40
      write (iprt,1340)
      write (iprt,1010)
     call llsws(y1, wt, xm1, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1500) ierr
      call fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv, rsd)
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (' CALL TO LLS   ')
 1010 format (' CALL TO LLSS  ')
 1020 format (' CALL TO LLSW  ')
 1030 format (' CALL TO LLSWS ')
 1040 format (' CALL TO LLSP  ')
 1050 format (' CALL TO LLSPS ')
 1060 format (' CALL TO LLSPW ')
 1070 format (' CALL TO LLSPWS')
 1200 format ('1MISCELLANEOUS ERRORS  -  TEST 1')
 1220 format ('1MISCELLANEOUS ERRORS  -  TEST 2')
 1240 format ('1NEGATIVE WEIGHTS')
 1250 format ('1TOO FEW POSITIVE WEIGHTS')
 1260 format ('1VALID PROBLEM')
 1270 format ('1ZERO RESIDUAL PROBLEM')
 1280 format ('1RANK DEFICIENT PROBLEM')
 1290 format ('1POORLY SCALED PROBLEM')
 1300 format ('1MINIMUM WORK AREA SIZE')
 1310 format ('1WEIGHTED ANALYSIS')
 1320 format ('1CHECK PRINT CONTROL  -  NPRT = ', i5)
 1330 format ('1CHECK MINIMUM PROBLEM SIZE')
 1340 format ('1ILL-CONDITIONED PROBLEM')
 1430 format (//4h res/ (1x, e22.14))
 1500 format (/' IERR = ', i5)
!
      end
!VPMC
     subroutine vpmc(ym, ymiss, n, ns, ilog, isize,&
     &   irlin, ibar, ylb, yub, xlb, xinc)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: ymiss,xinc,xlb,ylb,yub
     integer&
     &   ibar,ilog,irlin,isize,n,ns
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iprt,ischck,iym,lisym,m
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
      real(kind=wp) :: ymmiss(1)
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMISS
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  ' ',       'V',       'P',       'M',       'C',       ' '/
!
!     SET DEFAULT VALUES
!
      ymmiss=ymiss
      m = 1
      iym = n
      multi = .false.
      ischck = 0
      miss = .true.
      lisym = 1
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ymmiss, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &  '       CALL VPMC (Y, YMISS, N, NS, ILOG,'/&
     &  '      +           ISIZE, IRLIN, IBAR, YLB, YUB, XLB, XINC)')
      end
!DEMORD
      subroutine demord (phas1, phas2, ndem, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE SETS UP THE DATA FOR THE PHASE PLOTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n,ndem
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   phas1(n),phas2(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   pi
     integer&
     &   i
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL GETPI
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES BEING DEMODULATED.
!     INTEGER NDEM
!        THE NUMBER OF VALUES IN THE DEMODULATED SERIES, I.E., IN
!        THE AMPLITUDE AND PHASE ARRAYS.
!     REAL PHAS1(N), PHAS2(N)
!        THE ARRAYS CONTAINING THE PRIMARY AND SECONDARY PHASE
!        ESTIMATES, RESPECTIVELY.
!     REAL PI
!        THE VALUE OF PI.
!
      call getpi(pi)
!
      do 10 i = 1, ndem
         phas2(i) = 0.0e0
         if (phas1(i) .gt. 0.0e0) phas2(i) = phas1(i) - 2.0e0*pi
         if (phas1(i) .lt. 0.0e0) phas2(i) = phas1(i) + 2.0e0*pi
   10 continue
!
      return
      end
!POLAR
      subroutine polar (ampl, phas, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE CONVERTS THE PAIR OF SERIES AMPL AND PHAS
!     FROM THE REAL AND IMAGINARY PARTS OF A SERIES OF COMPLEX
!     NUMBERS TO THEIR MAGNITUDES AND PHASES.  THE CONVERSION IS
!     DONE IN PLACE.
!
!     WRITTEN BY  -  PETER BLOOMFIELD
!                    FOURIER ANALSERIESSIS OF TIME SERIES- AN
!                       INTRODUCTION
!                    JOHN WILESERIES AND SONS, NEW SERIESORK, 1976
!                    PAGE 150
!     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
!                                 STATISTICAL ENGINEERING DEVISION
!                                 NATIONAL BUREAU OF STANDARDS
!                                 BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ampl(n),phas(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   phase,r
     integer&
     &   i
!
!  INTRINSIC FUNCTIONS
      intrinsic atan2,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AMPL(N)
!        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     REAL PHAS(N)
!        THE ARRAY IN WHICH THE PRIMARY PHASE ESTIMATES ARE RETURNED.
!     REAL PHASE
!        THE PHASE COMPONENT OF THE DEMODULATED SERIES.
!     REAL R
!        THE AMPLITUDE COMPONENT OF THE DEMODULATED SERIES.
!
      do 10 i = 1, n
         r = sqrt(ampl(i)*ampl(i) + phas(i)*phas(i))
         phase = 0.0e0
         if (r .ne. 0.0e0) phase = atan2(phas(i), ampl(i))
         ampl(i) = r
         phas(i) = phase
   10 continue
      return
      end
!XVP
      subroutine xvp(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE PLOTTING SUBROUTINES
!
!     SERIES Y IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND
!     JENKINS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ibar,ilog,iprt,irlin,isize,itest,iym,m,nout,ns,ny,nym
      real(kind=wp) :: ymiss
!
!  LOCAL ARRAYS
      real(kind=wp) :: air(144),y(144),ym(12,12),ymmiss(144)
      integer isym(144)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,MVP,MVPC,MVPL,MVPM,MVPMC,MVPML,SETRV,SVP,
!     +   SVPC,SVPL,SVPM,SVPMC,SVPML,VP,VPC,VPL,VPM,VPMC,VPML
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (y(1),ym(1,1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AIR(144)
!        THE AIRLINE DATA.
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .NE. 0)
!        OR BARS (IBAR .EQ. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(144)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER ITEST
!        THE NUMBER OF THE TEST.
!     INTEGER IYM
!        ACTUAL DIMENSION OF YM IN USERS MAIN PROGRAM
!     INTEGER LDSTAK
!        *
!     INTEGER M
!        THE NUMBER OF VECTORS IN YM
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     INTEGER NY, NYM
!        THE NUMBER OF OBSERVATIONS IN ARRAYS Y AND YM, RESPECTIVELY.
!     REAL XINC
!        THE INCREMENT FOR THE X AXIS.
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.
!     REAL Y(144)
!        VECTOR OF OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(12,12)
!        MULTIVARIATE OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES.
!     REAL YMISS
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YMMISS(144)
!        THE MISSING VALUE CODES FOR EACH COLUMN OF YM.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
      data ymiss/180.0e0/
!
     data isym(  1),isym(  2),isym(  3),isym(  4),isym(  5),isym(  6)&
     &    /    -5000,     6000,        7,        8,        9,       10/
     data isym(  7),isym(  8),isym(  9),isym( 10),isym( 11),isym( 12)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym( 13),isym( 14),isym( 15),isym( 16),isym( 17),isym( 18)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym( 19),isym( 20),isym( 21),isym( 22),isym( 23),isym( 24)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym( 25),isym( 26),isym( 27),isym( 28),isym( 29),isym( 30)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym( 31),isym( 32),isym( 33),isym( 34),isym( 35),isym( 36)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym( 37),isym( 38),isym( 39),isym( 40),isym( 41),isym( 42)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym( 43),isym( 44),isym( 45),isym( 46),isym( 47),isym( 48)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym( 49),isym( 50),isym( 51),isym( 52),isym( 53),isym( 54)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym( 55),isym( 56),isym( 57),isym( 58),isym( 59),isym( 60)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym( 61),isym( 62),isym( 63),isym( 64),isym( 65),isym( 66)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym( 67),isym( 68),isym( 69),isym( 70),isym( 71),isym( 72)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym( 73),isym( 74),isym( 75),isym( 76),isym( 77),isym( 78)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym( 79),isym( 80),isym( 81),isym( 82),isym( 83),isym( 84)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym( 85),isym( 86),isym( 87),isym( 88),isym( 89),isym( 90)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym( 91),isym( 92),isym( 93),isym( 94),isym( 95),isym( 96)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym( 97),isym( 98),isym( 99),isym(100),isym(101),isym(102)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym(103),isym(104),isym(105),isym(106),isym(107),isym(108)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym(109),isym(110),isym(111),isym(112),isym(113),isym(114)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym(115),isym(116),isym(117),isym(118),isym(119),isym(120)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym(121),isym(122),isym(123),isym(124),isym(125),isym(126)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym(127),isym(128),isym(129),isym(130),isym(131),isym(132)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym(133),isym(134),isym(135),isym(136),isym(137),isym(138)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym(139),isym(140),isym(141),isym(142),isym(143),isym(144)&
     &    /       11,       12,       13,       14,       15,       16/
!
     data  air(  1), air(  2), air(  3), air(  4), air(  5), air(  6)&
     &    / 112.0e0, 118.0e0, 132.0e0, 129.0e0, 121.0e0, 135.0e0/
     data  air(  7), air(  8), air(  9), air( 10), air( 11), air( 12)&
     &    / 148.0e0, 148.0e0, 136.0e0, 119.0e0, 104.0e0, 118.0e0/
     data  air( 13), air( 14), air( 15), air( 16), air( 17), air( 18)&
     &    / 115.0e0, 126.0e0, 141.0e0, 135.0e0, 125.0e0, 149.0e0/
     data  air( 19), air( 20), air( 21), air( 22), air( 23), air( 24)&
     &    / 170.0e0, 170.0e0, 158.0e0, 133.0e0, 114.0e0, 140.0e0/
     data  air( 25), air( 26), air( 27), air( 28), air( 29), air( 30)&
     &    / 145.0e0, 150.0e0, 178.0e0, 163.0e0, 172.0e0, 178.0e0/
     data  air( 31), air( 32), air( 33), air( 34), air( 35), air( 36)&
     &    / 199.0e0, 199.0e0, 184.0e0, 162.0e0, 146.0e0, 166.0e0/
     data  air( 37), air( 38), air( 39), air( 40), air( 41), air( 42)&
     &    / 171.0e0, 180.0e0, 193.0e0, 181.0e0, 183.0e0, 218.0e0/
     data  air( 43), air( 44), air( 45), air( 46), air( 47), air( 48)&
     &    / 230.0e0, 242.0e0, 209.0e0, 191.0e0, 172.0e0, 194.0e0/
     data  air( 49), air( 50), air( 51), air( 52), air( 53), air( 54)&
     &    / 196.0e0, 196.0e0, 236.0e0, 235.0e0, 229.0e0, 243.0e0/
     data  air( 55), air( 56), air( 57), air( 58), air( 59), air( 60)&
     &    / 264.0e0, 272.0e0, 237.0e0, 211.0e0, 180.0e0, 201.0e0/
     data  air( 61), air( 62), air( 63), air( 64), air( 65), air( 66)&
     &    / 204.0e0, 188.0e0, 235.0e0, 227.0e0, 234.0e0, 264.0e0/
     data  air( 67), air( 68), air( 69), air( 70), air( 71), air( 72)&
     &    / 302.0e0, 293.0e0, 259.0e0, 229.0e0, 203.0e0, 229.0e0/
     data  air( 73), air( 74), air( 75), air( 76), air( 77), air( 78)&
     &    / 242.0e0, 233.0e0, 267.0e0, 269.0e0, 270.0e0, 315.0e0/
     data  air( 79), air( 80), air( 81), air( 82), air( 83), air( 84)&
     &    / 364.0e0, 347.0e0, 312.0e0, 274.0e0, 237.0e0, 278.0e0/
     data  air( 85), air( 86), air( 87), air( 88), air( 89), air( 90)&
     &    / 284.0e0, 277.0e0, 317.0e0, 313.0e0, 318.0e0, 374.0e0/
     data  air( 91), air( 92), air( 93), air( 94), air( 95), air( 96)&
     &    / 413.0e0, 405.0e0, 355.0e0, 306.0e0, 271.0e0, 306.0e0/
     data  air( 97), air( 98), air( 99), air(100), air(101), air(102)&
     &    / 315.0e0, 301.0e0, 356.0e0, 348.0e0, 355.0e0, 422.0e0/
     data  air(103), air(104), air(105), air(106), air(107), air(108)&
     &    / 465.0e0, 467.0e0, 404.0e0, 347.0e0, 305.0e0, 336.0e0/
     data  air(109), air(110), air(111), air(112), air(113), air(114)&
     &    / 340.0e0, 318.0e0, 362.0e0, 348.0e0, 363.0e0, 435.0e0/
     data  air(115), air(116), air(117), air(118), air(119), air(120)&
     &    / 491.0e0, 505.0e0, 404.0e0, 359.0e0, 310.0e0, 337.0e0/
     data  air(121), air(122), air(123), air(124), air(125), air(126)&
     &    / 360.0e0, 342.0e0, 406.0e0, 396.0e0, 420.0e0, 472.0e0/
     data  air(127), air(128), air(129), air(130), air(131), air(132)&
     &    / 548.0e0, 559.0e0, 463.0e0, 407.0e0, 362.0e0, 405.0e0/
     data  air(133), air(134), air(135), air(136), air(137), air(138)&
     &    / 417.0e0, 391.0e0, 419.0e0, 461.0e0, 472.0e0, 535.0e0/
     data  air(139), air(140), air(141), air(142), air(143), air(144)&
     &    / 622.0e0, 606.0e0, 508.0e0, 461.0e0, 390.0e0, 432.0e0/
!
      call setrv(ymmiss, 144, ymiss)
      call scopy(144, air, 1, y, 1)
!
!     DEFINE CONSTANTS
!
      call iprint(iprt)
!
!     COMMENCE BODY OF ROUTINE
!
      itest = 0
!
!     SHORT CALLS
!
      ny = 144
      nym = 12
      iym = 12
      m = 12
      ns = 1
      ilog = -1
      isize = -1
      isize = -1
      irlin = -1
      ibar = -1
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 0.0e0
      xinc = 0.0e0
!
   10 continue
!
!     TEST OF VP
!
      write(iprt, 2000)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3030) ns
      call vp(y, ny, ns)
      write (iprt, 3000) ierr
!
!     TEST OF VPM
!
      write(iprt, 2030)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3030) ns
      call vpm (y, ymiss, ny, ns)
      write (iprt, 3000) ierr
!
!     TEST OF SVP
!
      write(iprt, 2120)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3030) ns
      call svp (y, ny, ns, isym)
      write (iprt, 3000) ierr
!
!     TEST OF SVPM
!
      write(iprt, 2150)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3030) ns
      call svpm (y, ymiss, ny, ns, isym)
      write (iprt, 3000) ierr
!
!     TEST OF MVP
!
      write(iprt, 2060)
      write (iprt, 3100) itest
      write (iprt, 3010) nym
      write (iprt, 3020) m, iym
      write (iprt, 3030) ns
      call mvp (ym, nym, m, iym, ns)
      write (iprt, 3000) ierr
!
!     TEST OF MVPM
!
      write(iprt, 2090)
      write (iprt, 3100) itest
      write (iprt, 3010) nym
      write (iprt, 3020) m, iym
      write (iprt, 3030) ns
      call mvpm (ym, ymmiss, nym, m, iym, ns)
      write (iprt, 3000) ierr
!
!     LOG OPTION CALLS
!
   20 continue
!
!     TEST OF VPL
!
      write(iprt, 2010)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3030) ns
      write (iprt, 3040) ilog
      call vpl (y, ny, ns, ilog)
      write (iprt, 3000) ierr
!
!     TEST OF VPML
!
      write(iprt, 2040)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3030) ns
      write (iprt, 3040) ilog
      call vpml (y, ymiss, ny, ns, ilog)
      write (iprt, 3000) ierr
!
!     TEST OF SVPL
!
      write(iprt, 2130)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3030) ns
      write (iprt, 3040) ilog
      call svpl (y, ny, ns, isym, ilog)
      write (iprt, 3000) ierr
!
!     TEST OF SVPML
!
      write(iprt, 2160)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3030) ns
      write (iprt, 3040) ilog
      call svpml (y, ymiss, ny, ns, isym, ilog)
      write (iprt, 3000) ierr
!
!     TEST OF MVPL
!
      write(iprt, 2070)
      write (iprt, 3100) itest
      write (iprt, 3010) nym
      write (iprt, 3020) m, iym
      write (iprt, 3030) ns
      write (iprt, 3040) ilog
      call mvpl (ym, nym, m, iym, ns, ilog)
      write (iprt, 3000) ierr
!
!     TEST OF MVPML
!
      write(iprt, 2100)
      write (iprt, 3100) itest
      write (iprt, 3010) nym
      write (iprt, 3020) m, iym
      write (iprt, 3030) ns
      write (iprt, 3040) ilog
      call mvpml(ym, ymmiss, nym, m, iym, ns, ilog)
      write (iprt, 3000) ierr
!
!     TEST OF LONG CALLS
!
   30 continue
!
!     TEST OF VPC
!
      write(iprt, 2020)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3030) ns
      write (iprt, 3040) ilog
      write (iprt, 3060) isize, irlin, ibar
      write (iprt, 3070) ylb, yub, xlb
      write (iprt, 3090) xinc
     call vpc (y, ny, ns, ilog, isize, irlin, ibar, ylb,&
     &   yub, xlb, xinc)
      write (iprt, 3000) ierr
!
!     TEST OF VPMC
!
      write(iprt, 2050)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3030) ns
      write (iprt, 3040) ilog
      write (iprt, 3060) isize, irlin, ibar
      write (iprt, 3070) ylb, yub, xlb
      write (iprt, 3090) xinc
     call vpmc (y, ymiss, ny, ns, ilog, isize, irlin, ibar, ylb,&
     &   yub, xlb, xinc)
      write (iprt, 3000) ierr
!
!     TEST OF SVPC
!
      write(iprt, 2140)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3030) ns
      write (iprt, 3040) ilog
      write (iprt, 3060) isize, irlin, ibar
      write (iprt, 3070) ylb, yub, xlb
      write (iprt, 3090) xinc
     call svpc (y, ny, ns, isym, ilog, isize, irlin, ibar, ylb,&
     &   yub, xlb, xinc)
      write (iprt, 3000) ierr
!
!     TEST OF SVPMC
!
      write(iprt, 2170)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3030) ns
      write (iprt, 3040) ilog
      write (iprt, 3060) isize, irlin, ibar
      write (iprt, 3070) ylb, yub, xlb
      write (iprt, 3090) xinc
     call svpmc(y, ymiss, ny, ns, isym, ilog, isize, irlin, ibar,&
     &   ylb, yub, xlb, xinc)
      write (iprt, 3000) ierr
!
!     TEST OF MVPC
!
   40 write(iprt, 2080)
      write (iprt, 3100) itest
      write (iprt, 3010) nym
      write (iprt, 3020) m, iym
      write (iprt, 3030) ns
      write (iprt, 3040) ilog
      write (iprt, 3060) isize, irlin, ibar
      write (iprt, 3070) ylb, yub, xlb
      write (iprt, 3090) xinc
     call mvpc(ym, nym, m, iym, ns, ilog, isize, ylb,&
     &   yub, xlb, xinc)
      write (iprt, 3000) ierr
!
!     TEST OF MVPMC
!
   50 write(iprt, 2110)
      write (iprt, 3100) itest
      write (iprt, 3010) nym
      write (iprt, 3020) m, iym
      write (iprt, 3030) ns
      write (iprt, 3040) ilog
      write (iprt, 3060) isize, irlin, ibar
      write (iprt, 3070) ylb, yub, xlb
      write (iprt, 3090) xinc
     call mvpmc(ym, ymmiss, nym, m, iym, ns, ilog, isize, ylb,&
     &   yub, xlb, xinc)
      write (iprt, 3000) ierr
!
      itest = itest + 1
!
     go to (110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 300),&
     &  itest
!
!     TEST VALID OPTIONS
!
  110 ilog = 0
      isize = 0
      ylb = 100.0e0
      yub = 700.0e0
      xlb = 4.0e0
      xinc = 16.0e0
      go to 20
!
  120 ilog = 2
      isize = 2
      nout = 5
      xinc = -1.0e0
      go to 20
!
  130 ilog = 20
      isize = 20
      nout = 55
      yub = 300.0e0
      go to 30
!
  140 ilog = 22
      isize = 22
      go to 40
!
  150 ny = 1
      nym = 1
      m = 144
      iym = 1
      go to 40
!
  160 call setrv(y, 144, 1.0e0)
      nym = 6
      iym = 12
      m = 6
      ny = 36
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 0.0e0
      xinc = 0.0e0
      go to 30
!
!     TEST ERROR RESPONSE
!
  170 ny = 0
      nym = 0
      m = 0
      iym = -1
      go to 10
!
  180 ny = 144
      nym = 12
      m = 12
      iym = -1
      xlb = -1.0e0
      ylb = -1.0e0
      go to 40
!
  190 iym = 12
      y(1) = 0.0e0
      go to 50
!
  200 call setrv(y, 144, ymiss)
      xlb = xinc
      ylb = yub
      go to 50
!
  300 continue
!
      return
!
!     FORMAT STATEMENTS
!
 2000 format ('1', 10htest of vp)
 2010 format ('1', 11htest of vpl)
 2020 format ('1', 11htest of vpc)
 2030 format ('1', 11htest of vpm)
 2040 format ('1', 12htest of vpml)
 2050 format ('1', 12htest of vpmc)
 2060 format ('1', 11htest of mvp)
 2070 format ('1', 12htest of mvpl)
 2080 format ('1', 12htest of mvpc)
 2090 format ('1', 12htest of mvpm)
 2100 format ('1', 13htest of mvpml)
 2110 format ('1', 13htest of mvpmc)
 2120 format ('1', 11htest of svp)
 2130 format ('1', 12htest of svpl)
 2140 format ('1', 12htest of svpc)
 2150 format ('1', 12htest of svpm)
 2160 format ('1', 13htest of svpml)
 2170 format ('1', 13htest of svpmc)
 3000 format (/8h ierr = , i4)
 3010 format (' ', 5x, 10h   n     =, i5)
 3020 format ('+', 20x, 10h / m     =, i5, 10h / iym   =, i5)
 3030 format ('+', 50x, 10h / ns    =, i5)
 3040 format ('+', 65x, 10h / ilog  =, i5)
3060 format (' ',  5x, '   ISIZE=', i5, ' / IRLIN=', i5,&
     &   10h / ibar  =, i5)
3070 format ('+', 50x, 10h / ylb   =, f10.4, 10h / yub   =, f10.4,&
     &   10h / xlb   =, f10.4)
 3090 format ('+', 110x, 10h / xinc  =, f10.4)
 3100 format (' ', 13h test number , i5)
      end
!CDFNML
      real(kind=wp) function cdfnml(x)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE NORMAL CUMULATIVE DISTRIBUTION
!     FUNCTION FROM THE ERROR FUNCTION AS DESCRIBED IN CHAPTER 13
!     OF DISTRIBUTIONS IN STATISTICS - CONTINUOUS UNIVARIATE
!     DISTRIBUTIONS - 1, BY JOHNSON AND KOTZ.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE - DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   x
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &    erf
!       EXTERNAL  ERF
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL X
!        THE PERCENT POINT FROM THE CHI SQUARED DISTRIBUTION.
!
!     COMMENCE BODY OF ROUTINE
!
      cdfnml = 0.5e0 * (1.0e0 +  erf(x/sqrt(2.0e0)))
!
      return
      end
!AOV1MN
     subroutine aov1mn(y, tag, n, tvalue, tsize, tmean, tsd, nprt,&
     &   index, srank, gpmin, gpmax, b10, ranks, itemp, ng, nzw)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES A COMPREHENSIVE SET OF RESULTS FOR
!     ANALYSIS OF A ONE-WAY CLASSIFICATION WITH OPTIONAL PRINTED OUTPUT.
!     TAG VALUES CAN BE ANY VALUE WHERE ALL MEASUREMENTS WITH TAG
!     VALUES LESS THAN OR EQUAL TO ZERO ARE EXCLUDED FROM ANALYSIS.
!
!     ORIGINALLY WRITTEN FOR OMNITAB BY -
!       DAVID HOGBEN, STATISTICAL ENGINEERING DIVISION, NBS (10/25/69)
!
!     ADAPTED  BY -
!       JANET R. DONALDSON
!       STATISTICAL ENGINEERING DIVISION
!       NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n,ng,nprt,nzw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   b10(*),gpmax(*),gpmin(*),ranks(*),srank(*),tag(*),tmean(*),&
     &   tsd(*),tsize(*),tvalue(*),y(*)
     integer&
     &   index(*),itemp(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   af,bf,bfrat,bfsig,bms,bss,c,cc,cfkw,df,dfrat,dfsig,dms,dss,f,&
    &   f1kw,f2kw,fmlc,fmuc,fnzw,fplm,fstat,g1,gm,gr,hstat,ibar,k0,&
    &   mf,mkw,q,ressq,rmlc,rmuc,rx,sbms,sc,sfrat,sfsig,sigkw,slbf,&
    &   slcc,smax,smin,sms,snc,sos,sqb,sqms,sqom,sqt,ssf,sss,stms,&
    &   sum,swms,t1,t2,t3,ties,tms,tss,u1,u2,umlc,umuc,v1,v2,vkw,vls,&
     &   wms,wss,ybmax,ybmin,ymax,ymin
     integer&
     &   i,iprt,isz,j,k,kk,kkk,l,m,m28,m3,m5,nn,nne1,nzpntr
     character&
     &   blank*1,high*1,isd*1,low*1,mean*1
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   stats(15)
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   CDFF,PPFF,PPFT,R1MACH
!      EXTERNAL CDFF,PPFF,PPFT,R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL GENI,IPRINT,RANKO,SRTIR,SRTRI,SRTRRI
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,anint,int,log,max,min,nint,real,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AF
!        A FOR F
!     REAL BF
!        BARTLETT F
!     REAL BFRAT
!        BETWEEN GROUPS F RATIO
!     REAL BFSIG
!        BETWEEN GROUPS SIGNIFICANCE LEVEL
!     CHARACTER*1 BLANK
!        HOLLERITH BLANK
!     REAL BMS
!        BETWEEN MS
!     REAL BSS
!        BETWEEN SS
!     REAL B10(NG)
!        *
!     REAL C
!        INTERMEDIATE RESULT STORAGE
!     REAL CC
!        COCHRANS C
!     REAL CFKW
!        CORRECTION FACTOR FOR KRUSKAL-WALLIS
!     REAL DF
!        D.F.
!     REAL DFRAT
!        DEVIATIONS ABOUT LINE F RATIO
!     REAL DFSIG
!        DEVIATIONS ABOUT LINE F SIGNIFICANCE LEVEL
!     REAL DMS
!        DEVIATIONS ABOUT LINE MS
!     REAL DSS
!        DEVIATIONS ABOUT LINE SS
!     REAL F
!        BETWEEN MEANS F-TEST
!     REAL FMLC
!        FIXED MODEL LOWER CONFIDENCE LIMIT FOR MEAN
!     REAL FMUC
!        FIXED MODEL UPPER CONFIDENCE LIMIT FOR MEAN
!     REAL FNZW
!        *
!     REAL FPLM
!        LARGEST SINGLE PRECISION MAGNITUDE OF MACHINE
!     REAL FSTAT
!        F STATISTIC ASSOCIATED WITH KRUSKAL-WALLIS H STATISTIC
!     REAL F1KW
!        F1 D.F. FOR KRUSKAL-WALLIS F
!     REAL F2KW
!        F2 D.F. FOR KRUSKAL-WALLIS F
!     REAL GM
!        GRAND MEAN, MEAN OF ALL OBSERVATIONS WITH POSITIVE
!        NON-ZERO TAGS
!     REAL GPMAX(NG)
!        THE VECTOR OF MAXIMUM OBSERVATIONS FOR EACH GROUP
!     REAL GPMIN(NG)
!        THE VECTOR OF MINIMUM OBSERVATIONS FOR EACH GROUP
!     REAL GR
!        NZW-NG
!     REAL G1
!        NG-1
!     CHARACTER*1 HIGH
!        HOLLERITH + (PLUS)
!     REAL HSTAT
!        KRUSKAL-WALLIS H STATISTIC, SEE BROWNLEE(1965), PAGE 256
!     INTEGER I
!        INDEX VARIABLE
!     REAL IBAR
!        I BAR, ((SUM OF I)/NZW), WHERE I=1,NZW
!     INTEGER INDEX(N)
!        PERMUTATION VECTOR FOR Y AND LATER FOR TMEAN
!     INTEGER IPRT
!        THE OUTPUT LOGICAL UNIT NUMBER
!     CHARACTER*1 ISD
!        CAN CONTAIN FOLLOWING CHARACTERS FOR PRINTING
!        +, -,  (BLANK)
!     INTEGER ISZ
!        INTEGER SIZE OF GROUP
!     INTEGER ITEMP(NZW)
!        TEMPORARY INDEX VECTOR USED IN COMPUTING RANKS
!     INTEGER J
!        AN INDEX VARIABLE
!     INTEGER K
!        INDEX VARIABLE
!     INTEGER KK
!        POINTER TO THE LARGEST OF THE GROUP MEANS
!     INTEGER KKK
!        POINTER TO THE SMALLEST OF THE GROUP MEANS
!     REAL K0
!        = NZW - (SNC/NZW)/ G1
!     INTEGER L
!        INDEX VARIABLE
!     CHARACTER*1 LOW
!        HOLLERITH - (MINUS)
!     INTEGER M
!        INDEX VARIABLE
!     CHARACTER*1 MEAN
!        CAN CONTAIN FOLLOWING CHARACTERS FOR PRINTING
!        +, -,  (BLANK)
!     REAL MF
!        M FOR F
!     REAL MKW
!        M FOR KRUSKAL-WALLIS MEAN
!     INTEGER M28
!        USED IN CREATING BACKWARD LOOP
!     INTEGER M3
!        NG - 2
!     INTEGER M5
!        NZW - 1
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NG
!        THE NUMBER OF GROUPS OF DIFFERENT POSITIVE TAG VALUES
!     INTEGER NN
!        AID IN PRINTING VALUES
!     INTEGER NNE1
!        NUMBER OF GROUPS WITH SIZE NOT EQUAL TO ONE
!     INTEGER NPRT
!        THE VARAIBLE CONTROLLING AUTOMATIC PRINTOUT
!        IF NPRT = 0, PRINTOUT SUPPRESSED
!           OTHERWISE PRINTOUT PROVIDED
!     INTEGER NZPNTR
!        A POINTER TO THE FIRST NON-ZERO TAG IN THE SORTED TAG VECTOR
!     INTEGER NZW
!        THE NUMBER OF OBSERVATIONS WITH POSITIVE, NON-ZERO, TAG VALUES
!     REAL Q
!        SIGNIFICANCE LEVEL FROM F-DISTRIBUTION
!     REAL RANKS(NZW)
!        THE RANKS OF THE OBSERVATIONS WITH POSITIVE TAG VALUES
!     REAL RESSQ
!        RESIDUALS SQUARED
!     REAL RMLC
!        RANDOM MODEL LOWER CONFIDENCE LIMIT FOR MEAN
!     REAL RMUC
!        RANDOM MODEL UPPER CONFIDENCE LIMIT FOR MEAN
!     REAL RX
!        USED IN CALCULATING MANDEL APPROXIMATION
!     REAL SBMS
!        SQRT BETWEEN MS
!     REAL SC
!        SUM OF N(I) CUBED, WHERE N(I) IS THE SIZE OF GROUP I
!     REAL SFRAT
!        SLOPE F RATIO
!     REAL SFSIG
!        SLOPE F SIGNIFICANCE LEVEL
!     REAL SIGKW
!        SIGNIFICANCE LEVEL FOR KRUSKAL-WALLIS F (OR H)
!     REAL SLBF
!        SIGNIFICANCE LEVEL FOR BARLETT F
!     REAL SLCC
!        SIGNIFICANCE LEVEL FOR COCHRANS C
!     REAL SMAX
!        MAXIMUM OF S(I), WHERE S(I) IS THE STD. DEV. OF GROUP I
!     REAL SMIN
!        MINIMUM OF S(I)
!     REAL SMS
!        SLOPE MS
!     REAL SNC
!        SUM OF N(I) SQUARED
!     REAL SOS
!        SUM OF S(I) SQUARED
!     REAL SQB
!        SQRT BETWEEN MS / NZW
!     REAL SQMS
!        SQRT WITHIN MS / NZW
!     REAL SQOM
!        OMEGA HAT SQUARED
!     REAL SQT
!        SQRT TOTAL MS / NZW
!     REAL SRANK(NG)
!        THE SUM OF THE RANKS FOR THE OBSERVATIONS IN EACH GROUP
!     REAL SSF
!        S * SQRT(NG-1) * F
!     REAL SSS
!        SLOPE SS
!     REAL STATS(15)
!        VECTOR OF STATISTICS
!     REAL STMS
!        SQRT TOTAL MS
!     REAL SUM
!        INTERMIDIATE VALUE
!     REAL SWMS
!        SQRT WITHIN MS
!     REAL TAG(N)
!        VECTOR OF CLASSIFICATION VALUES - VALUES LESS THAN OR EQUAL
!        TO ZERO ARE IGNORED FOR ANALYSIS.  ON ENTERING TAG IS
!        SORTED SMALLEST TO LARGEST
!     REAL TIES
!        *
!     REAL TMEAN(NG)
!        THE MEAN OF EACH OF THE GROUPS
!     REAL TMS
!        TOTAL MS
!     REAL TSD(NG)
!        THE STANDARD DEVIATIONS OF EACH OF THE GROUPS (NOT THE
!        STANDARD DEVIATIONS OF THE MEANS)
!     REAL TSIZE(NG)
!        THE SIZE OF EACH OF THE DIFFERENT GROUPS
!     REAL TSS
!        TOTAL SS
!     REAL TVALUE(NG)
!        THE DIFFERENT POSITIVE (NON-ZERO) TAG VALUES ANALYZED, ORDERED
!        FROM SMALLEST TO LARGEST
!     REAL T1
!        T(.05,NG-1)
!     REAL T2
!        T(.05,NG-1)
!     REAL T3
!        T(.05,NZW-1)
!     REAL UMLC
!        UNGROUPED MODEL LOWER CONFIDENCE LIMIT FOR MEAN
!     REAL UMUC
!        UNGROUPED MODEL UPPER CONFIDENCE LIMIT FOR MEAN
!     REAL U1, U2
!        USED IN CALCULATING MANDEL APPROXIMATION
!     REAL VKW
!        U FOR KRUSKAL-WALLIS F
!     REAL VLS
!        LARGEST VARIANCE / SMALLEST VARIANCE
!     REAL V1, V2
!        USED IN CALCULATING MANDEL APPROXIMATION
!     REAL WMS
!        WITHIN MS
!     REAL WSS
!        WITHIN SS
!     REAL Y(N)
!        OBSERVATIONS TO BE ANALYZED, SORTED BY TAGS
!        Y(NZPNTR) IS THE FIRST ELEMENT WITH A NON-ZERO TAG
!     REAL YBMAX
!        MAXIMUM YBAR(I), WHERE YBAR(I) IS THE MEAN OF GROUP I
!     REAL YBMIN
!        MINIMUN YBAR(I)
!     REAL YMAX
!        MAXIMUM OBSERVATION
!     REAL YMIN
!        MINIMUM OBSERVATION
!
!     MACHINE DEPENDENT VARIABLE - FPLM
!
      data blank /' '/
      data low /'-'/
      data high /'+'/
!
      call iprint(iprt)
      fplm = r1mach(2)
      nzpntr = n - nzw + 1
      fnzw = nzw
!
!     ZERO WORK VECTORS
!
      do 10 i=1,ng
         tvalue(i) = 0.0_wp
         tsize(i) = 0.0_wp
         tmean(i) = 0.0_wp
         tsd(i) = 0.0_wp
         srank(i) = 0.0_wp
         gpmin(i) = 0.0_wp
         gpmax(i) = 0.0_wp
         b10(i) = 0.0_wp
   10 continue
!
      do 20 i=1,15
         stats(i) = 0.0_wp
   20 continue
!
      cc = 0.0_wp
      f = 0.0_wp
      dms = 0.0_wp
      bss = 0.0_wp
      wss = 0.0_wp
      hstat = 0.0_wp
      mf = 0.0_wp
      sc = 0.0_wp
      smax = 0.0_wp
      nne1 = 0
      snc = 0.0_wp
      sos = 0.0_wp
      sss = 0.0_wp
      sum = 0.0_wp
      ties = 0.0_wp
      tss = 0.0_wp
      smin = 0.0_wp
      sfrat = 0.0_wp
!
!     BEGIN COMPUTATIONS
!
!     COMPUTE RANKS
!
      call ranko(nzw, y(nzpntr), itemp, ranks, ties)
!
!     INITIALIZE FIRST ELEMENT BEFORE ENTERING LOOP
!
      tvalue(1) = tag(nzpntr)
      srank(1) = ranks(1)
      gpmin(1) = y(nzpntr)
      gpmax(1) = y(nzpntr)
      ymin = gpmin(1)
      ymax = gpmax(1)
      gm = y(nzpntr)
      ibar = 1.0_wp
      tmean(1) = y(nzpntr)
      tsize(1) = 1.0_wp
!
!     DETERMINE MEANS AND MAXS, DO SUMMATION PRIOR TO
!     DETERIMING MEANS
!     HERE J IS THE GROUP NUMBER
!
      j = 1
      l = nzpntr + 1
      do 50 i=l,n
         if (tag(i).eq.tag(i-1)) go to 40
!
!        NEW TAG GROUP
         j = j + 1
         tvalue(j) = tag(i)
         gpmin(j) = y(i)
         gpmax(j) = y(i)
   40    tsize(j) = tsize(j) + 1.0_wp
         tmean(j) = tmean(j) + y(i)
         gm = gm + y(i)
!
!     UNNECESSARY COMPUTATIONS IF PRINTED OUTPUT IS SUPRESSED
!
         if (nprt.eq.0) go to 50
         k = i + 1 - nzpntr
         srank(j) = srank(j) + ranks(k)
         gpmin(j) = min(gpmin(j),y(i))
         gpmax(j) = max(gpmax(j),y(i))
         ymin = min(ymin,gpmin(j))
         ymax = max(ymax,gpmax(j))
         ibar = ibar + j
   50 continue
!
!     CALCULATE MEANS
!
      gm = gm/fnzw
      ibar = ibar/fnzw
      k = nzpntr-1
      i = nzpntr
      do 70 j=1,ng
         if (tsize(j).ge.2.0_wp) then
            tmean(j) = tmean(j)/tsize(j)
         else
            tmean(j) = tmean(j)
         end if
         k = k + int(tsize(j))
!
!     L GIVES INDEX TO Y VALUE WITHIN GROUP J
!
         do 60 l=i,k
            ressq = (y(l)-tmean(j))*(y(l)-tmean(j))
            tsd(j) = tsd(j) + ressq
            if (nprt.eq.0) go to 60
            bss = bss + (tmean(j)-gm)*(tmean(j)-gm)
            wss = wss + ressq
            tss = tss + (y(l)-gm)*(y(l)-gm)
   60    continue
         i = k + 1
   70 continue
!
!     NOW DONE WITH TAG VECTOR, RETURN VECTOR TO INPUT ORDER
!     INDEX IS FREED FOR USE IN OTHER PLACES
!
      call srtrri(tag, y, n, index)
!
!     CHECK FOR PRINTED OUTPUT
!
      if (nprt.ne.0) go to 90
!
!     COMPUTE STANDARD DEVIATIONS WITHIN EACH GROUP
!
      do 80 j=1,ng
         tsd(j) = sqrt(tsd(j))
         if (tsize(j).le.1.0_wp) go to 80
         tsd(j) = tsd(j)/sqrt(tsize(j)-1.0_wp)
   80 continue
!
!     COMPUTATIONS COMPLETE FOR STORED OUTPUT - RETURN IF PRINTED
!     OUTPUT IS SUPRESSED
!
      return
   90 ybmin = tmean(1)
      ybmax = tmean(1)
      smin = fplm
!     HERE I IS THE GROUP NUMBER
      do 120 i=1,ng
         if (tsd(i).gt.0.0_wp) then
            b10(i) = tsize(i)*(tsize(i)-1.0_wp)/tsd(i)
            stats(1) = stats(1) + b10(i)*tmean(i)
            stats(2) = stats(2) + b10(i)
            if (tsize(i).gt.1.0_wp) then
               tsd(i) = sqrt(tsd(i)/(tsize(i)-1.0_wp))
            end if
            mf = mf + (tsize(i)-1.0_wp)*log(tsd(i)*tsd(i))
         end if
         if (nint(tsize(i)).ge.2) then
            nne1 = nne1 + 1
            smax = max(smax,tsd(i))
            smin = min(smin,tsd(i))
            stats(3) = stats(3) + 1.0_wp/(tsize(i)-1.0_wp)
         end if
         sss = sss + tsize(i)*(i-ibar)*(tmean(i)-gm)
         stats(4) = stats(4) + tsize(i)*(i-ibar)*(i-ibar)
!
!        LOOK FOR SMALLEST AND LARGEST MEANS (YBAR)
!
         ybmin = min(ybmin,tmean(i))
         ybmax = max(ybmax,tmean(i))
!
         hstat = hstat + srank(i)*srank(i)/tsize(i)
         sum = sum + 1.0_wp/tsize(i)
         stats(5) = stats(5) + (tmean(i)-gm)*(tmean(i)-gm)
         sos = sos + tsd(i)*tsd(i)
         snc = snc + tsize(i)*tsize(i)
         sc = sc + tsize(i)*tsize(i)*tsize(i)
  120 continue
      if (stats(2).ne.0.0_wp) stats(1) = stats(1)/stats(2)
      if (stats(4).ne.0.0_wp) sss = sss*sss/stats(4)
      dss = bss - sss
!
!     DEGREES OF FREEDOM FOR ANOVA
!
      g1 = ng-1
      m3 = ng - 2
      gr = nzw-ng
      m5 = nzw - 1
!
!     MEAN SQUARES
!
      bms = bss/g1
      sms = sss
      if (ng.ge.3) dms = dss/m3
      wms = wss/gr
      tms = tss/m5
      if (wms.eq.bms) then
         bfrat = 1.0_wp
         bfsig = 1.0_wp
      else if (wms.eq.0.0_wp) then
         bfrat = fplm
         bfsig = 0.0_wp
      else
         bfrat = bms/wms
         bfsig = 1.0_wp - cdff(bfrat,g1,gr)
      end if
      if (wms.eq.dms) then
         dfrat = 1.0_wp
         dfsig = 1.0_wp
      else if (wms.eq.0.0_wp) then
         dfrat = fplm
         dfsig = 0.0_wp
      else
         dfrat = dms/wms
         dfsig = 1.0_wp - cdff(dfrat,real(m3),real(nzw-2))
      end if
      if (sms.eq.dss+wss) then
         sfrat = 1.0_wp
         sfsig = 1.0_wp
      else if (dss+wss.eq.0.0_wp) then
         sfrat = fplm
         sfsig = 0.0_wp
      else
         sfrat = sms/((dss+wss)/(fnzw-2.0_wp))
         sfsig = 1.0_wp - cdff(sfrat,1.0_wp,gr)
      end if
!
!     COMPUTE FOR KRUSKAL-WALLIS TEST
!     FOR FORMULAE WITH CLEARER FORM AND NAMES SEE
!     KRAFT AND VAN EEDEN  A NON PARAMETRIC INTRODUCTION TO STATISTICS,
!     PP. 238 - 240
!
      stats(6) = nzw*(nzw+1)
      hstat = (12.0_wp*hstat/stats(6)) - (3.0_wp*(nzw+1))
      if (ties.eq.nzw*nzw*nzw-nzw) then
         cfkw = 0.0_wp
         hstat = 0.0_wp
         mkw = 0.0_wp
      else
         cfkw = 1.0_wp - ties/(nzw*nzw*nzw-nzw)
         hstat = hstat/cfkw
         mkw = ((nzw*nzw*nzw-sc)/stats(6))/cfkw
      end if
     vkw = 2.0_wp*g1 -&
    &   (0.4_wp*(3*ng*m3+nzw*(2*ng*(ng-3)+1)))/stats(6)&
     &   - 6.0_wp*sum/5.0_wp
     if (mkw-hstat.gt.0.0_wp .and.&
     &    mkw.ne.0.0_wp .and. vkw.ne.0.0_wp) then
         f1kw = (g1*(g1*(mkw-g1)-vkw))/(0.5_wp*vkw*mkw)
         f2kw = (mkw-g1)*f1kw/g1
         fstat = (hstat*(mkw-g1))/(g1*(mkw-hstat))
         sigkw = 1.0_wp - cdff(fstat,anint(f1kw),anint(f2kw))
      else
         sigkw = 0.0_wp
      end if
!
!     COMPUTE TOTAL STATISTICS
!
      swms = sqrt(wms)
      sbms = sqrt(stats(5)/g1)
      stms = sqrt(tms)
      sqms = swms/(sqrt(fnzw))
      sqb = sbms/(sqrt(real(ng)))
      sqt = stms/(sqrt(fnzw))
      t1 = ppft(0.975_wp,int(gr))
      t2 = ppft(0.975_wp,int(g1))
      t3 = ppft(0.975_wp,m5)
      fmlc = gm - sqms*t1
      rmlc = gm - sqb*t2
      umlc = gm - sqt*t3
      fmuc = gm + sqms*t1
      rmuc = gm + sqb*t2
      umuc = gm + sqt*t3
!
      ssf = swms*sqrt(g1*ppff(0.95_wp,int(g1),int(gr)))
!
!     TESTS FOR HOMOGENEITY OF VARIANCES
!
      if (smax*smax.eq.sos) then
         cc = 1.0_wp
      else if (sos.ne.0.0_wp) then
         cc = smax*smax/sos
      end if
      stats(7) = anint(fnzw/ng)
      if ((nne1.ge.2) .and. (cc.ne.1.0_wp)) then
        slcc = 1.0_wp -&
    &          cdff((nne1-1)*cc/(1.0_wp-cc),stats(7),&
     &          stats(7)*(nne1-1))
      else
         slcc = 1.0_wp
      end if
      slcc = (nne1-1)*slcc
      if (slcc.gt.1.0_wp) slcc = 1.0_wp
!
      if (smin.eq.smax) then
         vls = 1.0_wp
      else
         if (smin.eq.0.0_wp) then
            vls = fplm
         else
            vls = (smax/smin)*(smax/smin)
         end if
      end if
      if (wms.gt.0.0_wp) mf = gr*log(wms) - mf
      af = (stats(3)-(1.0_wp/gr))/(3.0_wp*g1)
      slbf = 1.0_wp
      if ((af.ne.1.0_wp) .and. (nne1.ge.2)) then
         df = (nne1+1)/(af*af)
         bf = (df*mf)/((nne1-1)*(df/(1.0_wp-af+(2.0_wp/df))-mf))
         if (bf.lt.0.0_wp) bf = 0.0_wp
         slbf = 1.0_wp - cdff(bf,real(nne1-1),anint(df))
      else
         bf = fplm
      end if
      k0 = (fnzw-(snc/fnzw))/g1
      sqom = (bms-wms)/k0
!
!     COMPUTATIONS ARE NOW COMPLETE ************************************
!
!     PRINT ANOVA
!
      nn = n - nzw
      write (iprt,1000) nn
      nn = ng - 1
      write (iprt,1010) nn, bss, bms, bfrat, bfsig
      if (ng.lt.3) go to 180
      if (bfsig.ge..10) go to 180
      nn = 1
      write (iprt,1020) nn, sss, sms, sfrat, sfsig
      write (iprt,1030) m3, dss, dms, dfrat, dfsig
  180 nn = nzw - ng
      write (iprt,1040) nn, wss, wms
      write (iprt,1050) m5, tss
!
!     PRINT KRUSKAL-WALLIS TEST
!
      write (iprt,1060) hstat, sigkw
!
!     PRINT ESTIMATES
!
      write (iprt,1070)
      do 200 i=1,ng
         mean = blank
         if (tmean(i).le.ybmin) mean = low
         if (tmean(i).ge.ybmax) mean = high
         isd = blank
         if (tsd(i).le.smin) isd = low
         if (tsd(i).ge.smax) isd = high
         isz = int(tsize(i))
         if (isz.le.1) then
           write (iprt,1090) tvalue(i), isz, tmean(i), mean, gpmin(i),&
     &         gpmax(i), srank(i)
         else
            stats(9) = tsd(i)/sqrt(tsize(i))
            stats(10) = ppft(0.975_wp,isz-1)
            stats(8) = tmean(i) - stats(9)*stats(10)
            stats(11) = tmean(i) + stats(9)*stats(10)
           write (iprt,1080) tvalue(i), isz, tmean(i), mean, tsd(i),&
    &                        isd, stats(9), gpmin(i), gpmax(i),&
     &                        srank(i), stats(8), stats(11)
         end if
  200 continue
     write (iprt,1100) nzw, gm, ymin, ymax, swms, sqms, fmlc, fmuc,&
     &   sbms, sqb, rmlc, rmuc, stms, sqt, umlc, umuc
      if (bfsig.lt.0.10) then
!
!     SORT YBAR FOR MULTIPLE COMPARISIONS OF MEANS
!
         call geni(index, ng, 1, 1)
         call srtir(index, ng, tmean)
!
!     COMPUTE AND PRINT FOR MULTIPLE COMPARISIONS
!
         if (nzw-ng.lt.4) go to 270
         write (iprt,1110)
!
!     NEWMAN-KEULS-HARTLEY
!
         write (iprt,1120)
         rx = -.283917_wp + 2.63532_wp*(gr-1.00123_wp)**(-.95862_wp)
         u1 = -.314115_wp + 2.38301_wp*(gr-1.03428_wp)**(-.864005_wp)
         u2 = 3.65961_wp*u1**2 - 1.00891_wp*u1 - 0.166346_wp
         j = 1
         m28 = 0
  210    i = ng
  220    if (i.le.m28) go to 260
         if (i.eq.j) go to 230
         stats(14) = abs(tmean(i)-tmean(j))
!
!     MANDEL APPROXIMATION TO PERCENT POINT OF STUDENTIZED RANGE
!
         stats(12) = i-j+1
        c = 2.3849867_wp -&
     &       2.9051857_wp*(stats(12)-0.57583164_wp)**(-.069648109_wp)
        v1 = 1.30153_wp -&
     &        1.95073_wp*(stats(12)+.394915_wp)**(-.139783_wp)
         v2 = 4.72863_wp*v1**2 + 0.404271_wp*v1 - 0.135104_wp
        stats(13) = 6.15075_wp + 4.441409_wp*rx +&
    &               6.7514569_wp*c + 7.4671282_wp*u1*v1 -&
     &               0.157537_wp*u2*v2
         kk = index(i)
         kkk = index(j)
        stats(13) = stats(13)*&
    &            sqrt(0.5_wp*((1.0_wp/tsize(kk))+(1.0_wp/tsize(kkk))))*&
     &            swms
         if (stats(14).le.stats(13)) go to 230
         i = i - 1
         go to 220
  230    if (j.eq.1) go to 250
         if (j.gt.m28) go to 240
         write (iprt,1150)
         go to 250
  240    write (iprt,1160)
  250    write (iprt,1140) (tmean(m),m=j,i)
         if (i.ge.ng) go to 270
         m28 = i
  260    j = j + 1
         go to 210
!
!     SCHEFFE METHOD
!
  270    write (iprt,1130)
         j = 1
         m28 = 0
  280    i = ng
  290    if (i.le.m28) go to 330
         if (i.eq.j) go to 300
         kk = index(i)
         kkk = index(j)
         stats(14) = abs(tmean(i)-tmean(j))
         stats(13) = ssf*sqrt((1.0_wp/tsize(kk))+(1./tsize(kkk)))
         if (stats(14)-stats(13).le.0.0_wp) go to 300
         i = i - 1
         go to 290
  300    if (j.eq.1) go to 320
         if (j.gt.m28) go to 310
         write (iprt,1150)
         go to 320
  310    write (iprt,1160)
  320    write (iprt,1140) (tmean(m),m=j,i)
         if (i.ge.ng) go to 340
         m28 = i
  330    j = j + 1
         go to 280
!
!     RETURN TAG MEANS TO ORIGINAL ORDER
!
  340    call srtri(tmean, ng, index)
      end if
!
      if (nne1.le.1) return
      write (iprt,1170) cc, slcc, bf, slbf, vls
      if (slcc.gt.0.1_wp .and. slbf.gt.0.1_wp) go to 390
      do 360 i=1,ng
         f = f + b10(i)*(tmean(i)-stats(1))*(tmean(i)-stats(1))
         if (stats(2).eq.0.0_wp .or. tsize(i).le.1.0_wp) go to 360
        stats(15) = stats(15) +&
    &               (1.0_wp-b10(i)*b10(i)/stats(2)/stats(2))/&
     &               (tsize(i)-1.0_wp)
  360 continue
      if (stats(15).eq.0.0_wp) go to 370
      stats(15) = (ng*ng-1.0_wp)/(3.0_wp*stats(15))
      if (ng.le.1) go to 370
      f = (f/g1)/(1.0_wp+(2.0_wp*m3/(3.0_wp*stats(15))))
      go to 380
  370 f = 0.0_wp
  380 q = 1.0_wp - cdff(f,g1,anint(stats(15)))
      write (iprt,1180) f, q
  390 write (iprt,1190) sqom
      return
!
!     AUTOMATIC PRINTOUT IS FINISHED
!
!     FORMAT STATEMENTS
!
1000 format(54h *group numbers have been assigned according to tag va,&
    &   59hlues given, where the smallest tag greater than zero has be,&
    &   14hen assigned  */41h *group number 1, the next smallest, grou,&
    &   59hp number 2, etc.  tags less than or equal to zero have not ,&
    &   27hbeen included in analysis.*/28h *number of values excluded ,&
    &   17hfrom analysis is , i4, 77x, 1h*//17x, 6hsource, 14x, 4hd.f.,&
    &   4x, 14hsum of squares, 5x, 12hmean squares, 9x, 7hf ratio, 4x,&
     &   7hf prob./)
1010 format(17x, 14hbetween groups, 5x, i4, 1p2e18.6, 4x, 0pe11.3,&
     &   f10.3)
 1020 format(20x, 5hslope, 14x, i4, 1p2e18.6, 3x, 0pe11.3, f10.3)
1030 format(20x, 16hdevs. about line, 3x, i4, 1p2e18.6, 3x, 0pe11.3,&
     &   f10.3)
 1040 format(17x, 13hwithin groups, 6x, i4, 1p2e18.6)
 1050 format(17x, 5htotal, 14x, i4, 1pe18.6//)
1060 format(11x, 49hkruskal-wallis rank test for difference between g,&
    &   16hroup means * h =, e11.3, 10h, f prob =, f6.3, 10h (approx.)&
     &   /)
1070 format(55x, 9hestimates/96x, 6hsum of/5x, 5h tag , 10x, 3hno.,&
    &   6x, 4hmean, 7x, 11hwithin s.d., 2x, 12hs.d. of mean, 5x,&
    &   7hminimum, 7x, 7hmaximum, 6x, 5hranks, 3x, 16h95pct conf int f,&
     &   7hor mean/)
1080 format(1x, 1pe14.6, i8, e14.5, a1, e13.5, a1, e13.5, 2e14.5,&
     &   0pf9.1, 1pe13.5, 3h to, e12.5)
1090 format(1x, 1pe14.6, i8, e14.5, a1, 3x, 23h estimate not available,&
     &   ' ', 2e14.5, 0pf9.1, 3x, 25h********** to ********** )
1100 format(/11x, 5htotal, i7, 1pe14.5, 28x, 2e14.5//&
    &   17x, 20hfixed effects model , 2e14.5, 37x, e13.5, 3h to, e12.5/&
    &   17x, 7hrandom ,&
    &   13heffects model, 2e14.5, 37x, e13.5, 3h to, e12.5/17x,&
     &   14hungrouped data, 6x, 2e14.5, 37x, e13.5, 3h to, e12.5/)
1110 format(1x, 50hpairwise multiple comparison of means.  the means ,&
    &   59hare put in increasing order in groups separated by *****.  ,&
    &   11ha mean is  /44h adjudged non-significantly different from a,&
    &   59hny mean in the same group and significantly different at th,&
    &   17he .05 level from /38h any mean in another group.  ***** ***,&
    &   59h** indicates adjacent groups have no common mean.          ,&
     &   23h                       )
1120 format(/3x, 49hnewman-keuls technique, hartley modification. (ap,&
     &   40hproximate if group numbers are unequal.))
 1130 format(/3x, 18hscheffe technique.)
 1140 format(3x, 9(1pe12.5, ','))
 1150 format(6x, 5h*****)
 1160 format(3x, 11h***** *****)
1170 format(/36h tests for homogeneity of variances./7x, 9hcochrans ,&
    &   35hc = max. variance/sum(variances) = , f7.4, 6h, p = , f6.3,&
    &   10h (approx.)/7x, 17hbartlett-box f = , f9.3, 6h, p = ,&
     &   f6.3/7x, 38hmaximum variance / minimum variance = , f14.4)
1180 format(7x, 50happrox between means f-test in presence of heterog,&
     &   20heneous variance. f =, f8.3, 5h, p =, f6.3)
1190 format(/35h model ii - components of variance./7x, 10hestimate o,&
     &   20hf between component , 1pe14.6)
      end
!DCKOUT
     subroutine dckout(xm, ixm, n, m, nrow, neta, ntau, npar, msg,&
    &   lmsg, par, scale, lscale, hdr, page, wide, isubhd, prtfxd,&
     &   ifixd)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRINTS THE RESULTS OF THE DERIVATIVE CHECKING
!     SUBROUTINE
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   isubhd,ixm,lmsg,lscale,m,n,neta,npar,nrow,ntau
     logical&
     &   page,prtfxd,wide
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),scale(lscale),xm(ixm,m)
     integer&
     &   ifixd(npar),msg(lmsg)
!
!  SUBROUTINE ARGUMENTS
       external hdr
!
!  LOCAL SCALARS
     integer&
     &   i,imax,imin,index,iprt,j,k,nperl
     character&
     &   blank*1
!
!  LOCAL ARRAYS
     logical&
     &   ftnote(6)
     character&
     &   fixed(3)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL FIXPRT,IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic min
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     CHARACTER*1 BLANK
!        THE CHARACTER BLANK.
!     CHARACTER*1 FIXED(3)
!        THE CHARACTERS USED TO LABEL THE PARAMETERS FIXED OR NOT.
!     LOGICAL FTNOTE(6)
!        THE ARRAY WHICH CONTROLS PRINTING OF FOOTNOTES.
!     EXTERNAL HDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXD(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXD(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER IMAX, IMIN
!        THE LARGEST AND SMALLEST INDEX VALUE TO BE PRINTED ON EACH
!        LINE.
!     INTEGER INDEX
!        THE INDEX VALUE TO BE PRINTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED BY
!        ROUTINE HDR.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER LMSG
!        THE LENGTH OF THE VECTOR MSG.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MSG(LMSG)
!        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPERL
!        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        APPROXIMATED DERIVATIVES AND THE USER-SUPPLIED DERIVATIVES.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     LOGICAL WIDE
!       THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!
      data blank /' '/
!
      call iprint(iprt)
!
!     INITIALIZE ARRAY FIXED
!
      do 10 k=1,3
         fixed(k) = blank
   10 continue
!
      call hdr(page, wide, isubhd)
!
!     SET UP FOR FOOTNOTES
!
      do 20 i=1,6
         ftnote(i) = .false.
   20 continue
!
      if (msg(1).le.0) go to 40
!
      do 30 i=1,npar
         if ((msg(i+1).eq.0) .or. (msg(i+1).eq.2)) go to 30
         k = msg(i+1) - 2
         if (k.eq.-1) k = 5
         ftnote(1) = .true.
         ftnote(k+1) = .true.
   30 continue
!
!     PRINT REPORT
!
   40 continue
!
      write (iprt,1000)
      if (ftnote(1)) write (iprt,1040)
      if (prtfxd) write (iprt,1160)
      if (.not.prtfxd) write (iprt,1170)
!
      if (scale(1).le.0.0e0) go to 60
!
      do 50 i=1,npar
         if (prtfxd) call fixprt(ifixd(i), fixed)
         k = msg(i+1) - 2
         if (k.eq.-1) k = 5
        if (k.eq.-2) write (iprt,1010) i, (fixed(j),j=1,3), par(i),&
     &      scale(i)
        if (k.eq.0) write (iprt,1020) i, (fixed(j),j=1,3), par(i),&
     &      scale(i)
        if (k.ge.1) write (iprt,1030) i, (fixed(j),j=1,3), par(i),&
     &      scale(i), k
   50 continue
      go to 80
!
   60 continue
!
      do 70 i=1,npar
         if (prtfxd) call fixprt(ifixd(i), fixed)
         k = msg(i+1) - 2
         if (k.eq.-1) k = 5
         if (k.eq.-2) write (iprt,1180) i, (fixed(j),j=1,3), par(i)
         if (k.eq.0) write (iprt,1190) i, (fixed(j),j=1,3), par(i)
         if (k.ge.1) write (iprt,1200) i, (fixed(j),j=1,3), par(i), k
   70 continue
!
   80 continue
!
!     PRINT FOOTNOTES
!
      if (.not.ftnote(1)) go to 90
!
      write (iprt,1060)
      if (ftnote(2)) write (iprt,1070)
      if (ftnote(3)) write (iprt,1080)
      if (ftnote(4)) write (iprt,1090)
      if (ftnote(5)) write (iprt,1100)
      if (ftnote(6)) write (iprt,1050)
!
   90 continue
!
      write (iprt,1110) neta
      write (iprt,1120) ntau
!
!     PRINT OUT ROW OF INDEPENDENT VARIABLE WHICH WAS CHECKED.
!
      write (iprt,1130) nrow
      nperl = 7
!
      do 100 i=1,m,nperl
         imin = i
         imax = min(i+nperl-1,m)
         write (iprt,1140) (index,index=imin,imax)
         write (iprt,1150) (xm(nrow,index),index=imin,imax)
  100 continue
      write (iprt,1210) n
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (//)
 1010 format (1x, i3, 5x, 3a1, 2g17.8, 10x, 2hok)
 1020 format (1x, i3, 5x, 3a1, 2g17.8, 7x, 9hincorrect)
 1030 format (1x, i3, 5x, 3a1, 2g17.8, 5x, 14hquestionable (, i1, ')')
 1040 format (62x, 1h*)
1050 format (/48h  (5) user-supplied and approximated derivatives,&
    &   14h disagree, but/5x, 37h approximated derivative is questiona,&
    &   11hble because, 6h ratio/5x, 30h of relative curvature to rela,&
     &   17htive slope is too, 6h high.)
1060 format (/53h * numbers in parentheses refer to the following note,&
     &   2hs.)
1070 format (/48h  (1) user-supplied and approximated derivatives,&
     &   11h agree, but/5x, 40h both are zero.  recheck at another row.)
1080 format (/48h  (2) user-supplied and approximated derivatives,&
    &   15h may agree, but/5x, 36h user-supplied derivative is identic,&
    &   9hally zero, 17h and approximated/5x, 21h derivative is only a,&
     &   18hpproximately zero., 25h  recheck at another row.)
1090 format (/48h  (3) user-supplied and approximated derivatives,&
    &   14h disagree, but/5x, 37h user-supplied derivative is identica,&
     &   9hlly zero., 12h  recheck at/5x, 13h another row.)
1100 format (/48h  (4) user-supplied and approximated derivatives,&
    &   14h disagree, but/5x, 37h approximated derivative is questiona,&
    &   11hble because, 13h either ratio/5x, 22h of relative curvature,&
    &   25h to relative slope is too, 9h high, or/5x, 13h scale(k) is ,&
     &   6hwrong.)
1110 format (/43h number of reliable digits in model results, 25x,&
     &   6h(neta), 1x, i5)
1120 format (/40h number of digits in derivative checking, 9h agreemen,&
     &   11ht tolerance, 8x, 6h(ntau), 1x, i5)
1130 format (/45h row number at which derivatives were checked, 23x,&
    &   6h(nrow), 1x, i5/42h   -values of the independent variables at,&
     &   9h this row)
 1140 format (10x, 5hindex, i5, 6i15)
 1150 format (10x, 5hvalue, 7(1x, g14.7)/)
1160 format (52x, 10hderivative/7x, 24hparameter starting value, 6x,&
    &   5hscale, 10x, 10hassessment/1x, 5hindex, 2x, 5hfixed, 6x,&
     &   5h(par), 12x, 7h(scale)/)
1170 format (17x, 9hparameter, 26x, 10hderivative/15x, 12hstarting val,&
    &   2hue, 8x, 5hscale, 10x, 10hassessment/1x, 5hindex, 13x,&
     &   5h(par), 12x, 7h(scale)/)
 1180 format (1x, i3, 5x, 3a1, g17.8, 7x, 7hdefault, 13x, 2hok)
 1190 format (1x, i3, 5x, 3a1, g17.8, 7x, 7hdefault, 10x, 9hincorrect)
1200 format (1x, i3, 5x, 3a1, g17.8, 7x, 7hdefault, 8x, 11hquestionabl,&
     &   3he (, i1, ')')
 1210 format (/23h number of observations, 48x, 3h(n), 1x, i5)
      end
!STPCNT
     subroutine stpcnt(xm, n, m, ixm, mdl, par, npar, stp,&
    &   exmpt, neta, scale, lscale, nprt, hdr, page, wide, isubhd,&
     &   hlfrpt, prtfxd, ifixed, lifixd)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CONTROLS THE STEP SIZE SELECTION PROCESS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   exmpt
     integer&
     &   isubhd,ixm,lifixd,lscale,m,n,neta,npar,nprt
     logical&
     &   hlfrpt,page,prtfxd,wide
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),scale(lscale),stp(npar),xm(ixm,m)
     integer&
     &   ifixed(lifixd)
!
!  SUBROUTINE ARGUMENTS
       external hdr,mdl
!
!  SCALARS IN COMMON
     real(kind=wp) ::&
     &   q
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   eta,exm,fplrs,scl,tau
     integer&
    &   cd,fd,fdlast,fdsave,ifailj,ifixd,ifp,itemp,j,mxfail,nall0,&
    &   ndd,ndgt1,nexmpt,nfail,nfailj,partmp,pv,pvmcd,pvnew,pvpcd,&
     &   pvstp,pvtemp
     logical&
     &   head
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
     integer&
     &   stkst
!       EXTERNAL R1MACH,STKST
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL CPYVII,ETAMDL,SETIV,STKCLR,STPMN,STPOUT
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,int,log10,max,min
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
      common /notopt/q
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CD
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE CENTRAL DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL ETA
!        THE RELATIVE NOISE IN THE MODEL
!     REAL EXM
!        THE PROPORTION OF OBSERVATIONS ACTUALLY USED FOR WHICH THE
!        COMPUTED NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE
!        EXEMPTED FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     REAL EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DRVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     INTEGER FD
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
!     INTEGER FDLAST
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!        FOR THE LAST STEP SIZE TRIED.
!     INTEGER FDSAVE
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!        FOR THE BEST STEP SIZE TRIED SO FAR.
!     REAL FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     EXTERNAL HDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE STEP SIZE SELECTION
!        ROUTINE HAS ALREADY PRINTED PART OF THE INITIAL SUMMARY (TRUE)
!        OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFAILJ
!        THE STARTING LOCATION IN ISTAK FOR
!        THE ARRAY OF INDICATOR VARIABLES DESIGNATING WHETHER
!        THE SETP SIZE SELECTED WAS SATISFACOTRY FOR A GIVEN
!        OBSERVATION AND THE JTH PARAMETER.
!     INTEGER IFIXD
!        THE STARTING LOCATION IN ISTAK OF
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER ITEMP
!        THE STARTING LOCATION IN ISTAK FOR
!        A TEMPORARY STORAGE VECTOR.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER LIFIXD
!        THE LENGTH OF THE VECTOR IFIXED.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER MXFAIL
!        THE MAXIMUM NUMBER OF FAILURES FOR ANY PARAMETER.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
!     INTEGER NDD
!        THE NUMBER OF DECIMAL DIGITS CARRIED FOR A REAL
!        NUMBERS.
!     INTEGER NDGT1
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL USED, EITHER
!        SET TO THE USER SUPPLIED VALUE OF NETA, OR COMPUTED
!        BY ETAMDL.
!     INTEGER NETA
!        THE USER SUPPLIED NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NEXMPT
!        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
!        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
!        SIZE STILL BE CONSIDERED OK.
!     INTEGER NFAIL
!        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP SIZE
!        FOR THE PARAMETER DOES NOT MEET THE CRITERIA.
!     INTEGER NFAILJ
!        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP SIZE
!        FOR THE JTH PARAMETER DOES NOT MEET THE CRITERIA.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     INTEGER PARTMP
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE MODIFIED MODEL PARAMETERS
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     INTEGER PV
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     INTEGER PVMCD
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     INTEGER PVNEW
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPNEW.
!     INTEGER PVPCD
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCD.
!     INTEGER PVSTP
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STP(J).
!     INTEGER PVTEMP
!        THE STARTING LOCATION IN THE WORK AREA OF
!        A TEMPORY STORAGE LOCATION FOR PREDICTED VALUES BEGINS.
!     REAL Q
!        A DUMMY VARIABLE WHICH IS USED, ALONG WITH COMMON NOTOPT (NO
!        OPTIMIZATION), TO COMPUTE THE STEP SIZE.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SCL
!        THE ACTUAL TYPICAL SIZE USED.
!     REAL STP(NPAR)
!        THE SELECTED STEP SIZES.
!     REAL TAU
!        THE AGREEMENT TOLERANCE.
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
!
      nall0 = stkst(1)
!
      fplrs = r1mach(4)
      ifp = 3
!
!     SET PRINT CONTROLS
!
      head = .true.
!
!     SUBDIVIDE WORK AREA
!
      ifixd = stkget(npar, 2)
      itemp = stkget(n, 2)
      ifailj = stkget(n, 2)
      nfail = stkget(npar, 2)
!
      cd = stkget(max(n,npar), ifp)
      fd = stkget(n, ifp)
      fdlast = stkget(n, ifp)
      fdsave = stkget(n, ifp)
      pv = stkget(n, ifp)
      pvmcd = stkget(n, ifp)
      pvnew = stkget(n, ifp)
      pvpcd = stkget(n, ifp)
      pvstp = stkget(n, ifp)
      pvtemp = stkget(n, ifp)
!
      if (ierr .eq. 1) return
!
      partmp = cd
!
!     SET UP IFIXD
!
      if (ifixed(1).lt.0) then
         call setiv(istak(ifixd), npar, 0)
      else
         call cpyvii(npar, ifixed, 1, istak(ifixd), 1)
      end if
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      ndd = int(-log10(fplrs))
!
      if ((neta.ge.2) .and. (neta.le.ndd)) then
         eta = 10.0e0 ** (-neta)
         ndgt1 = neta
      else
        call etamdl(mdl, par, npar, xm, n, m, ixm, eta, ndgt1,&
     &               rstak(partmp), rstak(pvtemp), 0)
      end if
!
      tau = min(eta ** (0.25e0), 0.01e0)
!
      exm = exmpt
      if ((exm.lt.0.0e0) .or. (exm.gt.1.0e0)) exm = 0.10e0
      nexmpt = exm * n
      if (exm .ne. 0.0e0) nexmpt = max(nexmpt, 1)
!
!     COMPUTE PREDICTED VALUES OF THE MODEL USING THE INPUT PARAMETER
!     ESTIMATES
!
      call mdl(par, npar, xm, n, m, ixm, rstak(pv))
!
      mxfail = 0
      nfailj = nfail
!
      do 120 j = 1, npar
         if (istak(ifixd-1+j).eq.0) then
            if (scale(1).le.0.0e0) then
               if (par(j).eq.0.0e0) then
                  scl = 1.0e0
               else
                  scl = abs(par(j))
               end if
            else
               scl = scale(j)
            end if
!
           call stpmn(j, xm, n, m, ixm, mdl, par, npar, nexmpt,&
    &         eta, tau, scl, stp(j), istak(nfailj), istak(ifailj),&
    &         rstak(cd), istak(itemp), rstak(fd), rstak(fdlast),&
    &         rstak(fdsave), rstak(pv), rstak(pvmcd), rstak(pvnew),&
     &         rstak(pvpcd), rstak(pvstp), rstak(pvtemp))
!
!     COMPUTE THE MAXIMUM NUMBER OF FAILURES FOR ANY PARAMETER
!
            mxfail = max(istak(nfailj), mxfail)
!
         else
            stp(j) = 0.0
         end if
!
!     PRINT RESULTS IF THEY ARE DESIRED
!
        if ((nprt.ne.0) .or. (mxfail.gt.nexmpt))&
    &      call stpout(head, n, exm, nexmpt, ndgt1, j, par, npar,&
    &            stp, istak(nfail), istak(ifailj), scale,  lscale, hdr,&
     &            page, wide, isubhd, nprt, prtfxd, istak(ifixd))
         nfailj = nfailj + 1
  120 continue
!
      hlfrpt = .false.
      if ((nprt.ne.0) .or. (mxfail.gt.nexmpt)) hlfrpt = .true.
!
      if (mxfail.gt.nexmpt) ierr = 2
!
      call stkclr(nall0)
!
      return
!
      end
!GFARF
      subroutine gfarf (phi, iar)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE TO COMPUTE THE GAIN
!     FUNCTION OF AN AUTOREGRESSIVE FILTER (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   phi(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,fmax,fmin,ypltmn,ypltmx
     integer&
     &   igferr,iprt,nf,nord,nprt
     logical&
     &   err01,head,sym
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   freq(101),gain(101),phas(101),xord(101),yord(101)
     integer&
     &   isort(101)
     character&
     &   liar(8)*1,nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,GFAEST,GFORD,GFOUT,IPRINT,SETFRQ
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     LOGICAL ERR01
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     REAL FMAX, FMIN
!        THE MINIMUM AND MAXIMUM FREQUENCY FOR WHICH THE GAIN
!        FUNCTION IS TO BE ESTIMATED.
!     REAL FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        HAS BEEN ESTIMATED.
!     REAL GAIN(101)
!        THE VECTOR IN WHICH THE GAIN FUNCTION ESTIMATES ARE
!        STORED.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IGFERR
!        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
!        TO HAVE PRODUCED REASONABLE RESULTS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     CHARACTER*1 LIAR(8)
!        THE ARRAY CONTAINING THE NAME OF THE VARIABLE IAR.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        IS TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NORD
!        THE NUMBER OF VALUES TO BE PLOTTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     REAL PHAS(101)
!        THE ARRAY IN WHICH THE PHASE OF THE FILTER IS RETURNED.
!     REAL PHI(IAR)
!        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
!     LOGICAL SYM
!        THE VARIABLE USED TO INDICATE WHETHER THE GAIN FUNCTION
!        COMPUTED WAS FOR A SYMMETRIC OR AUTOREGRESSIVE FILTER.
!     REAL XORD(101)
!        THE X COORDINATES FOR THE GAIN FUNCTION PLOT
!     REAL YORD(101)
!        THE Y COORDINATES FOR THE GAIN FUNCTION PLOT
!     REAL YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'G',       'F',       'A',       'R',       'F',       ' '/
     data&
    &  liar(1), liar(2), liar(3), liar(4), liar(5), liar(6), liar(7),&
    &  liar(8)&
     & /  'I',   'A',   'R',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, liar, iar, 1, 1, head, err01, liar)
!
      if (.not. err01) go to 10
!
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   10 continue
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      sym = .false.
!
      nf = 101
!
      fmin = 0.0e0
      fmax = 0.5e0
!
      delta = 1.0e0
!
      nprt = -1
!
!     SET FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO BE ESTIMATED
!
      call setfrq (freq, nf, nprt, fmin, fmax, delta)
!
!     COMPUTE THE GAIN FUNCTION
!
      call gfaest (phi, iar, nf, freq, gain, phas, delta)
!
!     SET THE COORDINATES FOR THE PLOT.
!
     call gford (freq, gain, isort, nf, xord, yord, nord,&
     &   ypltmn, ypltmx, nprt, igferr)
!
!     PLOT THE RESULTS.
!
     call gfout (xord, yord, nord, freq, phas, nf, iar, sym, fmin,&
     &   fmax, ypltmn, ypltmx, nprt, igferr, nmsub)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   28h       call gfarf (phi, iar))
      end
!UASER
     subroutine uaser(nmsub, n, acov, iar, phi, lagmax, lag, lacov,&
     &   nf, ldstak, ldsmin, lyfft, nfft, option)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE ERROR CHECKING ROUTINE FOR THE TIME SERIES
!     FOURIER UNIVARIATE SPECTRUM ANALYSIS ROUTINES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985  (JRD)
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iar,lacov,lag,lagmax,ldsmin,ldstak,lyfft,n,nf,nfft
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(*),phi(*)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   i,nv
     logical&
     &   head
!
!  LOCAL ARRAYS
     logical&
     &   err(20)
     character&
    &   l1(8)*1,lacv(8)*1,lacv1m(8)*1,lacv1p(8)*1,liar(8)*1,&
    &   llacov(8)*1,llag(8)*1,llds(8)*1,llgmx(8)*1,llgmx1(8)*1,&
    &   llgmxm(8)*1,llgmxp(8)*1,llyfft(8)*1,ln(8)*1,lnf(8)*1,&
     &   lnm1(8)*1,lphi(8)*1
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL EISGE,EISII,ERVII
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,iabs
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV)
!        THE AUTOCOVARIANCE FUNCTION.
!     LOGICAL ERR(20)
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF ERR01, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     CHARACTER*1 LACV(8), LACV1M(8), LACV1P(8),
!    *   LIAR(8), LLACOV(8), LLAG(8), LLGMX(8), LLGMXM(8),
!    *   LLGMXP(8),  LLGMX1(8), LLDS(8), LN(8), LNF(8), LNM1(8),
!    *   LLYFFT(8), LPHI(8), L1(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE ARGUMENT(S)
!        CHECKED FOR ERRORS.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THE USER CALLED SUBROUTINE.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND WHEN CHECKING VECTOR LAGS.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     REAL PHI(IAR)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!
!
!     SET UP NAME ARRAYS
!
     data lacv(1), lacv(2), lacv(3), lacv(4), lacv(5), lacv(6),&
     &   lacv(7), lacv(8) /'A','C','O','V',' ',' ',' ',' '/
     data lacv1m(1), lacv1m(2), lacv1m(3), lacv1m(4), lacv1m(5),&
    &   lacv1m(6), lacv1m(7), lacv1m(8) /'-','A','C','O','V','(','1',&
     &   ')'/
     data lacv1p(1), lacv1p(2), lacv1p(3), lacv1p(4), lacv1p(5),&
    &   lacv1p(6), lacv1p(7), lacv1p(8) /'+','A','C','O','V','(','1',&
     &   ')'/
     data liar(1), liar(2), liar(3), liar(4), liar(5),&
    &   liar(6), liar(7), liar(8) /'I','A','R',' ',' ',' ',' ',&
     &   ' '/
     data llacov(1), llacov(2), llacov(3), llacov(4), llacov(5),&
    &   llacov(6), llacov(7), llacov(8) /'L','A','C','O','V',' ',' ',&
     &   ' '/
     data llag(1), llag(2), llag(3), llag(4), llag(5), llag(6),&
     &   llag(7), llag(8) /'L','A','G',' ',' ',' ',' ',' '/
     data llgmx(1), llgmx(2), llgmx(3), llgmx(4), llgmx(5),&
    &   llgmx(6), llgmx(7), llgmx(8) /'L','A','G','M','A','X',' ',&
     &   ' '/
     data llgmxm(1), llgmxm(2), llgmxm(3), llgmxm(4), llgmxm(5),&
    &   llgmxm(6), llgmxm(7), llgmxm(8) /'-','L','A','G','M','A','X',&
     &   ' '/
     data llgmxp(1), llgmxp(2), llgmxp(3), llgmxp(4), llgmxp(5),&
    &   llgmxp(6), llgmxp(7), llgmxp(8) /'+','L','A','G','M','A','X',&
     &   ' '/
     data llgmx1(1), llgmx1(2), llgmx1(3), llgmx1(4), llgmx1(5),&
    &   llgmx1(6), llgmx1(7), llgmx1(8) /'L','A','G','M','A','X','+',&
     &   '1'/
     data llds(1), llds(2), llds(3), llds(4), llds(5), llds(6),&
     &   llds(7), llds(8) /'L','D','S','T','A','K',' ',' '/
     data ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8) /'N',&
     &   ' ',' ',' ',' ',' ',' ',' '/
     data lnf(1), lnf(2), lnf(3), lnf(4), lnf(5), lnf(6), lnf(7),&
     &   lnf(8) /'N','F',' ',' ',' ',' ',' ',' '/
     data lnm1(1), lnm1(2), lnm1(3), lnm1(4), lnm1(5), lnm1(6),&
     &   lnm1(7), lnm1(8) /'N','-','1',' ',' ',' ',' ',' '/
     data llyfft(1), llyfft(2), llyfft(3), llyfft(4), llyfft(5),&
    &   llyfft(6), llyfft(7), llyfft(8) /'L','Y','F','F','T',' ',' ',&
     &   ' '/
     data lphi(1), lphi(2), lphi(3), lphi(4), lphi(5), lphi(6),&
     &   lphi(7), lphi(8) /'P','H','I',' ',' ',' ',' ',' '/
     data l1(1), l1(2), l1(3), l1(4), l1(5), l1(6), l1(7), l1(8) /'1',&
     &   ' ',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
!
      ierr = 0
      head = .true.
!
      do 10 i=1,20
         err(i) = .false.
   10 continue
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 17, 1, head, err(1), ln)
!
      if ((.not.option(3))) go to 15
!
     call ervii(nmsub, lacv, acov, lagmax+1, -abs(acov(1)),&
     &   abs(acov(1)), 0, head, 4, nv, err(15)) !, LACV1M, LACV1P)
!
     call eisii(nmsub, llgmx, lagmax, 1, n-1, 1, head, err(2),&
     &   l1, lnm1)
!
      if (option(2)) then
        call eisge(nmsub, llacov, lacov, lagmax+1, 8, head, err(3),&
     &   llgmx1)
      else
        call eisge(nmsub, llacov, lacov, lagmax+1, 7, head, err(3),&
     &   llgmx1)
      end if
!
  15 if (option(1) .and. (.not.err(1)))&
    &   call eisge(nmsub, llyfft, lyfft, nfft, 9, head, err(4),&
     &   llyfft)
!
     if (option(1) .and. (.not.option(4)))&
     &   call eisge(nmsub, llds, ldstak, ldsmin, 9, head, err(5), llds)
!
      if (option(4)) go to 30
!
      do 20 i=1,15
         if (err(i)) go to 50
   20 continue
!
      return
!
   30 continue
!
     call eisii(nmsub, liar, iar, -iabs(lagmax), iabs(lagmax), 1, head,&
     &   err(6), llgmxm, llgmxp)
!
     call ervii(nmsub, lphi, phi, iar, -1.0e0, 1.0e0, 0, head, 1, nv,&
     &   err(7)) !, L1, L1)
!
     if (.not.option(3))&
    &   call eisii(nmsub, llgmx, lagmax, 1, n-1, 1, head, err(2),&
     &   l1, lnm1)
!
     call eisii(nmsub, llag, lag, -iabs(lagmax), iabs(lagmax), 1, head,&
     &   err(8), llgmxm, llgmxp)
!
      call eisge(nmsub, lnf, nf, 1, 1, head, err(9), lnf)
!
      if (err(1) .or. err(2) .or. err(9)) go to 50
!
      call eisge(nmsub, llds, ldstak, ldsmin, 9, head, err(14), llds)
!
      do 40 i=1,15
         if (err(i)) go to 50
   40 continue
!
      return
!
   50 continue
      ierr = 1
      return
!
      end
!DRV3
      subroutine drv3(par, npar, xm, n, m, ixm, d)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DERIVATIVE FUNCTION FOR NLS FAMILY EXERCISER SUBROUTINE MDL3
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   d(n,npar),par(npar),xm(ixm,m)
!
!  LOCAL SCALARS
     integer&
     &   i,j
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL PAR(NPAR)
!        MODEL PARAMETERS
!     REAL D(N,NPAR)
!        THE FIRST DERIVATIVE WITH RESPECT TO THE ITH PARAMETER
!     INTEGER I
!        ROW MARKER
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLESC
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS
!     REAL XM(IXM,M)
!        INDEPENDENT VARIABLE
!
      do 20 i=1,n
         do 10 j=1,npar
            d(i,j) = xm(i,j)
   10    continue
   20 continue
!
      return
!
      end
!BFSV
      subroutine bfsv(ccov, index1, index2, n, lagmax, iccov, jccov)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
!     FOURIER SPECTRUM ANALYSIS OF SERIES WITH
!     COVARIANCES INPUT RATHER THAN ORIGINAL SERIES
!     (SHORT CALL)
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iccov,index1,index2,jccov,lagmax,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ccov(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta,fmax,fmin,ymiss1,ymiss2
     integer&
    &   icspc2,inlppc,iphas,iprt,jnlppc,lagmx1,lagmxu,ldsmin,&
     &   ldstak,lpcv,lw,ly,m,nf,nprt,nw
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   ceven(101),codd(101),cspc2(101,4),freq(101),phas(101,4),&
    &   spcf1(101),spcf2(101),w(101),xaxis(404),y1(1),y2(1),&
     &   yaxis(404)
     integer&
     &   isym(404),lags(4),nlppc(1,1,1)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL BFSDRV,IPRINT,PARZEN,SETLAG
!
!  INTRINSIC FUNCTIONS
      intrinsic min
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL CCOV(ICCOV,JCCOV,*)
!        THE COVARIANCES.
!     REAL CEVEN(101)
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     REAL CODD(101)
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     REAL CSPC2(101,4)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISYM(404)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC.
!     INTEGER LAGMAX, LAGMXU
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC(1,1,1)
!        A DUMMY ARRAY.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL PHAS(101,4)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL SPCF1(101), SPCF2(101)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     REAL W(101)
!        THE WINDOWS.
!     REAL XAXIS(404)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YAXIS(404)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YMISS1, YMISS2
!        THE MISSING VALUE CODES
!     REAL Y1(1)
!        THE FIRST TIME SERIES.
!     REAL Y2(1)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'B','F','S','V',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      option(1) = .false.
      option(2) = .false.
      option(3) = .true.
      option(4) = .false.
!
      m = 2
!
      inlppc = 1
      jnlppc = 1
      icspc2 = 101
      iphas = 101
!
      ldstak = 0
      ldsmin = 0
!
      nf = 101
      lw = 101
      ly = n
      lpcv = 404
!
!     SET MAXIMUM LAG VALUE USED (LAGMXU)
!     SET NUMBER OF LAG WINDOW TRUCCATION POINTS (NW)
!
      call setlag(n, lagmxu)
      lagmxu = min(lagmxu,lagmax)
      nw = 4
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
     call bfsdrv(y1, y2, ymiss1, ymiss2, ccov, nlppc, spcf1, spcf2,&
    &   nf, fmin, fmax, freq, n, nw, lagmxu, lags, lagmx1, w, lw,&
    &   delta, isym, xaxis, yaxis, lpcv, alpha, nprt, parzen, iccov,&
    &   jccov, m, index1, index2, cspc2, phas, icspc2, iphas, codd,&
    &   ceven, w, lw, nmsub, ldsmin, ldstak, option, n, inlppc,&
     &   jnlppc, ly)
!
      if (ierr.eq.0) return
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &  '       CALL BFSV(CCOV, INDEX1, INDEX2, N, LAGMAX, ICCOV,',&
     &  ' JCCOV)')
      end
!MVPM
      subroutine mvpm(ym, ymmiss, n, m, iym, ns)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA AND MULTIPLE Y-AXIS VALUES
!     (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iym,m,n,ns
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(*),ymmiss(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ibar,ilog,iprt,irlin,ischck,isize,lisym
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(M)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'M',       'V',       'P',       'M',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      multi = .true.
      ilog = -1
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 1.0e0
      xinc = 1.0e0
      ischck = 2
      isize = -1
      miss = .true.
      lisym = 1
      irlin = -1
      ibar = 0
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ymmiss, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &  '       CALL MVPM (YM, YMMISS, N, M, IYM, NS)')
      end
!NLSUPK
      subroutine nlsupk(pare, npare, par, mask, npar)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE UNPACKS A VECTOR PARE INTO A VECTOR PAR, BY
!     PLACING SUCCEDING ELEMENTS OF PARE INTO ELEMENTS OF PAR
!     WHICH CORRESPOND TO ELEMENTS OF MASK WITH THE VALUE 1.
!     OTHER ELEMENTS OF MASK SHOULD BE 0.  THE NUMBER OF ELEMENTS
!     NPARE IN PARE SHOULD EQUAL THE NUMBER OF ELEMENTS OF
!     MASK WHICH ARE 1.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   npar,npare
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),pare(npar)
     integer&
     &   mask(npar)
!
!  LOCAL SCALARS
     integer&
     &   i,jpk
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER JPK
!        AN INDEX VARIABLE.
!     INTEGER MASK(NPAR)
!        INPUT PARAMETER.  THE MASK GOVERNING THE PACKING OF PAR.
!        ELEMENTS OF MASK ARE 1 IF THE CORRESPONDING ELEMENT OF PAR
!        WAS ELIMINATED IN PARE, 0 IF IT WAS INCLUDED.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     REAL PARE(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS BEING OPTIMIZED,
!        NOT INCLUDING THOSE WHOSE VALUES ARE FIXED.
!
!     COMMENCE BODY OF ROUTINE
!
      jpk = 0
      do 20 i=1,npar
         if (mask(i).ne.0) go to 20
         jpk = jpk + 1
         par(i) = pare(jpk)
   20 continue
      return
      end
!FLTAR
      subroutine fltar (y, n, iar, phi, yf, nyf)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE FILTERS THE INPUT SERIES Y USING THE IAR TERMS
!     OF THE AUTOREGRESSIVE FILTER PHI, COPYING THE FILTERED SERIES
!     INTO YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iar,n,nyf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   phi(*),y(*),yf(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   temp
     integer&
     &   i,i1,j,k
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IAR
!        THE NUMBER OF FILTER TERMS.
!     INTEGER I1, J, K
!        INDEXING VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     REAL PHI(IAR)
!        THE ARRAY IN WHICH THE FILTER COEFFICIENTS ARE STORED.
!     REAL TEMP
!        A TEMPORARY STORAGE LOCATION.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
      do 10 i = 1, n
         yf(i) = y(i)
   10 continue
!
      nyf = n - iar
!
      do 30 i = 1, nyf
         k = i + iar
         temp = yf(k)
         do 20 j = 1, iar
            k = k - 1
            temp = temp - phi(j) * yf(k)
   20    continue
         yf(i) = temp
   30 continue
!
      i1 = nyf + 1
!
      do 40 i = i1, n
         yf(i) = 0.0e0
   40 continue
      return
      end
!NLSC
     subroutine nlsc(y, xm, n, m, ixm, mdl, par, npar, res, ldstak,&
     &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
!     (CONTROL CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,stopp,stopss
     integer&
     &   ivaprx,ixm,ldstak,m,mit,n,npar,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),res(*),scale(*),stp(*),xm(*),y(*)
     integer&
     &   ifixed(*)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   rsd
     integer&
    &   iprt,ivcv,lifixd,lpv,lscale,lsdpv,lsdres,lstp,lwt,nnzw,&
     &   npare
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   pv(1),sdpv(1),sdres(1),vcv(1,1),wt(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,NLCNTN
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(NPAR)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(NPAR)
!        THE STEP SIZE ARRAY.
!     REAL VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(1)
!        THE DUMMY ARRAY FOR THE WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'N','L','S','C',' ',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      weight = .false.
      save = .false.
!
      wt(1) = 1.0e0
      lifixd = npar
      lpv = 1
      lscale = npar
      lstp = npar
      lsdpv = 1
      lsdres = 1
      lwt = 1
      ivcv = 1
!
     call nlcntn(y, wt, lwt, xm, n, m, ixm, mdl, par, npar, res,&
    &   ldstak, ifixed, lifixd, stp, lstp, mit, stopss, stopp, scale,&
    &   lscale, delta, ivaprx, nprt, rsd, pv, lpv, sdpv, lsdpv, sdres,&
     &   lsdres, vcv, ivcv, nmsub, weight, save, nnzw, npare)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL NLSC (Y, XM, N, M, IXM, NLSMDL,'/&
    &   '      +           PAR, NPAR, RES, LDSTAK,'/&
    &   '      +           IFIXED, STP, MIT, STOPSS, STOPP,'/&
     &   '      +           SCALE, DELTA, IVAPRX, NPRT)')
      end
!CHIRHO
      subroutine chirho (rho, n, nc, chi, chip)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE CHI SQUARED STATISTIC AND ITS
!     PROBABILITY BASED IN A VECTOR OF AUTOCORRELATIONS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   chi,chip
     integer&
     &   n,nc
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   rho(*)
!
!  LOCAL SCALARS
     integer&
     &   lag
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   cdfchi
!       EXTERNAL CDFCHI
!
!  INTRINSIC FUNCTIONS
      intrinsic real
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CHI, CHIP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARE STATISTIC PROBABILITY ARE STORED.
!     INTEGER LAG
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCORRELATION BEING EXAMINED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NC
!        THE NUMBER OF AUTOCORRELATIONS COMPUTED.
!     REAL RHO(NC)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
!
      chi = 0.0e0
      do 10 lag = 1, nc
         chi = chi + rho(lag) * rho(lag)
   10 continue
      chi = chi * n
      chip = 1.0e0 - cdfchi(chi, real(nc))
      return
      end
!XAIMT
      subroutine xaimt(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE TIME SERIES MODEL ESTIMATION ROUTINES.
!
!     SERIES Y IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND JENKINS
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
     &   i,ifcst,iprt,ivaprx,ivcv,mit,nfac,npar,npare,nprt,ny
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   fcst(50,5),fcstsd(50),par(50),pv(200),res(200),scale(50),&
    &   sdpv(200),sdres(200),stp(50),vcv(10,10),y(200),ylog(200),&
     &   yt(200)
     integer&
     &   ifixed(50),mspec(4,50)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AIME,AIMEC,AIMES,AIMF,AIMFS,IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic log
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FCST(50,5)
!        THE FORECASTS.
!     REAL FCSTSD(50)
!        THE STANDARD DEVIATIONS OF THE FORECASTS.
!     INTEGER I
!        *
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFCST
!        THE FIRST DIMENSION OF THE ARRAY FCST.
!     INTEGER IFIXED(50)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER MSPEC(4,50)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH
!        FACTOR.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NY
!        THE NUMBER OF OBSERVATIONS.
!     REAL PAR(50)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL PV(200)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(200)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     REAL SCALE(50)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     REAL SDPV(200)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(200)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(50)
!        THE RCSTEP SIZE ARRAY.
!     REAL VCV(10,10)
!        THE COVARIANCE MATRIX.
!     REAL Y(200),YLOG(200),YT(200)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!
     data    y(  1),   y(  2),   y(  3),   y(  4),   y(  5),   y(  6)&
     &    / 112.0e0, 118.0e0, 132.0e0, 129.0e0, 121.0e0, 135.0e0/
     data    y(  7),   y(  8),   y(  9),   y( 10),   y( 11),   y( 12)&
     &    / 148.0e0, 148.0e0, 136.0e0, 119.0e0, 104.0e0, 118.0e0/
     data    y( 13),   y( 14),   y( 15),   y( 16),   y( 17),   y( 18)&
     &    / 115.0e0, 126.0e0, 141.0e0, 135.0e0, 125.0e0, 149.0e0/
     data    y( 19),   y( 20),   y( 21),   y( 22),   y( 23),   y( 24)&
     &    / 170.0e0, 170.0e0, 158.0e0, 133.0e0, 114.0e0, 140.0e0/
     data    y( 25),   y( 26),   y( 27),   y( 28),   y( 29),   y( 30)&
     &    / 145.0e0, 150.0e0, 178.0e0, 163.0e0, 172.0e0, 178.0e0/
     data    y( 31),   y( 32),   y( 33),   y( 34),   y( 35),   y( 36)&
     &    / 199.0e0, 199.0e0, 184.0e0, 162.0e0, 146.0e0, 166.0e0/
     data    y( 37),   y( 38),   y( 39),   y( 40),   y( 41),   y( 42)&
     &    / 171.0e0, 180.0e0, 193.0e0, 181.0e0, 183.0e0, 218.0e0/
     data    y( 43),   y( 44),   y( 45),   y( 46),   y( 47),   y( 48)&
     &    / 230.0e0, 242.0e0, 209.0e0, 191.0e0, 172.0e0, 194.0e0/
     data    y( 49),   y( 50),   y( 51),   y( 52),   y( 53),   y( 54)&
     &    / 196.0e0, 196.0e0, 236.0e0, 235.0e0, 229.0e0, 243.0e0/
     data    y( 55),   y( 56),   y( 57),   y( 58),   y( 59),   y( 60)&
     &    / 264.0e0, 272.0e0, 237.0e0, 211.0e0, 180.0e0, 201.0e0/
     data    y( 61),   y( 62),   y( 63),   y( 64),   y( 65),   y( 66)&
     &    / 204.0e0, 188.0e0, 235.0e0, 227.0e0, 234.0e0, 264.0e0/
     data    y( 67),   y( 68),   y( 69),   y( 70),   y( 71),   y( 72)&
     &    / 302.0e0, 293.0e0, 259.0e0, 229.0e0, 203.0e0, 229.0e0/
     data    y( 73),   y( 74),   y( 75),   y( 76),   y( 77),   y( 78)&
     &    / 242.0e0, 233.0e0, 267.0e0, 269.0e0, 270.0e0, 315.0e0/
     data    y( 79),   y( 80),   y( 81),   y( 82),   y( 83),   y( 84)&
     &    / 364.0e0, 347.0e0, 312.0e0, 274.0e0, 237.0e0, 278.0e0/
     data    y( 85),   y( 86),   y( 87),   y( 88),   y( 89),   y( 90)&
     &    / 284.0e0, 277.0e0, 317.0e0, 313.0e0, 318.0e0, 374.0e0/
     data    y( 91),   y( 92),   y( 93),   y( 94),   y( 95),   y( 96)&
     &    / 413.0e0, 405.0e0, 355.0e0, 306.0e0, 271.0e0, 306.0e0/
     data    y( 97),   y( 98),   y( 99),   y(100),   y(101),   y(102)&
     &    / 315.0e0, 301.0e0, 356.0e0, 348.0e0, 355.0e0, 422.0e0/
     data    y(103),   y(104),   y(105),   y(106),   y(107),   y(108)&
     &    / 465.0e0, 467.0e0, 404.0e0, 347.0e0, 305.0e0, 336.0e0/
     data    y(109),   y(110),   y(111),   y(112),   y(113),   y(114)&
     &    / 340.0e0, 318.0e0, 362.0e0, 348.0e0, 363.0e0, 435.0e0/
     data    y(115),   y(116),   y(117),   y(118),   y(119),   y(120)&
     &    / 491.0e0, 505.0e0, 404.0e0, 359.0e0, 310.0e0, 337.0e0/
     data    y(121),   y(122),   y(123),   y(124),   y(125),   y(126)&
     &    / 360.0e0, 342.0e0, 406.0e0, 396.0e0, 420.0e0, 472.0e0/
     data    y(127),   y(128),   y(129),   y(130),   y(131),   y(132)&
     &    / 548.0e0, 559.0e0, 463.0e0, 407.0e0, 362.0e0, 405.0e0/
     data    y(133),   y(134),   y(135),   y(136),   y(137),   y(138)&
     &    / 417.0e0, 391.0e0, 419.0e0, 461.0e0, 472.0e0, 535.0e0/
     data    y(139),   y(140),   y(141),   y(142),   y(143),   y(144)&
     &    / 622.0e0, 606.0e0, 508.0e0, 461.0e0, 390.0e0, 432.0e0/
!
      call iprint(iprt)
!
!     COMMENCE BODY OF ROUTINE
!
!     TEST AGAINST PUBLISHED RESULTS
!
      ny = 144
      do 10 i = 1, ny
         ylog(i) = log(y(i))
   10 continue
!
      nfac = 2
      mspec(1,1) = 0
      mspec(2,1) = 1
      mspec(3,1) = 1
      mspec(4,1) = 1
!
      mspec(1,2) = 0
      mspec(2,2) = 1
      mspec(3,2) = 1
      mspec(4,2) = 12
!
      npar = 3
      par(1) = 0.0e0
      par(2) = 0.40e0
      par(3) = 0.60e0
!
      ifixed(1) = 1
      ifixed(2) = 0
      ifixed(3) = 0
!
      stopss = -1.0e0
      stopp = -1.0e0
      scale(1) = -1.0e0
      scale(2) = 1.0e-7
      scale(3) = 1.0e-7
      stp(1) = -1.0e0
      stp(2) = 1.0e-7
      stp(3) = 1.0e-7
      mit = 0
      nprt = -1
      delta = -1.0e0
      ivaprx = -1
!
      write(iprt, 1000)
     call aimec (ylog, ny, mspec, nfac,&
    &   par, npar, res,ldstak, ifixed,stp, mit, stopss, stopp,&
     &   scale, delta, ivaprx, nprt)
!
      write (iprt, 1005)
      par(1) = 0.0e0
      par(2) = 0.395e0
      par(3) = 0.615e0
     call aimfs (ylog, ny, mspec, nfac,&
     &   par, npar, ldstak, ny/10+1, 1, [ny], nprt, fcst, 50, fcstsd)
!
      scale(1) = 1.0e-7
      scale(2) = 1.0e-7
      scale(3) = 1.0e-7
!
      nfac = 2
      mspec(1,1) = 0
      mspec(2,1) = 1
      mspec(3,1) = 1
      mspec(4,1) = 1
!
      mspec(1,2) = 0
      mspec(2,2) = 0
      mspec(3,2) = 1
      mspec(4,2) = 12
!
      write (iprt, 1000)
     call aimec (ylog, ny, mspec, nfac,&
    &   par, npar, res,ldstak, ifixed,stp, mit, stopss, stopp,&
     &   scale, delta, ivaprx, nprt)
      ny = 20
      write (iprt, 1000)
     call aimec (ylog, ny, mspec, nfac,&
    &   par, npar, res,ldstak, ifixed,stp, mit, stopss, stopp,&
     &   scale, delta, ivaprx, nprt)
!
      nfac = 2
      mspec(1,1) = 0
      mspec(2,1) = 0
      mspec(3,1) = 1
      mspec(4,1) = 1
!
      mspec(1,2) = 0
      mspec(2,2) = 0
      mspec(3,2) = 1
      mspec(4,2) = 12
!
      ny = 144
      write (iprt, 1000)
     call aimec (ylog, ny, mspec, nfac,&
    &   par, npar, res,ldstak, ifixed,stp, mit, stopss, stopp,&
     &   scale, delta, ivaprx, nprt)
!
!     EXAMPLE FROM PAGE 212 OF BOX AND JENKINS (1970)
!     N.B. ADD PRINT STATEMENTS TO MDLTS2 TO CHECK COMPUTATIONS
!          AT FIRST CALL AGAINST THOSE LISTED ON PAGE 214.
!
      write(iprt, 1000)
      ny = 10
      yt(1) = 460.0e0
      yt(2) = 457.0e0
      yt(3) = 452.0e0
      yt(4) = 459.0e0
      yt(5) = 462.0e0
      yt(6) = 459.0e0
      yt(7) = 463.0e0
      yt(8) = 479.0e0
      yt(9) = 493.0e0
      yt(10) = 490.0e0
!
      nfac = 1
      mspec(1,1) = 0
      mspec(2,1) = 1
      mspec(3,1) = 1
      mspec(4,1) = 1
!
      npar = 2
      par(1) = 0.0e0
      par(2) = 0.5e0
!
      ifixed(1) = 1
      ifixed(2) = 0
!
     call aimec (yt, ny, mspec, nfac,&
    &   par, npar, res,ldstak, ifixed,stp, mit, stopss, stopp,&
     &   scale, delta, ivaprx, nprt)
!
!     EXAMPLE FROM PAGE 216 OF BOX AND JENKINS (1970)
!     N.B. ADD PRINT STATEMENTS TO MDLTS2 TO CHECK COMPUTATIONS
!          AT FIRST CALL AGAINST THOSE LISTED ON PAGE 218.
!
      write(iprt, 1000)
      ny = 12
      yt(1) = 2.0e0
      yt(2) = 0.8e0
      yt(3) = -0.3e0
      yt(4) = -0.3e0
      yt(5) = -1.9e0
      yt(6) = 0.3e0
      yt(7) = 3.2e0
      yt(8) = 1.6e0
      yt(9) = -0.7e0
      yt(10) = 3.0e0
      yt(11) = 4.3e0
      yt(12) = 1.1e0
!
      nfac = 1
      mspec(1,1) = 1
      mspec(2,1) = 0
      mspec(3,1) = 1
      mspec(4,1) = 1
!
      npar = 3
      par(1) = 0.3e0
      par(2) = 0.0e0
      par(3) = 0.7e0
!
      ifixed(1) = 0
      ifixed(2) = 1
      ifixed(3) = 0
!
     call aimec (yt, ny, mspec, nfac,&
    &   par, npar, res, ldstak, ifixed, stp, mit, stopss, stopp,&
     &   scale, delta, ivaprx, nprt)
!
!     TEST ERROR MESSAGES
!
      write (iprt, 1010)
      ny = 0
      nfac = 0
     call aime (yt, ny, mspec, nfac,&
     &   par, npar, res, ldstak)
     call aimec (yt, ny, mspec, nfac,&
    &   par, npar, res, ldstak, ifixed, stp, mit, stopss, stopp,&
     &   scale, delta, ivaprx, nprt)
     call aimes (yt, ny, mspec, nfac,&
    &   par, npar, res, ldstak, ifixed, stp, mit, stopss, stopp,&
    &   scale, delta, ivaprx, nprt, npare, rsd, pv, sdpv, sdres, vcv,&
     &   ivcv)
      call aimf (y, ny, mspec, nfac, par, npar, ldstak)
     call aimfs (y, ny, mspec, nfac,&
     &   par, npar, ldstak, ny/10+1, 1, [ny], nprt, fcst, 50, fcstsd)
!
      ny = 144
      nfac = 2
      mspec(1,1) = -1
     call aime (yt, ny, mspec, nfac,&
     &   par, npar, res, ldstak)
     call aimec (yt, ny, mspec, nfac,&
    &   par, npar, res, ldstak, ifixed, stp, mit, stopss, stopp,&
     &   scale, delta, ivaprx, nprt)
     call aimes (yt, ny, mspec, nfac,&
    &   par, npar, res, ldstak, ifixed, stp, mit, stopss, stopp,&
    &   scale, delta, ivaprx, nprt, npare, rsd, pv, sdpv, sdres, vcv,&
     &   ivcv)
      call aimf (y, ny, mspec, nfac, par, npar, ldstak)
     call aimfs (y, ny, mspec, nfac,&
     &   par, npar, ldstak, ny/10+1, 1, [ny], nprt, fcst, 50, fcstsd)
      ny = 144
      nfac = 2
      mspec(1,1) = 0
      npar = 1
     call aime (yt, ny, mspec, nfac,&
     &   par, npar, res, ldstak)
     call aimec (yt, ny, mspec, nfac,&
    &   par, npar, res, ldstak, ifixed, stp, mit, stopss, stopp,&
     &   scale, delta, ivaprx, nprt)
     call aimes (yt, ny, mspec, nfac,&
    &   par, npar, res, ldstak, ifixed, stp, mit, stopss, stopp,&
    &   scale, delta, ivaprx, nprt, npare, rsd, pv, sdpv, sdres, vcv,&
     &   ivcv)
      call aimf (y, ny, mspec, nfac, par, npar, ldstak)
     call aimfs (y, ny, mspec, nfac,&
     &   par, npar, ldstak, ny/10+1, 1, [ny], nprt, fcst, 50, fcstsd)
      ny = 144
      nfac = 2
      mspec(1,1) = 0
      npar = 3
      do 20 i = 1, npar
        ifixed(i) = 1
   20 continue
      ivcv = 0
      ifcst = 0
     call aimec (yt, ny, mspec, nfac,&
    &   par, npar, res, ldstak, ifixed, stp, mit, stopss, stopp,&
     &   scale, delta, ivaprx, nprt)
     call aimes (yt, ny, mspec, nfac,&
    &   par, npar, res, ldstak, ifixed, stp, mit, stopss, stopp,&
    &   scale, delta, ivaprx, nprt, npare, rsd, pv, sdpv, sdres, vcv,&
     &   ivcv)
     call aimfs (y, ny, mspec, nfac,&
     &   par, npar, ldstak, ny/10+1, 1, [ny], nprt, fcst, ifcst, fcstsd)
      do 30 i = 1, npar
        ifixed(i) = 1
   30 continue
      ivcv = 0
      stp(2) = -1.0e0
      scale(2) = -1.0e0
     call aimec (yt, ny, mspec, nfac,&
    &   par, npar, res, ldstak, ifixed, stp, mit, stopss, stopp,&
     &   scale, delta, ivaprx, nprt)
      return
!
!     FORMAT STATEMENTS
!
 1000 format ('1TEST OF ARIMA ESTIMATION ROUTINES')
 1005 format ('1TEST OF ARIMA FORECASTING ROUTINES')
 1010 format ('1TEST OF ERROR CHECKING FACILITIES')
      end
!UFSMV
      subroutine ufsmv(acov, nlppa, lagmax, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS WITH MISSING DATA AND USER SUPPLIED
!     ACVF VALUES (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lagmax,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(*)
     integer&
     &   nlppa(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
      real(kind=wp) :: alpha,delta,fmax,fmin,ymiss
     integer&
    &   iprt,ispcf,lacov,ldsmin,ldstak,lnlppa,lpcv,lwork,ly,nf,&
     &   nprt,nw
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   freq(101),spcf(101,4),work(101),xaxis(106),y(1),yaxis(106)
     integer&
     &   isort(101),isym(106),lags(4)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ECVF,IPRINT,PARZEN,UFSDRV
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LAGMAX+1)
!        THE AUTOCOVARIANCE AT LAG ZERO (BIASED VARIANCE).
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISYM(106)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(LAGMAX+1)
!        THE ARRAY CONTAINING THE NUMBER OF LAG PRODUCT PAIRS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL SPCF(101,4)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     REAL WORK(101)
!        THE VECTOR OF LAG WINDOWS.
!     REAL XAXIS(106)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL Y(1)
!        A DUMMY ARRAY.
!     REAL YAXIS(106)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL YMISS
!        A DUMMY VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'U','F','S','M','V',' '/
!
!     SET UP FOR ERROR CHECKING
!
      option(4) = .false.
      option(3) = .true.
      option(2) = .true.
      option(1) = .false.
!
      ldstak = 0
      ldsmin = 0
!
      ymiss = 1.0e0
      lacov = lagmax+1
!
      ispcf = 101
      ly = 1
      lnlppa = lacov
      lpcv = 106
      lwork = 101
      nf = 101
!
!     SET NUMBER OF LAG WINDOW TRUNCATION POINTS
!
      nw = 4
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!     FOR SERIES WITH MISSING DATA.
!
     call ufsdrv(y, ly, ymiss, acov, nlppa, spcf, ispcf, nf, fmin,&
    &   fmax, freq, n, nw, lagmax, lags, work, lacov, lwork, delta,&
    &   isort, isym, xaxis, yaxis, lpcv, alpha, nprt, parzen, nmsub,&
     &   ldsmin, ldstak, option, lnlppa, ly)
!
!     CHECK FOR ERRORS
!
      if (ierr.eq.0) return
!
      if (ierr.eq.2) call ecvf(nmsub)
      ierr = 1
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL UFSMV (ACOV, NLPPA, LAGMAX, N)')
      end
!NRAND
      subroutine nrand (y, n, iseed)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE GENERATES N NORMALLY DISTRIBUTED PSEUDO-
!     RANDOM NUMBERS WITH ZERO MEAN AND UNIT STANDARD DEVIATION.  THE
!     NUMBERS GENERATED ARE DETERMINED BY ISEED.  THEY ARE RETURNED IN Y
!
!     ORIGIN - CONCEIVED BY DR. PETER TRYON TO FACILITATE USE OF
!          EXISTING RANDOM NUMBER GENERATOR
!
!     WRITTEN BY -
!          JOHN E. KOONTZ AND JANET R. DONALDSON
!          STATISTICAL ENGINEERING DIVISION
!          NATIONAL BUREAU OF STANDARDS
!          BOULDER, COLORADO 80302
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iseed,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   i,iprt,iseedu
     logical&
     &   err01,head
!
!  LOCAL ARRAYS
     character&
     &   ln(8)*1,lone(8)*1,nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!     REAL(TYPE=WP) :: RANDN
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,EISRNG,IPRINT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!          THE INDEX OF THE COMPUTING LOOP
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THEIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN FOUND.
!     INTEGER IPRT
!        THE STANDARD OUTPUT FILE UNIT NUMBER
!     INTEGER ISEED
!        THE ISEED TO THE RANDOM NUMBER GENERATOR.
!        ISEED MUST LIE BETWEEN 0 AND 2**((MIN(32,I1MACH(8)+1))-1) -1,
!        INCLUSIVE.  IF ISEED IS NOT EQUAL TO 0, ISEED MUST BE ODD.
!     INTEGER ISEEDU
!        THE VALUE OF THE SEED ACTUALLY USED.
!     CHARACTER*1 LN(8), LONE(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE VARIABLES(S) CHECKED
!        FOR ERRORS
!     INTEGER N
!        THE LENGTH OF DATA SET GENERATED
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THIS SUBROUTINE
!     REAL Y(N)
!        THE GENERATED RANDOM VALUES.
!
     data  nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6)&
     &   /       'N',      'R',      'A',      'N',      'D',      ' '/
     data     ln(1),    ln(2),    ln(3),    ln(4),    ln(5),    ln(6),&
     &         ln(7),    ln(8)/'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
     data   lone(1),  lone(2),  lone(3),  lone(4),  lone(5),  lone(6),&
     &       lone(7),  lone(8)/'O', 'N', 'E', ' ', ' ', ' ', ' ', ' '/
!
      ierr = 0
!
      head = .true.
!
!     CHECK FOR INPUT ERRORS
!
      call eisge(nmsub, ln, n, 1, 2, head, err01, lone)
      call eisrng(nmsub, iseed, iseedu, head)
!
      if (err01) then
!
        call iprint(iprt)
        write (iprt,1000)
        ierr = 1
!
      else
!
!     GENERATE THE PSEUDO-RANDOM NUMBERS
!
        y(1) = randn(iseedu,typ=0.0_wp)
        do 20 i=1,n
           y(i) = randn(0,typ=0.0_wp)
   20   continue
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL NRAND(Y, N, ISEED)')
      end
!ERSGT
     subroutine ersgt(nmsub, nmvar, val, valmn, msgtyp, head, error,&
     &   nmmin)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THE ROUTINE CHECKS WHETHER THE VALUE   VAL   IS GREATER THAN
!        VALMN   , AND PRINTS A DIAGNOSTIC IF IT IS NOT.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   val,valmn
     integer&
     &   msgtyp
     logical&
     &   error,head
!
!  ARRAY ARGUMENTS
     character&
     &   nmmin(8)*1,nmsub(6)*1,nmvar(8)*1
!
!  LOCAL SCALARS
     integer&
     &   i,iprt
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
!        PRINTED, WHERE IF ERROR IS .TRUE. AND
!        MSGTYP = 1 THE INPUT VALUE WAS TOO SMALL BASED
!                   ON LIMITS IMPOSED BY STARPAC
!        MSGTYP = 2 THE INPUT VALUE WAS TOO SMALL BASED ON
!                   LIMITS BASED ON OTHER INPUT ARGUMENTS.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE ARGUMENTS NAME.
!     REAL VAL
!        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
!     REAL VALMN
!        THE MINIMUM VALUE THE ARGUMENT CAN VALIDLY HAVE.
!
      error = .false.
!
      if (val .gt. valmn) return
!
      error = .true.
      call iprint (iprt)
      call ehdr(nmsub, head)
!
      write (iprt, 1000) (nmvar(i),i=1,6), val
!
      go to (10, 20), msgtyp
!
   10 write (iprt, 1010) (nmvar(i),i=1,6), valmn
      return
!
   20 write (iprt, 1020) (nmvar(i),i=1,6), (nmmin(i),i=1,8)
      return
!
!     FORMAT STATEMENTS
!
 1000 format (/20h the input value of , 6a1, 4h is , g15.8, '.')
1010 format(&
    &   27h the value of the argument , 6a1,&
     &   22h must be greater than , g21.14, '.')
1020 format(&
    &   27h the value of the argument , 6a1,&
     &   22h must be greater than , 8a1, '.')
!
      end
!AMEAN
      subroutine amean(y, n, ymean)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE ARITHMETIC MEAN OF A SERIES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ymean
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   sumy
     integer&
     &   i
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES
!     REAL SUMY
!        THE VARIABLE USED TO SUM THE Y VALUES.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
      sumy = 0.0e0
      do 10 i = 1, n
         sumy = sumy + y(i)
   10 continue
      ymean = sumy / n
      return
      end
!XSTPLT
      subroutine xstplt(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,exmpt
     integer&
     &   i,iprt,ixm,ldsmin,m,n,neta,npar,nprt,ntest
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   exmtst(5),par(10),scale(10),stp(10),xm(200,2)
     integer&
     &   nettst(6)
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LDSCMP,LSTVEC,MDL4,STPLS1,STPLS2,STPLSC
!
!  INTRINSIC FUNCTIONS
      intrinsic log10
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        *
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     REAL EXMTST(5)
!        VARIOUS TEST VALUES FOR EXMPT.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL4
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NETTST(6)
!        VARIOUS TEST VALUES FOR NETA.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     REAL PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL SCALE(10)
!        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL STP(10)
!        THE SELECTED STEP SIZES FOR EACH PARAMETER.
!     REAL XM(200,2)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      call iprint(iprt)
!
!     SET PARAMETER VALUES
!
      call stpls1(n, m, ixm, par, npar, neta, exmpt, scale, nprt)
      call stpls2(npar, stp)
      call ldscmp(14, 0, 2*(n+npar), 0, 0, 0, 'S', 10*n, ldsmin)
!
      if (ldsmin.le.ldstak) go to 5
!
      write (iprt, 1000) ldsmin
      return
!
    5 continue
!
!     CREATE INDEPENDENT VARIABLE
!
      delta = 0.0625e0
      xm(1,1) = 0.0e0
      do 10 i=2,n
         xm(i,1) = xm(i-1,1) + delta
   10 continue
!
      ntest = 0
!
!
!     TEST VARIOUS VALUES OF EXMPT
!
      call stpls1(n, m, ixm, par, npar, neta, exmpt, scale, nprt)
      exmtst(1) = -1.0e0
      exmtst(2) = 0.0001e0
      exmtst(3) = 0.5e0
      exmtst(4) = 1.0e0
      exmtst(5) = 1.1e0
!
      do 20 i=1,5
!
         ntest = ntest + 1
         write (iprt,1090) ntest
         write (iprt,1040)
         write (iprt,1060) neta, exmtst(i), scale(1), nprt
         write (iprt,1010)
         call stpls2(npar, stp)
        call stplsc(xm, n, m, ixm, mdl4, par, npar, ldstak, stp, neta,&
     &      exmtst(i), scale, nprt)
         write (iprt,1100) neta, exmtst(i), scale(1), nprt
         write (iprt,1050) ierr
         write (iprt,1080)
         call lstvec(4, stp)
!
   20 continue
!
!     TEST VARIOUS VALUES OF NETA
!
      nettst(1) = -1
      nettst(2) = 0
      nettst(3) = 1
      nettst(4) = 2
!
      nettst(5) = -log10(r1mach(4))
      nettst(6) = nettst(5) + 1
!
      scale(1) = 0.0e0
!
      do 30 i=1,6
!
         ntest = ntest + 1
         write (iprt,1090) ntest
         write (iprt,1040)
         write (iprt,1060) nettst(i), exmpt, scale(1), nprt
         write (iprt,1010)
         call stpls2(npar, stp)
        call stplsc(xm, n, m, ixm, mdl4, par, npar, ldstak, stp,&
     &      nettst(i), exmpt, scale, nprt)
         write (iprt,1100) nettst(i), exmpt, scale(1), nprt
         write (iprt,1050) ierr
         write (iprt,1080)
         call lstvec(4, stp)
!
   30 continue
!
!     SUPPRESS OUTPUT
!
      call stpls1(n, m, ixm, par, npar, neta, exmpt, scale, nprt)
      nprt = 0
!
      ntest = ntest + 1
      write (iprt,1090) ntest
      write (iprt,1040)
      write (iprt,1060) neta, exmpt, scale(1), nprt
      write (iprt,1010)
      call stpls2(npar, stp)
     call stplsc(xm, n, m, ixm, mdl4, par, npar, ldstak, stp, neta,&
     &   exmpt, scale, nprt)
      write (iprt,1100) neta, exmpt, scale(1), nprt
      write (iprt,1050) ierr
      write (iprt,1080)
      call lstvec(4, stp)
!
!     LARGE CALCULATION ERROR PROBLEM
!
      call stpls1(n, m, ixm, par, npar, neta, exmpt, scale, nprt)
      par(3) = 10.0e0**((nettst(5)-1)/2)
      scale(1) = -1.0e0
!
      ntest = ntest + 1
      write (iprt,1090) ntest
      write (iprt,1070)
      write (iprt,1060) neta, exmpt, scale(1), nprt
      write (iprt,1010)
      call stpls2(npar, stp)
     call stplsc(xm, n, m, ixm, mdl4, par, npar, ldstak, stp, neta,&
     &   exmpt, scale, nprt)
      write (iprt,1100) neta, exmpt, scale(1), nprt
      write (iprt,1050) ierr
      write (iprt,1080)
      call lstvec(4, stp)
!
      exmpt = 0.11e0
      nprt = 0
!
      ntest = ntest + 1
      write (iprt,1090) ntest
      write (iprt,1070)
      write (iprt,1060) neta, exmpt, scale(1), nprt
      write (iprt,1010)
      call stpls2(npar, stp)
     call stplsc(xm, n, m, ixm, mdl4, par, npar, ldstak, stp, neta,&
     &   exmpt, scale, nprt)
      write (iprt,1100) neta, exmpt, scale(1), nprt
      write (iprt,1050) ierr
      write (iprt,1080)
      call lstvec(4, stp)
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (45h1 *** ldstak must be greater than or equal to , i6)
 1010 format (15h test of stplsc)
 1040 format (15h simple example)
1050 format (/29h ***** returned results *****, 5x, 15h (-1 indicates ,&
     &   39hvalue not changed by called subroutine)//9h ierr is , i3)
1060 format (19h input   -  neta = , i5, 10h, exmpt = , g15.8,&
     &   13h, scale(1) = , g15.8, 9h, nprt = , i5)
 1070 format (32h large calculation error problem)
 1080 format (//23h returned values of stp)
1090 format (54h1derivative step size selection subroutine test number,&
     &   i5)
1100 format (//19h output  -  neta = , i5, 10h, exmpt = , g15.8,&
     &   13h, scale(1) = , g15.8, 9h, nprt = , i5//)
      end
!BFSDRV
     subroutine bfsdrv(y1, y2, ymiss1, ymiss2, ccov, nlppc, spcf1,&
    &   spcf2, nf, fmin, fmax, freq, n, nw, lagmax, lags, lagmx1,&
    &   work, lwork, delta, isym, xaxis, yaxis, lpcv, alpha, nprt,&
    &   window, iccov, jccov, m, index1, index2, cspc2, phas, icspc2,&
    &   iphas, codd, ceven, w, lw, nmsub, ldsmin, ldstak, option,&
     &   nfft, inlppc, jnlppc, ly)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLING ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS .
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: alpha,delta,fmax,fmin,ymiss1,ymiss2
     integer&
    &   iccov,icspc2,index1,index2,inlppc,iphas,jccov,jnlppc,&
    &   lagmax,lagmx1,ldsmin,ldstak,lpcv,lw,lwork,ly,m,n,nf,nfft,&
     &   nprt,nw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   ccov(*),ceven(*),codd(*),cspc2(*),freq(*),phas(*),spcf1(*),&
     &   spcf2(*),w(*),work(*),xaxis(*),y1(*),y2(*),yaxis(*)
     integer&
     &   isym(*),lags(*),nlppc(*)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  SUBROUTINE ARGUMENTS
       external window
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   bw,df,fmn,fmx,xpltmn,xpltmx,ymean1,ymean2,ypltmn,ypltmx
     integer&
     &   i,ilog,ispcer,j,k,lag,laglst,nfused,npts,nwused
     logical&
     &   newpg,univar
!
!  EXTERNAL FUNCTIONS
     integer&
     &   lstlag
!       EXTERNAL LSTLAG
!
!  EXTERNAL SUBROUTINES
       external acvf,acvff,acvfm,bfser,bfslag,bfsmn,ccvf,ccvff,ccvfm,&
     &   dfbw,dfbwm,setfrq,ufsest,ufsout
!
!  INTRINSIC FUNCTIONS
      intrinsic int,max,min
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!  STATEMENT FUNCTIONS
     integer&
     &   i3c,i3n
!
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL BW
!        THE BANDWIDTH.
!     REAL CCOV(ICCOV,JCCOV,M)
!        THE COVARIANCES.
!     REAL CEVEN(LAGMX1)
!        THE SUMS OF THE COVARIANCES FOR EACH LAG.
!     REAL CODD(LAGMX1)
!        THE DIFFERENCES OF THE COVARIANCES FOR EACH LAG.
!     REAL CSPC2(ICSPC2,NW)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL DF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FMN, FMX
!        *
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER ILOG
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        ILOG = 0 THE PLOT IS LINEAR/LINEAR, IF
!        ILOG = 1 THE PLOT IS LOG/LINEAR, IF
!     INTEGER ISPCER
!        AN ERROR FLAG USED FOR THE SPECTRUM PLOTS.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER I3C
!        STATEMENT FUNCTION FOR FINDING LOCATIONS WITHIN CCOV.
!     INTEGER I3N
!        STATEMENT FUNCTION FOR FINDING LOCATIONS WITHIN NLPPC.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF CCOV
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF NLPPC
!     INTEGER LAG
!        THE LAG WINDWO TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGLST
!        THE LAST LAG BEFORE MISSING DATA CAUSED AN ACVF
!        TO BE UNABLE TO BE COMPUTED.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        THE VALUE LAGMAX+1.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     LOGICAL NEWPG
!        THE LOGICAL VARIABLE USED TO DETERMINE IF OUTPUT
!        WILL BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NFUSED
!        THE NUMBER OF FREQUENCIES ACTUALLY USED.
!     INTEGER NLPPC(INLPPC,JNLPPC,M)
!         THE ARRAY CONTAINING THE NUMBER OF LAG PRODUCT PAIRS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     INTEGER NWUSED
!        THE NUMBER OF DIFFERENT BANDWIDTHS ACTUALLY USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     REAL PHAS(IPHAS,NW)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRUM.
!     REAL SPCF1(NF), SPCF2(NF)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     LOGICAL UNIVAR
!        THE LOGICAL VARIABLE USED TO DETERMINE IF THE OUTPUT
!        IS FOR UNIVARIATE (TRUE) OR BIVARIATE (FALSE) SPECTRA.
!     REAL W(LW)
!        THE VECTOR OF WINDOWS.
!     EXTERNAL WINDOW
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL WORK(LWORK)
!        THE VECTOR OF WORK SPACE.
!     REAL XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     REAL YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YMEAN1, YMEAN2
!        THE MEAN OF THE OBSERVED TIME SERIES
!     REAL YMISS1, YMISS2
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!     REAL YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!     REAL Y1(N), Y2(N)
!         THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!
!
!  STATEMENT FUNCTION DEFINITIONS
!
      i3c(i,j,k) = i + (j-1)*iccov + (k-1)*jccov*iccov
      i3n(i,j,k) = i + (j-1)*inlppc + (k-1)*jnlppc*inlppc
!
      nfused = nf
      if (option(4)) then
        fmn = max(fmin, 0.0e0)
        fmx = min(fmax, 0.5e0)
        if (fmn.ge.fmx) then
          fmn = 0.0e0
          fmx = 0.5e0
        end if
      else
!
!       SET VARIOUS VALUES FOR SHORT FORMS OF CALL STATEMENT
!
        nprt = -1
        fmn = 0.0e0
        fmx = 0.5e0
        lagmx1 = lagmax + 1
      end if
!
!     CHECK FOR ERRORS
!
     call bfser(nmsub, n, lagmax, iccov, jccov, inlppc, jnlppc, m,&
    &           index1, index2, icspc2, iphas, nf, nw, lags,&
     &           ldstak, ldsmin, ly, nfft, option)
!
      if (ierr.eq.1) return
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      alpha = 0.95e0
      delta = 1.0e0
!
!     COMPUTE COVARIANCES
!
      laglst = lagmax
      if (option(1)) then
       call acvff(y1, n, nfft, ymean1,&
    &             ccov(i3c(1,index1,index1)),&
     &             lagmax, iccov, n, work, nfft)
       call acvff(y2, n, nfft, ymean2,&
    &             ccov(i3c(1,index2,index2)),&
     &             lagmax, iccov, n, work, nfft)
       call ccvff(y1, y2, n, nfft, lagmax,&
    &             ccov(i3c(1,index1,index2)),&
     &             ccov(i3c(1,index2,index1)), iccov, n, work, lwork)
!
      else
        if (option(3)) then
          if (option(2)) laglst = lstlag(nlppc,lagmax,inlppc)
        else
          if (option(2)) then
           call acvfm(y1, ymiss1, n, ymean1,&
    &                 ccov(i3c(1,index1,index1)),&
     &                 lagmax, laglst, nlppc, iccov)
           call acvfm(y2, ymiss2, n, ymean2,&
    &                 ccov(i3c(1,index2,index2)),&
     &                 lagmax, laglst, nlppc, iccov)
           call ccvfm(y1, ymiss1, y2, ymiss2, n, lagmax, ymean1,&
    &                 ymean2, ccov(i3c(1,index1,index2)),&
    &                 ccov(i3c(1,index2,index1)), iccov,&
    &                 nlppc(i3n(1,index1,index2)),&
     &                 nlppc(i3n(1,index2,index1)))
!
          else
           call acvf(y1, n, ymean1, ccov(i3c(1,index1,index1)), lagmax,&
     &                iccov)
           call acvf(y2, n, ymean2, ccov(i3c(1,index2,index2)), lagmax,&
     &                iccov)
           call ccvf(y1, y2, n, lagmax, ymean1, ymean2,&
    &                ccov(i3c(1,index1,index2)),&
     &                ccov(i3c(1,index2,index1)), iccov)
          end if
        end if
      end if
!
      if (laglst.le.0) then
!
!     AN ERROR HAS BEEN DETECTED
!
         ierr = 2
         return
      end if
!
!     COMPUTE THE VECTOR OF LAG WINDOW TRUNCATION POINTS, ORDERED
!     SMALLEST TO LARGEST.
!
      nwused = nw
     if (.not.option(4)) call bfslag(ccov, laglst, lags, n, nw, nwused,&
     &                                iccov, jccov, index1, index2)
!
!     BEGIN COMPUTING FOURIER SPECTRUM FOR SERIES
!
      univar = .false.
!
      ilog = 0
!
      xpltmn = fmn
      xpltmx = fmx
!
      ypltmn = 0.0e0
      ypltmx = 1.0e0
!
!     SET FREQUENCIES FOR THE SPECTRUM.
!
      call setfrq(freq, nf, 1, fmn, fmx, delta)
!
!     COMPUTE AND PLOT SPECTRUM VALUES.
!
      newpg = .false.
!
!     COMPUTE THE EVEN AND ODD CCVF ESTIMATES
!
      ceven(1) = ccov(i3c(1,index1,index2))
      codd(1) = 0.0e0
      do 30 i=1,laglst
        ceven(i+1) = 0.5e0*&
    &                (ccov(i3c(i+1,index1,index2))+&
     &                 ccov(i3c(i+1,index2,index1)))
        codd(i+1) = 0.5e0*&
    &               (ccov(i3c(i+1,index1,index2))-&
     &                ccov(i3c(i+1,index2,index1)))
   30 continue
!
      do 60 i=1,nwused
         lag = lags(i)
         if (lag.gt.laglst) then
            ispcer = 2
            df = 0.0e0
         else
!
            ispcer = 0
!
!     COMPUTE THE WINDOW, AND EFFECTIVE DEGREES OF FREEDOM AND
!     BANDWIDTH BASED ON THE WINDOW
!
            call window(lag, w, lw)
            if (option(2)) then
              call dfbwm(n, lag, w, lw, nlppc(i3n(1,index1,index2)),&
     &                    nlppc(i3n(1,index2,index1)), inlppc, df, bw)
            else
               call dfbw(n, lag, w, lw, df, bw)
            end if
!
!     COMPUTE THE SPECTRUM FOR EACH INDIVIDUAL SERIES
!
           call ufsest(ccov(i3c(1,index1,index1)), w, lag, spcf1,&
     &                  nfused, iccov, lagmax, nf, freq, delta)
!
           call ufsest(ccov(i3c(1,index2,index2)), w, lag, spcf2,&
     &                  nfused, iccov, lagmax, nf, freq, delta)
!
           call bfsmn(spcf1, spcf2, ceven, codd, w, lw, lag, df, nprt,&
    &                 nf, cspc2(1+(i-1)*icspc2), phas(1+(i-1)*iphas),&
    &                 freq, npts, xaxis,&
     &                 yaxis, isym, lpcv, alpha, lagmx1, delta)
!
            if (nprt.eq.0) go to 60
!
         end if
        call ufsout(xaxis, yaxis, isym, npts, bw, int(df+0.5e0), lag,&
    &               lagmax, newpg, ispcer, nfused+5, xpltmn, xpltmx,&
    &               ypltmn, ypltmx, ilog, phas(1+(i-1)*iphas), freq,&
     &               nf, univar, nmsub)
!
         newpg = .true.
!
   60 continue
!
      return
!
      end
!LSTVCF
      subroutine lstvcf(n, vec, lmask, mask)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS THE FIRST N ELEMENTS OF THE VECTOR
!     VEC.  THE I TH ELEMENT OF VEC IS IDENTIFIED WITH THE INDEX
!     OF THE I TH ZERO ELEMENT OF MASK.
!
!     WRITTEN BY  -  JOHN E. KOONTZ
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!                       PATTERNED AFTER LSTVEC OF JUNE 7, 1982.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lmask,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   vec(n)
     integer&
     &   mask(lmask)
!
!  LOCAL SCALARS
     integer&
     &   i,imask,imax,imin,index,iprt,j,jmax,nperl
!
!  LOCAL ARRAYS
     integer&
     &   indw(10)
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   INPERL
!      EXTERNAL INPERL
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic min
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IMASK
!        INDEX IN MASK.
!     INTEGER IMAX, IMIN
!        THE LARGEST AND SMALLEST INDICES IN VEC OF THE ELEMENTS TO BE
!        PRINTED.
!     INTEGER INDEX
!        THE INDEX OF THE VALUE TO BE PRINTED.
!     INTEGER INDW(10)
!        A WORK VECTOR FOR THE INDICES TO BE PRINTED FOR VEC.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER JMAX
!        INDEX IN INDW OF THE LARGEST INDEX TO BE PRINTED FOR VEC.
!     INTEGER LMASK
!        THE LENGTH OF MASK.  LMASK .GE. N.
!     INTEGER MASK(LMASK)
!        MASK VECTOR FOR VEC.  THE INDEX OF THE ITH ELEMENT OF MASK
!        EQUAL TO ZERO IS THE LABEL IN THE OUTPUT OF THE ITH ELEMENT
!        OF VEC.
!     INTEGER N
!        THE NUMBER OF VALUES TO BE PRINTED IN THE INPUT VECTOR.
!     INTEGER NPERL
!        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
!     REAL VEC(N)
!        THE VECTOR OF VALUES TO BE PRINTED.
!
      call iprint(iprt)
!
      nperl = inperl(0)
!        NOTE - INPERL(0) IS ASSUMED TO BE AT MOST 10.0E0  IF GREATER,
!               INCREASE THE DIMENSION OF INDW.
!
!
      imask = 0
      do 30 i = 1, n, nperl
         imin = i
         imax = min(i+nperl-1, n)
         jmax = min(n - imin + 1, nperl)
         do 20 j = 1, jmax
   10       if (imask .ge. lmask) go to 40
            imask = imask + 1
            if (mask(imask) .ne. 0) go to 10
            indw(j) = imask
   20    continue
         write(iprt, 1010) (indw(index), index = 1, jmax)
         write(iprt, 1020) (vec(index), index = imin, imax)
   30 continue
!
      return
!
   40 write (iprt, 1030)
      return
!
!     FORMAT STATEMENTS
!
 1010 format(10x, 5hindex, i5, 6i15)
 1020 format(10x, 5hvalue, 7(1x, g14.7)/)
1030 format (/47h error in starpac.  lstvec tried to access more,&
     &   29h elements than exist in mask.)
!
      end
!CCF
      subroutine ccf (y1, y2, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
!     CORRELATIONS OF TWO TIME SERIES (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y1(*),y2(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   y1mean,y1sd,y2mean,y2sd
     integer&
    &   iccov,inlppc,iprt,iym,iymfft,jccov,jnlppc,lagmax,ldsmin,&
     &   ldstak,lyfft,m,nfft
     logical&
     &   isfft,islong
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ccov(101,2,2),rhoc(201),sdrhoc(201)
     integer&
     &   ndum(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACVF,CCFER,CCFMN,CCFOUT,IPRINT,SETLAG
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCOV(101, 2, 2)
!        THE CCVF MATRIX.
!     INTEGER ICCOV
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER INLPPC
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
!        IN THE USERS PROGRAM.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     LOGICAL ISLONG
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
!     INTEGER IYM
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YM AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IYMFFT
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JCCOV
!        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
!        IN THE USERS PROGRAM.
!     INTEGER LAGMAX
!        THE NUMBER OF AUTOCORRELATIONS DESIRED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER M
!        THE NUMBER OF SERIES BEING COMPARED, IE THE
!        NUMBER OF COLUMNS OF DATA IN YM.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NDUM(1)
!        A DUMMY DIMENSIONED VARIABLE.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     REAL RHOC(201)
!        THE ARRAY CONTAINING THE CCF.
!     REAL SDRHOC(201)
!        THE ARRAY CONTAINING THE SD OF THE CCF.
!     REAL Y1(N), Y1MEAN, Y1SD
!        THE FIRST SERIES, AND ITS MEAN AND STANDARD DEVIATION.
!     REAL Y2(N), Y2MEAN, Y2SD
!        THE SECOND SERIES, AND ITS MEAN AND STANDARD DEVIATION.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'C',       'C',       'F',       ' ',       ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      iccov = 101
      inlppc = 1
      iym = n
      jccov = 2
      jnlppc = 1
      ldsmin = 0
      ldstak = 0
      lagmax = 1
      lyfft = n + lagmax
      iymfft = lyfft
      m = 2
      nfft = n
      isfft = .false.
      islong = .false.
!
!     CALL ERROR CHECKING ROUTINES
!
     call ccfer(nmsub, n, lagmax, ldstak, ldsmin, iccov, jccov,&
     &  inlppc, jnlppc, m, lyfft, nfft, iym, iymfft, isfft, islong)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      if (ierr.eq.0) then
!
!       SET THE MAXIMUM LAG VALUE TO BE USED.
!
        call setlag (n, lagmax)
!
!       COMPUTE THE SERIES ACVF AND SD
!
        call acvf (y1, n, y1mean, ccov(1,1,1), lagmax, 101)
        y1sd = sqrt(ccov(1,1,1) * n / (n-1))
!
        call acvf (y2, n, y2mean, ccov(1,2,2), lagmax, 101)
        y2sd = sqrt(ccov(1,2,2) * n / (n-1))
!
!       CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
       if (ccov(1,1,1)*ccov(1,2,2) .ne. 0.0e0)&
    &    call ccfmn (y1, y2, n, lagmax, 2*lagmax+1, ccov(1,1,1),&
    &     ccov(1,2,2), ccov(1,1,2), ccov(1,2,1), 101, y1mean, y2mean,&
     &     rhoc, sdrhoc, 1)
!
!       CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
       call ccfout (1, y1mean, y1sd, n, n, 2, y2mean, y2sd, n,&
    &     n, lagmax, 2*lagmax+1, rhoc, sdrhoc, .false., ndum, ndum, 1,&
     &     0.0e0, 0.0e0, .false.)
      end if
!
      if (ierr.ne.0) then
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        ierr = 1
        call iprint (iprt)
        write (iprt, 1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format(/42h the correct form of the call statement is//&
     &   27h       call ccf (y1, y2, n))
      end
!XPP
      subroutine xpp(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE PLOTTING SUBROUTINES
!
!     SERIES Y IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND
!     JENKINS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
      real(kind=wp) :: xlb,xmiss,xub,ylb,ymiss,yub
     integer&
     &   ilog,iprt,isize,itest,iym,m,nout,ny,nym
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   air(144),time(144),x(144),y(144),ym(12,12),ymmiss(144)
     integer&
     &   isym(144)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,MPP,MPPC,MPPL,MPPM,MPPMC,MPPML,PP,PPC,PPL,PPM,
!     +   PPMC,PPML,SETRV,SPP,SPPC,SPPL,SPPM,SPPMC,SPPML
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (y(1),ym(1,1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AIR(144)
!        THE AIRLINE DATA.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(144)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER ITEST
!        THE NUMBER OF THE TEST.
!     INTEGER IYM
!        ACTUAL DIMENSION OF YM IN USERS MAIN PROGRAM
!     INTEGER LDSTAK
!        *
!     INTEGER M
!        THE NUMBER OF VECTORS IN YM
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     INTEGER NY, NYM
!        THE NUMBER OF OBSERVATIONS IN ARRAYS Y AND YM, RESPECTIVELY.
!     REAL TIME(144)
!        THE TIME VALUES FOR THE AIRLINE DATA.
!     REAL X(144)
!        VECTOR OF OBSERVATIONS FOR X(HORIZONTAL) COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL Y(144)
!        VECTOR OF OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(12,12)
!        MULTIVARIATE OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES.
!     REAL YMISS
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YMMISS(144)
!        THE MISSING VALUE CODES FOR EACH COLUMN OF YM.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
     data     xmiss,    ymiss&
     &    /      7.0e0,    180.0e0/
!
     data isym(  1),isym(  2),isym(  3),isym(  4),isym(  5),isym(  6)&
     &    /    -5000,     6000,        7,        8,        9,       10/
     data isym(  7),isym(  8),isym(  9),isym( 10),isym( 11),isym( 12)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym( 13),isym( 14),isym( 15),isym( 16),isym( 17),isym( 18)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym( 19),isym( 20),isym( 21),isym( 22),isym( 23),isym( 24)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym( 25),isym( 26),isym( 27),isym( 28),isym( 29),isym( 30)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym( 31),isym( 32),isym( 33),isym( 34),isym( 35),isym( 36)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym( 37),isym( 38),isym( 39),isym( 40),isym( 41),isym( 42)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym( 43),isym( 44),isym( 45),isym( 46),isym( 47),isym( 48)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym( 49),isym( 50),isym( 51),isym( 52),isym( 53),isym( 54)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym( 55),isym( 56),isym( 57),isym( 58),isym( 59),isym( 60)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym( 61),isym( 62),isym( 63),isym( 64),isym( 65),isym( 66)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym( 67),isym( 68),isym( 69),isym( 70),isym( 71),isym( 72)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym( 73),isym( 74),isym( 75),isym( 76),isym( 77),isym( 78)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym( 79),isym( 80),isym( 81),isym( 82),isym( 83),isym( 84)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym( 85),isym( 86),isym( 87),isym( 88),isym( 89),isym( 90)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym( 91),isym( 92),isym( 93),isym( 94),isym( 95),isym( 96)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym( 97),isym( 98),isym( 99),isym(100),isym(101),isym(102)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym(103),isym(104),isym(105),isym(106),isym(107),isym(108)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym(109),isym(110),isym(111),isym(112),isym(113),isym(114)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym(115),isym(116),isym(117),isym(118),isym(119),isym(120)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym(121),isym(122),isym(123),isym(124),isym(125),isym(126)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym(127),isym(128),isym(129),isym(130),isym(131),isym(132)&
     &    /       11,       12,       13,       14,       15,       16/
     data isym(133),isym(134),isym(135),isym(136),isym(137),isym(138)&
     &    /        5,        6,        7,        8,        9,       10/
     data isym(139),isym(140),isym(141),isym(142),isym(143),isym(144)&
     &    /       11,       12,       13,       14,       15,       16/
!
     data time(  1),time(  2),time(  3),time(  4),time(  5),time(  6)&
     &    /   1.0e0,    2.0e0,    3.0e0,    4.0e0,    5.0e0,    6.0e0/
     data time(  7),time(  8),time(  9),time( 10),time( 11),time( 12)&
     &    /   7.0e0,    8.0e0,    9.0e0,   10.0e0,   11.0e0,   12.0e0/
     data time( 13),time( 14),time( 15),time( 16),time( 17),time( 18)&
     &    /  13.0e0,   14.0e0,   15.0e0,   16.0e0,   17.0e0,   18.0e0/
     data time( 19),time( 20),time( 21),time( 22),time( 23),time( 24)&
     &    /  19.0e0,   20.0e0,   21.0e0,   22.0e0,   23.0e0,   24.0e0/
     data time( 25),time( 26),time( 27),time( 28),time( 29),time( 30)&
     &    /  25.0e0,   26.0e0,   27.0e0,   28.0e0,   29.0e0,   30.0e0/
     data time( 31),time( 32),time( 33),time( 34),time( 35),time( 36)&
     &    /  31.0e0,   32.0e0,   33.0e0,   34.0e0,   35.0e0,   36.0e0/
     data time( 37),time( 38),time( 39),time( 40),time( 41),time( 42)&
     &    /  37.0e0,   38.0e0,   39.0e0,   40.0e0,   41.0e0,   42.0e0/
     data time( 43),time( 44),time( 45),time( 46),time( 47),time( 48)&
     &    /  43.0e0,   44.0e0,   45.0e0,   46.0e0,   47.0e0,   48.0e0/
     data time( 49),time( 50),time( 51),time( 52),time( 53),time( 54)&
     &    /  49.0e0,   50.0e0,   51.0e0,   52.0e0,   53.0e0,   54.0e0/
     data time( 55),time( 56),time( 57),time( 58),time( 59),time( 60)&
     &    /  55.0e0,   56.0e0,   57.0e0,   58.0e0,   59.0e0,   60.0e0/
     data time( 61),time( 62),time( 63),time( 64),time( 65),time( 66)&
     &    /  61.0e0,   62.0e0,   63.0e0,   64.0e0,   65.0e0,   66.0e0/
     data time( 67),time( 68),time( 69),time( 70),time( 71),time( 72)&
     &    /  67.0e0,   68.0e0,   69.0e0,   70.0e0,   71.0e0,   72.0e0/
     data time( 73),time( 74),time( 75),time( 76),time( 77),time( 78)&
     &    /  73.0e0,   74.0e0,   75.0e0,   76.0e0,   77.0e0,   78.0e0/
     data time( 79),time( 80),time( 81),time( 82),time( 83),time( 84)&
     &    /  79.0e0,   80.0e0,   81.0e0,   82.0e0,   83.0e0,   84.0e0/
     data time( 85),time( 86),time( 87),time( 88),time( 89),time( 90)&
     &    /  85.0e0,   86.0e0,   87.0e0,   88.0e0,   89.0e0,   90.0e0/
     data time( 91),time( 92),time( 93),time( 94),time( 95),time( 96)&
     &    /  91.0e0,   92.0e0,   93.0e0,   94.0e0,   95.0e0,   96.0e0/
     data time( 97),time( 98),time( 99),time(100),time(101),time(102)&
     &    /  97.0e0,   98.0e0,   99.0e0,  100.0e0,  101.0e0,  102.0e0/
     data time(103),time(104),time(105),time(106),time(107),time(108)&
     &    / 103.0e0,  104.0e0,  105.0e0,  106.0e0,  107.0e0,  108.0e0/
     data time(109),time(110),time(111),time(112),time(113),time(114)&
     &    / 109.0e0,  110.0e0,  111.0e0,  112.0e0,  113.0e0,  114.0e0/
     data time(115),time(116),time(117),time(118),time(119),time(120)&
     &    / 115.0e0,  116.0e0,  117.0e0,  118.0e0,  119.0e0,  120.0e0/
     data time(121),time(122),time(123),time(124),time(125),time(126)&
     &    / 121.0e0,  122.0e0,  123.0e0,  124.0e0,  125.0e0,  126.0e0/
     data time(127),time(128),time(129),time(130),time(131),time(132)&
     &    / 127.0e0,  128.0e0,  129.0e0,  130.0e0,  131.0e0,  132.0e0/
     data time(133),time(134),time(135),time(136),time(137),time(138)&
     &    / 133.0e0,  134.0e0,  135.0e0,  136.0e0,  137.0e0,  138.0e0/
     data time(139),time(140),time(141),time(142),time(143),time(144)&
     &    / 139.0e0,  140.0e0,  141.0e0,  142.0e0,  143.0e0,  144.0e0/
!
     data  air(  1), air(  2), air(  3), air(  4), air(  5), air(  6)&
     &    / 112.0e0,  118.0e0,  132.0e0,  129.0e0,  121.0e0,  135.0e0/
     data  air(  7), air(  8), air(  9), air( 10), air( 11), air( 12)&
     &    / 148.0e0,  148.0e0,  136.0e0,  119.0e0,  104.0e0,  118.0e0/
     data  air( 13), air( 14), air( 15), air( 16), air( 17), air( 18)&
     &    / 115.0e0,  126.0e0,  141.0e0,  135.0e0,  125.0e0,  149.0e0/
     data  air( 19), air( 20), air( 21), air( 22), air( 23), air( 24)&
     &    / 170.0e0,  170.0e0,  158.0e0,  133.0e0,  114.0e0,  140.0e0/
     data  air( 25), air( 26), air( 27), air( 28), air( 29), air( 30)&
     &    / 145.0e0,  150.0e0,  178.0e0,  163.0e0,  172.0e0,  178.0e0/
     data  air( 31), air( 32), air( 33), air( 34), air( 35), air( 36)&
     &    / 199.0e0,  199.0e0,  184.0e0,  162.0e0,  146.0e0,  166.0e0/
     data  air( 37), air( 38), air( 39), air( 40), air( 41), air( 42)&
     &    / 171.0e0,  180.0e0,  193.0e0,  181.0e0,  183.0e0,  218.0e0/
     data  air( 43), air( 44), air( 45), air( 46), air( 47), air( 48)&
     &    / 230.0e0,  242.0e0,  209.0e0,  191.0e0,  172.0e0,  194.0e0/
     data  air( 49), air( 50), air( 51), air( 52), air( 53), air( 54)&
     &    / 196.0e0,  196.0e0,  236.0e0,  235.0e0,  229.0e0,  243.0e0/
     data  air( 55), air( 56), air( 57), air( 58), air( 59), air( 60)&
     &    / 264.0e0,  272.0e0,  237.0e0,  211.0e0,  180.0e0,  201.0e0/
     data  air( 61), air( 62), air( 63), air( 64), air( 65), air( 66)&
     &    / 204.0e0,  188.0e0,  235.0e0,  227.0e0,  234.0e0,  264.0e0/
     data  air( 67), air( 68), air( 69), air( 70), air( 71), air( 72)&
     &    / 302.0e0,  293.0e0,  259.0e0,  229.0e0,  203.0e0,  229.0e0/
     data  air( 73), air( 74), air( 75), air( 76), air( 77), air( 78)&
     &    / 242.0e0,  233.0e0,  267.0e0,  269.0e0,  270.0e0,  315.0e0/
     data  air( 79), air( 80), air( 81), air( 82), air( 83), air( 84)&
     &    / 364.0e0,  347.0e0,  312.0e0,  274.0e0,  237.0e0,  278.0e0/
     data  air( 85), air( 86), air( 87), air( 88), air( 89), air( 90)&
     &    / 284.0e0,  277.0e0,  317.0e0,  313.0e0,  318.0e0,  374.0e0/
     data  air( 91), air( 92), air( 93), air( 94), air( 95), air( 96)&
     &    / 413.0e0,  405.0e0,  355.0e0,  306.0e0,  271.0e0,  306.0e0/
     data  air( 97), air( 98), air( 99), air(100), air(101), air(102)&
     &    / 315.0e0,  301.0e0,  356.0e0,  348.0e0,  355.0e0,  422.0e0/
     data  air(103), air(104), air(105), air(106), air(107), air(108)&
     &    / 465.0e0,  467.0e0,  404.0e0,  347.0e0,  305.0e0,  336.0e0/
     data  air(109), air(110), air(111), air(112), air(113), air(114)&
     &    / 340.0e0,  318.0e0,  362.0e0,  348.0e0,  363.0e0,  435.0e0/
     data  air(115), air(116), air(117), air(118), air(119), air(120)&
     &    / 491.0e0,  505.0e0,  404.0e0,  359.0e0,  310.0e0,  337.0e0/
     data  air(121), air(122), air(123), air(124), air(125), air(126)&
     &    / 360.0e0,  342.0e0,  406.0e0,  396.0e0,  420.0e0,  472.0e0/
     data  air(127), air(128), air(129), air(130), air(131), air(132)&
     &    / 548.0e0,  559.0e0,  463.0e0,  407.0e0,  362.0e0,  405.0e0/
     data  air(133), air(134), air(135), air(136), air(137), air(138)&
     &    / 417.0e0,  391.0e0,  419.0e0,  461.0e0,  472.0e0,  535.0e0/
     data  air(139), air(140), air(141), air(142), air(143), air(144)&
     &    / 622.0e0,  606.0e0,  508.0e0,  461.0e0,  390.0e0,  432.0e0/
!
      call setrv(ymmiss, 144, ymiss)
      call scopy(144, air, 1, y, 1)
      call scopy(144, time, 1, x, 1)
!
!     DEFINE CONSTANTS
!
      call iprint(iprt)
!
!     COMMENCE BODY OF ROUTINE
!
      itest = 0
!
!     SHORT CALLS
!
      ny = 144
      nym = 12
      iym = 12
      m = 12
      ilog = -1
      isize = -1
      nout = -1
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 0.0e0
      xub = 0.0e0
!
   10 continue
!
!     TEST OF PP
!
      write(iprt, 1000)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      call pp(y, x, ny)
      write (iprt, 3000) ierr
!
!     TEST OF PPM
!
      write(iprt, 1030)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      call ppm(y, ymiss, x, xmiss, ny)
      write (iprt, 3000) ierr
!
!     TEST OF SPP
!
      write(iprt, 1120)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      call spp(y, x, ny, isym)
      write (iprt, 3000) ierr
!
!     TEST OF SPPM
!
      write(iprt, 1150)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      call sppm(y, ymiss, x, xmiss, ny, isym)
      write (iprt, 3000) ierr
!
!     TEST OF MPP
!
      write(iprt, 1060)
      write (iprt, 3100) itest
      write (iprt, 3010) nym
      write (iprt, 3020) m, iym
      call mpp(ym, x, nym, m, iym)
      write (iprt, 3000) ierr
!
!     TEST OF MPPM
!
      write(iprt, 1090)
      write (iprt, 3100) itest
      write (iprt, 3010) nym
      write (iprt, 3020) m, iym
      call mppm(ym, ymmiss, x, xmiss, nym, m, iym)
      write (iprt, 3000) ierr
!
!
!     LOG OPTION CALLS
!
!
   20 continue
!
!     TEST OF PPL
!
      write(iprt, 1010)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3040) ilog
      call ppl(y, x, ny, ilog)
!
      write (iprt, 3000) ierr
!
!     TEST OF PPML
!
      write(iprt, 1040)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3040) ilog
      call ppml(y, ymiss, x, xmiss, ny, ilog)
      write (iprt, 3000) ierr
!
!     TEST OF SPPL
!
      write(iprt, 1130)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3040) ilog
      call sppl(y, x, ny, isym, ilog)
      write (iprt, 3000) ierr
!
!     TEST OF SPPML
!
      write(iprt, 1160)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3040) ilog
      call sppml(y, ymiss, x, xmiss, ny, isym, ilog)
      write (iprt, 3000) ierr
!
!     TEST OF MPPL
!
      write(iprt, 1070)
      write (iprt, 3100) itest
      write (iprt, 3010) nym
      write (iprt, 3020) m, iym
      write (iprt, 3040) ilog
      call mppl(ym, x, nym, m, iym, ilog)
      write (iprt, 3000) ierr
!
!     TEST OF MPPML
!
      write(iprt, 1100)
      write (iprt, 3100) itest
      write (iprt, 3010) nym
      write (iprt, 3020) m, iym
      write (iprt, 3040) ilog
      call mppml(ym, ymmiss, x, xmiss, nym, m, iym, ilog)
      write (iprt, 3000) ierr
!
!
!     TEST OF LONG CALLS
!
!
   30 continue
!
!     TEST OF PPC
!
      write(iprt, 1020)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3040) ilog
      write (iprt, 3050) isize, nout
      write (iprt, 3070) ylb, yub, xlb
      write (iprt, 3080) xub
      call ppc(y, x, ny, ilog, isize, nout, ylb, yub, xlb, xub)
      write (iprt, 3000) ierr
!
!     TEST OF PPMC
!
      write(iprt, 1050)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3040) ilog
      write (iprt, 3050) isize, nout
      write (iprt, 3070) ylb, yub, xlb
      write (iprt, 3080) xub
     call ppmc(y, ymiss, x, xmiss, ny, ilog, isize, nout, ylb, yub,&
     &   xlb, xub)
      write (iprt, 3000) ierr
!
!     TEST OF SPPC
!
      write(iprt, 1140)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3040) ilog
      write (iprt, 3050) isize, nout
      write (iprt, 3070) ylb, yub, xlb
      write (iprt, 3080) xub
     call sppc(y, x, ny, isym, ilog, isize, nout, ylb, yub, xlb,&
     &   xub)
      write (iprt, 3000) ierr
!
!     TEST OF SPPMC
!
      write(iprt, 1170)
      write (iprt, 3100) itest
      write (iprt, 3010) ny
      write (iprt, 3040) ilog
      write (iprt, 3050) isize, nout
      write (iprt, 3070) ylb, yub, xlb
      write (iprt, 3080) xub
     call sppmc(y, ymiss, x, xmiss, ny, isym, ilog, isize, nout,&
     &   ylb, yub, xlb, xub)
      write (iprt, 3000) ierr
!
!     TEST OF MPPC
!
   40 write(iprt, 1080)
      write (iprt, 3100) itest
      write (iprt, 3010) nym
      write (iprt, 3020) m, iym
      write (iprt, 3040) ilog
      write (iprt, 3050) isize, nout
      write (iprt, 3070) ylb, yub, xlb
      write (iprt, 3080) xub
     call mppc(ym, x, nym, m, iym, ilog, isize, nout, ylb, yub,&
     &   xlb, xub)
      write (iprt, 3000) ierr
!
!     TEST OF MPPMC
!
   50 write(iprt, 1110)
      write (iprt, 3100) itest
      write (iprt, 3010) nym
      write (iprt, 3020) m, iym
      write (iprt, 3040) ilog
      write (iprt, 3050) isize, nout
      write (iprt, 3070) ylb, yub, xlb
      write (iprt, 3080) xub
     call mppmc(ym, ymmiss, x, xmiss, nym, m, iym, ilog, isize, nout,&
     &   ylb, yub, xlb, xub)
      write (iprt, 3000) ierr
!
      itest = itest + 1
!
     go to (110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 300),&
     &  itest
!
!     TEST VALID OPTIONS
!
  110 ilog = 0
      isize = 0
      nout = 0
      ylb = 100.0e0
      yub = 700.0e0
      xlb = 4.0e0
      xub = 16.0e0
      go to 20
!
  120 ilog = 2
      isize = 2
      nout = 5
      go to 20
!
  130 ilog = 20
      isize = 20
      nout = 55
      yub = 300.0e0
      go to 30
!
  140 ilog = 22
      isize = 22
      go to 40
!
  150 ny = 1
      nym = 1
      m = 144
      iym = 1
      x(1) = 10.0e0
      go to 40
!
  160 call setrv(y, 144, 1.0e0)
      call setrv(x, 144, 1.0e0)
      nym = 6
      iym = 12
      m = 6
      ny = 36
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 0.0e0
      xub = 0.0e0
      go to 30
!
!     TEST ERROR RESPONSE
!
  170 ny = 0
      nym = 0
      m = 0
      iym = -1
      go to 10
!
  180 ny = 144
      nym = 12
      m = 12
      iym = -1
      xlb = -1.0e0
      ylb = -1.0e0
      go to 40
!
  190 iym = 12
      x(1) = 0.0e0
      y(1) = 0.0e0
      go to 50
!
  200 call setrv(x, 144, xmiss)
      call setrv(y, 144, ymiss)
      xlb = xub
      ylb = yub
      go to 50
!
  300 continue
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format ('1', 10htest of pp)
 1010 format ('1', 11htest of ppl)
 1020 format ('1', 11htest of ppc)
 1030 format ('1', 11htest of ppm)
 1040 format ('1', 12htest of ppml)
 1050 format ('1', 12htest of ppmc)
 1060 format ('1', 11htest of mpp)
 1070 format ('1', 12htest of mppl)
 1080 format ('1', 12htest of mppc)
 1090 format ('1', 12htest of mppm)
 1100 format ('1', 13htest of mppml)
 1110 format ('1', 13htest of mppmc)
 1120 format ('1', 11htest of spp)
 1130 format ('1', 12htest of sppl)
 1140 format ('1', 12htest of sppc)
 1150 format ('1', 12htest of sppm)
 1160 format ('1', 13htest of sppml)
 1170 format ('1', 13htest of sppmc)
 3000 format (/8h ierr = , i4)
 3010 format (' ', 5x, 10h   n     =, i5)
 3020 format ('+', 20x, 10h / m     =, i5, 10h / iym   =, i5)
 3040 format ('+', 65x, 10h / ilog  =, i5)
 3050 format (' ',  5x, 10h   isize =, i5, 10h / nout  =, i5)
3070 format ('+', 50x, 10h / ylb   =, f10.4, 10h / yub   =, f10.4,&
     &   10h / xlb   =, f10.4)
 3080 format ('+', 110x, 10h / xub   =, f10.4)
 3100 format (' ', 13h test number , i5)
      end
!NLSWDC
     subroutine nlswdc(y, wt, xm, n, m, ixm, mdl, drv, par, npar, res,&
    &   ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING ANALYTIC DERIVATIVES, WEIGHTS, AND
!     USER SUPPLIED CONTROL PARAMETERS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,stopp,stopss
     integer&
     &   idrvck,ivaprx,ixm,ldstak,m,mit,n,npar,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),res(*),scale(*),wt(*),xm(*),y(*)
     integer&
     &   ifixed(*)
!
!  SUBROUTINE ARGUMENTS
       external drv,mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   iprt,ivcv,lifixd,lpv,lscale,lsdpv,lsdres,lwt,nnzw,npare
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   pv(1),sdpv(1),sdres(1),vcv(1,1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,NLCNTA
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
!        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF IFIXED(I).EQ
!        THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(NPAR)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE-COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(N)
!        THE WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'N','L','S','W','D','C'/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      weight = .true.
      save = .false.
!
      lifixd = npar
      lpv = 1
      lscale = npar
      lsdpv = 1
      lsdres = 1
      lwt = n
      ivcv = 1
!
     call nlcnta(y, wt, lwt, xm, n, m, ixm, mdl, drv, par, npar, res,&
    &   ldstak, ifixed, lifixd, idrvck, mit, stopss, stopp, scale,&
    &   lscale, delta, ivaprx, nprt, rsd, pv, lpv, sdpv, lsdpv, sdres,&
     &   lsdres, vcv, ivcv, nmsub, weight, save, nnzw, npare)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL NLSWDC (Y, WT, XM, N, M, IXM, NLSMDL, NLSDRV,'/&
    &   '      +             PAR, NPAR, RES, LDSTAK,'/&
    &   '      +             IFIXED, IDRVCK, MIT, STOPSS, STOPP,'/&
     &   '      +             SCALE, DELTA, IVAPRX, NPRT)')
      end
!SPCCK
      subroutine spcck (spc, isort, nf, spcmn, spcmx, nspc, ispcer)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE ANALYZES THE ORDINATES FOR THE SPECTRAL SEMI LOG
!     PLOTS PRODUCED BY THE ASPC SERIES OF ROUTINES.  Y AXIS VALUES
!     (YORD) MORE THAN 3 POWERS OF TEN LESS THAN THE NEXT LARGER
!     VALUE ARE CONSIDERED INSIGNIFICANT AND ARE CULLED FROM THE
!     ORDINATES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   spcmn,spcmx
     integer&
     &   ispcer,nf,nspc
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   spc(nf)
     integer&
     &   isort(nf)
!
!  LOCAL SCALARS
     integer&
     &   i,k1,k2,log1,log2
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL SRTIR,SRTRI
!
!  INTRINSIC FUNCTIONS
      intrinsic log10
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER ISORT(NF)
!        THE ARRAY IN WHICH THE ORDER PERMUTATION FOR THE SORTED
!        DATA IS STORED.
!     INTEGER ISPCER
!        AN INDICATOR VARIABLE USED TO SUPRESS THE SPECTRAL PLOTS
!        WHEN FEWER THAN 1 VALID SPECTRAL VALUES WERE COMPUTED.
!     INTEGER K1, K2
!        INDEX VARIABLES.
!     INTEGER LOG1, LOG2
!        THE ORDER OF THE SPECTRAL ESTIMATES.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
!        ARE TO BE ESTIMATED.
!     INTEGER NSPC
!        THE NUMBER OF VALID SPECTRAL ESTIMATES.
!     REAL SPC(NF)
!        THE ARRAY CONTAINING THE SPECTRAL ESTIMATES.
!     REAL SPCMN, SPCMX
!        THE MINIMUM AND MAXIMUM SPECTRAL VALUE TO BE PLOTTED.
!
!     ORDER THE SPECTRAL ESTIMATES FROM SMALLEST TO LARGEST.
!
      do 10 i = 1, nf
         isort(i) = i
   10 continue
      call srtir (isort, nf, spc)
!
!     DETERMINE SIGINIFICANT VALUES TO BE PLOTTED.
!
      k1 = nf
      k2 = k1
      if ((spc(nf) .le. 0.0e0) .or. (nf.eq.1)) go to 30
      log1 = log10(spc(nf))
      if (spc(nf) .lt. 1.0e0) log1 = log1 - 1
      do 20 i = 2, nf
         k2 = k1 - 1
         if (spc(k2) .le. 0.0e0) go to 30
         log2 = log10(spc(k2))
         if (spc(k2) .lt. 1.0e0) log2 = log2 - 1
         if (log1-log2 .ge. 3 .and. nf-k2 .ge. 5) go to 30
         log1 = log2
         k1 = k2
   20 continue
!
   30 spcmn = spc(k1)
      nspc = nf + 1 - k1
!
      spcmx = spc(nf)
!
      call srtri (spc, nf, isort)
      ispcer = 0
      if (nf-k2 .le. 0) ispcer = 1
!
      return
      end
!IPGMS
     subroutine ipgms (yfft, n, lyfft, ldstak, nf, peri, lperi, freq,&
     &   lfreq, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
!     THE INTEGRATED PERIODOGRAM OF A SERIES (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,lfreq,lperi,lyfft,n,nf,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(*),peri(*),yfft(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iextnd,iprt,isym,ldsmin,lpcv,nall0,nfft,xaxis,yaxis
     logical&
     &   err01,err02,err03,err04,err05,head
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     character&
    &   llds(8)*1,llfreq(8)*1,llperi(8)*1,llyfft(8)*1,ln(8)*1,&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL CNTR,EISGE,IPGDV,IPRINT,LDSCMP,PGMMN,SETESL,STKCLR,STKSET
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     REAL FREQ(LFREQ)
!        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
!        INTEGRATED SPECTRUM VALUES ARE STORED.
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IEXTND
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
!        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
!        USED TO EXTEND THE SERIES.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LFREQ
!        THE LENGTH OF THE VECTOR FREQ.
!     CHARACTER*1 LLDS(8), LLFREQ(8), LLPERI(8), LLYFFT(8), LN(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LPERI
!        THE LENGTH OF THE VECTOR PERI.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING ALLOCATIONS OF THE STACK AT THE
!        TIME OF THIS CALL.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A PAGE PLOT.
!     REAL PERI(LPERI)
!        THE VECTOR IN WHICH THE INTEGRATED PERIODOGRAM IS STORED.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE X AXIS VALUES TO BE PLOTTED ARE STORED.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
!     REAL YFFT(LYFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'I',       'P',       'G',       'M',       'S',       ' '/
     data&
    & llfreq(1), llfreq(2), llfreq(3), llfreq(4), llfreq(5),&
    &  llfreq(6), llfreq(7), llfreq(8)&
     &  /'L','F','R','E','Q',' ',' ',' '/
     data&
    & llds(1), llds(2), llds(3), llds(4), llds(5),&
     &  llds(6), llds(7), llds(8) /'L','D','S','T','A','K',' ',' '/
     data&
    & llperi(1), llperi(2), llperi(3), llperi(4), llperi(5),&
    &  llperi(6), llperi(7), llperi(8)&
     &  /'L','P','E','R','I',' ',' ',' '/
     data&
    & llyfft(1), llyfft(2), llyfft(3), llyfft(4), llyfft(5),&
    &  llyfft(6), llyfft(7), llyfft(8)&
     &  /'L','Y','F','F','T',' ',' ',' '/
     data&
    & ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /'N',' ',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 17, 1, head, err01, ln)
      if (err01) go to 5
!
!     SET LENGTH OF EXTENDED SERIES
!
      call setesl(n, 2, nfft)
      nf = nfft/2
!
      call eisge(nmsub, llyfft, lyfft, nfft, 9, head, err02, llyfft)
!
      call eisge(nmsub, llperi, lperi, nf, 9, head, err03, llperi)
!
      call eisge(nmsub, llfreq, lfreq, nf, 9, head, err04, llfreq)
!
      if (nprt .eq. 0) then
        ldsmin = 0
      else
        call ldscmp(3, 0, nf+103, 0, 0, 0, 'S', 2*nfft+206, ldsmin)
      end if
!
      call eisge(nmsub, llds, ldstak, ldsmin, 9, head, err05, llds)
!
      if (err02 .or. err03 .or. err04 .or. err05) go to 5
      go to 10
!
    5 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   10 continue
!
!     SET THE SIZE OF THE WORK AREA
!
      call stkset(ldstak, 4)
!
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!
      nall0 = stkst(1)
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      lpcv = nf + 103
!
!     CENTER THE SERIES
!
      call cntr(yfft, n, yfft)
      iextnd = 0
!
!     SUBDIVIDE THE STACK.
!
      if (nprt .eq. 0) then
         isym = 1
         xaxis = 1
         yaxis = 1
      else
         isym = stkget(lpcv, 2)
         xaxis = stkget(lpcv, 3)
         yaxis = stkget(lpcv, 3)
      end if
!
!     COMPUTE THE RAW PERIODOGRAM.
!
     call pgmmn (yfft, n, nfft, iextnd, nf, peri, lperi, rstak(yaxis),&
     &   freq, lfreq, 0, nmsub)
!
!     CALL THE MAIN DRIVER FOR COMPUTING (AND PLOTTING) THE INTEGRATED
!     PERIODOGRAM.
!
     call ipgdv (peri, nf, n, peri, freq, rstak(xaxis),&
     &   rstak(yaxis), istak(isym), lpcv, nprt)
!
      call stkclr(nall0)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &  '       CALL IPGMS (YFFT, N, LYFFT, LDSTAK,'/&
     &  '      +            NF, PERI, LPERI, FREQ, LFREQ, NPRT)')
      end
!ACVFF
     subroutine acvff (yfft, n, nfft, ymean, acov, lagmax, lacov,&
     &   lyfft, work, lwork)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE ACVF OF A SERIES USING TWO
!     PASSES OF A FFT.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ymean
     integer&
     &   lacov,lagmax,lwork,lyfft,n,nfft
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(*),work(*),yfft(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fac
     integer&
     &   i,isn,n1,nf,nfft2
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL AMEAN,FFT,FFTCT,REALTR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV)
!        THE ARRAY IN WHICH THE AUTOCOVARIANCES ARE STORED
!     REAL FAC
!        A FACTOR USED IN THE COMPUTATIONS.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER ISN
!        AN INDICATOR VARIABLE USED BY THE FFT ROUTINES.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG TO BE USED.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NF
!        THE NUMBER OF FOURIER FREQUENCIES.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NFFT2
!        THE EFFECTIVE NUMBER OF OBSERVATIONS FOR THE FFT TRANSFORM.
!     INTEGER N1
!        THE VALUE N + 1.
!     REAL WORK(LWORK)
!        THE WORK AREA FOR THE COMPUTATIONS.
!     REAL YFFT(LYFFT)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!     COMPUTE ARITHMETIC MEAN
!
      call amean(yfft, n, ymean)
!
!     SUBTRACT THE MEAN FROM THE SERIES
!
      do 10 i = 1, n
         yfft(i) = yfft(i) - ymean
   10 continue
!
!     APPEND ZEROS
!
      n1 = n + 1
!
      do 20 i = n1, nfft
         yfft(i) = 0.0e0
   20 continue
!
!     COMPUTE AUTOCOVARIANCES.
!
      isn = 2
      nfft2 = (nfft - 2)/ 2
!
      call fft(yfft(1), yfft(2), nfft2, nfft2, nfft2, isn)
      call realtr (yfft(1), yfft(2), nfft2, isn)
!
      nf = nfft2 + 1
!
      do 30 i = 1, nf
         work(i) = yfft(2*i-1)*yfft(2*i-1) + yfft(2*i)*yfft(2*i)
   30 continue
!
      call fftct (work, nfft2, lwork)
!
      fac = 1.0e0 / (4 * (nfft - 2) * n)
!
      acov(1) = work(1) * fac
!
      do 40 i = 1, lagmax
         acov(i+1) = work(i+1) * fac
   40 continue
!
      return
      end
!UASFS
     subroutine uasfs (yfft, n, lyfft, ldstak, iar, phi, lagmax, lag,&
     &  nf, fmin, fmax, nprt, spca, spcf, freq)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
!     SPECTRUM ESTIMATION USING THE FFT (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fmax,fmin
     integer&
     &   iar,lag,lagmax,ldstak,lyfft,n,nf,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(*),phi(*),spca(*),spcf(*),yfft(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta,fmn,fmx,var,ymean
     integer&
    &   acov,aic,ftest,ia,ifp,io,iprt,isort,isym,lacov,laic,&
     &   ldsmin,lpcv,lphi,lspc,lwork,nall0,nfft,work,xaxis,yaxis
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACVFF,AMEAN,IPRINT,LDSCMP,PARZEN,SETESL,STKCLR,STKSET,
!     +   UASDV,UASER,UASVAR
!
!  INTRINSIC FUNCTIONS
      intrinsic max,min
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER ACOV
!        THE STARTING LOCATION IN RSTAK FOR THE ARRAY OF
!        THE AUTOCOVARIANCE ARRAY.
!     INTEGER AIC
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY CONTAINING THE AIC.
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
!        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
!     REAL FMN, FMX
!        THE MAXIMUM AND MINIMUM FREQUENCY ACTUALLY USED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     INTEGER FTEST
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IA
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON WHETHER OR NOT THE MODEL ORDER IS TO BE SELECTED OR
!        HAS BEEN PROVIDED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION IN ISTAK FOR
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN ISTAK FOR
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE COVARIANCE ARRAYS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE ARRAY AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER LSPC
!         THE LENGTH OF THE SPECTRUM ARRAYS.
!     INTEGER LWORK
!        THE ACTUAL LENGTH OF THE WORK ARRAY.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS OUTSTANDING WHEN THIS ROUTINE
!        WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
!        ARE TO BE ESTIMATED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE TYPE OF WINDOW TO BE USED.
!     REAL PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL SPCA(NF)
!        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!     REAL SPCF(NF)
!        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
!     REAL VAR
!        THE ONE STEP PREDICTION VARIANCE.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE STACK FOR
!        THE WORK ARRAY.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN RSTAK FOR
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN RSTAK FOR
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL YFFT(LYFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'U',       'A',       'S',       'F',       'S',       ' '/
!
      ifp = 3
!
!     SET UP FOR ERROR CHECKING
!
      option(1) = .true.
      option(2) = .false.
      option(3) = .false.
      option(4) = .true.
!
!     SET EXTENDED SERIES LENGTH
!
      call setesl(n+lagmax, 4, nfft)
!
      io = 1
      if (nprt .eq. 0) io = 0
      ia = 1
      if (iar .ne. 0) ia = 0
!
     call ldscmp(7, 0, io*(2*nf+5), 0, 0, 0, 'S',&
     &   lagmax+1+nfft+ia*(3*lagmax+1)+io*(4*nf+10), ldsmin)
!
     call uaser(nmsub, n, yfft, iar, phi, lagmax, lag, lacov,&
     &   nf, ldstak, ldsmin, lyfft, nfft, option)
!
    5 if (ierr.ne.0) then
         ierr = 1
         call iprint (iprt)
         write (iprt, 1000)
         return
      end if
!
!     SET SIZE OF WORK AREA.
!
      call stkset (ldstak, 4)
!
!     SAVE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
!
      nall0 = stkst(1)
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      lspc = nf
      lpcv = 2*nf + 5
      lphi = lagmax
      lacov = lagmax + 1
      lwork = nfft
!
      fmn = max(fmin, 0.0e0)
      fmx = min(fmax, 0.5e0)
      if (fmn.ge.fmx) then
        fmn = 0.0e0
        fmx = 0.5e0
      end if
!
      alpha = 0.95e0
      delta = 1.0e0
!
      if (iar.ge.1) then
!
!     USER HAS CHOSEN ORDER AND SUPPLIED COEFFICIENTS.
!     COMPUTE RESIDUAL VARIANCE.
!
         call amean(yfft, n, ymean)
         call uasvar (yfft, ymean, n, iar, phi, var)
      end if
!
!     COMPUTE AUTOCOVARIANCES
!
      acov = stkget(lacov, ifp)
      work = stkget(lwork, ifp)
!
     call acvff (yfft, n, nfft, ymean, rstak(acov), lagmax, lagmax+1,&
     &   lyfft, rstak(work), nfft)
!
!     SET UP ADDITIONAL STACK WORK AREA, IF NEEDED.
!
      if (iar.eq.0) then
         laic = lagmax+1
         aic = stkget(laic, ifp)
         ftest = stkget(2*lagmax, ifp)
      else
         laic = lwork
         aic = work
         ftest = work
      end if
      if (nprt.ne.0) then
         xaxis = stkget(lpcv, ifp)
         yaxis = stkget(lpcv, ifp)
         isym = stkget(lpcv, 2)
         isort = isym
      else
         xaxis = work
         yaxis = work
         isym = work
         isort = work
      end if
!
      if (ierr.eq.1) go to 5
!
!     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
!
     call uasdv(rstak(acov), spca, spcf, lspc, iar, phi, nf, fmn,&
    &   fmx, freq, n, lagmax, rstak(ftest), rstak(aic), rstak(work),&
    &   lacov, lwork, delta, istak(isort), istak(isym), rstak(xaxis),&
    &   rstak(yaxis), lpcv, alpha, lag, laic, lphi, nprt, var, parzen,&
     &   nmsub)
!
      call stkclr(nall0)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    & '       CALL UASFS (YFFT, N, LYFFT, LDSTAK,'/&
    & '      +            IAR, PHI, LAGMAX, LAG, NF, FMIN, FMAX, NPRT'/&
     & '      +            SPCA, SPCF, FREQ)')
      end
!ACVF
      subroutine acvf (y, n, ymean, acov, lagmax, lacov)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE AUTOCOVARIANCE FUNCTION OF A SERIES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ymean
     integer&
     &   lacov,lagmax,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(*),y(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   dotxy,dotyy
     integer&
     &   lag,ndotxy,ndotyy
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL AMEAN,DOTC
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV)
!        THE ARRAY IN WHICH THE AUTOCOVARIANCES ARE STORED
!     REAL DOTXY, DOTYY
!        THE DOT PRODUCT BETWEEN VECTORS (Y(I) - YMEAN)) AND
!        (Y(LAG) - YMEAN)), AND (Y(I) - YMEAN)) AND (Y(I) - YMEAN)),
!        RESPECTIVELY.
!     INTEGER LACOV
!        THE ACTUAL DIMENSION OF ACOV.
!     INTEGER LAG, LAGMAX
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCOVARIANCE BEING COMPUTED AND THE MAXIMUM LAG TO BE USED,
!        RESPECTIVELY.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NDOTXY, NDOTYY
!        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY AND
!        DOTYY, RESPECTIVELY.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!     COMPUTE ARITHMETIC MEAN
!
      call amean(y, n, ymean)
!
!     COMPUTE THE VARIANCE OF THE SERIES Y
!
      call dotc (y, ymean, n, y, ymean, n, dotyy, ndotyy)
      acov(1) = dotyy / ndotyy
!
!     COMPUTE AUTOCOVARIANCES.
!
      do 10 lag = 1, lagmax
        call dotc (y, ymean, n, y(lag+1), ymean, n - lag,&
     &       dotxy, ndotxy)
         acov(lag + 1) = dotxy / n
   10 continue
!
      return
      end
!NLISM
     subroutine nlism (nlhdr, page, wide, hlfrpt, npar, m, n, nnzw,&
    &   weight, ifixd, par, scale, iwork, iiwork, rwork, irwork, res,&
     &   aprxdv, stp, lstp, npare)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS AN INITIAL SUMMARY OF THE STARTING
!     ESTIMATES AND THE CONTROL PARAMETERS FOR THE NONLINEAR
!     LEAST SQUARES SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iiwork,irwork,lstp,m,n,nnzw,npar,npare
     logical&
     &   aprxdv,hlfrpt,page,weight,wide
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),res(n),rwork(irwork),scale(npar),stp(lstp)
     integer&
     &   ifixd(npar),iwork(iiwork)
!
!  SUBROUTINE ARGUMENTS
       external nlhdr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   rsd,rss
     integer&
     &   i,iprt,isubhd,lmax0,mxfcal,mxiter,rfctol,xctol
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   SNRM2
!      EXTERNAL SNRM2
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic real,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IIWORK
!        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IRWORK
!        THE DIMENSION OF THE REAL WORK VECTOR RWORK.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IWORK(IIWORK)
!        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER LMAX0
!        THE LOCATION IN RWORK OF THE VALUE INDICATING THE
!        MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MXFCAL
!        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
!        MAXIMUM NUMBER OF FUNCTION CALLS ALLOWED, EXCLUDING
!        CALLS NECESSARY TO COMPUTE THE DERIVATIVES AND COVARIANCE
!        MATRIX.
!     INTEGER MXITER
!        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
!        MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     EXTERNAL NLHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        NUMBER OF PARAMETERS ESTIMATED BY ROUTINE.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     INTEGER RFCTOL
!        THE LOCATION IN RWORK OF THE RELATIVE FUNCTION CONVERGENCE
!        TOLERANCE.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION AT THE INITIAL PARAMETER VALUES
!     REAL RSS
!        THE RESIDUAL SUM OF SQUARES AT THE INITIAL PARAMETER VALUES
!     REAL RWORK(IRWORK)
!        THE REAL WORK VECTOR USED BY THE NL2 SUBROUTINES.
!     REAL SCALE(NPAR)
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     REAL STP(LSTP)
!        THE SELECTED RELATIVE STEP SIZES.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!       THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        FULL WIDTH (TRUE) OR NOT (FALSE).
!     INTEGER XCTOL
!        THE LOCATION IN RSTAK/DSTAK OF THE P CONVERGENCE TOLERANCE.
!
!     IWORK SUBSCRIPT VALUES
!
      data mxfcal/17/, mxiter/18/
!
!     RWORK SUBSCRIPT VALUES
!
      data lmax0/35/, rfctol/32/, xctol/33/
!
      call iprint(iprt)
!
      if (.not.hlfrpt) then
!
         isubhd = 1
         call nlhdr(page, wide, isubhd)
!
         if (aprxdv) then
            write (iprt, 1260)
         else
            write (iprt, 1270)
         end if
!
         do 40 i = 1, npar
            if (ifixd(i).eq.0) then
               if (scale(1).gt.0.0e0) then
                  if (aprxdv) then
                     write (iprt, 1410) i, par(i), scale(i), stp(i)
                  else
                     write (iprt, 1410) i, par(i), scale(i)
                  end if
               else
                  if (aprxdv) then
                     write (iprt, 1310) i, par(i), stp(i)
                  else
                     write (iprt, 1310) i, par(i)
                  end if
               end if
            else
               if (aprxdv) then
                  write (iprt, 1510) i, par(i)
               else
                  write (iprt, 1610) i, par(i)
               end if
            end if
   40    continue
!
         write (iprt, 1160) n
!
      end if
!
      if (weight) write (iprt, 1170) nnzw
      write (iprt, 1180) m
      write(iprt, 1070) iwork(mxiter)
      write(iprt, 1090) iwork(mxfcal)
      write(iprt, 1080)
      write(iprt, 1100) rwork(rfctol)
      write(iprt, 1110) rwork(xctol)
      write(iprt, 1120) rwork(lmax0)
!
      rsd = snrm2(n, res, 1)
      rss = rsd * rsd
      if (nnzw-npare.ge.1) rsd = rsd /sqrt(real(nnzw-npare))
      write (iprt, 1200) rss
      write (iprt, 1210) rsd
!
      return
!
!     FORMAT STATEMENTS
!
1070 format (/37h maximum number of iterations allowed, 32x, 5h(mit),&
     &   1x, i5)
 1080 format(/44h convergence criterion for test based on the/)
1090 format(/41h maximum number of model subroutine calls,&
     &   8h allowed, 26x, i5)
1100 format (5x, 39h forecasted relative change in residual,&
     &   15h sum of squares, 7x, 8h(stopss), 1x, g11.4)
1110 format(5x, 49h maximum scaled relative change in the parameters,&
     &   13x, 7h(stopp), 1x, g11.4)
1120 format(//41h maximum change allowed in the parameters,&
     &   23h at the first iteration, 3x, 7h(delta), 1x, g11.4)
 1160 format (/23h number of observations, 48x, 3h(n), 1x, i5)
1170 format (/41h number of non zero weighted observations, 27x,&
     &   6h(nnzw), 1x, i5)
 1180 format (/32h number of independent variables, 39x, 3h(m), 1x, i5)
1200 format (/44h residual sum of squares for input parameter,&
     &   7h values, 24x, g11.4)
1210 format (/48h residual standard deviation for input parameter,&
     &   7h values, 14x, 5h(rsd), 1x, g11.4)
1260 format (//50x, 13hstep size for/&
    &   50x, 13happroximating/&
    &   7x, 24hparameter starting value, 6x, 5hscale, 10x,&
    &   10hderivative/&
    &   1x, 5hindex, 2x, 5hfixed, 6x, 5h(par), 12x, 7h(scale), 11x,&
     &   5h(stp)/)
1270 format (//6x, 25hparameter starting values, 5x, 5hscale/&
     &   1x, 5hindex, 2x, 5hfixed, 6x, 5h(par), 11x, 7h(scale)/)
 1310 format (1x, i3, 5x, ' NO', g17.8, 7x, 7hdefault, 3x, g17.8)
 1410 format (1x, i3, 5x, ' NO', 3g17.8)
 1510 format (1x, i3, 5x, 'YES', g17.8, 9x, '---', 14x, '---')
 1610 format (1x, i3, 5x, 'YES', g17.8, 9x, '---')
      end
!NLSW
      subroutine nlsw(y, wt, xm, n, m, ixm, mdl, par, npar, res, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
!     AND WEIGHTS (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,ldstak,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),res(*),wt(*),xm(*),y(*)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
    &   iprt,ivaprx,ivcv,lifixd,lpv,lscale,lsdpv,lsdres,lstp,lwt,&
     &   mit,nnzw,npare,nprt
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   pv(1),scale(1),sdpv(1),sdres(1),stp(1),vcv(1,1)
     integer&
     &   ifixed(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,NLCNTN
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(1)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(1)
!        THE STEP SIZE ARRAY.
!     REAL VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(N)
!        THE WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'N','L','S','W',' ',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      weight = .true.
      save = .false.
!
      stp(1) = -1.0e0
      mit = -1
      stopss = -1.0e0
      stopp = -1.0e0
      scale(1) = -1.0e0
      delta = -1.0e0
      nprt = -1
      ifixed(1) = -1
      ivaprx = 0
      lifixd = 1
      lpv = 1
      lstp = 1
      lscale = 1
      lsdpv = 1
      lsdres = 1
      lwt = n
      ivcv = 1
!
     call nlcntn(y, wt, lwt, xm, n, m, ixm, mdl, par, npar, res,&
    &   ldstak, ifixed, lifixd, stp, lstp, mit, stopss, stopp, scale,&
    &   lscale, delta, ivaprx, nprt, rsd, pv, lpv, sdpv, lsdpv, sdres,&
     &   lsdres, vcv, ivcv, nmsub, weight, save, nnzw, npare)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL NLSW (Y, WT, XM, N, M, IXM, NLSMDL,'/&
     &   '      +           PAR, NPAR, RES, LDSTAK)')
      end
!PP
      subroutine pp(ym, x, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT (SHORT CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xlb,xmiss,xub,ylb,yub
     integer&
     &   ilog,iprt,ischck,isize,iym,lisym,m,nout
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ymmiss(1)
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'P',       'P',       ' ',       ' ',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      ymmiss(1) = 1.0e0
      xmiss = 1.0e0
      m = 1
      iym = n
      multi = .false.
      ilog = -1
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 0.0e0
      xub = 0.0e0
      ischck = 0
      isize = -1
      nout = 0
      miss = .false.
      lisym = 1
!
     call ppcnt (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL PP (Y, X, N)')
      end
!FFTR
      subroutine fftr (yfft, n, nfft, iextnd, nf, ab, lab)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
!     THE FOURIER TRANSFORM OF A SERIES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iextnd,lab,n,nf,nfft
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ab(*),yfft(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   yextnd
     integer&
     &   i,iprt,isn,n1,nfft1,nfft2
     logical&
     &   err01,err02,err03,head
!
!  LOCAL ARRAYS
     character&
     &   llab(8)*1,ln(8)*1,nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AMEAN,EISGE,ENFFT,FFT,IPRINT,REALTR
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AB(LAB)
!        THE VECTOR OF THE NF REAL AND IMAGINARY COMPONENTS OF THE
!        FOURIER COEFFICIENTS.
!     LOGICAL ERR01, ERR02, ERR03
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IEXTND
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
!        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
!        USED TO EXTEND THE SERIES.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER LAB
!        THE LENGTH OF THE VECTOR AB.
!     CHARACTER*1 LLAB(8), LN(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS.
!     INTEGER N1
!        THE VALUE N+1.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
!     INTEGER NFFT1
!        THE EFFECTIVE SERIES LENGTH ACTUALLY USED.
!     INTEGER NFFT2
!        THE EFFECTIVE LENGTH OF THE SERIES STORED AS A COMPLEX
!        VARIABLE.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     REAL YEXTND
!        THE VALUE USED TO EXTEND THE SERIES.
!     REAL YFFT(N)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'F',       'F',       'T',       'R',       ' ',       ' '/
     data&
    &   llab(1),   llab(2),   llab(3),   llab(4),   llab(5),   llab(6)&
     & /     'L',       'A',       'B',       ' ',       ' ',       ' '/
     data&
    &   llab(7),   llab(8)&
     & /     ' ',       ' '/
     data&
    &     ln(1),     ln(2),     ln(3),     ln(4),     ln(5),     ln(6)&
     & /     'N',       ' ',       ' ',       ' ',       ' ',       ' '/
     data&
    &     ln(7),     ln(8)&
     & /     ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 17, 1, head, err01, ln)
      if (err01) go to 5
!
      call enfft(nmsub, nfft, 2, n, lab, nfft1, head, err02) !LN
      nf = nfft1/2
!
      call eisge(nmsub, llab, lab, nfft1, 9, head, err03, llab)
!
      if (err02 .or. err03) go to 5
      go to 10
!
    5 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   10 continue
!
!     COPY THE INPUT SERIES TO AB, EXTENDING APPROPRIATELY.
!
      yextnd = 0.0e0
      if (iextnd .ne. 0) call amean (yfft, n, yextnd)
!
      do 20 i = 1, n
         ab(i) = yfft(i)
   20 continue
!
      n1 = n+1
      do 30 i = n1, nfft1
         ab(i) = yextnd
   30 continue
!
      nfft2 = (nfft1-2) / 2
      isn = 2
!
      call fft (ab(1), ab(2), nfft2, nfft2, nfft2, isn)
      call realtr (ab(1), ab(2), nfft2, isn)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   53h       call fftr (yfft, n, nfft, iextnd, nf, ab, lab))
      end
!BFSMVS
     subroutine bfsmvs(ccov, nlppc, index1, index2, n, iccov, jccov,&
    &   inlppc, jnlppc, nw, lags, nf, fmin,&
     &   fmax, nprt, cspc2, icspc2, phas, iphas, freq, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
!     FOURIER SPECTRUM ANALYSIS OF SERIES WITH MISSING OBSERVATIONS
!     WITH USER INPUT OF THE COVARIANCES RATHER THAN THE SERIES
!     (LONG CALL)
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fmax,fmin
     integer&
    &   iccov,icspc2,index1,index2,inlppc,iphas,jccov,jnlppc,&
     &   ldstak,n,nf,nprt,nw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ccov(*),cspc2(*),freq(*),phas(*)
     integer&
     &   lags(*),nlppc(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta,ymiss1,ymiss2
     integer&
    &   ceven,codd,i,ifp,io,iprt,isym,lagmax,lagmx1,ldsmin,lpcv,&
     &   lw,lwork,ly,m,nall0,spcf1,spcf2,w,work,xaxis,yaxis
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12),y1(1),y2(1)
     integer&
     &   istak(12)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL BFSDRV,ECVF,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL CCOV(ICCOV,JCCOV,*)
!        THE COVARIANCES.
!     INTEGER CEVEN
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     INTEGER CODD
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     REAL CSPC2(ICSPC2,NW)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC(INLPPC,JNLPPC,*)
!        THE NUMBER OF OBSERVATIONS IN EACH COVARIANCE ESTIMATE
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL PHAS(IPHAS,NW)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SPCF1, SPCF2
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     INTEGER W
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE WINDOWS.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR THE VECTOR WORK.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YMISS1, YMISS2
!        DUMMY VARIABLES.
!     REAL Y1(1)
!        THE FIRST TIME SERIES.
!     REAL Y2(1)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'B','F','S','M','V','S'/
!
!     SET UP FOR ERROR CHECKING
!
      option(1) = .false.
      option(2) = .true.
      option(3) = .true.
      option(4) = .true.
!
!     SET MAXIMUM LAG VALUE TO BE USED (LAGMAX).
!
      lagmax = n - 1
      if (nw.le.0) go to 20
      lagmax = lags(1)
      do 10 i=1,nw
         lagmax = max(lagmax,lags(i))
   10 continue
   20 continue
      lagmx1 = lagmax + 1
!
      m = 2
!
!     COMPUTE THE MINIMUM ALLOWABLE STACK AREA (LDSMIN)
!
      io = 1
      if (nprt.eq.0) io = 0
!
     call ldscmp(8, 0, io*4*nf, 0, 0, 0, 'S',&
     &  7*lagmax+7+2*nf+io*8*nf, ldsmin)
!
      ly = n
      lpcv = 4*nf
      lw = lagmax + 1
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING STACK ALLOCATIONS (NALL0).
!     SET THE STACK ALLOCATION TYPE (IFP)
!
      call stkset(ldstak, 4)
      nall0 = stkst(1)
!
      ifp = 3
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS
!
      if ((ldsmin.gt.ldstak) .or. (ldsmin.le.6)) then
         ceven = 1
         codd = 1
         spcf1 = 1
         spcf2 = 1
         w = 1
!
         isym = 1
         xaxis = 1
         yaxis = 1
      else
         ceven = stkget(lagmx1,ifp)
         codd = stkget(lagmx1,ifp)
         spcf1 = stkget(nf,ifp)
         spcf2 = stkget(nf,ifp)
         w = stkget(lw,ifp)
         if (nprt.eq.0) then
            isym = w
            xaxis = w
            yaxis = w
         else
            isym = stkget(lpcv,2)
            xaxis = stkget(lpcv,ifp)
            yaxis = stkget(lpcv,ifp)
         end if
      end if
!
      work = w
      lwork = lw
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
     call bfsdrv(y1, y2, ymiss1, ymiss2, ccov, nlppc,&
    &   rstak(spcf1), rstak(spcf2), nf, fmin, fmax, freq, n, nw,&
    &   lagmax, lags, lagmx1, rstak(work), lwork, delta, istak(isym),&
    &   rstak(xaxis), rstak(yaxis), lpcv, alpha, nprt, parzen, iccov,&
    &   jccov, m, index1, index2, cspc2, phas, icspc2, iphas,&
    &   rstak(codd), rstak(ceven), rstak(w), lw, nmsub, ldsmin,&
     &   ldstak, option, n, inlppc, jnlppc, ly)
!
      call stkclr(nall0)
!
!     CHECK FOR ERRORS
!
      if (ierr.ne.0) then
        if (ierr.eq.2) call ecvf(nmsub)
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL BFSMVS(CCOV, NLPPC, INDEX1, INDEX2, N,'/&
    &   '      +            ICCOV, JCCOV, INLPPC, JNLPPC,'/&
    &   '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/&
     &   '      +            CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)')
      end
!XXCH10
      subroutine xxch10(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE HISTOGRAM FAMILY OF ROUTINES.
!
!     DATA IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND JENKINS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   i,iar,iprt,n,nyf
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   air(144),phi(5),y(150),yf(150)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DIF,GFARF,IPRINT,VP
!
!  INTRINSIC FUNCTIONS
      intrinsic log
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AIR(144)
!        THE AIRLINE DATA.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE NUMBER OF COEFFICIENTS IN THE DIFFERENCE FILTER.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES.
!     REAL PHI(5)
!        THE FILTER COEFFICIENTS.
!     REAL Y(150)
!        THE LOG OF THE AIRLINE DATA.
!     REAL YF(150)
!        THE FILTERED DATA.
!
!
     data  air(  1), air(  2), air(  3), air(  4), air(  5), air(  6)&
     &    / 112.0e0,  118.0e0,  132.0e0,  129.0e0,  121.0e0,  135.0e0/
     data  air(  7), air(  8), air(  9), air( 10), air( 11), air( 12)&
     &    / 148.0e0,  148.0e0,  136.0e0,  119.0e0,  104.0e0,  118.0e0/
     data  air( 13), air( 14), air( 15), air( 16), air( 17), air( 18)&
     &    / 115.0e0,  126.0e0,  141.0e0,  135.0e0,  125.0e0,  149.0e0/
     data  air( 19), air( 20), air( 21), air( 22), air( 23), air( 24)&
     &    / 170.0e0,  170.0e0,  158.0e0,  133.0e0,  114.0e0,  140.0e0/
     data  air( 25), air( 26), air( 27), air( 28), air( 29), air( 30)&
     &    / 145.0e0,  150.0e0,  178.0e0,  163.0e0,  172.0e0,  178.0e0/
     data  air( 31), air( 32), air( 33), air( 34), air( 35), air( 36)&
     &    / 199.0e0,  199.0e0,  184.0e0,  162.0e0,  146.0e0,  166.0e0/
     data  air( 37), air( 38), air( 39), air( 40), air( 41), air( 42)&
     &    / 171.0e0,  180.0e0,  193.0e0,  181.0e0,  183.0e0,  218.0e0/
     data  air( 43), air( 44), air( 45), air( 46), air( 47), air( 48)&
     &    / 230.0e0,  242.0e0,  209.0e0,  191.0e0,  172.0e0,  194.0e0/
     data  air( 49), air( 50), air( 51), air( 52), air( 53), air( 54)&
     &    / 196.0e0,  196.0e0,  236.0e0,  235.0e0,  229.0e0,  243.0e0/
     data  air( 55), air( 56), air( 57), air( 58), air( 59), air( 60)&
     &    / 264.0e0,  272.0e0,  237.0e0,  211.0e0,  180.0e0,  201.0e0/
     data  air( 61), air( 62), air( 63), air( 64), air( 65), air( 66)&
     &    / 204.0e0,  188.0e0,  235.0e0,  227.0e0,  234.0e0,  264.0e0/
     data  air( 67), air( 68), air( 69), air( 70), air( 71), air( 72)&
     &    / 302.0e0,  293.0e0,  259.0e0,  229.0e0,  203.0e0,  229.0e0/
     data  air( 73), air( 74), air( 75), air( 76), air( 77), air( 78)&
     &    / 242.0e0,  233.0e0,  267.0e0,  269.0e0,  270.0e0,  315.0e0/
     data  air( 79), air( 80), air( 81), air( 82), air( 83), air( 84)&
     &    / 364.0e0,  347.0e0,  312.0e0,  274.0e0,  237.0e0,  278.0e0/
     data  air( 85), air( 86), air( 87), air( 88), air( 89), air( 90)&
     &    / 284.0e0,  277.0e0,  317.0e0,  313.0e0,  318.0e0,  374.0e0/
     data  air( 91), air( 92), air( 93), air( 94), air( 95), air( 96)&
     &    / 413.0e0,  405.0e0,  355.0e0,  306.0e0,  271.0e0,  306.0e0/
     data  air( 97), air( 98), air( 99), air(100), air(101), air(102)&
     &    / 315.0e0,  301.0e0,  356.0e0,  348.0e0,  355.0e0,  422.0e0/
     data  air(103), air(104), air(105), air(106), air(107), air(108)&
     &    / 465.0e0,  467.0e0,  404.0e0,  347.0e0,  305.0e0,  336.0e0/
     data  air(109), air(110), air(111), air(112), air(113), air(114)&
     &    / 340.0e0,  318.0e0,  362.0e0,  348.0e0,  363.0e0,  435.0e0/
     data  air(115), air(116), air(117), air(118), air(119), air(120)&
     &    / 491.0e0,  505.0e0,  404.0e0,  359.0e0,  310.0e0,  337.0e0/
     data  air(121), air(122), air(123), air(124), air(125), air(126)&
     &    / 360.0e0,  342.0e0,  406.0e0,  396.0e0,  420.0e0,  472.0e0/
     data  air(127), air(128), air(129), air(130), air(131), air(132)&
     &    / 548.0e0,  559.0e0,  463.0e0,  407.0e0,  362.0e0,  405.0e0/
     data  air(133), air(134), air(135), air(136), air(137), air(138)&
     &    / 417.0e0,  391.0e0,  419.0e0,  461.0e0,  472.0e0,  535.0e0/
     data  air(139), air(140), air(141), air(142), air(143), air(144)&
     &    / 622.0e0,  606.0e0,  508.0e0,  461.0e0,  390.0e0,  432.0e0/
!
!     DEFINE CONSTANTS
!
      call iprint(iprt)
      n = 144
!
!     TAKE LOG OF DATA
!
      do 10 i=1,n
         y(i) = log(air(i))
   10 continue
!
!     WRITE HEADER
!
      write(iprt, 1000)
!
!     RUN SIMPLE TEST OF DIF
!
      write(iprt, 1100)
      call dif (y, n, yf, nyf)
      write (iprt,2000) ierr
!
!     PLOT ORIGINAL SERIES
!
      write(iprt, 1200)
      call vp (y, n, 1)
      write (iprt,2000) ierr
!
!     PLOT DIFFERENCED SERIES
!
      write(iprt, 1300)
      call vp (yf, nyf, 1)
      write (iprt,2000) ierr
!
!     RUN SIMPLE TEST OF GFARF
!
      write(iprt, 1400)
      phi(1) = 1.0
      iar = 1
      call gfarf (phi, iar)
      write (iprt,2000) ierr
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format ('1*CH10')
 1100 format (' SIMPLE TEST OF DIF (NO OUTPUT UNLESS ERROR FOUND)')
 1200 format ('1PLOT OF ORIGINAL SERIES')
 1300 format ('1PLOT OF DIFFERENCED SERIES')
 1400 format ('1SIMPLE TEST OF GFARF')
 2000 format (/' THE VALUE OF IERR IS ', i4)
      end
!DCKDRV
     subroutine dckdrv (nmsub, ldstak, xm, n, m, ixm, mdl,&
     &   drv, par, npar, neta, ntau, scale, lscale, nrow, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE IS THE DRIVER FOR THE DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,ldstak,lscale,m,n,neta,npar,nprt,nrow,ntau
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),scale(*),xm(*)
     character&
     &   nmsub(6)*1
!
!  SUBROUTINE ARGUMENTS
       external drv,mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   isubhd,lifixd
     logical&
     &   hlfrpt,page,prtfxd,wide
!
!  LOCAL ARRAYS
     integer&
     &   ifixed(1)
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL DCKCNT,DCKER,DCKHDR,STKSET
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     EXTERNAL DCKHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE LENGTH OF THE VECTOR IFIXED.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NROW
!        THE USER-SUPPLIED NUMBER OF THE ROW OF THE INDEPENDENT
!        VARIABLE ARRAY AT WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL XM(IXM,M)
!        THE INDEPENDENT VARIABLE ARRAY
!
!
!     CHECK FOR ERRORS IN INPUT PARAMETERS
!
      call dcker(nmsub, n, m, ixm, npar, ldstak, scale, lscale)
!
      if (ierr.ne.0) return
!
      page = .false.
      wide = .true.
      isubhd = 0
!
      prtfxd = .false.
      ifixed(1) = -1
      lifixd = 1
!
      call stkset(ldstak, 4)
!
!     PASS CONTROL OF DERIVATIVE CHECKING TO DCKCNT
!
     call dckcnt (xm, n, m, ixm, mdl, drv, par, npar, neta,&
    &   ntau, scale, lscale, nrow, nprt, dckhdr, page, wide, isubhd,&
     &   hlfrpt, prtfxd, ifixed, lifixd)
!
      return
!
      end
!DRV4A
      subroutine drv4a (coef, ncoef, xm, n, m, ixm, d)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DERIVATIVE FOR DERIVATIVE CHECKING ROUTINES (CORRECTLY CODED).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,m,n,ncoef
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   coef(ncoef),d(n,ncoef),xm(ixm,m)
!
!  LOCAL SCALARS
     integer&
     &   i
!
!  INTRINSIC FUNCTIONS
      intrinsic exp
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL COEF(NCOEF)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        COEFFICIENTS ARE STORED.
!     REAL D(N,NCOEF)
!        THE MATRIX OF FIRST PARTIAL DERIVATIVES (JACOBIAN).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NCOEF
!        THE NUMBER OF UNKNOWN COEFFICIENTS IN THE MODEL.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
!
      do 10 i = 1, n
         d(i,1) = 1.0e0
        d(i,2) = (coef(3)*2.0e0*(xm(i,1)-coef(2))/coef(4)) *&
     &      exp(-((xm(i,1)-coef(2))**2)/coef(4))
         d(i,3) = exp(-((xm(i,1)-coef(2))**2)/coef(4))
        d(i,4) = -coef(3)*(-((xm(i,1)-coef(2))**2) /&
     &      (coef(4)**2)) * exp(-((xm(i,1)-coef(2))**2)/coef(4))
   10 continue
!
      return
!
      end
!DRV4B
      subroutine drv4b (coef, ncoef, xm, n, m, ixm, d)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DERIVATIVE FOR DERIVATIVE CHECKING ROUTINES (INCORRECTLY CODED).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,m,n,ncoef
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   coef(ncoef),d(n,ncoef),xm(ixm,m)
!
!  LOCAL SCALARS
     integer&
     &   i
!
!  INTRINSIC FUNCTIONS
      intrinsic exp
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL COEF(NCOEF)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        COEFFICIENTS ARE STORED.
!     REAL D(N,NCOEF)
!        THE MATRIX OF FIRST PARTIAL DERIVATIVES (JACOBIAN).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NCOEF
!        THE NUMBER OF UNKNOWN COEFFICIENTS IN THE MODEL.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
!
      do 10 i = 1, n
         d(i,1) = 0.0e0
        d(i,2) = (coef(3)*2.0e0*(xm(i,1)-coef(2))/coef(4)) *&
     &      exp(-((xm(i,1)-coef(2))**2)/coef(4))
         d(i,3) = 0.0e0
        d(i,4) = coef(3)*(-((xm(i,1)-coef(2))**2) /&
     &      (coef(4)**2)) * exp(-((xm(i,1)-coef(2))**2)/coef(4))
   10 continue
!
      return
!
      end
!CCVF
     subroutine ccvf(y1, y2, n, lagmax, y1mean, y2mean, ccov12, ccov21,&
     &   iccov)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE CROSS COVARIANCE FUNCTION
!     BETWEEN TWO SERIES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   y1mean,y2mean
     integer&
     &   iccov,lagmax,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ccov12(iccov),ccov21(iccov),y1(n),y2(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   dotxy
     integer&
     &   lag,ndotxy
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL DOTC
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCOV12(ICCOV), CCOV21(ICCOV)
!        THE ARRAYS IN WHICH THE CCVF FOR SERIES 1 LAGGED
!        BEHIND SERIES 2 AND VISA VERSA, RESPECTIVELY, ARE
!        STORED.
!     REAL DOTXY
!        VARIOUS CROSS PRUDUCTS BETWEEN SERIES Y1 AND Y2.
!     INTEGER ICCOV
!        THE ROW DIMENSION OF THE ARRAYS CCOV12 AND CCOV21.
!     INTEGER LAG
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCORRELATION BEING COMPUTED.
!     INTEGER LAGMAX
!        THE MAXIMUM NUMBER OF LAGS TO BE USED.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NDOTXY
!        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY.
!     REAL Y1(N), Y1MEAN
!        THE FIRST SERIES, AND ITS MEAN.
!     REAL Y2(N), Y2MEAN
!        THE SECOND SERIES, AND ITS MEAN.
!
!     COMPUTE THE CROSS COVARIANCES
!
      call dotc ( y1, y1mean, n, y2, y2mean, n, dotxy, ndotxy)
      ccov12(1) = dotxy / n
      ccov21(1) = ccov12(1)
!
      do 10 lag = 1, lagmax
!
        call dotc (y1, y1mean, n, y2(lag + 1), y2mean, n - lag,&
     &       dotxy, ndotxy)
         ccov12(lag+1) = dotxy / n
!
        call dotc (y2, y2mean, n, y1(lag + 1), y1mean, n - lag,&
     &       dotxy, ndotxy)
         ccov21(lag+1) = dotxy / n
!
   10 continue
!
      return
      end
!PPLMT
     subroutine pplmt (ym, ymmiss, x, xmiss, n, m, iym, ylb, yub, ymn,&
     &  ymx, xlb, xub, xmn, xmx, error, nmsub, miss)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SETS THE PLOT LIMITS FOR PAGE PLOTS
!     WITH MISSING VALUES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   xlb,xmiss,xmn,xmx,xub,ylb,ymn,ymx,yub
     integer&
     &   iym,m,n
     logical&
     &   error,miss
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(n),ym(iym,m),ymmiss(m)
     character&
     &   nmsub(6)*1
!
!  LOCAL SCALARS
     integer&
     &   i,ii,iprt,j
     logical&
     &   head,setlmt,skprow
!
!  EXTERNAL FUNCTIONS
!      LOGICAL
!     +   MVCHK
!      EXTERNAL MVCHK
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ADJLMT,EHDR,IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic max,min
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        A VALUE INDICATING WHETHER AN ERROR WAS DETECTED (TRUE)
!        OR NOT (FALSE).
!     LOGICAL HEAD
!        PRINT HEADING (HEAD=TRUE) OR NOT (HEAD=FALSE).
!     INTEGER I, II
!        INDEXING VARIABLES.
!     INTEGER IPRT
!        ...
!     INTEGER IYM
!        ACTUAL ROW DIMENSION OF YM DECLARED IN THE USERS MAIN PROGRAM
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER M
!        THE NUMBER OF VECTORS IN YM
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS .
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     LOGICAL SETLMT
!        AN INDICATOR VARIABLE USED TO DETERMINE IF STARTING VALUES
!        FOR XMN, XMX, YMN, YMX HAVE BEEN FOUND.
!     LOGICAL SKPROW
!        AN INDICATOR VARIABLE USED TO DESIGNATE WHETHER ALL
!        OBSERVATIONS IN A GIVEN ROW OF YM ARE UNUSED (TRUE)
!        OR NOT (FALSE).
!     REAL X(N)
!        THE ARRAY CONTAINING THE INDEPENDENT VARIABLE.
!     REAL XLB
!        THE USER SUPPLIED X-AXIS LOWER BOUND.
!     REAL XMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IS MISSING.
!        IF X(I) = XMISS, THE VALUE IS ASSUMED MISSING, OTHERWISE
!        IT IS NOT.
!     REAL XMN, XMX
!        THE X-AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
!     REAL XUB
!        THE USER SUPPLIED X-AXIS UPPER BOUNDS.
!     REAL YLB
!        THE USER SUPPLIED Y-AXIS LOWER BOUND.
!     REAL YM(IYM,M)
!        THE ARRAY CONTAINING THE DEPENDENT VARIABLE(S).
!     REAL YMMISS(M)
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IS MISSING.
!        IF YM(I,J) = YMMISS(J), THE VALUE IS ASSUMED MISSING, OTHERWISE
!        IT IS NOT.
!     REAL YMN, YMX
!        THE Y-AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
!     REAL YUB
!        THE USER SUPPLIED Y-AXIS UPPER BOUNDS.
!
      error = .false.
!
      if ((xlb .lt. xub) .and. (ylb .lt. yub)) then
!
!       SET LIMITS TO USER SPECIFIED VALUES
!
        xmn = xlb
        xmx = xub
        ymn = ylb
        ymx = yub
!
      else
!
!       SET LIMITS TO RANGE OF VALUES WITHIN ANY USER SPECIFIED VALUES
!
        setlmt = .false.
        ii = 1
!
!       FIND FIRST VALUE TO BE PLOTTED
!
        do 20 i=1,n
           if (miss .and. mvchk(x(i),xmiss)) go to 20
          if ((xlb.lt.xub) .and. ((x(i).lt.xlb) .or.&
     &        (xub.lt.x(i)))) go to 20
           xmn = x(i)
           xmx = x(i)
           do 10 j=1,m
              if (miss .and. mvchk(ym(i,j),ymmiss(j))) go to 10
             if ((ylb.lt.yub) .and. ((ym(i,j).lt.ylb) .or.&
     &           (yub.lt.ym(i,j)))) go to 10
              if (setlmt) go to 5
              ymn = ym(i,j)
              ymx = ym(i,j)
              setlmt = .true.
              ii = i + 1
              go to 10
    5         ymn = min(ymn, ym(i,j))
              ymx = max(ymx, ym(i,j))
   10      continue
           if (setlmt) go to 30
   20   continue
!
   30   if (ii.le.1) then
!
!         NO VALUES TO BE PLOTTED.  PRINT ERROR MESSAGE
!
          error = .true.
          call iprint(iprt)
          head = .true.
          call ehdr(nmsub,head)
          if ((ylb.ge.yub) .and. (xlb.ge.xub)) then
            write (iprt, 1010)
          else
            write (iprt, 1020)
          end if
          write (iprt, 1030)
!
        else
!
!         FIND LIMITS FROM REMAINING VALUES
!
          if (ii.le.n) then
            do 50 i=ii,n
               if (miss .and. mvchk(x(i),xmiss)) go to 50
              if ((xlb.lt.xub) .and. ((x(i).lt.xlb) .or.&
     &            (xub.lt.x(i)))) go to 50
               skprow = .true.
               do 40 j=1,m
                  if (miss .and. mvchk(ym(i,j),ymmiss(j))) go to 40
                 if ((ylb.lt.yub) .and. ((ym(i,j).lt.ylb) .or.&
     &               (yub.lt.ym(i,j)))) go to 40
                  skprow = .false.
                  ymn = min(ymn, ym(i,j))
                  ymx = max(ymx, ym(i,j))
   40          continue
               if (skprow) go to 50
               xmn = min(xmn, x(i))
               xmx = max(xmx, x(i))
   50       continue
          end if
        end if
!
        if (ylb.lt.yub) then
!
!       SET Y AXIS LIMITS TO USER SUPPLIED VALUES
!
          ymn = ylb
          ymx = yub
        else
!
!       ADJUST Y AXIS LIMITS IF EQUAL
!
          if (ymn .ge. ymx) call adjlmt(ymn, ymx)
        end if
!
        if (xlb.lt.xub) then
!
!       SET X AXIS LIMITS TO USER SUPPLIED VALUES
!
          xmn = xlb
          xmx = xub
        else
!
!         ADJUST X AXIS LIMITS IF EQUAL
!
          if (xmn .ge. xmx) call adjlmt(xmn, xmx)
!
        end if
!
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1010 format (/&
     &   44h no non-missing plot coordinates were found.)
1020 format (/&
    &   40h no non-missing values were found within,&
     &   26h the user supplied limits.)
1030 format (/&
     &   30h the plot has been suppressed.)
      end
!SUMTS
      subroutine sumts(x, n, alpha, sumt1, xtrm)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO CALCULATE THE UNWEIGHTED TRIMMED MEAN FOR
!     A SORTED VECTOR IN WHICH THE MIDTH ELEMENT IS THE ELEMENT
!     CLOSEST TO ZERO.  USED BY THE STAT FAMILY.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   alpha,sumt1,xtrm
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(n)
!
!  LOCAL SCALARS
     integer&
     &   curhi,curlo,i,irev,ithi,itlo,mid,nalpha
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL SUMBS
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max,min
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        INPUT PARAMETER.  THE PERCENTAGE OF POINTS TO TRIM
!        FROM EACH END OF THE ARRAY X FOR THE TRIMMED MEAN.
!     INTEGER CURHI
!        THE UPPER BOUND OF THE CURRENT INTERVAL.
!     INTEGER CURLO
!        THE LOWER BOUND OF THE CURRENT INTERVAL.
!     INTEGER I
!        LOOP PARAMETER.
!     INTEGER IREV
!        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
!        IN THE REVERSE ORDER.
!     INTEGER ITHI
!        THE COMPUTED UPPER BOUND SUCH THAT ALPHA PER
!        CENT OF THE POSITIVELY WEIGHTED POINTS ARE
!        OMITTED.
!     INTEGER ITLO
!        THE COMPUTED LOWER BOUND SUCH THAT ALPHA PER
!        CENT OF THE POSITIVELY WEIGHTED POINTS ARE
!        OMITTED.
!     INTEGER MID
!        THE INDEX OF THE ELEMENT IN X CLOSEST TO ZERO IN VALUE.
!        THE POINT OUT FROM WHICH THE SUMMING IS DONE.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
!     INTEGER NALPHA
!        THE INTEGER WHICH IS ALPHA PER CENT OF N.
!     REAL SUMT1
!        OUTPUT PARAMETER.  THE UNWEIGHTED SUM OF THE TRIMMED
!        ARRAY.  ZERO-WEIGHTED ELEMENTS ARE OMITTED.
!     REAL X(N)
!        INPUT PARAMETER.  THE DATA ARRAY X IN WHICH THE SUMS ARE TAKEN.
!     REAL XTRM
!        OUTPUT PARAMETER.  THE UNWEIGHTED, TRIMMED MEAN OF X.
!
!     SET UP LIMITS TRIMMING THE NUMBER OF VALUES AT EACH END
!     BY ALPHA PER CENT.
!
      nalpha = alpha*n
      itlo = nalpha + 1
      ithi = n - nalpha
      call sumbs(x, n, itlo, mid, ithi)
!
!     INITIALIZE SUMMATION VARIABLES.
!
      sumt1 = x(mid)
      curlo = mid - 1
      curhi = mid + 1
!
!     SUM OUTWARDS FROM THE VALUE NEAREST ZERO.  THAT IS, SUM FROM
!     THE LEAST IN MAGNITUDE TO THE GREATEST.
!
   10 if (curhi.gt.ithi .or. curlo.lt.itlo) go to 30
      if (abs(x(curhi)).lt.abs(x(curlo))) go to 20
      sumt1 = sumt1 + x(curlo)
      curlo = curlo - 1
      go to 10
   20 sumt1 = sumt1 + x(curhi)
      curhi = curhi + 1
      go to 10
!
!     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
!     CENTER ZERO POINT.
!
   30 if (curhi.gt.ithi) go to 50
      curhi = max(curhi,itlo)
      do 40 i=curhi,ithi
         sumt1 = sumt1 + x(i)
   40 continue
   50 if (curlo.lt.itlo) go to 70
      curlo = min(curlo,ithi)
      do 60 irev=itlo,curlo
         i = itlo - irev + curlo
         sumt1 = sumt1 + x(i)
   60 continue
   70 xtrm = sumt1/(n-2*nalpha)
      return
      end
!STAT
      subroutine stat(y, n, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES 53 DIFFERENT STATISTICS FOR A VECTOR
!     Y, WITH NO WEIGHTS SPECIFIED.  ONE PAGE OF AUTOMATIC
!     PRINTOUT IS PRODUCED.
!
!     WRITTEN BY - JANET R. DONALDSON, JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!        (EXTENSIVE REVISION OF OLDER VERSION)
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,sumd2,sumd3,sumd4,sumda,sumdi,sumt1
     integer&
     &   idp,iint,iprt,lsort,mid,nall0,nnzw
     logical&
     &   stack,wts
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   sts(53),wt(1)
     integer&
     &   istak(12)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL GENI,IPRINT,SRTIR,SRTRI,STAT1,STAT2,STATER,STKCLR,STKSET,
!     +   SUMBS,SUMDS,SUMID,SUMOT,SUMSS,SUMTS
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        THE PERCENTAGE TO BE TRIMMED OFF EACH END OF Y FOR THE
!        TRIMMED MEANS CALCULATIONS.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDP
!        THE CODE VALUE FOR DOUBLE PRECISION FOR FRAMEWORK.
!     INTEGER IERR
!        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
!        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
!        SOME ERROR EXISTS.
!     INTEGER IINT
!        THE CODE VALUE FOR INTEGER FOR FRAMEWORK
!     INTEGER IPRT
!        THE NUMBER OF THE STANDARD OUTPUT UNIT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
!        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
!     INTEGER LSORT
!        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION
!        VECTOR.
!     INTEGER MID
!        THE INDEX OF THE (AN) ELEMENT OF Y CLOSEST TO ZERO, WHEN
!        Y HAS BEEN SORTED.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
!        WAS CALLED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NNZW
!        NUMBER OF NONZERO WEIGHTS.
!     LOGICAL STACK
!        A FLAG INDICATING WHETHER THIS ROUTINE USES THE STACK (TRUE)
!        OR NOT (FALSE).
!     REAL STS(53)
!        THE VECTOR OF THE 53 STATISTICS COMPUTED.
!     REAL SUMDA
!        THE SUM OF THE ABSOLUTE DIFFERENCES FROM THE MEAN.
!     REAL SUMDI
!        THE SUM OF THE PRODUCTS OF THE INDICES AND THE DIFFERENCES.
!     REAL SUMD2
!        THE SUM OF THE SQUARES OF THE DIFFERENCES.
!     REAL SUMD3
!        THE SUM OF THE CUBES OF THE DIFFERENCES.
!     REAL SUMD4
!        THE SUM OF THE 4TH POWERS OF THE DIFFERENCES.
!     REAL SUMT1
!        THE SUM OF THE ALPHA TRIMMED ARRAY Y.
!     REAL WT(1)
!        THE DUMMY WEIGHTS VECTOR.
!     LOGICAL WTS
!        A FLAG INDICATING WHETHER THERE ARE WEIGHTS (TRUE)
!        OR NOT (FALSE).
!     REAL Y(N)
!        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
!        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
!        TO ITS ORIGINAL ORDER AFTERWARDS.
!
!
!     INITIALIZE NAME VECTORS
!
     data  nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6)&
     &   /       'S',      'T',      'A',      'T',      ' ',      ' '/
!
      data alpha /0.25e0/
      data idp /4/
      data iint /2/
      data wts /.false./
      data stack /.true./
!
!     CHECK FOR ERRORS IN THE INPUT PARAMETERS
!
      call stater(nmsub, wt, n, ldstak, wts, nnzw, stack, ierr)
      if (ierr.ne.0) then
!
!     PRINT ERROR MESSAGE.
!
         call iprint(iprt)
         write (iprt,1000)
         return
      end if
!
!     SET UP FRAMEWORK AREA.
!
      call stkset (ldstak, idp)
      nall0 = stkst(1)
!
!     SET UP LSORT, THE PERMUTATION VECTOR.
!
      lsort = stkget(n,iint)
      call geni(istak(lsort), n, 1, 1)
!
!     SORT THE VECTOR Y.
!
      call srtir(istak(lsort), n, y)
!
!     COMPUTE THE STATISTICS WHICH USE A SORTED ARRAY.
!
     call stat1(y, n, sts(5), sts(34), sts(35), sts(6),&
     &   sts(11), 10, 0.0e0, 0.0e0, sts(44))
!
!     CALCULATE SUMS OF THE SORTED ARRAY.
!
      call sumbs(y, n, 1, mid, n)
     call sumss(y, n, 1, mid, n, sts(38), sts(39), sts(42),&
     &   sts(3))
      sts(4) = sts(3)
      call sumts(y, n, alpha, sumt1, sts(7))
      sts(8) = sts(7)
      call sumds(y, n, 1, mid, n, sts(3), sumda, sumd2, sumd3, sumd4)
!
!     RESTORE THE VECTOR Y TO ITS ORIGINAL ORDER.
!
      call srtri(y, n, istak(lsort))
!
!     COMPUTE REST OF STATISTICS.
!
      call sumid(y, n, sts(3), sumdi)
      call stat2(y, n, sts, sumda, sumdi, sumd2, sumd3, sumd4)
      call sumot(sts, n, n, wts)
!
!     RETURN THE VECTOR LSORT.
!
      call stkclr(nall0)
      return
!
!     FORMAT STATEMENTS.
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL STAT (Y, N, LDSTAK)')
      end
!DOTCM
     subroutine dotcm (y, ymean, ymiss, ny, x, xmean, xmiss,&
     &   nx, dotxy, ndotxy)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE DOT PRODUCT OF TWO
!     SERIES WITH MISSING DATA, CENTERED ABOUT THEIR RESPECTIVE MEANS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: dotxy,xmean,xmiss,ymean,ymiss
     integer&
     &   ndotxy,nx,ny
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(nx),y(ny)
!
!  LOCAL SCALARS
     integer&
     &   i,m
!
!  EXTERNAL FUNCTIONS
     logical&
     &   mvchk
!       EXTERNAL MVCHK
!
!  INTRINSIC FUNCTIONS
      intrinsic min
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DOTXY
!        THE DOT PRODUCT OF THE SERIES (Y(I) - YMEAN) AND
!        (X(I) - XMEAN).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER M
!        THE SMALLER OF THE NUMBER OF OBSERVATIONS IN X AND Y
!     INTEGER NDOTXY
!        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY
!     INTEGER NX, NY
!        THE NUMBER OF OBSERVATIONS IN SERIES X AND Y, RESPECTIVELY.
!     REAL X(NX)
!        THE VECTOR CONTAINING THE SECOND SERIES
!     REAL XMEAN
!        THE MEAN OF THE SECOND SERIES.
!     REAL XMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF X(I) = XMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!     REAL Y(NY)
!        THE VECTOR CONTAINING THE FIRST SERIES
!     REAL YMEAN
!        THE MEAN OF THE FIRST SERIES.
!     REAL YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!
      ndotxy = 0
      dotxy = 0.0e0
      m = min(ny, nx)
      do 10 i = 1, m
         if (mvchk(y(i), ymiss) .or. mvchk(x(i), xmiss)) go to 10
         dotxy = dotxy + (y(i) - ymean) * (x(i) - xmean)
         ndotxy = ndotxy + 1
   10 continue
      return
      end
!MVPC
     subroutine mvpc(ym, n, m, iym, ns, ilog, isize,&
     &   ylb, yub, xlb, xinc)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MULTIPLE Y-AXIS VALUES (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ilog,isize,iym,m,n,ns
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   ibar,iprt,irlin,ischck,lisym
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'M',       'V',       'P',       'C',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      multi = .true.
      irlin = -1
      ibar = -1
      ischck = 2
      miss = .false.
      lisym = 1
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ym, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    & '       CALL MVPC (YM, N, M, IYM, NS, ILOG,'/&
     & '      +           ISIZE, YLB, YUB, XLB, XINC)')
      end
!ACFLST
     subroutine acflst (rho, sdrho, nlppa, lagmax, ifmiss, chia,&
     &   ndfchi, chiap)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE ACTUALLY LISTS THE AUTOCORRELATIONS OR
!     PARTIAL AUTOCORRELATIONS AND OTHER PERTINENT INFORMATION.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   chia,chiap
     integer&
     &   lagmax,ndfchi
     logical&
     &   ifmiss
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   rho(*),sdrho(*)
     integer&
     &   nlppa(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm
     integer&
     &   i,imax,imin,iprt,lag,nperl
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic min
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CHIA, CHIAP
!        THE VARIABLES IN CHICH THE CHI SQUARE STATISTIC AND
!        PROBABILITY FOR THE AUTOCORRELATIONS ARE STORED.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     LOGICAL IFMISS
!        THE INDICATOR VARIABLE USED TO DETERMINE
!        WHETHER THE INPUT SERIES HAS MISSING DATA OR NOT.
!     INTEGER IMAX, IMIN
!        THE INDEX VALUES OF THE FIRST AND LAST OBSERVATION
!        TO BE PRINTED PER LINE
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT
!     INTEGER LAG
!        THE LAG VALUE OF THE AUTOCORRELATION OR PARTIAL
!        AUTOCORRELATION BEING PRINTED.
!     INTEGER LAGMAX
!        THE NUMBER OF AUTOCORRELATIONS OR PARTIAL AUTOCORRELATIONS
!        TO BE PRINTED.
!     INTEGER NDFCHI
!        THE DEGREES OF FREEDOM FOR THE CHI SQUARED STATISTIC.
!     INTEGER NLPPA(LAGMAX)
!        THE ARRAY IN WHICH THE NUMBER OF LAGGED PRODUCT PAIRS USED TO
!        COMPUTE EACH AUTOCORRELATION IS STORED
!     INTEGER NPERL
!        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
!     REAL RHO(LAGMAX)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED.
!     REAL SDRHO(LAGMAX)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!        ARE STORED
!
!
      fplm = r1mach(2)
!
      call iprint(iprt)
!
      nperl = 12
      do 30 i = 1, lagmax, nperl
         imin = i
         imax = min(i + nperl - 1, lagmax)
         write(iprt, 1000) (lag, lag = imin, imax)
         write(iprt, 1001) (rho(lag), lag = imin, imax)
         write(iprt, 1002) (sdrho(lag), lag = imin, imax)
         if (ifmiss) write(iprt, 1003) (nlppa(lag), lag = imin, imax)
   30 continue
!
      if (sdrho(lagmax) .eq. fplm) write(iprt, 1004) fplm
!
      write (iprt, 1005) chia, ndfchi, chiap
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format(/19h lag               , 12(1x, i6))
 1001 format( 19h acf               , 12(2x, f5.2))
 1002 format( 19h standard error    , 12(2x, f5.2))
 1003 format( 19h no. of obs. used  , 12(1x, i6))
1004 format(///5x, f5.2, 38h indicates value could not be computed,&
     &   ' DUE TO MISSING DATA.')
1005 format(///33h the chi square test statistic of/&
    &   40h the null hypothesis of white noise    =, g21.4/&
    &   40h degrees of freedom                    =, i17/&
     &   40h observed significance level           =, f17.4)
      end
!PGM
      subroutine pgm (yfft, n, lyfft, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
!     THE (RAW) PERIODOGRAM OF A SERIES (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,lyfft,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   yfft(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   freq,iextnd,iprt,ldsmin,nall0,nf,nfft,nprt,yaxis
     logical&
     &   err01,err02,err03,head
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     character&
     &   llds(8)*1,llyfft(8)*1,ln(8)*1,nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,IPRINT,LDSCMP,PGMMN,SETESL,STKCLR,STKSET
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     INTEGER FREQ
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
!        INTEGRATED SPECTRUM VALUES ARE STORED.
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IEXTND
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
!        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
!        USED TO EXTEND THE SERIES.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     CHARACTER*1 LLDS(8), LLYFFT(8), LN(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING ALLOCATIONS OF THE STACK AT THE
!        TIME OF THIS CALL.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .EQ.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
!        IF NPRT .GE.  2, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
!     REAL YFFT(LYFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'P',       'G',       'M',       ' ',       ' ',       ' '/
     data&
    & llds(1), llds(2), llds(3), llds(4), llds(5),&
     &  llds(6), llds(7), llds(8) /'L','D','S','T','A','K',' ',' '/
     data&
    & llyfft(1), llyfft(2), llyfft(3), llyfft(4), llyfft(5),&
    &  llyfft(6), llyfft(7), llyfft(8)&
     &  /'L','Y','F','F','T',' ',' ',' '/
     data&
    & ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /'N',' ',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 17, 1, head, err01, ln)
      if (err01) go to 5
!
!     SET LENGTH OF EXTENDED SERIES
!
      call setesl(n, 2, nfft)
!
      call eisge(nmsub, llyfft, lyfft, nfft, 9, head, err02, llyfft)
!
      call ldscmp(2, 0, 0, 0, 0, 0, 'S', nfft, ldsmin)
!
      call eisge(nmsub, llds, ldstak, ldsmin, 2, head, err03, llds)
!
      if (err01 .or. err02 .or. err03) go to 5
      go to 10
!
    5 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   10 continue
!
!     SET THE SIZE OF THE WORK AREA
!
      call stkset(ldstak, 4)
!
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!
      nall0 = stkst(1)
!
!     SET DEFAULT VALUES
!
      nprt = -1
      iextnd = 0
!
!     SUBDIVIDE THE WORK ARRAY
!
      yaxis = stkget(nfft/2, 3)
      freq = stkget(nfft/2, 3)
     call pgmmn (yfft, n, nfft, iextnd, nf, yfft, lyfft, rstak(yaxis),&
     &   rstak(freq), nfft/2, nprt, nmsub)
!
      call stkclr(nall0)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &  '       CALL PGM (YFFT, N, LYFFT, LDSTAK)')
      end
!HISTC
      subroutine histc (y, n, ncell, ylb, yub, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR PRODUCING A HISTOGRAM
!     (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ylb,yub
     integer&
     &   ldstak,n,ncell
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   idp,ifp,iint,iprt,lsort,nall0,ncells,ydist
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL HSTER,HSTMN,IPRINT,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic anint,log10,min,nint,real
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDP
!        THE CODE VALUE FOR DOUBLE PRECISION FOR FRAMEWORK.
!     INTEGER IERR
!        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
!        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
!        SOME ERROR EXISTS.
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IINT
!        THE CODE VALUE FOR INTEGER FOR FRAMEWORK
!     INTEGER IPRT
!        THE NUMBER OF THE STANDARD OUTPUT UNIT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
!        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
!     INTEGER LSORT
!        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION
!        VECTOR.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
!        WAS CALLED.
!     INTEGER NCELL
!        THE USER SUPPLIED VALUE FOR THE NUMBER OF CELLS IN THE
!        HISTOGRAM.  IF NCELL IS LESS THAN OR EQUAL TO ZERO, THE
!        NUMBER OF CELLS TO BE USED (NCELLS) WILL BE CALCULATED FROM
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NCELLS
!        THE NUMBER OF CELLS IN THE HISTOGRAM.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL Y(N)
!        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
!        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
!        TO ITS ORIGINAL ORDER AFTERWARDS.
!     INTEGER YDIST
!        THE STARTING LOCATION IN RSTAK OF THE DISTRIBUTION VECTOR.
!     REAL YLB
!        THE LOWER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!     REAL YUB
!        THE UPPER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!
!     INITIALIZE NAME VECTORS
!
     data  nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6)&
     &   /       'H',      'I',      'S',      'T',      'C',      ' '/
!
      data idp /4/
      data iint /2/
!
!     COMPUTE NCELLS
!
      if ((ncell.le.0) .and. (n.ge.1)) then
         ncells = min(nint(5.5e0+1.5e0*anint(log10(real(n)))),25)
      else
         ncells = ncell
      end if
!
!     CHECK FOR ERRORS IN THE INPUT PARAMETERS
!
      call hster(nmsub, y, n, ncells, ldstak, ylb, yub, ierr)
      if (ierr.eq.0) go to 10
!
!     PRINT ERROR MESSAGE.
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     SET UP FRAMEWORK AREA.
!
   10 call stkset (ldstak, idp)
      nall0 = stkst(1)
!
!     SET UP WORK VECTORS
!
      ifp = 3
!
      lsort = stkget(n,iint)
      ydist = stkget(ncells,ifp)
!
!     COMPUTE THE HISTOGRAM.
!
      call hstmn(y, n, ncells, ylb, yub, istak(lsort), rstak(ydist))
!
!     RETURN THE WORK VECTORS.
!
      call stkclr(nall0)
      return
!
!     FORMAT STATEMENTS.
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL HISTC (Y, N, NCELL, YLB, YUB, LDSTAK)')
      end
!XXCH3
      subroutine xxch3(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE NORMAL RANDOM NUMBER GENERATOR FAMILY OF ROUTINES.
!
!     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   sigma,ymean
     integer&
     &   i,iprt,iseed,iym,m,n
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ym(50,2)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,MVP,NRAND,NRANDC
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        FLAG TO INDICATE PRESENCE OF ERROR DETECTED BY PRECEDING
!        STARPAC CALL.  (0 IS OK, 1 IS ERROR)
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER ISEED
!        THE SEED FOR THE RANDOM NUMBER GENERATOR.
!     INTEGER IYM
!        THE EXACT VALUE OF THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LDSTAK
!        A DUMMY VARIABLE FOR THIS TEST SUBPROGRAM.
!     INTEGER M
!        THE NUMBER OF SETS OF NUMBERS TO BE GENERATED
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS TO BE GENERATED.
!     REAL SIGMA
!        THE S.D. OF THE SAMPLE.
!     REAL YM(50,2)
!        DATA VECTOR FOR TESTS.
!     REAL YMEAN
!        THE MEAN OF THE SAMPLE.
!
!
!     DATA INITIALIZATION
!
      iym = 50
      iseed = 531
      n = 50
      m = 2
      ymean = 4.0e0
      sigma = 0.5e0
!
!     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
!
      call iprint(iprt)
!
!     WRITE HEADING
!
      write (iprt,1000)
!
!     GENERATE STANDARD NORMAL PSEUDO-RANDOM NUMBERS INTO COLUMN 1 OF YM
!
      write (iprt,1100)
      call nrand(ym(1,1), n, iseed)
      write (iprt,2000) ierr
      write (iprt, 1400) (ym(i,1),i=1,n)
!
!     GENERATE NORMAL PSEUDO-RANDOM NUMBERS
!     WITH MEAN 4.0 AND STANDARD DEVIATION 0.5 INTO COLUMN 2 OF YM
!
      write (iprt,1200)
      call nrandc(ym(1,2), n, iseed, ymean, sigma)
      write (iprt,2000) ierr
      write (iprt, 1400) (ym(i,2),i=1,n)
!
!     PLOT RESULTS, SAMPLING EVERY OBSERVATION
!
      write (iprt,1500)
      call mvp (ym, n, m, iym, 1)
!
      return
!
!     FORMATS
!
 1000 format ('1*CH3')
 1100 format (' SIMPLE TEST OF NRAND')
 1200 format ('1SIMPLE TEST OF NRANDC')
 2000 format (/' THE VALUE OF IERR IS ', i4)
 1400 format (/' GENERATED RESULTS = '//(5e15.8))
 1500 format ('1MVP DISPLAY OF GENERATED RESULTS')
      end
!DCOEF
      subroutine dcoef (ndf, nd, iod, npardf, pardf, mbo, work)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE EXPANDS THE DIFFERENCE FILTER SPECIFIED BY NDF,
!     IOD AND ND INTO PARDF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   mbo,ndf,npardf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   pardf(*),work(*)
     integer&
     &   iod(*),nd(*)
!
!  LOCAL SCALARS
     integer&
     &   k,kk,l,ntimes,nwork1,nwork2
!
!  EXTERNAL FUNCTIONS
     integer&
     &   nchose
!       EXTERNAL NCHOSE
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL MULTBP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IOD(NDF)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER KK
!        AN INDEX VARIABLE.
!     INTEGER L
!        AN INDEX VARIABLE.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER ND(NDF)
!        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED.
!     INTEGER NDF
!        THE NUMBER OF DIFFERENCE FACTORS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NTIMES
!        THE NUMBER OF TIMES A GIVEN DIFFERENCE FACTOR IS TO BE APPLIED.
!     INTEGER NWORK1
!        THE NUMBER OF TERMS IN THE FIRST COLUMN OF WORK.
!     INTEGER NWORK2
!        THE NUMBER OF TERMS IN THE SECOND COLUMN OF WORK
!     REAL PARDF(MBO)
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS.
!     REAL WORK(MBO,2)
!        A WORK ARRAY NECESSARY TO EXPAND THE DIFFERENCE FILTER.
!
      npardf = 0
!
      do 30 l = 1, ndf
         if (nd(l).eq.0) go to 30
         ntimes = nd(l)
         nwork1 = iod(l) * nd(l)
         do 10 k = 1, nwork1
            work(k) = 0.0e0
   10    continue
         do 20 k = 1, ntimes
            kk = k * iod(l)
            work(kk) = ((-1)**(k+1)) * nchose(ntimes, k)
   20    continue
         nwork2 = nwork1 + npardf
        call multbp (work(1), nwork1, pardf, npardf, work(mbo+1),&
     &      nwork2, mbo)
   30 continue
      return
      end
!PPM
      subroutine ppm(ym, ymiss, x, xmiss, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT FOR DATA WITH MISSING OBSERVATIONS (SHORT CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: ymiss, xmiss
     integer&
     &   n
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: x(*),ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xlb,xub,ylb,yub
     integer&
     &   ilog,iprt,ischck,isize,iym,lisym,m,nout
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
      real(kind=wp) :: ymmiss(1)
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YMISS
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'P',       'P',       'M',       ' ',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      ymmiss=ymiss
      m = 1
      iym = n
      multi = .false.
      ilog = -1
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 0.0e0
      xub = 0.0e0
      ischck = 0
      isize = -1
      nout = 0
      miss = .true.
      lisym = 1
!
     call ppcnt (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL PPM (Y, YMISS, X, XMISS, N)')
      end
!SUMDS
     subroutine sumds(x, n, lo, mid, hi, xmeanw, sumda, sumd2, sumd3,&
     &   sumd4)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO CALCULATE UNWEIGHTED SUMS OF POWERS OF
!     DIFFERENCES FROM THE WEIGHTED MEAN FOR A SORTED
!     VECTOR IN WHICH THE MIDTH ELEMENT IS THE ELEMENT
!     CLOSEST TO ZERO.  USED BY THE STAT FAMILY.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   sumd2,sumd3,sumd4,sumda,xmeanw
     integer&
     &   hi,lo,mid,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   diff
     integer&
     &   curhi,curlo,i,irev
!
!  INTRINSIC FUNCTIONS
      intrinsic abs
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CURHI
!        THE UPPER BOUND OF THE CURRENT INTERVAL.
!     INTEGER CURLO
!        THE LOWER BOUND OF THE CURRENT INTERVAL.
!     REAL DIFF
!        THE DIFFERENCES BETWEEN X(I) AND XMEANW.
!     INTEGER HI
!        INPUT PARAMETER.  THE UPPER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER I
!        A LOOP PARAMETER.
!     INTEGER IREV
!        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
!        IN THE REVERSE ORDER.
!     INTEGER LO
!        INPUT PARAMETER.  THE LOWER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER MID
!        INPUT PARAMETER.  THE INDEX OF THE ELEMENT IN X CLOSEST TO
!        ZERO IN VALUE.  THE POINT OUT FROM WHICH THE SUMMING IS
!        DONE.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
!     REAL SUMDA
!        OUTPUT PARAMETER.  THE SUM OF THE ABSOLUTE VALUES OF THE
!        DIFFERENCES DIFF.
!     REAL SUMD2
!        OUTPUT PARAMETER.  THE SUM OF THE SQUARES OF THE
!        DIFFERENCES DIFF.
!     REAL SUMD3
!        OUTPUT PARAMETER.  THE SUM OF THE CUBES OF THE
!        DIFFERENCES DIFF.
!     REAL SUMD4
!        OUTPUT PARAMETER.  THE SUM OF THE HYPERCUBES OF THE
!        DIFFERENCES DIFF.
!     REAL X(N)
!        INPUT PARAMETER.  THE DATA ARRAY X IN WHICH THE SUMS ARE TAKEN.
!     REAL XMEANW
!        INPUT PARAMETER.  THE WEIGHTED MEAN OF X.
!
!     INITIALIZE SUMMATION VARIABLES.
!
      diff = x(mid) - xmeanw
      sumda = abs(diff)
      sumd2 = diff*diff
      sumd3 = diff*diff*diff
      sumd4 = diff*diff*diff*diff
      curlo = mid - 1
      curhi = mid + 1
!
!     SUM OUTWARDS FROM THE VALUE NEAREST ZERO.  THAT IS, SUM FROM
!     THE LEAST IN MAGNITUDE TO THE GREATEST.
!
   10 if (curhi.gt.hi .or. curlo.lt.lo) go to 30
      if (abs(x(curhi)).lt.abs(x(curlo))) go to 20
      diff = x(curlo) - xmeanw
      sumda = sumda + abs(diff)
      sumd2 = sumd2 + diff*diff
      sumd3 = sumd3 + diff*diff*diff
      sumd4 = sumd4 + diff*diff*diff*diff
      curlo = curlo - 1
      go to 10
   20 diff = x(curhi) - xmeanw
      sumda = sumda + abs(diff)
      sumd2 = sumd2 + diff*diff
      sumd3 = sumd3 + diff*diff*diff
      sumd4 = sumd4 + diff*diff*diff*diff
      curhi = curhi + 1
      go to 10
!
!     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
!     CENTER ZERO POINT.
!
   30 if (curhi.gt.hi) go to 50
      do 40 i=curhi,hi
         diff = x(i) - xmeanw
         sumda = sumda + abs(diff)
         sumd2 = sumd2 + diff*diff
         sumd3 = sumd3 + diff*diff*diff
         sumd4 = sumd4 + diff*diff*diff*diff
   40 continue
   50 if (curlo.lt.lo) go to 70
      do 60 irev=lo,curlo
         i = lo - irev + curlo
         diff = x(i) - xmeanw
         sumda = sumda + abs(diff)
         sumd2 = sumd2 + diff*diff
         sumd3 = sumd3 + diff*diff*diff
         sumd4 = sumd4 + diff*diff*diff*diff
   60 continue
   70 return
      end
!CORRMN
     subroutine corrmn(ym, n, m, iym, avg, sd, t, rank, sc, pc, scinv,&
    &   iwrk, wrk, slsc, slpc, srcc, quad, ciup, cilo, qf, nprt,&
     &   vcv, ivcv, liwrk, lwrk)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN ROUTINE FOR THE CORRELATION FAMILY, IT WAS
!     ADAPTED FROM THE OMNITAB ROUTINE CORREL. IT DOES A  CORRELATION
!     ANALYSIS OF A MULTIVARIATE RANDOM SAMPLE.
!     THE FOLLOWING TABLES ARE PRODUCED
!        SIMPLE CORRELATION COEFFICIENTS,
!        PARTIAL CORRELATION COEFFICIENTS,
!        AND THEIR SIGINIFICANCE LEVELS,
!        SPEARMAN RANK COEFFICIENTS,
!        QUADRATIC RELATIONSHIP,
!        95 AND 99 PERCENT CONFIDENCE INTERVALS.
!
!     THIS ROUTINE WAS ADAPTED FROM AN OMNITAB ROUTINE.
!
!     ADAPTED BY -
!        JANET R. DONALDSON AND LINDA L. MITCHELL
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ivcv,iym,liwrk,lwrk,m,n,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   avg(m),cilo(m,m),ciup(m,m),pc(m,m),qf(m,m),quad(n,3),&
    &   rank(n,m),sc(m,m),scinv(m,m),sd(m),slpc(m,m),slsc(m,m),&
     &   srcc(m,m),t(m),vcv(ivcv,m),wrk(lwrk),ym(iym,m)
     integer&
     &   iwrk(liwrk)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   b,f,fn3,fplm,hl1,hl2,sqsum,sum,z,zz
     integer&
     &   i,ier,iprt,j,k,k1,k2,nsum
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   c(3),d(3),rr(3,3),xx(3)
     integer&
     &   inert(3)
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   CDFF,R1MACH
!      EXTERNAL CDFF,R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AMEAN,CORRHD,DOTC,IPRINT,MATPRT,MGS,RANKO,SSIDI,SSIFA,
!     +   VCVOUT
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,int,log,max,min,real,sign,sqrt,tanh
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AVG(M)
!                  CONTAINS THE COLUMN AVERAGES OF YM
!     REAL B
!                  = (N-1) * N * (N+1) / 6
!     REAL C(3)
!                  *
!     REAL CILO(M,M)
!                  LOWER CONFIDENCE INTERVAL FOR SC
!     REAL CIUP(M,M)
!                  UPPER CONFIDENCE INTERVAL FOR SC
!     REAL D(3)
!                  A DUMMY ARRAY.
!     REAL F
!                  SQUARE ROOT OF FN3
!     REAL FN3
!                  REAL REPRESENTATION OF (N-3).
!     REAL FPLM
!                  THE FLOATING POINT LARGEST MAGNITUDE
!     REAL HL1
!                  *
!     REAL HL2
!                  *
!     INTEGER I
!                  AN INDEX VARIABLE
!     INTEGER IER
!                  ERROR FLAG FOR SUBROUTINES CALLED FROM THIS ROUTINE
!     INTEGER IERR
!                  WHEN RETURNED BY THIS ROUTINE, DESGINATES WHETHER ANY
!                  ERRORS WERE DETECTED DURING COMPUTATIONS
!                     IF IERR .EQ. 0, NO ERRORS
!                             .EQ. 1, ERRORS WERE DETECTED
!     INTEGER INERT(3)
!                  THE INERTIA OF THE SIMPLE CORRELATION MATRIX.
!     INTEGER IPRT
!                  THE LOGICAL OUTPUT NUMBER
!     INTEGER IVCV
!                  THE ROW DIMENSION OF VCV SPECIFIED IN THE USERS PROGR
!     INTEGER IWRK(LIWRK)
!                  A WORK VECTOR FOR THE INVERSION ROUTINE
!     INTEGER IYM
!                  THE ROW DIMENSION OF YM SPECIFIED IN THE USERS PROGRA
!     INTEGER J
!                  AN INDEX VARIABLE
!     INTEGER K
!                  AN INDEX VARIABLE
!     INTEGER K1
!                  *
!     INTEGER K2
!                  *
!     INTEGER LIWRK
!                  THE LENGTH OF THE INTEGER WORK VECTOR.
!     INTEGER LWRK
!                  THE LENGTH OF THE REAL WORK VECTOR.
!     INTEGER M
!                  THE NUMBER OF VARIABLES (THE COLUMN DIMENSION OF YM)
!     INTEGER N
!                  THE NUMBER OF OBSERVATIONS
!     INTEGER NPRT
!                  THE VARIABLE CONTROLLING THE AUTOMATIC PRINTOUT
!                  NPRT =0, PRINTOUT IS SUPPRESSED
!                  OTHERWISE PRINTOUT IS PROVIDED
!     INTEGER NSUM
!                  THE NUMBER OF OBSERVATIONS IN THE DOT PRODUCT
!     REAL PC(M,M)
!                  PARTIAL CORRELATION COEFFICIENTS MATRIX
!     REAL QF(M,M)
!                  QUADRATIC FIX MATRIX
!     REAL QUAD(N,3)
!                  DOUBLE VERSION OF QF MATRIX
!     REAL RANK(N,M)
!                  THE MATRIX CONTAING THE RANKS OF YM
!     REAL RR(3,3)
!                  *
!     REAL SC(M,M)
!                  SIMPLE CORRELATION COEFFICIENTS MATRIX
!     REAL SCINV(M,M)
!                  THE INVERSE MATRIX OF SC
!     REAL SD(M)
!                  STANDARD DEVIATION OF THE COMLUMNS OF YM
!     REAL SLPC(M,M)
!                  SIGNIFICANCE LEVELS OF PC
!     REAL SLSC(M,M)
!                  SIGNIFICANCE LEVELS OF SC
!     REAL SQSUM
!                  THE SUM OF SQUARES OF THE ITH COLUMN OF YM
!     REAL SRCC(M,M)
!                  SPEARMAN RANK CORRELATION COEFFICIENTS
!     REAL SUM
!                  USED IN CALCULATING THE STATISTICS OF YM
!     REAL T(M)
!                  USED IN DETERMINING SRCC
!     REAL VCV(IVCV,M)
!                  THE VARIANCE COVARIANCE MATRIX.
!     REAL WRK(LWRK)
!                  WORK STORAGE
!     REAL XX(3)
!                  *
!     REAL YM(IYM,M)
!                  THE MATRIX WHOSE COLUMNS EACH CONTAIN ONE OF M SETS
!                  OF N OBSERVATIONS. EACH COLUMN REPRESENTS A DIFFERENT
!                  VARIABLE
!     REAL Z
!                  USED IN COMPUTING CONFIDENCE INTERVALS
!     REAL ZZ
!                  USED IN DETERMINING CORRELATION COEFFICIENTS
!
      ierr = 0
!
      fplm = r1mach(2)
      call iprint(iprt)
!
      do 10 j=1,m
         call amean(ym(1,j), n, avg(j))
   10 continue
!
!     COMPUTE VARIANCE-COVARIANCE MATRIX
!
      do 30 j=1,m
         do 20 i=j,m
            call dotc(ym(1,j), avg(j), n, ym(1,i), avg(i), n, sum, nsum)
            vcv(j,i) = sum/(nsum-1)
            vcv(i,j) = vcv(j,i)
   20    continue
   30 continue
!
      if (nprt.eq.0) return
!
!     PRINT VARIANCE-COVARIANCE MATRIX AND SIMPLE CORRELATION
!     COEFFICIENTS
!
      call corrhd(iprt, m, n)
      call vcvout(m, vcv, ivcv, .false.)
!
!     COMPUTE STANDARD DEVIATIONS
!
      do 40 i=1,m
         if (vcv(i,i).le.0.0e0) go to 90
         sd(i) = sqrt(vcv(i,i))
   40 continue
!
!     COMPUTE SIMPLE CORRELATION COEFFICIENTS
!
      do 60 j=1,m
         do 50 i=j,m
            sc(i,j) = 1.0e0
            scinv(j,i) = 1.0e0
            if (i.eq.j) go to 50
            sc(i,j) = vcv(i,j)/sd(i)/sd(j)
            sc(j,i) = sc(i,j)
            scinv(j,i) = sc(i,j)
   50    continue
   60 continue
!
      if ((m.le.2) .or. (n.le.m)) go to 190
!
!     CALCULATE PARTIAL CORRELATION COEFFICIENTS.
!
      call ssifa(scinv, m, m, iwrk, ier)
      if (ier.eq.0) go to 100
   90 write (iprt,1000)
      ierr = 1
      return
  100 continue
      call ssidi(scinv, m, m, iwrk, d, inert, wrk, 1)
      do 130 j=1,m
         do 120 i=j,m
            pc(i,j) = 1.0e0
            if (i.eq.j) go to 120
            zz = scinv(i,i)*scinv(j,j)
            pc(i,j) = fplm
            if (zz.le.0.0e0) go to 110
            pc(i,j) = -scinv(j,i)/sqrt(zz)
            if (abs(pc(i,j)).gt.1.0e0) pc(i,j) = sign(1.0e0,pc(i,j))
  110       pc(j,i) = pc(i,j)
  120    continue
!
  130 continue
!
!     COMPUTE SIGNIFICANCE LEVELS OF PARTIAL CORRELATION COEFFICIENTS.
!     NOTE, LOWER TRIANGULAR MATRIX STORED IN SQUARE MATRIX.
!
      do 180 i=1,m
         do 170 j=1,i
            if (pc(i,j).ne.0.0e0) go to 140
            slpc(i,j) = 1.0e0
            go to 170
  140       if (abs(pc(i,j)).lt.1.0e0) go to 150
            slpc(i,j) = 0.0e0
            go to 170
  150       f = pc(i,j)*pc(i,j)
            if (1.0e0-f.ne.0.0e0) go to 160
            slpc(i,j) = fplm
            go to 170
  160       f = (n-m)*f/(1.0e0-f)
            slpc(i,j) = 1.0e0 - cdff(f,1.0e0,real(n-m))
  170    continue
  180 continue
!
!     COMPUTE SIGNIFICANCE LEVELS OF SIMPLE CORRELATION COEFFICIENTS
!     NOTE, ONLY LOWER TRIANGULAR STORED IN SQUARE MATRIX.
!
  190 do 250 i=1,m
         do 240 j=1,i
            if (i.ne.j) go to 200
            slsc(i,j) = 0.0e0
            go to 240
  200       if (sc(i,j).ne.0.0e0) go to 210
            slsc(i,j) = 1.0e0
            go to 240
  210       if (abs(sc(i,j)).lt.1.0e0) go to 220
            slsc(i,j) = 0.0e0
            go to 240
  220       f = sc(i,j)*sc(i,j)
            if (f.ne.1.0e0) go to 230
            slsc(i,j) = fplm
            go to 240
  230       f = (n-2)*f/(1.0e0-f)
            slsc(i,j) = 1.0e0 - cdff(f,1.0e0,real(n-2))
  240    continue
  250 continue
!
!     PRINT SIGNIFICANCE LEVELS OF SIMPLE CORRELATION COEFFICIENTS,
!     PARTIAL CORRELATION COEFFICIENTS AND SIGNIFICANCE LEVELS
!
      write (iprt,1020)
      call matprt(slsc, slsc, m, iprt, 0, 1, m)
      if ((m.gt.2) .and. (n.gt.m)) go to 260
      write (iprt,1010)
      go to 270
  260 i = m - 2
      write (iprt,1030) i
      call matprt(pc, pc, m, iprt, 0, 1, m)
      write (iprt,1040)
      call matprt(slpc, slpc, m, iprt, 0, 1, m)
  270 continue
!
!     DETERMINE THE RANKS OF THE OBSERVATIONS.
!
      do 280 i=1,m
         call ranko(n, ym(1,i), iwrk, rank(1,i), t(i))
         t(i) = t(i) / 12.0e0
  280 continue
!
!     COMPUTE SPEARMAN RANK CORRELATION COEFFICIENTS.
!     NOTE, LOWER TRIANGULAR MATRIX, STORED IN SQUARE MATRIX.
!
      b = (n-1)*n*(n+1)/6
      do 330 i=1,m
         do 320 j=1,i
            srcc(i,j) = 1.0e0
            if (i.eq.j) go to 320
            k1 = 2.0e0*t(i) + 0.4e0
            k2 = 2.0e0*t(j) + 0.4e0
            srcc(i,j) = fplm
            if ((int(b)-k1.le.0) .or. (int(b)-k2.le.0)) go to 320
            sum = 0.0e0
            do 310 k=1,n
               zz = rank(k,i) - rank(k,j)
               sum = sum + zz*zz
  310       continue
            zz = (b - 2.0e0*t(i))*(b - 2.0e0*t(j))
            if (zz.gt.0.0e0) srcc(i,j) = (b-sum-t(i)-t(j))/sqrt(zz)
  320    continue
  330 continue
!
!     PRINT SPEARMAN RANK CORRELATIONS COEFFICIENTS
!
      write (iprt,1050)
      call matprt(srcc, srcc, m, iprt, 0, 1, m)
!
      if (n.gt.3) go to 340
      write (iprt,1060)
      return
!
!     COMPUTE THE SIGNIFICANCE LEVELS OF THE QUADRATIC FIT OVER THE
!     LINEAR FIT.
!
!     THESE CALCULATIONS MAY PRODUCE VARIABLE RESULTS IN VARYING
!     MACHINE/COMPILATION ENVIRONMENTS, IN CASES IN WHICH THE
!     YM MATRIX IS NEAR SINGULAR (ESSENTIALLY SINGULAR BUT THE
!     SINGULARITY IS UNDETECTED BY THE CODE).  THE OBSERVED SYMPTOMS
!     ARE ALTERNATION BETWEEN QF VALUES OF 0.0E0 (FIRST F = LINE
!     PRODUCES ZERO) AND 1.0E0 (FIRST F = LINE PRODUCES APPROX.
!     ZERO, AND NUMERATOR IN SECOND F = LINE IS NONZERO).
!
  340 fn3 = n-3
      do 410 j=1,m
         do 400 i=1,m
            if (i.ne.j) go to 350
            qf(i,j) = 1.0e0
            go to 400
  350       sqsum = 0.0e0
            do 360 k=1,n
              quad(k,1) = 1.0e0
               quad(k,2) = ym(k,j)
               quad(k,3) = ym(k,j)*ym(k,j)
               sqsum = sqsum + ym(k,i)*ym(k,i)
               wrk(k) = ym(k,i)
  360       continue
            call mgs(quad, wrk, n, 3, xx, c, d, rr, 3, n, ier)
            if (ier.eq.0) go to 370
            write (iprt,1090)
            go to 420
  370       do 380 k=1,3
               c(k) = c(k)*sqrt(d(k))
  380       continue
            f = (sqsum-c(1)*c(1)-c(2)*c(2)-c(3)*c(3))
            qf(i,j) = 0.0e0
            if (f.eq.0.0e0) go to 400
            f = (c(3)*c(3)*fn3)/f
            qf(i,j) = 1.0e0
            if (f.gt.0.0e0) qf(i,j) = 1.0e0 - cdff(f,1.0e0,fn3)
  400    continue
  410 continue
!
!     PRINT THE QUADRATIC FIT MATRIX
!
      j = 2
      k = 1
      i = n - 3
      write (iprt,1070) i, qf(j,k), j, k
      call matprt(qf, qf, m, iprt, 1, 1, m)
!
!     COMPUTE CONFIDENCE LIMITS FOR SIMPLE CORRELATION COEFFICIENTS
!
  420 f = sqrt(fn3)
      hl1 = 2.5758293e0/f
      hl2 = 1.9599640e0/f
      do 520 j=1,m
         do 510 i=1,m
            if (i.ne.j) go to 430
            ciup(i,j) = 99.0e0
            cilo(i,j) = 95.0e0
            go to 510
  430       if (i.lt.j) go to 470
!
!           COMPUTE 95 PERCENT INTERVALS.
!
            if (sc(i,j).ge.1.0e0) go to 440
            if (sc(i,j).gt.-1.0e0) go to 450
            z = -1.0e0
            go to 460
  440       z = 1.0e0
            go to 460
  450       z = 0.5e0*log((1.0e0+sc(i,j))/(1.0e0-sc(i,j)))
  460       ciup(i,j) = min(tanh(z+hl2),1.0e0)
            cilo(i,j) = max(tanh(z-hl2),-1.0e0)
            go to 510
!
!           COMPUTE 99 PERCENT INTERVALS.
!
  470       if (sc(j,i).ge.1.0e0) go to 480
            if (sc(j,i).gt.-1.0e0) go to 490
            z = -1.0e0
            go to 500
  480       z = 1.0e0
            go to 500
  490       z = 0.5e0*log((1.0e0+sc(j,i))/(1.0e0-sc(j,i)))
  500       ciup(i,j) = min(tanh(z+hl1),1.0e0)
            cilo(i,j) = max(tanh(z-hl1),-1.0e0)
  510    continue
  520 continue
!
!     PRINT CONFIDENCE LIMITS
!
      write (iprt,1080)
      call matprt(ciup, cilo, m, iprt, 1, 2, m)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/ 46h computation stopped due to singular or ill-co,&
     &   28hnditioned covariance matrix.)
1010 format (//42h the partial correlation coefficients (and, 6h signi,&
    &   50hficance levels) are not printed or defined because/6h eithe,&
    &   52hr the number of vectors being compared is two or the,&
    &   59h number of measurements is less than or equal to the number/&
     &   27h of vectors being compared.)
1020 format (// 44h significance levels of simple correlation c,&
     &   32hoefficients (assuming normality))
1030 format (// 38h partial correlation coefficients with, i3,&
     &   26h remaining variables fixed)
1040 format (// 44h significance levels of partial correlation ,&
     &   33hcoefficients (assuming normality))
1050 format (// 44h spearman rank correlation coefficients (adj,&
     &   15husted for ties))
1060 format (// 44h nonlinearity test and approximation of conf,&
     &   39hidence intervals not defined for n = 3.)
1070 format (// 45h significance level of quadratic fit over lin,&
    &   35hear fit based on f ratio with 1 and, i5, 15h degrees of fre,&
    &   4hedom/14h (for example,, f7.4, 19h is the significanc,&
    &   41he level of the quadratic term when column, i3, 9h is fitte,&
     &   11hd to column, i3, ')')
1080 format (// 44h confidence intervals for simple correlation,&
    &   43h coefficients (using fisher transformation)/' 95 PER C',&
    &   59hent limits below diagonal, 99 per cent limits above diagona,&
     &   'L')
1090 format (/ 46h significance levels of quadratic fit over lin,&
    &   30hear fit have not been computed/' DUE TO SINGULARITY IN',&
     &   32h design matrix. check your data.)
      end
!XXCH13
      subroutine xxch13(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE ARIMA MODELING AND FORECASTING FAMILY OF ROUTINES.
!
!     DATA IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND JENKINS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   i,iprt,n,nfac,npar
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   air(200),par(10),res(200),y(200)
     integer&
     &   mspec(4,10)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AIME,AIMF,IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic log
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AIR(200)
!        THE AIRLINE DATA.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER MSPEC(4,10)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH
!        FACTOR.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     REAL PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL RES(200)
!        THE RESIDUALS FROM THE FIT.
!     REAL Y(200)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     DEFINE CONSTANTS
!
     data mspec(1,1), mspec(2,1), mspec(3,1), mspec(4,1)&
     &   /          0,          1,          1,          1/
     data mspec(1,2), mspec(2,2), mspec(3,2), mspec(4,2)&
     &   /          0,          1,          1,         12/
!
     data  air(  1), air(  2), air(  3), air(  4), air(  5), air(  6)&
     &    / 112.0e0, 118.0e0, 132.0e0, 129.0e0, 121.0e0, 135.0e0/
     data  air(  7), air(  8), air(  9), air( 10), air( 11), air( 12)&
     &    / 148.0e0, 148.0e0, 136.0e0, 119.0e0, 104.0e0, 118.0e0/
     data  air( 13), air( 14), air( 15), air( 16), air( 17), air( 18)&
     &    / 115.0e0, 126.0e0, 141.0e0, 135.0e0, 125.0e0, 149.0e0/
     data  air( 19), air( 20), air( 21), air( 22), air( 23), air( 24)&
     &    / 170.0e0, 170.0e0, 158.0e0, 133.0e0, 114.0e0, 140.0e0/
     data  air( 25), air( 26), air( 27), air( 28), air( 29), air( 30)&
     &    / 145.0e0, 150.0e0, 178.0e0, 163.0e0, 172.0e0, 178.0e0/
     data  air( 31), air( 32), air( 33), air( 34), air( 35), air( 36)&
     &    / 199.0e0, 199.0e0, 184.0e0, 162.0e0, 146.0e0, 166.0e0/
     data  air( 37), air( 38), air( 39), air( 40), air( 41), air( 42)&
     &    / 171.0e0, 180.0e0, 193.0e0, 181.0e0, 183.0e0, 218.0e0/
     data  air( 43), air( 44), air( 45), air( 46), air( 47), air( 48)&
     &    / 230.0e0, 242.0e0, 209.0e0, 191.0e0, 172.0e0, 194.0e0/
     data  air( 49), air( 50), air( 51), air( 52), air( 53), air( 54)&
     &    / 196.0e0, 196.0e0, 236.0e0, 235.0e0, 229.0e0, 243.0e0/
     data  air( 55), air( 56), air( 57), air( 58), air( 59), air( 60)&
     &    / 264.0e0, 272.0e0, 237.0e0, 211.0e0, 180.0e0, 201.0e0/
     data  air( 61), air( 62), air( 63), air( 64), air( 65), air( 66)&
     &    / 204.0e0, 188.0e0, 235.0e0, 227.0e0, 234.0e0, 264.0e0/
     data  air( 67), air( 68), air( 69), air( 70), air( 71), air( 72)&
     &    / 302.0e0, 293.0e0, 259.0e0, 229.0e0, 203.0e0, 229.0e0/
     data  air( 73), air( 74), air( 75), air( 76), air( 77), air( 78)&
     &    / 242.0e0, 233.0e0, 267.0e0, 269.0e0, 270.0e0, 315.0e0/
     data  air( 79), air( 80), air( 81), air( 82), air( 83), air( 84)&
     &    / 364.0e0, 347.0e0, 312.0e0, 274.0e0, 237.0e0, 278.0e0/
     data  air( 85), air( 86), air( 87), air( 88), air( 89), air( 90)&
     &    / 284.0e0, 277.0e0, 317.0e0, 313.0e0, 318.0e0, 374.0e0/
     data  air( 91), air( 92), air( 93), air( 94), air( 95), air( 96)&
     &    / 413.0e0, 405.0e0, 355.0e0, 306.0e0, 271.0e0, 306.0e0/
     data  air( 97), air( 98), air( 99), air(100), air(101), air(102)&
     &    / 315.0e0, 301.0e0, 356.0e0, 348.0e0, 355.0e0, 422.0e0/
     data  air(103), air(104), air(105), air(106), air(107), air(108)&
     &    / 465.0e0, 467.0e0, 404.0e0, 347.0e0, 305.0e0, 336.0e0/
     data  air(109), air(110), air(111), air(112), air(113), air(114)&
     &    / 340.0e0, 318.0e0, 362.0e0, 348.0e0, 363.0e0, 435.0e0/
     data  air(115), air(116), air(117), air(118), air(119), air(120)&
     &    / 491.0e0, 505.0e0, 404.0e0, 359.0e0, 310.0e0, 337.0e0/
     data  air(121), air(122), air(123), air(124), air(125), air(126)&
     &    / 360.0e0, 342.0e0, 406.0e0, 396.0e0, 420.0e0, 472.0e0/
     data  air(127), air(128), air(129), air(130), air(131), air(132)&
     &    / 548.0e0, 559.0e0, 463.0e0, 407.0e0, 362.0e0, 405.0e0/
     data  air(133), air(134), air(135), air(136), air(137), air(138)&
     &    / 417.0e0, 391.0e0, 419.0e0, 461.0e0, 472.0e0, 535.0e0/
     data  air(139), air(140), air(141), air(142), air(143), air(144)&
     &    / 622.0e0, 606.0e0, 508.0e0, 461.0e0, 390.0e0, 432.0e0/
!
      call iprint(iprt)
!
      nfac = 2
      n = 144
!
      npar = 3
      par(1) = 0.000
      par(2) = 0.395
      par(3) = 0.615
!
      do 10 i = 1, n
        y(i) = log(air(i))
   10 continue
!
!     RUN SIMPLE TEST OF AIME
!
      write (iprt,1000)
      write (iprt,1100)
      call aime (y, n, mspec, nfac, par, npar, res, ldstak)
      write (iprt,2000) ierr
!
!     RUN SIMPLE TEST OF AIMF
!
      write (iprt,1200)
      call aimf (y, n, mspec, nfac, par, npar, ldstak)
      write (iprt,2000) ierr
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format ('1*CH13')
 1100 format (' SIMPLE TEST OF AIME')
 1200 format ('1SIMPLE TEST OF AIMF')
 2000 format (/' THE VALUE OF IERR IS ', i4)
      end
!XDCKLT
      subroutine xdcklt(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer ldstak
!
!  SCALARS IN COMMON
      integer ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
      real(kind=wp) :: delta
     integer i,iprt,ixm,j,jstop,ldsmin,m,n,neta,npar,nprt,nrow,ntau,&
     &   ntest
!
!  LOCAL ARRAYS
      real(kind=wp) :: par(10),scale(10),xm(200,2)
      integer nettst(6),nrotst(5),ntatst(6)
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) :: R1MACH
!      EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DCKLS,DCKLS1,DCKLSC,DRV4A,DRV4B,IPRINT,LDSCMP,MDL4,SETRV
!
!  INTRINSIC FUNCTIONS
      intrinsic log10
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        *
!     EXTERNAL DRV4A, DRV4B
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER J, JSTOP
!        *
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL4
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NETTST(6)
!        VARIOUS TEST VALUES FOR NETA.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NROTST(5)
!        VARIOUS TEST VALUES FOR NROW.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTATST(6)
!         VARIOUS TEST VALUES FOR NTAU.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     REAL PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL SCALE(10)
!        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL XM(200,2)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      call iprint(iprt)
!
!     SET PARAMETER VALUES
!
      call dckls1(n, m, ixm, par, npar, neta, ntau, nrow, scale, nprt)
     call ldscmp(5, 0, 2*npar+1, 0, 0, 0, 'S',&
     &            n*npar+npar+n, ldsmin)
!
      if (ldsmin.le.ldstak) go to 5
!
      write (iprt, 1020) ldsmin
      return
!
    5 continue
!
!     CREATE INDEPENDENT VARIABLE
!
      delta = 0.0625e0
      xm(1,1) = 0.0e0
      do 10 i=2,n
         xm(i,1) = xm(i-1,1) + delta
   10 continue
!
      ntest = 0
!
!
!     TEST VARIOUS VALUES OF NETA AND NTAU
!
      scale(1) = 0.0e0
!
      nettst(1) = -1
      nettst(2) = 0
      nettst(3) = 1
      nettst(4) = 2
!
      nettst(5) = -log10(r1mach(4))
      nettst(6) = nettst(5) + 1
!
      ntatst(1) = -1
      ntatst(2) = 0
      ntatst(3) = 1
!
      jstop = 3
!
      do 30 i=1,6
!
         ntatst(4) = nettst(i)/4
         if (i.le.5) then
            ntatst(5) = (nettst(i)-1)/2
            ntatst(6) = ntatst(5) + 1
         end if
!
         if (i.eq.5) jstop = 6
!
         do 20 j=1,jstop
!
            ntest = ntest + 1
            write (iprt,1130) ntest
            write (iprt,1100)
            write (iprt,1040)
            write (iprt,1060) nettst(i), ntatst(j), scale(1), nrow, nprt
            write (iprt,1000)
            ierr = -1
           call dcklsc(xm, n, m, ixm, mdl4, drv4a, par, npar, ldstak,&
     &         nettst(i), ntatst(j), scale, nrow, nprt)
            write (iprt,1050) ierr
            write (iprt,1140) nettst(i), ntatst(j), scale(1), nrow, nprt
!
   20    continue
!
   30 continue
!
!     SUPPRESS OUTPUT
!
      nprt = 0
!
      ntest = ntest + 1
      write (iprt,1130) ntest
      write (iprt,1100)
      write (iprt,1040)
      write (iprt,1060) neta, ntau, scale(1), nrow, nprt
      write (iprt,1010)
      ierr = -1
     call dcklsc(xm, n, m, ixm, mdl4, drv4a, par, npar, ldstak, neta,&
     &   ntau, scale, nrow, nprt)
      write (iprt,1050) ierr
      write (iprt,1140) neta, ntau, scale(1), nrow, nprt
!
!     LARGE CALCULATION ERROR PROBLEM
!
      call dckls1(n, m, ixm, par, npar, neta, ntau, nrow, scale, nprt)
      par(3) = 10.0e0**ntatst(5)
      scale(1) = 0.0e0
      nrow = 51
!
      ntest = ntest + 1
      write (iprt,1130) ntest
      write (iprt,1100)
      write (iprt,1070)
      write (iprt,1080)
      write (iprt,1060) neta, ntau, scale(1), nrow, nprt
      write (iprt,1010)
      ierr = -1
     call dcklsc(xm, n, m, ixm, mdl4, drv4a, par, npar, ldstak, neta,&
     &   ntau, scale, nrow, nprt)
      write (iprt,1050) ierr
      write (iprt,1140) neta, ntau, scale(1), nrow, nprt
!
!     NEARLY ZERO DERIVATIVE
!
      nrow = 50
!
      ntest = ntest + 1
      write (iprt,1130) ntest
      write (iprt,1100)
      write (iprt,1070)
      write (iprt,1090)
      write (iprt,1060) neta, ntau, scale(1), nrow, nprt
      write (iprt,1010)
      ierr = -1
     call dcklsc(xm, n, m, ixm, mdl4, drv4a, par, npar, ldstak, neta,&
     &   ntau, scale, nrow, nprt)
      write (iprt,1050) ierr
      write (iprt,1140) neta, ntau, scale(1), nrow, nprt
!
!     INCORRECTLY CODED DERIVATIVE
!
!     SIMPLE EXAMPLE
!
!     SET PARAMETER VALUES
!
      call dckls1(n, m, ixm, par, npar, neta, ntau, nrow, scale, nprt)
!
      ntest = ntest + 1
      write (iprt,1130) ntest
      write (iprt,1110)
      write (iprt,1040)
      write (iprt,1000)
      ierr = -1
      call dckls(xm, n, m, ixm, mdl4, drv4b, par, npar, ldstak)
      write (iprt,1050) ierr
!
      ntest = ntest + 1
      write (iprt,1130) ntest
      write (iprt,1110)
      write (iprt,1040)
      write (iprt,1060) neta, ntau, scale(1), nrow, nprt
      write (iprt,1010)
      ierr = -1
     call dcklsc(xm, n, m, ixm, mdl4, drv4b, par, npar, ldstak, neta,&
     &   ntau, scale, nrow, nprt)
      write (iprt,1050) ierr
      write (iprt,1140) neta, ntau, scale(1), nrow, nprt
!
!     SUPPRESS OUTPUT
!
      nprt = 0
!
      ntest = ntest + 1
      write (iprt,1130) ntest
      write (iprt,1110)
      write (iprt,1040)
      write (iprt,1060) neta, ntau, scale(1), nrow, nprt
      write (iprt,1010)
      ierr = -1
     call dcklsc(xm, n, m, ixm, mdl4, drv4b, par, npar, ldstak, neta,&
     &   ntau, scale, nrow, nprt)
      write (iprt,1050) ierr
      write (iprt,1140) neta, ntau, scale(1), nrow, nprt
!
!     LARGE CALCULATION ERROR PROBLEM
!
      call dckls1(n, m, ixm, par, npar, neta, ntau, nrow, scale, nprt)
!
      par(3) = 10.0e0**ntatst(5)
      nrow = 26
!
      ntest = ntest + 1
      write (iprt,1130) ntest
      write (iprt,1110)
      write (iprt,1070)
      write (iprt,1060) neta, ntau, scale(1), nrow, nprt
      write (iprt,1010)
      ierr = -1
     call dcklsc(xm, n, m, ixm, mdl4, drv4b, par, npar, ldstak, neta,&
     &   ntau, scale, nrow, nprt)
      write (iprt,1050) ierr
      write (iprt,1140) neta, ntau, scale(1), nrow, nprt
!
      par(4) = 0.75e0
      nrow = 1
!
      ntest = ntest + 1
      write (iprt,1130) ntest
      write (iprt,1110)
      write (iprt,1070)
      write (iprt,1060) neta, ntau, scale(1), nrow, nprt
      write (iprt,1010)
      ierr = -1
     call dcklsc(xm, n, m, ixm, mdl4, drv4b, par, npar, ldstak, neta,&
     &   ntau, scale, nrow, nprt)
      write (iprt,1050) ierr
      write (iprt,1140) neta, ntau, scale(1), nrow, nprt
!
!     CHECK VARIOUS VALUES OF NROW
!
      call dckls1(n, m, ixm, par, npar, neta, ntau, nrow, scale, nprt)
!
      call setrv(xm(1,1), n, 0.0e0)
      nrotst(1) = -1
      nrotst(2) = 0
      nrotst(3) = 1
      nrotst(4) = n
      nrotst(5) = n + 1
!
      do 40 i=1,5
!
         ntest = ntest + 1
         write (iprt,1130) ntest
         write (iprt,1110)
         write (iprt,1120)
         write (iprt,1060) neta, ntau, scale(1), nrotst(i), nprt
         write (iprt,1010)
         ierr = -1
        call dcklsc(xm, n, m, ixm, mdl4, drv4b, par, npar, ldstak,&
     &      neta, ntau, scale, nrotst(i), nprt)
         write (iprt,1050) ierr
         write (iprt,1140) neta, ntau, scale(1), nrotst(i), nprt
!
   40 continue
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (15h test of dckls )
 1010 format (15h test of dcklsc)
 1020 format (45h1 *** ldstak must be greater than or equal to , i6)
 1040 format (15h simple example)
1050 format (29h ***** returned results *****, 5x, 15h (-1 indicates ,&
     &   39hvalue not changed by called subroutine)//9h ierr is , i3)
1060 format (19h input   -  neta = , i5, 9h, ntau = , i5,&
     &   13h, scale(1) = , g15.8, 9h, nrow = , i5, 9h, nprt = , i5)
 1070 format (32h large calculation error problem)
 1080 format (16h zero derivative)
 1090 format (23h nearly zero derivative)
 1100 format (27h correctly coded derivative)
 1110 format (' INCORRECTLY CODED DERIVATIVE FOR PARAMETERS 1, 2 AND 4')
 1120 format (' ALL INDEPENDENT VARIABLES EQUAL TO ZERO')
 1130 format (43h1derivative checking subroutine test number, i5)
1140 format (19h output  -  neta = , i5, 9h, ntau = , i5,&
     &   13h, scale(1) = , g15.8, 9h, nrow = , i5, 9h, nprt = , i5//)
      end
!SETRA
      subroutine setra(array, im, m, n, value)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     SETS THE FIRST N ROWS AND M COLUMNS OF THE ARRAY
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   value
     integer&
     &   im,m,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   array(im,m)
!
!  LOCAL SCALARS
     integer&
     &   i,j
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ARRAY(IM,M)
!        ARRAY FOR WHICH ELEMENTS WILL BE SET
!     INTEGER I
!        *
!     INTEGER IM
!        ACTUAL FIRST DIMENSION OF ARRAY IN CALLING PROGRAM
!     INTEGER J
!        *
!     INTEGER M
!        NUMBER OF COLUMNS TO SET
!     INTEGER N
!        NUMBER OF ROWS TO SET
!     REAL VALUE
!        VALUE TO WHICH THE ELEMENTS ARE TO BE SET
!
!
      do 20 i=1,n
         do 10 j=1,m
            array(i,j) = value
   10    continue
   20 continue
      return
      end
!MPP
      subroutine mpp(ym, x, n, m, iym)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH MULTIPLE Y-AXIS VALUES (SHORT CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iym,m,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xlb,xmiss,xub,ylb,yub
     integer&
     &   ilog,iprt,ischck,isize,lisym,nout
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(IYM,M)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'M',       'P',       'P',       ' ',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      xmiss = 1.0e0
      multi = .true.
      ilog = -1
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 0.0e0
      xub = 0.0e0
      ischck = 2
      isize = -1
      nout = 0
      miss = .false.
      lisym = 1
!
     call ppcnt (ym, ym, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL MPP (YM, X, N, M, IYM)')
      end
!CENTER
      subroutine center (y, n, yc)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER ROUTINE FOR CENTERING THE OBSERVED SERIES Y,
!     RETURNING THE CENTERED SERIES IN YC.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*),yc(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iprt
     logical&
     &   err01,head
!
!  LOCAL ARRAYS
     character&
     &   ln(8)*1,nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL CNTR,EISGE,IPRINT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT NUMBER USED FOR OUTPUT.
!     CHARACTER*1 LN(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YC(N)
!        THE VECTOR IN WHICH THE CENTERED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'C',       'E',       'N',       'T',       'E',       'R'/
     data&
    & ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /'N',' ',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 2, 1, head, err01, ln)
      if (.not. err01) go to 5
!
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
    5 continue
!
      call cntr (y, n, yc)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   29h       call center (y, n, yc))
      end
!PPL
      subroutine ppl(ym, x, n, ilog)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT (LOG OPTION).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ilog,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xlb,xmiss,xub,ylb,yub
     integer&
     &   iprt,ischck,isize,iym,lisym,m,nout
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ymmiss(1)
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'P',       'P',       'L',       ' ',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      ymmiss(1) = 1.0e0
      xmiss = 1.0e0
      m = 1
      iym = n
      multi = .false.
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 0.0e0
      xub = 0.0e0
      ischck = 0
      isize = -1
      nout = 0
      miss = .false.
      lisym = 1
!
     call ppcnt (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL PPL (Y, X, N, ILOG)')
      end
!GFARFS
     subroutine gfarfs (phi, iar, nf, fmin, fmax, gain, phas, freq,&
     &   nprt, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE TO COMPUTE THE GAIN
!     FUNCTION OF AN AUTOREGRESSIVE FILTER (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fmax,fmin
     integer&
     &   iar,ldstak,nf,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(*),gain(*),phas(*),phi(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,fmn,fmx,ypltmn,ypltmx
     integer&
     &   igferr,io,iprt,isort,ldsmin,nall0,nord,xord,yord
     logical&
     &   err01,err02,err03,head,sym
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     character&
     &   liar(8)*1,llds(8)*1,lnf(8)*1,nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,GFAEST,GFORD,GFOUT,IPRINT,LDSCMP,SETFRQ,STKCLR,
!     +   STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic max,min
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03
!        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     REAL FMAX, FMIN
!        THE MINIMUM AND MAXIMUM FREQUENCY FOR WHICH THE GAIN
!        FUNCTION IS TO BE ESTIMATED.
!     REAL FMN, FMX
!        THE FREQUENCY RANGE ACTUALLY USED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        HAS BEEN ESTIMATED.
!     REAL GAIN(NF)
!        THE VECTOR IN WHICH THE GAIN FUNCTION ESTIMATES ARE
!        STORED.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IGFERR
!        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
!        TO HAVE PRODUCED REASONABLE RESULTS.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION IN ISTAK FOR
!        THE ARRAY USED FOR SORTING.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     CHARACTER*1 LIAR(8), LLDS(8), LNF(8)
!        THE ARRAYS CONTAINING THE NAMES OF CHECKED VARIABLES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        IS TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NORD
!        THE NUMBER OF POINTS TO BE PLOTTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     REAL PHAS(NF)
!        THE ARRAY IN WHICH THE PHASE OF THE FILTER IS RETURNED.
!     REAL PHI(IAR)
!        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL SYM
!        THE VARIABLE USED TO INDICATE WHETHER THE GAIN FUNCTION
!        COMPUTED WAS FOR A SYMMETRIC OR AUTOREGRESSIVE FILTER.
!     INTEGER XORD
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE X COORDINATES FOR THE GAIN FUNCTION PLOT
!     INTEGER YORD
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE Y COORDINATES FOR THE GAIN FUNCTION PLOT
!     REAL YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'G',       'F',       'A',       'R',       'F',       'S'/
     data&
    &  liar(1), liar(2), liar(3), liar(4), liar(5), liar(6),&
     &  liar(7), liar(8) /'I', 'A', 'R', ' ', ' ', ' ', ' ', ' '/
     data&
    &  llds(1), llds(2), llds(3), llds(4), llds(5), llds(6), llds(7),&
     &  llds(8) /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
     data&
    &  lnf(1), lnf(2), lnf(3), lnf(4), lnf(5), lnf(6), lnf(7), lnf(8)&
     & /  'N',   'F',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
      io = 1
      if (nprt .eq. 0) io = 0
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, liar, iar, 1, 1, head, err01, liar)
!
      call eisge(nmsub, lnf, nf, 1, 1, head, err02, lnf)
!
      if (err02) go to 10
!
      call ldscmp(3*io, 0, nf, 0, 0, 0, 'S', 2*io*nf, ldsmin)
!
      call eisge(nmsub, llds, ldstak, ldsmin, 9, head, err03, llds)
!
      if (err01.or.err02.or.err03) go to 10
      go to 20
!
   10   ierr = 1
        call iprint (iprt)
        write (iprt, 1000)
        return
!
   20 continue
!
      if (nprt .ne. 0) then
        call stkset (ldstak, 4)
        nall0 = stkst(1)
      else
        nall0 = 0
      end if
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      sym = .false.
!
      delta = 1.0e0
!
!     SET FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO BE ESTIMATED
!
      fmn = max(fmin, 0.0e0)
      fmx = min(fmax, 0.5e0)
      if (fmn.ge.fmx) then
        fmn = 0.0e0
        fmx = 0.5e0
      end if
      call setfrq (freq, nf, 2, fmn, fmx, delta)
!
!     COMPUTE THE GAIN FUNCTION
!
      call gfaest (phi, iar, nf, freq, gain, phas, delta)
!
      if (nprt .eq. 0) return
!
!     SET VARIOUS POINTERS FOR THE PLOTTING ARRAYS
!
      xord = stkget(nf, 3)
      yord = stkget(nf, 3)
!
      isort = stkget(nf, 2)
!
      if (ierr .eq. 1) go to 10
!
!     PLOT THE RESULTS
!
     call gford (freq, gain, istak(isort), nf, rstak(xord),&
     &   rstak(yord), nord, ypltmn, ypltmx, nprt, igferr)
     call gfout (rstak(xord), rstak(yord), nord, freq, phas, nf,&
     &   iar, sym, fmn, fmx, ypltmn, ypltmx, nprt, igferr, nmsub)
!
      call stkclr(nall0)
!
      if (ierr .eq. 1) go to 10
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    & '       CALL GFARFS (PHI, IAR,'/&
    & '      +             NF, FMIN, FMAX, GAIN, PHAS, FREQ, NPRT,',&
     & ' LDSTAK)')
      end
!SVPL
      subroutine svpl(ym, n, ns, isym, ilog)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH USER CONTROL OF THE PLOT SYMBOL USED (LOG PLOT OPTION).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ilog,n,ns
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(*)
     integer&
     &   isym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ibar,iprt,irlin,ischck,isize,iym,lisym,m
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'S',       'V',       'P',       'L',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      m = 1
      iym = n
      multi = .false.
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 1.0e0
      xinc = 1.0e0
      ischck = 1
      isize = -1
      miss = .false.
      lisym = n
      irlin = -1
      ibar = 0
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ym, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL SVPL (Y, N, NS, ISYM, ILOG)')
      end
!CPYMSS
      subroutine cpymss (n, m, x, ix, y, iy)
!
!     LATEST REVISION  -  03/15/90  (JRD
!
!     THIS ROUTINE COPIES THE N BY M ELEMENTS OF MATRIX X TO
!     MATRIX Y.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ix,iy,m,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(ix,*),y(iy,*)
!
!  LOCAL SCALARS
     integer&
     &   i,j
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER IX
!        THE FIRST DIMENSION OF THE MATRIX X.
!     INTEGER IY
!        THE FIRST DIMENSION OF THE MATRIX Y.
!     INTEGER J
!        AN INDEX VALUE.
!     INTEGER M
!        THE NUMBER OF COLUMNS OF DATA TO BE COPIED FROM MATRIX X.
!     INTEGER N
!        THE NUMBER OF ROWS OF DATA TO BE COPIED FROM MATRIX X.
!     REAL X(IX,M)
!        THE MATRIX TO BE COPIED FROM.
!     REAL Y(IY,M)
!        THE MATRIX TO BE COPIED TO.
!
!
      do 20 j = 1, m
         do 10 i = 1, n
            y(i,j) = x(i,j)
   10    continue
   20 continue
!
      return
!
      end
!FITEXT
      subroutine fitext(rss, yss, exact)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS WHETHER THE FIT IS EXACT TO MACHINE
!     PRECISION.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rss,yss
     logical&
     &   exact
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplrs,rsstst
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
!       EXTERNAL R1MACH
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL EXACT
!        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
!        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
!     REAL FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     REAL RSS
!        THE RESIDUAL SUM OF SQUARES.
!     REAL RSSTST
!        THE VALUE FOR TESTING WHETHER THE RESIDUAL SUM OF SQUARES
!        IS ZERO (TO WITHIN MACHINE PRECISION).
!     REAL YSS
!        THE SUM OF SQUARES OF THE DEPENDENT VARIABLE Y.
!
      fplrs = r1mach(4)
!
!     TEST FOR EXACT FIT
!
      exact = .false.
      rsstst = rss
      if (yss.gt.0.0e0) rsstst = rsstst / yss
      rsstst = sqrt(rsstst)
      if (rsstst.lt.10.0e0*fplrs) exact = .true.
!
      return
!
      end
!NLFIN
     subroutine nlfin(y, weight, nnzw, wt, lwt, xm, n, m, ixm, ifixd,&
    &   par, npar, npare, res, page, wide, iptout, ndigit, rsshlf, rsd,&
     &   pv, sdpv, sdres, rd, vcvl, lvcvl, d, nlhdr, ivcvpt, iskull)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPLETES THE ANALYSIS FOR THE NONLINEAR
!     LEAST SQUARES ESTIMATION ROUTINES ONCE THE ESTIMATES
!     HAVE BEEN FOUND.
!
!     REFERENCES
!
!        DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1979), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, (BEING REVISED).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rsd,rsshlf
     integer&
     &   ivcvpt,ixm,lvcvl,lwt,m,n,ndigit,nnzw,npar,npare
     logical&
     &   page,weight,wide
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   d(n,npar),par(npar),pv(n),rd(npare),res(n),sdpv(n),sdres(n),&
     &   vcvl(lvcvl),wt(lwt),xm(ixm,m),y(n)
     integer&
     &   ifixd(npar),iptout(ndigit),iskull(10)
!
!  SUBROUTINE ARGUMENTS
       external nlhdr
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   cond,rss,yss
     integer&
     &   idf
     logical&
     &   exact,prtfsm
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL NLCMP,NLOUT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL COND
!        THE CONDITION NUMBER OF D.
!     REAL D(N,NPAR)
!        THE DERIVATIVE OF THE MODEL (JACOBIAN).
!     LOGICAL EXACT
!        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
!        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
!     INTEGER IDF
!        THE DEGREES OF FREEDOM IN THE FIT.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) HAVE BEEN HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) HAVE BEEN OPTIMIZED.
!     INTEGER IPTOUT(NDIGIT)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER ISKULL(10)
!        AN ERROR MESSAGE INDICATOR VARIABLE.
!     INTEGER IVCVPT
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
!        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
!        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                       *INVERSE(HESSIAN)
!        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)
!        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LVCVL
!        THE LENGTH OF THE VECTOR CONTAINING
!        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     EXTERNAL NLHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
!        PARAMETERS ARE STORED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     LOGICAL PRTFSM
!        THE VARIABLE USED TO INDICATE WHETHER ANY OF THE SUMMARY
!        INFORMATION IS TO BE PRINTED (TRUE) OR NOT (FALSE).
!     REAL PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RD(NPARE)
!        THE DIAGONAL ELEMENTS OF THE R MATRIX OF THE Q - R
!        FACTORIZATION OF D.
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSSHLF
!        HALF THE RESIDUAL SUM OF SQUARES.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     REAL RSS
!        THE RESIDUAL SUM OF SQUARES.
!     REAL SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL VCVL(LVCVL)
!        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!     REAL YSS
!        THE SUM OF SQUARES OF THE DEPENDENT VARIABLE Y.
!
!
!     COMPUTE RETURNED AND/OR PRINTED VALUES.
!
     call nlcmp (y, weight, wt, lwt, n, npar, npare, res,&
    &   d, rd, cond, vcvl, lvcvl, nnzw, idf, rsshlf, rss, rsd, yss,&
     &   exact, pv, sdpv, sdres, iskull)
!
     prtfsm = ((iptout(3).ne.0) .or. (iptout(4).ne.0) .or.&
     &   (iptout(5).ne.0) .or. (ierr.ne.0))
!
!     PRINT SUMMARY INFORMATION IF DESIRED OR IF AN ERROR FLAG
!     HAS BEEN SET.
!
     if (prtfsm) call nlout(y, weight, nnzw, wt, lwt, xm, n, m, ixm,&
    &   ifixd, par, npar, npare, res, iptout, ndigit, page, idf, cond,&
    &   rss, rsd, yss, exact, pv, sdpv, sdres, vcvl, lvcvl, ivcvpt,&
     &   iskull, nlhdr, wide)
      return
!
      end
!DCKFPA
     subroutine dckfpa(j, d, par, npar, eta, tau, mdl, xm, n,&
    &   nrow, m, ixm, pv, pvtemp, msg, lmsg, fd, parmx, stp, pvpstp,&
     &   curve)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CHECK WHETHER FINITE PRECISION ARITHMETIC COULD POSSIBLY BE THE
!     PROBLEM
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   curve,d,eta,fd,parmx,pv,pvpstp,stp,tau
     integer&
     &   ixm,j,lmsg,m,n,npar,nrow
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),pvtemp(n),xm(ixm,m)
     integer&
     &   msg(lmsg)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   temp
     logical&
     &   large
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,sign
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CURVE
!        A MEASURE OF THE CURVATURE IN THE MODEL.
!     REAL D
!        THE SCALAR IN WHICH ROW   NROW   OF THE DERIVATIVE
!        MATRIX WITH RESPECT TO THE JTH UNKNOWN PARAMETER
!        IS STORED.
!     REAL ETA
!        THE RELATIVE NOISE IN THE MODEL
!     REAL FD
!        THE FORWARD DIFFERENCE QUOTIENT DERIVATIVE WITH RESPECT TO THE
!        JTH PARAMETER
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARTIAL DERIVATIVE BEING EXAMINED.
!     LOGICAL LARGE
!        AN INDICATOR VALUE INDICATING WHETHER THE RECOMMENDED
!        INCREASE IN THE STEP SIZE WOULD BE GREATER THAN PARMX.
!     INTEGER LMSG
!        THE LENGTH OF THE VECTOR MSG.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER MSG(LMSG)
!        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL PARMX
!        THE MAXIMUM OF THE CURRENT PARAMETER ESTIMATE AND THE
!        TYPICAL VALUE OF THAT PARAMETER
!     REAL PV
!        THE SCALAR IN WHICH THE PREDICTED VALUE FROM THE MODEL FOR
!        ROW   NROW   IS STORED.
!     REAL PVPSTP
!        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
!        BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J) + STP.
!     REAL PVTEMP(N)
!        THE VECTOR OF PREDICTED VALUES FROM THE MODEL.
!     REAL STP
!        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FINITE DIFFERENC
!        DERIVATIVE
!     REAL TAU
!        THE AGREEMENT TOLERANCE.
!     REAL TEMP
!        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
!        PARAMETER IS STORED.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
!     CHECK WHETHER FINITE PRECISION COULD BE THE PROBLEM
!
     if (abs(stp*(fd-d)) .ge.&
     &   10.0e0*eta*(abs(pv)+abs(pvpstp))) then
!
!     DISCREPANCY BETWEEN NUMERICAL AND ANALYTICAL DERIVATIVES CANNOT
!     BE ACCOUNTED FOR BY FINITE PRECISION ARITHMETIC
!
         msg(1) = 2
         msg(j+1) = 2
         return
!
      end if
!
!     FINITE PRECISION ARITHMETIC COULD BE THE PROBLEM.
!
!     TRY A LARGER STEP SIZE
!
     stp = (eta*(abs(pv)+abs(pvpstp))*sign(1.0e0,par(j))/&
     &   (tau*abs(d))+par(j)) - par(j)
!
      large = .false.
!
      if (abs(stp).gt.parmx) then
         stp = parmx*sign(1.0e0,par(j))
         large = .true.
      end if
!
!     CALCULATE NUMERICAL DERIVATIVE USNG NEW, LARGER, STEPSIZE
!
      temp = par(j)
      par(j) = par(j) + stp
      call mdl(par, npar, xm, n, m, ixm, pvtemp)
      par(j) = temp
!
      pvpstp = pvtemp(nrow)
!
      fd = (pvpstp-pv)/stp
!
!     CHECK FOR AGREEMENT
!
      if ((abs(fd-d)).le.2.0e0*tau*abs(d)) then
!
!     FORWARD DIFFERENCE QUOTIENT AND ANALYTIC DERIVATIVES AGREE FOR
!     THIS STEP SIZE
!
         return
      end if
!
!     FORWARD DIFFERENCE QUOTIENT AND ANALYTIC DERIVATIVES STILL
!     DISAGREE
!
!     CHECK IF CURVATURE IS THE PROBLEM
!
      if (abs(curve*stp) .lt. abs(fd-d) .and. (.not. large)) then
!
!        CURVATURE COULDNT BE THE CULPRIT
!
             msg(1) = 2
             msg(j+1) = 2
             return
      else
!
!        CURVATURE MAY BE THE CULPRIT
!
             if (msg(1).eq.0) msg(1) = 1
             if (large) msg(j+1) = 6
             if (.not. large) msg(j+1) = 1
             return
      end if
!
      end
!UASEST
     subroutine uasest (iar, var, phi, nf, freq, delta, spca, lphi,&
     &   ispc)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CALCULATES THE AUTOREGRESSIVE SPECTRUM.  IT IS
!        MODELED AFTER SUBROUTINE UASEC BY DICK JONES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,var
     integer&
     &   iar,ispc,lphi,nf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(nf),phi(lphi),spca(ispc)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   arg,ei,er,exi,exr,exrtmp,pi,ti,tr
     integer&
     &   i,j
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL GETPI
!
!  INTRINSIC FUNCTIONS
      intrinsic cos,sin
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ARG
!        THE ARGUMENT FOR THE SINE AND COSINE FUNCTIONS USED IN
!        CALCULATIONS OF THE SPECTRUM.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL EI, ER, EXI, EXR, EXRTMP
!        'COMPLEX' VARIABLES USED IN THE COMPUTATIONS.
!     REAL FREQ(NF)
!        THE ARRAY CONTAINING THE FREQUENCIES AT WHICH THE SPECTRUM
!        IS TO BE COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER ISPC
!        THE LENGTH OF THE ARRAY SPCA.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER LPHI
!        THE LENGTH OF THE ARRAY PHI.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     REAL PHI(LPHI)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     REAL PI
!        THE VALUE OF PI.
!     REAL SPCA(ISPC)
!        THE ARRAY IN WHICH THE AUTOREGRESSIVE SPECTRUM IS STORED.
!     REAL TI, TR
!        A VARIABLE USED IN THE COMPUTATIONS.
!     REAL VAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED ORDER (IAR).
!
      call getpi(pi)
!
      do 20 j=1,nf
         spca(j) = delta * var
         if (iar.ge.1) then
            if (delta.eq.1.0e0) then
               if (freq(j).eq.0.0e0) then
                  er = 1.0e0
                  ei = 0.0e0
               else if (freq(j).eq.0.25e0) then
                  er = 0.0e0
                  ei = 1.0e0
               else if (freq(j).eq.0.5e0) then
                  er = -1.0e0
                  ei = 0.0e0
               else
                  arg = 2.0e0 * pi * delta * freq(j)
                  er = cos(arg)
                  ei = sin(arg)
               end if
            else
               arg = 2.0e0 * pi * delta * freq(j)
               er = cos(arg)
               ei = sin(arg)
            end if
            exr = 1.0e0
            exi = 0.0e0
            tr = 1.0e0
            ti = 0.0e0
            do 10 i=1,iar
               exrtmp = exr*er - exi*ei
               exi = exr*ei + exi*er
               exr = exrtmp
               tr = tr - phi(i) * exr
               ti = ti - phi(i) * exi
   10       continue
            spca(j) = spca(j)/(tr*tr + ti*ti)
         end if
   20 continue
      return
      end
!DIF
      subroutine dif (y, n, yf, nyf)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PERFORMS A FIRST DIFFERENCE FILTERING OPERATION,
!     RETURNING THE FILTERED SERIES IN YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n,nyf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*),yf(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iar,iprt
     logical&
     &   err01,head
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   phi(1)
     character&
     &   ln(8)*1,nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,FLTAR,IPRINT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     CHARACTER*1 LN(8)
!        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES N.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     REAL PHI(1)
!        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'D',       'I',       'F',       ' ',       ' ',       ' '/
     data&
    &  ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 3, 1, head, err01, ln)
!
!
      if (.not. err01) go to 10
!
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   10 continue
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      iar = 1
      phi(1) = 1.0e0
!
      call fltar (y, n, iar, phi, yf, nyf)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   31h       call dif (y, n, yf, nyf))
      end
!DEMODS
     subroutine demods (y, n, fd, fc, k, ampl, phas, ndem, nprt,&
     &  ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE TO DEMODULATE SERIES
!     Y AT FREQUENCY FD, TO APPLY A LOW PASS FILTER WITH CUTOFF
!     FREQUENCY FC, AND TO EXTRACT THE AMPLITUDE AND PHASE COMPONENTS
!     OF THE RESULTING FILTERED SERIES (LONG CALL).
!
!     WRITTEN BY  -  PETER BLOOMFIELD
!                    FOURIER ANALYSIS OF TIME SERIES- AN
!                       INTRODUCTION
!                    JOHN WILEY AND SONS, NEW YORK, 1976
!                    PAGE 147
!     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
!                                STATISTICAL ENGINEERING DIVISION
!                                NATIONAL BUREAU OF STANDARDS
!                                BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fc,fd
     integer&
     &   k,ldstak,n,ndem,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ampl(*),phas(*),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   temp
     integer&
     &   hlp,io,iprt,ldsmin,nall0,phase
     logical&
     &   err01,err02,err03,err04,err05,err06,err07,head
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     character&
    &   lfc(8)*1,lfd(8)*1,lk(8)*1,lkin(8)*1,llds(8)*1,ln(8)*1,&
     &   lnm1(8)*1,lone(8)*1,nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DEMDRV,EISGE,EISII,ERIODD,ERSII,ERSLFS,IPRINT,LDSCMP,
!     +   STKCLR,STKSET
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AMPL(N)
!        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05, ERR06, ERR07
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     REAL FC
!        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
!     REAL FD
!        THE DEMODULATION FREQUENCY.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER HLP
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE ARRAY IN WHICH THE LOW PASS FILTER COEFFICIENTS ARE
!        STORED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER K
!        THE USER SUPPLIED NUMBER OF TERMS TO BE USED FOR THE LOW
!        PASS FILTER.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LFC(8), LFD(8), LK(8), LKIN(8), LLDS(8), LN(8),
!    *  LNM1(8), LONE(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
!        WAS CALLED.
!     INTEGER NDEM
!        THE NUMBER OF VALUES IN THE DEMODULATED SERIES, I.E., IN
!        THE AMPLITUDE AND PHASE ARRAYS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF NPRT
!        IS ZERO, NO OUTPUT IS GIVEN, OTHERWISE OUTPUT IS PROVIDED.
!     REAL PHAS(N)
!        THE ARRAY IN WHICH THE PRIMARY PHASE ESTIMATES ARE RETURNED.
!     INTEGER PHASE
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE ARRAY CONTAINING THE PRIMARY AND SECONDARY PHASE ESTIMATES.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL TEMP
!        A TEMPORARY VARIABLE USED FOR TYPE CONVERSION.
!     REAL Y(N)
!        THE INPUT ARRAY CONTAINING THE OBSERVED SERIES.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'D',       'E',       'M',       'O',       'D',       'S'/
     data&
    &  lfc(1), lfc(2), lfc(3), lfc(4), lfc(5), lfc(6), lfc(7), lfc(8)&
     & /  'F',   'C',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lfd(1), lfd(2), lfd(3), lfd(4), lfd(5), lfd(6), lfd(7), lfd(8)&
     & /  'F',   'D',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lk(1), lk(2), lk(3), lk(4), lk(5), lk(6), lk(7), lk(8)&
     & /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lkin(1), lkin(2), lkin(3), lkin(4), lkin(5), lkin(6), lkin(7),&
     &  lkin(8) /  '(',   '1',   '/',   'K',   ')',   ' ',   ' ',   ' '/
     data&
    &  llds(1), llds(2), llds(3), llds(4), llds(5), llds(6), llds(7),&
     &  llds(8) /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
     data&
    &  ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lnm1(1), lnm1(2), lnm1(3), lnm1(4), lnm1(5), lnm1(6), lnm1(7),&
     &  lnm1(8) /  '(',   'N',   '-',   '1',   ')',   ' ',   ' ',   ' '/
     data&
    &  lone(1), lone(2), lone(3), lone(4), lone(5), lone(6), lone(7),&
     &  lone(8) /  'O',   'N',   'E',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     PERFORM ERROR CHECKING ON INPUT DATA.
!
      ierr = 0
      head = .true.
!
      if (nprt.eq.0) then
        io = 0
      else
        io = 1
      end if
!
      call eisge(nmsub, ln, n, 17, 1, head, err01, ln)
!
     call ersii(nmsub, lfd, fd,&
     &           0.0e0, 0.5e0, 2, head, err02, lfd, lfd)
!
      err03 = .true.
     if (.not. err01)&
     &  call eisii(nmsub, lk, k, 1, n-1, 1, head, err03, lone, lnm1)
!
      call eriodd(nmsub, lk, k, 1, head, err04)
!
      err05 = .true.
      if ((.not. err02) .and. (.not. err03) .and. (.not. err04)) then
         temp = k
        call ersii(nmsub, lfc, fc, 1.0e0/temp, fd, 1, head, err05,&
     &              lkin, lfd)
      end if
!
      err06 = .true.
     if ((.not. err03) .and. (.not. err04) .and. (.not. err05))&
     &   call erslfs(nmsub, fc, k, head, err06)
!
      if (err01 .or. err06) go to 10
!
      call ldscmp(2, 0, 0, 0, 0, 0, 'S', k + io*2*n, ldsmin)
!
      call eisge(nmsub, llds, ldstak, ldsmin, 9, head, err07, llds)
!
!
      if (err02 .or. err03 .or. err04 .or. err05 .or. err07) go to 10
      go to 20
!
   10 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   20 continue
      call stkset (ldstak, 4)
      nall0 = stkst(1)
!
      hlp = stkget(k, 3)
      if (nprt.eq.0) then
         phase = 1
      else
         phase = stkget(2*n, 3)
      end if
!
      if (ierr .eq. 1) go to 10
!
      if (nprt .ne. 0) then
!
        call demdrv(y, n, fd, fc, k, rstak(hlp), ampl,&
     &      rstak(phase), n, ndem, nprt, nmsub)
         call scopy(ndem, rstak(phase), 1, phas, 1)
      else
        call demdrv(y, n, fd, fc, k, rstak(hlp), ampl,&
     &      phas, n, ndem, nprt, nmsub)
      end if
!
      call stkclr(nall0)
!
      if (ierr .eq. 1) go to 10
!
      return
!
!     FORMAT STATEMENT
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL DEMODS (Y, N, FD, FC, K,'/&
     &   '      +             AMPL, PHAS, NDEM, NPRT, LDSTAK)')
!
      end
!PGMMN
     subroutine pgmmn (yfft, n, nfft, iextnd, nf, per, lper, yaxis,&
     &   freq, lfreq, nprt, nmsub)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS THE MAIN ROUTINE FOR COMPUTING THE RAW PERIODOGRAM.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iextnd,lfreq,lper,n,nf,nfft,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(lfreq),per(lper),yaxis(lfreq),yfft(nfft)
     character&
     &   nmsub(6)*1
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   yextnd
     integer&
     &   i,n1
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL AMEAN,PGMEST,PGORD,PGOUT,SETFRQ
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL FREQ(LFREQ)
!        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
!        INTEGRATED SPECTRUM VALUES ARE STORED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IEXTND
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
!        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
!        USED TO EXTEND THE SERIES.
!     INTEGER LFREQ
!        THE LENGTH OF THE ARRAY FREQ.
!     INTEGER LPER
!        THE LENGTH OF THE ARRAY PER.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .EQ.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
!        IF NPRT .GE.  2, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!     REAL PER(LPER)
!        THE ARRAY IN WHICH THE PERIODOGRAM IS STORED.
!     REAL YAXIS(LFREQ)
!        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
!     REAL YEXTND
!        THE VALUE USED TO EXTEND THE SERIES.
!     REAL YFFT(NFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!
      yextnd = 0.0e0
      if (iextnd .ne. 0) call amean (yfft, n, yextnd)
!
!     EXTEND THE PERIODOGRAM ARRAY BY ITS MEAN  OR ZERO TO THE
!     EXTENDED LENGTH NFFT.
!
      n1 = n + 1
!
      do 40 i = n1, nfft
         yfft(i) = yextnd
   40 continue
!
!     COMPUTE THE PERIODOGRAM.
!
      call pgmest (yfft, nfft, nf, 1.0e0, per, lper)
!
!     SET FREQUENCIES FOR PERIODOGRAM VALUES
!
      call setfrq (freq, nf, 1, 0.0e0, 0.5e0, 1.0e0)
!
      if (nprt .eq. 0) return
!
!     SET Y CO-ORDINATES FOR PERIODOGRAM PLOT.
!
      call pgord (per, nf, yaxis, nprt)
!
!     PLOT PERIODOGRAM IF OUTPUT NOT SUPPRESSED
!
      call pgout (yaxis, freq, nf, nprt, nmsub)
!
      return
!
      end
!SPPM
      subroutine sppm(ym, ymiss, x, xmiss, n, isym)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH USER CONTROL OF PLOT SYMBOLS AND WITH MISSING
!     OBSERVATIONS (SHORT CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: ymiss, xmiss
     integer&
     &   n
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: x(*),ym(*)
     integer&
     &   isym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xlb,xub,ylb,yub
     integer&
     &   ilog,iprt,ischck,isize,iym,lisym,m,nout
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
      real(kind=wp) :: ymmiss(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'S',       'P',       'P',       'M',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      ymmiss=ymiss
      m = 1
      iym = n
      multi = .false.
      ilog = -1
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 0.0e0
      xub = 0.0e0
      ischck = 1
      isize = -1
      nout = 0
      miss = .true.
      lisym = n
!
     call ppcnt (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL SPPM (Y, YMISS, X, XMISS, N, ISYM)')
      end
!PLTCHK
     subroutine pltchk (ym, ymmiss, x, xmiss, n, m, iym, multi,&
     &   ilog, ylb, yub, xlb, xub, nmsub, miss, xcheck)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS PLOT FAMILY ROUTINE CHECKS FOR ERRORS IN THE PARAMETER LISTS
!     OF THE MULTIPLE PLOT ROUTINES
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   xlb,xmiss,xub,ylb,yub
     integer&
     &   ilog,iym,m,n
     logical&
     &   miss,multi,xcheck
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),ym(*),ymmiss(*)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   nv
     logical&
     &   err01,err02,err03,err04,err05,err06,err07,err08,err09,head
!
!  LOCAL ARRAYS
     integer&
     &   ilogxy(2)
     character&
    &   liym(8)*1,lm(8)*1,ln(8)*1,lone(8)*1,lx(8)*1,lxlb(8)*1,&
     &   lxub(8)*1,ly(8)*1,lylb(8)*1,lym(8)*1,lyub(8)*1
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL EISGE,ERAGT,ERAGTM,ERSGT,ERVGT,ERVGTM,PRTCNT
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05, ERR06, ERR07, ERR08,
!    1   ERR09
!        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        THE COMMON VARIABLE USED AS AN ERROR FLAG
!        IF = 0 THEN NO ERORRS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER ILOGXY(2)
!        ...
!     INTEGER IYM
!        ACTUAL ROW DIMENSION OF YM DECLARED IN USERS MAIN PROGRAM
!     CHARACTER*1 LIYM(8), LM(8), LN(8), LONE(8), LX(8), LXLB(8),
!    *  LXUB(8), LY(8), LYLB(8), LYM(8), LYUB(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE INPUT PARAMETERS(S)
!        CHECKED FOR ERRORS.
!     INTEGER M
!        THE NUMBER OF VECTORS IN YM
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        AN INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS AN M PREFIX (TRUE) OR NOT (FALSE).
!     INTEGER N
!        THE LENGTH OF THE VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND IN THE X AND Y AXIS ARRAYS.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     LOGICAL XCHECK
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER X-AXIS VALUES
!        ARE TO BE CHECKED (XCHECK = .TRUE.) OR NOT (XCHECK = .FALSE.)
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES.
!     REAL YMMISS(M)
!        THE MISSING VALUE CODE FOR EACH COLUMN OF YM.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &   liym(1),   liym(2),   liym(3),   liym(4),   liym(5),   liym(6)&
     & /     'I',       'Y',       'M',       ' ',       ' ',       ' '/
     data liym(7), liym(8)&
     &   /     ' ',     ' '/
     data&
    &     lm(1),     lm(2),     lm(3),     lm(4),     lm(5),     lm(6)&
     & /     'M',       ' ',       ' ',       ' ',       ' ',       ' '/
     data   lm(7),   lm(8)&
     &   /     ' ',     ' '/
     data&
    &     ln(1),     ln(2),     ln(3),     ln(4),     ln(5),     ln(6)&
     & /     'N',       ' ',       ' ',       ' ',       ' ',       ' '/
     data   ln(7),   ln(8)&
     &   /     ' ',     ' '/
     data   lone(1),  lone(2),  lone(3),  lone(4),  lone(5),  lone(6),&
     &       lone(7),  lone(8)/'O', 'N', 'E', ' ', ' ', ' ', ' ', ' '/
     data&
    &     lx(1),     lx(2),     lx(3),     lx(4),     lx(5),     lx(6)&
     & /     'X',       ' ',       ' ',       ' ',       ' ',       ' '/
     data   lx(7),   lx(8)&
     &   /     ' ',     ' '/
     data&
    &   lxlb(1),   lxlb(2),   lxlb(3),   lxlb(4),   lxlb(5),   lxlb(6)&
     & /     'X',       'L',       'B',       ' ',       ' ',       ' '/
     data lxlb(7), lxlb(8)&
     &   /     ' ',     ' '/
     data&
    &   lxub(1),   lxub(2),   lxub(3),   lxub(4),   lxub(5),   lxub(6)&
     & /     'X',       'U',       'B',       ' ',       ' ',       ' '/
     data lxub(7), lxub(8)&
     &   /     ' ',     ' '/
     data&
    &     ly(1),     ly(2),     ly(3),     ly(4),     ly(5),     ly(6)&
     & /     'Y',       ' ',       ' ',       ' ',       ' ',       ' '/
     data   ly(7),   ly(8)&
     &   /     ' ',     ' '/
     data&
    &   lylb(1),   lylb(2),   lylb(3),   lylb(4),   lylb(5),   lylb(6)&
     & /     'Y',       'L',       'B',       ' ',       ' ',       ' '/
     data lylb(7), lylb(8)&
     &   /     ' ',     ' '/
     data&
    &    lym(1),    lym(2),    lym(3),    lym(4),    lym(5),    lym(6)&
     & /     'Y',       'M',       ' ',       ' ',       ' ',       ' '/
     data  lym(7),  lym(8)&
     &   /     ' ',     ' '/
     data&
    &   lyub(1),   lyub(2),   lyub(3),   lyub(4),   lyub(5),   lyub(6)&
     & /     'Y',       'U',       'B',       ' ',       ' ',       ' '/
     data lyub(7), lyub(8)&
     &   /     ' ',     ' '/
!
!     COMMENCE BODY OF ROUTINE
!
      ierr = 0
      head = .true.
!
!     NUMBER OF POINTS MUST BE AT LEAST 1
!
      call eisge(nmsub, ln, n, 1, 2, head, err01, lone)
!
!     THERE MUST BE AT LEAST 1 COLUMN OF VECTORS
!
      call eisge(nmsub, lm, m, 1, 2, head, err02, lone)
!
!     THE ACTUAL LENGTH OF YM MUST EQUAL OR EXCEED THE NUMBER OF
!     OBSERVATIONS
!
      err03 = .true.
     if (.not.err01)&
     &   call eisge(nmsub, liym, iym, n, 3, head, err03, ln)
!
!     IF THIS IS A LOG PLOT CHECK FOR NON-POSITIVE VALUES IN DATA
!
      if (err01 .or. err02 .or. err03) ierr = 1
      if (ilog .le. 0) return
!
      err04 = .false.
      err05 = .false.
      err06 = .false.
      err07 = .false.
      err08 = .false.
      err09 = .false.
!
      call prtcnt (max(0,ilog),2,ilogxy)
      if ((ilogxy(1).ne.0) .and. xcheck) then
        if (.not.err01) then
!
!         IF X AXIS IS LOG SCALE, CHECK FOR NEGATIVE X AXIS VALUES
!
          if (miss) then
           call ervgtm(nmsub, lx, x, xmiss, n, 0.0e0, 0, head, 1,&
     &        nv, err04, lx)
          else
           call ervgt(nmsub, lx, x, n, 0.0e0, 0, head, 1, nv, err04,&
     &        lx)
          end if
        end if
!
        if (xlb.lt.xub) then
!
!         CHECK FOR NEGATIVE PLOT BOUNDS
!
          call ersgt(nmsub, lxlb, xlb, 0.0e0, 1, head, err05, lxlb)
          call ersgt(nmsub, lxub, xub, 0.0e0, 1, head, err06, lxub)
        end if
      end if
      if (ilogxy(2).ne.0) then
        if ((.not.err01) .and. (.not.err02) .and. (.not.err03)) then
!
!         IF Y AYIS IS LOG SCALE, CHECK FOR NEGATIVE Y AYIS VALUES
!
          if (miss) then
            if (multi) then
             call eragtm(nmsub, lym, ym, ymmiss, n, m, iym, 0.0e0, 0,&
     &           head, 1, nv, err04, lym)
            else
             call ervgtm(nmsub, ly, ym, ymmiss(1), n, 0.0e0, 0, head,&
     &           1, nv, err04, ly)
            end if
          else
            if (multi) then
             call eragt(nmsub, lym, ym, n, m, iym, 0.0e0, 0, head,&
     &           1, nv, err04, lym)
            else
             call ervgt(nmsub, ly, ym, n, 0.0e0, 0, head, 1,&
     &           nv, err04, ly)
            end if
          end if
        end if
!
        if (ylb.lt.yub) then
!
!         CHECK FOR NEGATIVE PLOT BOUNDS
!
          call ersgt(nmsub, lylb, ylb, 0.0e0, 1, head, err05, lylb)
          call ersgt(nmsub, lyub, yub, 0.0e0, 1, head, err06, lyub)
        end if
      end if
!
     if (err04 .or. err05 .or. err06 .or. err07 .or. err08 .or. err09)&
     &   ierr = 1
!
      return
!
      end
!BFSVS
     subroutine bfsvs(ccov, index1, index2, n, iccov, jccov,&
    &   nw, lags, nf, fmin, fmax, nprt, cspc2, icspc2, phas, iphas,&
     &   freq, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
!     FOURIER SPECTRUM ANALYSIS OF SERIES WITH
!     USER INPUT OF THE COVARIANCES RATHER THAN THE SERIES
!     (LONG CALL)
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fmax,fmin
     integer&
     &   iccov,icspc2,index1,index2,iphas,jccov,ldstak,n,nf,nprt,nw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ccov(*),cspc2(*),freq(*),phas(*)
     integer&
     &   lags(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta,ymiss1,ymiss2
     integer&
    &   ceven,codd,i,ifp,inlppc,io,iprt,isym,jnlppc,lagmax,lagmx1,&
    &   ldsmin,lpcv,lw,lwork,ly,m,nall0,spcf1,spcf2,w,work,xaxis,&
     &   yaxis
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12),y1(1),y2(1)
     integer&
     &   istak(12),nlppc(1,1,1)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL BFSDRV,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL CCOV(ICCOV,JCCOV,*)
!        THE COVARIANCES.
!     INTEGER CEVEN
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     INTEGER CODD
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     REAL CSPC2(ICSPC2,NW)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC(1,1,1)
!        THE NUMBER OF OBSERVATIONS IN EACH COVARIANCE ESTIMATE
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL PHAS(IPHAS,NW)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SPCF1, SPCF2
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     INTEGER W
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE WINDOWS.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR THE VECTOR WORK.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YMISS1, YMISS2
!        DUMMY VARIABLES.
!     REAL Y1(1)
!        THE FIRST TIME SERIES.
!     REAL Y2(1)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'B','F','S','V','S',' '/
!
!     SET UP FOR ERROR CHECKING
!
      option(1) = .false.
      option(2) = .false.
      option(3) = .true.
      option(4) = .true.
!
!     SET MAXIMUM LAG VALUE TO BE USED (LAGMAX).
!
      lagmax = n - 1
      if (nw.le.0) go to 20
      lagmax = lags(1)
      do 10 i=1,nw
         lagmax = max(lagmax,lags(i))
   10 continue
   20 continue
      lagmx1 = lagmax + 1
!
      m = 2
!
!     COMPUTE THE MINIMUM ALLOWABLE STACK AREA (LDSMIN)
!
      io = 1
      if (nprt.eq.0) io = 0
!
     call ldscmp(8, 0, io*4*nf, 0, 0, 0, 'S',&
     &  3*lagmax+3+2*nf+io*8*nf, ldsmin)
!
      inlppc = 1
      jnlppc = 1
      ly = n
      lpcv = 4*nf
      lw = lagmax + 1
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING STACK ALLOCATIONS (NALL0).
!     SET THE STACK ALLOCATION TYPE (IFP)
!
      call stkset(ldstak, 4)
      nall0 = stkst(1)
!
      ifp = 3
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS
!
      if ((ldsmin.gt.ldstak) .or. (ldsmin.le.6)) then
         ceven = 1
         codd = 1
         spcf1 = 1
         spcf2 = 1
         w = 1
         isym = w
         xaxis = w
         yaxis = w
      else
         ceven = stkget(lagmx1,ifp)
         codd = stkget(lagmx1,ifp)
         spcf1 = stkget(nf,ifp)
         spcf2 = stkget(nf,ifp)
         w = stkget(lw,ifp)
         if (nprt.eq.0) then
            isym = w
            xaxis = w
            yaxis = w
         else
            isym = stkget(lpcv,2)
            xaxis = stkget(lpcv,ifp)
            yaxis = stkget(lpcv,ifp)
         end if
      end if
!
      work = w
      lwork = lw
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
     call bfsdrv(y1, y2, ymiss1, ymiss2, ccov, nlppc,&
    &   rstak(spcf1), rstak(spcf2), nf, fmin, fmax, freq, n, nw,&
    &   lagmax, lags, lagmx1, rstak(work), lwork, delta, istak(isym),&
    &   rstak(xaxis), rstak(yaxis), lpcv, alpha, nprt, parzen, iccov,&
    &   jccov, m, index1, index2, cspc2, phas, icspc2, iphas,&
    &   rstak(codd), rstak(ceven), rstak(w), lw, nmsub, ldsmin,&
     &   ldstak, option, n, inlppc, jnlppc, ly)
!
      call stkclr(nall0)
!
!     CHECK FOR ERRORS
!
      if (ierr.eq.0) return
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    & '       CALL BFSVS(CCOV, INDEX1, INDEX2, N, ICCOV, JCCOV,'/&
    & '      +           NW, LAGS, NF, FMIN, FMAX, NPRT,'/&
     & '      +           CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)')
      end
!AMESTP
     subroutine amestp(xm, n, m, ixm, mdl, par, npar, stp,&
    &   exmpt, neta, scale, lscale, nprt, hdr, page, wide, isubhd,&
     &   hlfrpt, prtfxd, ifixed, lifixd, stpout, pvpad)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CONTROLS THE STEP SIZE SELECTION PROCESS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   exmpt
     integer&
     &   isubhd,ixm,lifixd,lscale,m,n,neta,npar,nprt,pvpad
     logical&
     &   hlfrpt,page,prtfxd,wide
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),scale(*),stp(*),xm(ixm,*)
     integer&
     &   ifixed(*)
!
!  SUBROUTINE ARGUMENTS
       external hdr,mdl,stpout
!
!  SCALARS IN COMMON
     real(kind=wp) ::&
     &   q
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   eta,exm,fplrs,scl,tau
     integer&
    &   cd,fd,fdlast,fdsave,ifailj,ifixd,ifp,itemp,j,mxfail,nall0,&
    &   ndd,ndgt1,nexmpt,nfail,nfailj,partmp,pv,pvmcd,pvnew,pvpcd,&
     &   pvstp,pvtemp
     logical&
     &   head
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
     integer&
     &   stkst
!       EXTERNAL R1MACH,STKST
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL CPYVII,ETAMDL,SETIV,STKCLR,STPMN
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,int,log10,max,min
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
      common /notopt/q
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CD
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE CENTRAL DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL ETA
!        THE RELATIVE NOISE IN THE MODEL.
!     REAL EXM
!        THE PROPORTION OF OBSERVATIONS ACTUALLY USED FOR WHICH THE
!        COMPUTED NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE
!        EXEMPTED FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     REAL EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     INTEGER FD
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
!     INTEGER FDLAST
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!        FOR THE LAST STEP SIZE TRIED.
!     INTEGER FDSAVE
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!        FOR THE BEST STEP SIZE TRIED SO FAR.
!     REAL FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     EXTERNAL HDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFAILJ
!        THE STARTING LOCATION IN ISTAK FOR
!        THE ARRAY OF INDICATOR VARIABLES DESIGNATING WHETHER
!        THE SETP SIZE SELECTED WAS SATISFACOTRY FOR A GIVEN
!        OBSERVATION AND THE JTH PARAMETER.
!     INTEGER IFIXD
!        THE STARTING LOCATION IN /CSTAK/ OF VECTOR IFIXD CONTAINING
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IFP
!        AN INDICATOR FOR THE PRECISION OF THE STACK ALLOCATION TYPE,
!        WHERE IFP=3 INDICATES SINGLE AND IFP=4 INDICATES DOUBLE.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER ITEMP
!        THE STARTING LOCATION IN ISTAK FOR
!        A TEMPORARY STORAGE VECTOR.
!     INTEGER IXM
!        THE FIRST DIMENSION OF MATRIX XM.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER LIFIXD
!        THE DIMENSION OF VECTOR IFIXED.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER MXFAIL
!        THE MAXIMUM NUMBER OF FAILURES FOR ANY PARAMETER.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        NUMBER OF STACK ALLOCATIONS OUTSTANDING.
!     INTEGER NDD
!        THE NUMBER OF DECIMAL DIGITS CARRIED FOR A SINGLE
!        PRECISION REAL NUMBER.
!     INTEGER NDGT1
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL USED, EITHER
!        SET TO THE USER SUPPLIED VALUE OF NETA, OR COMPUTED
!        BY ETAMDL.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL RESULTS.
!     INTEGER NEXMPT
!        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
!        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
!        SIZE STILL BE CONSIDERED OK.
!     INTEGER NFAIL
!        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP SIZE
!        FOR THE PARAMETER DOES NOT MEET THE CRITERIA.
!     INTEGER NFAILJ
!        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP SIZE
!        FOR THE JTH PARAMETER DOES NOT MEET THE CRITERIA.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARTMP
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE MODIFIED MODEL PARAMETERS
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     INTEGER PV
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     INTEGER PVMCD
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     INTEGER PVNEW
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPNEW.
!     INTEGER PVPAD
!       ADDITIONAL WORKSPACE NEEDED IN PV FOR THE EVALUATION OF THE
!       MODEL.
!     INTEGER PVPCD
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCD.
!     INTEGER PVSTP
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STP(J).
!     INTEGER PVTEMP
!        THE STARTING LOCATION IN THE WORK AREA OF
!        A TEMPORY STORAGE LOCATION FOR PREDICTED VALUES BEGINS.
!     REAL Q
!        A DUMMY VARIABLE WHICH IS USED, ALONG WITH COMMON NOTOPT (NO
!        OPTIMIZATION), TO COMPUTE THE STEP SIZE.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SCL
!        THE ACTUAL TYPICAL SIZE USED.
!     REAL STP(NPAR)
!        THE SELECTED STEP SIZES.
!     EXTERNAL STPOUT
!        THE ROUTINE FOR PRINTING THE OUTPUT.
!     REAL TAU
!        THE AGREEMENT TOLERANCE.
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!
!
      nall0 = stkst(1)
!
      fplrs = r1mach(4)
      ifp = 3
!
!     SET PRINT CONTROLS
!
      head = .true.
!
!     SUBDIVIDE WORK AREA
!
      ifixd = stkget(npar, 2)
      itemp = stkget(n, 2)
      ifailj = stkget(n, 2)
      nfail = stkget(npar, 2)
!
      cd = stkget(n, ifp)
      fd = stkget(n, ifp)
      fdlast = stkget(n, ifp)
      fdsave = stkget(n, ifp)
      pv = stkget(n+pvpad, ifp)
      pvmcd = stkget(n+pvpad, ifp)
      pvnew = stkget(n+pvpad, ifp)
      pvpcd = stkget(n+pvpad, ifp)
      pvstp = stkget(n+pvpad, ifp)
      pvtemp = stkget(n+pvpad, ifp)
!
      if (ierr .eq. 1) return
!
      partmp = cd
!
!     SET UP IFIXD
!
      if (ifixed(1).lt.0) call setiv(istak(ifixd), npar, 0)
      if (ifixed(1).ge.0) call cpyvii(npar, ifixed, 1, istak(ifixd), 1)
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      ndd = int(-log10(fplrs))
!
      if ((neta .ge. 2) .and. (neta .le. ndd)) then
            eta = 10.0e0 ** (-neta)
            ndgt1 = neta
      else
           call etamdl(mdl, par, npar, xm, n, m, ixm, eta, ndgt1,&
     &         rstak(partmp), rstak(pvtemp), 0)
      end if
!
      tau = min(eta**0.25e0, 0.01e0)
!
      exm = exmpt
      if ((exm.lt.0.0e0) .or. (exm.gt.1.0e0)) exm = 0.10e0
      nexmpt = int(exm * n)
      if (exm .ne. 0.0e0) nexmpt = max(nexmpt, 1)
!
!     COMPUTE PREDICTED VALUES OF THE MODEL USING THE INPUT PARAMETER
!     ESTIMATES
!
      call mdl(par, npar, xm, n, m, ixm, rstak(pv))
!
      mxfail = 0
      nfailj = nfail
!
      do 120 j = 1, npar
!
         if (scale(1) .le. 0.0e0) then
            if (par(j) .eq. 0.0e0) then
               scl = 1.0e0
            else
               scl = abs(par(j))
            end if
         else
            scl = scale(j)
         end if
!
        call stpmn(j, xm, n, m, ixm, mdl, par, npar, nexmpt,&
    &      eta, tau, scl, stp(j), istak(nfailj), istak(ifailj),&
    &      rstak(cd), istak(itemp), rstak(fd), rstak(fdlast),&
    &      rstak(fdsave), rstak(pv), rstak(pvmcd), rstak(pvnew),&
     &      rstak(pvpcd), rstak(pvstp), rstak(pvtemp))
!
!     COMPUTE THE MAXIMUM NUMBER OF FAILURES FOR ANY PARAMETER
!
         mxfail = max(istak(nfailj), mxfail)
!
!     PRINT RESULTS IF THEY ARE DESIRED
!
        if ((nprt.ne.0) .or. (mxfail.gt.nexmpt))&
    &      call stpout(head, n, exm, nexmpt, ndgt1, j, par, npar,&
    &         stp, istak(nfail), istak(ifailj), scale,  lscale, hdr,&
     &         page, wide, isubhd, nprt, prtfxd, istak(ifixd))
!
         nfailj = nfailj + 1
!
  120 continue
!
      hlfrpt = .false.
      if ((nprt.ne.0) .or. (mxfail.gt.nexmpt)) hlfrpt = .true.
!
      if (mxfail.gt.nexmpt) ierr = 2
!
      call stkclr(nall0)
!
      return
!
      end
!NLSWD
     subroutine nlswd(y, wt, xm, n, m, ixm, mdl, drv, par, npar, res,&
     &   ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING ANALYTIC DERIVATIVES AND WEIGHTS
!     (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,ldstak,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),res(*),wt(*),xm(*),y(*)
!
!  SUBROUTINE ARGUMENTS
       external drv,mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
    &   idrvck,iprt,ivaprx,ivcv,lifixd,lpv,lscale,lsdpv,lsdres,&
     &   lwt,mit,nnzw,npare,nprt
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   pv(1),scale(1),sdpv(1),sdres(1),vcv(1,1)
     integer&
     &   ifixed(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,NLCNTA
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE DERIVATIVES WE
!        CHECKED OR NOT.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF IFIXED(I).EQ
!        THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(1)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(N)
!        THE WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'N','L','S','W','D',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      weight = .true.
      save = .false.
!
      idrvck = 1
      mit = -1
      stopss = -1.0e0
      stopp = -1.0e0
      scale(1) = -1.0e0
      delta = -1.0e0
      nprt = -1
      ifixed(1) = -1
      ivaprx = 0
      lifixd = 1
      lpv = 1
      lscale = 1
      lsdpv = 1
      lsdres = 1
      lwt = n
      ivcv = 1
!
     call nlcnta(y, wt, lwt, xm, n, m, ixm, mdl, drv, par, npar, res,&
    &   ldstak, ifixed, lifixd, idrvck, mit, stopss, stopp, scale,&
    &   lscale, delta, ivaprx, nprt, rsd, pv, lpv, sdpv, lsdpv, sdres,&
     &   lsdres, vcv, ivcv, nmsub, weight, save, nnzw, npare)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL NLSWD (Y, WT, XM, N, M, IXM, NLSMDL, NLSDRV,'/&
     &   '      +            PAR, NPAR, RES, LDSTAK)')
      end
!DEMOUT
      subroutine demout(fd, fc, k, ampl, phase, iphase, ndem, nmsub)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRODUCES THE OUTPUT FOR THE TIME SERIES
!     DEMODULATION ROUTINE.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fc,fd
     integer&
     &   iphase,k,ndem
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ampl(ndem),phase(iphase,2)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   pi,ymn,ymx
     integer&
     &   iprt
     logical&
     &   error
!
!  LOCAL ARRAYS
     integer&
     &   isym(1)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL GETPI,IPRINT,VERSP,VPLMT,VPMN
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AMPL(NDEM)
!        THE ARRAY IN WHICH THE AMPLITUDES OF THE DEMODULATED SERIES
!        ARE STORED.
!     LOGICAL ERROR
!        AN ERROR FLAG
!     REAL FC, FD
!        THE CUTOFF FREQUENCY AND THE DEMODULATION FREQUENCY.
!     INTEGER IERR
!        THE ERROR FLAG
!     INTEGER IPHASE
!
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER ISYM(1)
!        A DUMMY ARRAY.
!     INTEGER K
!        THE NUMBER OF TERMS IN THE LOW PASS FILTER USED TO SMOOTH
!        THE DEMODULATED SERIES.
!     INTEGER NDEM
!        THE NUMBER OF VALUES IN THE DEMODULATED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE
!     REAL PHASE(IPHASE,2)
!        THE ARRAY CONTAINING THE PRIMARY AND SECONDARY PHASE VALUES.
!     REAL PI
!        THE VALUE OF PI.
!     REAL YMN, YMX
!
!
      call iprint(iprt)
!
      call versp(.true.)
!
      call getpi(pi)
!
      write (iprt, 1000) fd, fc, k
!
      write (iprt, 1001)
     call vplmt(ampl, ampl, ndem, 1, ndem, 0.0e0, 0.0e0,&
     &  ymn, ymx, error, nmsub, .false., 1)
!
      if (error) then
        ierr = 1
        return
      else
       call vpmn(ampl, ampl, ndem, 1, ndem, 1, 0, isym, 1, 0,&
     &   ymn, ymx, 1.0e0, 1.0e0, .false., 0, 1, 0)
      end if
!
      write (iprt, 1002)
      call versp(.true.)
      write (iprt, 1003)
     call vpmn(phase, phase, ndem, 2, iphase, 1, 2, isym, 1, 0,&
     &   -2.0e0*pi, 2.0e0*pi, 1.0e0, 1.0e0, .false., 0, 0, 0)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/25h time series demodulation//&
    &   26h demodulation frequency is, f10.8/&
    &   26h cutoff frequency is      , f10.8/&
     &   38h the number of terms in the filter is , i5///)
 1001 format (49h plot of amplitude of smoothed demodulated series)
 1002 format ('1')
 1003 format (45h plot of phase of smoothed demodulated series)
      end
!AMDRV
     subroutine amdrv (mdlts3, drv, done, ifixd, par, npar, xm, n, m,&
     &   ixm, nrests, rests, d, weight, wt, lwt, stpt, lstpt, scl, lscl)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE NUMERICAL APPROXIMATIONS TO THE
!     DERIVATIVE MATRIX (JACOBIAN).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,lscl,lstpt,lwt,m,n,npar,nrests
     logical&
     &   done,weight
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   d(nrests,*),par(*),rests(*),scl(*),stpt(*),wt(*),xm(ixm,*)
     integer&
     &   ifixd(*)
!
!  SUBROUTINE ARGUMENTS
       external drv,mdlts3
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   pj,stpj
     integer&
     &   i,j,jpk
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max,sign
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL D(NRESTS,NPAR)
!        THE FIRST DERIVATIVE OF THE MODEL (JACOBIAN).
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     LOGICAL DONE
!        THE VARIABLE USED TO INDICATE WHETHER THIS IS THE FINAL
!        COMPUTATION OF THE JACOBIAN OR NOT.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IXM
!        THE FIRST DIMENSION OF MATRIX XM.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER JPK
!        AN INDEX VARIABLE.
!     INTEGER LSCL
!        THE DIMENSION OF VECTOR SCL.
!     INTEGER LSTPT
!        THE DIMENSION OF VECTOR STPT.
!     INTEGER LWT
!        THE DIMENSION OF VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDLTS3
!        THE STARPAC FORMAT SUBROUTINE FOR COMPUTING THE ARIMA MODEL
!        RESIDUALS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PJ
!        A TEMPORARY LOCATION FOR STORAGE OF THE JTH PARAMETER.
!     REAL RESTS(NRESTS)
!        THE RESIDUALS FROM THE ARIMA MODEL.
!     REAL SCL(LSCL)
!        THE SCALE VALUES.
!     REAL STPT(LSTPT)
!        THE STEP SIZE ARRAY.
!     REAL STPJ
!        THE JTH STEP SIZE.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     REAL XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!
!     COMPUTE FINITE-DIFFERENCE JACOBIAN OF THE OPTIMIZED PARAMETERS
!
      jpk = 0
!
      do 20 j=1,npar
!
         if (ifixd(j).ne.0) go to 20
!
         jpk = jpk + 1
!
         pj = par(j)
         if (scl(jpk).ne.0.0e0) then
           stpj = stpt(j)*sign(1.0e0,par(j))*max(abs(par(j)),1.0e0/&
     &             abs(scl(jpk)))
         else
            if (par(j).ne.0.0e0) then
               stpj = stpt(j)*sign(1.0e0,par(j))*abs(par(j))
            else
               stpj = stpt(j)
            end if
         end if
!
         stpj = stpj + par(j)
         stpj = stpj - par(j)
!
         par(j) = pj + stpj
         call mdlts3(par, npar, xm, n, m, ixm, d(1,j))
!
         do 10 i=1,nrests
            d(i,jpk) = (-rests(i)+d(i,j))/stpj
   10    continue
!
         par(j) = pj
!
   20 continue
!
      return
!
      end
!RANKO
      subroutine ranko(n, y, h, r, t)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     VERSION  45.0    RANKO    3/ 6/70
!     *****
!     PUTS RANK OF N X"S IN VECTOR R. VECTOR H IS USED FOR STORAGE.
!     X,H AND R MUST BE DIMENSIONED N OR GREATER.
!     STORES CORRECTION FOR TIES IN T = SUM(T-1)*T*(T+1).
!        N.B.  T IS 12 TIMES VALUE COMPUTED BY ORIGINAL OMNITAB ROUTINE.
!     T=0  MEANS NO TIES.
!     WRITTEN BY DAVID HOGBEN, SEL, NBS.   4/9/69.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   t
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   r(n),y(n)
     integer&
     &   h(n)
!
!  LOCAL SCALARS
     integer&
     &   i,ij,j,k,k2
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL SRTIR,SRTRI
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER H(N)
!        THE INDICES TO THE HIERARCHY OF R
!     INTEGER I
!        INDEX VARIABLE
!     INTEGER IJ
!        INDEX VARIABLE BASED ON I-J
!     INTEGER J
!        INDEX VARIABLE
!     INTEGER K
!        INDEX VARIABLE
!     INTEGER K2
!          INDEX VARIABLE
!     INTEGER N
!        NUMBER OF OBSERVATIONS
!     REAL R(N)
!        FINAL VECTOR CONTAINING RANK
!     REAL T
!        12 TIMES THE OMNITAB CORRECTION FOR TIES
!             T = SUM(T-1)*T*(T+1)
!             T = 0 MEANS NO TIES
!     REAL Y(N)
!        VECTOR TO BE RANKED
!
!
!     MOVE Y TO R AND PUT I IN H
!
      do 10 i=1,n
         h(i) = i
         r(i) = y(i)
   10 continue
!
!     SORT Y IN R, CARRY ALONG I IN H TO OBTAIN HIERARCHY IN H.
!
      call srtir(h, n, r)
!
!     REPLACE R(I) BY I*.
!     LET K BE SUCH THAT R(I)=R(I-J+1),J=1,K. THEN I* = I-(K-1)/2.
!
      k = 1
      t = 0
      do 40 i=2,n
         if (r(i).eq.r(i-1)) then
            k = k + 1
         else
            do 30 j=1,k
               ij = i - j
               r(ij) = (i-1) - (k-1)/2.0e0
   30       continue
            t = t + (k-1)*k*(k+1)
            k = 1
         end if
   40 continue
      t = t + (k-1)*k*(k+1)
      do 50 i=1,k
         k2 = n + 1 - i
         r(k2) = n - (k-1)/2.0e0
   50 continue
!
!     SORT H CARRY ALONG R TO OBTAIN RANKS IN R
!
      call srtri(r, n, h)
      return
      end
!UFSMVS
     subroutine ufsmvs(acov, nlppa, lagmax, n, nw, lags, nf,&
     &   fmin, fmax, nprt, spcf, ispcf, freq, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS WITH MISSING DATA (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fmax,fmin
     integer&
     &   ispcf,lagmax,ldstak,n,nf,nprt,nw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(*),freq(*),spcf(*)
     integer&
     &   lags(*),nlppa(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
      real(kind=wp) :: alpha,delta,ymiss
     integer&
    &   ifp,io,iprt,isort,isym,lacov,ldsmin,lnlppa,lpcv,lwork,ly,&
     &   nall0,work,xaxis,yaxis
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12),y(1)
     integer&
     &   istak(12)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ECVF,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UFSDRV
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LAGMAX+1)
!        THE AUTOCOVARIANCES OF THE SERIES.
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE SPECTRUM
!        IS TO BE COMPUTED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF ERR01, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION FOR THE ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY ISYM.
!     INTEGER LACOV
!        THE LENGTH OF THE ACVF VECTORS.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
!        THIS ROUTINE WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(LAGMAX+1)
!        THE ARRAY CONTAINING THE NUMBER OF LAG PRODUCT PAIRS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL SPCF(ISPCF,NW)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     INTEGER WORK
!        THE STARTING LOCATION IN RSTAK FOR
!        THE WORK VECTOR.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY XAXIS.
!     REAL Y(1)
!        A DUMMY ARRAY.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY YAXIS.
!     REAL YMISS
!        A DUMMY VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'U','F','S','M','V','S'/
!
!     SET UP
!
      option(4) = .true.
      option(3) = .true.
      option(2) = .true.
      option(1) = .false.
!
!     COMPUTE MINIMUM ALLOWABLE STACK LENGTH
!
      io = 1
      if (nprt.eq.0) io = 0
!
     call ldscmp(4, 0, io*(nf+5), 0, 0, 0, 'S',&
     &   lagmax+1+io*(2*nf+10), ldsmin)
!
      ymiss = 1.0e0
      lacov = lagmax+1
!
      ly = 1
      lnlppa = lacov
      lpcv = nf + 5
      lwork = lagmax+1
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!     SET THE STACK ALLOCATION TYPE.
!
      call stkset(ldstak, 4)
      nall0 = stkst(1)
!
      ifp = 3
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
!
      if ((ldsmin.gt.ldstak) .or. (ldsmin.le.6)) then
         work = 1
         xaxis = 1
         yaxis = 1
         isym = 1
         isort = 1
      else
         work = stkget(lwork,ifp)
         if (nprt.ne.0) then
            xaxis = stkget(lpcv,ifp)
            yaxis = stkget(lpcv,ifp)
            isym = stkget(lpcv,2)
            isort = isym
         else
            xaxis = work
            yaxis = work
            isym = work
            isort = isym
         end if
      end if
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!     FOR SERIES WITH MISSING DATA.
!
     call ufsdrv(y, ly, ymiss, acov, nlppa, spcf, ispcf, nf, fmin,&
    &   fmax, freq, n, nw, lagmax, lags, rstak(work), lacov, lwork,&
    &   delta, istak(isort), istak(isym), rstak(xaxis), rstak(yaxis),&
    &   lpcv, alpha, nprt, parzen, nmsub, ldsmin, ldstak, option,&
     &   lnlppa, ly)
!
      call stkclr(nall0)
!
!     CHECK FOR ERRORS
!
      if (ierr.eq.0) return
!
      if (ierr.eq.2) call ecvf(nmsub)
      ierr = 1
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &  '       CALL UFSMVS (ACOV, NLPPA, LAGMAX, N,'/&
    &  '      +             NW, LAGS, NF, FMIN, FMAX, NPRT,'/&
     &  '      +             SPCF, ISPCF, FREQ, LDSTAK)')
      end
!BFS
      subroutine bfs(y1, y2, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     BIVARIATE SPECTRUM ANALYSIS (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y1(*),y2(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta,fmax,fmin,ymiss1,ymiss2
     integer&
    &   iccov,icspc2,index1,index2,inlppc,iphas,iprt,jccov,jnlppc,&
     &   lagmax,lagmx1,ldsmin,ldstak,lpcv,lw,ly,m,nf,nprt,nw
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   ccov(101,2,2),ceven(101),codd(101),cspc2(101,4),freq(101),&
    &   phas(101,4),spcf1(101),spcf2(101),w(101),xaxis(404),&
     &   yaxis(404)
     integer&
     &   isym(404),lags(4),nlppc(1,1,1)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL BFSDRV,IPRINT,PARZEN,SETLAG
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL CCOV(101,2,2)
!        THE COVARIANCES.
!     REAL CEVEN(101)
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     REAL CODD(101)
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     REAL CSPC2(101,4)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISYM(404)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC(1,1,1)
!        A DUMMY ARRAY.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL PHAS(101,4)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL SPCF1(101), SPCF2(101)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     REAL W(101)
!        THE WINDOWS.
!     REAL XAXIS(404)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YAXIS(404)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YMISS1, YMISS2
!        DUMMY VARIABLES.
!     REAL Y1(N)
!        THE FIRST TIME SERIES.
!     REAL Y2(N)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'B','F','S',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      option(1) = .false.
      option(2) = .false.
      option(3) = .false.
      option(4) = .false.
!
      iccov = 101
      jccov = 2
      m = 2
      index1 = 1
      index2 = 2
!
      icspc2 = 101
      iphas = 101
!
      ldstak = 0
      ldsmin = 0
!
      nf = 101
      ymiss1 = 1.0e0
      ymiss2 = 1.0e0
      inlppc = 1
      jnlppc = 1
      lw = 101
      ly = n
      lpcv = 404
!
!     SET MAXIMUM LAG VALUE (LAGMAX)
!     SET NUMBER OF LAG WINDOW TRUCCATION POINTS (NW)
!
      call setlag(n, lagmax)
      nw = 4
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
     call bfsdrv(y1, y2, ymiss1, ymiss2, ccov, nlppc, spcf1, spcf2,&
    &   nf, fmin, fmax, freq, n, nw, lagmax, lags, lagmx1, w, lw,&
    &   delta, isym, xaxis, yaxis, lpcv, alpha, nprt, parzen, iccov,&
    &   jccov, m, index1, index2, cspc2, phas, icspc2, iphas, codd,&
    &   ceven, w, lw, nmsub, ldsmin, ldstak, option, n, inlppc,&
     &   jnlppc, ly)
!
      if (ierr.eq.0) return
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL BFS (Y1, Y2, N)')
      end
!MPPL
      subroutine mppl(ym, x, n, m, iym, ilog)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH MULTIPLE Y-AXIS VALUES (LOG OPTION).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ilog,iym,m,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xlb,xmiss,xub,ylb,yub
     integer&
     &   iprt,ischck,isize,lisym,nout
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(IYM,M)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'M',       'P',       'P',       'L',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      xmiss = 1.0e0
      multi = .true.
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 0.0e0
      xub = 0.0e0
      ischck = 2
      isize = -1
      nout = 0
      miss = .false.
      lisym = 1
!
     call ppcnt (ym, ym, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL MPPL (YM, X, N, M, IYM, ILOG)')
      end
!TAPER
      subroutine taper (y, n, taperp, yt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER ROUTINE FOR APPLYING A SPLIT-COSINE-BELL
!     TAPER TO THE (CENTERED) OBSERVED SERIES Y, RETURNING THE TAPERED
!     SERIES IN YT.  THIS ROUTINE IS ADAPTED FROM BLOOMFIELDS
!     ROUTINE TAPER.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   taperp
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*),yt(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   pi,weight
     integer&
     &   i,iprt,j,m
     logical&
     &   err01,head
!
!  LOCAL ARRAYS
     character&
     &   ln(8)*1,nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL CENTER,EISGE,GETPI,IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic cos,int
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICARE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT NUMBER USED FOR OUTPUT.
!     INTEGER J
!        AN INDEXING VARIABLE.
!     CHARACTER*1 LN(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER M
!        THE NUMBER OF POINTS AT EACH END OF THE SERIES TO BE
!        TAPERED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     REAL PI
!        THE VALUE OF PI.
!     REAL TAPERP
!        THE TOTAL PERCENTAGE OF THE DATA TO BE TAPERED.
!     REAL WEIGHT
!        THE ITH TAPER WEIGHT.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YT(N)
!        THE VECTOR IN WHICH THE TAPERED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'T',       'A',       'P',       'E',       'R',       ' '/
     data&
    & ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /'N',' ',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 17, 1, head, err01, ln)
      if (.not. err01) go to 5
!
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
    5 continue
!
      call center (y, n, yt)
!
      if ((taperp .le. 0.0e0) .or. (taperp .gt. 1.0e0)) return
!
      call getpi(pi)
!
      m = int(taperp * n + 0.5e0) / 2
      if (m .eq. 0) return
!
      do 20 i = 1, m
         weight = 0.5e0 - 0.5e0 * cos(pi * (i-0.5e0) / m)
         yt(i) = weight * yt(i)
         j = n + 1 - i
         yt(j) = weight * yt(j)
   20 continue
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   36h       call taper (y, n, taperp, yt))
      end
!AMLST1
     subroutine amlst1 (iamhd, par, npar, mspect, nfac, vcvl, lvcvl,&
     &  scale, lscale, stpt, lstpt, iparmn, iparmx, lbltyp, t975, ifixd)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRINTS THE PARAMETERS FOR THE ARIMA ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   t975
     integer&
     &   iamhd,iparmn,iparmx,lbltyp,lscale,lstpt,lvcvl,nfac,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),scale(*),stpt(*),vcvl(*)
     integer&
     &   ifixd(*),mspect(nfac,4)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm,pll,pul,ratio,sdpar
     integer&
     &   iprt,j,k,l,ll,lpar,order
!
!  LOCAL ARRAYS
     character&
     &   fixed(3)*1
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL FIXPRT,IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     CHARACTER*1 FIXED(3)
!        THE CHARACTERS USED TO LABEL THE PARAMETERS FIXED OR NOT.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER IAMHD
!        THE INDICATOR VALUE USED TO DESIGNATE THE TYPE OF LIST
!        TO BE GENERATED
!        IF IAMHD=1, THE LIST IS FOR THE INITIAL SUMMARY OF THE
!                    ESTIMATION ROUTINES.
!        IF IAMHD=2, THE LIST IS FOR THE INITIAL REPORT OF THE
!                    FORECASTING ROUTINES.
!        IF IAMHD=3, THE LIST IS FOR THE FINAL REPORT OF THE
!                    ESTIMATION ROUTINES.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IPARMN
!        THE SMALLEST PARAMETER INDEX INCLUDED IN THIS TERM.
!     INTEGER IPARMX
!        THE LARGEST PARAMETER INDEX INCLUDED IN THIS TERM.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER LVCVL
!        THE DIMENSION OF VECTOR VCVL.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER L
!        AN INDEX VARIABLE.
!     INTEGER LBLTYP
!        THE TYPE OF LABLE TO BE PRINTED, WHERE
!        1 INDICATES THE TERM IS AUTOREGRESSIVE AND
!        2 INDICATES THE TERM IS MOVING AVERAGE
!     INTEGER LL
!        AN INDEX VARIABLE.
!     INTEGER LPAR
!        AN INDEX VARIABLE.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER LSTPT
!        THE DIMENSION OF VECTOR STPT.
!     INTEGER MSPECT(NFAC,4)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER ORDER
!        THE ORDER OF B FOR THE PARAMETER BEING PRINTED
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PLL
!        THE LOWER CONFIDENCE LIMIT FOR A GIVEN PARAMETER.
!     REAL PUL
!        THE UPPER CONFIDENCE LIMIT FOR A GIVEN PARAMETER.
!     REAL RATIO
!        THE RATIO OF A GIVEN PARAMETER VALUE TO ITS STANDARD ERROR.
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPAR
!        THE STANDARD DEVIATION OF A GIVEN PARAMETER VALUE.
!     REAL STPT(LSTPT)
!        THE STEP SIZE ARRAY.
!     REAL T975
!        THE VALUE OF THE 97.5 PERCENT POINT FUNCTION FOR THE
!        T DISTRIBUTION.
!     REAL VCVL(LVCVL)
!        THE LOWER HALF OF THE VARIANCE-COVARIANCE MATRIX, STORED
!        ROW WISE.
!
!
      fplm = r1mach(2)
!
      call iprint(iprt)
!
!     PRINT NEXT SET OF TERMS
!
      lpar = 0
      do 1 j=1,iparmx
         if (ifixd(j).eq.0) lpar = lpar + 1
    1 continue

      do 40 j=1,nfac
        if ((mspect(j,lbltyp).eq.0) .and. (lbltyp.ne.2)) go to 40
        if (lbltyp.ne.2) iparmx = iparmx + mspect(j,lbltyp)
        if (lbltyp.eq.2) iparmx = iparmx + 1
        order = 0
        do 30 l = iparmn, iparmx
          order = order + mspect(j,4)
          if (iamhd.eq.2) go to 25
          call fixprt(ifixd(l), fixed)
         if (lbltyp.eq.1) write(iprt, 1000) l, j, order,&
     &      (fixed(k),k=1,3), par(l)
         if (lbltyp.eq.2) write(iprt, 1004) l,&
     &      (fixed(k),k=1,3), par(l)
         if (lbltyp.eq.3) write(iprt, 1005) l, j, order,&
     &      (fixed(k),k=1,3), par(l)
            if (iamhd.eq.3) go to 10
!
            if (ifixd(l).eq.0) go to 5
            write (iprt, 1007)
            go to 10
!
    5       continue
            if (scale(1).le.0.0e0) write (iprt, 1001) stpt(l)
            if (scale(1).gt.0.0e0) write (iprt, 1002) scale(l), stpt(l)
   10     continue
          if (iamhd .eq. 1) go to 30
!
          if (ifixd(l).eq.0) go to 20
          write(iprt, 1006)
          go to 30
!
   20     continue
          lpar = lpar + 1
          ratio = fplm
          ll = lpar*(lpar-1)/2 + lpar
          if (vcvl(ll).gt.0.0e0) ratio = par(l)/sqrt(vcvl(ll))
          sdpar = sqrt(vcvl(ll))
          pll = par(l) - t975*sdpar
          pul = par(l) + t975*sdpar
          write(iprt, 1003) sdpar, ratio, pll, pul
          go to 30
   25     continue
          if (lbltyp.eq.1) write(iprt, 1010) l, j, order, par(l)
          if (lbltyp.eq.2) write(iprt, 1014) l, par(l)
          if (lbltyp.eq.3) write(iprt, 1015) l, j, order, par(l)
   30   continue
        iparmn = iparmx + 1
   40 continue
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format(1x, i5, 2x, 'AR (FACTOR', i2, ')',4x,i5,6x,3a1,e17.8)
 1001 format ('+', 65x, 7hdefault, e17.8)
 1002 format ('+', 55x, 2e17.8)
 1003 format ('+', 55x, 4(2x, e15.8))
 1004 format(1x, i5, 13x, 'MU', 4x, '  ---' ,6x,3a1,e17.8)
 1005 format(1x, i5, 2x, 'MA (FACTOR', i2, ')',4x,i5,6x,3a1,e17.8)
 1006 format('+', 55x, 4(14x, '---'))
 1007 format('+', 69x, '---', 14x, '---')
 1010 format(1x, i5, 2x, 'AR (FACTOR', i2, ')',4x,i5,e17.8)
 1014 format(1x, i5, 13x, 'MU', 4x, '  ---' ,e17.8)
 1015 format(1x, i5, 2x, 'MA (FACTOR', i2, ')',4x,i5,e17.8)
      end
!ERSLF
      subroutine erslf (nmsub, nmvar, k, h, head, error)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PERFORMS ERROR CHECKING FOR THE INPUT
!     VALUES OF A SYMMETRIC LINEAR FILTER.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   k
     logical&
     &   error,head
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   h(*)
     character&
     &   nmsub(6)*1,nmvar(8)*1
!
!  LOCAL SCALARS
     integer&
     &   i,ihm,ihp,iprt,khalf,kmid,nzero
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     REAL H(K)
!         THE VECTOR OF FILTER COEFFICIENTS.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IHM, IHP
!        INDEX VARIABLES FOR SYMMETRIC LOCATIONS AROUND THE MIDPOINT
!        OF THE FILTER.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER K
!        THE NUMBER OF TERMS IN THE FILTER.
!     INTEGER KHALF
!        THE VALUE OF THE MIDPOINT OF K MINUS 1.
!     INTEGER KMID
!        THE MIDPOINT OF THE FILTER.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     CHARACTER*1 NMVAR(8)
!        THE ARRAY CONTAINING THE NAME OF THE FILTER COEFFICIENT
!        ARRAY.
!     INTEGER NZERO
!        THE NUMBER OF FILTER COEFFICIENTS EQUAL TO ZERO.
!
      error = .false.
!
      kmid = (k + 1) / 2
      khalf = kmid - 1
      nzero = 0
      do 10 ihm = 1, khalf
         ihp = k + 1 - ihm
         if (h(ihm) .eq. 0.0e0) nzero = nzero + 1
         if (h(ihm)  .eq.  h(ihp)) go to 10
!
         call iprint(iprt)
         call ehdr(nmsub, head)
         write (iprt, 1010) (nmvar(i), i = 1, 6), (h(i), i = 1, k)
         error = .true.
         return
   10 continue
!
      if (h(kmid) .eq. 0.0e0) nzero = nzero + 1
!
      if (nzero .lt. kmid) return
!
      call iprint(iprt)
      call ehdr(nmsub, head)
      write (iprt, 1020) (nmvar(i), i = 1, 6)
      error = .true.
!
      return
!
!     FORMAT STATEMENTS
!
1010 format(/&
    &   18h the input filter , 6a1, 24h must be symmetric.  the,&
    &   30h input filter coefficients are/&
     &   5(1x, e15.5))
1020 format(/&
    &   32h all the filter coefficients in , 6a1, 16h are identically,&
    &   15h equal to zero,/&
     &   42h therefore no filtering will be performed.)
      end
!ACFMNF
     subroutine acfmnf (yfft, n, nfft, lagmax, rho, sdrho, ymean,&
    &   prho, aic, ftest, phi, iar, ospvar, acov, lacov, laic,&
     &   chia, chiap, lyfft, work, lwork, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING AUTOCORRELATIONS AND
!     PARTIAL AUTOCORRELATIONS OF A TIME SERIES .
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   chia,chiap,ospvar,ymean
     integer&
     &   iar,lacov,lagmax,laic,lwork,lyfft,n,nfft,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   acov(*),aic(*),ftest(2,*),phi(*),prho(*),rho(*),sdrho(*),&
     &   work(*),yfft(*)
!
!  LOCAL SCALARS
     integer&
     &   i
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL ACFSD,ACVFF,AOS,CHIRHO
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV)
!        THE AUTOCOVARIANCE FUNCTION ESTIMATE VECTOR.
!     REAL AIC(LAIC)
!        THE AKAIKES INFORMATION CRITERION VECTOR.
!     REAL CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     REAL FTEST(2, LAGMAX)
!        THE ARRAY IN WHICH THE PARTIAL F RATIOS AND PROBABILITIES
!        ARE STORED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     REAL OSPVAR
!        THE ONE STEP PREDICTION VARIANCE.
!     REAL PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER (IAR).
!     REAL PRHO(LAGMAX)
!        THE ARRAY IN WHICH THE PARTIAL AUTOCORRELATIONS ARE STORED
!     REAL RHO(LAGMAX)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
!     REAL SDRHO(LAGMAX)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!        ARE STORED
!     REAL WORK(LWORK)
!        A WORK ARRAY.
!     REAL YFFT(LYFFT)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!     COMPUTE AUTOCOVARIANCESS AND STANDARD DEVIATION OF THE SERIES.
!
     call acvff(yfft, n, nfft, ymean, acov, lagmax, lacov, lyfft, work,&
     &   lwork)
!
      if (acov(1) .eq. 0.0e0) return
!
!     COMPUTE PARTIAL AUTOCORRELATIONS AND AUTOREGRESSIVE ORDER
!     SELECTION STATISTICS.
!
     call aos (n, lagmax, acov, prho, iar, ospvar, phi, work,&
     &   aic, ftest, lacov, laic)
!
      if (nprt .eq. 0) return
!
!     COMPUTE AUTOCORRELATIONS
!
      do 10 i = 1, lagmax
         rho(i) = acov(i+1) / acov(1)
   10 continue
!
!     COMPUTE STANDARD ERROR OF AUTOCORRELATIONS.
!
      call acfsd (rho, sdrho, lagmax, n)
!
!     COMPUTE CHI STATISTIC BASED ON AUTOCORRELATION VALUES
!
      call chirho (rho, n, lagmax, chia, chiap)
!
      return
      end
!AIMF
      subroutine aimf (y, n, mspec, nfac, par, npar, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR ARIMA ESTIMATION
!     (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,n,nfac,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),y(*)
     integer&
     &   mspec(4,*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   ifcst,iprt,nfcst,nfcsto,nprt
     logical&
     &   save
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   fcst(1,1),fcstsd(1)
     integer&
     &   ifcsto(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AMFCNT,IPRINT
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FCST(1,1)
!        THE STORAGE ARRAY FOR THE FORECASTS.
!     REAL FCSTSD(1)
!        THE STORAGE ARRAY FOR THE STANDARD DEVIATIONS OF THE FORECASTS.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFCST
!        THE FIRST DIMENSION OF THE ARRAY FCST.
!     INTEGER IFCSTO(1)
!        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER MSPEC(4,NFAC)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFCST
!        THE NUMBER OF FORECASTS.
!     INTEGER NFCSTO
!        THE NUMBER OF THE ORIGINS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'A','I','M','F',' ',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      save = .false.
!
      nfcst = n/10 + 1
      nfcsto = 1
      ifcsto(1) = n
      nprt = -1
      ifcst = 1
!
     call amfcnt(y, n, mspec, nfac, par, npar, ldstak, nfcst, nfcsto,&
     &   ifcsto, nprt, fcst, ifcst, fcstsd, nmsub, save)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/' THE CORRECT FORM OF THE CALL STATEMENT IS'//&
     &     '       CALL AIMF (Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK)')
      end
!REALTR
      subroutine realtr(a, b, n, isn)
!  IF ISN=1, THIS SUBROUTINE COMPLETES THE FOURIER TRANSFORM
!    OF 2*N DATA VALUES, WHERE THE ORIGINAL DATA VALUES ARE
!    STORED ALTERNATELY IN ARRAYS A AND B, AND ARE FIRST
!    TRANSFORMED BY A COMPLEX FOURIER TRANSFORM OF DIMENSION N.
!    THE COSINE COEFFICIENTS ARE IN A(1),A(2),...A(N+1) AND
!    THE SINE COEFFICIENTS ARE IN B(1),B(2),...B(N+1).
!    A TYPICAL CALLING SEQUENCE IS
!      CALL FFT(A,B,N,N,N,1)
!      CALL REALTR(A,B,N,1)
!    THE RESULTS SHOULD BE MULTIPLIED BY 0.5E0/N TO GIVE THE
!    USUAL SCALING OF COEFFICIENTS.
!  IFISN-1, THE INVERSE TRANSFORMATION IS DONE, THE FIRST STEP
!    IN EVALUATING A REAL FOURIER SERIES.
!    A TYPICAL CALLING SEQUENCE IS
!      CALL REALTRA(A,B,N,-1)
!      CALL FFT(A,B,N,N,N,-1)
!    THE RESULTS SHOULD BE MULTIPLIED BY 0.5E0 TO GIVE THE USUAL
!    SCALING, AND THE TIME DOMAIN RESULTS ALTERNATE IN ARRAYS A
!    AND B, I.E. A(1),B(1),A(2),B(2),...A(N),B(N).
!  THE DATA MAY ALTERNATIVELY BE STORED IN A SINGLE COMPLEX
!    ARRAY A, THEN THE MAGNITUDE OF ISN CHANGED TO TWO TO
!    GIVE THE CORRECT INDEXING INCREMENT AND A(2) USED TO
!    PASS THE INITIAL ADDRESS FOR THE SEQUENCE OF IMAGINARY
!    VALUES, E.G.
!      CALL FFT(A,A(2),N,N,N,2)
!      CALL REALTR(A,A(2),N,2)
!    IN THIS CASE, THE COSINE AND SINE COEFFICIENTS ALTERNATE IN A.
!  BY R. C. SINGLETON, STANFORD RESEARCH INSTITUTE, OCT. 1968
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   isn,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   a(1),b(1)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   aa,ab,ba,bb,cd,cn,im,re,sd,sn
     integer&
     &   inc,j,k,nh,nk
!
!  INTRINSIC FUNCTIONS
      intrinsic atan,iabs,sin
!
!
!
      inc = iabs(isn)
      nk = n*inc + 2
      nh = nk/2
      sd = 2.0e0*atan(1.0e0)/n
      cd = 2.0e0*sin(sd)**2
      sd = sin(sd+sd)
      sn = 0.0e0
      if (isn.lt.0) go to 30
      cn = 1.0e0
      a(nk-1) = a(1)
      b(nk-1) = b(1)
   10 do 20 j=1,nh,inc
         k = nk - j
         aa = a(j) + a(k)
         ab = a(j) - a(k)
         ba = b(j) + b(k)
         bb = b(j) - b(k)
         re = cn*ba + sn*ab
         im = sn*ba - cn*ab
         b(k) = im - bb
         b(j) = im + bb
         a(k) = aa - re
         a(j) = aa + re
         aa = cn - (cd*cn+sd*sn)
         sn = (sd*cn-cd*sn) + sn
         cn = 0.5e0/(aa**2+sn**2) + 0.5e0
         sn = cn*sn
         cn = cn*aa
   20 continue
      return
   30 cn = -1.0e0
      sd = -sd
      go to 10
      end
!AMEDRV
     subroutine amedrv(y, n, mspec, nfac, par, npar,&
    &   res, ldstak, ifixed, lifixd, stp, lstp, mit, stopss, stopp,&
    &   scale, lscale, delta, ivaprx, nprt, rsd, pv, lpv, sdpv, lsdpv,&
     &   sdres, lsdres, vcv, ivcv, nmsub, save, npare)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
    &   ivaprx,ivcv,ldstak,lifixd,lpv,lscale,lsdpv,lsdres,lstp,&
     &   mit,n,nfac,npar,npare,nprt
     logical&
     &   save
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   par(*),pv(*),res(*),scale(*),sdpv(*),sdres(*),stp(*),vcv(*),&
     &   y(*)
     integer&
     &   ifixed(*),mspec(4,*)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
    &   ierr,iflag,mbo,mbol,mspect,nfact,nparar,npardf,nparma,&
     &   nrests,parar,pardf,parma,t,temp
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   exmpt
     integer&
     &   ifp,is,isubhd,ixm,ldsmin,lwt,m,nall0,ndigit,neta,nnzw,stpt
     logical&
     &   aprxdv,hlfrpt,page,prtfxd,weight,wide
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12),wt(1)
     integer&
     &   iptout(5),istak(12)
!
!  EXTERNAL FUNCTIONS
     integer&
     &   icnti,stkst
!       EXTERNAL ICNTI,STKST
!
!  EXTERNAL SUBROUTINES
       external amecnt,ameer,amehdr,amestp,backop,cpyvii,&
    &   dcoef,drv,ldscmp,mdlts1,mdlts3,nldrvn,prtcnt,&
     &   stkclr,stkset,stpamo
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
     common /mdltsc/mspect,nfact,pardf,npardf,parar,nparar,parma,&
     &   nparma,mbo,mbol,t,temp,nrests,iflag
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     EXTERNAL AMEHDR
!        THE ROUTINE USED TO PRINT THE HEADING
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IFLAG
!        ...
!     INTEGER IFP
!        AN INDICATOR FOR THE PRECISION OF THE STACK ALLOCATION TYPE,
!        WHERE IFP=3 INDICATES SINGLE AND IFP=4 INDICATES DOUBLE.
!     INTEGER IPTOUT(5)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER IS
!        A VALUE USED TO DETERMINE THE AMOUNT OF WORK SPACE NEEDED
!        BASED ON WHETHER STEP SIZES ARE INPUT OR ARE TO BE CALCULATED.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE FOR
!        IVAPRX LE 0, VCV = THE DEFAULT OPTION
!        IVAPRX EQ 1, VCV = INVERSE(TRANSPOSE(J)*J)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2, VCV = INVERSE(H)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4, VCV = INVERSE(TRANSPOSE(J)*J)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5, VCV = INVERSE(H)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7, VCV = THE DEFAULT OPTION
!        WITH J REPRESENTING THE JACOBIAN AND H THE HESSIAN.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF MATRIX XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE DIMENSION OF VECTOR IFIXED.
!     INTEGER LPV
!        THE DIMENSION OF VECTOR PV.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER LSDPV
!        THE DIMENSION OF VECTOR SDPV.
!     INTEGER LSDRES
!        THE DIMENSION OF VECTOR SDRES.
!     INTEGER LSTP
!        THE DIMENSION OF VECTOR STP.
!     INTEGER LWT
!        THE DIMENSION OF VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBOL
!        THE MAXIMUM BACK ORDER ON THE LEFT
!     EXTERNAL MDLTS1
!        THE STARPAC FORMAT SUBROUTINE FOR COMPUTING THE ARIMA MODEL
!        PREDICTED VALUES.
!     EXTERNAL MDLTS3
!        THE STARPAC FORMAT SUBROUTINE FOR COMPUTING THE ARIMA MODEL
!        RESIDUALS.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER MSPEC(4,NFAC)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER MSPECT
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        NUMBER OF STACK ALLOCATIONS OUTSTANDING.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL RESULTS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFACT
!        THE NUMBER OF FACTORS IN THE MODEL
!     EXTERNAL NLDRVN
!        THE NAME OF THE ROUTINE WHICH CALCULATES THE DERIVATIVES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARAR
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE AUTOREGRESSIVE PARAMETERS
!     INTEGER PARDF
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
!     INTEGER PARMA
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE MOVING AVERAGE PARAMETERS
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     REAL PV(LPV)
!        THE PREDICTED VALUE OF THE FIT.
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(LSDPV)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(LSDRES)
!        THE STANDARDIZED RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(LSTP)
!        THE STEP SIZE ARRAY.
!     EXTERNAL STPAMO
!        THE ROUTINE USED TO PRINT THE OUTPUT FROM THE STEP SIZE SELECTI
!        ROUTINES.
!     INTEGER STPT
!        THE STARTING LOCATION IN /CSTAK/ OF VECTOR STPT CONTAINING
!        THE STEP SIZE ARRAY.
!     INTEGER T
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR.
!     INTEGER TEMP
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR
!     REAL VCV(IVCV,NPAR)
!        THE VARIANCE-COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL WT(1)
!        THE USER SUPPLIED WEIGHTS, UNUSED WHEN WEIGHT = FALSE.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!     SET VARIOUS PROGRAM VALUES
!
      weight = .false.
      wt(1) = 1.0e0
      lwt = 1
!
      hlfrpt = .false.
      aprxdv = .true.
      prtfxd = .true.
      exmpt = -1.0e0
      neta = 0
!
      wide = .true.
      page = .false.
!
      ndigit = 5
!
!     COMPUTE BACK OPERATORS
!
      call backop(mspec, nfac, npardf, mbol, mbo, nparma, nparar)
      nnzw = n - npardf
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      npare = npar
     if ((ifixed(1).ge.0) .and. (npar.ge.1)) npare =&
     &   icnti(ifixed,npar,0)
      is = 0
      if (stp(1).le.0.0e0) is = 1
!
     call ldscmp(25, 0, max(is*2*(n+npar),60+npar+npare) + 4*nfac,&
    &   0, 0, 0, 'S', 5*mbo +&
    &   max(is*(10*n+6*mbo+606),&
    &        94+4*(n+mbo+101)+npare*(3*npare+35)/2),&
     &   ldsmin)
!
     call ameer(nmsub, n, npar, npare, ldstak,&
     &   ldsmin, stp, lstp, scale, lscale, ivcv, save, mspec, nfac)
!
      if (ierr.ne.0) return
!
      call stkset(ldstak, 4)
!
!     SET PRINT CONTROL VALUES
!
      call prtcnt(nprt, ndigit, iptout)
!
!     SUBDIVIDE WORKSPACE FOR STEP SIZES
!
      nall0 = stkst(1)
!
      ifp = 3
!
      stpt = stkget(npar,ifp)
!
      pardf = stkget(mbo, ifp)
      parar = stkget(mbo, ifp)
      parma = stkget(mbo, ifp)
      t = stkget(2*mbo, ifp)
!
      temp = t + mbo
!
      nfact = nfac
      mspect = stkget(4*nfac, 2)
!
!     SET UP FOR MODEL
!
      aprxdv = .true.
      m = 1
      ixm = n
      nrests = mbo + 101 + n
!
      call cpyvii(nfac, mspec(1,1), 4, istak(mspect), 1)
      call cpyvii(nfac, mspec(2,1), 4, istak(mspect+nfac), 1)
      call cpyvii(nfac, mspec(3,1), 4, istak(mspect+2*nfac), 1)
      call cpyvii(nfac, mspec(4,1), 4, istak(mspect+3*nfac), 1)
     call dcoef (nfac, istak(mspect+nfac), istak(mspect+3*nfac),&
     &  npardf, rstak(pardf), mbo, rstak(t))
!
!     COPY SUPPLIED STEP SIZES TO WORK SPACE
!
      call scopy(lstp, stp, 1, rstak(stpt), 1)
!
      if (ierr.ne.0) go to 10
!
!     SELECT STEP SIZES, IF DESIRED
!
      isubhd = 1
     if (stp(1).le.0.0e0) call amestp(y, n, m, ixm, mdlts3, par, npar,&
    &  rstak(stpt), exmpt, neta, scale, lscale, iptout(1), amehdr,&
    &  page, wide, isubhd, hlfrpt, prtfxd, ifixed, lifixd, stpamo,&
     &  nrests-n)
!
     call amecnt(y, wt, lwt, y, n, m, ixm, mdlts1, nldrvn, aprxdv, drv,&
    &  par, npar, res, ifixed, lifixd, rstak(stpt), npar, mit,&
    &  stopss, stopp, scale, lscale, delta, ivaprx, rsd, pv, lpv,&
    &  sdpv, lsdpv, sdres, lsdres, vcv, ivcv, weight, save, nnzw,&
     &  npare, amehdr, page, wide, iptout, ndigit, hlfrpt, nrests)
!
   10 continue
!
      call stkclr(nall0)
!
      return
!
      end
!GETPI
subroutine getpi(pi)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SETS THE VALUE OF PI.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) :: pi
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL(KIND=WP) :: PI
!        THE VALUE OF PI.
!
      pi = 3.141592653589793238462643383279_wp

end subroutine getpi
!FITXSP
     subroutine fitxsp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv,&
     &   nnzw, npare, rsd)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     GENERATES REPORTS FOR LEAST SQUARES EXERCISER RETURNED STORAGE
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   ivcv,n,nnzw,npar,npare
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),pv(n),res(n),sdpv(n),sdres(n),vcv(ivcv,npar)
!
!  LOCAL SCALARS
     integer&
     &   i,iprt
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,MATPRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        INDEX VARIABLE
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT
!     INTEGER IVCV
!        ACTUAL FIRST DIMENSION OF VCV
!     INTEGER N
!        NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        NUMBER OF PARAMETERS
!     INTEGER NPARE
!        NUMBER OF PARAMETERS ESTIMATED BY ROUTINE.
!     INTEGER NNZW
!        NUMBER OF NONZERO WEIGHTS.
!     REAL PAR(NPAR)
!        THE ESTIMATED PARAMETERS.
!     REAL PV(N)
!        PREDICTED VALUES
!     REAL RES(N)
!        RESIDUALS
!     REAL RSD
!        RESIDUAL STANDARD DEVIATION
!     REAL SDPV(N)
!        STANDARD DEVIATION OF PREDICTED VALUES
!     REAL SDRES(N)
!        STANDARDIZED RESIDUALS.
!     REAL VCV(IVCV,NPAR)
!        VARIANCE COVARANCE MATRIX
!
      call iprint(iprt)
      write (iprt,1000)
      do 10 i=1,n
         if (i.le.npar) then
            write (iprt,1010) i,par(i),res(i),pv(i),sdpv(i),sdres(i)
         else
            write (iprt,1070) i,res(i),pv(i),sdpv(i),sdres(i)
         end if
   10 continue
      write (iprt,1030)
      call matprt(vcv, vcv, ivcv, iprt, 1, 1, ivcv)
      write (iprt,1060) rsd
      write (iprt,1040) nnzw
      write (iprt,1050) npare
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/12x, 3hpar, 12x, 3hres, 12x, 2hpv, 13x, 4hsdpv, 12x,&
     &   5hsdres/)
 1010 format (1x, i5, g14.7, 2x, 4(g14.7, 2x))
 1030 format (/27h variance covariance matrix)
 1040 format (8h nnzw = , i5)
 1050 format (9h npare = , i5)
 1060 format (/7h rsd = , g14.7)
 1070 format (1x, i5, 16x, 4(g14.7, 2x))
      end
!SUMWSS
     subroutine sumwss(x, w, n, lo, mid, hi, nnzw, sum1, sumw1, sumw2,&
     &   sumwa, sumw, xmean, xmeanw)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO CALCULATE WEIGHTED AND UNWEIGHTED SUMS OF
!     POWERS AND THE MEAN FOR A SORTED VECTOR IN WHICH THE MID TH
!     ELEMENT IS THE ELEMENT CLOSEST TO ZERO.  USED BY THE STAT
!     FAMILY.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   sum1,sumw,sumw1,sumw2,sumwa,xmean,xmeanw
     integer&
     &   hi,lo,mid,n,nnzw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   w(n),x(n)
!
!  LOCAL SCALARS
     integer&
     &   curhi,curlo,i,irev
!
!  INTRINSIC FUNCTIONS
      intrinsic abs
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CURHI
!        THE UPPER BOUND OF THE CURRENT INTERVAL.
!     INTEGER CURLO
!        THE LOWER BOUND OF THE CURRENT INTERVAL.
!     INTEGER HI
!        INPUT PARAMETER.  THE UPPER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER I
!        LOOP PARAMETER.
!     INTEGER IREV
!        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
!        IN THE REVERSE ORDER.
!     INTEGER LO
!        INPUT PARAMETER.  THE LOWER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER MID
!        INPUT PARAMETER.  THE INDEX OF THE ELEMENT IN X CLOSEST TO
!        ZERO IN VALUE.  THE POINT OUT FROM WHICH THE SUMMING IS
!        DONE.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
!     INTEGER NNZW
!        INPUT PARAMETER.  THE NUMBER OF POSITIVELY WEIGHTED VALUES
!        IN X.
!     REAL SUMW
!        OUTPUT PARAMETER.  THE SUM OF THE WEIGHTS WT(I).
!     REAL SUMWA
!        OUTPUT PARAMETER.  THE WEIGHTED SUM OF THE ABSOLUTE
!        VALUES OF THE ELEMENTS OF X.
!     REAL SUMW1
!        OUTPUT PARAMETER.  THE WEIGHTED SUM OF THE ELEMENTS OF
!        X.
!     REAL SUMW2
!        OUTPUT PARAMETER.  THE WEIGHTED SUM OF THE SQUARES OF
!        THE ELEMENTS OF X.
!     REAL SUM1
!        OUTPUT PARAMETER.  THE UNWEIGHTED SUM OF THE ELEMENTS OF X.
!     REAL W(N)
!        INPUT PARAMETER.  THE ARRAY OF WEIGHTS.
!     REAL X(N)
!        INPUT PARAMETER.  THE DATA ARRAY X IN WHICH THE SUMS ARE TAKEN.
!     REAL XMEAN
!        OUTPUT PARAMETER.  THE UNWEIGHTED MEAN OF X.
!     REAL XMEANW
!        OUTPUT PARAMETER.  THE WEIGHTED MEAN OF X.
!
!     INITIALIZE SUMMATION VARIABLES.
!
      sum1 = 0.0e0
      sumw1 = 0.0e0
      sumw2 = 0.0e0
      sumwa = 0.0e0
      sumw = 0.0e0
      if (w(mid).eq.0.0e0) go to 10
      sum1 = x(mid)
      sumw1 = w(mid)*x(mid)
      sumw2 = w(mid)*x(mid)*x(mid)
      sumwa = w(mid)*abs(x(mid))
      sumw = w(mid)
   10 curlo = mid - 1
      curhi = mid + 1
!
!     SUM OUTWARDS, FROM THE VALUE NEAREST ZERO.  THAT IS, FROM
!     THE LEAST IN MAGNITUDE TO THE GREATEST.
!
   20 if (curhi.gt.hi .or. curlo.lt.lo) go to 60
      if (abs(x(curhi)).lt.abs(x(curlo))) go to 40
      if (w(curlo).eq.0.0e0) go to 30
      sum1 = sum1 + x(curlo)
      sumw1 = sumw1 + w(curlo)*x(curlo)
      sumw2 = sumw2 + w(curlo)*x(curlo)*x(curlo)
      sumwa = sumwa + w(curlo)*abs(x(curlo))
      sumw = sumw + w(curlo)
   30 curlo = curlo - 1
      go to 20
   40 if (w(curhi).eq.0.0e0) go to 50
      sum1 = sum1 + x(curhi)
      sumw1 = sumw1 + w(curhi)*x(curhi)
      sumw2 = sumw2 + w(curhi)*x(curhi)*x(curhi)
      sumwa = sumwa + w(curhi)*abs(x(curhi))
      sumw = sumw + w(curhi)
   50 curhi = curhi + 1
      go to 20
!
!     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
!     CENTER ZERO POINT.
!
   60 if (curhi.gt.hi) go to 80
      do 70 i=curhi,hi
         if (w(i).eq.0.0e0) go to 70
         sum1 = sum1 + x(i)
         sumw1 = sumw1 + w(i)*x(i)
         sumw2 = sumw2 + w(i)*x(i)*x(i)
         sumwa = sumwa + w(i)*abs(x(i))
         sumw = sumw + w(i)
   70 continue
   80 if (curlo.lt.lo) go to 100
      do 90 irev=lo,curlo
         i = lo - irev + curlo
         if (w(i).eq.0.0e0) go to 90
         sum1 = sum1 + x(i)
         sumw1 = sumw1 + w(i)*x(i)
         sumw2 = sumw2 + w(i)*x(i)*x(i)
         sumwa = sumwa + w(i)*abs(x(i))
         sumw = sumw + w(i)
   90 continue
  100 xmean = sum1/nnzw
      xmeanw = sumw1/sumw
      return
      end
!ERVGT
     subroutine ervgt (nmsub, nmvar, vec, n, veclb, nvmx,&
     &   head, msgtyp, nv, error, nmmin)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS TO ENSURE THAT NO VALUES, OR ONLY A MAXIMUM
!     OF NVMX, ARE NOT GREATER THAN A SPECIFIED LOWER BOUND VECLB,
!     WITH NAME NMMIN. THE ROUTINE ALTERNATIVELY CHECKS TO MAKE SURE
!     THAT NO VALUES ARE IN VIOLATION OF THIS LOWER BOUND IF THE FIRST
!     VALUE IN THE VECTOR IS NOT.  THE CHECKING OPTION IS SPECIFIED
!     WITH MSGTYP.  IF AN ERROR IS FOUND, THE ERROR IS PRINTED AND
!     AN ERROR FLAG AND THE NUMBER OF VIOLATINS ARE RETURNED.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   veclb
     integer&
     &   msgtyp,n,nv,nvmx
     logical&
     &   error,head
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   vec(*)
     character&
     &   nmmin(8)*1,nmsub(6)*1,nmvar(8)*1
!
!  LOCAL SCALARS
     integer&
     &   i,nvmn
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL ERVGTP
!
!  INTRINSIC FUNCTIONS
      intrinsic mod
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        THE VALUE RETURNED FROM THE ERROR CHECKING ROUTINES TO INDICATE
!        WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED (TRUE)
!        OR NOT (FALSE).
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER MSGTYP
!        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
!        IF (MSGTYP.GE.4) THE MESSAGE PRINTED WILL USE NMMIN
!        OTHERWISE IT WILL USE VECLB.
!        IF (MSGTYP = 1 OR 4) NO VIOLATIONS ARE ALLOWED.
!        IF (MSGTYP = 2 OR 5) THE NUMBER OF VIOLATIONS MUST
!                             BE LESS THAN   NVMX   .
!        IF (MSGTYP = 3 OR 6) VIOLATIONS ARE COUNTED ONLY IF THE
!                             THE FIRST ELEMENT IS NOT IN VIOLATION.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE ARGUMENTS NAME.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND.
!     INTEGER NVMN
!        THE SMALLEST NUMBER OF NON-VIOLATIONS ALLOWED.
!     INTEGER NVMX
!        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
!     REAL VEC(N)
!        THE VECTOR BEING TESTED.
!     REAL VECLB
!        THE VALUE THAT THE VECTOR IS BEING TESTED AGAINST.
!
      error = .false.
!
      if (n .le. 0) return
!
!     TEST WHETHER TESTING IS NECESSRY
!
      if ((mod(msgtyp,3) .eq. 0) .and. (vec(1) .le. veclb)) return
!
!     CHECK FOR VIOLATIONS
!
      nv = 0
      do 5 i = 1, n
         if ((vec(i).le.veclb)) nv = nv + 1
    5 continue
!
      if (nv .le. nvmx) return
!
!     VIOLATIONS FOUND
!
      error = .true.
      nvmn = n - nvmx
     call ervgtp (nmsub, nmvar, veclb, nvmn, nvmx, head, msgtyp, nv,&
     &   nmmin)
!
      return
!
      end
!AOV1XP
      subroutine aov1xp(gstat, igstat, ng)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     PRINT STORAGE FOR ONEWAY FAMILY EXERCISER
!     AND CLEAR STORAGE VECTORS
!
!     WRITTEN BY -
!        LINDA MITCHELL
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   igstat,ng
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   gstat(igstat,4)
!
!  LOCAL SCALARS
     integer&
     &   i,iprt,j
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,SETRA
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL GSTAT(IGSTAT,4)
!        THE GROUP STATISTICS.  COLUMNS CORRESPOND TO THE TAG
!        VALUE, SAMPLE SIZE, GROUP MEAN, AND GROUP STANDARD DEVIATION.
!     INTEGER I
!        AN INDEX VALUE
!     INTEGER IGSTAT
!        THE FIRST DIMENSION OF GSTAT.
!     INTEGER IPRT
!        THE OUTPUT LOGICAL UNIT NUMBER
!     INTEGER J, NG
!        *
!
!     COMMENCE BODY OF ROUTINE
!
      call iprint(iprt)
      write (iprt,1000)
      write (iprt,1010) ((gstat(i,j),j=1,4),i=1,ng)
      call setra(gstat, igstat, 4, ng, 0.0e0)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format(//21h storage from aov1   //6x, 8htagvalue,&
     &   11x, 10h groupsize, 11x, 10h groupmean, 13x, 8h groupsd/)
 1010 format(4(1x, g20.14))
      end
!CCFXP
     subroutine ccfxp (store, lagmax, m, ccov, iccov, jccov, miss,&
     &   nlppc,  inlppc, jnlppc, cmiss)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO LIST THE COMPUTED RESULTS FROM THE TIME SERIES
!     CROSS CORRELATION ROUTINES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   cmiss
     integer&
     &   iccov,inlppc,jccov,jnlppc,lagmax,m
     logical&
     &   miss,store
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ccov(iccov,jccov,*)
     integer&
     &   nlppc(inlppc,jnlppc,*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   i,iprt,j,k,l,l1,lag
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ccf(16)
!
!  EXTERNAL FUNCTIONS
!      LOGICAL
!     +   MVCHK
!      EXTERNAL MVCHK
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCF(16)
!        AN ARRAY USED FOR PRINTING THE CCF.
!     REAL CCOV(ICCOV,JCCOV,M)
!        THE CROSS COVARIANCE ARRAY.
!     REAL CMISS
!        THE MISSING VALUE CODE FOR THE RETURNED CCVF ESTIMATES
!        (VECTOR CCOV).
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER J
!        AN INDEXING VARIABLE.
!     INTEGER JCCOV, JNLPPC
!        THE SECOND DIMENSIONS OF THE ARRAYS CCOV AND NLPPC,
!        RESPECTIVELY.
!     INTEGER K
!        AN INDEXING VARIABLE.
!     INTEGER L1
!        AN INDEX VARIABLE.
!     INTEGER LAG
!        THE LAG VALUE AT WHICH THE DATA IS BEING PRINTED.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER M
!        THE NUMBER OF SERIES IN THE MULTIVARIATE TIME SERIES YM.
!     LOGICAL MISS
!        THE VALUE INDICATING WHETHER THE ANALYSIS INCLUDED MISSING
!        DATA (TRUE) OR NOT (FALSE).
!     INTEGER NLPPC(INLPPC,JNLPPC,M)
!        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
!        USED TO COMPUTE EACH CCVF ESTIMATE.
!     LOGICAL STORE
!        THE VALUE INDICATING WHETHER THE RESULTS WERE RETURNED
!        TO THE USER (TRUE) OR NOT (FALSE).
!
      call iprint(iprt)
!
!     PRINT IERR
!
      write (iprt, 1000) ierr
!
      if (ierr.ne.0) return
!
!     CHECK FOR STORED RESULTS
!
      if (.not.store) return
!
!     PRINT HEADING FOR CCVF
!
      write (iprt, 1010)
      write (iprt, 1040) ((j,k, k=1,m), j=1,m)
!
!     PRINT CROSS COVARIANCES
!
      lag = 0
      write (iprt, 1060) lag, ((ccov(1,j,k), k=1,m), j=1,m)
      do 10 lag = 1, lagmax
         write (iprt, 1060) lag, ((ccov(lag+1,j,k), k=1,m), j=1,m)
   10 continue
!
!     PRINT HEADING FOR CCF
!
      write (iprt, 1020)
      write (iprt, 1040) ((j,k, k=1,m), j=1,m)
!
!     PRINT CROSS CORRELATIONS
!
      lag = 0
      i = 0
      do 30 j = 1, m
         do 20 k = 1, m
            i = i + 1
            ccf(i) = ccov(1,j,k) / sqrt(ccov(1,j,j)*ccov(1,k,k))
   20    continue
   30 continue
      write (iprt, 1060) lag, (ccf(l), l=1,i)
!
      do 60 lag = 1, lagmax
         i = 0
         do 50 j = 1, m
            do 40 k = 1, m
               i = i + 1
               if (.not.miss) go to 35
               ccf(i) = cmiss
               if (mvchk(ccov(lag+1,j,k),cmiss)) go to 40
   35          ccf(i) = ccov(lag+1,j,k) / sqrt(ccov(1,j,j)*ccov(1,k,k))
   40       continue
   50    continue
         write (iprt, 1060) lag, (ccf(l1), l1=1,i)
   60 continue
!
!     CHECK FOR MISSING VALUES
!
      if (.not.miss) return
!
!     PRINT HEADING FOR NUMBERS OF LAGGED PRODUCT PAIRS
!
      write (iprt, 1030)
      write (iprt, 1040) ((j,k, k=1,m), j=1,m)
!
!     PRINT NUMBERS OF LAGGED PRODUCT PAIRS FOR EACH CCVF
!
      lag = 0
      write (iprt, 1070) lag, ((nlppc(1,j,k), k=1,m), j=1,m)
      do 70 lag = 1, lagmax
         write (iprt, 1070) lag, ((nlppc(lag+1,j,k), k=1,m), j=1,m)
   70 continue
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (//8h ierr = , i5)
 1010 format (// 6x, 6h  ccvf)
 1020 format (// 6x, 6h   ccf)
 1030 format (// 6x, 6h nlppc)
 1040 format (1x, 3hlag, 16(5x, i1, ',', i1))
 1060 format (1x, i3, 16f8.4)
 1070 format (1x, i3, 16i8)
      end
!GFAEST
      subroutine gfaest (phi, iar, nf, freq, gain, phas, delta)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE GAIN FUNCTION OF AN AUTOREGRESSIVE
!     LINEAR FILTER USING THE ALGORITHM GIVEN ON PAGES 419 AND 420
!     JENKINS AND WATTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta
     integer&
     &   iar,nf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(nf),gain(nf),phas(nf),phi(iar)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   arg,c,pi,s,v0,v1,v2,z0,z1,z2
     integer&
     &   i,j,jj
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL GETPI
!
!  INTRINSIC FUNCTIONS
      intrinsic atan2,cos,sin,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ARG
!        A VALUE USED TO COMPUTE THE GAIN FUNCTION ESTIMATES.
!     REAL C
!        A VALUE USED TO COMPUTE THE GAIN FUNCTION ESTIMATES.
!     REAL DELTA
!        THE SAMPLING INTERVAL OF THE ORIGINAL SERIES.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO
!        BE ESTIMATED.
!     REAL GAIN(NF)
!        THE ARRAY IN WHICH THE GAIN FUNCTION ESTIMATES ARE RETURNED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER J, JJ
!        INDEX VARIABLES.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE GAIN FUNCTION ESTIMATES
!        ARE TO BE COMPUTED.
!     REAL PHAS(NF)
!        THE ARRAY IN WHICH THE PHASE OF THE FILTER IS RETURNED.
!     REAL PHI(IAR)
!        THE VECTOR CONTAINING THE AUTOREGRESSIVE FILTER COEFFICIENTS.
!     REAL PI
!        THE VALUE OF PI.
!     REAL S
!        A VALUE USED TO COMPUTE THE GAIN FUNCTION ESTIMATES.
!     REAL V0, V1, V2
!        CONSTANTS USED FOR COMPUTING THE GAIN FUNCTION ESTIMATES.
!     REAL Z0, Z1, Z2
!        CONSTANTS USED FOR COMPUTING THE GAIN FUNCTION ESTIMATES.
!
      call getpi(pi)
!
!     COMPUTE GAIN FUNCTION ESTIMATES AND THEIR CONFIDENCE LIMITS.
!
      do 30 i = 1, nf
         if (freq(i).eq.0.0e0) then
            arg = 0.0e0
            c = 1.0e0
            s = 0.0e0
         else if (freq(i).eq.0.25e0) then
            arg = pi/2.0e0
            c = 0.0e0
            s = 1.0e0
         else if (freq(i).eq.0.5e0) then
            arg = pi
            c = -1.0e0
            s = 0.0e0
         else
            arg = 2.0e0 * pi * freq(i)
            c = cos(arg)
            s = sin(arg)
         end if
         v0 = 0.0e0
         v1 = 0.0e0
         z0 = 0.0e0
         z1 = 0.0e0
!
         jj = iar + 1
!
         do 20 j = 1, iar
            jj = jj -1
!
            v2 = c * v1 - v0 - phi(jj)
            v0 = v1
            v1 = v2
!
            z2 = s * z1 - z0 - phi(jj)
            z0 = z1
            z1 = z2
   20    continue
!
         v2 = delta * (1.0e0 + (v1 * c - v0))
!
         z2 = delta * z1 * s
!
         gain(i) = sqrt(v2*v2 + z2*z2)
!
         phas(i) = -0.5e0 * pi
         if (z2.ne.0.0e0 .and. v2.ne.0.0e0) phas(i) = atan2(z2, v2)
!
   30 continue
!
      return
      end
!XUAS
      subroutine xuas(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE AUTOREGRESSIVE SPECTRUM ANALYSIS ROUTINES
!
!     SERIES Y IS THE FIRST 50 VALUES OF THE SERIES LISTED ON PAGE
!     318 OF JENKINS AND WATTS.  THE SPECTRUM OF THIS SERIES IS SHOWN
!     FOR VARIOUS BANDWIDTH ON PAGE 270 OF JENKINS AND WATTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
      real(kind=wp) :: fmax,fmin,ymiss
     integer&
     &   i,iar,iprt,lacov,lag,lagmax,lds,lyfft,nf,nprt,ny
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   acov(101),freq(300),phi(101),spca(101),spcf(101),y(150),&
     &   yfft(400)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACFS,IPRINT,SETRV,UAS,UASF,UASFS,UASS,UASV,UASVS
!
!  INTRINSIC FUNCTIONS
      intrinsic abs
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(101)
!        THE AUTOCOVARIANCE VECTOR.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCIES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(300)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE MODEL TO BE USED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAG, LAGMAX
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCOVARIANCE BEING COMPUTED AND THE MAXIMUM LAG TO BE USED,
!        RESPECTIVELY.
!     INTEGER LDS
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NY
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     REAL PHI(101)
!        THE VECTOR OF THE ORDER IAR AUTOREGRESSIVE MODEL COEFFICIENTS.
!     REAL SPCA(101)
!        THE ARRAYS IN WHICH THE AUTOREGRESSIVE SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     REAL SPCF(101)
!        THE ARRAYS IN WHICH THE FOURIER SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     REAL Y(150)
!         THE ARRAY CONTAINING THE TIME SERIES FROM JENKINS AND WATTS.
!     REAL YFFT(400)
!        THE VECTOR OF THE OBSERVED TIME SERIES TO BE ANALYZED USING
!        THE FFT.
!     REAL YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!
!
     data   y(  1), y(  2), y(  3), y(  4), y(  5), y(  6)&
     &    /-0.88_wp, -0.12_wp, -0.89_wp, -1.38_wp, -0.07_wp,  1.03_wp/
     data   y(  7), y(  8), y(  9), y( 10), y( 11), y( 12)&
     &    / 2.14_wp,  0.35_wp, -1.10_wp, -1.78_wp, -2.76_wp, -1.77_wp/
     data   y( 13), y( 14), y( 15), y( 16), y( 17), y( 18)&
     &    / 0.98_wp,  1.00_wp, -0.70_wp, -1.01_wp, -1.30_wp, -0.85_wp/
     data   y( 19), y( 20), y( 21), y( 22), y( 23), y( 24)&
     &    /-0.46_wp,  1.63_wp,  0.06_wp, -0.17_wp, -1.01_wp, -1.04_wp/
     data   y( 25), y( 26), y( 27), y( 28), y( 29), y( 30)&
     &    /-0.66_wp, -1.12_wp, -0.51_wp, -0.71_wp, -0.20_wp, -0.13_wp/
     data   y( 31), y( 32), y( 33), y( 34), y( 35), y( 36)&
     &    / 0.14_wp,  1.59_wp, -0.76_wp, -1.08_wp, -1.77_wp, -1.20_wp/
     data   y( 37), y( 38), y( 39), y( 40), y( 41), y( 42)&
     &    / 0.45_wp, -0.07_wp, -0.63_wp, -0.35_wp, -0.87_wp, -0.62_wp/
     data   y( 43), y( 44), y( 45), y( 46), y( 47), y( 48)&
     &    / 0.28_wp,  1.90_wp,  2.14_wp,  1.05_wp,  0.31_wp,  1.07_wp/
     data   y( 49), y( 50)&
     &    / 2.67_wp,  2.44_wp/
!
!
      call iprint(iprt)
!
!     CHECK ERROR HANDLING
!
!        TEST 1  -  MISCELANEOUS ERROR CHECKING
!
      write (iprt, 2000)
      ymiss = 1.16_wp
      lagmax = -1
      ny = -10
      lacov = 101
      lag = -2
      iar = -2
      lyfft = -11
      nf = -5
      fmin = 0.5_wp
      fmax = 0.0_wp
      nprt = -1
      lds = 0
      write(iprt, 1001)
      call uas(y, ny)
      write (iprt, 1002) ierr
      write(iprt, 1003)
     call uass(y, ny, iar, phi, lagmax, lag, nf,&
     &   fmin, fmax, nprt,spca, spcf, freq, lds)
      write (iprt, 1002) ierr
      write(iprt, 1019)
      call uasf (yfft, ny, lyfft, lds)
      write (iprt, 1002) ierr
      write(iprt, 1020)
     call uasfs(yfft, ny, lyfft, lds, iar, phi, lagmax, lag, nf,&
     &   fmin, fmax, nprt, spca, spcf, freq)
      write (iprt, 1002) ierr
      write (iprt, 1007)
      call uasv(acov, lagmax, ny)
      write (iprt, 1002) ierr
      write (iprt, 1008)
     call uasvs(acov, lagmax, y, ny, iar, phi, lag, nf,&
     &   fmin, fmax, nprt, spca, spcf, freq, lds)
      write (iprt, 1002) ierr
!
!        TEST 2  -  MISCELANEOUS ERROR CHECKING (CONTINUED)
!
      write (iprt, 2010)
      ymiss = 1.16_wp
      ny = 50
      lagmax = 50
      lag = 101
      iar = 101
      call setrv(phi, iar, 2.0_wp)
      call setrv(acov, lagmax+1, 2.0_wp)
      acov(1) = 1.0_wp
      lyfft = -11
      nf = 51
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 5
      lds = 0
      write(iprt, 1003)
     call uass(y, ny, iar, phi, lagmax, lag, nf,&
     &   fmin, fmax, nprt, spca, spcf, freq, lds)
      write (iprt, 1002) ierr
      write(iprt, 1019)
      call uasf (yfft, ny, lyfft, lds)
      write (iprt, 1002) ierr
      write(iprt, 1020)
     call uasfs(yfft, ny, lyfft, lds, iar, phi, lagmax, lag, nf,&
     &   fmin, fmax, nprt, spca, spcf, freq)
      write (iprt, 1002) ierr
      write (iprt, 1007)
      call uasv(acov, lagmax, ny)
      write (iprt, 1002) ierr
      write (iprt, 1008)
     call uasvs(acov, lagmax, y, ny, iar, phi, lag, nf,&
     &   fmin, fmax, nprt, spca, spcf, freq, lds)
      write (iprt, 1002) ierr
!
!        TEST 3  -  LDS TOO SMALL
!
      write (iprt, 2030)
      ymiss = 1.16_wp
      ny = 50
      lagmax = 49
      lyfft = 400
      lag = 16
      iar = 2
      phi(1) = 1.0_wp
      phi(2) = -0.5_wp
      call acfs (y, ny, lagmax, lacov, acov, iar, phi, 0, 700)
      nf = 51
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 3
      lds = 0
      write(iprt, 1003)
     call uass(y, ny, iar, phi, lagmax, lag, nf,&
     &   fmin, fmax, nprt, spca, spcf, freq, lds)
      write (iprt, 1002) ierr
      write(iprt, 1019)
      call uasf (yfft, ny, lyfft, lds)
      write (iprt, 1002) ierr
      write(iprt, 1020)
     call uasfs(yfft, ny, lyfft, lds, iar, phi, lagmax, lag, nf,&
     &   fmin, fmax, nprt, spca, spcf, freq)
      write (iprt, 1002) ierr
      write (iprt, 1008)
     call uasvs(acov, lagmax, y, ny, iar, phi, lag, nf,&
     &   fmin, fmax, nprt, spca, spcf, freq, lds)
      write (iprt, 1002) ierr
!
!     CHECK RESULTS FROM VALID CALL
!
      ymiss = 1.16_wp
      ny = 50
      lagmax = 49
      lyfft = 400
      lag = 16
      iar = 2
      phi(1) = 1.0_wp
      phi(2) = -0.5_wp
      nf = 51
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 2
      lds = 700
!
!     TEST OF UAS
!
      write(iprt, 2020)
      write(iprt, 1001)
      call uas(y, ny)
      write (iprt, 1002) ierr
!
!     TEST OF UASS
!
      write(iprt, 2020)
      write(iprt, 1003)
     call uass(y, ny, iar, phi, lagmax, lag, nf,&
     &   fmin, fmax, nprt, spca, spcf, freq, lds)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM UASS
!
      write (iprt, 1004) (freq(i), spca(i), spcf(i), i=1,nf)
      write (iprt, 1005) iar, lag
      write (iprt, 1006) (phi(i), i=1,abs(iar))
!
!     TEST OF UASF
!
      write(iprt, 2020)
      write(iprt, 1019)
      call scopy(ny, y, 1, yfft, 1)
      call uasf (yfft, ny, lyfft, lds)
      write (iprt, 1002) ierr
!
!     TEST OF UASFS
!
      write(iprt, 2020)
      write(iprt, 1020)
      call scopy(ny, y, 1, yfft, 1)
     call uasfs(yfft, ny, lyfft, lds, iar, phi, lagmax, lag, nf,&
     &   fmin, fmax, nprt, spca, spcf, freq)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM UASFS
!
      write (iprt, 1004) (freq(i), spca(i), spcf(i), i=1,nf)
      write (iprt, 1005) iar, lag
      write (iprt, 1006) (phi(i), i=1,abs(iar))
!
!     TEST OF UASV
!
      write(iprt, 2020)
      write (iprt, 1007)
      call uasv(acov, lagmax, ny)
      write (iprt, 1002) ierr
!
!     TEST OF UASVS
!
      write(iprt, 2020)
      write (iprt, 1008)
     call uasvs(acov, lagmax, y, ny, iar, phi, lag, nf,&
     &   fmin, fmax, nprt, spca, spcf, freq, lds)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM UASVS
!
      write (iprt, 1004) (freq(i), spca(i), spcf(i), i=1,nf)
      write (iprt, 1005) iar, lag
      write (iprt, 1006) (phi(i), i=1,abs(iar))
!
!     MINIMUM PROBLEM SIZE
!
      ymiss = 1.16_wp
      ny = 17
      lagmax = 1
      lyfft = 400
      lag = 1
      iar = -1
      phi(1) = 1.0_wp
      phi(2) = -0.5_wp
      nf = 1
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 2
      lds = ldstak
!
!     TEST OF UAS
!
      write (iprt, 2060)
      write(iprt, 1001)
      call uas(y, ny)
      write (iprt, 1002) ierr
!
!     TEST OF UASS
!
      write(iprt, 2060)
      write(iprt, 1003)
     call uass(y, ny, iar, phi, lagmax, lag, nf,&
     &   fmin, fmax, nprt, spca, spcf, freq, lds)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM UASS
!
      write (iprt, 1004) (freq(i), spca(i), spcf(i), i=1,nf)
      write (iprt, 1005) iar, lag
      write (iprt, 1006) (phi(i), i=1,abs(iar))
!
!     CHECK HANDLING OF FMIN AND FMAX, AND LAG.EQ.0 AND IAR.EQ.0
!
      ny = 50
      lagmax = 49
      lyfft = 400
      lag = 0
      iar = 0
      phi(1) = 1.0_wp
      phi(2) = -0.5_wp
      nf = 51
      fmin = 0.45_wp
      fmax = 0.5_wp
      nprt = 2
!
!     TEST OF UASS
!
      write(iprt, 2070)
      write(iprt, 1003)
     call uass(y, ny, iar, phi, lagmax, lag, nf,&
     &   fmin, fmax, nprt, spca, spcf, freq, lds)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM UASS
!
      write (iprt, 1004) (freq(i), spca(i), spcf(i), i=1,nf)
      write (iprt, 1005) iar, lag
      write (iprt, 1006) (phi(i), i=1,abs(iar))
!
!     WHITE NOISE SPECTRUM
!
      ymiss = 1.16_wp
      call setrv(yfft, ny, 0.0_wp)
      ny = 50
      lagmax = 49
      lyfft = 400
      lag = 16
      iar = 2
      phi(1) = 1.0_wp
      phi(2) = -0.5_wp
      nf = 51
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 2
!
!     TEST OF UASS
!
      write(iprt, 2080)
      write(iprt, 1003)
     call uass(yfft, ny, iar, phi, lagmax, lag, nf,&
     &   fmin, fmax, nprt, spca, spcf, freq, lds)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM UASS
!
      write (iprt, 1004) (freq(i), spca(i), spcf(i), i=1,nf)
      write (iprt, 1005) iar, lag
      write (iprt, 1006) (phi(i), i=1,abs(iar))
!
!     SUPPRESS OUTPUT AND
!     CHECK HANDLING OF LAG .LT.0 AND IAR .LT. 0
!
      ny = 50
      lagmax = 49
      lyfft = 400
      lag = 0
      iar = 0
      phi(1) = 1.0_wp
      phi(2) = -0.5_wp
      nf = 51
      fmin = 0.45_wp
      fmax = 0.5_wp
      nprt = 0
!
!     TEST OF UASS
!
      write(iprt, 2090)
      write(iprt, 1003)
     call uass(y, ny, iar, phi, lagmax, lag, nf,&
     &   fmin, fmax, nprt, spca, spcf, freq, lds)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM UASS
!
      write (iprt, 1004) (freq(i), spca(i), spcf(i), i=1,nf)
      write (iprt, 1005) iar, lag
      write (iprt, 1006) (phi(i), i=1,abs(iar))
!
      return
!
!     FORMAT STATEMENTS
!
 1001 format (12h test of uas)
 1002 format (/8h ierr is, i5/)
 1003 format (13h test of uass)
 1004 format (3(1x, e16.8))
 1005 format (/7h iar = , i5/7h lag = , i5)
 1006 format (/7h phi = , (1x, 5e21.8))
 1007 format (13h test of uasv)
 1008 format (14h test of uasvs)
 1019 format (13h test of uasf)
 1020 format (14h test of uasfs)
 2000 format (32h1check error handling  -  test 1)
 2010 format (32h1check error handling  -  test 2)
 2020 format (14h1valid problem)
 2030 format (14h1lds too small)
 2060 format (21h1minimum problem size)
2070 format (&
     &   59h1check handling of fmin and fmax, lag and iar equal to zero)
 2080 format (21h1white noise spectrum)
 2090 format (44h1suppress output, lag and iar less than zero)
      end
!MVPL
      subroutine mvpl(ym, n, m, iym, ns, ilog)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MULTIPLE Y-AXIS VALUES (LOG PLOT OPTION).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ilog,iym,m,n,ns
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ibar,iprt,irlin,ischck,isize,lisym
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'M',       'V',       'P',       'L',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      multi = .true.
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 1.0e0
      xinc = 1.0e0
      ischck = 2
      isize = -1
      miss = .false.
      lisym = 1
      irlin = -1
      ibar = 0
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ym, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL MVPL (YM, N, M, IYM, NS, ILOG)')
      end
!ERSGE
     subroutine ersge(nmsub, nmvar, val, valmn, msgtyp, head, error,&
     &   nmmin)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THE ROUTINE CHECKS WHETHER THE VALUE   VAL   IS GREATER THAN OR
!     EQUAL TO   VALMN   , AND PRINTS A DIAGNOSTIC IF IT IS NOT.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   val,valmn
     integer&
     &   msgtyp
     logical&
     &   error,head
!
!  ARRAY ARGUMENTS
     character&
     &   nmmin(8)*1,nmsub(6)*1,nmvar(8)*1
!
!  LOCAL SCALARS
     integer&
     &   i,iprt
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
!        PRINTED, WHERE IF ERROR IS .TRUE. AND
!        MSGTYP = 1 THE INPUT VALUE WAS TOO SMALL BASED
!                   ON LIMITS IMPOSED BY STARPAC
!        MSGTYP = 2 THE INPUT VALUE WAS TOO SMALL BASED ON
!                   LIMITS BASED ON OTHER INPUT ARGUMENTS.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE ARGUMENTS NAME.
!     REAL VAL
!        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
!     REAL VALMN
!        THE MINIMUM VALUE THE ARGUMENT CAN VALIDLY HAVE.
!
      error = .false.
!
      if (val .ge. valmn) return
!
      error = .true.
      call iprint (iprt)
      call ehdr(nmsub, head)
!
      write (iprt, 1000) (nmvar(i),i=1,6), val
!
      go to (10, 20), msgtyp
!
!     PRINT MESSAGE FOR VALUE TOO SMALL BASED ON LIMITS IMPOSED
!     BY STARPAC.
!
   10 write (iprt, 1010) (nmvar(i),i=1,6), valmn
      return
!
   20 write (iprt, 1020) (nmvar(i),i=1,6), (nmmin(i),i=1,8)
      return
!
!     FORMAT STATEMENTS
!
 1000 format (/20h the input value of , 6a1, 4h is , g15.8, '.')
1010 format(&
    &   27h the value of the argument , 6a1,&
     &   34h must be greater than or equal to , g21.14, '.')
1020 format(&
    &   27h the value of the argument , 6a1,&
     &   34h must be greater than or equal to , 8a1, '.')
!
      end
!XAOV1
      subroutine xaov1(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE EXCERCISES THE ONEWAY FAMILY ROUTINES.
!
!     WRITTEN BY -
!        LINDA MITCHELL
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fi
     integer&
     &   i,igstat,iprt,ldsmin,n,ng
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   gstat(10,4),tag(20),y(20),z(10),ztag(10)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AOV1,AOV1S,AOV1XP,IPRINT,LDSCMP,MSGX,SETRV
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (APHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FI
!        FLOAT OF INDEX I
!     REAL GSTAT(10,4)
!        THE GROUP STATISTICS.  COLUMNS CORRESPOND TO THE TAG
!        VALUE, SAMPLE SIZE, GROUP MEAN, AND GROUP STANDARD DEVIATION.
!     INTEGER I
!        INDEX VARIABLE
!     INTEGER IERR
!        COMMON FLAG INDICATING WHETHER OR NOT THERE WERE ANY ERRORS
!     INTEGER IGSTAT
!        THE FIRST DIMENSION OF GSTAT.
!     INTEGER IPRT
!        THE OUTPUT LOGICAL UNIT NUMBER
!     INTEGER LDSMIN
!        THE SMALLEST ACCEPTABLE SIZE OF THE COMMON CSTAK
!     INTEGER LDSTAK
!        THE SIZE OF THE COMMON CSTAK
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NG
!        THE NUMBER OF DIFFERENT GROUPS
!     REAL TAG(20)
!        THE TAG VALUES FOR EACH OBSERVATION
!     REAL Y(20)
!        THE VECTOR OF OBSERVATIONS
!     REAL Z(10)
!        TEST VECTOR
!     REAL ZTAG(10)
!        TEST TAG VECTOR
!
     data   y( 1),   y( 2),   y( 3),   y( 4),   y( 5)&
     &   /    61.0e0,    61.0e0,    67.0e0,    67.0e0,    64.0e0/
     data   y( 6),   y( 7),   y( 8),   y( 9),   y(10)&
     &   /    78.0e0,    71.0e0,    75.0e0,    72.0e0,    74.0e0/
     data   y(11),   y(12),   y(13),   y(14),   y(15)&
     &   /    83.0e0,    81.0e0,    76.0e0,    78.0e0,    79.0e0/
     data   y(16),   y(17)&
     &   /    72.0e0,   72.0e0/
!
     data tag( 1), tag( 2), tag( 3), tag( 4), tag( 5)&
     &   /    11.5e0,    11.5e0,    11.5e0,    11.5e0,    11.5e0/
     data tag( 6), tag( 7), tag( 8), tag( 9), tag(10)&
     &   /    12.0e0,    12.0e0,    12.0e0,    12.0e0,    12.0e0/
     data tag(11), tag(12), tag(13), tag(14), tag(15)&
     &   /    11.0e0,    11.0e0,    11.0e0,    11.0e0,    11.0e0/
     data tag(16), tag(17)&
     &   /   -11.0e0,   11.0e0/
!
      call iprint(iprt)
!
!     SET VARIOUS DIMENSIONS AND PROGRAM VARIABLES
!
      n = 17
      igstat = 10
!
!**** TEST WITH CORRECT CALL STATEMENTS ****
!
      write (iprt,1060)
!
!     TEST AOV1
!
      write (iprt,1000)
      call aov1(y, tag, n, ldstak)
      call msgx(0, iprt)
      write (iprt,1010)
      write (iprt,1020) (tag(i),i=1,n)
!
!     TEST OF AOV1S
!
!     PRINTOUT NOT SUPRESSED
!
      write (iprt,1040)
      write (iprt,1030)
      call aov1s(y, tag, n, ldstak, 1, gstat, igstat, ng)
      call msgx(0, iprt)
!
!     PRINT STORAGE AND ZERO VECTORS BEFORE USING AGAIN
!
      call aov1xp(gstat, igstat, ng)
!
!     PRINTOUT SUPRESSED
!
      write (iprt,1050)
      call aov1s(y, tag, n, ldstak, 0, gstat, igstat, ng)
      call msgx(0, iprt)
!
!     PRINT STORAGE AND ZERO VECTORS BEFORE USING AGAIN
!
      call aov1xp(gstat, igstat, ng)
!
!**** NUMBER OF OBSERVATIONS LESS THAN 2 ****
!
      write (iprt,1090)
      call aov1(y, tag, 1, ldstak)
      call msgx(1, iprt)
!
      call aov1s(y, tag, -14, ldstak, 0, gstat, igstat, ng)
      call msgx(1, iprt)
!
!**** ALL OBSERVATIONS THE SAME VALUE ****
!
      write (iprt,1100)
      write (iprt,1000)
      call setrv(z, 10, 0.0e0)
      call aov1(z, tag, 10, ldstak)
      call msgx(0, iprt)
!
      call setrv(z, 10, 2.0e0)
      write (iprt,1100)
      write (iprt,1030)
      call aov1s(z, tag, 10, ldstak, 1, gstat, igstat, ng)
      call msgx(0, iprt)
!
!**** TEST WORK AREA SIZE HANDLING ****
!
      call ldscmp(11, 0, 33, 0, 0, 0, 'S', 40, ldsmin)
      write (iprt,1070)
      write (iprt,1000)
      call aov1(y, tag, n, 1)
      call msgx(1, iprt)
      write (iprt,1070)
      write (iprt,1000)
      call aov1(y, tag, n, ldsmin-1)
      call msgx(1, iprt)
      write (iprt,1010)
      write (iprt,1020) (tag(i),i=1,n)
      write (iprt,1080)
      write (iprt,1000)
      call aov1(y, tag, n, ldsmin)
      call msgx(0, iprt)
!
      call ldscmp(11, 0, 33, 0, 0, 0, 'S', 28, ldsmin)
      write (iprt,1070)
      write (iprt,1030)
      call aov1s(y, tag, n, 1, 0, gstat, igstat, ng)
      call msgx(1, iprt)
      write (iprt,1070)
      write (iprt,1030)
      call aov1s(y, tag, n, ldsmin-1, 0, gstat, igstat, ng)
      call msgx(1, iprt)
      write (iprt,1010)
      write (iprt,1020) (tag(i),i=1,n)
      write (iprt,1080)
      write (iprt,1030)
      call aov1s(y, tag, n, ldsmin, 1, gstat, igstat, ng)
      call msgx(0, iprt)
!
!**** SAME NUMBER OF GROUPS AS NON-ZERO TAGS ****
!
      write (iprt,1120)
      do 20 i=1,10
         fi = i
         ztag(i) = fi
         z(i) = 13.0e0 - fi
   20 continue
      call aov1(z, ztag, 10, ldstak)
      call msgx(1, iprt)
      call aov1s(z, ztag, 10, ldstak, 1, gstat, igstat, ng)
      call msgx(1, iprt)
!
!**** LESS THAN 2 DIFFERENT TAG GROUPS ****
!
      write (iprt,1130)
      call setrv(ztag, 10, 1.0e0)
      call aov1(z, ztag, 10, ldstak)
      call msgx(1, iprt)
      call aov1s(z, ztag, 10, ldstak, 1, gstat, igstat, ng)
      call msgx(1, iprt)
!
!**** LESS THAN 2 TAGS ****
!
      call setrv(ztag, 9, 0.0e0)
      write (iprt,1140)
      call aov1(z, ztag, 10, ldstak)
      call msgx(1, iprt)
      call aov1s(z, ztag, 10, ldstak, 1, gstat, igstat, ng)
      call msgx(1, iprt)
!
!**** INCORRECT DIMENSION OF GSTAT ****
!
      write (iprt,1150)
      call aov1s(y, tag, n, ldstak, 1, gstat, 2, ng)
      call msgx(1, iprt)
!
!**** ALL OBSERVATIONS WITHIN A GROUP SAME VALUE ****
!
      z(1) = 53.0e0
      ztag(1) = 1.0e0
      z(2) = 62.0e0
      ztag(2) = 3.0e0
      z(3) = 53.0e0
      ztag(3) = 1.0e0
      z(4) = 71.0e0
      ztag(4) = 4.0e0
      z(5) = 89.0e0
      ztag(5) = 2.0e0
      z(6) = 71.0e0
      ztag(6) = 4.0e0
      z(7) = 89.0e0
      ztag(7) = 2.0e0
      z(8) = 62.0e0
      ztag(8) = 3.0e0
      z(9) = 71.0e0
      ztag(9) = 4.0e0
      z(10) = 62.0e0
      ztag(10) = 3.0e0
      write (iprt,1160)
      call aov1(z, ztag, 10, ldstak)
      call msgx(0, iprt)
!
!**** 2 TAGS ****
!
      write (iprt,1170)
      call aov1(z, ztag, 3, ldstak)
      call msgx(0, iprt)
!
!**** ALL GROUPS(EXCEPT FOR 1) WITH 1 OBSERVATION ****
!
      write (iprt,1180)
      call aov1(z, ztag, 5, ldstak)
      call msgx(0, iprt)
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format(' TEST OF AOV1 ')
 1010 format(' CHECK TO SEE IF TAGS HAVE BEEN CHANGED')
 1020 format(4f12.6)
 1030 format(' TEST OF AOV1S ')
 1040 format('1PRINTOUT NOT SUPRESSED.')
 1050 format(' PRINTOUT SUPRESSED.')
 1060 format('1****TEST ROUTINES WITH CORRECT CALL****')
 1070 format('1****TEST WITH INSUFFICIENT WORK AREA****')
 1080 format('1****TEST WITH EXACTLY THE RIGHT AMOUNT OF WORK AREA****')
 1090 format('1****NUMBER OF OBSERVATIONS LESS THAN 2****')
 1100 format('1****ALL OBSERVATIONS WITH SAME VALUE****')
 1120 format('1****SAME NUMBER OF GROUPS AS NON-ZERO TAGS****')
 1130 format(' ****LESS THAN 2 DIFFERENT TAG GROUPS****')
 1140 format(' ****LESS THAN 2 TAGS****')
 1150 format('1****INCORRECT DIMENSION OF GSTAT****')
 1160 format('1****ALL OBSERVATIONS WITHIN A GROUP SAME VALUE****')
 1170 format('1****TEST WITH 2 TAGS****')
 1180 format('1****ALL GROUPS EXCEPT FOR 1 WITH 1 OBSERVATION ****')
      end
!MDL4
      subroutine mdl4 (par, npar, xm, n, m, ixm, pv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     MODEL ROUTINE FOR STEP SIZE AND DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),pv(n),xm(ixm,m)
!
!  LOCAL SCALARS
     integer&
     &   i
!
!  INTRINSIC FUNCTIONS
      intrinsic exp
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN COEFFICIENTS IN THE MODEL.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        COEFFICIENTS ARE STORED.
!     REAL PV(N)
!        THE PREDICTED VALUES FROM THE FIT.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      do 10 i = 1, n
         pv(i) = par(1) + par(3)*exp(-((xm(i,1)-par(2))**2)/par(4))
   10 continue
!
      return
!
      end
!SLFLT
      subroutine slflt (y, n, k, h, yf, nyf)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PERFORMS A SYMMETRIC FILTERING OPERATION
!     ON AN INPUT SERIES Y, RETURNING THE FILTERED SERIES IN YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   k,n,nyf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   h(*),y(*),yf(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iprt
     logical&
     &   err01,err02,err03,err04,head
!
!  LOCAL ARRAYS
     character&
     &   lh(8)*1,lk(8)*1,ln(8)*1,lone(8)*1,nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,EISII,ERIODD,ERSLF,FLTSL,IPRINT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03, ERR04
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     REAL H(K)
!        THE ARRAY OF SYMMETRIC LINEAR FILTER COEFFICIENTS.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS.
!     CHARACTER*1 LH(8), LK(8), LN(8), LONE(8)
!        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES K AND N.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'S',       'L',       'F',       'L',       'T',       ' '/
     data&
    &  lh(1), lh(2), lh(3), lh(4), lh(5), lh(6), lh(7), lh(8)&
     & /  'H',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lk(1), lk(2), lk(3), lk(4), lk(5), lk(6), lk(7), lk(8)&
     & /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lone(1), lone(2), lone(3), lone(4), lone(5), lone(6), lone(7),&
     &  lone(8) /'O', 'N', 'E', ' ', ' ', ' ', ' ', ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 3, 1, head, err01, ln)
!
      call eisii(nmsub, lk, k, 1, n, 1, head, err02, lone, ln)
!
      call eriodd(nmsub, lk, k, 1, head, err03)
!
      if (err01 .or. err02 .or. err03) go to 10
!
      call erslf(nmsub, lh, k, h, head, err04)
!
      if (.not. err04) go to 20
!
   10 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   20 continue
!
      call fltsl (y, n, k, h, yf, nyf)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   39h       call slflt (y, n, k, h, yf, nyf))
      end
!CDFT
      real(kind=wp) function cdft(x, idf)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE CUMULATIVE DISTRIBUTION
!              FUNCTION VALUE FOR STUDENT"S T DISTRIBUTION
!              WITH INTEGER DEGREES OF FREEDOM PARAMETER = IDF.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X.
!              THE PROBABILITY DENSITY FUNCTION IS GIVEN
!              IN THE REFERENCES BELOW.
!     INPUT  ARGUMENTS--X      = THE VALUE AT
!                                WHICH THE CUMULATIVE DISTRIBUTION
!                                FUNCTION IS TO BE EVALUATED.
!                                X SHOULD BE NON-NEGATIVE.
!                     --IDF     = THE INTEGER NUMBER OF DEGREES
!                                OF FREEDOM.
!                                IDF SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--CDF    = THE SINGLE PRECISION CUMULATIVE
!                                DISTRIBUTION FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION CUMULATIVE DISTRIBUTION
!             FUNCTION VALUE CDF FOR THE STUDENT"S T DISTRIBUTION
!             WITH DEGREES OF FREEDOM PARAMETER = IDF.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--IDF SHOULD BE A POSITIVE INTEGER VARIABLE.
!     OTHER DATAPAC   SUBROUTINES NEEDED--NORCDFC     LANGUAGE--ANSI FOR
!     REFERENCES--NATIONAL BUREAU OF STANDARDS APPLIED MATHMATICS
!                 SERIES 55, 1964, PAGE 948, FORMULAE 26.7.3 AND 26.7.4.
!               --JOHNSON AND KOTZ, CONTIIDFOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGES 94-129.
!               --FEDERIGHI, EXTENDED TABLES OF THE
!                 PERCENTAGE POINTS OF STUDENT"S
!                 T-DISTRIBUTION, JOURNAL OF THE
!                 AMERICAN STATISTICAL ASSOCIATION,
!                 1959, PAGES 683-688.
!               --OWEN, HANDBOOK OF STATISTICAL TABLES,
!                 1962, PAGES 27-30.
!               --PEARSON AND HARTLEY, BIOMETRIKA TABLES
!                 FOR STATISTICIANS, VOLUME 1, 1954,
!                 PAGES 132-134.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --MAY       1974.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --OCTOBER   1976.
!
!---------------------------------------------------------------------
!
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   x
     integer&
     &   idf
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   b11,b21,b22,b23,b24,b25,b31,b32,b33,b34,b35,b36,b37,c,csq,d1,&
    &   d11,d3,d5,d7,d9,dconst,df,fpspm,pi,sd,sum,term,term1,term2,&
     &   term3,z
     integer&
     &   i,idfcut,ievodd,imax,imin,iprt
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   CDFNML,R1MACH
!      EXTERNAL CDFNML,R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL GETPI,IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,atan,exp,log,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL B11, B21, B22, B23, B24, B25
!        CONSTANTS USED IN THE COMPUTATIONS.
!     REAL B31, B32, B33, B34, B35, B36, B37
!        CONSTANTS USED IN THE COMPUTATIONS.
!     REAL C
!        ...
!     REAL CSQ
!        ...
!     REAL DCONST
!        ...
!     REAL DF
!        THE DEGREES OF FREEDOM.
!     REAL D1, D11, D3, D5, D7, D9
!        CONSTANTS USED IN THE COMPUTATIONS.
!     REAL FPSPM
!        THE FLOATING POINT SMALLEST POSITIVE MAGNITUDE.
!     INTEGER I
!        AN INDEX.
!     INTEGER IDF
!        THE DEGREES OF FREEDOM.
!     INTEGER IDFCUT
!        ...
!     INTEGER IEVODD
!        ...
!     INTEGER IMAX
!        ...
!     INTEGER IMIN
!        ...
!     INTEGER IPRT
!        THE PRINT UNIT.
!     REAL PI
!        PI.
!     REAL SD
!        ...
!     REAL SUM
!        ...
!     REAL TERM, TERM1, TERM2, TERM3
!        ...
!     REAL X
!        THE T STATISTIC.
!     REAL Z
!        ...
!
      data idfcut /1000/
      data dconst /0.3989422804e0/
      data b11 /0.25e0/
      data b21 /96.0e0/
!     DATA B21 /0.01041666666667E0/
      data b22, b23, b24, b25 /3.0e0,-7.0e0,-5.0e0,-3.0e0/
      data b31 /0.00260416666667e0/
     data b32, b33, b34, b35, b36, b37&
     &    /1.0e0,-11.0e0,14.0e0,6.0e0,-3.0e0,-15.0e0/
!
!
      call getpi(pi)
      call iprint(iprt)
      fpspm = r1mach(1)
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      if (idf.le.0) go to 10
      go to 20
   10 write (iprt, 1000)
      write (iprt, 1010) idf
      cdft = 0.0e0
      return
   20 continue
!
!-----START POINT-----------------------------------------------------
!
      df = idf
!
!     IF IDF IS 3 THROUGH 9 AND X IS MORE THAN 3000
!     STANDARD DEVIATIONS BELOW THE MEAN,
!     SET CDFT = 0.0E0 AND RETURN.
!     IF IDF IS 10 OR LARGER AND X IS MORE THAN 150
!     STANDARD DEVIATIONS BELOW THE MEAN,
!     SET CDFT = 0.0E0 AND RETURN.
!     IF IDF IS 3 THROUGH 9 AND X IS MORE THAN 3000
!     STANDARD DEVIATIONS ABOVE THE MEAN,
!     SET CDFT = 1.0E0 AND RETURN.
!     IF IDF IS 10 OR LARGER AND X IS MORE THAN 150
!     STANDARD DEVIATIONS ABOVE THE MEAN,
!     SET CDFT = 1.0E0 AND RETURN.
!
      if (idf.le.2) go to 50
      sd = sqrt(df/(df-2.0e0))
      z = x/sd
      if (idf.lt.10 .and. z.lt.(-3000.0e0)) go to 30
      if (idf.ge.10 .and. z.lt.(-150.0e0)) go to 30
      if (idf.lt.10 .and. z.gt.3000.0e0) go to 40
      if (idf.ge.10 .and. z.gt.150.0e0) go to 40
      go to 50
   30 cdft = 0.0e0
      return
   40 cdft = 1.0e0
      return
   50 continue
!
!     DISTINGUISH BETWEEN THE SMALL AND MODERATE
!     DEGREES OF FREEDOM CASE VERSUS THE
!     LARGE DEGREES OF FREEDOM CASE
!
      if (idf.lt.idfcut) go to 60
      go to 120
!
!     TREAT THE SMALL AND MODERATE DEGREES OF FREEDOM CASE
!     METHOD UTILIZED--EXACT FINITE SUM
!     (SEE AMS 55, PAGE 948, FORMULAE 26.7.3 AND 26.7.4).
!
   60 continue
      csq = df/(x*x+df)
      c = sqrt(csq)
      imax = idf - 2
      ievodd = idf - 2*(idf/2)
      if (ievodd.ne.0) then
         if (idf.eq.1) then
            sum = 0.0e0
         else
            sum = c
         end if
         term = c
         imin = 3
      else
         sum = 1.0e0
         term = 1.0e0
         imin = 2
      end if
!
      do 90 i=imin,imax,2
         if (term.ne.0.0e0) then
            if (log(term)+log((i-1.0e0)/i)+log(csq).ge.log(fpspm)) then
               term = term*((i-1.0e0)/i)*csq
               sum = sum + term
            else
               term = 0.0e0
            end if
         end if
   90 continue
!
      if (sum.eq.0.0e0 .or. x.eq.0.0e0) then
         sum = 0.0e0
      else
         if (log(sum)+log(abs(x))-0.5*log(x*x+df) .lt. log(fpspm)) then
            sum = 0.0e0
         else
            sum = sum*x/sqrt(x*x+df)
         end if
      end if
      if (ievodd.eq.0) go to 110
      sum = (2.0e0/pi)*(atan(x/sqrt(df))+sum)
  110 cdft = 0.5e0 + sum/2.0e0
      return
!
!     TREAT THE LARGE DEGREES OF FREEDOM CASE.
!     METHOD UTILIZED--TRUNCATED ASYMPTOTIC EXPANSION
!     (SEE JOHNSON AND KOTZ, VOLUME 2, PAGE 102, FORMULA 10?
!     SEE FEDERIGHI, PAGE 687).
!
  120 continue
      d1 = x
      d3 = x**3
      d5 = x**5
      d7 = x**7
      d9 = x**9
      d11 = x**11
      term1 = b11*(d3+d1)/df
!     TERM2 = B21*(B22*D7+B23*D5+B24*D3+B25*D1)/(DF**2)
      term2 = (b22*d7+b23*d5+b24*d3+b25*d1)/(df**2) / b21
      term3 = b31*(b32*d11+b33*d9+b34*d7+b35*d5+b36*d3+b37*d1)/(df**3)
      cdft = term1 + term2 + term3
      cdft = cdfnml(x) - (dconst*(exp(-x*x/2.0e0)))*cdft
      return
!
!     FORMAT STATEMENTS
!
1000 format (' ', 49h***** fatal error--the second input argument to t,&
     &   42hhe cdft   subroutine is non-positive *****)
 1010 format (' ', 35h***** the value of the argument is , i8, 6h *****)
      end
!ACVFM
     subroutine acvfm (y, ymiss, n, ymean, acov, lagmax,&
     &   laglst, nlppa, lacov)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE AUTOCOVARIANCES WHEN MISSING DATA ARE
!     INVOLVED.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: ymean,ymiss
     integer&
     &   lacov,laglst,lagmax,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(*),y(*)
     integer&
     &   nlppa(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   dotxy,dotyy,fplm
     integer&
     &   lag,ndotxy,ndotyy,nused
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
     integer&
     &   lstlag
!       EXTERNAL R1MACH,LSTLAG
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL AMEANM,DOTCM
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV)
!        THE ARRAY IN WHICH THE AUTOCOVARIANCES ARE STORED
!     REAL DOTXY, DOTYY
!        THE DOT PRODUCT BETWEEN VECTORS (Y(I) - YMEAN)) AND
!        (Y(LAG) - YMEAN)), AND (Y(I) - YMEAN)) AND (Y(I) - YMEAN)),
!        RESPECTIVELY.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAG, LAGLST, LAGMAX
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCORRELATION BEING COMPUTED, THE NUMBER OF AUTOCORRELATIONS
!        COMPUTED BEFORE A MISSING AUTOCORRELATION, AND THE NUMBER OF
!        AUTOCORRELATIONS DESIRED, RESPECTIVELY.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NDOTXY, NDOTYY
!        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY AND
!        DOTYY, RESPECTIVELY.
!     INTEGER NLPPA(LACOV)
!        THE ARRAY CONTAINING THE NUMBERS OF LAGGED PRODUCT PAIRS
!        USED TO COMPUTE THE ACVF AT EACH LAG.
!     INTEGER NUSED
!        THE NUMBER OF ACTIVE OBSERVATIONS IN THE SERIES.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     REAL YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!
!
      fplm = r1mach(2)
!
!     COMPUTE ARITHMETIC MEAN, WITH MISSING VALUES TAKEN INTO ACCOUNT
!
      call ameanm (y, ymiss, n, nused, ymean)
!
!     COMPUTE THE VARIANCE OF THE SERIES Y
!
     call dotcm (y, ymean, ymiss, n, y, ymean, ymiss, n,&
     &   dotyy, ndotyy)
      nlppa(1) = ndotyy
      if (nlppa(1).eq.0) then
         laglst = 0
      else
         acov(1) = dotyy / ndotyy
!
!     COMPUTE AUTOCORRELATIONS, WITH MISSING VALUES TAKEN INTO ACCOUNT
!
         do 10 lag = 1, lagmax
           call dotcm (y, ymean, ymiss, n, y(lag+1), ymean,&
     &         ymiss, n - lag, dotxy, ndotxy)
            nlppa(lag + 1) = ndotxy
            acov(lag + 1) = fplm
            if (nlppa(lag + 1) .le. 0) go to 10
            acov(lag + 1) = dotxy * (n-lag) / (nlppa(lag + 1) * n)
   10    continue
!
!     FIND THE LAST AUTOCORRELATION TO BE COMPUTED BEFORE
!     ONE COULD NOT BE COMPUTED DUE TO MISSING DATA
!
         laglst = lstlag(nlppa, lagmax, lacov)
      end if
      return
      end
!XCCF
      subroutine xccf(lds,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE TIME SERIES CORRELATION SUBROUTINES
!
!     SERIES Y1 AND Y2 ARE LISTED AS SERIES X1 AND X2 ON PAGE OF 361 OF
!     JENKINS AND WATTS.  CCF FOR SERIES Y1 AND Y2 ARE PLOTTED ON PAGE 3
!     AND LISTED ON PAGE 420.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lds
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   cmiss,y1miss,y2miss,ymiss0
     integer&
    &   iccov,inlppc,iprt,itest,iym,iymfft,jccov,jnlppc,lagmax,&
     &   ldstak,lyfft,m,n,nlag,nprt,nyd
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   ccov(30,5,5),y1(100),y2(100),yfft1(150),yfft2(150),ym(150,5),&
     &   ymfft(150,5),ymmiss(5)
     integer&
     &   nlppc(30,5,5)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL CCF,CCFF,CCFFS,CCFM,CCFMS,CCFS,CCFXP,IPRINT,SETRA,
!     +   SETRV
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCOV(30,5,5)
!        THE CROSS COVARIANCE ARRAY.
!     REAL CMISS
!        THE MISSING VALUE CODE FOR THE RETURNED CCVF ESTIMATES
!        (VECTOR CCOV).
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER ITEST
!        THE NUMBER OF THE TEST BEING PERFORMED
!     INTEGER IYM, IYMFFT
!        THE FIRST DIMENSION OF THE ARRAYS YM AND YMFFT, RESPECTIVELY.
!     INTEGER JCCOV, JNLPPC
!        THE SECOND DIMENSIONS OF THE ARRAYS CCOV AND NLPPC,
!        RESPECTIVELY.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDS, LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE ARRAYS USED WHEN THE COMPUTATIONS ARE
!        PERFORMED BY THE FFT.
!     INTEGER M
!        THE NUMBER OF SERIES IN THE MULTIVARIATE TIME SERIES YM.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NLAG
!        THE NUMBER OF LAGS AT WHICH THE ACVF WAS COMPUTED.
!     INTEGER NLPPC(30,5,5)
!        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
!        USED TO COMPUTE EACH ACVF ESTIMATE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     INTEGER NYD
!        THE NUMBER OF OBSERVATIONS IN THE SERIES TO BE DIFFERENCED.
!     REAL YFFT1(150), YFFT2(150)
!        THE VECTORS USED FOR STORING THE SERIES FOR THE ROUTINES
!        USING THE FFT.
!     REAL YM(150,5), YMFFT(150,5)
!        THE ARRAYS USED FOR MULTIVARIATE TIME SERIES.
!     REAL YMISS0, YMMISS(5)
!        THE MISSING VALUE CODES FOR SERIES Y AND YM.
!     REAL Y1(100), Y1MISS
!        THE FIRST SERIES, AND ITS MISSING VALUE CODE.
!     REAL Y2(100), Y2MISS
!        THE SECOND SERIES, AND ITS MISSING VALUE CODE.
!
!
     data   y1(  1),  y1(  2),  y1(  3),  y1(  4),  y1(  5),  y1(  6)&
     &    /-0.88_wp, -0.16_wp, -1.87_wp, -1.12_wp,  1.38_wp,  2.13_wp/
     data   y1(  7),  y1(  8),  y1(  9),  y1( 10),  y1( 11),  y1( 12)&
     &    / 2.76_wp,  0.56_wp, -0.69_wp, -1.79_wp, -3.82_wp, -2.38_wp/
     data   y1( 13),  y1( 14),  y1( 15),  y1( 16),  y1( 17),  y1( 18)&
     &    / 1.00_wp,  0.70_wp, -0.15_wp,  0.98_wp,  0.11_wp, -0.35_wp/
     data   y1( 19),  y1( 20),  y1( 21),  y1( 22),  y1( 23),  y1( 24)&
     &    /-0.73_wp,  0.89_wp, -1.63_wp, -0.44_wp, -1.37_wp, -1.71_wp/
     data   y1( 25),  y1( 26),  y1( 27),  y1( 28),  y1( 29),  y1( 30)&
     &    /-1.22_wp, -2.00_wp, -0.22_wp,  0.38_wp,  1.31_wp,  0.71_wp/
     data   y1( 31),  y1( 32),  y1( 33),  y1( 34),  y1( 35),  y1( 36)&
     &    / 0.32_wp,  0.48_wp, -1.88_wp, -0.94_wp, -1.54_wp, -0.13_wp/
     data   y1( 37),  y1( 38),  y1( 39),  y1( 40),  y1( 41),  y1( 42)&
     &    / 1.02_wp,  0.02_wp, -0.77_wp,  0.11_wp, -0.60_wp, -0.52_wp/
     data   y1( 43),  y1( 44),  y1( 45),  y1( 46),  y1( 47),  y1( 48)&
     &    /-0.09_wp,  1.23_wp,  1.46_wp,  0.61_wp,  0.42_wp,  2.16_wp/
     data   y1( 49),  y1( 50),  y1( 51),  y1( 52),  y1( 53),  y1( 54)&
     &    / 3.18_wp,  2.10_wp,  0.37_wp, -0.24_wp,  0.57_wp, -0.53_wp/
     data   y1( 55),  y1( 56),  y1( 57),  y1( 58),  y1( 59),  y1( 60)&
     &    / 2.44_wp,  1.02_wp, -0.53_wp, -2.49_wp, -2.12_wp, -1.04_wp/
     data   y1( 61),  y1( 62),  y1( 63),  y1( 64),  y1( 65),  y1( 66)&
     &    /-0.12_wp, -1.88_wp, -1.50_wp,  1.54_wp,  3.33_wp,  3.08_wp/
     data   y1( 67),  y1( 68),  y1( 69),  y1( 70),  y1( 71),  y1( 72)&
     &    / 1.71_wp,  0.79_wp,  1.55_wp,  0.89_wp, -0.89_wp, -1.18_wp/
     data   y1( 73),  y1( 74),  y1( 75),  y1( 76),  y1( 77),  y1( 78)&
     &    / 0.89_wp,  1.71_wp,  3.05_wp,  0.15_wp, -1.04_wp,  0.12_wp/
     data   y1( 79),  y1( 80),  y1( 81),  y1( 82),  y1( 83),  y1( 84)&
     &    / 0.08_wp,  0.11_wp, -2.62_wp, -1.28_wp,  1.07_wp,  3.20_wp/
     data   y1( 85),  y1( 86),  y1( 87),  y1( 88),  y1( 89),  y1( 90)&
     &    / 1.92_wp,  0.53_wp, -1.08_wp,  0.49_wp, -0.58_wp,  0.17_wp/
     data   y1( 91),  y1( 92),  y1( 93),  y1( 94),  y1( 95),  y1( 96)&
     &    / 1.15_wp, -0.97_wp, -1.63_wp,  1.14_wp, -0.67_wp, -0.88_wp/
     data   y1( 97),  y1( 98),  y1( 99),  y1(100)&
     &    /-0.07_wp,  0.24_wp,  0.55_wp, -2.16_wp/
     data   y2(  1),  y2(  2),  y2(  3),  y2(  4),  y2(  5),  y2(  6)&
     &    / 0.79_wp,  1.12_wp, -1.10_wp, -2.39_wp, -1.75_wp, -0.82_wp/
     data   y2(  7),  y2(  8),  y2(  9),  y2( 10),  y2( 11),  y2( 12)&
     &    /-0.36_wp,  1.27_wp,  1.75_wp,  2.44_wp,  0.36_wp, -2.10_wp/
     data   y2( 13),  y2( 14),  y2( 15),  y2( 16),  y2( 17),  y2( 18)&
     &    /-1.93_wp, -1.30_wp, -1.75_wp, -0.34_wp,  0.74_wp,  0.49_wp/
     data   y2( 19),  y2( 20),  y2( 21),  y2( 22),  y2( 23),  y2( 24)&
     &    / 0.70_wp,  0.71_wp,  0.09_wp,  0.59_wp,  1.54_wp,  0.14_wp/
     data   y2( 25),  y2( 26),  y2( 27),  y2( 28),  y2( 29),  y2( 30)&
     &    / 0.55_wp, -1.40_wp, -2.55_wp, -1.66_wp, -0.43_wp,  0.58_wp/
     data   y2( 31),  y2( 32),  y2( 33),  y2( 34),  y2( 35),  y2( 36)&
     &    / 2.18_wp, -0.24_wp,  0.58_wp, -0.18_wp, -1.55_wp, -0.64_wp/
     data   y2( 37),  y2( 38),  y2( 39),  y2( 40),  y2( 41),  y2( 42)&
     &    /-1.09_wp,  0.90_wp, -0.66_wp, -0.35_wp,  0.48_wp,  0.50_wp/
     data   y2( 43),  y2( 44),  y2( 45),  y2( 46),  y2( 47),  y2( 48)&
     &    / 0.05_wp, -0.68_wp,  0.24_wp,  0.58_wp, -1.26_wp, -0.25_wp/
     data   y2( 49),  y2( 50),  y2( 51),  y2( 52),  y2( 53),  y2( 54)&
     &    / 0.25_wp,  2.18_wp,  2.96_wp,  1.56_wp, -0.36_wp, -0.59_wp/
     data   y2( 55),  y2( 56),  y2( 57),  y2( 58),  y2( 59),  y2( 60)&
     &    /-0.12_wp,  3.03_wp,  2.11_wp,  0.78_wp,  0.89_wp, -1.45_wp/
     data   y2( 61),  y2( 62),  y2( 63),  y2( 64),  y2( 65),  y2( 66)&
     &    /-0.36_wp, -0.37_wp, -1.39_wp, -4.19_wp, -0.73_wp, -0.98_wp/
     data   y2( 67),  y2( 68),  y2( 69),  y2( 70),  y2( 71),  y2( 72)&
     &    / 0.36_wp,  0.06_wp, -1.94_wp, -0.08_wp,  0.17_wp,  1.00_wp/
     data   y2( 73),  y2( 74),  y2( 75),  y2( 76),  y2( 77),  y2( 78)&
     &    /-0.05_wp,  0.43_wp,  0.15_wp,  2.69_wp,  0.57_wp,  0.29_wp/
     data   y2( 79),  y2( 80),  y2( 81),  y2( 82),  y2( 83),  y2( 84)&
     &    / 1.10_wp,  0.48_wp, -1.06_wp, -2.28_wp, -2.03_wp, -0.75_wp/
     data   y2( 85),  y2( 86),  y2( 87),  y2( 88),  y2( 89),  y2( 90)&
     &    / 1.00_wp,  1.71_wp,  0.58_wp,  1.97_wp,  0.99_wp,  1.94_wp/
     data   y2( 91),  y2( 92),  y2( 93),  y2( 94),  y2( 95),  y2( 96)&
     &    / 2.18_wp,  3.14_wp,  0.60_wp,  0.51_wp,  1.35_wp,  0.56_wp/
     data   y2( 97),  y2( 98),  y2( 99),  y2(100)&
     &    / 0.11_wp,  0.00_wp,  2.34_wp,  1.88_wp/
!
      call iprint(iprt)
      itest = 1
      ldstak = lds
!
      n = 100
      lagmax = 20
      nlag = 30
      nprt = 1
      lyfft = 150
      iccov = 30
      jccov = 5
      iym = 150
      m = 4
      iymfft = 150
      inlppc = 30
      jnlppc = 5
      nyd = 144
      ymiss0 = 1.16_wp
      y1miss = 0.89_wp
      y2miss = 0.89_wp
!
!     COPY DATA INTO YM FOR CCFS AND CCFMS
!
      call scopy(n, y1, 1, ym(1,1), 1)
      call scopy(n, y2, 1, ym(1,2), 1)
      call scopy(n, y1, 1, ym(1,3), 1)
      call scopy(n, y2, 1, ym(1,4), 1)
      call setrv(ymmiss, 4, ymiss0)
!
!     TEST OF CCF
!
      write (iprt,1060)
      call ccf(y1, y2, n)
!
!     PRINT RETURNED RESULTS
!
     call ccfxp (.false., lagmax, m, ccov, iccov, jccov, .false.,&
     &   nlppc,  inlppc, jnlppc, cmiss)
!
!     TEST OF CCFS
!
      write (iprt,1080)
     call ccfs(ym, n, m, iym, lagmax, ccov, iccov, jccov, nprt,&
     &   ldstak)
!
!     PRINT RETURNED RESULTS
!
     call ccfxp (.true., lagmax, m, ccov, iccov, jccov, .false.,&
     &   nlppc,  inlppc, jnlppc, cmiss)
!
!     TEST OF CCFM WITHOUT MISSING VALUES
!
      write (iprt,1070)
      write (iprt, 1050)
      call ccfm(y1, ymiss0, y2, ymiss0, n)
!
!     PRINT RETURNED RESULTS
!
     call ccfxp (.false., lagmax, m, ccov, iccov, jccov, .true.,&
     &   nlppc,  inlppc, jnlppc, cmiss)
!
!     TEST OF CCFMS WITHOUT MISSING VALUES
!
      write (iprt,1140)
      write (iprt, 1050)
     call ccfms(ym, ymmiss, n, m, iym, lagmax, ccov, cmiss,&
     &   iccov, jccov, nlppc, inlppc, jnlppc, nprt, ldstak)
!
!     PRINT RETURNED RESULTS
!
     call ccfxp (.true., lagmax, m, ccov, iccov, jccov, .true.,&
     &   nlppc,  inlppc, jnlppc, cmiss)
!
!     COPY DATA INTO YFFT1, YFFT2 AND YMFFT FOR CCFF AND CCFFS
!
      call scopy(n, y1, 1, yfft1, 1)
      call scopy(n, y2, 1, yfft2, 1)
      call scopy(n, y1, 1, ymfft(1,1), 1)
      call scopy(n, y2, 1, ymfft(1,2), 1)
      call scopy(n, y1, 1, ymfft(1,3), 1)
      call scopy(n, y2, 1, ymfft(1,4), 1)
!
!     TEST OF CCFF
!
      write (iprt,1100)
      call ccff(yfft1, yfft2, n, lyfft, ldstak)
!
!     PRINT RETURNED RESULTS
!
     call ccfxp (.false., lagmax, m, ccov, iccov, jccov, .false.,&
     &   nlppc,  inlppc, jnlppc, cmiss)
!
!     TEST OF CCFFS
!
      write (iprt,1150)
     call ccffs(ymfft, n, m, iymfft, lagmax, ccov,&
     &   iccov, jccov, nprt, ldstak)
!
!     PRINT RETURNED RESULTS
!
     call ccfxp (.true., lagmax, m, ccov, iccov, jccov, .false.,&
     &   nlppc,  inlppc, jnlppc, cmiss)
!
!     RESET YMMISS
!
      ymmiss(1) = y1miss
      ymmiss(2) = y2miss
      ymmiss(3) = y1miss
      ymmiss(4) = y2miss
!
!     TEST OF CCFM WITH MISSING VALUES
!
      write (iprt,1070)
      write (iprt, 1040)
      call ccfm(y1, y1miss, y2, y2miss, n)
!
!     PRINT RETURNED RESULTS
!
     call ccfxp (.false., lagmax, m, ccov, iccov, jccov, .true.,&
     &   nlppc,  inlppc, jnlppc, cmiss)
!
!     TEST OF CCFMS WITH MISSING VALUES
!
      write (iprt,1140)
      write (iprt, 1040)
     call ccfms(ym, ymmiss, n, m, iym, lagmax, ccov, cmiss,&
     &   iccov, jccov, nlppc, inlppc, jnlppc, nprt, ldstak)
!
!     PRINT RETURNED RESULTS
!
     call ccfxp (.true., lagmax, m, ccov, iccov, jccov, .true.,&
     &   nlppc,  inlppc, jnlppc, cmiss)
!
!     TEST PRINT CONTROL
!
      nprt = 0
!
!     TEST OF CCFS
!
      write (iprt,1080)
      write (iprt, 1020)
     call ccfs(ym, n, m, lagmax, iym, ccov, iccov, jccov, nprt,&
     &   ldstak)
!
!     PRINT RETURNED RESULTS
!
     call ccfxp (.true., lagmax, m, ccov, iccov, jccov, .false.,&
     &   nlppc,  inlppc, jnlppc, cmiss)
!
!     TEST OF CCFMS WITH MISSING VALUES
!
      write (iprt,1140)
      write (iprt, 1040)
      write (iprt, 1020)
     call ccfms(ym, ymmiss, n, m, iym, lagmax, ccov, cmiss,&
     &   iccov, jccov, nlppc, inlppc, jnlppc, nprt, ldstak)
!
!     PRINT RETURNED RESULTS
!
     call ccfxp (.true., lagmax, m, ccov, iccov, jccov, .true.,&
     &   nlppc,  inlppc, jnlppc, cmiss)
!
!     COPY DATA INTO YMFFT FOR CCFFS
!
      call scopy(n, y1, 1, ymfft(1,1), 1)
      call scopy(n, y2, 1, ymfft(1,2), 1)
      call scopy(n, y1, 1, ymfft(1,3), 1)
      call scopy(n, y2, 1, ymfft(1,4), 1)
!
!     TEST OF CCFFS
!
      write (iprt,1150)
      write (iprt, 1020)
     call ccffs(ymfft, n, m, iymfft, lagmax, ccov,&
     &   iccov, jccov, nprt, ldstak)
!
!     PRINT RETURNED RESULTS
!
     call ccfxp (.true., lagmax, m, ccov, iccov, jccov, .false.,&
     &   nlppc,  inlppc, jnlppc, cmiss)
!
!     TEST LEAD/LAG MESSAGE
!
      nprt = 1
!
      call setra(ymfft, iymfft, m, n, 0.0_wp)
      ymfft(5,1) = 1.0_wp
      ymfft(15,2) = 1.0_wp
      ymfft(5,3) = ymfft(5,1)
      ymfft(15,4) = ymfft(15,2)
!
!     TEST OF CCFFS
!
      write (iprt,1150)
      write (iprt, 1020)
     call ccffs(ymfft, n, m, iymfft, lagmax, ccov,&
     &   iccov, jccov, nprt, ldstak)
!
!     PRINT RETURNED RESULTS
!
     call ccfxp (.true., lagmax, m, ccov, iccov, jccov, .false.,&
     &   nlppc,  inlppc, jnlppc, cmiss)
!
      go to (100, 200, 300, 400), itest
!
!     TEST MINIMUM PROBLEM SIZE
!
  100 itest = itest + 1
      n = 3
      lagmax = 1
      lyfft = 150
      iccov = 30
      jccov = 5
      iym = 150
      m = 1
      iymfft = 150
      inlppc = 30
      jnlppc = 5
      nyd = 144
      ymiss0 = 1.16_wp
      y1miss = 0.89_wp
      y2miss = 0.89_wp
!
!     TEST ERROR HANDLING
!
  200 itest = itest + 1
      n = 0
      lagmax = 1
      lyfft = 0
      iccov = 0
      jccov = 0
      iym = 0
      m = 0
      iymfft = 0
      inlppc = 0
      jnlppc = 0
      nyd = 0
!
!     TEST ERROR HANDLING
!
  300 itest = itest + 1
      n = 100
      lagmax = 100
      lyfft = 0
      iccov = 0
      jccov = 0
      iym = 0
      m = 0
      iymfft = 0
      inlppc = 0
      jnlppc = 0
      nyd = 144
      ldstak = 0
!
  400 return
!
!     FORMAT STATEMENTS
!
 1020 format (18h output suppressed)
 1040 format (20h with missing values)
 1050 format (23h without missing values)
 1060 format ('1', 11htest of ccf)
 1070 format ('1', 12htest of ccfm)
 1080 format ('1', 12htest of ccfs)
 1100 format ('1', 12htest of ccff)
 1140 format ('1', 13htest of ccfms)
 1150 format ('1', 13htest of ccffs)
      end
!STATWS
      subroutine statws(y, wt, n, ldstak, sts, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES 53 DIFFERENT STATISTICS FOR A VECTOR
!     Y, WITH WEIGHTS SPECIFIED.  ONE PAGE OF AUTOMATIC
!     PRINTOUT IS PRODUCED.
!
!     WRITTEN BY - JANET R. DONALDSON, JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!        (EXTENSIVE REVISION OF OLDER VERSION)
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,n,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   sts(53),wt(*),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   alpha,sum1,sumd2,sumd3,sumd4,sumda,sumdi,sumt1,sumw,sumwd2,&
     &   sumwt1
     integer&
     &   idp,iint,iprt,lsort,mid,nall0,nnzw
     logical&
     &   stack,wts
!
!  LOCAL ARRAYS
     integer&
     &   istak(12)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL GENI,IPRINT,SRTIRR,SRTRRI,STAT1W,STAT2W,STATER,STKCLR,
!     +   STKSET,SUMBS,SUMIDW,SUMOT,SUMWDS,SUMWSS,SUMWTS
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        THE PERCENTAGE TO BE TRIMMED FROM EACH END OF THE
!        SORTED ARRAY Y.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDP
!        FRAMEWORK CODE VALUE FOR DOUBLE PRECISION NUMBERS.
!     INTEGER IERR
!        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
!        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
!        SOME ERROR EXISTS.
!     INTEGER IINT
!        THE CODE VALUE FOR INTEGER FOR FRAMEWORK.
!     INTEGER IPRT
!        THE NUMBER OF THE STANDARD OUTPUT UNIT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
!        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
!     INTEGER LSORT
!        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION VECTOR.
!     INTEGER MID
!        THE INDEX OF A ZERO ELEMENT IN THE SORTED Y, OR OF THE
!        ELEMENT CLOSEST TO ZERO.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
!        WAS CALLED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        INPUT PARAMETER.  THE CODE INDICATING WHETHER PRINTOUT
!        IS DESIRED.  0 MEANS NO PRINTOUT, NOT 0 MEANS PRINTOUT.
!     INTEGER NNZW
!        NUMBER OF NONZERO WEIGHTS.
!     LOGICAL STACK
!        A FLAG INDICATING WHETHER THIS ROUTINE USES THE STACK (TRUE)
!        OR NOT (FALSE).
!     REAL STS(53)
!        OUTPUT PARAMETER.  THE VECTOR OF THE 53 STATISTICS COMPUTED.
!     REAL SUMDA
!        THE SUM OF THE ABSOLUTE DIFFERENCES FROM THE MEAN.
!     REAL SUMDI
!        THE SUM OF THE PRODUCTS OF THE INDICES AND THE
!        DIFFERENCES.
!     REAL SUMD2
!        THE SUM OF THE SQUARES OF THE DIFFERENCES.
!     REAL SUMD3
!        THE SUM OF THE CUBES OF THE DIFFERENCES.
!     REAL SUMD4
!        THE SUM OF THE 4TH POWERS OF THE DIFFERENCES.
!     REAL SUMT1
!        THE SUM OF THE ALPHA TRIMMED ARRAY Y.
!     REAL SUMW
!        THE SUM OF THE WEIGHTS VECTOR WT.
!     REAL SUMWD2
!        THE WEIGHTED SUM OF THE SQUARES OF THE DIFFERENCES.
!     REAL SUMWT1
!        THE WEIGHTED SUM OF THE ALPHA TRIMMED ARRAY.
!     REAL SUM1
!        THE SUM OF THE ELEMENTS OF X.  A DUMMY VARIABLE.
!     REAL WT(N)
!        INPUT PARAMETER.  THE WEIGHTS VECTOR.
!     LOGICAL WTS
!        A FLAG INDICATING WHETHER THERE ARE WEIGHTS (TRUE)
!        OR NOT (FALSE).
!     REAL Y(N)
!        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
!        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
!        TO ITS ORIGINAL ORDER AFTERWARDS.
!
!
!     INITIALIZE NAME VECTORS
!
     data  nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6)&
     &   /       'S',      'T',      'A',      'T',      'W',      'S'/
!
      data alpha /0.25e0/
      data idp /4/
      data iint /2/
      data wts /.true./
      data stack /.true./
!
!     CHECK FOR ERRORS IN THE INPUT PARAMETERS.
!
      call stater(nmsub, wt, n, ldstak, wts, nnzw, stack, ierr)
      if (ierr.ne.0) then
!
!     PRINT ERROR MESSAGE.
!
         call iprint(iprt)
         write (iprt,1000)
         return
      end if
!
!     SET UP FRAMEWORK AREA.
!
      call stkset (ldstak, idp)
      nall0 = stkst(1)
!
!     SET UP LSORT, THE PERMUTATION VECTOR.
!
      lsort = stkget(n,iint)
      call geni(istak(lsort), n, 1, 1)
!
!     SORT THE VECTOR Y CARRYING ALONG THE CONTENTS OF THE VECTOR
!     ISTAK(LSORT).
!
      call srtirr(istak(lsort), wt, n, y)
!
!     COMPUTE THE STATISTICS WHICH USE A SORTED ARRAY.
!
     call stat1w(y, wt, n, sts(5), sts(34), sts(35), sts(6),&
     &   sts(11), 10, 0.0e0, 0.0e0, sts(44), nnzw)
!
!     COMPUTED VARIOUS SUMS IN THE SORTED ARRAY Y.
!
      call sumbs(y, n, 1, mid, n)
     call sumwss(y, wt, n, 1, mid, n, nnzw, sum1, sts(38), sts(39),&
     &   sts(42), sumw, sts(3), sts(4))
     call sumwts(y, wt, n, nnzw, alpha, sumt1, sumwt1, sts(7),&
     &   sts(8))
     call sumwds(y, wt, n, 1, mid, n, sts(4), sumda, sumwd2, sumd2,&
     &   sumd3, sumd4)
!
!     RESTORE THE VECTOR Y TO ITS ORIGINAL ORDER.
!
      call srtrri(y, wt, n, istak(lsort))
!
!     COMPUTE REST OF STATISTICS.
!
      call sumidw(y, wt, n, sts(4), sumdi)
     call stat2w(y, wt, n, nnzw, sts, sumda, sumdi, sumwd2, sumd2,&
     &   sumd3, sumd4, sumw)
      if (nprt.ne.0) call sumot(sts, n, nnzw, wts)
!
!     RETURN THE VECTOR LSORT.
!
      call stkclr(nall0)
      return
!
!     FORMAT STATEMENTS.
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL STATWS (Y, WT, N, LDSTAK, STS, NPRT)')
      end
!NLSD
     subroutine nlsd(y, xm, n, m, ixm, mdl, drv, par, npar, res,&
     &   ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING ANALYTIC DERIVATIVES (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,ldstak,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),res(*),xm(*),y(*)
!
!  SUBROUTINE ARGUMENTS
       external drv,mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
    &   idrvck,iprt,ivaprx,ivcv,lifixd,lpv,lscale,lsdpv,lsdres,&
     &   lwt,mit,nnzw,npare,nprt
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   pv(1),scale(1),sdpv(1),sdres(1),vcv(1,1),wt(1)
     integer&
     &   ifixed(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,NLCNTA
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE DERIVATIVES WE
!        CHECKED OR NOT.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(1)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(1)
!        THE DUMMY ARRAY FOR THE WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'N','L','S','D',' ',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      weight = .false.
      save = .false.
!
      wt(1) = 1.0e0
      idrvck = 1
      mit = -1
      stopss = -1.0e0
      stopp = -1.0e0
      scale(1) = -1.0e0
      delta = -1.0e0
      nprt = -1
      ifixed(1) = -1
      ivaprx = 0
      lifixd = 1
      lpv = 1
      lscale = 1
      lsdpv = 1
      lsdres = 1
      lwt = 1
      ivcv = 1
!
     call nlcnta(y, wt, lwt, xm, n, m, ixm, mdl, drv, par, npar, res,&
    &   ldstak, ifixed, lifixd, idrvck, mit, stopss, stopp, scale,&
    &   lscale, delta, ivaprx, nprt, rsd, pv, lpv, sdpv, lsdpv, sdres,&
     &   lsdres, vcv, ivcv, nmsub, weight, save, nnzw, npare)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL NLSD (Y, XM, N, M, IXM, NLSMDL, NLSDRV,'/&
     &   '      +           PAR, NPAR, RES, LDSTAK)')
      end
!FLTMA
      subroutine fltma (y, n, k, hma, yf, nyf)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE FILTERS THE INPUT SERIES Y USING THE K TERMS
!     OF H, COPYING THE FILTERED SERIES INTO YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   hma
     integer&
     &   k,n,nyf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(n),yf(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   sum
     integer&
     &   i,i1,ii,j
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL HMA
!        THE VALUE OF EACH OF THE SIMPLE MOVING AVERAGE LINEAR FILTER
!        COEFFICIENTS.
!     INTEGER I, II, I1, J
!        INDEXING VARIABLES.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     REAL SUM
!        A TEMPORARY LOCATION USED IN COMPUTING THE FILTERED SERIES.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
      do 10 i = 1, n
         yf(i) = y(i)
   10 continue
!
      nyf = n - (k - 1)
!
      do 30 i = 1, nyf
         ii = i - 1
         sum = 0.0e0
         do 20 j = 1, k
            ii = ii + 1
            sum = sum + hma*yf(ii)
   20    continue
         yf(i) = sum
   30 continue
!
      i1 = nyf + 1
!
      do 40 i = i1, n
         yf(i) = 0.0e0
   40 continue
!
      return
      end
!CCFMNF
     subroutine ccfmnf (y1, y2, n, nfft, lagmax, ncc, ccov11, ccov22,&
     &   ccov12, ccov21, lccov, rhoc, sdrhoc, nprt, lyfft, work, lwork)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING CROSS CORRELATIONS AND
!     THEIR STANDARD ERRORS OF A TIME SERIES USING A FFT.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lagmax,lccov,lwork,lyfft,n,ncc,nfft,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   ccov11(lccov),ccov12(lccov),ccov21(lccov),ccov22(lccov),&
     &   rhoc(ncc),sdrhoc(ncc),work(lwork),y1(lyfft),y2(lyfft)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fac
     integer&
     &   i,i0,im,ip
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL CCFSD,CCVFF
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCOV11(LCCOV)
!        THE ARRAY IN WHICH THE AUTOCOVARIANCE FUNCTION ESTIMATES
!        FOR THE FIRST SERIES IS STORED.
!     REAL CCOV12(LCCOV), CCOV21(LCCOV)
!        THE ARRAYS IN WHICH THE CROSS COVARIANCE FUNCTION
!        ESTIMATES FOR THE FIRST SERIES LAGGED BEHIND THE SECOND
!        AND VISA VERSA, ARE STORED.
!     REAL CCOV22(LCCOV)
!        THE ARRAY IN WHICH THE AUTOCOVARIANCE FUNCTION ESTIMATES
!        FOR THE SECOND SERIES IS STORED.
!     REAL FAC
!        THE INVERSE OF THE SQUARE ROOT OF THE PRODUCT OF THE
!        AUTOCOVARIANCES AT LAG ZERO.
!     INTEGER I
!        THE INDEXING VARIABLE FOR THE LAG VALUE.
!     INTEGER  IM, IP, I0
!        THE LOCATIONS IN THE CCF RELATED ARRAYS
!        OF THE LAG -I, I, AND 0, RESPECTIVELY.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LCCOV
!        THE DIMENSION OF THE COVARANCE ARRAYS.
!     INTEGER LWORK
!        THE DIMENSION OF THE WORK ARRAY.
!     INTEGER LYFFT
!        THE DIMENSION OF THE DATA ARRAYS.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NCC
!        THE NUMBER OF CROSS CORRELATIONS COMPUTED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO CONTROL COMPUTATIONS NEEDED
!        ONLY FOR PRINTED OUTPUT.
!     REAL RHOC(NCC)
!        THE ARRAY IN WHICH THE CROSS CORRELATIONS ARE STORED
!     REAL SDRHOC(NCC)
!        THE ARRAY CONTAINING THE STD. ERRORS OF THE CROSS CORRELATIONS.
!        ARE STORED.
!     REAL WORK(LWORK)
!        THE WORK ARRAY.
!     REAL Y1(LYFFT), Y2(LYFFT)
!        THE VECTORS CONTAINING THE OBSERVED SERIES
!
!     COMPUTE THE CROSS CORRELATIONS.
!
     call ccvff (y1, y2, n, nfft, lagmax, ccov12, ccov21, lccov, lyfft,&
     &   work, lwork)
!
      if (nprt .eq. 0 .or. ccov11(1)*ccov22(1) .eq. 0.0e0) return
!
      fac = 1.0e0 / sqrt(ccov11(1) * ccov22(1))
!
      i0 = lagmax + 1
      rhoc(i0) = ccov12(1) * fac
      do 10 i = 1, lagmax
         ip = i0 + i
         rhoc(ip) = ccov12(i+1) * fac
!
         im = i0 - i
         rhoc(im) = ccov21(i+1) * fac
   10 continue
!
!     COMPUTE STANDARD ERROR OF THE CROSSCORRELATIONS.
!
      call ccfsd (ccov11, ccov22, sdrhoc, lagmax, ncc, n, lccov)
!
      return
      end
!LPFLT
      subroutine lpflt (fc, k, hlp)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE LOPASS FILTER COEFFICIENTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fc
     integer&
     &   k
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   hlp(k)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   arg,con,pi,sum
     integer&
     &   i,ihm,ihp,khalf,kmid
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL GETPI
!
!  INTRINSIC FUNCTIONS
      intrinsic sin
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ARG, CON
!        VARIABLES USED IN THE COMPUTATION OF THE LOW PASS FILTER
!        COEFFICIENTS.
!     REAL FC
!        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
!     REAL HLP(K)
!        THE ARRAY IN WHICH THE INPUT LOW PASS FILTER COEFFICIENTS
!        ARE STORED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IHM, IHP
!        INDEX VARIABLES FOR SYMMETRIC LOCATIONS AROUND THE MIDPOINT
!        OF THE FILTER.
!     INTEGER K
!        THE NUMBER OF TERMS IN THE FILTER.
!     INTEGER KHALF
!        THE VALUE OF THE MIDPOINT OF K MINUS 1.
!     INTEGER KMID
!        THE MIDPOINT OF THE FILTER.
!     REAL PI
!        THE VALUE OF PI.
!     REAL SUM
!        A VALUE USED FOR SUMMING.
!
      call getpi(pi)
!
      kmid = (k + 1) / 2
!
      hlp(kmid) = 1.0e0
!
      if (k .eq. 1) return
!
      hlp(kmid) = 2.0e0 * fc
      con = 2.0e0 * pi / k
      sum = hlp(kmid)
!
      khalf = (k - 1) / 2
!
      do 10 i = 1, khalf
         arg = i * con
         ihp = kmid + i
        hlp(ihp) = sin(i * fc * 2.0e0 * pi) * sin(arg) /&
     &      (i * pi * arg)
         ihm = kmid - i
         hlp(ihm) = hlp(ihp)
         sum = sum + hlp(ihm) + hlp(ihp)
   10 continue
      do 20 i = 1, k
         hlp(i) = hlp(i) / sum
   20 continue
      return
      end
!DCKLSC
     subroutine dcklsc(xm, n, m, ixm, mdl, drv, par, npar, ldstak,&
     &   neta, ntau, scale, nrow, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR CHECKING USER SUPPLIED
!     ANALYTIC DERIVATIVES AGAINST NUMERICAL DERIVATIVES
!     FOR THE NONLINEAR LEAST SQUARES ROUTINES (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,ldstak,m,n,neta,npar,nprt,nrow,ntau
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),scale(*),xm(*)
!
!  SUBROUTINE ARGUMENTS
       external drv,mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,lscale
!
!  LOCAL ARRAYS
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DCKDRV,IPRINT
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
!        PARAMETERS ARE STORED.
!     REAL SCALE(NPAR)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'D','C','K','L','S','C'/
!
      lscale = npar
!
!     PASS CONTROL OF DERIVATIVE CHECKING TO DCKDRV
!
     call dckdrv(nmsub, ldstak, xm, n, m, ixm, mdl, drv, par, npar,&
     &   neta, ntau, scale, lscale, nrow, nprt)
!
      if (ierr.ne.1) return
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL DCKLSC (XM, N, M, IXM, NLSMDL, NLSDRV,'/&
    &   '      +             PAR, NPAR, LDSTAK,'/&
     &   '      +             NETA, NTAU, SCALE, NROW, NPRT)')
      end
!HSTMN
      subroutine hstmn(y, n, ncells, ylb, yub, lsort, ydist)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN ROUTINE FOR PRODUCING A HISTOGRAM
!
!     ORIGINAL VERSION ADAPTED FROM AN EARLY VERSION OF MINITAB.
!
!     ADAPTED BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ylb,yub
     integer&
     &   n,ncells
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(n),ydist(ncells)
     integer&
     &   lsort(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   alpha,b1sqrt,b2,cfract,cfrctm,cntmx,fract,p,scale,sum1,sum2,&
    &   sum3,sumd2,sumd3,sumd4,sumda,sumt1,temp,width,xn,xnn,yintmp,&
     &   ymax,ymddsd,ymean,ymeant,ymed,ymidrg,ymin,yrange,ysd,yvar
     integer&
     &   i,iflag,iprt,j,mid,nhigh,nlow,nobs,num,nums
     character&
     &   iplus*1
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   a(6)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL GENI,IPRINT,SRTIR,SRTRI,STAT1,SUMBS,SUMDS,SUMSS,SUMTS,
!     +   VERSP
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,int,max,mod,nint,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL A(6)
!        A VECTOR USED FOR PRINTING THE HISTOGRAM SCALE.
!     REAL ALPHA
!        THE PERCENTAGE TO BE TRIMMED OFF EACH END OF Y FOR THE
!        TRIMMED MEANS CALCULATIONS.
!     REAL B1SQRT
!        BETA ONE  -  A MEASURE OF SKEWNESS
!     REAL B2
!        BETA TWO  -  A MEASURE OF KURTOSIS
!     REAL CFRACT
!        THE CUMULATIVE DISTRIBUTION
!     REAL CFRCTM
!        THE REVERSE CUMULATIVE DISTRIBUTION
!     REAL CNTMX
!        THE SIZE OF THE LARGEST CELL COUNT
!     REAL FRACT
!        THE FRACTION OF THE OBSERVATIONS IN A GIVEN CELL
!     INTEGER I
!        AN INDEX
!     INTEGER IFLAG
!        IF 1, THEN MORE THAN 50 OBS. FELL IN A SINGLE CELL,
!        AND A SCALED HISTOGRAM WILL BE PROVIDED.
!     CHARACTER*1 IPLUS
!        THE CHARACTER +
!     INTEGER IPRT
!        THE NUMBER OF THE STANDARD OUTPUT UNIT.
!     INTEGER J
!        AN INDEX.
!     INTEGER LSORT(N)
!        THE PERMUTATION VECTOR.
!     INTEGER MID
!        THE INDEX OF THE (AN) ELEMENT OF Y CLOSEST TO ZERO, WHEN
!        Y HAS BEEN SORTED.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y.
!     INTEGER NCELLS
!        THE NUMBER OF CELLS IN THE FREQUENCY DISTRIBUTION.
!     INTEGER NHIGH
!        THE INDEX OF THE LARGEST VALUE IN THE SORTED ARRAY
!        TO BE USED IN THE HISTOGRAM
!     INTEGER NLOW
!        THE INDEX OF THE SMALLEST VALUE IN THE SORTED ARRAY
!        TO BE USED IN THE HISTOGRAM
!     INTEGER NOBS
!        THE NUMBER OF OBSERVATIONS ACTUALLY USED IN THE HISTOGRAM
!     INTEGER NUM
!        THE CELL COUNT
!     INTEGER NUMS
!        THE SCALED CELL COUNT
!     REAL P
!        A VARIABLE USED TO DETERMINE THE SCALE
!     REAL SCALE
!        THE PRINTED INCREMENT ON THE HISTOGRAM SCALE
!     REAL SUMDA
!        THE SUM OF THE ABSOLUTE DIFFERENCES FROM THE MEAN.
!     REAL SUMD2
!        THE SUM OF THE SQUARES OF THE DIFFERENCES.
!     REAL SUMD3
!        THE SUM OF THE CUBES OF THE DIFFERENCES.
!     REAL SUMD4
!        THE SUM OF THE 4TH POWERS OF THE DIFFERENCES.
!     REAL SUMT1
!        THE SUM OF THE ALPHA TRIMMED ARRAY Y.
!     REAL SUM1, SUM2, SUM3
!        VARIOUS SUMS OF THE DATA.
!     REAL TEMP
!        A TEMPORARY STORAGE VARIABLE
!     REAL WIDTH
!        THE WIDTH OF A CELL
!     REAL XN
!        THE FOATING POINT REPRESENTATION OF N
!     REAL XNN
!        THE UNROUNDED NUMBER OF PLOTTING POSISTIONS ON A SCALES
!        HISTOGRAM
!     REAL Y(N)
!        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
!        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
!        TO ITS ORIGINAL ORDER AFTERWARDS.
!     REAL YDIST(NCELLS)
!        THE FREQUENCY DISTRIBUTION USED TO CREATE THE HISTOGRAM.
!     REAL YINTMP
!        THE MIDPOINT OF THE ITH CELL
!     REAL YLB
!        THE LOWER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!     REAL YMAX
!        THE HISTOGRAM UPPER BOUND USED
!     REAL YMDDSD
!        THE MEAN ABSOLUTE DEVIATION / THE STANDARD DEVIATION
!     REAL YMEAN, YMEANT
!        THE MEAN OF THE OBSERVATIONS USED IN THE HISTOGRAM
!     REAL YMED
!        THE MEDIAN OF THE OBSERVATIONS USED IN THE HISTOGRAM
!     REAL YMIDRG
!        THE MID RANGE OF THE OBSERVATIONS USED IN THE HISTOGRAM
!     REAL YMIN
!        THE HISTOGRAM LOWER BOUND USED.
!     REAL YRANGE
!        THE RANGE OF THE OBSERVATIONS USED IN THE HISTOGRAM
!     REAL YSD
!        THE STANDARD DEVIATION OF THE OBSERVATIONS USED IN THE
!        HISTOGRAM.
!     REAL YUB
!        THE UPPER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!     REAL YVAR
!        THE VARIANCE OF THE OBSERVATIONS.
!
      data iplus /'+'/
      data alpha/0.25_wp/
!
      call iprint(iprt)
!
!     SORT DATA
!
      call geni(lsort, n, 1, 1)
      call srtir(lsort, n, y)
!
!     FIX UPPER AND LOWER BOUNDS.
!
      nlow = 1
      nhigh = n
      if (ylb.eq.yub) go to 50
!
!     FIND INDEX OF THE FIRST VALUE OF Y .GE. YLB
!
      do 20 i=1,n
         if (y(i).lt.ylb) go to 20
         nlow = i
         go to 30
   20 continue
!
!     FIND INDEX OF THE LAST VALUE OF Y .LE. YUB
!
   30 do 40 i=1,n
         j = n - i + 1
         if (y(j).gt.yub) go to 40
         nhigh = j
         go to 50
   40 continue
   50 continue
      xn = nhigh-nlow+1
      nobs = nhigh - nlow + 1
!
!     COMPUTE MEDIAN, EXTREMA, MID-RANGE, RANGE AND FREQUENCY
!     DISTRIBUTION FOR NCELLS CELLS
!
     call stat1(y(nlow), nobs, ymed, ymin, ymax, ymidrg, yrange,&
     &   ncells, ylb, yub, ydist)
!
      if (ylb.ge.yub) go to 55
!
      ymin = ylb
      ymax = yub
!
   55 continue
!
!     COMPUTE MEAN, TRIMMED MEAN, STANDARD DEVIATION,
!     MEAN DEVIATION/STANDARD DEVIATION, BETA ONE, AND BETA TWO
!
      call sumbs(y, n, nlow, mid, nhigh)
      call sumss(y, n, nlow, mid, nhigh, sum1, sum2, sum3, ymean)
      call sumts(y(nlow), nobs, alpha, sumt1, ymeant)
     call sumds(y, n, nlow, mid, nhigh, ymean, sumda, sumd2, sumd3,&
     &   sumd4)
!
      yvar = 0.0_wp
      ysd = 0.0_wp
      b1sqrt = 0.0_wp
      b2 = 0.0_wp
      ymddsd = 0.0_wp
!
      if ((sumd2.le.0.0_wp) .or. (nobs.le.1)) go to 60
!
      yvar = sumd2/(nobs-1)
      ysd = sqrt(yvar)
      b1sqrt = abs((sumd3/xn)/((sumd2/xn)**1.5_wp))
      b2 = (sumd4/xn)/((sumd2/xn)**2)
      ymddsd = sumda/(ysd*nobs)
!
   60 continue
!
!     OUTPUT STATISTICS
!
      call versp(.true.)
      write (iprt,1070) n, y(nlow), y(nhigh), ymin, ymax
     write (iprt,1000)&
    &   ncells, nobs, ymeant, y(nlow), ysd, y(nhigh), ymddsd,&
     &   ymean, b1sqrt, ymed, b2
      write (iprt,1010)
!
!     CHECK FOR MORE THAN 50 VALUES IN INTERVAL AND FIND MAX. VALUE.
!
      iflag = 0
      cntmx = 0.0_wp
      do 80 i=1,ncells
         if (ydist(i).gt.cntmx) cntmx = ydist(i)
   80 continue
      if (nint(cntmx).gt.50) iflag = 1
!
!     DETERMINE SCALE.
!
      if (iflag.eq.0) then
         scale = 1.0_wp
      else
         p = cntmx/xn
         scale = 0.05_wp
         if (p.gt.0.25_wp) scale = 0.1_wp
         if (p.gt.0.5_wp) scale = 0.2_wp
      end if
!
!     PRINT COLUMN HEADINGS AND HISTOGRAM SCALE.
!
      if (iflag.eq.0) write (iprt,1020)
      if (iflag.ne.0) write (iprt,1080)
      write (iprt,1090)
      if (iflag.ne.0) go to 100
      write (iprt,1030) (i,i=10,50,10)
      go to 120
  100 a(1) = 0.0_wp
      do 110 i=1,5
         a(i+1) = a(i) + scale
  110 continue
      write (iprt,1040) (a(i),i=1,6)
  120 write (iprt,1050)
      cfract = 0.0_wp
      cfrctm = 1.0_wp
      temp = 0.0_wp
      width = (ymax-ymin)/ncells
      yintmp = ymin
      yintmp = yintmp - width/2.0_wp
      do 150 i=1,ncells
         num = int(ydist(i)+0.5_wp)
        if (mod(ncells,2).eq.1 .and. i.eq.ncells/2+1&
     &       .and. ymin.eq.(-ymax)) then
            yintmp = 0.0_wp
         else
            yintmp = yintmp + width
         end if
         fract = ydist(i)/xn
         cfract = cfract + fract
         cfrctm = 1.0_wp - temp
         temp = cfract
         if (num.le.0) then
           write (iprt,1060) yintmp, cfract, cfrctm, fract, num
         else
           if (iflag.eq.0) then
             nums = num
           else
             xnn = fract*10.0_wp/scale
             nums = int(xnn)
             nums = max(1, nums + int(xnn-nums+0.5_wp))
           end if
          write (iprt,1060) yintmp, cfract, cfrctm, fract,&
     &        num, (iplus,j=1,nums)
         end if
  150 continue
!
!     RESTORE DATA TO ORIGINAL ORDER
!
      call srtri(y, n, lsort)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format(/26h number of cells        = , i15/&
    &        26h observations used      = , i15, 11x,&
    &              22h25 pct trimmed mean = , 1pe15.8/&
    &        26h min. observation used  = , e15.8, 11x,&
    &              22hstandard deviation  = , e15.8/&
    &        26h max. observation used  = , e15.8, 11x,&
    &              22hmean dev./std. dev. = , e15.8/&
    &        26h mean value             = , e15.8, 11x,&
    &              22hsqrt(beta one)      = , e15.8/&
    &        26h median value           = , e15.8, 11x,&
     &              22hbeta two            = , e15.8)
1010 format(//44h for a normal distribution, the values (mean,&
    &   56h deviation/standard deviation), sqrt(beta one), and beta,&
    &   22h two are approximately/&
    &   ' 0.8, 0.0 AND 3.0, RESPECTIVELY.  TO TEST THE ',&
    &   59hnull hypothesis of normality, see tables of critical values,&
    &   13h pp. 207-208,/  22h biometrika tables for,&
    &   58h statisticians, vol. 1.  see pp. 67-68 for a discussion of,&
     &   13h these tests.)
1020 format(///5x,39hinterval     cum.   1-cum.   cell   no.,19x,&
     & 22hnumber of observations)
 1030 format('+',47x,1h0,8x,5(i2,8x))
 1040 format('+',46x,6(f4.2,6x))
 1050 format(4x,42('-'),2x,'+',5(10h---------+))
 1060 format(3x,1pe13.6,2x,2(0pf5.3,3x),f5.3,1x,i5,4x,50a1)
1070 format (10h histogram//&
    &        26h number of observations = , i15/&
    &        26h minimum observation    = , 1pe15.8/&
    &        26h maximum observation    = , e15.8//&
    &        26h histogram lower bound  = , e15.8/&
     &        26h histogram upper bound  = , e15.8)
1080 format(///5x,39hinterval     cum.   1-cum.   cell   no.,23x,&
     & 13hcell fraction)
 1090 format(5x,41hmid point   fract.  fract.  fract.  obs. )
      end
!UFSMS
     subroutine ufsms(y, ymiss, n, nw, lags, nf, fmin, fmax, nprt,&
     &   spcf, ispcf, freq, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS WITH MISSING DATA (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: fmax,fmin,ymiss
     integer&
     &   ispcf,ldstak,n,nf,nprt,nw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(*),spcf(*),y(*)
     integer&
     &   lags(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta
     integer&
    &   acov,i,ifp,io,iprt,isort,isym,lacov,lagmax,ldsmin,lnlppa,&
     &   lpcv,lwork,ly,nall0,nlppa,work,xaxis,yaxis
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ECVF,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UFSDRV
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER ACOV
!        THE STARTING LOCATION IN RSTAK FOR THE ACVF VECTOR.
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE SPECTRUM
!        IS TO BE COMPUTED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF ERR01, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION FOR THE ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY ISYM.
!     INTEGER LACOV
!        THE LENGTH OF VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
!        THIS ROUTINE WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA
!        THE STARTING LOCATION IN ISTAK FOR THE ARRAY CONTAINING
!        THE NUMBERS OF LAGGED PRODUCT PAIRS USED FOR EACH ACVF.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL SPCF(ISPCF,NW)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY WINDOW.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY XAXIS.
!     REAL Y(N)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY YAXIS.
!     REAL YMISS
!        THE MISSING VALUE CODE FOR THE SERIES.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'U','F','S','M','S',' '/
!
!     SET UP
!
      option(4) = .true.
      option(3) = .false.
      option(2) = .true.
      option(1) = .false.
!
!     SET MAXIMUM LAG VALUE TO BE USED.
!
      lagmax = n - 1
      if (nw.le.0) go to 20
      lagmax = lags(1)
      do 10 i=1,nw
         lagmax = max(lagmax,lags(i))
   10 continue
   20 continue
      lacov = lagmax + 1
      lnlppa = lagmax + 1
!
!     COMPUTE MINIMUM ALLOWABLE STACK LENGTH
!
      io = 1
      if (nprt.eq.0) io = 0
!
     call ldscmp(6, 0, lagmax+1+io*(nf+5), 0, 0, 0, 'S',&
     &   2*lagmax+2+io*(2*nf+10), ldsmin)
!
      ly = n
      lnlppa = lacov
      lpcv = nf + 5
      lwork = lagmax+1
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!     SET THE STACK ALLOCATION TYPE.
!
      call stkset(ldstak, 4)
      nall0 = stkst(1)
!
      ifp = 3
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
!
      if ((ldsmin.gt.ldstak) .or. (ldsmin.le.6)) then
         nlppa = 1
         acov = 1
         work = 1
         xaxis = 1
         yaxis = 1
         isym = 1
         isort = 1
      else
         nlppa = stkget(lacov,2)
         acov = stkget(lacov,ifp)
         work = stkget(lwork,ifp)
         if (nprt.ne.0) then
            xaxis = stkget(lpcv,ifp)
            yaxis = stkget(lpcv,ifp)
            isym = stkget(lpcv,2)
            isort = isym
         else
            xaxis = work
            yaxis = work
            isym = work
            isort = isym
         end if
      end if
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!     FOR SERIES WITH MISSING DATA.
!
     call ufsdrv(y, ly, ymiss, rstak(acov), istak(nlppa), spcf, ispcf,&
    &   nf, fmin, fmax, freq, n, nw, lagmax, lags, rstak(work), lacov,&
    &   lwork, delta, istak(isort), istak(isym), rstak(xaxis),&
    &   rstak(yaxis), lpcv, alpha, nprt, parzen, nmsub, ldsmin, ldstak,&
     &   option, lnlppa, ly)
!
      call stkclr(nall0)
!
!     CHECK FOR ERRORS
!
      if (ierr.eq.0) return
!
      if (ierr.eq.2) call ecvf(nmsub)
      ierr = 1
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL UFSMS (Y, YMISS, N,'/&
    &   '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/&
     &   '      +            SPCF, ISPCF, FREQ, LDSTAK)')
      end
!PPFCHS
      real(kind=wp) function ppfchs(p, nu)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS FUNCTION IS A VERSION OF DATAPAC SUBROUTINE CHSPPF, WITH
!     MODIFICATIONS TO FACILITATE CONVERSION TO DOUBLE PRECISION
!     AUTOMATICALLY USING THE NAG, INC., CODE APT, AND TO CORRESPOND
!     TO STARPAC CONVENTIONS.
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE CHI-SQUARED DISTRIBUTION
!              WITH INTEGER DEGREES OF FREEDOM PARAMETER = NU.
!              THE CHI-SQUARED DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL NON-NEGATIVE X,
!              AND ITS PROBABILITY DENSITY FUNCTION IS GIVEN
!              IN REFERENCES 2, 3, AND 4 BELOW.
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0E0 (INCLUSIVELY)
!                                AND 1.0E0 (EXCLUSIVELY))
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!                     --NU     = THE INTEGER NUMBER OF DEGREES
!                                OF FREEDOM.
!                                NU SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--PPFCHS = THE SINGLE PRECISION PERCENT
!                                POINT FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT FUNCTION .
!             VALUE PPFCHS FOR THE CHI-SQUARED DISTRIBUTION
!             WITH DEGREES OF FREEDOM PARAMETER = NU.
!     PRINTING--DECEMBER 2, 1985  (JRD) UNLESS AN INPUT ARGUMENT ERROR C
!     RESTRICTIONS--NU SHOULD BE A POSITIVE INTEGER VARIABLE.
!                 --P SHOULD BE BETWEEN 0.0E0 (INCLUSIVELY)
!                   AND 1.0E0 (EXCLUSIVELY).
!     OTHER DATAPAC   SUBROUTINES NEEDED--NONE
!     FORTRAN LIBRARY SUBROUTINES NEEDED--EXP, LOG.
!     MODE OF INTERNAL OPERATIONS--REAL.
!     LANGUAGE--ANSI FORTRAN.
!     ACCURACY--(ON THE UNIVAC 1108, EXEC 8 SYSTEM AT NBS)
!               COMPARED TO THE KNOWN NU = 2 (EXPONENTIAL)
!               RESULTS, AGREEMENT WAS HAD OUT TO 6 SIGNIFICANT
!               DIGITS FOR ALL TESTED P IN THE RANGE P = .001 TO
!               P = .999.  FOR P = .95 AND SMALLER, THE AGREEMENT
!               WAS EVEN BETTER--7 SIGNIFICANT DIGITS.
!               (NOTE THAT THE TABULATED VALUES GIVEN IN THE WILK,
!               GNANADESIKAN, AND HUYETT REFERENCE BELOW, PAGE 20,
!               ARE IN ERROR FOR AT LEAST THE GAMMA = 1 CASE--
!               THE WORST DETECTED ERROR WAS AGREEMENT TO ONLY 3
!               SIGNIFICANT DIGITS (IN THEIR 8 SIGNIFICANT DIGIT TABLE)
!               FOR P = .999.)
!     REFERENCES--WILK, GNANADESIKAN, AND HUYETT, "PROBABILITY
!                 PLOTS FOR THE GAMMA DISTRIBUTION",
!                 TECHNOMETRICS, 1962, PAGES 1-15,
!                 ESPECIALLY PAGES 3-5.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 257, FORMULA 6.1.41,
!                 AND PAGES 940-943.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 166-206.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 46-51.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY (205.03)
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE  301-921-2315
!     ORIGINAL VERSION--SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!
!---------------------------------------------------------------------
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   p
     integer&
     &   nu
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   a,aj,b,c,cut1,cut2,cutoff,den,dx,fp,gamma,&
    &   pcalc,sum,term,xdel,xlower,xmax,xmid,xmin,xmin0,xupper,&
     &   z,z2,z3,z4,z5
     integer&
     &   icount,iloop,iprt,j,maxit
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   d(10)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic exp,log
!
!
      data c/0.918938533204672741e0/
     data d(3),d(4),d(5)&
    &  /+0.793650793650793651e-3,&
    &   -0.595238095238095238e-3,&
     &   +0.8417508417508417151e-3/
     data d(6),d(7),d(8),d(9),d(10)&
    &  /-0.191752691752691753e-2,&
    &   +0.641025641025641025e-2,&
    &   -0.2955065359147712418e-1,&
    &   +0.179644372368830573e0,&
     &   -0.139243221690590111e1/
!
      d(1) = 1.0e0/12.0e0
      d(2) = 1.0e0/360.0e0
!
      call iprint (iprt)
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      if (p.lt.0.0e0 .or. p.ge.1.0e0) then
         write(iprt,1010)
         write(iprt,1030) p
         ppfchs = 0.0e0
         return
      end if
      if(nu.lt.1) then
         write(iprt,1020)
         write(iprt,1040) nu
         ppfchs = 0.0e0
         return
      end if
!
!-----START POINT-----------------------------------------------------
!
!     EXPRESS THE CHI-SQUARED DISTRIBUTION PERCENT POINT
!     FUNCTION IN TERMS OF THE EQUIVALENT GAMMA
!     DISTRIBUTION PERCENT POINT FUNCTION,
!     AND THEN EVALUATE THE LATTER.
!
      fp = p
      gamma = nu/2.0e0
      maxit = 10000
!
!     COMPUTE THE GAMMA FUNCTION USING THE ALGORITHM IN THE
!     NBS APPLIED MATHEMATICS SERIES REFERENCE.
!     THIS GAMMA FUNCTION NEED BE CALCULATED ONLY ONCE.
!     IT IS USED IN THE CALCULATION OF THE CDF BASED ON
!     THE TENTATIVE VALUE OF THE PPFCHS IN THE ITERATION.
!
      z = gamma
      den = 1.0e0
  150 if(z.lt.10.0e0) then
         den = den*z
         z = z+1.0e0
         go to 150
      end if
      z2 = z*z
      z3 = z*z2
      z4 = z2*z2
      z5 = z2*z3
      a = (z-0.5e0)*log(z)-z+c
     b = d(1)/z + d(2)/z3 + d(3)/z5 + d(4)/(z2*z5) + d(5)/(z4*z5) +&
    &    d(6)/(z*z5*z5) + d(7)/(z3*z5*z5) + d(8)/(z5*z5*z5) +&
     &    d(9)/(z2*z5*z5*z5)
!     G = EXP(A+B)/DEN
!
!     DETERMINE LOWER AND UPPER LIMITS ON THE DESIRED 100P
!     PERCENT POINT.
!
      iloop = 1
!     XMIN0 = (FP*GAMMA*G)**(1.0E0/GAMMA)
      xmin0 = exp((1.0e0/gamma)*(log(fp)+log(gamma)+(a+b)-log(den)))
      xmin = xmin0
      xlower = xmin
      xmid = xmin
      xupper = xmin
      icount = 1
  350 continue
      xmax = icount*xmin0
      dx = xmax
      go to 600
  360 if(pcalc.lt.fp) then
         xmin = xmax
         icount = icount+1
         if(icount.le.30000) go to 350
      end if
      xmid = (xmin+xmax)/2.0e0
!
!     NOW ITERATE BY BISECTION UNTIL THE DESIRED ACCURACY IS ACHIEVED.
!
      iloop = 2
      xlower = xmin
      xupper = xmax
      icount = 0
  550 dx = xmid
      go to 600
  560 if(pcalc.ne.fp) then
         if(pcalc.gt.fp) then
            xupper = xmid
            xmid = (xmid+xlower)/2.0e0
         else
            xlower = xmid
            xmid = (xmid+xupper)/2.0e0
         end if
         xdel = xmid-xlower
         if(xdel.lt.0.0e0)xdel = -xdel
         icount = icount+1
         if((xdel.ge.0.0000000001e0) .and. (icount.le.100)) go to 550
      end if
      ppfchs = 2.0e0*xmid
      return
!
!********************************************************************
!     THIS SECTION BELOW IS LOGICALLY SEPARATE FROM THE ABOVE.
!     THIS SECTION COMPUTES A CDF VALUE FOR ANY GIVEN TENTATIVE
!     PERCENT POINT X VALUE AS DEFINED IN EITHER OF THE 2
!     ITERATION LOOPS IN THE ABOVE CODE.
!
!     COMPUTE T-SUB-Q AS DEFINED ON PAGE 4 OF THE WILK, GNANADESIKAN,
!     AND HUYETT REFERENCE
!
  600 sum = 1.0e0/gamma
      term = 1.0e0/gamma
      cut1 = dx-gamma
      cut2 = dx*10000000000.0e0
      do 700 j=1,maxit
         aj = j
         term = dx*term/(gamma+aj)
         sum = sum+term
         cutoff = cut1+(cut2*term/sum)
         if (aj.gt.cutoff) go to 750
  700 continue
      write(iprt,1050)maxit
      write(iprt,1060)p
      write(iprt,1070)nu
      write(iprt,1080)
      ppfchs = 0.0e0
      return
!
  750 continue
!     PCALC = (DX**GAMMA)*(EXP(-DX))*SUM/G
      pcalc = exp(gamma*log(dx) + log(sum) + log(den) - dx - a - b)
      if (iloop.eq.1) go to 360
      go to 560
!
1010 format(' ',115h***** fatal error--the first  input argument to the&
     & ppfchs function is outside the allowable (0,1  ) interval *****)
1020 format(' ', 91h***** fatal error--the second input argument to the&
     & ppfchs function is non-positive *****  )
 1030 format(' ', 35h***** the value of the argument is ,e15.8,6h *****)
 1040 format(' ', 35h***** the value of the argument is ,i8   ,6h *****)
1050 format(' ',48h*****error in internal operations in the ppfchs ,&
     & 43hfunction--the number of iterations exceeds ,i7)
 1060 format(' ',33h     the input value of p     is ,e15.8)
 1070 format(' ',33h     the input value of nu    is ,i8)
 1080 format(52h      the output value of ppfchs has been set to 0.0)
!
      end
!OANOVA
      subroutine oanova(ysum, red, npar, rvar, nnzw, temp, iprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     COMPUTE AND PRINT ANALYSIS OF VARIANCE
!
!     WRITTEN BY DAVID HOGBEN, SEL, NBS.   10/09/69.
!
!     THIS ROUTINE WAS ADAPTED FROM THE OMNITAB ROUTINE OANOVA
!     BY - -
!
!     JANET R. DONALDSON
!     STATISTICAL ENGINEERING DIVISION
!     NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rvar,ysum
     integer&
     &   iprt,nnzw,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   red(npar),temp(npar)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   asum,cr,f1,f2,fplm,pf1,pf2,resms,resss,ssu,v1f2,vr
     integer&
     &   i,k,nsua
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   cdff,r1mach
!       EXTERNAL CDFF,R1MACH
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ASUM
!        *
!     REAL CR
!        *
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     REAL F1
!        *
!     REAL F2
!        *
!     INTEGER I
!        AN INDEX.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER K
!        *
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NSUA
!        *
!     REAL PF1
!        *
!     REAL PF2
!        *
!     REAL RED(NPAR)
!        THE REDUCTION TO THE SUM OF SQUARES DUE TO EACH PARAMETER.
!     REAL RESMS
!        *
!     REAL RESSS
!        *
!     REAL RVAR
!        THE RESIDUAL VARIANCE.
!     REAL SSU
!        *
!     REAL TEMP(NPAR)
!        A WORK VECTOR.
!     REAL VR
!        *
!     REAL V1F2
!        *
!     REAL YSUM
!        THE SUM OF THE WEIGHTED DEPENDENT VARIABLES SQUARED.
!
!
      fplm = r1mach(2)
!
      resms = ysum/nnzw
      nsua = nnzw
      write (iprt,1000)
      asum = 0.0e0
      vr = nnzw-npar
      resss = vr*rvar
      temp(npar) = resss
      if (npar.eq.1) go to 20
      do 10 i=2,npar
         k = npar + 2 - i
         temp(k-1) = temp(k) + red(k)
   10 continue
   20 v1f2 = npar+1
      ssu = nnzw
      do 50 i=1,npar
         nsua = nsua - 1
         asum = asum + red(i)
         ssu = ssu - 1.0e0
         cr = asum/i
         resms = 0.0e0
         if (ssu.gt.0.0e0) resms = temp(i)/ssu
         v1f2 = v1f2 - 1.0e0
!
!     NEVER POOL
!
         if (rvar.gt.0.0e0) go to 30
         f1 = fplm
         f2 = fplm
         pf1 = 0.0e0
         pf2 = 0.0e0
         go to 40
   30    f1 = red(i)/rvar
         pf1 = 1.0e0 - cdff(f1,1.0e0,vr)
!
!     TEST HIGHER SUB-HYPOTHESES
!
         f2 = (temp(i)+red(i)-resss)/v1f2/rvar
         pf2 = 1.0e0 - cdff(f2,v1f2,vr)
   40    continue
        write (iprt,1010) i, red(i), cr, i, resms, nsua, f1, pf1, f2,&
     &      pf2
   50 continue
      write (iprt,1020) resss, nsua
      write (iprt,1030) ysum, nnzw
      return
!
!     FORMAT STATEMENTS
!
1000 format (////50x, 20hanalysis of variance/24x, 16h-dependent on or,&
    &   33hder variables are entered, unless, 21h vectors are orthogon,&
    &   3hal-//&
    &   1x, 5h par , 4x, 14hsum of squares, 63x,&
    &   19h------ par=0 ------, 4x, 19h------ pars=0 -----/&
    &   1x, 5hindex, 4x, 14hred due to par, 7x, 10hcum ms red,&
    &   6x, 9hdf(msred), 6x, 10hcum res ms, 6x, 7hdf(rms), 5x,&
     &   'F', 8x, 7hprob(f), 7x, 'F', 8x, 7hprob(f)/)
1010 format (1x, i3, 6x, g16.9, 3x, g16.9, 1x, i6, 8x, g16.9, 1x, i5,&
     &   4x, g12.6, f7.3, 4x, g12.6, f7.3)
 1020 format (/1x, 10hresidual  , 1x, g14.7, 20x, i6)
 1030 format (1x, 10htotal     , 1x, g14.7, 20x, i6)
      end
!PPFF
      real(kind=wp) function ppff(p, nu1, nu2)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS FUNCTION IS A VERSION OF DATAPLOT SUBROUTINE FPPF,
!     WITH MODIFICATIONS NECESSARY TO CORRESPOND TO STARPAC CONVENTIONS.
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FOR THE F DISTRIBUTION
!              WITH INTEGER DEGREES OF FREEDOM
!              PARAMETERS = NU1 AND NU2.
!              THIS DISTRIBUTION IS DEFINED FOR ALL NON-NEGATIVE X.
!              THE PROBABILITY DENSITY FUNCTION IS GIVEN
!              IN THE REFERENCES BELOW.
!     INPUT  ARGUMENTS--P      = THE SINGLE PRECISION VALUE
!                                (BETWEEN 0.0E0 AND 1.0E0)
!                                AT WHICH THE PERCENT POINT
!                                FUNCTION IS TO BE EVALUATED.
!                     --NU1    = THE INTEGER DEGREES OF FREEDOM
!                                FOR THE NUMERATOR OF THE F RATIO.
!                                NU1 SHOULD BE POSITIVE.
!                     --NU2    = THE INTEGER DEGREES OF FREEDOM
!                                FOR THE DENOMINATOR OF THE F RATIO.
!                                NU2 SHOULD BE POSITIVE.
!     OUTPUT ARGUMENTS--PPFF    = THE SINGLE PRECISION PERCENT POINT
!                                FUNCTION VALUE.
!     OUTPUT--THE SINGLE PRECISION PERCENT POINT
!             FUNCTION VALUE PPFF FOR THE F DISTRIBUTION
!             WITH DEGREES OF FREEDOM
!             PARAMETERS = NU1 AND NU2.
!     PRINTING--NONE UNLESS AN INPUT ARGUMENT ERROR CONDITION EXISTS.
!     RESTRICTIONS--P SHOULD BE BETWEEN
!                   0.0E0 (INCLUSIVELY) AND 1.0E0 (EXCLUSIVELY).
!                 --NU1 SHOULD BE A POSITIVE INTEGER VARIABLE.
!                 --NU2 SHOULD BE A POSITIVE INTEGER VARIABLE.
!     LANGUAGE--ANSI FORTRAN.
!     REFERENCES--NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGES 946-947,
!                 FORMULAE 26.6.4, 26.6.5, 26.6.8, AND 26.6.15.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGE 83, FORMULA 20,
!                 AND PAGE 84, THIRD FORMULA.
!               --PAULSON, AN APPROXIMATE NORMAILIZATION
!                 OF THE ANALYSIS OF VARIANCE DISTRIBUTION,
!                 ANNALS OF MATHEMATICAL STATISTICS, 1942,
!                 NUMBER 13, PAGES 233-135.
!               --SCHEFFE AND TUKEY, A FORMULA FOR SAMPLE SIZES
!                 FOR POPULATION TOLERANCE LIMITS, 1944,
!                 NUMBER 15, PAGE 217.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 CENTER FOR APPLIED MATHEMATICS
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!                 PHONE--301-921-3651
!     NOTE-- THIS ROUTINE WAS ADAPTED FROM DATAPLOT SUBROUTINE
!            FPPF WITH PERMISSION FROM THE AUTHOR.  DATAPLOT IS
!            A REGISTERED TRADEMARK.
!
!           THIS SUBROUTINE MAY NOT BE COPIED, EXTRACTED,
!           MODIFIED, OR OTHERWISE USED IN A CONTEXT
!           OUTSIDE OF THIS LANGUAGE/SYSTEM.
!     LANGUAGE--ANSI FORTRAN (1966)
!     VERSION NUMBER--82.3
!     ORIGINAL VERSION--MAY       1978.
!     UPDATED         --AUGUST    1979.
!     UPDATED         --DECEMBER  1981.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   p
     integer&
     &   nu1,nu2
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   anu1,anu2,expf,pcalc,sdf,tol,x,xdel,xlow,xmax,&
     &   xmid,xmin,xn,xup,zn
     integer&
     &   ibug,icount,iprt,maxit
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   CDFF,PPFNML
!      EXTERNAL CDFF,PPFNML
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,exp,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ANU1
!        THE (REAL) DEGREES OF FREEDOM IN THE NUMERATOR.
!     REAL ANU2
!        THE (REAL) DEGREES OF FREEDOM IN THE DENOMINATOR.
!     REAL EXPF
!        *
!     INTEGER IBUG
!        *
!     INTEGER ICOUNT
!        *
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MAXIT
!        *
!     INTEGER NU1
!        THE DEGREES OF FREEDOM IN THE NUMERATOR.
!     INTEGER  NU2
!        THE DEGREES OF FREEDOM IN THE DENOMINATOR.
!     REAL P
!        THE VALUE (BETWEEN 0.0E0 AND 1.0E0) AT WHICH THE PERCENT POINT
!        IS TO BE CALCULATED.
!     REAL PCALC
!        *
!     REAL SDF
!        *
!     REAL TOL
!        *
!     REAL X
!        *
!     REAL XDEL
!        *
!     REAL XLOW
!        *
!     REAL XMAX
!        *
!     REAL XMID
!        *
!     REAL XMIN
!        *
!     REAL XN
!        *
!     REAL XUP
!        *
!     REAL ZN
!        *
!
!---------------------------------------------------------------------
!
!     COMMON /MACH/IRD,IPR,CPUMIN,CPUMAX,NUMBPC,NUMCPW,NUMBPW
!     COMMON /PRINT/IFEEDB,IPRINT
!
!-----START POINT-----------------------------------------------------
!
!     CHECK THE INPUT ARGUMENTS FOR ERRORS
!
      call iprint(iprt)
!
      ppff = 0.0e0
      if (nu1.le.0) go to 10
      if (nu2.le.0) go to 20
      if (p.lt.0.0e0 .or. p.ge.1.0e0) go to 30
      go to 40
   10 write (iprt,1010)
      write (iprt,1040) nu1
      ppff = 0.0e0
      return
   20 write (iprt,1020)
      write (iprt,1040) nu2
      ppff = 0.0e0
      return
   30 write (iprt,1000)
      write (iprt,1030) p
      ppff = 0.0e0
      return
   40 continue
!
!-----START POINT-----------------------------------------------------
!
      ibug = 0.0e0
!
      tol = 0.000001e0
      maxit = 100
      xmin = 0.0e0
      xmax = 10.0e30
      xlow = xmin
      xup = xmax
!
      anu1 = nu1
      anu2 = nu2
!
      expf = 0.5e0*((1.0e0/anu2)-(1.0e0/anu1))
      sdf = sqrt(0.5e0*((1.0e0/anu2)+(1.0e0/anu1)))
      zn = ppfnml(p)
      xn = expf + zn*sdf
      xmid = exp(2.0e0*xn)
      if (ibug.eq.1) write (iprt,1050) xmid
!
      if (p.eq.0.0e0) go to 50
      go to 60
   50 continue
      ppff = xmin
      return
   60 continue
!
      icount = 0
!
   70 continue
      x = xmid
      pcalc = cdff(x,anu1,anu2)
      if (pcalc.eq.p) go to 130
      if (pcalc.gt.p) go to 100
!
   80 continue
      xlow = xmid
      x = xmid*2.0e0
      if (x.ge.xup) go to 90
      xmid = x
      if (ibug.eq.1) write (iprt,1050) xmid
      pcalc = cdff(x,anu1,anu2)
      if (pcalc.eq.p) go to 130
      if (pcalc.lt.p) go to 80
      xup = x
   90 continue
      xmid = (xlow+xup)/2.0e0
      if (ibug.eq.1) write (iprt,1050) xmid
      go to 120
!
  100 continue
      xup = xmid
      x = xmid/2.0e0
      if (x.le.xlow) go to 110
      xmid = x
      if (ibug.eq.1) write (iprt,1050) xmid
      pcalc = cdff(x,anu1,anu2)
      if (pcalc.eq.p) go to 130
      if (pcalc.gt.p) go to 100
      xlow = x
  110 continue
      xmid = (xlow+xup)/2.0e0
      if (ibug.eq.1) write (iprt,1050) xmid
!
  120 continue
      xdel = abs(xmid-xlow)
      icount = icount + 1
      if (xdel.lt.tol .or. icount.gt.maxit) go to 130
      go to 70
!
  130 continue
      ppff = xmid
!
      return
1000 format (' ', 49h***** fatal error--the first  input argument to t,&
    &   59hhe fppf subroutine is outside the allowable (0,1) interval ,&
     &   5h*****)
1010 format (' ', 49h***** fatal error--the second input argument to t,&
     &   42hhe fppf   subroutine is non-positive *****)
1020 format (' ', 49h***** fatal error--the third  input argument to t,&
     &   42hhe fcdf   subroutine is non-positive *****)
1030 format (' ', 35h***** the value of the argument is , e15.8,&
     &   6h *****)
 1040 format (' ', 35h***** the value of the argument is , i8, 6h *****)
 1050 format (' ', 7hxmid = , e15.7)
      end
!AIMX1
     subroutine aimx1(mxn, mxpar, mxfc, mxfco, mxfac,&
    &   mod, n, mspec, nfac, par, npar, res,&
    &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt,&
    &   npare, rsd, pv, sdpv, sdres, vcv, ivcv,&
     &   nfcst, nfcsto, ifcsto, fcst, ifcst, fcstsd)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     SET THE STARTING PARAMETER VALUES FOR AIMX
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
    &   ifcst,ivaprx,ivcv,mit,mod,mxfac,mxfc,mxfco,mxn,mxpar,n,&
     &   nfac,nfcst,nfcsto,npar,npare,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   fcst(mxfc,*),fcstsd(*),par(*),pv(*),res(*),scale(*),sdpv(*),&
     &   sdres(*),stp(*),vcv(mxpar,*)
     integer&
     &   ifcsto(*),ifixed(*),mspec(4,*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   sqmeps
     integer&
     &   i,j
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL SETRV
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     REAL FCST(MXFC,MXFCO)
!        THE FORECASTS.
!     REAL FCSTSD(MXFC)
!        THE STANDARD DEVIATION OF THE FORECASTS.
!     INTEGER I
!        *
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFCST
!        *
!     INTEGER IFCSTO(MXFCO)
!        THE FORECAST ORIGINS.
!     INTEGER IFIXED(MXPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IVAPRX
!        *
!     INTEGER IVCV
!        THE ACTUAL FIRST DIMENSION OF VCV.
!     INTEGER J
!        *
!     INTEGER MIT
!        *
!     INTEGER MOD
!        AN INDICATOR VALUE USED TO DESIGNATE THE MODEL FOR WHICH
!        THE PARAMETERS ARE TO BE SET.
!     INTEGER MSPEC(4,MXFAC)
!        THE VALUES OF P, D, Q AND S FOR EACH FACTOR.
!     INTEGER MXFAC
!        THE MAXIMUM NUMBER OF FACTORS ALLOWED.
!     INTEGER MXFC
!        THE MAXIMUM NUMBER OF FORECASTS ALLOWED.
!     INTEGER MXFCO
!        THE MAXIMUM NUMBER OF FORECASTS ORIGINS ALLOWED.
!     INTEGER MXN
!        THE MAXIMUM NUMBER OF OBSERVATIONS ALLOWED.
!     INTEGER MXPAR
!        THE MAXIMUM NUMBER OF PARAMETERS ALLOWED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFCST, NFCSTO
!        THE NUMBER OF FORECASTS AND FORCAST ORIGINS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!        TO BE PROVIDED.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
!     INTEGER NPRT
!        *
!     REAL PAR(MXPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL PV(MXN)
!        THE PREDICTED VALUES.
!     REAL RES(MXN)
!        THE RESIDUALS.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     REAL SCALE(MXPAR)
!        THE SCALE VALUES.
!     REAL SDPV(MXN)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUES.
!     REAL SDRES(MXN)
!        THE STANDARDIZED RESIDUALS.
!     REAL SQMEPS, STOPP, STOPSS
!        *
!     REAL STP(MXPAR)
!        THE STEP VALUES.
!     REAL VCV(MXPAR,MXPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!
      go to (10, 20, 30, 40, 50, 60), mod
!
   10 continue
      n = 144
      nfac = 2
      mspec(1,1) = 0
      mspec(2,1) = 1
      mspec(3,1) = 1
      mspec(4,1) = 1
      mspec(1,2) = 0
      mspec(2,2) = 1
      mspec(3,2) = 1
      mspec(4,2) = 12
      npar = 3
      par(1) = 0.0e0
      par(2) = 0.4e0
      par(3) = 0.6e0
      ifixed(1) = 1
      ifixed(2) = 0
      ifixed(3) = 0
!
      go to 70
!
!
   20 par(1) = 1.0e0
      par(2) = 2.0e0
      par(3) = 3.0e0
!
      go to 70
!
!
   30 par(1) = 6.0e0
      par(2) = 5.0e0
      par(3) = 4.0e0
      par(4) = 3.0e0
      par(5) = 2.0e0
!
      go to 70
!
!
   40 call setrv(par, npar, 0.0e0)
!
      go to 70
!
!
   50 call setrv(par, npar, 0.5e0)
!
      go to 70
!
!
   60 par(1) = 100.0e0
      par(2) = 15.0e0
!
   70 continue
!
      sqmeps = sqrt(rmdcon(3,typ=0.0_wp))
!
      mit = 25
      do 80 i=1,10
         stp(i) = sqmeps
         scale(i) = 1.0e0
   80 continue
      stopss = 10.0e-7
      stopp = 10.0e-7
      delta = 0.5e0
      nprt = 11111
      ivaprx = 3
      ivcv = mxpar
!
      nfcst = 36
      nfcsto = 2
      ifcsto(1) = 103
      ifcsto(2) = n
      ifcst = mxfc
!
      do 85 i=1,mxn
         res(i) = -1.0e0
         pv(i) = -1.0e0
         sdpv(i) = -1.0e0
         sdres(i) = -1.0e0
   85 continue
!
      do 100 i=1,mxpar
         do 90 j=1,mxpar
            vcv(i,j) = -1.0e0
   90    continue
  100 continue
!
      do 110 i = 1, mxfc
        fcstsd(i) = -1.0e0
        do 105 j = 1, mxfco
          fcst(i,j) = -1.0e0
  105   continue
  110 continue
!
      npare = -1
      rsd = -1.0e0
!
      ierr = -1
!
      return
!
      end
!STAT2W
     subroutine stat2w(y, wt, n, nnzw, sts, sumda, sumdi, sumwd2,&
     &   sumd2, sumd3, sumd4, sumw)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES FOR A VECTOR Y THE STATISTICS THAT DO
!     NOT REQUIRE SORTING OF THE VECTOR, THAT IS, THOSE NOT COMPUTED
!     BY STAT1W.  WEIGHTS ARE USED IN THE CALCULATIONS.
!
!     THIS SUBROUTINE IS BASED ON A MODIFICATION OF THE STATIS
!     CODE USED IN OMNITAB, VERSION 5 (6/16/72), WRITTEN BY
!     SALLY PEAVY.  THE ORIGINAL ADAPTATION TO STARPAC WAS
!     DONE BY JANET DONALDSON.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   sumd2,sumd3,sumd4,sumda,sumdi,sumw,sumwd2
     integer&
     &   n,nnzw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   sts(53),wt(n),y(n)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   dif,t,ta,tk1,tk2
     integer&
     &   i,ic,ici,icount,idruns,iminus,iplus,irun,j
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   cdff,ppfchs,ppft
!       EXTERNAL CDFF,PPFCHS,PPFT
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,sqrt
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DIF
!        THE SUM OF THE DIFFERENCES BETWEEN SUCCEEDING ELEMENTS
!        IN Y.
!     INTEGER I
!        A LOOP INDEX.
!     INTEGER IC
!        PREVIOUS SIGN IN RUNS CALCULATION.
!     INTEGER ICI
!        CURRENT SIGN IN RUNS CALCULATION.
!     INTEGER ICOUNT
!        USED IN RUNS CALCULATIONS.
!     INTEGER IDRUNS
!        THE NUMBER OF RUNS.
!     INTEGER IERR
!        AN ERROR FLAG SET IN COMMON ERRCHK.
!     INTEGER IMINUS, IPLUS
!        COUNTS OF SIGNS OF DEVIATIONS.
!     INTEGER IRUN
!        THE NUMBER OF RUNS UP AND DOWN.
!     INTEGER J
!        A LOOP INDEX.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y AND WT.
!     INTEGER NNZW
!        INPUT PARAMETER.  THE NUMBER OF POSITIVE ELEMENTS IN WT.
!     REAL STS(53)
!        OUTPUT PARAMETER.  THE VECTOR OF 53 STATISTICS COMPUTED.
!     ROW STATISTIC                    ROW STATISTIC
!         1  LENGTH OF VECTOR             TESTS FOR NONRANDOMNESS
!         2  NUMBER OF NONZERO WEIGHTS    23  NUMBER OF RUNS UP AND DOWN
!        MEASURES OF LOCATION             24  EXPECTED NUMBER OF RUNS
!         3  UNWEIGHTED MEAN              25  S.D. OF NUMBER OF RUNS
!         4  WEIGHTED MEAN                26  MEAN SQR. SUCCESSIVE DIFF.
!         5  MEDIAN                       27  MEAN SQR. SUCC. DIFF./VAR.
!         6  MID-RANGE                    DEVIATIONS FROM WTD MEAN
!         7  25 P.C. UNWTD. TRIMMED MEAN  28  NUMBER OF + SIGNS
!         8  25 P.C. WTD. TRIMMED MEAN    29  NUMBER OF - SIGNS
!        MEASURES OF DISPERSION           30  NUMBER OF RUNS
!         9  STANDARD DEVIATION (S.D.)    31  EXPECTED NUMBER OF RUNS
!        10  S.D. OF MEAN                 32  S.D. OF RUNS
!        11  RANGE                        33  DIFF./S.D. OF RUNS
!        12  MEAN VARIATION               OTHER STATISTICS
!        13  VARIANCE (VAR.)              34  MINIMUM
!        14  COEFFICIENT OF VARIATION     35  MAXIMUM
!        CONFIDENCE INTERVALS             36  BETA 1
!        15  LOWER CONFIDENCE LIMIT, MEAN 37  BETA 2
!        16  UPPER CONFIDENCE LIMIT, MEAN 38  WTD. SUM OF VALUES
!        17  LOWER CONFIDENCE LIMIT, S.D. 39  WTD. SUM OF SQUARES
!        18  UPPER CONFIDENCE LIMIT, S.D. 40  WTD. SUM OF SQRD. DEVS.
!        LINEAR TREND STATISTICS          41  STUDENTS T
!        19  SLOPE                        42  WTD. SUM OF ABS. VALUES
!        20  S.D. OF SLOPE                43  WTD. AVG. ABS. VALUES
!        21  SLOPE/S.D. OF SLOPE = T      44-53 FREQ. DISTRIBUTION
!        22  PROB ( X .GT. ABS(OBS. T))
!     REAL SUMDA
!        INPUT PARAMETER.  THE SUM OF THE ABSOLUTE VALUES OF THE
!        DIFFERENCES DIFF.
!     REAL SUMDI
!        INPUT PARAMETER.  THE SUM OF THE PRODUCTS OF I AND THE
!        ITH DIFFERENCE DIFF.
!     REAL SUMD2
!        INPUT PARAMETER.  THE SUM OF THE SQUARES OF THE
!        DIFFERENCES DIFF.
!     REAL SUMD3
!        INPUT PARAMETER.  THE SUM OF THE CUBES OF THE
!        DIFFERENCES DIFF.
!     REAL SUMD4
!        INPUT PARAMETER.  THE SUM OF THE HYPERCUBES OF THE
!        DIFFERENCES DIFF.
!     REAL SUMW
!        INPUT PARAMETER.  THE SUM OF THE WEIGHTS VECTOR WT.
!     REAL SUMWD2
!        INPUT PARAMETER.  THE WEIGHTED SUM OF THE SQUARED
!        DIFFERENCES DIFF.
!     REAL T
!        A RESIDUAL (Y(I) - MEANY)
!     REAL TA
!        A TEMPORARY VARIABLE IN THE RUNS CALCULATION.
!     REAL TK1, TK2
!        CHI-SQUARED VALUES.
!     REAL WT(N)
!        INPUT PARAMETER.  THE VECTOR OF WEIGHTS FOR THE
!        Y OBSERVATIONS.
!     REAL Y(N)
!        INPUT PARAMETER.  A SET OF N DATA POINTS, SORTED
!        INTO ASCENDING ORDER.
!
!
!     BEGIN STORAGE OF STATISTICS.
!
      sts(1) = n
      sts(2) = nnzw
      sts(24) = (2.0e0*sts(2)-1.0e0)/3.0e0
      sts(25) = sqrt((16.0e0*sts(2)-29.0e0)/90.0e0)
      sts(43) = sts(42)/sumw
!
!     COMPUTE RESIDUALS AND STANDARD DEVIATIONS.
!
      ici = 0
      iplus = 0
      iminus = 0
      idruns = 0
      ic = 0
      do 30 i=1,n
         if (wt(i).le.0.0e0) go to 30
         t = y(i) - sts(4)
         if (t.lt.0.0e0) go to 10
         iplus = iplus + 1
         ici = 1
         go to 20
   10    iminus = iminus + 1
         ici = -1
   20    if (ic.eq.ici) go to 30
         ic = ici
         idruns = idruns + 1
   30 continue
      sts(28) = iplus
      sts(29) = iminus
      sts(31) = 1.0e0 + (2.0e0*sts(28)*sts(29)/sts(2))
     sts(32) =&
    &   sqrt((2.0e0*sts(28)*sts(29)*(2.0e0*sts(28)*sts(29)-&
    &                                     sts(28)-sts(29)))/&
     &        ((sts(28)+sts(29))**2*(sts(2)-1.0e0)))
      sts(30) = idruns
      sts(33) = 0.0e0
     if (sts(32).ne.0.0e0)&
     &   sts(33) = (sts(30)-sts(31))/sts(32)
      sts(13) = sumwd2/(sts(2)-1.0e0)
      sts(9) = sqrt(sts(13))
      sts(10) = sts(9)/(sqrt(sumw))
     if (sts(4).ne.0.0e0)&
     &   sts(14) = 100.0e0*abs(sts(9)/sts(4))
      if (sts(4).eq.0.0e0) sts(14) = 0.0e0
      sts(36) = 0.0e0
     if (sumd2.ne.0.0e0)&
     &   sts(36) = (sumd3/sts(2))**2/((sumd2/sts(2))**3)
      sts(37) = 0.0e0
     if (sumd2.ne.0.0e0)&
     &   sts(37) = (sumd4/sts(2))/((sumd2/sts(2))**2)
      sts(40) = sumwd2
      sts(19) = (12.0e0*sumdi)/(sts(2)*(sts(2)**2-1.0e0))
     sts(20) = (1.0e0/(sts(2)-2.0e0)*&
    &             (12.0e0*(sumd2/(sts(2)*(sts(2)**2-1.0e0)))-&
     &              sts(19)**2))
      if (sts(20).le.0.0e0) sts(20) = 0.0e0
      sts(20) = sqrt(sts(20))
      if (sts(20).eq.0.0e0) sts(21) = 0.0e0
      if (sts(20).gt.0.0e0) sts(21) = sts(19)/sts(20)
!
      sts(22) = 1.0e0 - cdff(sts(21)*sts(21), 1.0e0, sts(2)-2.0e0)
!
!     COMPUTE NUMBER OF RUNS IN THE DATA.
!
      dif = 0.0e0
      irun = 1
      ta = 0.0e0
      do 50 i=1,n
         if (i.ge.n) go to 60
         if (wt(i).le.0.0e0) go to 50
         j = i
   40    j = j + 1
         if (j.ge.n) go to 60
         if (wt(j).le.0.0e0) go to 40
         ta = y(j) - y(i)
         if (ta.ne.0.0e0) go to 60
   50 continue
   60 icount = 0
      do 80 i=1,n
         if (wt(i).le.0.0e0) go to 80
         icount = icount + 1
         if (icount.ge.nnzw) go to 80
         j = i
   70    j = j + 1
         if (wt(j).le.0.0e0) go to 70
         t = y(j) - y(i)
         dif = dif + t*t
         if (ta*t.ge.0.0e0) go to 80
         ta = t
         irun = irun + 1
   80 continue
      sts(23) = irun
      sts(26) = dif/(sts(2)-1.0e0)
      sts(27) = 0.0e0
     if (sts(13).ne.0.0e0)&
     &   sts(27) = sts(26)/sts(13)
      sts(41) = 0.0e0
     if (sts(9).ne.0.0e0)&
     &   sts(41) = (sts(4)*sqrt(sumw))/sts(9)
      sts(12) = sumda/sts(2)
      t = ppft(0.975e0, nnzw-1)
      tk1 = ppfchs(0.975e0, nnzw-1)
      tk2 = ppfchs(0.025e0, nnzw-1)
      sts(15) = sts(4) - t*sts(10)
      sts(16) = sts(4) + t*sts(10)
      sts(17) = sqrt((sts(2)-1.0e0)/tk1)*sts(9)
      sts(18) = sqrt((sts(2)-1.0e0)/tk2)*sts(9)
      return
      end
!XDFLT
      subroutine xdflt(lds,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE TIME SERIES DIGITAL FILTERING AND
!     COMPLEX DEMODULATION ROUTINES.
!
!     SERIES Y IS THE WOLF SUNSPOT DATA FROM 1700 TO 1960 AS
!     TABULATED BY WALDMEIER
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lds
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
      real(kind=wp) :: fc,fmax,fmin,yfmiss,ymiss
     integer&
     &   i,iar,iprt,itest,k,ldstak,lphi,n,nf,nfac,nprt,nyf,nys
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   freq(101),gain(101),hhp(50),hlp(50),phas(300),phi(50),y(300),&
     &   yf(300),ys(300)
     integer&
     &   iod(10),nd(10)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ARFLT,DIF,DIFC,DIFM,DIFMC,GFARF,GFARFS,GFSLF,GFSLFS,
!     +   HIPASS,HPCOEF,IPRINT,LOPASS,LPCOEF,MAFLT,SAMPLE,SLFLT
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FC
!        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
!     REAL FMAX, FMIN
!        THE MINIMUM AND MAXIMUM FREQUENCY FOR WHICH THE GAIN
!        FUNCTION IS TO BE ESTIMATED.
!     REAL FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        HAS BEEN ESTIMATED.
!     REAL GAIN(101)
!        THE VECTOR IN WHICH THE GAIN FUNCTION ESTIMATES ARE
!        STORED.
!     REAL HHP(50)
!        THE ARRAY IN WHICH THE -IDEAL- HIGH PASS FILTER COEFFICIENTS
!        WILL BE RETURNED.
!     REAL HLP(50)
!        THE ARRAY IN WHICH THE INPUT LOW PASS FILTER COEFFICIENTS
!        ARE STORED.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IOD(10)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER ITEST
!        THE NUMBER OF THE TEST BEING PERFORMED
!     INTEGER K
!        THE NUMBER OF TERMS IN THE SYMETRIC LINEAR FILTER.
!     INTEGER LDS, LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE INPUT SERIES.
!     INTEGER ND(10)
!        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE
!        FACTORS ARE TO BE APPLIED.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        IS TO BE ESTIMATED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT = 1 THE PLOT IS DECIBELS/LINEAR
!        NPRT = 2 THE PLOT IS LOG/LINEAR
!     INTEGER NYF
!        THE NUMBER OF VALUES IN THE FILTERED SERIES.
!     INTEGER NYS
!        THE NUMBER OF VALUES IN THE SAMPLED SERIES.
!     REAL PHAS(300)
!        THE ARRAY IN WHICH THE PRIMARY PHASE ESTIMATES ARE RETURNED.
!     REAL PHI(50)
!        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
!     REAL Y(300)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YF(300)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!     REAL YFMISS
!        THE MISSING VALUE CODE USED IN THE FILTERED SERIES.
!     REAL YMISS
!        THE MISSING VALUE CODE USED IN THE INPUT TIME SERIES.
!     REAL YS(300)
!        THE ARRAY CONTAINING THE SAMPLED SERIES.
!
     data   y(  1),  y(  2),  y(  3),  y(  4),  y(  5),  y(  6)&
     &    /     5.0e0, 11.0e0, 16.0e0, 23.0e0, 36.0e0, 58.0e0/
     data   y(  7),  y(  8),  y(  9),  y( 10),  y( 11),  y( 12)&
     &    /    29.0e0, 20.0e0, 10.0e0,  8.0e0,  3.0e0,  0.0e0/
     data   y( 13),  y( 14),  y( 15),  y( 16),  y( 17),  y( 18)&
     &    /     0.0e0, 2.0e0, 11.0e0, 27.0e0, 47.0e0, 63.0e0/
     data   y( 19),  y( 20),  y( 21),  y( 22),  y( 23),  y( 24)&
     &    /    60.0e0, 39.0e0, 28.0e0, 26.0e0, 22.0e0, 11.0e0/
     data   y( 25),  y( 26),  y( 27),  y( 28),  y( 29),  y( 30)&
     &    /    21.0e0, 40.0e0, 78.0e0,122.0e0,103.0e0, 73.0e0/
     data   y( 31),  y( 32),  y( 33),  y( 34),  y( 35),  y( 36)&
     &    /    47.0e0, 35.0e0, 11.0e0,  5.0e0, 16.0e0, 34.0e0/
     data   y( 37),  y( 38),  y( 39),  y( 40),  y( 41),  y( 42)&
     &    /    70.0e0, 81.0e0,111.0e0,101.0e0, 73.0e0, 40.0e0/
     data   y( 43),  y( 44),  y( 45),  y( 46),  y( 47),  y( 48)&
     &    /    20.0e0, 16.0e0,  5.0e0, 11.0e0, 22.0e0, 40.0e0/
     data   y( 49),  y( 50),  y( 51),  y( 52),  y( 53),  y( 54)&
     &    /    60.0e0, 80.9e0, 83.4e0, 47.7e0, 47.8e0, 30.7e0/
     data   y( 55),  y( 56),  y( 57),  y( 58),  y( 59),  y( 60)&
     &    /    12.2e0,  9.6e0, 10.2e0, 32.4e0, 47.6e0, 54.0e0/
     data   y( 61),  y( 62),  y( 63),  y( 64),  y( 65),  y( 66)&
     &    /    62.9e0, 85.9e0, 61.2e0, 45.1e0, 36.4e0, 20.9e0/
     data   y( 67),  y( 68),  y( 69),  y( 70),  y( 71),  y( 72)&
     &    /    11.4e0, 37.8e0, 69.8e0,106.1e0,100.8e0, 81.6e0/
     data   y( 73),  y( 74),  y( 75),  y( 76),  y( 77),  y( 78)&
     &    /    66.5e0, 34.8e0, 30.6e0,  7.0e0, 19.8e0, 92.5e0/
     data   y( 79),  y( 80),  y( 81),  y( 82),  y( 83),  y( 84)&
     &    /   154.4e0,125.9e0, 84.8e0, 68.1e0, 38.5e0, 22.8e0/
     data   y( 85),  y( 86),  y( 87),  y( 88),  y( 89),  y( 90)&
     &    /    10.2e0, 24.1e0, 82.9e0,132.0e0,130.9e0,118.1e0/
     data   y( 91),  y( 92),  y( 93),  y( 94),  y( 95),  y( 96)&
     &    /    89.9e0, 66.6e0, 60.0e0, 46.9e0, 41.0e0, 21.3e0/
     data   y( 97),  y( 98),  y( 99),  y(100),  y(101),  y(102)&
     &    /    16.0e0,  6.4e0,  4.1e0,  6.8e0, 14.5e0, 34.0e0/
     data   y(103),  y(104),  y(105),  y(106),  y(107),  y(108)&
     &    /    45.0e0, 43.1e0, 47.5e0, 42.2e0, 28.1e0, 10.1e0/
     data   y(109),  y(110),  y(111),  y(112),  y(113),  y(114)&
     &    /     8.1e0,  2.5e0,  0.0e0,  1.4e0,  5.0e0, 12.2e0/
     data   y(115),  y(116),  y(117),  y(118),  y(119),  y(120)&
     &    /    13.9e0, 35.4e0, 45.8e0, 41.1e0, 30.1e0, 23.9e0/
     data   y(121),  y(122),  y(123),  y(124),  y(125),  y(126)&
     &    /    15.6e0,  6.6e0,  4.0e0,  1.8e0,  8.5e0, 16.6e0/
     data   y(127),  y(128),  y(129),  y(130),  y(131),  y(132)&
     &    /    36.3e0, 49.6e0, 64.2e0, 67.0e0, 70.9e0, 47.8e0/
     data   y(133),  y(134),  y(135),  y(136),  y(137),  y(138)&
     &    /    27.5e0,  8.5e0, 13.2e0, 56.9e0,121.5e0,138.3e0/
     data   y(139),  y(140),  y(141),  y(142),  y(143),  y(144)&
     &    /   103.2e0, 85.7e0, 64.6e0, 36.7e0, 24.2e0, 10.7e0/
     data   y(145),  y(146),  y(147),  y(148),  y(149),  y(150)&
     &    /    15.0e0, 40.1e0, 61.5e0, 98.5e0,124.7e0, 96.3e0/
     data   y(151),  y(152),  y(153),  y(154),  y(155),  y(156)&
     &    /    66.6e0, 64.5e0, 54.1e0, 39.0e0, 20.6e0,  6.7e0/
     data   y(157),  y(158),  y(159),  y(160),  y(161),  y(162)&
     &    /     4.3e0, 22.7e0, 54.8e0, 93.8e0, 95.8e0, 77.2e0/
     data   y(163),  y(164),  y(165),  y(166),  y(167),  y(168)&
     &    /    59.1e0, 44.0e0, 47.0e0, 30.5e0, 16.3e0,  7.3e0/
     data   y(169),  y(170),  y(171),  y(172),  y(173),  y(174)&
     &    /    37.6e0, 74.0e0,139.0e0,111.2e0,101.6e0, 66.2e0/
     data   y(175),  y(176),  y(177),  y(178),  y(179),  y(180)&
     &    /    44.7e0, 17.0e0, 11.3e0, 12.4e0,  3.4e0,  6.0e0/
     data   y(181),  y(182),  y(183),  y(184),  y(185),  y(186)&
     &    /    32.3e0, 54.3e0, 59.7e0, 63.7e0, 63.5e0, 52.2e0/
     data   y(187),  y(188),  y(189),  y(190),  y(191),  y(192)&
     &    /    25.4e0, 13.1e0,  6.8e0,  6.3e0,  7.1e0, 35.6e0/
     data   y(193),  y(194),  y(195),  y(196),  y(197),  y(198)&
     &    /    73.0e0, 85.1e0, 78.0e0, 64.0e0, 41.8e0, 26.2e0/
     data   y(199),  y(200),  y(201),  y(202),  y(203),  y(204)&
     &    /    26.7e0, 12.1e0,  9.5e0,  2.7e0,  5.0e0, 24.4e0/
     data   y(205),  y(206),  y(207),  y(208),  y(209),  y(210)&
     &    /    42.0e0, 63.5e0, 53.8e0, 62.0e0, 48.5e0, 43.9e0/
     data   y(211),  y(212),  y(213),  y(214),  y(215),  y(216)&
     &    /    18.6e0,  5.7e0,  3.6e0,  1.4e0,  9.6e0, 47.4e0/
     data   y(217),  y(218),  y(219),  y(220),  y(221),  y(222)&
     &    /    57.1e0,103.9e0, 80.6e0, 63.6e0, 37.6e0, 26.1e0/
     data   y(223),  y(224),  y(225),  y(226),  y(227),  y(228)&
     &    /    14.2e0,  5.8e0, 16.7e0, 44.3e0, 63.9e0, 69.0e0/
     data   y(229),  y(230),  y(231),  y(232),  y(233),  y(234)&
     &    /    77.8e0, 64.9e0, 35.7e0, 21.2e0, 11.1e0,  5.7e0/
     data   y(235),  y(236),  y(237),  y(238),  y(239),  y(240)&
     &    /     8.7e0, 36.1e0, 79.7e0,114.4e0,109.6e0, 88.8e0/
     data   y(241),  y(242),  y(243),  y(244),  y(245),  y(246)&
     &    /    67.8e0, 47.5e0, 30.6e0, 16.3e0,  9.6e0, 33.2e0/
     data   y(247),  y(248),  y(249),  y(250),  y(251),  y(252)&
     &    /    92.6e0,151.6e0,136.3e0,134.7e0, 83.9e0, 69.4e0/
     data   y(253),  y(254),  y(255),  y(256),  y(257),  y(258)&
     &    /    31.5e0, 13.9e0,  4.4e0, 38.0e0,141.7e0,190.2e0/
     data   y(259),  y(260),  y(261)&
     &    /   184.8e0,159.0e0,112.3e0/
!
      call iprint(iprt)
      itest = 1
      ldstak = lds
!
      n = 261
      nprt = 2
      fc = 1.0e0/22.0e0
      nf = 101
      fmin = 0.0e0
      fmax = 0.2e0
      lphi = 50
      nfac = 1
      nd(1) = 1
      iod(1) = 1
      iar = 1
      phi(1) = 0.6e0
      k = 41
      ymiss = 11.0e0
!
!     TEST OF LPCOEF
!
   10 write (iprt, 1001)
      call lpcoef (fc, k, hlp)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM LPCOEF
!
      if (ierr.eq.0) write (iprt, 1004) (hlp(i), i = 1, k)
!
!     TEST OF LOPASS
!
      write (iprt, 1007)
      call lopass (y, n, fc, k, hlp, yf, nyf)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM LOPASS
!
      if (ierr.eq.0) then
        write (iprt, 1004) (hlp(i), i = 1, k)
        write (iprt, 1004) (yf(i), i = 1, nyf)
      end if
!
!     TEST OF HIPASS
!
      write (iprt, 1008)
      call hipass (y, n, fc, k, hhp, yf, nyf)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM HIPASS
!
      if (ierr.eq.0) then
        write (iprt, 1004) (hhp(i), i = 1, k)
        write (iprt, 1004) (yf(i), i = 1, nyf)
      end if
!
!     TEST OF HPCOEF
!
   20 write (iprt, 1003)
      call hpcoef (hlp, k, hhp)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM HPCOEF
!
      if (ierr.eq.0) write (iprt, 1004) (hhp(i), i = 1, k)
!
!     TEST OF MAFLT
!
      write (iprt, 1020)
      call maflt (y, n, k, yf, nyf)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM MAFLT
!
      if (ierr.eq.0) write (iprt, 1004) (yf(i), i = 1, nyf)
!
!     TEST OF SLFLT
!
      write (iprt, 1005)
      call slflt (y, n, k, hlp, yf, nyf)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM SLFLT
!
      if (ierr.eq.0) write (iprt, 1004) (yf(i), i = 1, nyf)
!
!     TEST OF SAMPLE
!
      write (iprt, 1006)
      call sample (yf, n, k, ys, nys)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM SAMPLE
!
      if (ierr.eq.0) write (iprt, 1004) (yf(i), i = 1, nys)
!
!     TEST OF ARFLT
!
      write (iprt, 1009)
      call arflt (y, n,  iar, phi, yf, nyf)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM ARFLT
!
      if (ierr.eq.0) write (iprt, 1004) (yf(i), i = 1, nyf)
!
!     TEST OF DIF
!
      write (iprt, 1015)
      call dif (y, n, yf, nyf)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM DIF
!
      if (ierr.eq.0) write (iprt, 1004) (yf(i), i = 1, nyf)
!
!     TEST OF DIFM
!
      write (iprt, 1018)
      call difm (y, ymiss, n, yf, yfmiss, nyf)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM DIFM
!
      if (ierr.eq.0) then
         write (iprt, 1004) (yf(i), i = 1, nyf)
         write (iprt, 1004) yfmiss
      end if
!
!     TEST OF GFSLF
!
      write (iprt, 1011)
      call gfslf (hlp, k)
      write (iprt, 1002) ierr
!
!     TEST OF GFARF
!
      write (iprt, 1013)
      call gfarf (phi, iar)
      write (iprt, 1002) ierr
!
!     TEST OF DIFC
!
   30 write (iprt, 1010)
      call difc (y, n, nfac, nd, iod, iar, phi, lphi, yf, nyf, ldstak)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM DIFC
!
      if (ierr.eq.0) then
        write (iprt, 1004) (phi(i), i = 1, k)
        write (iprt, 1004) (yf(i), i = 1, nyf)
      end if
!
!     TEST OF DIFMC
!
      write (iprt, 1019)
     call difmc (y, ymiss, n, nfac, nd, iod, iar, phi, lphi, yf,&
     &   yfmiss, nyf, ldstak)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM DIFMC
!
      if (ierr.eq.0) then
        write (iprt, 1004) (phi(i), i = 1, k)
        write (iprt, 1004) (yf(i), i = 1, nyf)
        write (iprt, 1004) yfmiss
      end if
!
!     TEST OF GFSLFS
!
      write (iprt, 1012)
      call gfslfs (hlp, k, nf, fmin, fmax, gain, freq, nprt, ldstak)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM GFSLFS
!
      if (ierr.eq.0) then
        write (iprt, 1004) (gain(i), i = 1, nf)
        write (iprt, 1004) (freq(i), i = 1, nf)
      end if
!
!     TEST OF GFARFS
!
      write (iprt, 1014)
     call gfarfs (phi, iar, nf, fmin, fmax, gain, phas, freq, nprt,&
     &   ldstak)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM GFARFS
!
      if (ierr.eq.0) then
        write (iprt, 1004) (gain(i), i = 1, nf)
        write (iprt, 1004) (phas(i), i = 1, nf)
        write (iprt, 1004) (freq(i), i = 1, nf)
      end if
!
      go to (100, 200, 300, 400), itest
!
!     TEST SPECIAL CASES
!
  100 itest = itest + 1
!
!     TEST OF GFSLFS
!
      fmin = 0.4e0
      fmax = 0.1e0
      nprt = 1
      write (iprt, 1012)
      call gfslfs (hlp, k, nf, fmin, fmax, gain, freq, nprt, ldstak)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM GFSLFS
!
      if (ierr.eq.0) then
        write (iprt, 1004) (gain(i), i = 1, nf)
        write (iprt, 1004) (freq(i), i = 1, nf)
      end if
!
!     TEST OF GFARFS
!
      nprt = -1
      write (iprt, 1014)
     call gfarfs (phi, iar, nf, fmin, fmax, gain, phas, freq, nprt,&
     &   ldstak)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM GFARFS
!
      if (ierr.eq.0) then
        write (iprt, 1004) (gain(i), i = 1, nf)
        write (iprt, 1004) (phas(i), i = 1, nf)
        write (iprt, 1004) (freq(i), i = 1, nf)
      end if
!
!     TEST MINIMUM PROBLEM SIZE
!
      n = 3
      k = 1
      nprt = -1
      iar = 1
      nf = 1
      go to 20
!
!     TEST ERROR CONDITIONS
!
  200 itest = itest + 1
      n = -5
      fc = 1.0e0
      nf = 0
      lphi = 0
      nfac = 1
      nd(1) = -1
      iod(1) = -1
      iar = 0
      k = -1
      go to 10
!
!     TEST LDSTAK
!
  300 itest = itest + 1
      n = 261
      nprt = 2
      fc = 1.0e0/22.0e0
      nf = 101
      fmin = 0.0e0
      fmax = 0.2e0
      lphi = 50
      nfac = 1
      nd(1) = 1
      iod(1) = 1
      iar = 1
      phi(1) = 0.6e0
      k = 41
      ymiss = 11.0e0
      ldstak = 0
      go to 30
!
  400 return
!
!     FORMAT STATEMENTS
!
 1001 format ('1', 14htest of lpcoef)
 1002 format (/' IERR IS ', i5)
 1003 format ('1', 14htest of hpcoef)
 1004 format (10e10.3)
 1005 format ('1', 13htest of slflt)
 1006 format ('1', 14htest of sample)
 1007 format ('1', 14htest of lopass)
 1008 format ('1', 14htest of hipass)
 1009 format ('1', 13htest of arflt)
 1010 format ('1', 12htest of difc)
 1011 format ('1', 13htest of gfslf)
 1012 format ('1', 14htest of gfslfs)
 1013 format ('1', 13htest of gfarf)
 1014 format ('1', 14htest of gfarfs)
 1015 format ('1', 11htest of dif)
 1018 format ('1', 12htest of difm)
 1019 format ('1', 13htest of difmc)
 1020 format ('1', 13htest of maflt)
!
      end
!AMFCNT
     subroutine amfcnt(y, n, mspec, nfac, par, npar, ldstak,&
     &   nfcst, nfcsto, ifcsto, nprt, fcst, ifcst, fcstsd, nmsub, save)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR FORECASTING USING
!     ARIMA MODELS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ifcst,ldstak,n,nfac,nfcst,nfcsto,npar,nprt
     logical&
     &   save
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   fcst(*),fcstsd(*),par(*),y(*)
     integer&
     &   ifcsto(*),mspec(4,*)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
    &   ierr,iflag,mbo,mbol,mspect,nfact,nparar,npardf,nparma,&
     &   nrests,parar,pardf,parma,t,temp
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   f,fsd,ifp,is,ldsmin,nall0,pv
     logical&
     &   page,wide
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
!
!  EXTERNAL FUNCTIONS
     integer&
     &   stkst
!       EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL AMFER,AMFMN,BACKOP,CPYVII,LDSCMP,STKCLR,STKSET
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
     common /mdltsc/mspect,nfact,pardf,npardf,parar,nparar,parma,&
     &   nparma,mbo,mbol,t,temp,nrests,iflag
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER F
!        THE STARTING LOCATION IN THE WORK VECTOR FOR
!        THE FORECASTS.
!     REAL FCST(IFCST,NFCSTO)
!        THE STORAGE ARRAY FOR THE FORECASTS.
!     REAL FCSTSD(NFCST)
!        THE STORAGE ARRAY FOR THE STANDARD DEVIATIONS OF THE FORECASTS.
!     INTEGER FSD
!        THE STARTING LOCATION IN THE WORK VECTOR FOR
!        THE STANDARD DEVIATIONS OF THE FORECASTS.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFCST
!        THE FIRST DIMENSION OF THE ARRAY FCST.
!     INTEGER IFCSTO(NFCSTO)
!        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
!     INTEGER IFP
!        AN INDICATOR FOR THE PRECISION OF THE STACK ALLOCATION TYPE,
!        WHERE IFP=3 INDICATES SINGLE AND IFP=4 INDICATES DOUBLE.
!     INTEGER IS
!        A VALUE USED TO DETERMINE THE AMOUNT OF WORK SPACE NEEDED
!        BASED ON WHETHER STEP SIZES ARE INPUT OR ARE TO BE CALCULATED.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBOL
!        THE MAXIMUM BACK ORDER ON THE LEFT
!     INTEGER MSPEC(4,NFAC)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER MSPECT
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        NUMBER OF STACK ALLOCATIONS OUTSTANDING.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFACT
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFCST
!        THE NUMBER OF FORECASTS.
!     INTEGER NFCSTO
!        THE NUMBER OF THE ORIGINS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARAR
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE AUTOREGRESSIVE PARAMETERS
!     INTEGER PARDF
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
!     INTEGER PARMA
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE MOVING AVERAGE PARAMETERS
!     INTEGER PV
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE PREDICTED VALUES
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     INTEGER T
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR.
!     INTEGER TEMP
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!     SET VARIOUS PROGRAM VALUES
!
      wide = .true.
      page = .false.
!
!     COMPUTE BACK OPERATORS
!
      call backop(mspec, nfac, npardf, mbol, mbo, nparma, nparar)
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      is = 0
!
     call ldscmp(8, 0, 4*nfac,&
     &   0, 0, 0, 'S', 5*mbo + 2*nfcst + n + mbo + 101, ldsmin)
!
     call amfer(nmsub, n, npar, ldstak, ldsmin, save, mspec, nfac,&
     &   ifcst, nfcst)
!
      if (ierr.eq.0) then
!
        call stkset(ldstak, 4)
!
!       SUBDIVIDE WORKSPACE FOR STEP SIZES
!
        nall0 = stkst(1)
!
        ifp = 3
!
        pardf = stkget(mbo, ifp)
        parar = stkget(mbo, ifp)
        parma = stkget(mbo, ifp)
        t = stkget(2*mbo, ifp)
!
        temp = t + mbo
!
        nfact = nfac
        mspect = stkget(4*nfac, 2)
        f = stkget(nfcst, ifp)
        fsd = stkget(nfcst, ifp)
!
!       SET UP FOR MODEL
!
        nrests = mbo + 101 + n
        pv = stkget(nrests, ifp)
!
        call cpyvii(nfac, mspec(1,1), 4, istak(mspect), 1)
        call cpyvii(nfac, mspec(2,1), 4, istak(mspect+nfac), 1)
        call cpyvii(nfac, mspec(3,1), 4, istak(mspect+2*nfac), 1)
        call cpyvii(nfac, mspec(4,1), 4, istak(mspect+3*nfac), 1)
!
!       CALL MAIN ROUTINE FOR COMPUTING AND PRINTING FORECASTS
!
       call amfmn (par, rstak(pv), y, npar, n, nfac, istak(mspect),&
    &    rstak(pardf), npardf, rstak(t), rstak(temp), rstak(parar),&
    &    rstak(parma), mbo, mbol, n-nrests+1, n, nprt, save,&
    &    nfcst, nfcsto, ifcsto, fcst, ifcst, fcstsd, rstak(f),&
     &    rstak(fsd), nparar, nparma)
      end if
!
      call stkclr(nall0)
!
      return
!
      end
!MPPM
      subroutine mppm(ym, ymmiss, x, xmiss, n, m, iym)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH MULTIPLE Y-AXIS VALUES AND WITH MISSING
!     OBSERVATIONS (SHORT CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   xmiss
     integer&
     &   iym,m,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),ym(*),ymmiss(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xlb,xub,ylb,yub
     integer&
     &   ilog,iprt,ischck,isize,lisym,nout
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(IYM,M)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(M)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'M',       'P',       'P',       'M',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      multi = .true.
      ilog = -1
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 0.0e0
      xub = 0.0e0
      ischck = 2
      isize = -1
      nout = 0
      miss = .true.
      lisym = 1
!
     call ppcnt (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL MPPM (YM, YMMISS, X, XMISS, N, M, IYM)')
      end
!ERVGTM
     subroutine ervgtm (nmsub, nmvar, vec, vcmiss, n, veclb, nvmx,&
     &   head, msgtyp, nv, error, nmmin)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS TO ENSURE THAT NO VALUES, OR ONLY A MAXIMUM
!     OF NVMX, ARE NOT GREATER THAN A SPECIFIED LOWER BOUND VECLB,
!     WITH NAME NMMIN. THE ROUTINE ALTERNATIVELY CHECKS TO MAKE SURE
!     THAT NO VALUES ARE IN VIOLATION OF THIS LOWER BOUND IF THE FIRST
!     VALUE IN THE VECTOR IS NOT.  THE CHECKING OPTION IS SPECIFIED
!     WITH MSGTYP.  IF AN ERROR IS FOUND, THE ERROR IS PRINTED AND
!     AN ERROR FLAG AND THE NUMBER OF VIOLATINS ARE RETURNED.
!     VALUES OF VEC EQUAL TO VCMISS ARE EXEMPTED FROM THE CHECKING.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   vcmiss,veclb
     integer&
     &   msgtyp,n,nv,nvmx
     logical&
     &   error,head
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   vec(*)
     character&
     &   nmmin(8)*1,nmsub(6)*1,nmvar(8)*1
!
!  LOCAL SCALARS
     integer&
     &   i,nvmn
!
!  EXTERNAL FUNCTIONS
     logical&
     &   mvchk
!       EXTERNAL MVCHK
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL ERVGTP
!
!  INTRINSIC FUNCTIONS
      intrinsic mod
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        THE VALUE RETURNED FROM THE ERROR CHECKING ROUTINES TO INDICATE
!        WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED (TRUE)
!        OR NOT (FALSE).
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER MSGTYP
!        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
!        IF (MSGTYP.GE.4) THE MESSAGE PRINTED WILL USE NMMIN
!        OTHERWISE IT WILL USE VECLB.
!        IF (MSGTYP = 1 OR 4) NO VIOLATIONS ARE ALLOWED.
!        IF (MSGTYP = 2 OR 5) THE NUMBER OF VIOLATIONS MUST
!                             BE LESS THAN   NVMX   .
!        IF (MSGTYP = 3 OR 6) VIOLATIONS ARE COUNTED ONLY IF THE
!                             THE FIRST ELEMENT IS NOT IN VIOLATION.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE ARGUMENTS NAME.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND.
!     INTEGER NVMN
!        THE SMALLEST NUMBER OF NON-VIOLATIONS ALLOWED.
!     INTEGER NVMX
!        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
!     REAL VCMISS
!        MISSING VALUE CODE IN VEC.
!     REAL VEC(N)
!        THE VECTOR BEING TESTED.
!     REAL VECLB
!        THE VALUE THAT THE VECTOR IS BEING TESTED AGAINST.
!
      error = .false.
!
      if (n .le. 0) return
!
!     TEST WHETHER TESTING IS NECESSRY
!
      if ((mod(msgtyp,3) .eq. 0) .and. (vec(1) .le. veclb)) return
!
!     CHECK FOR VIOLATIONS
!
      nv = 0
      do 5 i = 1, n
         if (mvchk(vec(i), vcmiss)) go to 5
         if ((vec(i).le.veclb)) nv = nv + 1
    5 continue
!
      if (nv .le. nvmx) return
!
!     VIOLATIONS FOUND
!
      error = .true.
      nvmn = n - nvmx
     call ervgtp (nmsub, nmvar, veclb, nvmn, nvmx, head, msgtyp, nv,&
     &   nmmin)
!
      return
!
      end
!PPFNML
      real(kind=wp) function ppfnml(p)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS FUNCTION IS A VERSION OF DATAPAC SUBROUTINE
!     NORPPF, WITH MODIFICATIONS TO FACILITATE CONVERSION TO
!     DOUBLE PRECISION AUTOMATICALLY USING THE NAG, INC. CODE APT, AND
!     TO CORRESPOND TO STARPAC CONVENTIONS.
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE NORMAL (GAUSSIAN)
!              DISTRIBUTION WITH MEAN = 0 AND STANDARD DEVIATION = 1.
!              THIS DISTRIBUTION IS DEFINED FOR ALL X AND HAS
!              THE PROBABILITY DENSITY FUNCTION
!              F(X) = (1/SQRT(2*PI))*EXP(-X*X/2).
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     ERROR CHECKING--NONE
!     RESTRICTIONS--P SHOULD BE BETWEEN 0.0E0 AND 1.0E0, EXCLUSIVELY.
!     REFERENCES--ODEH AND EVANS, THE PERCENTAGE POINTS
!                 OF THE NORMAL DISTRIBUTION, ALGORITHM 70,
!                 APPLIED STATISTICS, 1974, PAGES 96-97.
!               --EVANS, ALGORITHMS FOR MINIMAL DEGREE
!                 POLYNOMIAL AND RATIONAL APPROXIMATION,
!                 M. SC. THESIS, 1972, UNIVERSITY
!                 OF VICTORIA, B. C., CANADA.
!               --HASTINGS, APPROXIMATIONS FOR DIGITAL
!                 COMPUTERS, 1955, PAGES 113, 191, 192.
!               --NATIONAL BUREAU OF STANDARDS APPLIED MATHEMATICS
!                 SERIES 55, 1964, PAGE 933, FORMULA 26.2.23.
!               --FILLIBEN, SIMPLE AND ROBUST LINEAR ESTIMATION
!                 OF THE LOCATION PARAMETER OF A SYMMETRIC
!                 DISTRIBUTION (UNPUBLISHED PH.D. DISSERTATION,
!                 PRINCETON UNIVERSITY), 1969, PAGES 21-44, 229-231.
!               --FILLIBEN, "THE PERCENT POINT FUNCTION",
!                 (UNPUBLISHED MANUSCRIPT), 1970, PAGES 28-31.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--1, 1970, PAGES 40-111.
!               --THE KELLEY STATISTICAL TABLES, 1948.
!               --OWEN, HANDBOOK OF STATISTICAL TABLES,
!                 1962, PAGES 3-16.
!               --PEARSON AND HARTLEY, BIOMETRIKA TABLES
!                 FOR STATISTICIANS, VOLUME 1, 1954,
!                 PAGES 104-113.
!     COMMENTS--THE CODING AS PRESENTED BELOW
!               IS ESSENTIALLY IDENTICAL TO THAT
!               PRESENTED BY ODEH AND EVANS
!               AS ALGORITHM 70 OF APPLIED STATISTICS.
!               THE PRESENT AUTHOR HAS MODIFIED THE
!               ORIGINAL ODEH AND EVANS CODE WITH ONLY
!               MINOR STYLISTIC CHANGES.
!             --AS POINTED OUT BY ODEH AND EVANS
!               IN APPLIED STATISTICS,
!               THEIR ALGORITHM REPRESENTES A
!               SUBSTANTIAL IMPROVEMENT OVER THE
!               PREVIOUSLY EMPLOYED
!               HASTINGS APPROXIMATION FOR THE
!               NORMAL PERCENT POINT FUNCTION--
!               THE ACCURACY OF APPROXIMATION
!               BEING IMPROVED FROM 4.5*(10**-4)
!               TO 1.5*(10**-8).
!
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING LABORATORY
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!     ORIGINAL VERSION--JUNE      1972.
!     UPDATED         --SEPTEMBER 1975.
!     UPDATED         --NOVEMBER  1975.
!     UPDATED         --OCTOBER   1976.
!
!     MODIFIED BY     --JANET R. DONALDSON, DECEMBER 7, 1981
!                       STATISTICAL ENGINEERING DIVISION
!                       NATIONAL BUREAU OF STANDARDS, BOULDER, COLORDAO
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   p
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   aden,anum,p0,p1,p2,p3,p4,q0,q1,q2,q3,q4,r,t
!
!  INTRINSIC FUNCTIONS
      intrinsic log,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ADEN, ANUM
!        *
!     REAL P
!        THE PROBABILITY AT WHICH THE PERCENT POINT IS TO BE EVALUATED
!     REAL P0, P1, P2, P3, P4
!        VARIOUS PARAMETERS USED IN THE APPROXIMATIONS.
!     REAL Q0, Q1, Q2, Q3, Q4
!        VARIOUS ADDITIONAL PARAMETERS USED IN THE APPROXIMATIONS.
!     REAL R
!        *
!     REAL T
!        *
!
     data p0, p1, p2, p3, p4&
    &  /-.322232431088e0, -1.0e0, -.342242088547e0,&
     &   -.204231210245e-1,-.453642210148e-4/
     data q0, q1, q2, q3, q4&
    &  /.993484626060e-1, .588581570495e0,&
     &   .531103462366e0, .103537752850e0, .38560700634e-2/
!
!
      if (p.ne.0.5e0) go to 30
      ppfnml = 0.0e0
      return
!
   30 r = p
      if (p.gt.0.5e0) r = 1.0e0 - r
      t = sqrt(-2.0e0*log(r))
      anum = ((((t*p4+p3)*t+p2)*t+p1)*t+p0)
      aden = ((((t*q4+q3)*t+q2)*t+q1)*t+q0)
      ppfnml = t + (anum/aden)
!
      if (p.lt.0.5e0) ppfnml = -ppfnml
!
      return
!
      end
!AMEISM
     subroutine ameism (amehdr, page, wide, hlfrpt, npar, m, n, nnzw,&
    &   weight, ifixd, par, scale, lscale, iwork, liwork, rwork,&
     &   lrwork, res, aprxdv, stpt, lstpt, npare)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS AN INITIAL SUMMARY OF THE STARTING
!     ESTIMATES AND THE CONTROL PARAMETERS FOR THE NONLINEAR
!     LEAST SQUARES SUBROUTINES FOR ARIMA MODELING.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   liwork,lrwork,lscale,lstpt,m,n,nnzw,npar,npare
     logical&
     &   aprxdv,hlfrpt,page,weight,wide
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),res(*),rwork(*),scale(*),stpt(*)
     integer&
     &   ifixd(*),iwork(*)
!
!  SUBROUTINE ARGUMENTS
       external amehdr
!
!  SCALARS IN COMMON
     integer&
    &   iflag,mbo,mbol,mspect,nfact,nparar,npardf,nparma,nrests,&
     &   parar,pardf,parma,t,temp
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   rsd,rss
     integer&
     &   iamhd,iprt,isubhd,lmax0,mxfcal,mxiter,rfctol,xctol
!
!  LOCAL ARRAYS
     integer&
     &   istak(12)
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   SNRM2
!      EXTERNAL SNRM2
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AMLST,IPRINT,MODSUM
!
!  INTRINSIC FUNCTIONS
      intrinsic real,sqrt
!
!  COMMON BLOCKS
      common /cstak/dstak
     common /mdltsc/mspect,nfact,pardf,npardf,parar,nparar,parma,&
     &   nparma,mbo,mbol,t,temp,nrests,iflag
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     EXTERNAL AMEHDR
!        THE ROUTINE USED TO PRINT THE HEADING
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IAMHD
!        THE INDICATOR VALUE USED TO DESIGNATE THE TYPE OF LIST
!        TO BE GENERATED
!        IF IAMHD=1, THE LIST IS FOR THE INITIAL SUMMARY OF THE
!                    ESTIMATION ROUTINES.
!        IF IAMHD=2, THE LIST IS FOR THE INITIAL REPORT OF THE
!                    FORECASTING ROUTINES.
!        IF IAMHD=3, THE LIST IS FOR THE FINAL REPORT OF THE
!                    ESTIMATION ROUTINES.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IWORK(LIWORK)
!        WORK SPACE USED BY THE NL2 SUBROUTINES.
!     INTEGER LIWORK
!        THE DIMENSION OF VECTOR IWORK.
!     INTEGER LMAX0
!        THE LOCATION IN RWORK OF THE VALUE INDICATING THE
!        MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     INTEGER LRWORK
!        THE DIMENSION OF VECTOR RWORK.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER LSTPT
!        THE DIMENSION OF VECTOR STPT.
!     INTEGER M
!        A DUMMY VARIABLE.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBOL
!        THE MAXIMUM BACK ORDER ON THE LEFT
!     INTEGER MSPECT
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER MXFCAL
!        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
!        MAXIMUM NUMBER OF FUNCTION CALLS ALLOWED, EXCLUDING
!        CALLS NECESSARY TO COMPUTE THE DERIVATIVES AND VARIANCE
!        COVARIANCE MATRIX.
!     INTEGER MXITER
!        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
!        MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFACT
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARAR
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE AUTOREGRESSIVE PARAMETERS
!     INTEGER PARDF
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
!     INTEGER PARMA
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE MOVING AVERAGE PARAMETERS
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     INTEGER RFCTOL
!        THE LOCATION IN RWORK OF THE RELATIVE FUNCTION CONVERGENCE
!        TOLERANCE.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     REAL RSS
!        THE RESIDUAL SUM OF SQUARES.
!     REAL RWORK(LRWORK)
!        WORK SPACE USED BY THE NL2 SUBROUTINES.
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL STPT(LSTPT)
!        THE STEP SIZE ARRAY.
!     INTEGER T
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR.
!     INTEGER TEMP
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     INTEGER XCTOL
!        THE LOCATION IN RWORK OF THE PARAMETER CONVERGENCE TOLERANCE.
!
!     IWORK SUBSCRIPT VALUES
!
      data mxfcal/17/, mxiter/18/
!
!     RWORK SUBSCRIPT VALUES
!
      data lmax0/35/, rfctol/32/, xctol/33/
!
      call iprint(iprt)
!
      isubhd = 1
      call amehdr(page, wide, isubhd)
!
      call modsum(nfact, istak(mspect))
      iamhd = 1
     call amlst (iamhd, par, npar, nfact, istak(mspect), n, par, npar,&
     &  scale, lscale, stpt, lstpt, ifixd, rss, rsd, npardf, npare, 0)
!
      if (weight) write (iprt, 1170) nnzw
      write(iprt, 1070) iwork(mxiter)
      write(iprt, 1090) iwork(mxfcal)
      write(iprt, 1080)
      write(iprt, 1100) rwork(rfctol)
      write(iprt, 1110) rwork(xctol)
      write(iprt, 1120) rwork(lmax0)
      rsd = snrm2(nrests, res, 1)
      rss = rsd * rsd
     if (n-npardf-npare.ge.1)&
     &     rsd = rsd / sqrt(real(n-npardf-npare))
      write (iprt, 1200) rss
      write (iprt, 1210) rsd
      write (iprt, 1220) n, npardf, npare, nnzw-npare
!
      return
!
!     FORMAT STATEMENTS
!
1070 format (/37h maximum number of iterations allowed, 32x, 5h(mit),&
     &   1x, i5)
 1080 format(/44h convergence criterion for test based on the/)
1090 format(/' MAXIMUM NUMBER OF MODEL SUBROUTINE CALLS',&
     &   8h allowed, 26x, i5)
1100 format (5x, 39h forecasted relative change in residual,&
     &   15h sum of squares, 7x, 8h(stopss), 1x, g11.4)
1110 format(5x, 49h maximum scaled relative change in the parameters,&
     &   13x, 7h(stopp), 1x, g11.4)
1120 format(//' MAXIMUM CHANGE ALLOWED IN THE PARAMETERS',&
     &   23h at the first iteration, 3x, 7h(delta), 1x, g11.4)
1170 format (/' NUMBER OF NON ZERO WEIGHTED OBSERVATIONS', 27x,&
     &   6h(nnzw), 1x, i5)
1200 format (/44h residual sum of squares for input parameter,&
     &   7h values, 24x, g11.4, '  (BACKFORECASTS INCLUDED)')
1210 format (/48h residual standard deviation for input parameter,&
     &   7h values, 14x, 5h(rsd), 1x, g11.4)
1220 format (/ 19h based on degrees o,&
     &   9hf freedom, 1x, i4, 3h - , i3, 3h - , i3, 3h = , i4)
      end
!ARFLT
      subroutine arflt (y, n, iar, phi, yf, nyf)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PERFORMS THE AUTOREGRESSIVE FILTERING
!     OPERATION DEFINED BY PHI, RETURNING THE FILTERED SERIES
!     IN YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iar,n,nyf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   phi(*),y(*),yf(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   ymean
     integer&
     &   i,iprt
     logical&
     &   err01,head
!
!  LOCAL ARRAYS
     character&
     &   ln(8)*1,nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AMEAN,EISGE,FLTAR,IPRINT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     CHARACTER*1 LN(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     REAL PHI(IAR)
!        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!     REAL YMEAN
!        THE MEAN OF THE INPUT SERIES Y.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'A',       'R',       'F',       'L',       'T',       ' '/
     data&
    &  ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 3, 1, head, err01, ln)
!
!
      if (.not. err01) go to 10
!
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   10 continue
!
!     COMPUTE ARITHMETIC MEAN
!
      call amean(y, n, ymean)
!
      do 20 i = 1, n
         yf(i) = y(i) - ymean
   20 continue
!
      call fltar (yf, n, iar, phi, yf, nyf)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   43h       call arflt (y, n, iar, phi, yf, nyf))
      end
!MULTBP
      subroutine multbp(t, lt, c, lc, temp, ltemp, mbo)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE MULTIPLIES TOGETHER TWO DIFFERENCE FACTORS FROM A
!     (BOX-JENKINS) TIME SERIES MODEL.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 1, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lc,lt,ltemp,mbo
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   c(mbo),t(2*mbo),temp(mbo)
!
!  LOCAL SCALARS
     integer&
     &   i,j,ji,k
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL C(MBO)
!        THE SECOND FACTOR ON INPUT AND THE EXPANDED FACTOR ON OUTPUT.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER JI
!        AN INDEX VARIABLE
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER LC
!        THE LARGEST ORDER OF THE SECOND FACTOR ON INPUT, AND
!        THE LARGEST ORDER OF THE EXPANDED FACTOR ON OUTPUT.
!     INTEGER LT
!        THE LARGEST ORDER OF THE FIRST FACTOR.
!     INTEGER LTEMP
!        THE LENGTH OF THE VECTOR TEMP.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     REAL T(2*MBO)
!        A TEMPORARY WORK VECTOR.
!     REAL TEMP(MBO)
!        A TEMPORARY WORK VECTOR
!
      if (lc .eq. 0) go to 15
      do 10 j = 1, lc
         temp(j) = c(j)
   10 continue
   15 k = lc + 1
      do 20 j=k,ltemp
         temp(j) = 0.0e0
   20 continue
      if (lt .eq. 0) go to 50
      do 40 j=1,lt
         temp(j) = temp(j) + t(j)
         if (lc .eq. 0) go to 40
         do 30 i=1,lc
            ji = j + i
            temp(ji) = temp(ji) - c(i)*t(j)
   30    continue
   40 continue
!
   50 do 60 j=1,ltemp
         c(j) = temp(j)
   60 continue
      lc = ltemp
      return
      end
!VCVOTF
      subroutine vcvotf(npar, vcv, lvcv, est, lmask, mask, ivcvpt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS THE VARIANCE COVARIANCE MATRIX
!     STORED ROW WISE WHEN IT IS TO BE LABELLED ON THE BASIS OF A MASK.
!     IF EST IS TRUE, THE COVARIANCES ARE LISTED ABOVE THE
!     DIAGONAL, THE VARIANCES ON THE DIAGONAL, AND THE CORRELATION
!     COEFFICIENTS BELOW THE DIAGONAL.
!     IF EST IS FALSE, THE STANDARD DEVIATIONS ARE LISTED ON THE
!     DIAGONAL, AND THE CORRELATION COEFFICIENTS ARE BELOW THE
!     DIAGONAL.
!
!     WRITTEN BY  -  JOHN E. KOONTZ
!          STATISTICAL ENGINEERING DIVISION
!          NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!        BASED ON VCVOUT VERSION OF DECEMBER 29, 1982
!        WRITTEN BY JANET R. DONALDSON
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ivcvpt,lmask,lvcv,npar
     logical&
     &   est
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   vcv(lvcv)
     integer&
     &   mask(lmask)
!
!  LOCAL SCALARS
     integer&
     &   code,i,ii,iprt,mode
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,MATPRF
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CODE
!        IF 1 -SINGLE PRINTED, X ONLY (Y IS DUMMY ARG)
!           2 -DOUBLE PRINTED LINE, BOTH X AND Y
!     LOGICAL EST
!        AN INDICATOR USED TO DESIGNATE WHETHER THE VCV TO BE PRINTED
!        IS OF THE ESTIMATED PARAMETERS (TRUE) OR NOT (FALSE).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER II
!        THE INDEX OF THE (I,I)TH ELEMENT OF THE VCV MATRIX
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCVPT
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
!        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
!        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)
!        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                       *INVERSE(HESSIAN)
!     INTEGER LMASK
!        THE LENGTH OF MASK.
!     INTEGER LVCV
!        THE LENGTH OF ARRAY VCV.
!     INTEGER MASK(LMASK)
!        MASK VECTOR FOR VCV.  THE INDEX OF THE ITH ELEMENT OF
!        MASK EQUAL TO ZERO IS THE LABEL IN THE OUTPUT OF VCV
!        OF THE ITH ROW AND ITH COLUMN.
!     INTEGER MODE
!        IF 0, LOWER TRIANGULAR PART PRINTED
!           1, LOWER TRIANGULAR PART IS PRINTED WITH
!              SQUARE ROOTS OF THE DIAGONAL
!           2, LOWER TRIANGLE PRINTED AS CORRELATION MATRIX
!              WITH SQUARE ROOTS ON THE DIAGONAL
!           3, FULL MATRIX PRINTED
!           4, FULL MATRIX PRINTED WITH CORRELATION MATRIX
!              PRINTED BELOW THE DIAGONAL
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     REAL VCV(LVCV)
!        THE VARIANCE COVARIANCE MATRIX.
!
!     COMMENCE BODY OF ROUTINE
!
      call iprint(iprt)
!
      code = 1
!
!     DETERMINE WHETHER TO ISSUE NEGATIVE VARIANCE WARNING
!
      mode = 0
      do 30 i=1,npar
         ii = i*(i-1)/2 + i
         if (vcv(ii).gt.0.0e0) go to 30
         if (est) go to 10
         write (iprt,1000)
         go to 20
!
   10    continue
         write (iprt,1050)
         if (ivcvpt.eq.1) write (iprt,1060)
         if (ivcvpt.eq.2) write (iprt,1070)
         if (ivcvpt.eq.3) write (iprt,1080)
   20    write (iprt,1010)
         go to 50
   30 continue
!
      if (est) go to 40
!
!     PRINT HEADING FOR CORRELATION ROUTINES
!
      write (iprt,1040)
      write (iprt,1030)
      mode = 2
      go to 50
!
   40 continue
!
!     PRINT HEADING FOR ESTIMATION ROUTINES
!
      write (iprt,1050)
      if (ivcvpt.eq.1) write (iprt,1060)
      if (ivcvpt.eq.2) write (iprt,1070)
      if (ivcvpt.eq.3) write (iprt,1080)
      write (iprt,1020)
      mode = 4
!
   50 call matprf(vcv, vcv, npar, mode, code, lvcv, mask, lmask)
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (///18h covariance matrix)
1010 format (/39h     nonpositive variances encountered./10h     corre,&
     &   39hlation coefficients cannot be computed.)
1020 format (4x, 36h- covariances are above the diagonal/4x, 7h- varia,&
    &   24hnces are on the diagonal/4x, 27h- correlation coefficients ,&
     &   22hare below the diagonal)
1030 format (4x, 41h- standard deviations are on the diagonal/4x,&
     &   49h- correlation coefficients are below the diagonal)
 1040 format (/19h correlation matrix)
1050 format (///45h variance-covariance and correlation matrices,&
     &   38h of the estimated (unfixed) parameters/ 1x, 82('-'))
1060 format (/&
    &   4x, 54h- approximation based on assumption that residuals are,&
     &   6h small)
1070 format (&
    &   /4x, 51h- approximation based on asymptotic maximum likelih,&
     &   10hood theory)
1080 format (/4x,&
    &   51h- approximation based on assumption that conditions,&
    &   10h necessary/&
    &   5x, 41h for asymptotic maximum likelihood theory,&
     &   18h might be violated)
      end
!PPMC
     subroutine ppmc(ym, ymiss, x, xmiss, n, ilog, isize, nout, ylb,&
     &   yub, xlb, xub)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT FOR DATA WITH MISSING OBSERVATIONS (LONG CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: xlb,ymiss,xmiss,xub,ylb,yub
     integer&
     &   ilog,isize,n,nout
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: x(*),ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iprt,ischck,iym,lisym,m
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
      real(kind=wp) :: ymmiss(1)
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YMISS
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'P',       'P',       'M',       'C',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      ymmiss=ymiss
      m = 1
      iym = n
      multi = .false.
      ischck = 0
      miss = .true.
      lisym = 1
!
     call ppcnt (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL PPMC (Y, YMISS, X, XMISS, N, ILOG,'/&
     &   '      +           ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      end
!BFSFS
     subroutine bfsfs(yfft1, yfft2, n, lyfft, ldstak, nw, lags, nf,&
     &   fmin, fmax, nprt, cspc2, icspc2, phas, iphas, freq)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     BIVARIATE SPECTRUM ANALYSIS (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fmax,fmin
     integer&
     &   icspc2,iphas,ldstak,lyfft,n,nf,nprt,nw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   cspc2(*),freq(*),phas(*),yfft1(*),yfft2(*)
     integer&
     &   lags(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta,ymiss1,ymiss2
     integer&
    &   ccov,ccov11,ccov12,ccov21,ccov22,ceven,codd,i,iccov,ifp,&
    &   index1,index2,inlppc,io,iprt,isym,jccov,jnlppc,lagmax,&
    &   lagmx1,ldsmin,lpcv,lw,lwork,m,nall0,nfft,spcf1,spcf2,w,&
     &   work,xaxis,yaxis
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12),nlppc(1,1,1)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL BFSDRV,IPRINT,LDSCMP,PARZEN,SETESL,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     INTEGER CCOV, CCOV11, CCOV12, CCOV21, CCOV22
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE COVARIANCES.
!     INTEGER CEVEN
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     INTEGER CODD
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     REAL CSPC2(ICSPC2,NW)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NLPPC(1,1,1)
!        A DUMMY ARRAY.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL PHAS(IPHAS,NW)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SPCF1, SPCF2
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     INTEGER W
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE WINDOWS.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR THE VECTOR WORK.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YMISS1, YMISS2
!        DUMMY VARIABLES.
!     REAL YFFT1(LYFFT)
!        THE FIRST TIME SERIES.
!     REAL YFFT2(LYFFT)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'B','F','S','F','S',' '/
!
!     SET UP FOR ERROR CHECKING
!
      option(1) = .false.
      option(2) = .false.
      option(3) = .false.
      option(4) = .true.
!
!     SET MAXIMUM LAG VALUE TO BE USED.
!
      if (nw.ge.1) then
         lagmax = lags(1)
         do 10 i=2,nw
            lagmax = max(lagmax,lags(i))
   10    continue
      else
         lagmax = n - 1
      end if
      lagmx1 = lagmax + 1
      call setesl(n+lagmax, 4, nfft)
!
      iccov = lagmax + 1
      jccov = 2
      inlppc = 1
      jnlppc = 1
      m = 2
      index1 = 1
      index2 = 2
!
!     COMPUTE THE MINIMUM ALLOWABLE STACK AREA
!
      if (nprt.eq.0) then
         io = 0
      else
         io = 1
      end if
!
     call ldscmp(9, 0, io*4*nf, 0, 0, 0, 'S',&
     &            6*lagmax+6+nfft+io*8*nf, ldsmin)
!
      ymiss1 = 1.0e0
      ymiss2 = 1.0e0
      lpcv = 4*nf
      lw = nfft
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING STACK ALLOCATIONS (NALL0)
!     SET THE STACK ALLOCATION TYPE (IFP)
!
      call stkset(ldstak, 4)
      nall0 = stkst(1)
!
      ifp = 3
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS
!
      if ((ldsmin.gt.ldstak) .or. (ldsmin.le.6)) then
         ccov = 1
         ceven = 1
         codd = 1
         spcf1 = 1
         spcf2 = 1
         w = 1
!
         ccov11 = 1
         ccov21 = 1
         ccov12 = 1
         ccov22 = 1
!
         isym = 1
         xaxis = 1
         yaxis = 1
      else
         ccov = stkget(4*lagmx1,ifp)
         ceven = stkget(lagmx1,ifp)
         codd = stkget(lagmx1,ifp)
         spcf1 = stkget(nf,ifp)
         spcf2 = stkget(nf,ifp)
         w = stkget(lw,ifp)
!
         ccov11 = ccov
         ccov21 = ccov + lagmx1
         ccov12 = ccov21 + lagmx1
         ccov22 = ccov12 + lagmx1
!
         if (nprt.eq.0) then
            isym = w
            xaxis = w
            yaxis = w
         else
            isym = stkget(lpcv,2)
            xaxis = stkget(lpcv,ifp)
            yaxis = stkget(lpcv,ifp)
         end if
      end if
!
      work = w
      lwork = lw
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
     call bfsdrv(yfft1, yfft2, ymiss1, ymiss2, rstak(ccov), nlppc,&
    &   rstak(spcf1), rstak(spcf2), nf, fmin, fmax, freq, n, nw,&
    &   lagmax, lags, lagmx1, rstak(work), lwork, delta, istak(isym),&
    &   rstak(xaxis), rstak(yaxis), lpcv, alpha, nprt, parzen, iccov,&
    &   jccov, m, index1, index2, cspc2, phas, icspc2, iphas,&
    &   rstak(codd), rstak(ceven), rstak(w), lw, nmsub, ldsmin,&
     &   ldstak, option, nfft, inlppc, jnlppc, lyfft)
!
      call stkclr(nall0)
!
!     CHECK FOR ERRORS
!
      if (ierr.eq.0) return
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL BFSFS (YFFT1, YFFT2, N, LYFFT, LDSTAK,'/&
    &   '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/&
     &   '      +            CSPC2, ICSPC2, PHAS, IPHAS, FREQ)')
      end
!LOPASS
      subroutine lopass (y, n, fc, k, hlp, yf, nyf)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE CARRIES OUT LOW-PASS FILTERING OF THE
!     SERIES.  THE FILTER IS THE K-TERM
!     LEAST SQUARES APPROXIMATION TO THE CUTOFF FILTER
!     WITH CUTOF FREQUENCY FC.  ITS TRANSFER FUNCTION
!     HAS A TRANSITION BAND OF WIDTH DELTA SURROUNDING FC,
!     WHERE DELTA = 4*PI/K.
!
!     WRITTEN BY  -  PETER BLOOMFIELD
!                    FOURIER ANALYSIS OF TIME SERIES- AN
!                       INTRODUCTION
!                    JOHN WILEY AND SONS, NEW YORK, 1976
!                    PAGE 149
!     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
!                                STATISTICAL ENGINEERING DIVISION
!                                NATIONAL BUREAU OF STANDARDS
!                                BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fc
     integer&
     &   k,n,nyf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   hlp(*),y(*),yf(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iprt
     logical&
     &   err01,err02,err03,err04,err05,head
!
!  LOCAL ARRAYS
     character&
     &   lfc(8)*1,lk(8)*1,ln(8)*1,nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,EISII,ERIODD,ERSII,ERSLFS,FLTSL,IPRINT,LPFLT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     REAL FC
!        THE USER SUPPLIED CUTOFF FREQUENCY.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     REAL HLP(K)
!        THE ARRAY IN WHICH THE -IDEAL- HIGH PASS FILTER COEFFICIENTS
!        WILL BE RETURNED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS TO BE COMPUTED.
!     CHARACTER*1 LFC(8), LK(8), LN(8)
!        THE ARRAY CONTAINING THE NAMES OF THE VARIABLES FC, K AND N.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'L',       'O',       'P',       'A',       'S',       'S'/
     data&
    &  lfc(1), lfc(2), lfc(3), lfc(4), lfc(5), lfc(6), lfc(7), lfc(8)&
     & /  'F',   'C',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lk(1), lk(2), lk(3), lk(4), lk(5), lk(6), lk(7), lk(8)&
     & /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 3, 1, head, err01, ln)
!
      call ersii(nmsub, lfc, fc, 0.0e0, 0.5e0, 2, head, err02, lfc, lfc)
!
      call eisii(nmsub, lk, k, 1, n, 2, head, err03, lk, lk)
!
      call eriodd(nmsub, lk, k, 1, head, err04)
!
      if (err01 .or. err02 .or. err03 .or. err04) go to 10
!
      call erslfs(nmsub, fc, k, head, err05)
!
      if (.not. err05) go to 20
!
   10 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   20 continue
!
      call lpflt (fc, k, hlp)
!
      call fltsl (y, n, k, hlp, yf, nyf)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   46h       call lopass (y, n, fc, k, hlp, yf, nyf))
      end
!STPDRV
     subroutine stpdrv(nmsub, xm, n, m, ixm, mdl, par, npar, ldstak,&
     &   stp, neta, exmpt, scale, lscale, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE DRIVER ROUTINE FOR SELECTING STEP SIZES
!     TO BE USED IN COMPUTING FORWARD DIFFERENCE QUOTIENT ESTIMATES
!     OF THE NUMERICAL DERIVATIVES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   exmpt
     integer&
     &   ixm,ldstak,lscale,m,n,neta,npar,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),scale(*),stp(*),xm(*)
     character&
     &   nmsub(6)*1
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   isubhd,lifixd
     logical&
     &   hlfrpt,page,prtfxd,wide
!
!  LOCAL ARRAYS
     integer&
     &   ifixed(1)
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL STKSET,STPCNT,STPER,STPHDR
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXCEPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE STEP SIZE SELECTION
!        ROUTINE HAS ALREADY PRINTED PART OF THE INITIAL SUMMARY (TRUE)
!        OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE LENGTH OF THE VECTOR IFIXED.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     REAL STP(NPAR)
!        THE SELECTED STEP SIZES.
!     EXTERNAL STPHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL XM(IXM,M)
!        THE INDEPENDENT VARIABLE ARRAY
!
!
!     PERFORM ERROR CHECKING
!
      call stper(nmsub, n, m, ixm, npar, ldstak, scale, lscale)
!
      if (ierr.ne.0) return
!
      call stkset(ldstak, 4)
!
      page = .false.
      wide = .true.
      isubhd = 0
!
      prtfxd = .false.
      ifixed(1) = -1
      lifixd = 1
!
!     PASS CONTROL OF STEP SIZE SELECTION TO SUBROUTINE STPCNT
!
     call stpcnt(xm, n, m, ixm, mdl, par, npar, stp, exmpt, neta,&
    &   scale, lscale, nprt, stphdr, page, wide, isubhd, hlfrpt,&
     &   prtfxd, ifixed, lifixd)
!
      return
!
      end
!XACF
      subroutine xacf(lds,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE TIME SERIES CORRELATION SUBROUTINES
!
!     SERIES Y IS LISTED AS SERIES X1 ON PAGE 362 IN JENKINS AND WATTS.
!
!     SERIES YD IS LISTED AS SERIES G ON PAGE 531 OF BOX AND JENKINS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lds
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
      real(kind=wp) :: amiss,ymiss
     integer&
     &   i,iar,iprt,itest,lacov,lagmax,ldstak,lyfft,n,nfac,nprt,nyd
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   acov(21),phi(21),y(100),yd(150),yfft(150)
     integer&
     &   iod(2),nd(2),nlppa(21)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACF,ACFD,ACFF,ACFFS,ACFM,ACFMS,ACFS,IPRINT
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(21)
!        THE AUTOCOVARIANCE VECTOR.
!     REAL AMISS
!        THE MISSING VALUE CODE FOR THE RETURNED ACVF ESTIMATES
!        (VECTOR ACOV).
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!     INTEGER IOD(2)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER ITEST
!        THE NUMBER OF THE TEST BEING RUN
!     INTEGER LACOV
!        THE LENGTH OF THE ACVF RELATED VECTORS.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE ARRAYS USED WHEN THE COMPUTATIONS ARE
!        PERFORMED BY THE FFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER ND(2)
!        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE
!        FACTORS ARE TO BE APPLIED.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS.
!     INTEGER NLPPA(21)
!        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
!        USED TO COMPUTE EACH ACVF ESTIMATE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     INTEGER NYD
!        THE NUMBER OF OBSERVATIONS IN THE SERIES TO BE DIFFERENCED.
!     REAL PHI(21)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     REAL Y(100), YD(150)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     REAL YFFT(150)
!        THE VECTORS USED FOR STORING THE SERIES FOR THE ROUTINES
!        USING THE FFT.
!     REAL YMISS
!        THE MISSING VALUE CODES FOR SERIES Y AND YM.
!
     data    y(  1),   y(  2),   y(  3),   y(  4),   y(  5),   y(  6)&
     &    / -2.07_wp, -1.15_wp,  0.69_wp, -0.46_wp, -1.49_wp, -0.70_wp/
     data    y(  7),   y(  8),   y(  9),   y( 10),   y( 11),   y( 12)&
     &    / -1.07_wp, -0.69_wp, -0.68_wp,  1.27_wp, -1.05_wp, -0.05_wp/
     data    y( 13),   y( 14),   y( 15),   y( 16),   y( 17),   y( 18)&
     &    / -0.84_wp, -0.62_wp, -0.49_wp, -1.29_wp, -0.49_wp, -1.06_wp/
     data    y( 19),   y( 20),   y( 21),   y( 22),   y( 23),   y( 24)&
     &    / -0.38_wp, -0.52_wp, -0.13_wp,  1.3_wp, -1.51_wp, -0.43_wp/
     data    y( 25),   y( 26),   y( 27),   y( 28),   y( 29),   y( 30)&
     &    / -1.33_wp, -0.78_wp,  0.31_wp, -0.95_wp, -0.9_wp, -0.30_wp/
     data    y( 31),   y( 32),   y( 33),   y( 34),   y( 35),   y( 36)&
     &    / -1.02_wp, -0.53_wp,  0.15_wp,  1.4_wp,  1.22_wp,  0.59_wp/
     data    y( 37),   y( 38),   y( 39),   y( 40),   y( 41),   y( 42)&
     &    /  0.7_wp,  1.7_wp,  2.78_wp,  1.98_wp,  1.39_wp,  1.85_wp/
     data    y( 43),   y( 44),   y( 45),   y( 46),   y( 47),   y( 48)&
     &    /  2.6_wp,  0.51_wp,  2.77_wp,  1.16_wp,  1.07_wp, -0.48_wp/
     data    y( 49),   y( 50),   y( 51),   y( 52),   y( 53),   y( 54)&
     &    / -0.52_wp,  0.37_wp,  0.0_wp, -1.99_wp, -1.75_wp,  0.70_wp/
     data    y( 55),   y( 56),   y( 57),   y( 58),   y( 59),   y( 60)&
     &    /  0.73_wp,  1.16_wp,  0.06_wp, -0.02_wp,  1.1_wp, -0.35_wp/
     data    y( 61),   y( 62),   y( 63),   y( 64),   y( 65),   y( 66)&
     &    / -1.67_wp, -1.57_wp,  1.16_wp,  1.84_wp,  3.35_wp,  0.40_wp/
     data    y( 67),   y( 68),   y( 69),   y( 70),   y( 71),   y( 72)&
     &    /  0.45_wp,  1.3_wp,  0.93_wp,  1.17_wp, -1.74_wp, -1.28_wp/
     data    y( 73),   y( 74),   y( 75),   y( 76),   y( 77),   y( 78)&
     &    / -0.07_wp,  1.5_wp,  0.53_wp,  0.2_wp, -0.42_wp,  1.18_wp/
     data    y( 79),   y( 80),   y( 81),   y( 82),   y( 83),   y( 84)&
     &    /  0.82_wp,  1.5_wp,  2.92_wp,  1.18_wp,  1.23_wp,  3.16_wp/
     data    y( 85),   y( 86),   y( 87),   y( 88),   y( 89),   y( 90)&
     &    /  0.79_wp,  0.68_wp,  1.14_wp,  1.02_wp,  1.02_wp, -0.71_wp/
     data    y( 91),   y( 92),   y( 93),   y( 94),   y( 95),   y( 96)&
     &    / -0.17_wp, -1.5_wp, -0.26_wp, -0.38_wp,  0.93_wp, -0.33_wp/
     data    y( 97),   y( 98),   y( 99),   y(100)&
     &    / -1.12_wp, -2.95_wp, -2.09_wp, -1.11_wp                    /
!
     data   yd(  1),  yd(  2),  yd(  3),  yd(  4),  yd(  5),  yd(  6)&
     &    /  112._wp, 118._wp, 132._wp, 129._wp, 121._wp, 135.0_wp/
     data   yd(  7),  yd(  8),  yd(  9),  yd( 10),  yd( 11),  yd( 12)&
     &    /  148._wp, 148._wp, 136._wp, 119._wp, 104._wp, 118.0_wp/
     data   yd( 13),  yd( 14),  yd( 15),  yd( 16),  yd( 17),  yd( 18)&
     &    /  115._wp, 126._wp, 141._wp, 135._wp, 125._wp, 149.0_wp/
     data   yd( 19),  yd( 20),  yd( 21),  yd( 22),  yd( 23),  yd( 24)&
     &    /  170._wp, 170._wp, 158._wp, 133._wp, 114._wp, 140.0_wp/
     data   yd( 25),  yd( 26),  yd( 27),  yd( 28),  yd( 29),  yd( 30)&
     &    /  145._wp, 150._wp, 178._wp, 163._wp, 172._wp, 178.0_wp/
     data   yd( 31),  yd( 32),  yd( 33),  yd( 34),  yd( 35),  yd( 36)&
     &    /  199._wp, 199._wp, 184._wp, 162._wp, 146._wp, 166.0_wp/
     data   yd( 37),  yd( 38),  yd( 39),  yd( 40),  yd( 41),  yd( 42)&
     &    /  171._wp, 180._wp, 193._wp, 181._wp, 183._wp, 218.0_wp/
     data   yd( 43),  yd( 44),  yd( 45),  yd( 46),  yd( 47),  yd( 48)&
     &    /  230._wp, 242._wp, 209._wp, 191._wp, 172._wp, 194.0_wp/
     data   yd( 49),  yd( 50),  yd( 51),  yd( 52),  yd( 53),  yd( 54)&
     &    /  196._wp, 196._wp, 236._wp, 235._wp, 229._wp, 243.0_wp/
     data   yd( 55),  yd( 56),  yd( 57),  yd( 58),  yd( 59),  yd( 60)&
     &    /  264._wp, 272._wp, 237._wp, 211._wp, 180._wp, 201.0_wp/
     data   yd( 61),  yd( 62),  yd( 63),  yd( 64),  yd( 65),  yd( 66)&
     &    /  204._wp, 188._wp, 235._wp, 227._wp, 234._wp, 264.0_wp/
     data   yd( 67),  yd( 68),  yd( 69),  yd( 70),  yd( 71),  yd( 72)&
     &    /  302._wp, 293._wp, 259._wp, 229._wp, 203._wp, 229.0_wp/
     data   yd( 73),  yd( 74),  yd( 75),  yd( 76),  yd( 77),  yd( 78)&
     &    /  242._wp, 233._wp, 267._wp, 269._wp, 270._wp, 315.0_wp/
     data   yd( 79),  yd( 80),  yd( 81),  yd( 82),  yd( 83),  yd( 84)&
     &    /  364._wp, 347._wp, 312._wp, 274._wp, 237._wp, 278.0_wp/
     data   yd( 85),  yd( 86),  yd( 87),  yd( 88),  yd( 89),  yd( 90)&
     &    /  284._wp, 277._wp, 317._wp, 313._wp, 318._wp, 374.0_wp/
     data   yd( 91),  yd( 92),  yd( 93),  yd( 94),  yd( 95),  yd( 96)&
     &    /  413._wp, 405._wp, 355._wp, 306._wp, 271._wp, 306.0_wp/
     data   yd( 97),  yd( 98),  yd( 99),  yd(100),  yd(101),  yd(102)&
     &    /  315._wp, 301._wp, 356._wp, 348._wp, 355._wp, 422.0_wp/
     data   yd(103),  yd(104),  yd(105),  yd(106),  yd(107),  yd(108)&
     &    /  465._wp, 467._wp, 404._wp, 347._wp, 305._wp, 336.0_wp/
     data   yd(109),  yd(110),  yd(111),  yd(112),  yd(113),  yd(114)&
     &    /  340._wp, 318._wp, 362._wp, 348._wp, 363._wp, 435.0_wp/
     data   yd(115),  yd(116),  yd(117),  yd(118),  yd(119),  yd(120)&
     &    /  491._wp, 505._wp, 404._wp, 359._wp, 310._wp, 337.0_wp/
     data   yd(121),  yd(122),  yd(123),  yd(124),  yd(125),  yd(126)&
     &    /  360._wp, 342._wp, 406._wp, 396._wp, 420._wp, 472.0_wp/
     data   yd(127),  yd(128),  yd(129),  yd(130),  yd(131),  yd(132)&
     &    /  548._wp, 559._wp, 463._wp, 407._wp, 362._wp, 405.0_wp/
     data   yd(133),  yd(134),  yd(135),  yd(136),  yd(137),  yd(138)&
     &    /  417._wp, 391._wp, 419._wp, 461._wp, 472._wp, 535.0_wp/
     data   yd(139),  yd(140),  yd(141),  yd(142),  yd(143),  yd(144)&
     &    /  622._wp, 606._wp, 508._wp, 461._wp, 390._wp, 432.0_wp/
!
      call iprint(iprt)
      itest = 1
      ldstak = lds
!
      n = 100
      lagmax = 20
      nprt = 1
      lyfft = 150
      lacov = 21
      nyd = 144
      nfac = 2
      nd(1) = 1
      nd(2) = 1
      iod(1) = 12
      iod(2) = 1
      ymiss = 1.16_wp
!
!     TEST OF ACF
!
    5 write (iprt,1000)
      call acf(y, n)
      write (iprt,1010) ierr
!
!     TEST OF ACFS
!
      write (iprt,1020)
      call acfs(y, n, lagmax, lacov, acov, iar, phi, nprt, ldstak)
      write (iprt,1010) ierr
!
!     PRINT STORAGE FROM ACFS
!
      if (ierr.eq.0) then
        write (iprt,1030) (acov(i),i=1,lagmax+1)
        write (iprt,1030) (phi(i),i=1,iar)
      end if
!
!     TEST OF ACFD
!
      write (iprt,1040)
      call acfd(yd, nyd, lagmax, nfac, nd, iod, ldstak)
      write (iprt,1010) ierr
!
!     TEST OF ACFM
!
      write (iprt,1050)
      call acfm(y, ymiss, n)
      write (iprt,1010) ierr
!
!     TEST OF ACFMS
!
      write (iprt,1120)
     call acfms(y, ymiss, n, lagmax, lacov, acov, amiss, nlppa, nprt,&
     &   ldstak)
      write (iprt,1010) ierr
!
!     PRINT STORAGE FROM ACFMS
!
      if (ierr.eq.0) then
        write (iprt,1030) (acov(i),i=1,lagmax+1)
        write (iprt,1140) (nlppa(i),i=1,lagmax+1)
      end if
!
!     COPY DATA INTO YFFT FOR ACFF
!
      do 10 i=1,n
         yfft(i) = y(i)
   10 continue
!
!     TEST OF ACFF
!
      write (iprt,1090)
      call acff(yfft, n, lyfft, ldstak)
      write (iprt,1010) ierr
!
!     COPY DATA INTO YFFT FOR ACFFS
!
      do 20 i=1,n
         yfft(i) = y(i)
   20 continue
!
!     TEST OF ACFFS
!
      write (iprt,1130)
     call acffs(yfft, n, lyfft, ldstak, lagmax, lacov, acov, iar, phi,&
     &   nprt)
      write (iprt,1010) ierr
!
!     PRINT STORAGE FROM ACFFS
!
      if (ierr.eq.0) then
        write (iprt,1030) (acov(i),i=1,lagmax+1)
        write (iprt,1030) (phi(i),i=1,iar)
      end if
!
      go to (100, 200, 300, 400), itest
!
!     TEST MINIMUM PROBLEM SIZE
!
  100 itest = itest + 1
      n = 13
      lagmax = 1
      nfac = 1
      nd(1) = 1
      iod(1) = 1
      go to 5
!
!     CHECK ERROR HANDLING
!
  200 itest = itest + 1
      n = 0
      lagmax = 20
      lyfft = 0
      lacov = 0
      nyd = 0
      nfac = 1
      nd(1) = 0
      iod(1) = 0
      go to 5
!
!     CHECK ERROR HANDLING
!
  300 itest = itest + 1
      n = 100
      lagmax = 0
      lyfft = 0
      lacov = 0
      nyd = 144
      nfac = 0
      ldstak = 0
      go to 5
!
  400 return
!
!     FORMAT STATEMENTS
!
 1000 format ('1TEST OF ACF')
 1010 format (8h ierr is, i5)
 1020 format ('1', 12htest of acfs)
 1030 format (9f10.5)
 1040 format ('1', 12htest of acfd)
 1050 format ('1', 12htest of acfm)
 1090 format ('1', 12htest of acff)
 1120 format ('1', 13htest of acfms)
 1130 format ('1', 13htest of acffs)
 1140 format (9i10)
      end
!CCFOUT
     subroutine ccfout (j, ymeanj, ysdj, nj, nusedj, k, ymeank, ysdk,&
    &   nk, nusedk, lagmax, ncc, rhoc, sdrhoc, ifmiss, nlpp12,&
     &   nlpp21, lccov, ymissj, ymissk, newpg)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRINTS THE CROSS CORRELATIONS AND THEIR
!     STANDARD ERRORS, AND MISCELLANEOUS SUMMARY INFORMATION.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ymeanj,ymeank,ymissj,ymissk,ysdj,ysdk
     integer&
     &   j,k,lagmax,lccov,ncc,nj,nk,nusedj,nusedk
     logical&
     &   ifmiss,newpg
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   rhoc(*),sdrhoc(*)
     integer&
     &   nlpp12(*),nlpp21(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm,pmissj,pmissk
     integer&
     &   iprt,nmissj,nmissk
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ymmiss(1)
     integer&
     &   isym(1)
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL CCFLST,IPRINT,VERSP,VPMN
!
!  INTRINSIC FUNCTIONS
      intrinsic real
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     LOGICAL IFMISS
!        THE INDICATOR VARIABLE USED TO DETERMINE
!        WHETHER THE INPUT SERIES HAS MISSING DATA OR NOT.
!     INTEGER IPRT
!        THE UNIT NUMBER OF THE DEVICE USED FOR PRINTED
!        OUTPUT.
!     INTEGER ISYM(1)
!        A DUMMY ARRAY.
!     INTEGER J, K
!        THE SUBSCRIPT VALUES OF THE TWO SERIES BEING COMPARED.
!     INTEGER LAGMAX
!        THE LARGEST LAG VALUE TO BE USED.
!     INTEGER LCCOV
!        THE NUMBER OF LOCATIONS ALLOWED FOR STORING THE NLPPC.
!     INTEGER NCC
!        THE NUMBER OF CROSS CORRELATIONS COMPUTED (FROM -LAGMAX
!        TO +LAGMAX).
!     LOGICAL NEWPG
!        AN INDICATOR VARIABLE USED TO DETERMINE IF THE OUTPUT SHOULD
!        START ON A NEW PAGE.
!     INTEGER NJ, NK
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NLPP12(LCCOV), NLPP21(LCCOV)
!        THE NUMBER OF LAGGED PRODUCT PAIRS USED TO COMPUTE EACH
!        CCVF AT EACH LAG.
!     INTEGER NMISSJ, NMISSK
!        THE NUMBER OF MISSING VALUES IN EACH SERIES.
!     INTEGER NUSEDJ, NUSEDK
!        THE ACTIVE NUMBER OF OBSERVATIONS IN EACH SERIES.
!     REAL PMISSJ, PMISSK
!        THE PERCENT OF MISSING OBSERVATIONS.
!     REAL RHOC(NCC)
!        THE ARRAY IN WHICH THE CROSS CORRELATIONS ARE STORED
!     REAL SDRHOC(NCC)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!        ARE STORED
!     REAL YMEANJ, YMEANK
!        THE MEAN OF EACH OF THE SERIES.
!     REAL YMISSJ, YMISSK
!        THE MISSING VALUE CODE FOR EACH SERIES.
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE CROSS CORRELATIONS.
!     REAL YSDJ, YSDK
!        THE STANDARD DEVIAION OF EACH SERIES.
!
      fplm = r1mach(2)
!
      ymmiss(1) = fplm
!
!     PRINT SUMMARY INFORMATION
!
      call iprint(iprt)
!
      if (newpg) write (iprt, 1004)
      call versp (.true.)
      write(iprt, 1005)
!
      write(iprt, 1000) j, k, ymeanj, ymeank, ysdj, ysdk, nj, nk
      if (.not. ifmiss) go to 10
      nmissj = nj - nusedj
      pmissj = 100.0e0 * nmissj / nj
      nmissk = nk - nusedk
      pmissk = 100.0e0 * nmissk / nk
      write(iprt, 1003) nmissj, nmissk, pmissj, pmissk
!
   10 write(iprt, 1006) lagmax
      if (ifmiss) write(iprt, 1007) ymissj, ymissk
!
      if (ysdj .gt. 0.0e0 .and. ysdk .gt. 0.0e0) go to 20
      write (iprt, 1008) j, k
      return
!
!     PRINT CCF INFORMATION
!
   20 continue
      write(iprt, 1002)
      write (iprt, 1001) j, k
     call ccflst (rhoc, sdrhoc, nlpp12, nlpp21, lagmax, lccov, ncc,&
     &   ifmiss)
!
!     PLOT CCF INFORMATION
!
      write(iprt, 1004)
      call versp (.true.)
      write (iprt, 1001) j, k
     call vpmn(rhoc, ymmiss, 2*lagmax+1, 1, 2*lagmax+1, 1, 0,&
    &   isym, 1, 0, -1.0e0, 1.0e0, real(-lagmax), 1.0e0, ifmiss,&
     &   0, 0, 1)
      return
!
!     FORMAT STATEMENTS
!
1000 format(/ 42x, 7hseries , i2, 5x, 7hseries , i2//&
    &   41h average of the series                 = , 2g14.7/&
    &   41h standard deviation of the series      = , 2g14.7/&
     &   41h number of time points                 = , 2(i10, 4x))
1001 format (42h cross correlation function estimate (ccf)//&
    &   22h ccf correlates series , i2, 22h at time t with series , i2,&
    &   15h at time t + k./&
    &   5x, 55h(if peak correlation occures at positive (negative) lag/&
     &   8x, 36hthen series 1 leads (lags) series 2))
 1002 format(//)
1003 format (&
    &   41h number of missing observations        = , 2(i10, 4x)/&
     &   41h percentage of observations missing    = , 2(f10.4, 4x))
 1004 format ('1')
 1005 format ( 27h cross correlation analysis)
1006 format(/&
     &   41h largest lag value to be used          = , i10)
1007 format(&
     &   41h missing value code                    = , 2g14.7)
1008 format (//35h cross correlations between series , i2, 5h and ,&
    &   i2, 22h could not be computed/&
    &   54h because the lag zero autocovariance of one or both of/&
     &   20h the series is zero.)
      end
!RANDU
      real(kind=wp) function randu(jd)
!***BEGIN PROLOGUE  RANDU  (ORIGINALLY UNI)
!***DATE WRITTEN   810915
!***REVISION DATE  900315
!***CATEGORY NO.  L6A21
!***KEYWORDS  RANDOM NUMBERS, UNIFORM RANDOM NUMBERS
!***AUTHOR    BLUE, JAMES
!             KAHANER, DAVID
!             APPLIED AND COMPUTATIONAL MATHEMATICS DIVISTION, NIST
!
!             MARSAGLIA, GEORGE
!             COMPUTER SCIENCE DEPT., WASH STATE UNIV
!
!             MODIFIED BY -
!             DONALDSON, JANET
!             APPLIED AND COMPUTATIONAL MATHEMATICS DIVISTION, NIST
!
!***PURPOSE  THIS ROUTINE GENERATES QUASI UNIFORM RANDOM NUMBERS ON
!             (0,1] AND CAN BE USED ON ANY COMPUTER WHICH ALLOWS
!             INTEGERS AT LEAST AS LARGE AS 32767.
!***DESCRIPTION
!
!       THIS ROUTINE GENERATES QUASI UNIFORM RANDOM NUMBERS ON THE
!       INTERVAL (0,1].  IT CAN BE USED WITH ANY COMPUTER WHICH ALLOWS
!       INTEGERS AT LEAST AS LARGE AS 32767.
!
!
!   USE
!       FIRST TIME....
!                   Z = RANDU(JD)
!                     HERE JD IS ANY  N O N - Z E R O  INTEGER.
!                     THIS CAUSES INITIALIZATION OF THE PROGRAM
!                     AND THE FIRST RANDOM NUMBER TO BE RETURNED AS Z.
!       SUBSEQUENT TIMES...
!                   Z = RANDU(0)
!                     CAUSES THE NEXT RANDOM NUMBER TO BE RETURNED AS Z.
!
!
!===================================================================
!   NOTE: USERS WHO WISH TO TRANSPORT THIS PROGRAM FROM ONE COMPUTER
!         TO ANOTHER SHOULD READ THE FOLLOWING INFORMATION:
!
!   MACHINE DEPENDENCIES...
!      MDIG = A LOWER BOUND ON THE NUMBER OF BINARY DIGITS AVAILABLE
!              FOR REPRESENTING INTEGERS, INCLUDING THE SIGN BIT.
!              THIS VALUE MUST BE AT LEAST 16, BUT MAY BE INCREASED
!              IN LINE WITH REMARK A BELOW.
!
!   REMARKS...
!     A. THIS PROGRAM CAN BE USED IN TWO WAYS:
!        (1) TO OBTAIN REPEATABLE RESULTS ON DIFFERENT COMPUTERS,
!            SET 'MDIG' TO THE SMALLEST OF ITS VALUES ON EACH, OR,
!        (2) TO ALLOW THE LONGEST SEQUENCE OF RANDOM NUMBERS TO BE
!            GENERATED WITHOUT CYCLING (REPEATING) SET 'MDIG' TO THE
!            LARGEST POSSIBLE VALUE.
!     B. THE SEQUENCE OF NUMBERS GENERATED DEPENDS ON THE INITIAL
!          INPUT 'JD' AS WELL AS THE VALUE OF 'MDIG'.
!          IF MDIG=16 ONE SHOULD FIND THAT
!            THE FIRST EVALUATION
!              Z=RANDU(305) GIVES Z=.027832881...
!            THE SECOND EVALUATION
!              Z=RANDU(0) GIVES   Z=.56102176...
!            THE THIRD EVALUATION
!              Z=RANDU(0) GIVES   Z=.41456343...
!            THE THOUSANDTH EVALUATION
!              Z=RANDU(0) GIVES   Z=.19797357...
!
!***REFERENCES  MARSAGLIA G., "COMMENTS ON THE PERFECT UNIFORM RANDOM
!                 NUMBER GENERATOR", UNPUBLISHED NOTES, WASH S. U.
!***ROUTINES CALLED  I1MACH,XERROR
!***END PROLOGUE  RANDU
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   jd
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   one,zero
     integer&
     &   i,j,j0,j1,jseed,k,k0,k1,m1,m2,mdig
!
!  LOCAL ARRAYS
     integer&
     &   m(17)
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     &   I1MACH
!       EXTERNAL I1MACH
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL XERROR
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,min,mod,real
!
!  SAVE STATEMENT
      save i,j,m,m1,m2
!
!
     data m(1),m(2),m(3),m(4),m(5),m(6),m(7),m(8),m(9),m(10),m(11),&
    &     m(12),m(13),m(14),m(15),m(16),m(17)/30788,23052,2053,19346,&
    &     10646,19427,23975,19049,10949,19693,29746,26748,2796,23890,&
     &     29168,31924,16499/
      data m1,m2,i,j/32767,256,5,17/
      data zero,one /0.0e0,1.0e0/
!
!***FIRST EXECUTABLE STATEMENT  RANDU
      if (jd.ne.0) then
!  FILL
          mdig = i1mach(8) + 1
!
!  MODIFICATION SO SAME NUMBERS WILL BE GENERATED ON ALL MACHINES
!  WITH I1MACH(8) AT LEAST 31
!
          mdig = min(mdig,32)
!
!  BE SURE THAT MDIG AT LEAST 16...
          if (mdig.lt.16) call xerror('RANDU--MDIG LESS THAN 16',22,1,2)
          m1 = 2** (mdig-2) + (2** (mdig-2)-1)
          m2 = 2** (mdig/2)
          jseed = min(abs(jd),m1)
          if (mod(jseed,2).eq.0) jseed = jseed - 1
          k0 = mod(9069,m2)
          k1 = 9069/m2
          j0 = mod(jseed,m2)
          j1 = jseed/m2
          do 10 i = 1,17
              jseed = j0*k0
              j1 = mod(jseed/m2+j0*k1+j1*k0,m2/2)
              j0 = mod(jseed,m2)
              m(i) = j0 + m2*j1
   10     continue
          i = 5
          j = 17
      end if
!  BEGIN MAIN LOOP HERE
      k = m(i) - m(j)
      if (k.lt.0) k = k + m1
      m(j) = k
      i = i - 1
      if (i.eq.0) i = 17
      j = j - 1
      if (j.eq.0) j = 17
      randu = real(k)/real(m1)
!
!  MODIFICATION SO RANDOM NUMBERS IN (0,1] RATHER THAN [0,1)
!
      if (randu.eq.zero) randu = one
      end
!AMEFIN
     subroutine amefin(y, weight, nnzw, wt, lwt, xm, n, m, ixm, ifixd,&
    &   par, npar, npare, res, page, wide, iptout, ndigit, rsshlf, rsd,&
    &   pvt, sdpvt, sdrest, rd, vcvl, lvcvl, d, amehdr, ivcvpt, iskull,&
     &   nrests)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPLETES THE ANALYSIS FOR THE NONLINEAR
!     LEAST SQUARES ESTIMATION ROUTINES ONCE THE ESTIMATES
!     HAVE BEEN FOUND.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rsd,rsshlf
     integer&
     &   ivcvpt,ixm,lvcvl,lwt,m,n,ndigit,nnzw,npar,npare,nrests
     logical&
     &   page,weight,wide
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   d(n,*),par(*),pvt(*),rd(*),res(*),sdpvt(*),sdrest(*),vcvl(*),&
     &   wt(*),xm(ixm,*),y(*)
     integer&
     &   ifixd(*),iptout(*),iskull(10)
!
!  SUBROUTINE ARGUMENTS
       external amehdr
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   cond,rss,yss
     integer&
     &   i,idf
     logical&
     &   exact,prtfsm
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL AMEOUT,NLCMP
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL COND
!        THE CONDITION NUMBER OF D.
!     REAL D(N,NPAR)
!        THE FIRST DERIVATIVE OF THE MODEL (JACOBIAN).
!     LOGICAL EXACT
!        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
!        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
!     EXTERNAL AMEHDR
!        THE ROUTINE USED TO PRINT THE HEADING
!     INTEGER IDF
!        THE DEGREES OF FREEDOM IN THE FIT.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IPTOUT(NDIGIT)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER ISKULL(10)
!        AN ERROR MESSAGE INDICATOR VARIABLE.
!     INTEGER IVCVPT
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
!        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
!        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)
!        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                       *INVERSE(HESSIAN)
!     INTEGER IXM
!        THE FIRST DIMENSION OF MATRIX XM.
!     INTEGER LVCVL
!        THE DIMENSION OF VECTOR VCVL.
!     INTEGER LWT
!        THE DIMENSION OF VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     LOGICAL PRTFSM
!        THE VARIABLE USED TO INDICATE WHETHER ANY OF THE SUMMARY
!        INFORMATION IS TO BE PRINTED (TRUE) OR NOT (FALSE).
!     REAL PVT(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
!     REAL RD(N)
!        THE DIAGONAL ELEMENTS OF THE R MATRIX OF THE Q - R
!        FACTORIZATION OF D.
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     REAL RSS
!        THE RESIDUAL SUM OF SQUARES.
!     REAL RSSHLF
!        HALF THE RESIDUAL SUM OF SQUARES.
!     REAL SDPVT(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDREST(N)
!        THE STANDARDIZED RESIDUALS.
!     REAL VCVL(LVCVL)
!        THE LOWER HALF OF THE VARIANCE-COVARIANCE MATRIX, STORED
!        ROW WISE.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     REAL XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!     REAL YSS
!        THE SUM OF THE SQUARES ABOUT THE MEAN Y VALUE.
!
!     MODIFY VCV TO REFLECT PROPER DEGREES OF FREEDOM
!
      do 10 i=1,lvcvl
         vcvl(i) = (nrests-npar)*vcvl(i)/(n-npar)
   10 continue
!
!     COMPUTE RETURNED AND/OR PRINTED VALUES.
!
     call nlcmp (y, weight, wt, lwt, n, npar, npare, res,&
    &   d, rd, cond, vcvl, lvcvl, nnzw, idf, rsshlf, rss, rsd, yss,&
     &   exact, pvt, sdpvt, sdrest, iskull)
!
     prtfsm = ((iptout(3).ne.0) .or. (iptout(4).ne.0) .or.&
     &   (iptout(5).ne.0) .or. (ierr.ne.0))
!
!     PRINT SUMMARY INFORMATION IF DESIRED OR IF AN ERROR FLAG
!     HAS BEEN SET.
!
     if (prtfsm) call ameout(y, n,&
    &   ifixd, par, npar, npare, res, iptout, ndigit, page, idf, cond,&
    &   rss, rsd, yss, exact, pvt, sdpvt, sdrest, vcvl, lvcvl, ivcvpt,&
     &   iskull, amehdr, wide)
      return
!
      end
!GFSLF
      subroutine gfslf (h, k)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE
!     GAIN FUNCTION OF A SYMMETRIC LINEAR FILTER (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   k
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   h(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,fmax,fmin,ypltmn,ypltmx
     integer&
     &   igferr,iprt,nf,nord,nprt
     logical&
     &   err01,err02,err03,head,sym
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   freq(101),gain(101),xord(101),yord(101)
     integer&
     &   isort(101)
     character&
     &   lh(8)*1,lk(8)*1,nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,ERIODD,ERSLF,GFORD,GFOUT,GFSEST,IPRINT,SETFRQ
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     LOGICAL ERR01, ERR02, ERR03
!        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     REAL FMAX, FMIN
!        THE MINIMUM AND MAXIMUM FREQUENCY FOR WHICH THE GAIN
!        FUNCTION IS TO BE ESTIMATED.
!     REAL FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        HAS BEEN ESTIMATED.
!     REAL GAIN(101)
!        THE VECTOR IN WHICH THE GAIN FUNCTION ESTIMATES ARE
!        STORED.
!     REAL H(K)
!        THE ARRAY OF SYMMETRIC LINEAR FILTER COEFFICIENTS.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IGFERR
!        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
!        TO HAVE PRODUCED REASONABLE RESULTS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER ISORT(101)
!        THE ARRAY USED FOR SORTING.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS.
!     CHARACTER*1 LH(8), LK(8)
!        THE ARRAY CONTAINING THE NAME OF THE VARIABLES H AND K.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        IS TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NORD
!        THE NUMBER OF POINTS TO BE PLOTTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     LOGICAL SYM
!        THE VARIABLE USED TO INDICATE WHETHER THE GAIN FUNCTION
!        COMPUTED WAS FOR A SYMMETRIC OR AUTOREGRESSIVE FILTER.
!     REAL XORD(101)
!        THE X COORDINATES FOR THE GAIN FUNCTION PLOT
!     REAL YORD(101)
!        THE Y COORDINATES FOR THE GAIN FUNCTION PLOT
!     REAL YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'G',       'F',       'S',       'L',       'F',       ' '/
     data&
    &  lh(1), lh(2), lh(3), lh(4), lh(5), lh(6), lh(7), lh(8)&
     & /  'H',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lk(1), lk(2), lk(3), lk(4), lk(5), lk(6), lk(7), lk(8)&
     & /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, lk, k, 1, 1, head, err01, lk)
!
      call eriodd(nmsub, lk, k, 1, head, err02)
!
      if ((.not. err01) .and. (.not. err02)) then
         call erslf(nmsub, lh, k, h, head, err03)
      else
         err03 = .false.
      end if
!
      if (err01 .or. err02 .or. err03) go to 10
      go to 20
!
   10 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   20 continue
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      sym = .true.
      nf = 101
!
      fmin = 0.0e0
      fmax = 0.5e0
!
      delta = 1.0e0
!
      nprt = -1
!
!     SET FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO BE ESTIMATED
!
      call setfrq (freq, nf, nprt, fmin, fmax, delta)
!
!     COMPUTE THE GAIN FUNCTION
!
      call gfsest (h, k, nf, freq, gain, delta)
!
!     PLOT THE RESULTS
!
     call gford (freq, gain, isort, nf, xord, yord, nord,&
     &   ypltmn, ypltmx, nprt, igferr)
!
     call gfout (xord, yord, nord, freq, gain, nf, k,&
     &   sym, fmin, fmax, ypltmn, ypltmx, nprt, igferr, nmsub)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   24h       call gfslf (h, k))
      end
!SPPLTD
     subroutine sppltd (spcmn, spcmx, alow, aup, ypltmn, ypltmx,&
     &   cilow, cimid, ciup, ymax)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SETS VARIOUS Y AXIS LIMITS FOR DECIBLE
!     SPECTRUM PLOTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   alow,aup,cilow,cimid,ciup,spcmn,spcmx,ymax,ypltmn,ypltmx
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   rngmn,ymin
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,log10
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALOW, AUP
!        FACTORS USED TO COMPUTE THE CONFIDENCE INTERVALS.
!     REAL CILOW, CIMID, CIUP
!        THE Y CORDNATES FOR THE LOWER  MID AND UPPER CONFIDENCE
!        INTERVAL POINTS.
!     REAL RNGMN
!        THE MINIMUM Y AXIS RANGE FOR THE PLOT.
!     REAL SPCMN, SPCMX
!        THE MINIMUM AND MAXIMUM SPECTRAL VALUE TO BE PLOTTED.
!     REAL YMAX, YMIN
!        THE MAXIMUM AND MINIMUM ACTUAL SPECTRAL VALUE
!        (IN DECIBELS) TO BE PLOTTED.
!     REAL YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VAUES TO BE PLOTTED FOR THE Y AXIS.
!
!     SET CO-ORDINATES FOR DECIBLE PLOTS
!
      ymax = 10.0e0 * log10(spcmx)
      ymin = 10.0e0 * log10(spcmn) - ymax
!
      ypltmx = 0.0e0
      rngmn = 20.0e0 * (log10(aup) - log10(alow))
      if (abs(ymin) .lt. rngmn) ypltmx = (rngmn + ymin) * 0.5e0
      ypltmn = ymin - ypltmx
      ciup = ypltmx
      cimid = ciup - 10.0e0 * log10(aup)
      cilow = cimid + 10.0e0 * log10(alow)
!
      return
      end
!MVPML
      subroutine mvpml(ym, ymmiss, n, m, iym, ns, ilog)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA AND MULTIPLE Y-AXIS VALUES
!     (LOG PLOT OPTION).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ilog,iym,m,n,ns
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(*),ymmiss(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ibar,iprt,irlin,ischck,isize,lisym
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(M)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'M',       'V',       'P',       'M',       'L',       ' '/
!
!     SET DEFAULT VALUES
!
      multi = .true.
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 1.0e0
      xinc = 1.0e0
      ischck = 2
      isize = -1
      miss = .true.
      lisym = 1
      irlin = -1
      ibar = 0
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ymmiss, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &  '       CALL MVPML (YM, YMMISS, N, M, IYM, NS, ILOG)')
      end
!SETFRQ
      subroutine setfrq (freq, nf, nprt, fmin, fmax, h)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE FREQUENCIES AT WHICH THE
!     SPECTRUM IS TO BE ESTIMATED.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fmax,fmin,h
     integer&
     &   nf,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(nf)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   deltaf
     integer&
     &   i
!
!  INTRINSIC FUNCTIONS
      intrinsic log10
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTAF
!        THE FREQUENCY INCREMENT.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCIES AT WHICH THE
!        SPECTRUM IS TO BE ESTIMATED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     REAL H
!        THE SAMPLING INTERVAL.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
!        ARE TO BE ESTIMATED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT EQUALS 2 THE FREQUENCY SCALE IS LINEAR, AND IF
!        NPRT EQUALS 3 THE FREQUENCY SCALE IS LOG.
!
      if (nprt .eq. 3) go to 20
!
!     COMPUTE FREQUENCY VALUES FOR LINEAR SCALE
!
      freq(1) = fmin
!
      if (nf .eq. 1) return
!
      deltaf = (fmax - fmin) / (h * (nf - 1))
      do 10 i = 2, nf
         freq(i) = freq(i-1) + deltaf
   10 continue
!
      freq(nf) = fmax
      return
!
   20 continue
!
!     COMPUTE FREQUENCY VALUES FOR LOG SCALE
!
      deltaf = (log10(fmax) - log10(fmin)) / (h * (nf - 1))
!
      freq(1) = fmin
!
      if (nf .eq. 1) return
!
      do 30 i = 2, nf
         freq(i) = 10.0e0**(log10(freq(i-1)) + deltaf)
   30 continue
!
      freq(nf) = fmax
!
!
      return
      end
!CCFMN
     subroutine ccfmn (y1, y2, n, lagmax, ncc, ccov11, ccov22, ccov12,&
     &   ccov21, lccov, y1mean, y2mean, rhoc, sdrhoc, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING CROSS CORRELATIONS AND
!     THEIR STANDARD ERRORS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   y1mean,y2mean
     integer&
     &   lagmax,lccov,n,ncc,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   ccov11(lccov),ccov12(lccov),ccov21(lccov),ccov22(lccov),&
     &   rhoc(ncc),sdrhoc(ncc),y1(n),y2(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fac
     integer&
     &   i,i0,im,ip
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL CCFSD,CCVF
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCOV11(LCCOV)
!        THE ARRAY IN WHICH THE AUTOCOVARIANCE FUNCTION ESTIMATES
!        FOR THE FIRST SERIES IS STORED.
!     REAL CCOV12(LCCOV), CCOV21(LCCOV)
!        THE ARRAYS IN WHICH THE CROSS COVARIANCE FUNCTION
!        ESTIMATES FOR THE FIRST SERIES LAGGED BEHIND THE SECOND
!        AND VISA VERSA, ARE STORED.
!     REAL CCOV22(LCCOV)
!        THE ARRAY IN WHICH THE AUTOCOVARIANCE FUNCTION ESTIMATES
!        FOR THE SECOND SERIES IS STORED.
!     REAL FAC
!        THE INVERSE OF THE SQUARE ROOT OF THE PRODUCT OF THE
!        AUTOCOVARIANCES AT LAG ZERO.
!     INTEGER I
!        THE INDEXING VARIABLE FOR THE LAG VALUE.
!     INTEGER  IM, IP, I0
!        THE LOCATIONS IN THE CCF RELATED ARRAYS
!        OF THE LAG -I, I, AND 0, RESPECTIVELY.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE AT WHICH THE CCVF IS TO BE COMPUTED.
!     INTEGER LCCOV
!        THE DIMENSION OF THE COVARIANCE RELATED ARRAYS.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NCC
!        THE NUMBER OF CCF COMPUTED.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO CONTROL COMPUTATIONS NEEDED
!        ONLY FOR PRINTED OUTPUT.
!     REAL RHOC(NCC)
!        THE ARRAY IN WHICH THE CROSS CORRELATIONS ARE STORED
!     REAL SDRHOC(NCC)
!        THE ARRAY CONTAINING THE STD. ERRORS OF THE CROSS CORRELATIONS.
!        ARE STORED
!     REAL Y1(N), Y1MEAN
!        THE FIRST SERIES, AND ITS MEAN.
!     REAL Y2(N), Y2MEAN
!        THE SECOND SERIES, AND ITS MEAN.
!
!     COMPUTE THE CROSS CORRELATIONS.
!
     call ccvf(y1, y2, n, lagmax, y1mean, y2mean, ccov12, ccov21,&
     &   lccov)
!
      if (nprt .eq. 0 .or. ccov11(1)*ccov22(1) .eq. 0.0e0) return
!
      fac = 1.0e0 / sqrt(ccov11(1) * ccov22(1))
!
      i0 = lagmax + 1
      rhoc(i0) = ccov12(1) * fac
      do 10 i = 1, lagmax
         ip = i0 + i
         rhoc(ip) = ccov12(i+1) * fac
!
         im = i0 - i
         rhoc(im) = ccov21(i+1) * fac
   10 continue
!
!     COMPUTE STANDARD ERROR OF THE CROSSCORRELATIONS.
!
      call ccfsd (ccov11, ccov22, sdrhoc, lagmax, ncc, n, lccov)
!
      return
      end
!IPGDV
     subroutine ipgdv (per, nf, n, peri, freq, xaxis, yaxis, isym,&
     &   lpcv, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES CO-ORDINATES FOR THE SPECTRAL PLOTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lpcv,n,nf,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(nf),per(nf),peri(nf),xaxis(lpcv),yaxis(lpcv)
     integer&
     &   isym(lpcv)
!
!  LOCAL SCALARS
     integer&
     &   ispcer,npts
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL IPGMN,IPGORD,IPGOUT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL FREQ(NF)
!        THE ARRAY IN WHICH THE FREQUENCIES AT WHICH THE PERIODOGRAM
!        WAS ESTIMATED ARE STORED.
!     INTEGER ISPCER
!        AN ERROR INDICATOR FOR THE INTEGRATED PERIODOGRAM COMPUTATIONS.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER N
!        THE ACTUAL NUMBER OF OBSERVATIONS IN THE SERIES FROM WHICH
!        THE PERIODOGRAM WAS COMPUTED.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A PAGE PLOT.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
!        ARE ESTIMATED.
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     REAL PER(NF)
!        THE RAW PERIODOGRAM.
!     REAL PERI(NF)
!        THE ARRAY CONTAINING THE INTEGRATED PERIODOGRAM VALUES.
!     REAL XAXIS(LPCV), YAXIS(LPCV)
!        THE X, Y CO-ORDINATES FOR THE SPECTRAL PLOTS.
!
!     COMPUTE THE INTEGRATED PERIODOGRAM
!
      call ipgmn(per, nf, peri, ispcer)
!
      if (ispcer .ne. 0) go to 10
!
      if (nprt .eq. 0) return
!
!     SET CO-ORDINATES FOR THE INTEGRATED PERIODOGRAM
!
      call ipgord(peri, nf, n, freq, xaxis, yaxis, isym, npts, lpcv)
!
!     PLOT THE INTEGRATED PERIODOGRAM
!
   10 call ipgout (xaxis, yaxis, isym, npts, lpcv, ispcer)
!
      return
!
      end
!DCKMN
     subroutine dckmn(j, d, par, scale, npar, eta, tau, mdl, xm,&
     &   n, nrow, m, ixm, pv, pvtemp, msg, lmsg)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR CHECKING USER SUPPLIED
!     ANALYTIC DERIVATIVES AGAINST NUMERICAL DERIVATIVES
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   d,eta,pv,scale,tau
     integer&
     &   ixm,j,lmsg,m,n,npar,nrow
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),pvtemp(n),xm(ixm,m)
     integer&
     &   msg(lmsg)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fd,parmx,pvpstp,stp,temp
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL DCKCRV,DCKZRO
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max,sign,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL D
!        THE SCALAR IN WHICH ROW   NROW   OF THE DERIVATIVE
!        MATRIX WITH RESPECT TO THE JTH UNKNOWN PARAMETER
!        IS STORED.
!     REAL ETA
!        THE RELATIVE NOISE IN THE MODEL
!     REAL FD
!        THE FORWARD DIFFERENCE QUOTIENT DERIVATIVE WITH RESPECT TO THE
!        JTH PARAMETER
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARTIAL DERIVATIVE BEING EXAMINED.
!     INTEGER LMSG
!        THE LENGTH OF THE VECTOR MSG.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER MSG(LMSG)
!        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL PARMX
!        THE MAXIMUM OF THE CURRENT PARAMETER ESTIMATE AND THE
!        TYPICAL VALUE OF THAT PARAMETER
!     REAL PV
!        THE SCALAR IN WHICH THE PREDICTED VALUE FROM THE MODEL FOR
!        ROW   NROW   IS STORED.
!     REAL PVPSTP
!        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
!        BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J) + STP.
!     REAL PVTEMP(N)
!        THE VECTOR OF PREDICTED VALUE FROM THE MODEL.
!     REAL SCALE
!        THE TYPICAL SIZE OF THE JTH PARAMETER.
!     REAL STP
!        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FINITE DIFFERENC
!        DERIVATIVE
!     REAL TAU
!        THE AGREEMENT TOLERANCE.
!     REAL TEMP
!        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
!        PARAMETER IS STORED.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
!     CALCULATE THE JTH PARTIAL DERIVATIVE USING FORWARD DIFFERENCE
!     QUOTIENTS AND DECIDE IF IT AGREES WITH USER SUPPLIED VALUES
!
      msg(j+1) = 0
!
      parmx = max(abs(par(j)),abs(scale))
      if (parmx .eq. 0.0e0) parmx = 1.0e0
!
!     COMPUTE INITIAL STEP SIZE
!
      stp = (sqrt(eta)*parmx*sign(1.0e0,par(j))+par(j)) - par(j)
!
!     COMPUTE PREDICTED VALUES
!
      temp = par(j)
      par(j) = par(j) + stp
      call mdl(par, npar, xm, n, m, ixm, pvtemp)
      par(j) = temp
!
      pvpstp = pvtemp(nrow)
!
      fd = (pvpstp-pv)/stp
!
!     CHECK FOR DISAGREEMENT
!
      if (abs(fd-d) .gt. tau*abs(d)) go to 10
!
!     NUMERICAL AND ANALYTIC DERIVATIVES AGREE
!
!     CHECK IF ANALYTIC DERIVATIVE IS IDENTICALLY ZERO, INDICATING
!     THE POSSIBILITY THAT THE DERIVATIVE SHOULD BE RECHECKED AT
!     ANOTHER POINT.
!
      if (d.ne.0.0e0) return
!
!     JTH ANALYTIC AND NUMERICAL DERIVATIVES BOTH ARE ZERO.
!
      if (msg(1).eq.0) msg(1) = 1
      msg(j+1) = 3
      return
!
   10 continue
!
!     NUMERICAL AND ANALYTIC DERIVATIVES DISAGREE
!
!     CHECK WHY
!
      if (d.eq.0.0e0) then
        call dckzro(j, par, npar, mdl, xm, n,&
    &      nrow, m, ixm, pv, pvtemp, msg, lmsg, fd, parmx, pvpstp,&
     &      stp)
      else
        call dckcrv(j, d, par, npar, eta, tau, mdl, xm,&
    &      n, nrow, m, ixm, pv, pvtemp, msg, lmsg, fd, parmx,&
     &      pvpstp, stp)
      end if
!
      return
      end
!ACFMS
     subroutine acfms (y, ymiss, n, lagmax, lacov, acov, amiss, nlppa,&
     &   nprt, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
!     CORRELATIONS OF A TIME SERIES WITH MISSING VALUES (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: amiss,ymiss
     integer&
     &   lacov,lagmax,ldstak,n,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(*),y(*)
     integer&
     &   nlppa(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   chia,chiap,fplm,ospvar,ymean,ysd
     integer&
    &   aic,ftest,i,iar,ifp,iprt,laglst,ldsmin,lyfft,nall0,nfac,&
     &   nfft,phi,prho,sdrho,work
     logical&
     &   differ,isfft
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   iod(1),nd(1),ndum(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      INTEGER
!     +   STKST
!      EXTERNAL R1MACH,STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACFER,ACFMNM,ACFOUT,IPRINT,LDSCMP,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV)
!        THE AUTOCOVARIANCE VECTOR.
!     INTEGER AIC
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE AKAIKES CRITERION FOR EACH ORDER.
!     REAL AMISS
!        THE MISSING VALUE CODE FOR THE RETURNED ACVF ESTIMATES
!        (VECTOR ACOV).
!     REAL CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     LOGICAL DIFFER
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER FTEST
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE PARTIAL F RATIO AND PROBABILITIES
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!     INTEGER IFP
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE FLOATING
!        POINT VARIABLES ARE SINGLE (IFP=3) OR DOUBLE (IFP=4) PRECISION.
!     INTEGER IOD(1)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGLST
!        THE LAST LAG BEFORE MISSING DATA CAUSED THE ACVF OF THE
!        SERIES NOT TO BE COMPUTED.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     INTEGER ND(1)
!        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
!     INTEGER NDUM(1)
!        A DUMMY ARRAY.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NLPPA(LACOV)
!        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
!        USED TO COMPUTE EACH ACVF ESTIMATE.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     REAL OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
!     INTEGER PHI
!        THE STARTING LOCATION IN DSTAK FOR THE
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     INTEGER PRHO
!        THE STARTING LOCATION IN THE WORK AREA FOR PRHO.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SDRHO
!        THE STARTING LOCATION IN THE WORK AREA FOR SDRHO.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR WORK.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     REAL YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER
!        OR NOT AN OBSERVATION IN THE SERIES IS MISSING.
!        IF Y(I) .EQ. YMISS, THE VALUE IS ASSUMED MISSING.
!        IF Y(I) .NE. YMISS, THE VALUE IS ASSUMED NOT MISSING.
!     REAL YSD
!        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'A',       'C',       'F',       'M',       'S',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      differ = .false.
      nfac = 1
      nd(1) = 0
      iod(1) = 0
      isfft = .false.
      lyfft = n
      nfft = n
!
      if (nprt .eq. 0) then
        ldsmin = 0
      else
        call ldscmp(5, 0, 0, 0, 0, 0, 'S', 6*lagmax+1, ldsmin)
      end if
!
     call acfer(nmsub, n, lagmax, lacov, ldstak, ldsmin,&
     &  differ, nfac, nd, iod, isfft, lyfft, nfft)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      if (ierr.eq.0) then
!
!       SET UP THE WORK AREA.
!
        call stkset(ldstak, 4)
        nall0 = stkst(1)
!
        fplm = r1mach(2)
!
        amiss = fplm
!
        if (nprt.eq.0) then
!
!         SPECIFY STARTING LOCATIONS IN THE STACK FOR DUMMY VARIABLES
!
          prho = 1
          aic = 1
          ftest = 1
          phi = 1
          work = 1
          sdrho = 1
        else
!
          ifp = 3
!
          prho = stkget(lagmax, ifp)
          aic = stkget(lagmax+1, ifp)
          ftest = stkget(2*lagmax, ifp)
          phi = stkget(lagmax, ifp)
          work = stkget(lagmax, ifp)
          sdrho = work
        end if
!
        if (ierr.eq.0) then
!
!         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
         call acfmnm (y, ymiss, n, lagmax, acov(2), rstak(sdrho),&
    &       nlppa, ymean, rstak(prho), rstak(aic), rstak(ftest),&
    &       rstak(phi), iar, ospvar, acov, lacov, lagmax+1, chia,&
     &       chiap, laglst, rstak(work), nprt)
!
          if (laglst .ge. 0) then
            ysd = sqrt (acov(1) * n / (n - 1))
          else
            ysd = acov(1)
          end if
!
!           CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
         if ((nprt.ne.0) .or. (acov(1).eq.0.0e0))&
    &      call acfout (ymean, ysd, n, nlppa(1), lagmax, acov(2),&
    &         rstak(sdrho), rstak(prho), nlppa, rstak(aic), lagmax+1,&
    &         rstak(ftest), iar, rstak(phi), ospvar, chia, chiap,&
    &         laglst, .true., ymiss, .false., .false., 0, ndum, ndum,&
     &         0)
!
          if (nprt.ne.0) then
            do 50 i = 1, lagmax
               acov(i+1) = acov(i+1) * acov(1)
   50       continue
          end if
        end if
!
        call stkclr(nall0)
      end if
!
      if (ierr.ne.0) then
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        ierr = 1
        call iprint (iprt)
        write (iprt, 1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format(/42h the correct form of the call statement is//&
    &  '       CALL ACFMS (Y, YMISS, N,'/&
    &  '      +            LAGMAX, LACOV, ACOV, AMISS, NLPPA, NPRT,',&
     &  ' LDSTAK)')
      end
!AMEPT2
      subroutine amept2 (res, sdrest, n, rss)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE, ADAPTED FROM OMNITAB II, PRINTS
!     THE FOUR STANDARDIZED RESIDUAL PLOTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rss
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   res(*),sdrest(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   an,dot,fac1,fac2,fplm,gamma,pi,ratio,rowdiv,rowmax,rowmid,&
     &   rowmin,xdiv,xmax,xmin,ylabel,ymax,ymin
     integer&
    &   i,i1,i2,imid,iplot,iprb,iprt,irow,ix,k,l,ncol,ncolp1,&
     &   ncolpl,ncolt2,ndot,nrow
     character&
     &   iblank*1,iminus*1,iplus*1,istar*1
!
!  LOCAL ARRAYS
     character&
     &   line(113)*1
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      LOGICAL
!     +   MVCHK
!      EXTERNAL R1MACH,MVCHK
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DOTC,GETPI,IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic int,max,min,mod
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AN
!        THE NUMBER OF OBSERVATIONS, USED IN COMPUTING
!        THE NORMAL PROBABILITY PLOT.
!     REAL DOT
!        THE DOT PRODUCT USED TO COMPUTE THE CORRELATION COEFFICIENT.
!     REAL FAC1, FAC2
!        FACTORS USED IN COMPUTING THE NORMAL PROBABILITY PLOT.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     REAL GAMMA
!        A VALUE USED IN COMPUTING THE NORMAL PROBABILITY PLOT.
!     INTEGER I
!        AN INDEX VARIABLE.
!     CHARACTER*1 IBLANK
!        THE VALUE OF THE CHARACTER -BLANK-.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IMID
!        THE MIDPOINT OF THE AUTOCORRELATION PLOT.
!     CHARACTER*1 IMINUS
!        THE CHARACTER MINUS.
!     INTEGER IPLOT
!        AN INDICATOR VARIABLE DESIGNATING WHETHER THE FIRST OR
!        SECOND SET OF TWO PLOTS ARE BEING PRINTED.
!     CHARACTER*1 IPLUS
!        THE CHARACTER PLUS.
!     INTEGER IPRB
!        THE LOCATION IN THE PLOT STRING OF THE SYMBOL FOR THE
!        PROBABILITY PLOT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IROW
!        THE ROW OF THE VARIABLES BEING PLOTTED.
!     CHARACTER*1 ISTAR
!        THE CHARACTER STAR.
!     INTEGER IX
!        THE LOCATION IN THE PLOT STRING OF THE SYMBOL FOR THE PLOTS
!        VERSUS THE INDEPENDENT VARIABLE.
!     INTEGER I1, I2
!        INDEX VALUES.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER L
!        AN INDEX VARIABLE.
!     CHARACTER*1 LINE(113)
!        THE SYMBOLS (BLANKS AND CHARACTERS) FOR A GIVEN LINE
!        OF THE PLOT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NCOL, NCOLPL, NCOLP1, NCOLT2
!        THE NUMBER OF COLUMNS IN THE PLOT, NCOL+L, NCOL+1,
!        AND NCOL * 2.
!     INTEGER NDOT
!        THE NUMBER OF POINTS MAKING UP DOT.
!     INTEGER NROW
!        THE NUMBER OF COLUMNS IN THE PLOT.
!     REAL PI
!        THE VALUE OF PI.
!     REAL RATIO
!        A VALUE USED TO PRODUCE THE NORMAL PROBABILITY PLOT.
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL ROWDIV
!        THE VALUE OF A DIVISION ALONG THE -ROW- AXIS.
!     REAL ROWMAX
!        THE LARGEST ROW VALUE.
!     REAL ROWMID
!        THE MIDPOINT OF THE RANGE OF THE ROWS PLOTTED.
!     REAL ROWMIN
!        THE SMALLEST ROW VALUE PLOTTED.
!     REAL RSS
!        THE RESIDUAL SUM OF SQUARES.
!     REAL SDREST(N)
!        THE STANDARDIZED RESIDUALS.
!     REAL XDIV
!        THE VALUE OF A DIVISION ALONG THE X AXIS.
!     REAL XMAX
!        THE LARGEST VALUE ALONG THE X AXIS.
!     REAL XMIN
!        THE SMALLEST VALUE ALONG THE X AXIS.
!     REAL YLABEL
!        THE LABEL TO BE PRINTED ALONG THE Y AXIS.
!     REAL YMAX
!        THE LARGEST VALUE ALONG THE Y AXIS
!     REAL YMIN
!        THE SMALLEST VALUE ALONG THE Y AXIS.
!
      data iplus/'+'/, iminus/'-'/, istar/'*'/, iblank/' '/
!
      call iprint(iprt)
!
      fplm = r1mach(2)
!
!     CHECK FOR INSUFFICIENT POINTS TO PLOT
!
      if (ierr.ne.4) go to 20
      do 10 i = 1, n
         if (sdrest(i).ne.fplm) go to 20
   10 continue
      write (iprt, 1090)
      return
!
   20 continue
!
!     INITIALIZE VALUES FOR PROBABILITY PLOT
!
      call getpi(pi)
      gamma = pi/8.0_wp
      an = n
      fac1 = 1.0_wp / (an - 2.0_wp*gamma + 1.0_wp)
      fac2 = 10.0_wp
!
!     INITIALIZE THE PLOT SIZE (IN PLOT UNITS)
!
      nrow = 26
!
!     BEGIN COMPUTATIONS FOR FIRST SET OF PLOTS
!
      iplot = 1
      ncol = 111
!
!     SET X AXIS LIMITS FOR STANDARDIZED RESIDUAL VS ROW PLOT,
!
      rowmin = 1
      rowmax = n
!
      rowmid = (rowmax+rowmin)/2.0_wp
      rowdiv = (rowmax-rowmin)/(ncol-1)
!
!     PRINT TITLES FOR FIRST PLOTS
!
      write (iprt,1000)
      go to 90
!
!     BEGIN COMPUTATIONS FOR SECOND SET OF PLOTS
!
   40 iplot = 2
      ncol = 51
!
!     SET AXIS LIMITS FOR THE STANDARDIZED RESIDUALS VS
!     STANDARDIZED RESIDUALS LAGGED BY ONE AND FOR PROBABILITY PLOT
!
      xmin = -3.75_wp
      xmax = 3.75_wp
      xdiv = (xmax-xmin)/(ncol-1)
!
!     PRINT TITLES FOR SECOND PLOTS
!
      write (iprt,1050)
!
!     WRITE FIRST LINE OF PLOTS
!
   90 continue
!
!     PRINT PLOTS, ONE LINE AT A TIME
!
      ncolp1 = ncol + 1
      ncolt2 = 2*ncol
      ylabel = 3.75_wp
      ymax = fplm
      ymin = 4.05_wp
      do 160 k=1,nrow
         ymin = ymin - 0.3_wp
         if (-3.70_wp.ge.ymin) ymin = -fplm
         do 100 l=1,ncol
            ncolpl = l + ncol
            line(l) = iblank
            if (iplot.eq.2) line(ncolpl) = iblank
            if ((k.ne.1) .and. (k.ne.nrow)) go to 100
               line(l) = iminus
               if (iplot.eq.2) line(ncolpl) = iminus
               if ((mod(l,10).ne.1) .and. (l.ne.1+ncol/2)) go to 100
                  line(l) = iplus
                  if (iplot.eq.2) line(ncolpl) = iplus
  100    continue
         do 130 i=1,n
            if (.not.mvchk(sdrest(i),fplm)) then
               if ((sdrest(i).gt.ymin) .and. (sdrest(i).le.ymax)) then
                  if (iplot.eq.1) then
                      irow = int(((i-rowmin)/rowdiv)+1.5_wp)
                      line(irow) = istar
                   else
                      ratio = (an-gamma) * fac1
                     iprb = int(4.91_wp*(ratio**0.14_wp-&
     &                          (1.0_wp-ratio)**0.14_wp)*fac2) + 77
                      if (iprb.le.ncol) iprb = ncol+1
                      if (iprb.ge.103) iprb = 102
                      line(iprb) = istar
                      an = an - 1.0_wp
                      if ((an.lt.2.0_wp) .and. (n.le.10)) then
                         gamma = 1.0_wp/3.0_wp
                      end if
                   end if
                end if
             end if
  130    continue
!
!     SET PLOT LINE FOR CORRELATION PLOT OF SECOND SET OF PLOTS
!
         if (iplot.eq.2) then
            imid = (ncol-1)/2
            if (k.le.n-1) then
               dot = 0.0_wp
              call dotc(res, 0.0_wp, n, res(k+1), 0.0_wp,&
     &                   n-k, dot, ndot)
               ix = int(imid*dot/rss) + imid + 1
               i1 = min(ix,imid+1)
               i2 = max(ix,imid+1)
               do 135 ix=i1,i2
                  line(ix) = istar
  135          continue
            end if
         end if
         if (mod(k,5).eq.1) then
            if (iplot.eq.1) then
               write (iprt,2020) ylabel, (line(l),l=1,ncol)
            else
              write (iprt,1020) k, (line(l),l=1,ncol), ylabel,&
     &                           (line(l),l=ncolp1,ncolt2)
            end if
            ylabel = ylabel - 1.5_wp
         else
            if (iplot.eq.1) then
               write (iprt,2030) (line(l),l=1,111)
            else
               write (iprt,1030) (line(l),l=1,102)
            end if
         end if
         ymax = ymin
  160 continue
!
!     PRINT BOTTOM LINE OF GRAPHS
!
      if (iplot.eq.1) then
!
!     PRINT X AXIS LABELS FOR FIRST SET OF PLOTS
!
         write (iprt,1040) rowmin, rowmid, rowmax
         go to 40
!
!     PRINT X AXIS LABELS FOR SECOND SET OF PLOTS
!
      else
         write (iprt,1070)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (/51x, 23h std res vs row number )
 1020 format (1x, i5, '+', 51a1, '+', 2x, f5.2, '+', 51a1, '+')
 1030 format (6x, '-', 51a1, '-', 7x, '-', 51a1, '-')
 1040 format (1x, f8.1, 47x, f8.1, 47x, f8.1)
1050 format (/13x, 'AUTOCORRELATION FUNCTION OF RESIDUALS',&
     &   23x, 36h normal probability plot of std res )
1070 format (4x, 5h-1.00, 22x, 3h0.0, 21x, 4h1.00, 5x, 4h-2.5, 23x,&
     &   3h0.0, 22x, 3h2.5)
1090 format (// 1x, 13(1h*)/ 1x, 13h*  warning  */ 1x, 13(1h*)//&
    &   54h the standardized residual plots have been suppressed.,&
    &   45h  none of the standardized residuals could be,&
    &   10h computed,/&
    &   50h because for each observation either the weight or,&
     &   48h the standard deviation of the residual is zero.)
 2020 format (1x, f5.2, '+', 111a1, '+')
 2030 format (6x, '-', 111a1, '-')
      end
!AMLST
     subroutine amlst (iamhd, par, npar, nfac, mspect, n, vcvl,&
    &   lvcvl, scale, lscale, stpt, lstpt, ifixd, rss, rsd, npardf,&
     &   npare, idf)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRINTS THE PARAMETER SUMMARY OUTPUT FROM THE
!     ARIMA FORECASTING SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 4, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rsd,rss
     integer&
     &   iamhd,idf,lscale,lstpt,lvcvl,n,nfac,npar,npardf,npare
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),scale(*),stpt(*),vcvl(*)
     integer&
     &   ifixd(*),mspect(nfac,4)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm,t975
     integer&
     &   iparmn,iparmx,iprt,lbltyp
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   PPFT,R1MACH
!      EXTERNAL PPFT,R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AMLST1,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER IAMHD
!        THE INDICATOR VALUE USED TO DESIGNATE THE TYPE OF LIST
!        TO BE GENERATED
!        IF IAMHD=1, THE LIST IS FOR THE INITIAL SUMMARY OF THE
!                    ESTIMATION ROUTINES.
!        IF IAMHD=2, THE LIST IS FOR THE INITIAL REPORT OF THE
!                    FORECASTING ROUTINES.
!        IF IAMHD=3, THE LIST IS FOR THE FINAL REPORT OF THE
!                    ESTIMATION ROUTINES.
!     INTEGER IDF
!        THE DEGREES OF FREEDOM IN THE FIT.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IPARMN
!        THE SMALLEST PARAMETER INDEX INCLUDED IN THIS TERM.
!     INTEGER IPARMX
!        THE LARGEST PARAMETER INDEX INCLUDED IN THIS TERM.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER LSTPT
!        THE DIMENSION OF VECTOR STPT.
!     INTEGER LVCVL
!        THE DIMENSION OF VECTOR VCVL.
!     INTEGER MSPECT(NFAC,4)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     REAL RSS
!        THE RESIDUAL SUM OF SQUARES.
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL STPT(LSTPT)
!        THE STEP SIZE ARRAY.
!     REAL T975
!        THE VALUE OF THE 97.5 PERCENT POINT FUNCTION FOR THE
!        T DISTRIBUTION.
!     REAL VCVL(LVCVL)
!        THE LOWER HALF OF THE VARIANCE-COVARIANCE MATRIX, STORED
!        ROW WISE.
!
      fplm = r1mach(2)
!
      call iprint(iprt)
!
!     PRINT HEADING FOR INFORMATION ABOUT PARAMETERS
!
      write(iprt, 1001)
!
      if (iamhd .eq. 1) write(iprt, 1004)
      if (iamhd .eq. 2) write(iprt, 1005)
      if (iamhd .eq. 3) write(iprt, 1006)
      write(iprt, 1001)
!
!     PRINT MODEL SUMMARY INFORMATION
!
      iparmn = 1
      iparmx = 0
      t975 = ppft(0.95e0, n-npar)
!
!     PRINT AUTOREGRESSIVE TERMS
!
      lbltyp = 1
     call amlst1 (iamhd, par, npar, mspect, nfac, vcvl, lvcvl,&
     &  scale, lscale, stpt, lstpt, iparmn, iparmx, lbltyp, t975, ifixd)
!
!     PRINT MEAN OR TREND TERM
!
      lbltyp = 2
     call amlst1 (iamhd, par, npar, mspect, 1, vcvl, lvcvl,&
     &  scale, lscale, stpt, lstpt, iparmn, iparmx, lbltyp, t975, ifixd)
!
!     PRINT MOVING AVERAGE TERMS
!
      lbltyp = 3
     call amlst1 (iamhd, par, npar, mspect, nfac, vcvl, lvcvl,&
     &  scale, lscale, stpt, lstpt, iparmn, iparmx, lbltyp, t975, ifixd)
!
      write (iprt, 1160) n
     if (iamhd.ge.2)&
     &   write (iprt, 1040) rss, rsd, n, npardf, npare, idf
      return
!
!     FORMAT STATEMENTS
!
 1001 format(1x)
1004 format (//73x, '  --STEP SIZE FOR'/&
    &  39x, '  ------PARAMETER', 17x, '  --APPROXIMATING'/&
    &  ' -----------------PARAMETER DESCRIPTION  STARTING VALUES',&
    &  '  ----------SCALE  -----DERIVATIVE'/&
    &  ' INDEX  ---------TYPE  --ORDER  --FIXED  ----------(PAR)',&
     &  '  --------(SCALE)  ----------(STP)')
1005 format(30x, '  ------PARAMETER'/&
    &  ' --------PARAMETER DESCRIPTION  ------ESTIMATES'/&
     &  ' INDEX  ---------TYPE  --ORDER  ----------(PAR)')
1006 format(&
    &  39x, '  ------PARAMETER  -----STD DEV OF', 17x,&
    &  '  ---------------------APPROXIMATE'/&
    &  ' -----------------PARAMETER DESCRIPTION  ------ESTIMATES',&
    &  '  ------PARAMETER  ----------RATIO',&
    &  '  ----95 PERCENT CONFIDENCE LIMITS'/&
    &  ' INDEX  ---------TYPE  --ORDER  --FIXED  ----------(PAR)',&
    &  '  ------ESTIMATES',&
     &  '  PAR/(SD OF PAR)  ----------LOWER  ----------UPPER')
1040 format (//' RESIDUAL SUM OF SQUARES       ', 8x, g15.7,&
    &  '  (BACKFORECASTS INCLUDED)'//6h resid,&
    &   25hual standard deviation   , 8x, g15.7/19h based on degrees o,&
     &   9hf freedom, 1x, i4, 3h - , i3, 3h - , i3, 3h = , i4)
 1160 format (//23h number of observations, 48x, 3h(n), 1x, i5)
      end
!XSTAT
      subroutine xstat(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS PROGRAM TESTS FEATURES OF THE STAT FAMILY TO ENSURE THAT
!     ALL ASPECTS OF THE STAT FAMILY ROUTINES WORK CORRECTLY.
!
!     WRITTEN BY  -  JOHN E. KOONTZ AND JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm,wtemp,ytemp1,ytempn
     integer&
     &   i,iprt,n,nconst,nprtof,nprton
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   sts(53),wt(84),wtall0(10),wtall1(84),y(84),yconst(10),&
     &   ypath(10)
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,STAT,STATS,STATW,STATWS
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        A LOOP INDEX.
!     INTEGER IERR
!        FLAG TO INDICATE PRESENCE OF ERROR DETECTED BY PRECEDING
!        STARPAC CALL.  (0 IS OK, 1 IS ERROR)
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER LDSTAK
!        AMOUNT OF WORK AREA.  SIZE OF DSTAK.
!     INTEGER N
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER NCONST
!        LENGTH OF THE VECTOR YCONST.
!     INTEGER NPRTOF
!        FLAG FOR NO OUTPUT (EXCEPT ERROR MESSAGES).
!     INTEGER NPRTON
!        FLAG FOR FULL PRINTOUT.
!     REAL STS(53)
!        VECTOR OF STATISTICS.
!     REAL WT(84)
!        WEIGHTS VECTOR.
!     REAL WTALL0(10)
!        N VECTOR OF 0 WEIGHTS.
!     REAL WTALL1(84)
!        N VECTOR OF 1 WEIGHTS.
!     REAL WTEMP
!        TEMPORARY STORAGE FOR ONE OF THE WEIGHTS.
!     REAL Y(84)
!        DATA VECTOR FOR TESTS.
!     REAL YCONST(10)
!        VECTOR OF CONSTANT DATA.
!     REAL YPATH(10)
!        A VECTOR OF Y VALUES DESIGNED TO FORCE DIFFERENT PATHS
!        THROUGH THE SUMMATION ROUTINES.
!     REAL YTEMPN, YTEMP1
!        TEMPORARY STORAGE FOR THE FIRST AND LAST Y VALUE.
!
!     DATA INITIALIZATIONS.
!
      data n /84/
      data nconst /10/
      data nprton /1/
      data nprtof /0/
!
!     DAVIS-HARRISON R.H. DATA, PIKES PEAK.
!
!     THIS IS AN ARBITRARILY CHOSEN DATA SET.
!
     data y( 1), y( 2), y( 3), y( 4)&
     &    / 0.6067e0, 0.6087e0, 0.6086e0, 0.6134e0/
     data y( 5), y( 6), y( 7)&
     &    / 0.6108e0, 0.6138e0, 0.6125e0/
     data y( 8), y( 9), y(10), y(11)&
     &    / 0.6122e0, 0.6110e0, 0.6104e0, 0.7213e0/
     data y(12), y(13), y(14)&
     &    / 0.7078e0, 0.7021e0, 0.7004e0/
     data y(15), y(16), y(17), y(18)&
     &    / 0.6981e0, 0.7242e0, 0.7268e0, 0.7418e0/
     data y(19), y(20), y(21)&
     &    / 0.7407e0, 0.7199e0, 0.6225e0/
     data y(22), y(23), y(24), y(25)&
     &    / 0.6254e0, 0.6252e0, 0.6267e0, 0.6218e0/
     data y(26), y(27), y(28)&
     &    / 0.6178e0, 0.6216e0, 0.6192e0/
     data y(29), y(30), y(31), y(32)&
     &    / 0.6191e0, 0.6250e0, 0.6188e0, 0.6233e0/
     data y(33), y(34), y(35)&
     &    / 0.6225e0, 0.6204e0, 0.6207e0/
     data y(36), y(37), y(38), y(39)&
     &    / 0.6168e0, 0.6141e0, 0.6291e0, 0.6231e0/
     data y(40), y(41), y(42)&
     &    / 0.6222e0, 0.6252e0, 0.6308e0/
     data y(43), y(44), y(45), y(46)&
     &    / 0.6376e0, 0.6330e0, 0.6303e0, 0.6301e0/
     data y(47), y(48), y(49)&
     &    / 0.6390e0, 0.6423e0, 0.6300e0/
     data y(50), y(51), y(52), y(53)&
     &    / 0.6260e0, 0.6292e0, 0.6298e0, 0.6290e0/
     data y(54), y(55), y(56)&
     &    / 0.6262e0, 0.5952e0, 0.5951e0/
     data y(57), y(58), y(59), y(60)&
     &    / 0.6314e0, 0.6440e0, 0.6439e0, 0.6326e0/
     data y(61), y(62), y(63)&
     &    / 0.6392e0, 0.6417e0, 0.6412e0/
     data y(64), y(65), y(66), y(67)&
     &    / 0.6530e0, 0.6411e0, 0.6355e0, 0.6344e0/
     data y(68), y(69), y(70)&
     &    / 0.6623e0, 0.6276e0, 0.6307e0/
     data y(71), y(72), y(73), y(74)&
     &    / 0.6354e0, 0.6197e0, 0.6153e0, 0.6340e0/
     data y(75), y(76), y(77)&
     &    / 0.6338e0, 0.6284e0, 0.6162e0/
     data y(78), y(79), y(80), y(81)&
     &    / 0.6252e0, 0.6349e0, 0.6344e0, 0.6361e0/
     data y(82), y(83), y(84)&
     &    / 0.6373e0, 0.6337e0, 0.6383e0/
     data wt( 1), wt( 2), wt( 3), wt( 4), wt( 5), wt( 6), wt( 7)&
     &   / 0.5e0, 0.5e0, 0.5e0, 0.5e0, 0.5e0, 0.5e0, 0.5e0/
     data wt( 8), wt( 9), wt(10), wt(11), wt(12), wt(13), wt(14)&
     &   / 0.5e0, 0.5e0, 0.5e0, 0.0e0, 0.0e0, 0.0e0, 0.0e0/
     data wt(15), wt(16), wt(17), wt(18), wt(19), wt(20), wt(21)&
     &   / 0.0e0, 0.0e0, 0.0e0, 0.0e0, 0.0e0, 0.0e0, 0.5e0/
     data wt(22), wt(23), wt(24), wt(25), wt(26), wt(27), wt(28)&
     &   / 0.5e0, 0.5e0, 0.5e0, 0.5e0, 0.5e0, 0.5e0, 0.5e0/
     data wt(29), wt(30), wt(31), wt(32), wt(33), wt(34), wt(35)&
     &   / 0.5e0, 0.5e0, 0.5e0, 0.5e0, 0.5e0, 0.5e0, 0.5e0/
     data wt(36), wt(37), wt(38), wt(39), wt(40), wt(41), wt(42)&
     &   / 0.5e0, 0.5e0, 0.5e0, 0.5e0, 0.5e0, 0.5e0, 0.5e0/
     data wt(43), wt(44), wt(45), wt(46), wt(47), wt(48), wt(49)&
     &   / 1.0e0, 1.0e0, 1.0e0, 1.0e0, 1.0e0, 1.0e0, 1.0e0/
     data wt(50), wt(51), wt(52), wt(53), wt(54), wt(55), wt(56)&
     &   / 1.0e0, 1.0e0, 1.0e0, 1.0e0, 1.0e0, 0.0e0, 0.0e0/
     data wt(57), wt(58), wt(59), wt(60), wt(61), wt(62), wt(63)&
     &   / 1.0e0, 1.0e0, 1.0e0, 1.0e0, 1.0e0, 1.0e0, 1.0e0/
     data wt(64), wt(65), wt(66), wt(67), wt(68), wt(69), wt(70)&
     &   / 1.0e0, 1.0e0, 1.0e0, 1.0e0, 1.0e0, 1.0e0, 1.0e0/
     data wt(71), wt(72), wt(73), wt(74), wt(75), wt(76), wt(77)&
     &   / 1.0e0, 1.0e0, 1.0e0, 1.0e0, 1.0e0, 1.0e0, 1.0e0/
     data wt(78), wt(79), wt(80), wt(81), wt(82), wt(83), wt(84)&
     &   / 1.0e0, 1.0e0, 1.0e0, 1.0e0, 1.0e0, 1.0e0, 1.0e0/
!
!     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
!
      call iprint(iprt)
!
      fplm = r1mach(2)
!
!     SET UP THE WEIGHTS VECTORS.
!
      do 10 i=1,n
         wtall1(i) = 1.0e0
   10 continue
      do 20 i=1,nconst
         yconst(i) = 1.0e0
         wtall0(i) = 0.0e0
   20 continue
!
!     HEADING.
!
      write (iprt,1150)
!
!     TEST 1.  CHECK ALL ERROR MESSAGES.
!
!     ERROR 1, TWO OR FEWER ELEMENTS.
!
      write (iprt,1180)
      write(iprt,1230)
      write(iprt,1240)
      call stat(y, 2, ldstak)
      write(iprt,1390) (y(i), i = 1, 10)
      write (iprt,1170) ierr
      write(iprt,1230)
      write(iprt,1250)
      call stats(y, 2, ldstak, sts, nprton)
      write(iprt,1390) (y(i), i = 1, 10)
      write (iprt,1170) ierr
      write(iprt,1230)
      write(iprt,1400)
      call statw(y, wt, 2, ldstak)
      write(iprt,1390) (y(i), i = 1, 10)
      write (iprt,1170) ierr
      write(iprt,1230)
      write(iprt,1410)
      call statws(y, wt, 2, ldstak, sts, nprton)
      write(iprt,1390) (y(i), i = 1, 10)
      write (iprt,1170) ierr
!
!     ERROR 2, NOT ENOUGH SPACE IN CSTAK.
!
      write (iprt,1190)
      write(iprt,1230)
      write(iprt,1240)
      call stat(y, n, n/4)
      write (iprt,1170) ierr
      write(iprt,1230)
      write(iprt,1250)
      call stats(y, n, n/4, sts, nprton)
      write (iprt,1170) ierr
      write(iprt,1230)
      write(iprt,1400)
      call statw(y, wt, n, n/4)
      write (iprt,1170) ierr
      write(iprt,1230)
      write(iprt,1410)
      call statws(y, wt, n, n/4, sts, nprton)
      write (iprt,1170) ierr
!
!     ERROR 4, NEGATIVE WEIGHTS.
!
      write (iprt,1210)
      wtemp = wt(2)
      wt(2) = -1.0e0
      write(iprt,1230)
      write(iprt,1400)
      call statw(y, wt, n, ldstak)
      write(iprt,1390) (y(i), i = 1, 10)
      write(iprt,1390) (y(i), i = 1, 10)
      write (iprt,1170) ierr
      write(iprt,1230)
      write(iprt,1410)
      call statws(y, wt, n, ldstak, sts, nprton)
      write(iprt,1390) (y(i), i = 1, 10)
      write(iprt,1390) (y(i), i = 1, 10)
      write (iprt,1170) ierr
      wt(2) = wtemp
!
!     ERROR 5, ALL WEIGHTS ZERO (PLUS CONSTANT Y).
!
      write (iprt,1220)
      write(iprt,1230)
      write(iprt,1400)
      call statw(yconst, wtall0, nconst, ldstak)
      write (iprt,1170) ierr
      write(iprt,1230)
      write(iprt,1410)
      call statws(yconst, wtall0, nconst, ldstak, sts, nprton)
      write (iprt,1170) ierr
!
!     TEST 2.  CHECK FOR READING OUTSIDE OF DATA ARRAY.
!
      write (iprt,1160)
      ytemp1 = yconst(1)
      yconst(1) = fplm
      ytempn = yconst(nconst)
      yconst(nconst) = fplm
      write(iprt,1440)
      write(iprt,1240)
      call stat(yconst(2), nconst-2, ldstak)
      write (iprt,1170) ierr
      write(iprt,1440)
      write(iprt,1250)
      call stats(yconst(2), nconst-2, ldstak, sts, nprton)
      write (iprt,1170) ierr
      write(iprt,1440)
      write(iprt,1400)
      call statw(yconst(2), wt, nconst-2, ldstak)
      write (iprt,1170) ierr
      write(iprt,1440)
      write(iprt,1410)
      call statws(yconst(2), wt, nconst-2, ldstak, sts, nprton)
      write (iprt,1170) ierr
      yconst(1) = ytemp1
      yconst(nconst) = ytempn
!
!     TEST 3.  CONSTANT Y.
!
      write (iprt,1200)
      write(iprt,1440)
      write(iprt,1240)
      call stat(yconst, nconst, ldstak)
      write (iprt,1170) ierr
      write(iprt,1440)
      write(iprt,1250)
      call stats(yconst, nconst, ldstak, sts, nprton)
      write (iprt,1170) ierr
      write(iprt,1440)
      write(iprt,1400)
      call statw(yconst, wt, nconst, ldstak)
      write (iprt,1170) ierr
      write(iprt,1440)
      write(iprt,1410)
      call statws(yconst, wt, nconst, ldstak, sts, nprton)
      write (iprt,1170) ierr
!
!     TEST 4.  SEE IF TURNING OFF THE PRINTOUT WORKS.
!
      write (iprt,1260)
      write (iprt,1270)
      write(iprt,1230)
      write(iprt,1250)
      call stats(y, n, ldstak, sts, nprtof)
      write(iprt,1390) (y(i), i = 1, 10)
      write (iprt,1280)
      write(iprt,1230)
      write(iprt,1410)
      call statws(y, wt, n, ldstak, sts, nprtof)
      write(iprt,1390) (y(i), i = 1, 10)
!
!     TEST 5.  MAKE A WORKING RUN OF EACH ROUTINE  FIRST WITH
!              N=2 (THE MINIMUN VALID VALUE) AND THEN FOR THE WHOLE
!              DATA SET TO CHECK THE OUTPUT.
!
      write (iprt,1300)
      write (iprt,1310)
      write(iprt,1240)
      call stat(y, 3, ldstak)
      write (iprt,1310)
      write(iprt,1240)
      call stat(y, n, ldstak)
      write(iprt,1390) (y(i), i = 1, 10)
      write (iprt,1170) ierr
!
      write (iprt,1320)
      write(iprt,1400)
      call statw(y, wt, 3, ldstak)
      write (iprt,1320)
      write(iprt,1400)
      call statw(y, wt, n, ldstak)
      write(iprt,1390) (y(i), i = 1, 10)
      write (iprt,1170) ierr
!
      write (iprt,1340)
      write(iprt,1250)
      call stats(y, 3, ldstak, sts, nprton)
      write (iprt,1340)
      write(iprt,1250)
      call stats(y, n, ldstak, sts, nprton)
      write(iprt,1390) (y(i), i = 1, 10)
      write (iprt,1170) ierr
!
      write (iprt,1350)
      write(iprt,1410)
      call statws(y, wt, 3, ldstak, sts, nprton)
      write (iprt,1350)
      write(iprt,1410)
      call statws(y, wt, n, ldstak, sts, nprton)
      write(iprt,1390) (y(i), i = 1, 10)
      write (iprt,1170) ierr
!
!     TEST 5.  CHECK RESULTS OF WEIGHTING ALL OBSERVATIONS
!              WITH 1.0E0.  COMPARE WITH STAT EXECUTION.
!
      write (iprt,1370)
      write(iprt,1400)
      call statw(y, wtall1, n, ldstak)
      write (iprt,1170) ierr
!
!     TEST 6.  CHECK RESULTS OF FORCING DIFFERENCE PATHS THROUGH
!              THE SUMMATION ROUTINES, USING SMALL, SIMPLE DATA SETS.
!
      write (iprt,1000)
!
!     RUN DATA SET 6.1
!
      do 30 i=1,10
         ypath(i) = i
   30 continue
      write (iprt,1010)
      write(iprt,1240)
      call stat(ypath, nconst, ldstak)
      write (iprt,1170) ierr
      write (iprt,1020)
      write(iprt,1400)
      call statw(ypath, wtall1, nconst, ldstak)
      write (iprt,1170) ierr
!
!     RUN DATA SET 6.2
!
      do 40 i=1,10
         ypath(i) = -i
   40 continue
      write (iprt,1030)
      write(iprt,1240)
      call stat(ypath, nconst, ldstak)
      write (iprt,1170) ierr
      write (iprt,1040)
      write(iprt,1400)
      call statw(ypath, wtall1, nconst, ldstak)
      write (iprt,1170) ierr
!
!     RUN DATA SET 6.3
!
      do 50 i=1,10
         ypath(i) = i-1
   50 continue
      write (iprt,1050)
      write(iprt,1240)
      call stat(ypath, nconst, ldstak)
      write (iprt,1170) ierr
      write (iprt,1060)
      write(iprt,1400)
      call statw(ypath, wtall1, nconst, ldstak)
      write (iprt,1170) ierr
!
!     RUN DATA SET 6.4
!
      do 60 i=1,10
         ypath(i) = 1-i
   60 continue
      write (iprt,1070)
      write(iprt,1240)
      call stat(ypath, nconst, ldstak)
      write (iprt,1170) ierr
      write (iprt,1080)
      write(iprt,1400)
      call statw(ypath, wtall1, nconst, ldstak)
      write (iprt,1170) ierr
!
!     RUN DATA SET 6.5
!
      do 70 i=1,10
         ypath(i) = i-6
   70 continue
      write (iprt,1090)
      write(iprt,1240)
      call stat(ypath, nconst, ldstak)
      write (iprt,1170) ierr
      write (iprt,1100)
      write(iprt,1400)
      call statw(ypath, wtall1, nconst, ldstak)
      write (iprt,1170) ierr
!
!     RUN DATA SET 6.6
!
      do 80 i=1,10
         ypath(i) = i-5
   80 continue
      write (iprt,1110)
      write(iprt,1240)
      call stat(ypath, nconst, ldstak)
      write (iprt,1170) ierr
      write (iprt,1120)
      write(iprt,1400)
      call statw(ypath, wtall1, nconst, ldstak)
      write (iprt,1170) ierr
!
!     RUN DATA SET 6.7
!
      do 90 i=1,10
         ypath(i) = 0.0e0
   90 continue
      ypath(1) = -5.0e0
      ypath(10) = 5.0e0
      write (iprt,1130)
      write(iprt,1240)
      call stat(ypath, nconst, ldstak)
      write (iprt,1170) ierr
      write (iprt,1140)
      write(iprt,1400)
      call statw(ypath, wtall1, nconst, ldstak)
      write (iprt,1170) ierr
!
!     RUN DATA SET 6.8
!
      do 100 i=1,10
         ypath(i) = 0.0e0
  100 continue
      ypath(1) = -5.0e0
      wtall1(1) = 0.0e0
      ypath(10) = 5.0e0
      wtall1(10) = 0.0e0
      write (iprt,1380)
      write(iprt,1400)
      call statw(ypath, wtall1, nconst, ldstak)
      write (iprt,1170) ierr
      return
!
!     FORMATS
!
1000 format(51h1test 6.  try different paths through the summation,&
     &   6h code.)
 1010 format('1RUN STAT ON 1, ..., 10.')
 1020 format('1RUN STATW ON 1, ..., 10.  WEIGHTS ARE ALL 1.')
 1030 format('1RUN STAT ON -1, ..., -10.')
 1040 format('1RUN STATW ON -1, ..., -10.  WEIGHTS ARE ALL 1.')
 1050 format('1RUN STAT ON 0, ..., 9.')
 1060 format('1RUN STATW ON 0, ..., 9.  WEIGHTS ARE ALL 1.')
 1070 format('1RUN STAT ON 0, ..., -9.')
 1080 format('1RUN STATW ON 0, ..., -9.  WEIGHTS ARE ALL 1.')
 1090 format('1STAT ON -5, ..., 4.')
 1100 format('1RUN STATW ON -5, ..., 4.  WEIGHTS ARE ALL 1.')
 1110 format('1RUN STAT ON -4, ..., 5.')
 1120 format('1RUN STATW ON -4, ..., 5.  WEIGHTS ARE ALL 1.')
 1130 format('1RUN STAT ON -1, 8*0, 1.')
 1140 format('1RUN STATW ON -1, 8*0, 1.  WEIGHTS ARE ALL 1.')
 1150 format('1TEST RUNS FOR THE STATISTICAL ANALYSIS FAMILY ROUTINES.')
1160 format('1TEST RUNS TO BE SURE CODE IS NOT READING OUTSIDE',&
     &       ' DATA ARRAY.')
 1170 format(/' THE VALUE OF IERR IS ', i4)
 1180 format('1TRY TWO OR FEWER ELEMENTS.')
 1190 format('1TRY INSUFFICIENT WORK AREA.')
 1200 format('1TRY CONSTANT Y.')
 1210 format('1TRY NEGATIVE WEIGHTS.')
 1220 format('1TRY ALL WEIGHTS ZERO (AND CONSTANT Y).')
 1230 format (///)
 1240 format (' CALL TO STAT')
 1250 format (' CALL TO STATS')
1260 format(45h1test3.  try turning off the print for those ,&
     &   24hroutines which allow it.)
 1270 format(37h try turning the print off for stats.)
 1280 format(38h try turning the print off for statws.)
1300 format(52h1test 4.  make working runs of all routines to check,&
     &   16h the statistics.)
 1310 format('1RUN STAT ON THE DAVIS-HARRISON PIKES PEAK DATA.')
 1320 format('1RUN STATW ON THE DAVIS-HARRISON PIKES PEAK DATA.')
 1340 format('1RUN STATS ON THE DAVIS-HARRISON PIKES PEAK DATA.')
 1350 format('1RUN STATWS ON THE DAVIS-HARRISON PIKES PEAK DATA.')
1370 format('1RUN STATW ON THE DAVIS-HARRISON PIKES PEAK DATA.',&
    &  '  WEIGHTS ALL EQUAL TO ONE.  COMPARE TO STAT ABOVE, NOT TO',&
     &  ' STATW.')
 1380 format(42h series with nonzero values weighted zero.)
 1390 format(/8h data = , 10f7.4)
 1400 format (14h call to statw)
 1410 format (15h call to statws)
 1440 format ('1')
      end
!SPP
      subroutine spp(ym, x, n, isym)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH USER CONTROL OF PLOT SYMBOLS (SHORT CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),ym(*)
     integer&
     &   isym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xlb,xmiss,xub,ylb,yub
     integer&
     &   ilog,iprt,ischck,isize,iym,lisym,m,nout
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ymmiss(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!     THE LABELED COMMON FOR COMMUNICATING ERROR FLAGS TO THE USER
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'S',       'P',       'P',       ' ',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      ymmiss(1) = 1.0e0
      xmiss = 1.0e0
      m = 1
      iym = n
      multi = .false.
      ilog = -1
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 0.0e0
      xub = 0.0e0
      ischck = 1
      isize = -1
      nout = 0
      miss = .false.
      lisym = n
!
     call ppcnt (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL SPP (Y, X, N, ISYM)')
      end
!NLITRP
     subroutine nlitrp(nlhdr, head, page, wide, iptout, npar, nnzw,&
     &   iwork, iiwork, rwork, irwork, ifixd, pare, npare)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS THE ITERATION REPORTS FOR THE
!     NONLINEAR LEAST SQUARES REGRESSION SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer iiwork,iptout,irwork,nnzw,npar,npare
      logical head,page,wide
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: pare(npar),rwork(irwork)
      integer ifixd(npar),iwork(iiwork)
!
!  SUBROUTINE ARGUMENTS
       external nlhdr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   rsd,rss,rssc,rsspc
     integer&
    &   dst0,f,f0,fdif,icase,iprt,isubhd,mxiter,nfcall,niter,&
     &   nreduc,preduc,reldx,stppar
     character&
     &   lettrn*1,lettry*1
!
!  LOCAL ARRAYS
     character&
     &   ischkd(2)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LSTVCF
!
!  INTRINSIC FUNCTIONS
      intrinsic mod,real,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER DST0
!        THE LOCATION IN RWORK OF THE VALUE OF THE 2 NORM OF D TIMES
!        THE  NEWTON STEP.
!     INTEGER F
!        THE LOCATION IN RWORK OF THE VALUE OF HALF THE RESIDUAL
!        SUM OF SQUARES AT THE CURRENT PARAMETER VALUES.
!     INTEGER FDIF
!        THE LOCATION IN RWORK OF THE DIFFERENCE BETWEEN THE
!        RESIDUAL SUM OF SQUARES AT THE BEGINNING AND END OF THE
!        CURRENT ITERATION.
!     INTEGER F0
!        THE LOCATION IN RWORK OF THE VALUE OF HALF THE RESIDUAL
!        VARIANCE AT THE BEGINNING OF THE CURRENT ITERATION.
!     LOGICAL HEAD
!        THE VARIABLE USED TO INDICATE WHETHER A HEADING IS TO BE
!        PRINTED DURING A GIVEN CALL TO THE ITERATION REPORT (TRUE)
!        OR NOT (FALSE).
!     INTEGER ICASE
!        AN INDICATER VARIABLE USED TO DESIGNATE THE MESSAGE TO BE
!        PRINTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IIWORK
!        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IRWORK
!        THE DIMENSION OF THE REAL WORK VECTOR RWORK.
!     CHARACTER*1 ISCHKD(2)
!        THE INDICATOR USED TO DESIGNATE WHETHER THE
!        TEST VALUE WAS CHECKED FOR CONVERGENCE (Y) OR NOT (N).
!     INTEGER ISUBHD
!        AN INTEGER VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IWORK(IIWORK)
!        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
!     CHARACTER*1 LETTRN, LETTRY
!        THE LETTERS N AND Y, RESPECTIVELY.
!     INTEGER MXITER
!        THE LOCATION IN IWORK OF THE VARIABLE DESIGNATING THE
!        MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER NFCALL
!        THE LOCATION IN IWORK OF THE NUMBER OF FUNCTION EVALUATIONS.
!     INTEGER NITER
!        THE LOCATION IN IWORK OF THE NUMBER OF THE CURRENT ITERATION.
!     EXTERNAL NLHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF UNKNOWN PARAMETERS TO BE OPTIMIZED.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NREDUC
!        THE LOCATION IN RWORK OF THE VALUE USED TO CHECK IF THE
!        HESSIAN APPROXIMATION IS POSITIVE DEFINITE.  IF
!        IF RWORK(NREDUC) .EQ. 0, THE HESSIAN IS SINGULAR, OTHERWISE
!        IT IS NOT.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PARE(NPAR)
!        THE CURRENT ESTIMATES OF THE UNKNOWN PARAMETERS, BUT ONLY
!        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
!     INTEGER PREDUC
!        THE LOCATION IN RWORK OF THE PREDICTED FUNCTION REDUCTION
!        FOR THE CURRENT STEP.
!     INTEGER RELDX
!        THE LOCATION IN RWORK OF THE SCALED RELATIVE CHANGE IN
!        THE PARAMETER VALUES CAUSED BY THE CURRENT ITERATION.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     REAL RSS
!        THE RESIDUAL SUM OF SQUARES.
!     REAL RSSC
!        THE CHANGE IN THE RESIDUAL SUM OF SQUARES CAUSED BY THIS
!        ITERATION.
!     REAL RSSPC
!        THE PREDICTED CHANGE IN THE RESIDUAL SUM OF SQUARES AT THIS
!        ITERATION.
!     REAL RWORK(IRWORK)
!        THE REAL WORK VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER STPPAR
!        THE LOCATION IN RWORK OF THE MARQUARDT LAMBDA PARAMETER.
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!
!
      data lettrn /'N'/, lettry /'Y'/
!
!     IWORK SUBSCRIPT VALUES
!
      data mxiter /18/, nfcall /6/, niter /31/
!
!     RWORK SUBSCRIPT VALUES
!
     data dst0 /3/, f /10/, fdif /11/, f0 /13/, nreduc /6/, preduc&
     &   /7/, reldx /17/, stppar /5/
!
      call iprint(iprt)
!
      if (iwork(1).eq.10) go to 90
     if ((iptout.eq.1) .and. (iwork(niter).ne.1) .and.&
     &   (iwork(niter).ne.iwork(mxiter)) .and. (iwork(1).le.2)) return
!
      isubhd = 0
      if (head) call nlhdr(page, wide, isubhd)
      head = .false.
      if (mod(iwork(niter),4).eq.0) head = .true.
!
      write (iprt,1000) iwork(niter)
!
!     COMPUTE STATISTICS TO BE PRINTED
!
      rss = 2.0e0*rwork(f)
      rsd = sqrt(rss)
      if (nnzw-npare.ge.1) rsd = rsd/sqrt(real(nnzw-npare))
!
      rssc = 0.0e0
      if (rwork(f0).gt.0.0e0) rssc = rwork(fdif)/rwork(f0)
!
      rsspc = 0.0e0
      if (rwork(f0).gt.0.0e0) rsspc = rwork(nreduc)/rwork(f0)
!
!     REFERENCE NL2 SUBROUTINE ASSESS, STATEMENT LABEL 300 TO 320
!
      ischkd(1) = lettrn
      ischkd(2) = lettrn
      if (rwork(fdif).gt.2.0e0*rwork(preduc)) go to 10
      if (rwork(dst0).lt.0.0e0) go to 10
      if (rwork(nreduc).ge.0.0e0) ischkd(1) = lettry
      if (rwork(stppar).eq.0.0e0) ischkd(2) = lettry
   10 continue
!
     write (iprt,1010) iwork(nfcall), rsd, rss, rssc, rsspc,&
     &   ischkd(1), rwork(reldx), ischkd(2)
      if (npare.lt.npar) write (iprt,1020)
      if (npare.ge.npar) write (iprt,1150)
      call lstvcf(npare, pare, npar, ifixd)
!
      if (iwork(1).le.2) return
!
!     PRINT FINAL ITERATION MESSAGE
!
      icase = iwork(1) - 2
     go to (20, 30, 40, 50, 60, 70, 80, 90, 100, 140, 110, 120, 130),&
     &   icase
!
!     ***** PARAMETER CONVERGENCE *****
!
   20 write (iprt,1030)
      return
!
!     ***** RESIDUAL SUM OF SQUARES CONVERGENCE *****
!
   30 write (iprt,1040)
      return
!
!     ***** PARAMETER AND RESIDUAL SUM OF SQUARES CONVERGENCE ****
!
   40 write (iprt,1050)
      return
!
!     ***** RESIDUAL SUM OF SQUARES IS EXACTLY ZERO *****
!
   50 write (iprt,1060)
      return
!
!     ***** SINGULAR CONVERGENCE *****
!
   60 write (iprt,1070)
      return
!
!     ***** FALSE CONVERGENCE *****
!
   70 write (iprt,1080)
      return
!
!     ***** LIMIT ON NUM. OF CALLS TO THE MODEL SUBROUTINE REACHED *****
!
   80 write (iprt,1090)
      return
!
!     ***** ITERATION LIMIT REACHED *****
!
   90 write (iprt,1100)
      return
!
!     ***** STOPX *****
!
  100 write (iprt,1110)
      return
!
!     ***** INITIAL RESIDUAL SUM OF SQUARES OVERFLOWS *****
!
  110 write (iprt,1120)
      return
!
!     ***** BAD PARAMETERS TO ASSESS *****
!
  120 write (iprt,1130)
      return
!
!     ***** J COULD NOT BE COMPUTED *****
!
  130 write (iprt,1140)
      return
!
  140 return
!
!      FORMAT STATEMENTS
!
 1000 format (//17h iteration number, i5/1x, 22('-'))
1010 format (5x, 5hmodel, 53x, 10hforecasted/5x, 5hcalls, 9x, 3hrsd,&
    &   13x, 3hrss, 8x, 12hrel chng rss, 4x, 12hrel chng rss, 4x,&
    &   12hrel chng par/62x, 5hvalue, 3x, 4hchkd, 4x, 5hvalue, 3x,&
     &   4hchkd/3x, i7, 3(2x, g14.4), 2(g12.4, 3x, a1))
1020 format (/5x, 25h current parameter values, 19h (only unfixed para,&
     &   18hmeters are listed))
 1030 format (/34h ***** parameter convergence *****)
 1040 format (/48h ***** residual sum of squares convergence *****)
1050 format (/44h ***** parameter and residual sum of squares,&
     &   18h convergence *****)
1060 format (/50h ***** the residual sum of squares is exactly zero,&
     &   6h *****)
 1070 format (/33h ***** singular convergence *****)
 1080 format (/30h ***** false convergence *****)
1090 format (/44h ***** limit on number of calls to the model,&
     &   25h subroutine reached *****)
 1100 format (/36h ***** iteration limit reached *****)
 1110 format (/18h ***** stopx *****)
1120 format (/53h ***** initial residual sum of squares overflows ****,&
     &   1h*)
 1130 format (/37h ***** bad parameters to assess *****)
 1140 format (/52h ***** derivative matrix could not be computed *****)
 1150 format (/5x, 25h current parameter values)
      end
!ADJLMT
subroutine adjlmt(ymn, ymx)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     This routine corrects the plot limits when all
!     observations are identically equal.
!
!     WRITTEN BY - Janet R. Donaldson
!                  Statistical Engineering Division
!                  National Bureau of Standards, Boulder, Colorado
!
!     CREATION DATE  -  January 21, 1982
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp),intent(inout) :: ymn,ymx
!  INTRINSIC FUNCTIONS
      intrinsic :: abs
!  VARIABLE DEFINITIONS (ALPHABETICALLY)
!     REAL(KIND=WP) :: YMN, YMX
!        THE Y-AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
!
      if (ymn .lt. ymx) return
!
!     CORRECT FOR ALL OBSERVATIONS IDENTICALLY EQUAL
!
      ymn = ymn - abs(ymn/2.0_wp)
      ymx = ymx + abs(ymx/2.0_wp)
      if (ymn .lt. ymx) return
      ymn = -0.5_wp
      ymx = 0.5_wp
!
end subroutine adjlmt
!XXCH7
      subroutine xxch7(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     TEST SUBPROGRAM FOR SIMPLE TEST OF
!     THE CORRELATION ANALYSIS FAMILY OF ROUTINES.
!
!     DATA IS FROM DRAPER AND SMITH [1968], PAGE 216.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,iym,m,n
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ym(10,5)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL CORR,IPRINT
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER IYM
!        THE FIRST DIMENSION OF THE ARRAY YM.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER M
!        THE NUMBER OF VARIABLES MEASURED FOR EACH OBSERVATION.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     REAL YM(10,5)
!        THE OBSERVED MULTIVARIATE DATA.
!
!
     data     ym(1,1),   ym(1,2),   ym(1,3),   ym(1,4)&
     &    /      42.2e0,  11.2e0,  31.9e0, 167.1e0/
     data     ym(2,1),   ym(2,2),   ym(2,3),   ym(2,4)&
     &    /      48.6e0,  10.6e0,  13.2e0, 174.4e0/
     data     ym(3,1),   ym(3,2),   ym(3,3),   ym(3,4)&
     &    /      42.6e0,  10.6e0,  28.7e0, 160.8e0/
     data     ym(4,1),   ym(4,2),   ym(4,3),   ym(4,4)&
     &    /      39.0e0,  10.4e0,  26.1e0, 162.0e0/
     data     ym(5,1),   ym(5,2),   ym(5,3),   ym(5,4)&
     &    /      34.7e0,   9.3e0,  30.1e0, 140.8e0/
     data     ym(6,1),   ym(6,2),   ym(6,3),   ym(6,4)&
     &    /      44.5e0,  10.8e0,   8.5e0, 174.6e0/
     data     ym(7,1),   ym(7,2),   ym(7,3),   ym(7,4)&
     &    /      39.1e0,  10.7e0,  24.3e0, 163.7e0/
     data     ym(8,1),   ym(8,2),   ym(8,3),   ym(8,4)&
     &    /      40.1e0,  10.0e0,  18.6e0, 174.5e0/
     data     ym(9,1),   ym(9,2),   ym(9,3),   ym(9,4)&
     &    /      45.9e0,  12.0e0,  20.4e0, 185.7e0/
!
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      call iprint(iprt)
      iym = 10
      n = 9
      m = 4
!
!     PRINT HEADER
!
      write (iprt,1000)
!
!     RUN SIMPLE EXAMPLE OF CORR
!
      write (iprt,1100)
      call corr(ym, n, m, iym, ldstak)
      write (iprt,2000) ierr
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format ('1*CH7')
 1100 format (' SIMPLE TEST OF CORR')
 2000 format (/' THE VALUE OF IERR IS ', i4)
!
      end
!LLER
     subroutine ller(nmsub, ixm, ivcv, n, npar, lpar, ldstak, wt, lnwt,&
     &   weight, nnzw, ifit, save)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE ERROR CHECKING ROUTINE FOR THE LINEAR LEAST
!     SQUARES LLSTING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ifit,ivcv,ixm,ldstak,lnwt,lpar,n,nnzw,npar
     logical&
     &   save,weight
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   wt(*)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   i,ldsmin,nzw
     logical&
     &   head
!
!  LOCAL ARRAYS
     logical&
     &   error(10)
     character&
    &   livcv(8)*1,lixm(8)*1,llds(8)*1,llpar(8)*1,ln(8)*1,&
    &   ln1(8)*1,lnc(8)*1,lndeg(8)*1,lndeg1(8)*1,lnpar(8)*1,&
     &   lone(8)*1,lwt(8)*1,lzero(8)*1
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL EISGE,EISII,ERVWT,LDSCMP
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR(10)
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIT
!        THE INDICATOR VALUE DESIGNATING WHETHER THE LLS IS OF A
!        GENERAL MODEL (IFIT=3) OR A POLYNOMIAL MODEL (IFIT=1).
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     CHARACTER*1 LIVCV(8), LIXM(8), LLPAR(8), LLDS(8), LN(8), LNC(8),
!    *   LNDEG(8), LNDEG1(8), LNPAR(8), LN1(8), LONE(8), LWT(8),
!    *   LZERO(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LNWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NZW
!        THE NUMBER OF ZERO WEIGHTS.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(LNWT)
!        THE USER SUPPLIED WEIGHTS.
!
!     SET UP NAME ARRAYS
!
     data livcv(1), livcv(2), livcv(3), livcv(4), livcv(5), livcv(6),&
     &   livcv(7), livcv(8) /'I','V','C','V',' ',' ',' ',' '/
     data lixm(1), lixm(2), lixm(3), lixm(4), lixm(5), lixm(6),&
     &   lixm(7), lixm(8) /'I','X','M',' ',' ',' ',' ',' '/
     data llds(1), llds(2), llds(3), llds(4), llds(5), llds(6),&
     &   llds(7), llds(8) /'L','D','S','T','A','K',' ',' '/
     data llpar(1), llpar(2), llpar(3), llpar(4), llpar(5), llpar(6),&
     &   llpar(7), llpar(8) /'L','P','A','R',' ',' ',' ',' '/
     data ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8) /'N',&
     &   ' ',' ',' ',' ',' ',' ',' '/
     data lndeg(1), lndeg(2), lndeg(3), lndeg(4), lndeg(5), lndeg(6),&
     &   lndeg(7), lndeg(8) /'N','D','E','G',' ',' ',' ',' '/
     data lndeg1(1), lndeg1(2), lndeg1(3), lndeg1(4), lndeg1(5),&
    &   lndeg1(6), lndeg1(7), lndeg1(8) /'N','D','E','G','+','1',&
     &   ' ',' '/
     data lnpar(1), lnpar(2), lnpar(3), lnpar(4), lnpar(5),&
    &   lnpar(6), lnpar(7), lnpar(8) /'N','P','A','R',' ',' ',' ',&
     &   ' '/
     data ln1(1), ln1(2), ln1(3), ln1(4), ln1(5), ln1(6),&
     &   ln1(7), ln1(8) /'N','-','1',' ',' ',' ',' ',' '/
     data lone(1), lone(2), lone(3), lone(4), lone(5), lone(6),&
     &   lone(7), lone(8) /'O','N','E',' ',' ',' ',' ',' '/
     data lwt(1), lwt(2), lwt(3), lwt(4), lwt(5), lwt(6), lwt(7),&
     &   lwt(8) /'W','T',' ',' ',' ',' ',' ',' '/
     data lzero(1), lzero(2), lzero(3), lzero(4), lzero(5), lzero(6),&
     &   lzero(7), lzero(8) /'Z','E','R','O',' ',' ',' ',' '/
!
!     ERROR CHECKING
!
      ierr = 0
      head = .true.
!
      do 10 i=1,10
         error(i) = .false.
   10 continue
!
      if (ifit.eq.1) go to 30
!
      do 20 i = 1, 8
         lnc(i) = lnpar(i)
   20 continue
      go to 50
!
   30 continue
      do 40 i = 1, 8
         lnc(i) = lndeg1(i)
   40 continue
!
   50 continue
!
      call eisge(nmsub, ln, n, 1, 1, head, error(1), ln)
!
     if (ifit.eq.3)&
    &   call eisii(nmsub, lnpar, npar, 1, n, 1, head, error(2), lone,&
     &   ln)
     if (ifit.eq.1)&
    &   call eisii(nmsub, lndeg, npar-1, 0, n-1, 1, head, error(2),&
     &      lzero, ln1)
!
      call eisge(nmsub, lixm, ixm, n, 3, head, error(4), ln)
!
     if (save .and. (ifit.eq.1))&
     &   call eisge(nmsub, llpar, lpar, npar, 7, head, error(5), lndeg1)
!
     if (save)&
     &    call eisge(nmsub, livcv, ivcv, npar, 3, head, error(6), lnc)
!
      if (error(1) .or. error(2) .or. error(3)) go to 70
!
      nnzw = n
     if (weight) call ervwt(nmsub, lwt, wt, n, npar, head, nnzw,&
     &   nzw, 2, error(8), lnc)
!
     call ldscmp(15, 0, 0, 0, 0, 0, 'S',&
     &            6*n + npar*(n+2*npar+5) + 1, ldsmin)
!
      call eisge(nmsub, llds, ldstak, ldsmin, 9, head, error(9), llds)
!
      do 60 i=1,10
         if (error(i)) go to 70
   60 continue
      return
!
   70 continue
      ierr = 1
      return
!
      end
!MVP
      subroutine mvp(ym, n, m, iym, ns)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MULTIPLE Y-AXIS VALUES (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iym,m,n,ns
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ibar,ilog,iprt,irlin,ischck,isize,lisym
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'M',       'V',       'P',       ' ',       ' ',       ' '/
!
!     DEFINE CONSTANTS
!
!     SET DEFAULT VALUES
!
      multi = .true.
      ilog = -1
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 1.0e0
      xinc = 1.0e0
      ischck = 2
      isize = -1
      miss = .false.
      lisym = 1
      irlin = -1
      ibar = 0
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ym, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL MVP (YM, N, M, IYM, NS)')
      end
!STAT2
      subroutine stat2(y, n, sts, sumda, sumdi, sumd2, sumd3, sumd4)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES FOR A VECTOR Y THE STATISTICS THAT DO
!     NOT REQUIRE SORTING OF THE VECTOR, THAT IS, THOSE NOT COMPUTED
!     BY STAT1.  NO WEIGHTS ARE USED.
!
!     THIS SUBROUTINE IS BASED ON A MODIFICATION OF THE STATIS
!     CODE USED IN OMNITAB, VERSION 5 (6/16/72), WRITTEN BY
!     SALLY PEAVY.  THE ORIGINAL ADAPTATION TO STARPAC WAS
!     DONE BY JANET DONALDSON.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   sumd2,sumd3,sumd4,sumda,sumdi
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   sts(53),y(n)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   dif,t,ta,tk1,tk2
     integer&
     &   i,ic,ici,idruns,iminus,iplus,irun
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   cdff,ppfchs,ppft
!       EXTERNAL CDFF,PPFCHS,PPFT
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,sqrt
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DIF
!        THE SUM OF THE DIFFERENCES BETWEEN SUCCEEDING ELEMENTS
!        IN Y.
!     INTEGER I
!        A LOOP INDEX.
!     INTEGER IC
!        PREVIOUS SIGN IN RUNS CALCULATION.
!     INTEGER ICI
!        CURRENT SIGN IN RUNS CALCULATION.
!     INTEGER IDRUNS
!        THE NUMBER OF RUNS.
!     INTEGER IERR
!        AN ERROR FLAG SET IN COMMON ERRCHK.
!     INTEGER IMINUS, IPLUS
!        COUNTS OF SIGNS OF DEVIATIONS.
!     INTEGER IRUN
!        THE NUMBER OF RUNS UP AND DOWN.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y AND WT.
!     REAL STS(53)
!        OUTPUT PARAMETER.  THE VECTOR OF 53 STATISTICS COMPUTED.
!        ROW STATISTIC                    ROW STATISTIC
!         1  LENGTH OF VECTOR             TESTS FOR NONRANDOMNESS
!         2  NUMBER OF NONZERO WEIGHTS    23  NUMBER OF RUNS UP AND DOWN
!        MEASURES OF LOCATION             24  EXPECTED NUMBER OF RUNS
!         3  UNWEIGHTED MEAN              25  S.D. OF NUMBER OF RUNS
!         4  WEIGHTED MEAN                26  MEAN SQR. SUCCESSIVE DIFF.
!         5  MEDIAN                       27  MEAN SQR. SUCC. DIFF./VAR.
!         6  MID-RANGE                    DEVIATIONS FROM WTD MEAN
!         7  25 P.C. UNWTD. TRIMMED MEAN  28  NUMBER OF + SIGNS
!         8  25 P.C. WTD. TRIMMED MEAN    29  NUMBER OF - SIGNS
!        MEASURES OF DISPERSION           30  NUMBER OF RUNS
!         9  STANDARD DEVIATION (S.D.)    31  EXPECTED NUMBER OF RUNS
!        10  S.D. OF MEAN                 32  S.D. OF RUNS
!        11  RANGE                        33  DIFF./S.D. OF RUNS
!        12  MEAN VARIATION               OTHER STATISTICS
!        13  VARIANCE (VAR.)              34  MINIMUM
!        14  COEFFICIENT OF VARIATION     35  MAXIMUM
!        CONFIDENCE INTERVALS             36  BETA 1
!        15  LOWER CONFIDENCE LIMIT, MEAN 37  BETA 2
!        16  UPPER CONFIDENCE LIMIT, MEAN 38  WTD. SUM OF VALUES
!        17  LOWER CONFIDENCE LIMIT, S.D. 39  WTD. SUM OF SQUARES
!        18  UPPER CONFIDENCE LIMIT, S.D. 40  WTD. SUM OF SQRD. DEVS.
!        LINEAR TREND STATISTICS          41  STUDENTS T
!        19  SLOPE                        42  WTD. SUM OF ABS. VALUES
!        20  S.D. OF SLOPE                43  WTD. AVG. ABS. VALUES
!        21  SLOPE/S.D. OF SLOPE = T      44-53 FREQ. DISTRIBUTION
!        22  PROB ( X .GT. ABS(OBS. T))
!     REAL SUMDA
!        INPUT PARAMETER.  THE SUM OF THE ABSOLUTE VALUES OF THE
!        DIFFERENCES DIFF.
!     REAL SUMDI
!        INPUT PARAMETER.  THE SUM OF THE PRODUCTS OF I AND THE
!        ITH DIFFERENCE DIFF.
!     REAL SUMD2
!        INPUT PARAMETER.  THE SUM OF THE SQUARES OF THE
!        DIFFERENCES DIFF.
!     REAL SUMD3
!        INPUT PARAMETER.  THE SUM OF THE CUBES OF THE
!        DIFFERENCES DIFF.
!     REAL SUMD4
!        INPUT PARAMETER.  THE SUM OF THE HYPERCUBES OF THE
!        DIFFERENCES DIFF.
!     REAL T
!        A RESIDUAL (Y(I) - MEANY)
!     REAL TA
!        A TEMPORARY VARIABLE IN THE RUNS CALCULATION.
!     REAL TK1, TK2
!        CHI-SQUARED VALUES.
!     REAL Y(N)
!        INPUT PARAMETER.  A SET OF N DATA POINTS, SORTED
!        INTO ASCENDING ORDER.
!
!
!     BEGIN STORAGE OF STATISTICS.
!
      sts(1) = n
      sts(2) = sts(1)
      sts(24) = (2.0e0*sts(1)-1.0e0)/3.0e0
      sts(25) = sqrt((16.0e0*sts(1)-29.0e0)/90.0e0)
      sts(43) = sts(42)/sts(1)
!
!     COMPUTE RESIDUALS AND STANDARD DEVIATIONS.
!
      ici = 0
      iplus = 0
      iminus = 0
      idruns = 0
      ic = 0
      do 30 i=1,n
         t = y(i) - sts(4)
         if (t.lt.0.0e0) go to 10
         iplus = iplus + 1
         ici = +1
         go to 20
   10    iminus = iminus + 1
         ici = -1
   20    if (ic.eq.ici) go to 30
         ic = ici
         idruns = idruns + 1
   30 continue
      sts(28) = iplus
      sts(29) = iminus
      sts(31) = 1.0e0 + (2.0e0*sts(28)*sts(29)/sts(1))
     sts(32) = sqrt((2.0e0*sts(28)*sts(29)*&
    &                 (2.0e0*sts(28)*sts(29) -&
    &                  sts(28)-sts(29)))/&
     &            ((sts(28)+sts(29))**2*(sts(1)-1.0e0)))
      sts(30) = idruns
      sts(33) = 0.0e0
     if (sts(32).ne.0.0e0)&
     &   sts(33) = (sts(30)-sts(31))/sts(32)
      sts(13) = sumd2/(sts(1)-1.0e0)
      sts(9) = sqrt(sts(13))
      sts(10) = sts(9)/sqrt(sts(1))
     if (sts(4).ne.0.0e0)&
     &   sts(14) = 100.0e0*abs(sts(9)/sts(4))
      if (sts(4).eq.0.0e0) sts(14) = 0.0e0
      sts(36) = 0.0e0
     if (sumd2.gt.0.0e0)&
     &   sts(36) = (sumd3/sts(1))**2/((sumd2/sts(1))**3)
      sts(37) = 0.0e0
     if (sumd2.gt.0.0e0)&
     &   sts(37) = (sumd4/sts(1))/((sumd2/sts(1))**2)
      sts(40) = sumd2
      sts(19) = (12.0e0*sumdi)/(sts(1)*(sts(1)**2-1.0e0))
     sts(20) = (1.0e0/(sts(1)-2.0e0)*&
    &             (12.0e0*(sumd2/(sts(1)*(sts(1)**2-1.0e0)))-&
     &              sts(19)**2))
      if (sts(20).le.0.0e0) sts(20) = 0.0e0
      sts(20) = sqrt(sts(20))
      if (sts(20).eq.0.0e0) sts(21) = 0.0e0
      if (sts(20).gt.0.0e0) sts(21) = sts(19)/sts(20)
!
      sts(22) = 1.0e0 - cdff(sts(21)*sts(21), 1.0e0, sts(1)-2.0e0)
!
!     COMPUTE NUMBER OF RUNS IN THE DATA.
!
      dif = 0.0e0
      irun = 1
      ta = 0.0e0
      do 40 i=1,n
         if (i.ge.n) go to 50
         ta = y(i+1) - y(i)
         if (ta.ne.0.0e0) go to 50
   40 continue
   50 do 60 i=1,n
         if (i.eq.n) go to 60
         t = y(i+1) - y(i)
         dif = dif + t*t
         if (ta*t.ge.0.0e0) go to 60
         ta = t
         irun = irun + 1
   60 continue
      sts(23) = irun
      sts(26) = dif/(sts(1)-1.0e0)
      sts(27) = 0.0e0
     if (sts(13).ne.0.0e0)&
     &   sts(27) = sts(26)/sts(13)
      sts(41) = 0.0e0
     if (sts(9).ne.0.0e0)&
     &   sts(41) = (sts(4)*sqrt(sts(1)))/sts(9)
      sts(12) = sumda/sts(1)
      t = ppft(0.975e0, n-1)
      tk1 = ppfchs(0.975e0, n-1)
      tk2 = ppfchs(0.025e0, n-1)
      sts(15) = sts(4) - t*sts(10)
      sts(16) = sts(4) + t*sts(10)
      sts(17) = sqrt((sts(1)-1.0e0)/tk1)*sts(9)
      sts(18) = sqrt((sts(1)-1.0e0)/tk2)*sts(9)
      return
      end
!IPGM
      subroutine ipgm (yfft, n, lyfft, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
!     THE INTEGRATED PERIODOGRAM OF A SERIES (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,lyfft,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   yfft(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
    &   freq,iextnd,iprt,isym,ldsmin,lpcv,nall0,nf,nfft,nprt,&
     &   xaxis,yaxis
     logical&
     &   err01,err02,err03,head
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     character&
     &   llds(8)*1,llyfft(8)*1,ln(8)*1,nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL CNTR,EISGE,IPGDV,IPRINT,LDSCMP,PGMMN,SETESL,STKCLR,STKSET
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     INTEGER FREQ
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
!        INTEGRATED SPECTRUM VALUES ARE STORED.
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IEXTND
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
!        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
!        USED TO EXTEND THE SERIES.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     CHARACTER*1 LLDS(8), LLYFFT(8), LN(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING ALLOCATIONS OF THE STACK AT THE
!        TIME OF THIS CALL.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE EFFECTIVE LENGTH OF THE SERIES TO BE TRANSFORMED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A PAGE PLOT.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE X AXIS VALUES TO BE PLOTTED ARE STORED.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
!     REAL YFFT(LYFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'I',       'P',       'G',       'M',       ' ',       ' '/
     data&
    & llds(1), llds(2), llds(3), llds(4), llds(5),&
     &  llds(6), llds(7), llds(8) /'L','D','S','T','A','K',' ',' '/
     data&
    & llyfft(1), llyfft(2), llyfft(3), llyfft(4), llyfft(5),&
    &  llyfft(6), llyfft(7), llyfft(8)&
     &  /'L','Y','F','F','T',' ',' ',' '/
     data&
    & ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /'N',' ',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 17, 1, head, err01, ln)
      if (err01) go to 5
!
!     SET LENGTH OF EXTENDED SERIES
!
      call setesl(n, 2, nfft)
      nf = nfft/2
!
      call eisge(nmsub, llyfft, lyfft, nfft, 9, head, err02, llyfft)
!
      call ldscmp(3, 0, nf+103, 0, 0, 0, 'S', 2*nfft+206, ldsmin)
!
      call eisge(nmsub, llds, ldstak, ldsmin, 9, head, err03, llds)
!
      if (err01 .or. err02 .or. err03) go to 5
      go to 10
!
    5 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   10 continue
!
!     SET THE SIZE OF THE WORK AREA
!
      call stkset(ldstak, 4)
!
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!
      nall0 = stkst(1)
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      lpcv = nf + 103
      nprt = 1
!
!     CENTER THE SERIES
!
      call cntr(yfft, n, yfft)
      iextnd = 0
!
!     SUBDIVIDE THE STACK.
!
      isym = stkget(lpcv, 2)
      xaxis = stkget(lpcv, 3)
      yaxis = stkget(lpcv, 3)
!
      freq = xaxis
!
!     COMPUTE THE RAW PERIODOGRAM.
!
     call pgmmn (yfft, n, nfft, iextnd, nf, yfft, lyfft, rstak(yaxis),&
     &   rstak(freq), lpcv, 0, nmsub)
!
!     CALL THE MAIN DRIVER FOR COMPUTING (AND PLOTTING) THE INTEGRATED
!     PERIODOGRAM.
!
     call ipgdv (yfft, nf, n, yfft, rstak(freq), rstak(xaxis),&
     &   rstak(yaxis), istak(isym), lpcv, nprt)
!
      call stkclr(nall0)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &  '       CALL IPGM (YFFT, N, LYFFT, LDSTAK)')
      end
!REPCK
subroutine repck(d, nrests, npar, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE MODIFIES D TO CONFORM TO N BY NPAR FORMAT REQUIRED
!     BY NLCMP.  FUTURE REVISIONS TO NLCMP SHOULD BE MADE TO ELIMINATE
!     THE NEED FOR THIS ROUTINE.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer :: n,npar,nrests
!  ARRAY ARGUMENTS
     real(kind=wp) :: d(nrests*npar)
!  LOCAL SCALARS
     integer i,i1,i2,j
!
      i1 = -n
      i2 = -n
      do j = 1, npar
        i1 = i1 + nrests
        i2 = i2 + n
        do i = 1, n
          d(i2+i) = d(i1+i)
        enddo
      enddo

end subroutine repck
!MDFLT
      subroutine mdflt (per, nf, nk, kmd, perf, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR APPLYING MODIFIED
!     DANIEL FILTERS TO A SYMMETRIC SERIES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,nf,nk
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   per(*),perf(*)
     integer&
     &   kmd(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   sym
     integer&
     &   i,iprt,l,ldsmin,nall0,work
     logical&
     &   err01,err02,err03,head
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     character&
     &   lkmd(8)*1,llds(8)*1,lnf(8)*1,lnk(8)*1,nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,EIVEO,FLTMD,IPRINT,LDSCMP,STKCLR,STKSET
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT NUMBER USED FOR OUTPUT.
!     INTEGER KMD(NK)
!        THE ARRAY OF FILTER LENGTHS.
!     CHARACTER*1 LKMD(8), LLDS(8), LNK(8), LNF(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     INTEGER NF
!        THE NUMBER OF POINTS IN THE SERIES TO BE FILTERED.
!     INTEGER NK
!        THE NUMBER OF FILTERS TO BE APPLIED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     REAL PER(NF)
!        THE INPUT SERIES TO BE FILTERED.
!     REAL PERF(NF)
!        THE FILTERED SERIES.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL SYM
!        AN INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE SERIES
!        IS SYMMETRIC (SYM = 1.0E0) OR NOT (SYM = -1.0E0).
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR THE WORK VECTOR.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'M',       'D',       'F',       'L',       'T',       ' '/
     data&
    & lkmd(1), lkmd(2), lkmd(3), lkmd(4), lkmd(5),&
     &  lkmd(6), lkmd(7), lkmd(8) /'K','M','D',' ',' ',' ',' ',' '/
     data&
    & llds(1), llds(2), llds(3), llds(4), llds(5),&
     &  llds(6), llds(7), llds(8) /'L','D','S','T','A','K',' ',' '/
     data&
    & lnf(1), lnf(2), lnf(3), lnf(4), lnf(5),&
     &  lnf(6), lnf(7), lnf(8) /'N','F',' ',' ',' ',' ',' ',' '/
     data&
    & lnk(1), lnk(2), lnk(3), lnk(4), lnk(5),&
     &  lnk(6), lnk(7), lnk(8) /'N','K',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, lnf, nf, 17, 1, head, err01, lnf)
!
      call eisge(nmsub, lnk, nk, 1, 1, head, err02, lnk)
!
      if (.not.err02) call eiveo(nmsub, lkmd, kmd, nk, .true., head)
!
      if (err01) go to 10
!
      call ldscmp(1, 0, 0, 0, 0, 0, 'S', nf, ldsmin)
!
      call eisge(nmsub, llds, ldstak, ldsmin, 9, head, err03, llds)
!
      if ((.not.err02) .and. (.not.err03)) go to 20
!
   10 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   20 continue
!
!     SET THE SIZE OF THE WORK AREA
!
      call stkset(ldstak, 4)
      nall0 = stkst(1)
!
!     SUBDIVIDE THE WORK AREA
!
      work = stkget(nf, 3)
!
!     DESIGNATE THE SERIES IS SYMMETRIC
!
      sym = 1.0e0
!
      do 30 i = 1, nf
         perf(i) = per(i)
   30 continue
!
      do 40 l = 1, nk
         call fltmd(perf, rstak(work), nf, kmd(l), sym)
   40 continue
!
      call stkclr(nall0)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &  '       CALL MDFLT (PER, NF, NK, KMD, PERF, LDSTAK)')
      end
!LLSP
      subroutine llsp(y, xm, n, ndeg, res, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CALL FOR POLYNOMIAL MODEL LEAST SQUARES FIT
!     NO WEIGHTS SPECIFIED
!     NO STORAGE OTHER THAN RESIDUALS
!     FOUR PAGES AUTOMATIC PRINTOUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,n,ndeg
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   res(*),xm(*),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   iprt,ivcv,lpar,lpv,lsdpv,lsdres,lwt,npar,nprt
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   par(1),pv(1),sdpv(1),sdres(1),vcv(1,1),wt(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LLCNTP
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDEG
!        THE DEGREE OF THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     REAL PAR(1)
!        A DUMMY ARRAY FOR
!        THE PARAMETERS  TO BE ESTIMATED.
!     REAL PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUES.
!     REAL RES(N)
!        THE RESIDUALS.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     REAL SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARDIZED RESIDUALS.
!     REAL VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(1)
!        A DUMMY ARRAY FOR
!        THE WEIGHTS.
!     REAL XM(N,1)
!        THE INDEPENDENT VARIABLE.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'L','L','S','P',' ',' '/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      weight = .false.
      save = .false.
      nprt = 1111
      lpar = 1
      lpv = 1
      lsdpv = 1
      lsdres = 1
      ivcv = 1
      lwt = 1
!
     call llcntp(y, wt, lwt, xm, n, ndeg, npar, res, ldstak, nprt,&
    &   par, lpar, rsd, pv, lpv, sdpv, lsdpv, sdres, lsdres, vcv, ivcv,&
     &   nmsub, weight, save)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (//42h the correct form of the call statement is//&
     &   45h       call llsp (y, x, n, ndeg, res, lsdtak))
      end
!XXCH8
      subroutine xxch8(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     TEST SUBPROGRAM FOR SIMPLE TEST OF
!     THE LINEAR LEAST SQUARES FAMILY OF ROUTINES.
!
!     LLS PROBLEM IS FROM DANIAL AND WOOD [1971], PAGES 61-65.
!
!     LLSP PROBLEM IS FROM MILLER AND FREUND [1977], PAGE 311.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,ixm,n1,n2,ndeg,npar
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   res(25),x(25),xm(25,5),y1(25),y2(25)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LLS,LLSP
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX X.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER NDEG
!        THE DEGREE OF THE POLYNOMIAL MODEL TO BE FIT.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER N1, N2
!        THE NUMBER OF OBSERVATIONS IN EACH PROBLEM.
!     REAL RES(25)
!        THE RESIDUALS.
!     REAL X(25)
!        THE INDEPENDENT VARIABLE.
!     REAL XM(25,5)
!        THE INDEPENDENT VARIABLE.
!     REAL Y1(25), Y2(25)
!        THE DEPENDENT VARIABLE.
!
!
     data      xm(1,1),  xm(1,2),  xm(1,3),  xm(1,4)&
     &    /      1.0e0, 80.0e0, 27.0e0, 89.0e0/
     data      xm(2,1),  xm(2,2),  xm(2,3),  xm(2,4)&
     &    /      1.0e0, 80.0e0, 27.0e0, 88.0e0/
     data      xm(3,1),  xm(3,2),  xm(3,3),  xm(3,4)&
     &    /      1.0e0, 75.0e0, 25.0e0, 90.0e0/
     data      xm(4,1),  xm(4,2),  xm(4,3),  xm(4,4)&
     &    /      1.0e0, 62.0e0, 24.0e0, 87.0e0/
     data      xm(5,1),  xm(5,2),  xm(5,3),  xm(5,4)&
     &    /      1.0e0, 62.0e0, 22.0e0, 87.0e0/
     data      xm(6,1),  xm(6,2),  xm(6,3),  xm(6,4)&
     &    /      1.0e0, 62.0e0, 23.0e0, 87.0e0/
     data      xm(7,1),  xm(7,2),  xm(7,3),  xm(7,4)&
     &    /      1.0e0, 62.0e0, 24.0e0, 93.0e0/
     data      xm(8,1),  xm(8,2),  xm(8,3),  xm(8,4)&
     &    /      1.0e0, 62.0e0, 24.0e0, 93.0e0/
     data      xm(9,1),  xm(9,2),  xm(9,3),  xm(9,4)&
     &    /      1.0e0, 58.0e0, 23.0e0, 87.0e0/
     data     xm(10,1), xm(10,2), xm(10,3), xm(10,4)&
     &    /      1.0e0, 58.0e0, 18.0e0, 80.0e0/
     data     xm(11,1), xm(11,2), xm(11,3), xm(11,4)&
     &    /      1.0e0, 58.0e0, 18.0e0, 89.0e0/
     data     xm(12,1), xm(12,2), xm(12,3), xm(12,4)&
     &    /      1.0e0, 58.0e0, 17.0e0, 88.0e0/
     data     xm(13,1), xm(13,2), xm(13,3), xm(13,4)&
     &    /      1.0e0, 58.0e0, 18.0e0, 82.0e0/
     data     xm(14,1), xm(14,2), xm(14,3), xm(14,4)&
     &    /      1.0e0, 58.0e0, 19.0e0, 93.0e0/
     data     xm(15,1), xm(15,2), xm(15,3), xm(15,4)&
     &    /      1.0e0, 50.0e0, 18.0e0, 89.0e0/
     data     xm(16,1), xm(16,2), xm(16,3), xm(16,4)&
     &    /      1.0e0, 50.0e0, 18.0e0, 86.0e0/
     data     xm(17,1), xm(17,2), xm(17,3), xm(17,4)&
     &    /      1.0e0, 50.0e0, 19.0e0, 72.0e0/
     data     xm(18,1), xm(18,2), xm(18,3), xm(18,4)&
     &    /      1.0e0, 50.0e0, 19.0e0, 79.0e0/
     data     xm(19,1), xm(19,2), xm(19,3), xm(19,4)&
     &    /      1.0e0, 50.0e0, 20.0e0, 80.0e0/
     data     xm(20,1), xm(20,2), xm(20,3), xm(20,4)&
     &    /      1.0e0, 56.0e0, 20.0e0, 82.0e0/
     data     xm(21,1), xm(21,2), xm(21,3), xm(21,4)&
     &    /      1.0e0, 70.0e0, 20.0e0, 91.0e0/
!
     data        y1(1),    y1(2),    y1(3)&
     &    /     42.0e0, 37.0e0, 37.0e0/
     data        y1(4),    y1(5),    y1(6)&
     &    /     28.0e0, 18.0e0, 18.0e0/
     data        y1(7),    y1(8),    y1(9)&
     &    /     19.0e0, 20.0e0, 15.0e0/
     data       y1(10),   y1(11),   y1(12)&
     &    /     14.0e0, 14.0e0, 13.0e0/
     data       y1(13),   y1(14),   y1(15)&
     &    /     11.0e0, 12.0e0,  8.0e0/
     data       y1(16),   y1(17),   y1(18)&
     &    /      7.0e0,  8.0e0,  8.0e0/
     data       y1(19),   y1(20),   y1(21)&
     &    /      9.0e0, 15.0e0, 15.0e0/
!
     data         x(1),     x(2),     x(3)&
     &    /      0.0e0,  1.0e0,  2.0e0/
     data         x(4),     x(5),     x(6)&
     &    /      3.0e0,  4.0e0,  5.0e0/
     data         x(7),     x(8),     x(9)&
     &    /      6.0e0,  7.0e0,  8.0e0/
!
     data        y2(1),    y2(2),    y2(3)&
     &    /     12.0e0, 10.5e0, 10.0e0/
     data        y2(4),    y2(5),    y2(6)&
     &    /      8.0e0,  7.0e0,  8.0e0/
     data        y2(7),    y2(8),    y2(9)&
     &    /      7.5e0,  8.5e0,  9.0e0/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      call iprint(iprt)
      ixm = 25
      n1 = 21
      n2 = 9
      npar = 4
      ndeg = 2
!
!     PRINT HEADER
!
      write (iprt,1000)
!
!     RUN SIMPLE EXAMPLE OF LLS
!
      write (iprt,1100)
      call lls(y1, xm, n1, ixm, npar, res, ldstak)
      write (iprt,2000) ierr
!
!     RUN SIMPLE EXAMPLE OF LLSP
!
      write (iprt,1200)
      call llsp(y2, x, n2, ndeg, res, ldstak)
      write (iprt,2000) ierr
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format ('1*CH8')
 1100 format (' SIMPLE TEST OF LLS')
 1200 format ('1SIMPLE TEST OF LLSP')
 2000 format (/' THE VALUE OF IERR IS ', i4)
!
      end
!SUMID
      subroutine sumid(x, n, xmean, sumdi)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO CALCULATE THE SUM OF THE PRODUCTS OF I AND THE I TH
!     DIFFERENCE AMONG THE ELEMENTS OF THE VECTOR X - XMEAN.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   sumdi,xmean
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   diff
     integer&
     &   i
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DIFF
!        THE DIFFERENCE OF A VALUE OF X AND THE WEIGHTED MEAN OF X.
!     INTEGER I
!        A LOOP INDEX.
!     INTEGER N
!        INPUT PARAMETER.  THE NUMBER OF ELEMENTS IN X.
!     REAL SUMDI
!        OUTPUT PARAMETER.  THE SUM OF THE PRODUCTS OF I AND THE
!        ELEMENTS OF THE VECTOR X - XMEAN.
!     REAL X(N)
!        INPUT PARAMETER.  THE VECTOR OF N DATA VALUES.
!     REAL XMEAN
!        INPUT PARAMETER.  THE MEAN OF X.
!
      sumdi = 0.0e0
      do 10 i=1,n
         diff = x(i) - xmean
         sumdi = sumdi + i*diff
   10 continue
      return
      end
!UFSEST
     subroutine ufsest(acov, w, lag, spcf, ispcf, lacov, lw, nf, freq,&
     &   delta)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE SPECTRUM, SPCF, AND
!     THEIR LOWER AND UPPER CONFIDENCE LIMITS, SPCLCL AND SPCUCL,
!     RESPECTIVELY.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta
     integer&
     &   ispcf,lacov,lag,lw,nf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(lacov),freq(nf),spcf(ispcf),w(lw)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   c,pi,v0,v1,v2
     integer&
     &   i,k,kk
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL GETPI
!
!  INTRINSIC FUNCTIONS
      intrinsic cos
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV)
!        THE AUTOCOVARIANCES OF THE SERIES.
!     REAL C
!        A VALUE USED TO COMPUTE THE SPECTRUM VALUES.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER K, KK
!        INDEXING VARIABLES.
!     INTEGER LACOV
!        THE LENGTH OF VECTOR ACOV.
!     INTEGER LAG
!        THE LAG WINDOW TRUCCATION POINT.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     REAL PI
!        THE VALUE OF PI.
!     REAL SPCF(ISPCF)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     REAL V0, V1, V2
!        CONSTANTS USED FOR COMPUTING THE SPECTRUM VALUES.
!     REAL W(LW)
!        THE VECTOR OF LAG WINDOWS.
!
      call getpi(pi)
!
!        COMPUTE THE SPECTRUM AND ITS CONFIDENCE LIMITS.
!
      do 20 i=1,nf
         c = cos(2.0e0*pi*freq(i))
         v0 = 0.0e0
         v1 = 0.0e0
         do 10 k=1,lag
            kk = lag + 1 - k
            v2 = 2.0e0*c*v1 - v0 + w(kk+1)*acov(kk+1)
            v0 = v1
            v1 = v2
   10    continue
         spcf(i) = delta*(acov(1)*w(1)+2.0e0*(v1*c-v0))
         if (spcf(i).lt.0.0e0) spcf(i) = 0.0e0
   20 continue
      return
      end
!ERSLFS
      subroutine erslfs(nmsub, fc, k, head, error)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PERFORMS ERROR CHECKING FOR THE INPUT
!     VALUES USED TO SPECIFY SYMMETRIC LINEAR FILTERING OF A
!     TIME SERIES
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fc
     integer&
     &   k
     logical&
     &   error,head
!
!  ARRAY ARGUMENTS
     character&
     &   nmsub(6)*1
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   temp
     integer&
     &   iprt
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     REAL FC
!        THE USER SUPPLIED CUTOFF FREQUENCY.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER K
!        THE NUMBER OF TERMS IN THE FILTER.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THE CALLING SUBROUTINE.
!     REAL TEMP
!        A TEMPORARY VARIABLE USED FOR TYPE CONVERSION.
!
      error = .false.
      temp = k
!
      if (fc - 1.0e0/temp .ge. 0.0e0) go to 10
!
      call iprint(iprt)
      call ehdr(nmsub, head)
      write (iprt, 1010) fc, k
      error = .true.
      return
!
   10 continue
!
      if (fc + 1.0e0/k .lt. 0.5e0) return
!
      call iprint(iprt)
      call ehdr(nmsub, head)
      write (iprt, 1020) fc, k
      error = .true.
      return
!
!     FORMAT STATEMENTS
!
1010 format (/36h the cutoff frequency, fc, minus one,&
    &   41h over the number of filter terms, k, that/&
    &   53h is, fc - 1/k, must be greater than or equal to zero.,&
    &   29h the input values of fc and k/&
     &   4h are, f8.5, 4h and, i5, 15h, respectively.)
1020 format (/35h the cutoff frequency, fc, plus one,&
    &   45h over the number of filter terms, k, that is,/&
    &   49h fc + 1/k, must be greater than or equal to zero.,&
    &   29h the input values of fc and k/&
     &   4h are, f7.5, 4h and, i5, 15h, respectively.)
!
      end
!UAS
      subroutine uas (y, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
!     SPECTRUM ESTIMATION (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta,fmax,fmin,var,ymean
     integer&
    &   iar,iprt,lacov,lag,lagmax,laic,ldsmin,ldstak,lpcv,lphi,&
     &   lspc,lwork,nf,nprt
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   acov(101),aic(101),freq(101),ftest(2,100),phi(100),spca(101),&
     &   spcf(101),work(101),xaxis(207),yaxis(207)
     integer&
     &   isort(101),isym(207)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACVF,IPRINT,PARZEN,SETLAG,UASDV,UASER
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(101)
!        THE AUTOCOVARIANCE COMPUTED FROM THE LAG PRODUCT PAIRS.
!     REAL AIC(101)
!        THE ARRAY CONTAINING AKIAKES CRITERIA FOR EACH ORDER.
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
!        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
!     REAL FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     REAL FTEST(2, 100)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISYM(207)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE COVARIANCE ARRAYS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE ARRAY AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER LSPC
!         THE LENGTH OF THE SPECTRUM ARRAYS.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
!        ARE TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE TYPE OF WINDOW TO BE USED.
!     REAL PHI(100)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     REAL SPCA(101)
!        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!     REAL SPCF(101)
!        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
!     REAL VAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED MODEL.
!     REAL WORK(101)
!        A REAL WORK AREA USED FOR THE LAG WINDOWS AND FOR
!        COMPUTING THE AUTOREGRESSIVE COEFFICIENTS.
!     REAL XAXIS(207)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL Y(N)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     REAL YAXIS(207)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'U',       'A',       'S',       ' ',       ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      option(1) = .false.
      option(2) = .false.
      option(3) = .false.
      option(4) = .false.
!
      lag = 0
      iar = 0
      nf = 101
      fmin = 0.0e0
      fmax = 0.5e0
      nprt = -1
      ldstak = 0
      ldsmin = 0
!
!     SET THE MAXIMUM NUMBER OF LAGS TO BE USED.
!
      call setlag(n, lagmax)
!
!     CALL ERROR CHECKING ROUTINE
!
     call uaser(nmsub, n, acov, iar, phi, lagmax, lag, lacov,&
     &   nf, ldstak, ldsmin, n, n, option)
!
      if (ierr.ne.0) then
         ierr = 1
         call iprint (iprt)
         write (iprt, 1000)
         return
      end if
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      lpcv = 207
      lspc = 101
      lphi = 100
      laic = 101
      lacov = 101
      lwork = 101
!
      alpha = .95e0
      delta = 1.0e0
!
!     COMPUTE AUTOCOVARIANCES
!
      call acvf (y, n, ymean, acov, lagmax, lacov)
!
!     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
!
     call uasdv(acov, spca, spcf, lspc, iar, phi, nf, fmin, fmax, freq,&
    &   n, lagmax, ftest, aic, work, lacov, lwork, delta, isort,&
    &   isym, xaxis, yaxis, lpcv, alpha, lag, laic, lphi, nprt, var,&
     &   parzen, nmsub)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   22h       call uas (y, n))
      end
!UASOUT
     subroutine uasout (xaxis, yaxis, isym, npts, bw, idf, lag,&
    &   iar, phi, ispcer, lpcv, xpltmn, xpltmx, ypltmn, ypltmx,&
     &   ftest, aic, laic, var, nprt, lagmax, aicprt, n, nmsub)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES THE SPECTRUM PLOTS FOR THE
!     AUTOREGRESSIVE SPECTRUM ESTIMATES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   bw,var,xpltmn,xpltmx,ypltmn,ypltmx
     integer&
     &   iar,idf,ispcer,lag,lagmax,laic,lpcv,n,nprt,npts
     logical&
     &   aicprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   aic(laic),ftest(2,lagmax),phi(lagmax),xaxis(lpcv),yaxis(lpcv)
     integer&
     &   isym(lpcv)
     character&
     &   nmsub(6)*1
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xmn,xmx,ymn,ymx
     integer&
     &   ilog,iprt
     logical&
     &   error
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   prho(1)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AOSLST,IPRINT,PPLMT,PPMN,VERSP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AIC(LAIC)
!        THE ARRAY CONTAINING AKIAKES CRITERIA FOR EACH ORDER.
!     LOGICAL AICPRT
!        AN INDICATOR VARIABLE USED TO DETERMINE IF THE AKIAKE
!        INFORMATION CRITERIA AND CHI SQUARED STATISTICS SHOULD
!        BE PRINTED.
!     REAL BW
!        THE BANDWIDTH.
!     LOGICAL ERROR
!        AN ERROR FLAG
!     REAL FTEST(2,LAGMAX)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IDF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     INTEGER IPRT
!        THE LOGICAL UNIT NUMBER FOR THE OUTPUT.
!     INTEGER ISPCER
!        A VARIABLE USED TO DESIGNATE AN ERROR IN THE SPECTRAL
!        ESTIMATES.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR THE FOURIER SPECTRUM.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE ARRAY AIC.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     REAL PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     REAL PRHO(1)
!        A DUMMY VARIABLE.
!     REAL VAR
!        THE ONE STEP PREDICTION VARIANCE FOR ORDER IAR.
!     REAL XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRAL PLOT.
!     REAL XMN, XMX
!     REAL XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     REAL YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRAL PLOT.
!     REAL YMN, YMX
!        *
!     REAL YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
!     SET LOGICAL UNIT NUMBER FOR OUTPUT AND SET OUTPUT WIDTH.
!
      call iprint (iprt)
!
      if (.not. aicprt) go to 5
!
!     PRINT AUTOREGRESSIVE MODEL ORDER SELECTION STATISTICS
!
      call versp(.true.)
      write(iprt, 1007)
     call aoslst (prho, aic, ftest, lagmax, laic, iar, phi, var,&
     &   .false., n)
      write (iprt, 1001)
!
    5 continue
      call versp(.true.)
!
      write(iprt, 1002) lag, bw, idf
      write(iprt, 1000) iar
      if (ispcer .eq. 0) go to 10
      write(iprt, 1006)
      return
!
   10 continue
      if (nprt.le.0) then
        ilog = 0
      else
        ilog = 1
      end if
!
     call pplmt(yaxis,yaxis,xaxis,xaxis(1),npts,1,lpcv,ypltmn,&
    &  ypltmx, ymn, ymx, xpltmn, xpltmx, xmn, xmx, error, nmsub,&
     &  .false.)
     if (.not.error)&
    &   call ppmn (yaxis,yaxis,xaxis,xaxis(1),npts,1,lpcv,1,isym,&
     &    lpcv, 0, -1, ymn, ymx, xmn, xmx, .false., ilog)
      if (xpltmn .ne. 0.0e0 .or. xpltmx .ne. 0.5e0) return
      write (iprt, 1004)
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (11h and order , i2, 28h autoregressive spectrum (.))
 1001 format ('1')
1002 format (44h fourier spectrum (+) (lag wind. trunc. pt.=, i5,&
     &   1x, 5h/ bw=, f6.4, 1x, 6h/ edf=, i6, ')')
1004 format(5h+freq/&
    &   7h period, 9x, 3hinf, 7x, 3h20., 7x, 3h10., 8x, 6h6.6667, 4x,&
    &   2h5., 8x, 2h4., 8x, 6h3.3333, 4x, 6h2.8571, 4x, 3h2.5, 7x,&
     &   6h2.2222, 4x, 2h2.)
!1005 FORMAT(5H+FREQ/
!    1   7H PERIOD, 9X, 3HINF, 7X, 3H10., 4X, 2H5., 8X, 6H3.3333, 4X,
!    2   3H2.5, 4X, 2H2.)
1006 format(//&
    &   56h ** the plot has been supressed because fewer than    **/&
    &   56h ** four valid (positive) spectral estimates could be **/&
     &   56h ** computed.                                         **)
 1007 format (/42h autoregressive order selection statistics/)
      end
!MGS
      subroutine mgs(a, b, n, np, x, c, d, r, ir, ia, ier)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE SOLUTION  X  TO THE LINEAR SYSTEM OF
!     EQUATIONS  AX=B, USING THE METHOD OF MODIFIED GRAM-SCHMIDT.
!     THE MATRIX A IS DECOMPOSED INTO THREE MATRICES
!        Q  AN ORTHOGONAL MATRIX
!        D  A DIAGONAL MATRIX AND
!        R  AN UPPER TRIANGULAR MATRIX
!     THE SOLUTION VECTOR X IS THE VECTOR WHICH SOLVES THE SYSTEM
!     OF EQUATIONS  RX = C
!     X, A, AND B ARE NOT PRESERVED ON OUTPUT
!
!     ADAPTED FROM OMNITAB II BY -
!                  JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ia,ier,ir,n,np
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   a(ia,np),b(n),c(np),d(np),r(ir,np),x(np)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   sm1,sm2
     integer&
     &   i,j,jj,k,npjjmj
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL A(IA,NP)
!           THE COEFFICIENTS MATRIX (NOT PRESERVED ON OUTPUT)
!     REAL B(N)
!           THE CONSTANT COLUMN MATRIX OF THE SYSTEM (NOT PRESERVED
!           ON OUTPUT)
!     REAL C(NP)
!           THE MATRIX C DESCRIBED ABOVE
!     REAL D(NP)
!           THE DIAGONAL ELEMENTS OF THE MATRIX D DESCRIBED ABOVE
!     INTEGER I
!           *
!     INTEGER IA
!           THE ROW DIMENSION OF A.
!     INTEGER IER
!           *
!     INTEGER IR
!           THE ROW DIMENSION OF R.
!     INTEGER J
!           *
!     INTEGER JJ
!           *
!     INTEGER K
!           *
!     INTEGER N
!           THE NUMBER OF OBSERVATIONS
!     INTEGER NP
!           THE NUMBER OF PARAMETERS
!     INTEGER NPJJMJ
!           *
!     REAL R(IR,NP)
!           THE UPPER ELEMENTS OF THE MATRIX R DESCRIBED ABOVE
!     REAL SM1
!           *
!     REAL SM2
!           *
!     REAL X(NP)
!           THE SOLUTION MATRIX
!
!
      ier = 0
!
      sm1 = 0.0e0
      sm2 = 0.0e0
      do 10 i=1,n
         sm1 = a(i,1)*a(i,1) + sm1
         sm2 = a(i,1)*b(i) + sm2
   10 continue
      if (sm1.eq.0.0e0) go to 100
      d(1) = sm1
      c(1) = sm2/sm1
      if (np.eq.1) go to 70
      do 60 k=2,np
         do 40 j=k,np
            sm1 = 0.0e0
            do 20 i=1,n
               sm1 = a(i,k-1)*a(i,j) + sm1
   20       continue
            r(k-1,j) = sm1/d(k-1)
            do 30 i=1,n
               a(i,j) = a(i,j) - a(i,k-1)*r(k-1,j)
   30       continue
   40    continue
         sm1 = 0.0e0
         sm2 = 0.0e0
         do 50 i=1,n
            b(i) = b(i) - a(i,k-1)*c(k-1)
            sm1 = a(i,k)*a(i,k) + sm1
            sm2 = a(i,k)*b(i) + sm2
   50    continue
         if (sm1.eq.0.0e0) go to 100
         d(k) = sm1
         c(k) = sm2/sm1
   60 continue
!
!     COMPLETE BACKSOLVE
!
   70 x(np) = c(np)
      if (np.eq.1) return
      do 90 i=2,np
         k = np + 1 - i
         jj = k + 1
         sm1 = 0.0e0
         do 80 j=jj,np
            npjjmj = np + jj - j
            sm1 = r(k,npjjmj)*x(npjjmj) + sm1
   80    continue
         x(k) = c(k) - sm1
   90 continue
      return
  100 ier = 1
      return
      end
!UFSDRV
     subroutine ufsdrv(y, ly, ymiss, acov, nlppa, spcf, ispcf, nf,&
    &   fmin, fmax, freq, n, nw, lagmax, lags, work, lacov, lwork,&
    &   delta, isort, isym, xaxis, yaxis, lpcv, alpha, nprt, window,&
     &   nmsub, ldsmin, ldstak, option, lnlppa, nfft)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLING ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS .
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   alpha,delta,fmax,fmin,ymiss
     integer&
    &   ispcf,lacov,lagmax,ldsmin,ldstak,lnlppa,lpcv,lwork,ly,n,&
     &   nf,nfft,nprt,nw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(*),freq(*),spcf(*),work(*),xaxis(*),y(*),yaxis(*)
     integer&
     &   isort(*),isym(*),lags(*),nlppa(*)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  SUBROUTINE ARGUMENTS
       external window
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   alow,aup,bw,df,fmn,fmx,spcfmn,spcfmx,xpltmn,xpltmx,ymean,&
     &   ypltmn,ypltmx
     integer&
     &   i,ilog,ispcer,lag,laglst,nfused,npts,nspc,nwused
     logical&
     &   newpg,univar
!
!  EXTERNAL FUNCTIONS
     integer&
     &   lstlag
!       EXTERNAL LSTLAG
!
!  EXTERNAL SUBROUTINES
       external acvf,acvff,acvfm,setfrq,spcck,ufser,ufslag,ufsmn,ufsout,&
     &   ufspcv
!
!  INTRINSIC FUNCTIONS
      intrinsic max,min,nint
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV)
!        THE AUTOCOVARIANCE.
!     REAL ALOW
!        A FACTOR USED TO COMPUTE THE LOWER CONFIDENCE LIMITS.
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL AUP
!        A FACTOR USED TO COMPUTE THE UPPER CONFIDENCE LIMITS.
!     REAL BW
!        THE BANDWIDTH.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL DF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FMN, FMX
!        THE MAXIMUM AND MINIMUM FREQUENCES ACTUALLY USED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER ILOG
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        ILOG = 0 THE PLOT IS LINEAR/LINEAR, IF
!        ILOG = 1 THE PLOT IS LOG/LINEAR, IF
!        ILOG = 2 THE PLOT IS LINEAR/LOG, AND IF
!        ILOG = 3 THE PLOT IS LOG/LOG.
!     INTEGER ISORT(NF)
!        THE VECTOR USED FOR SORTING.
!     INTEGER ISPCER
!        AN ERROR FLAG USED FOR THE SPECTRUM PLOTS.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAG
!        THE LAG WINDWO TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGLST
!        THE LAST LAG BEFORE MISSING DATA CAUSED AN ACVF
!        TO BE UNABLE TO BE COMPUTED.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     LOGICAL NEWPG
!        THE LOGICAL VARIABLE USED TO DETERMINE IF OUTPUT
!        WILL BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NFUSED
!        THE NUMBER OF FREQUENCIES ACTUALLY USED.
!     INTEGER NLPPA(LNLPPA)
!        THE ARRAY CONTAINING THE NUMBER OF LAG PRODUCT PAIRS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     INTEGER NSPC
!        THE NUMBER OF VALID (POSITIVE) SPECTRUM VALUES.
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     INTEGER NWUSED
!        THE NUMBER OF DIFFERENT BANDWIDTHS ACTUALLY USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     REAL SPCF(ISPCF,NW)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     REAL SPCFMN, SPCFMX
!        THE MINIMUM AND MAXIMUM SPECTRUM VALUE TO BE PLOTTED.
!     LOGICAL UNIVAR
!        THE LOGICAL VARIABLE USED TO DETERMINE IF THE OUTPUT
!        IS FOR UNIVARIATE (TRUE) OR BIVARIATE (FALSE) SPECTRA.
!     EXTERNAL WINDOW
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL WORK(LWORK)
!        THE VECTOR OF LAG WINDOWS.
!     REAL XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     REAL Y(LY)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     REAL YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     REAL YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!     REAL YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
      nfused = nf
      if (option(4)) then
        fmn = max(fmin, 0.0e0)
        fmx = min(fmax, 0.5e0)
        if (fmn.ge.fmx) then
          fmn = 0.0e0
          fmx = 0.5e0
        end if
      else
!
!       SET VARIOUS VALUES FOR SHORT FORMS OF CALL STATEMENT
!
        nprt = -1
        fmn = 0.0e0
        fmx = 0.5e0
      end if
!
!     CHECK FOR ERRORS
!
     call ufser(nmsub, n, lagmax, lacov, nfused, ispcf, nw, lags,&
     &  ldstak, ldsmin, ly, nfft, option)
!
      if (ierr.eq.1) return
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      alpha = 0.95e0
      delta = 1.0e0
!
!     COMPUTE COVARIANCES
!
      laglst = lagmax
      if (option(1)) then
       call acvff(y, n, nfft, ymean, acov, lagmax, lacov,&
     &   ly, work, nfft)
      else
        if (.not.option(3)) then
          if (option(2)) then
           call acvfm(y, ymiss, n, ymean, acov, lagmax, laglst,&
     &        nlppa, lacov)
          else
            call acvf(y, n, ymean, acov, lagmax, lacov)
          end if
        end if
      end if
      if (option(2) .and. option(3)) laglst = lstlag(nlppa,lagmax,lacov)
!
      if (laglst.ge.1) go to 20
!
!     AN ERROR HAS BEEN DETECTED
!
      ierr = 2
      return
!
   20 continue
!
!     COMPUTE THE VECTOR OF LAG WINDOW TRUNCATION POINTS, ORDERED
!     SMALLEST TO LARGEST.
!
      nwused = nw
     if (.not.option(4)) call ufslag(acov, laglst, lags, n, nw,&
     &   nwused, lacov)
!
!     BEGIN COMPUTING FOURIER SPECTRUM FOR SERIES
!
      univar = .true.
!
      if (nprt.ge.1) then
        ilog = 1
      else
        ilog = 0
      end if
!
      xpltmn = fmn
      xpltmx = fmx
!
!     SET FREQUENCIES FOR THE SPECTRUM.
!
      call setfrq(freq, nfused, 2, fmn, fmx, delta)
!
!     COMPUTE AND PLOT SPECTRUM VALUES.
!
      newpg = .false.
!
      do 50 i=1,nwused
         lag = lags(i)
         ispcer = 0
         if (lag.le.laglst) go to 30
         ispcer = 2
         df = 0.0e0
         go to 40
!
  30    call ufsmn(acov, nlppa, lag, df, nfused, freq, alpha, bw,&
    &              spcf(1+(i-1)*ispcf), alow, aup, lacov, ispcf,&
     &              window, work, lag, n, delta, option(2), lnlppa)
!
         if (nprt.eq.0) go to 50
!
         ispcer = 0
        call spcck(spcf(1+(i-1)*ispcf), isort, nfused,&
     &              spcfmn, spcfmx, nspc, ispcer)
!
         if (ispcer.ne.0) go to 40
!
        call ufspcv(spcf(1+(i-1)*ispcf), spcfmn, spcfmx,&
    &               freq, nfused, xaxis, yaxis, isym, npts, ispcf,&
    &               nfused+5, nspc, bw, alow, aup,&
     &               xpltmn, xpltmx, ypltmn, ypltmx, nprt)
!
  40    call ufsout(xaxis, yaxis, isym, npts, bw, nint(df), lag,&
    &      laglst, newpg, ispcer, nfused+5, xpltmn, xpltmx, ypltmn,&
     &      ypltmx, ilog, yaxis, xaxis, npts, univar, nmsub)
!
         newpg = .true.
!
   50 continue
!
      return
!
      end
!ACF
      subroutine acf (y, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
!     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
!     (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   chia,chiap,ospvar,ymean,ysd
     integer&
    &   iar,iprt,lacov,lagmax,laic,ldsmin,ldstak,lyfft,nfac,nfft,&
     &   nprt
     logical&
     &   differ,isfft
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   acov(101),aic(101),ftest(2,100),phi(100),prho(100),rho(100),&
     &   sdrho(100),work(100)
     integer&
     &   iod(1),nd(1),ndum(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACFER,ACFMN,ACFOUT,IPRINT,SETLAG
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (acov(2),rho(1))
      equivalence (work(1),sdrho(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(101)
!        THE AUTOCOVARIANCE FUNCTION ESTIMATE VECTOR.
!     REAL AIC(101)
!        THE ARRAY CONTAINING AKIAKES CRITERIA FOR EACH ORDER.
!     REAL CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     LOGICAL DIFFER
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
!     REAL FTEST(2, 100)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IOD(1)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER ND(1)
!        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
!     INTEGER NDUM(1)
!        A DUMMY ARRAY.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING THE PRINTED OUTPUT.
!     REAL OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED ORDER (IAR).
!     REAL PHI(100)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     REAL PRHO(100)
!        THE ARRAY CONTAINING THE PARTIAL ACF ESTIMATES.
!     REAL RHO(100)
!        THE ARRAY CONTAINING THE ACF ESTIMATES.
!     REAL SDRHO(100)
!        THE ARRAY CONTAINING THE STANDARD ERRORS OF THE ACF ESTIMATES.
!     REAL WORK(100)
!        A VECTOR USED IN THE COMPUTATIONS OF THE PARTIAL
!        AUTOCORRELATION COEFFICIENTS.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     REAL YMEAN, YSD
!        THE MEAN AND STANDARD DEVIATION OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5), nmsub(6)&
     & /     'A',       'C',       'F',       ' ',       ' ',      ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      lagmax = 1
      lacov = 101
      laic = 101
      ldsmin = 0
      ldstak = 0
      nprt = 1
      differ = .false.
      nfac = 1
      nd(1) = 0
      iod(1) = 0
      isfft = .false.
      lyfft = n
      nfft = n
!
     call acfer(nmsub, n, lagmax, lacov, ldstak, ldsmin,&
     &  differ, nfac, nd, iod, isfft, lyfft, nfft)
!
      if (ierr.eq.0) then
!
!       SET NUMBER OF ACF TO BE COMPUTED
!
        call setlag (n, lagmax)
!
!       CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
       call acfmn (y, n, lagmax, rho, sdrho, ymean, prho, aic, ftest,&
     &     phi, iar, ospvar, acov, lacov, laic, chia, chiap, work, nprt)
!
        ysd = sqrt(acov(1) * n / (n-1))
!
!       CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
       call acfout (ymean, ysd, n, n, lagmax, rho, sdrho, prho, ndum,&
    &     aic, laic, ftest, iar, phi, ospvar, chia, chiap, lagmax,&
     &     .false., 0.0e0, .false., .false., 0, ndum, ndum, 0)
      end if
!
      if (ierr.ne.0) then
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        ierr = 1
        call iprint (iprt)
        write (iprt, 1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format(/42h the correct form of the call statement is//&
     &   22h       call acf (y, n))
      end
!XDEMOD
      subroutine xdemod(lds,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE TIME SERIES
!     COMPLEX DEMODULATION ROUTINES.
!
!     SERIES Y IS THE WOLF SUNSPOT DATA FROM 1700 TO 1960 AS
!     TABULATED BY WALDMEIER
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lds
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fc,fd
     integer&
     &   i,iprt,itest,k,ldstak,n,ndem,nprt
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ampl(300),phas(300),y(300)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DEMOD,DEMODS,IPRINT
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AMPL(300)
!        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FC
!        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
!     REAL FD
!        THE DEMODULATION FREQUENCY.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER ITEST
!        THE NUMBER OF THE TEST BEING RUN
!     INTEGER K
!        THE NUMBER OF TERMS IN THE SYMETRIC LINEAR FILTER.
!     INTEGER LDS, LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE INPUT SERIES.
!     INTEGER NDEM
!        THE NUMBER OF VALUES IN THE DEMODULATED SERIES, I. E., IT
!        IS THE NUMBER OF VALUES IN THE AMPLITUDE AND PHASE ARRAYS.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT .EQ. 0 THE PLOT IS SUPPRESSED
!        NPRT .NE. 1 THE PLOT IS PROVIDED
!     REAL PHAS(300)
!        THE ARRAY IN WHICH THE PRIMARY PHASE ESTIMATES ARE RETURNED.
!     REAL Y(300)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!
     data   y(  1),  y(  2),  y(  3),  y(  4),  y(  5),  y(  6)&
     &    /     5.0e0, 11.0e0, 16.0e0, 23.0e0, 36.0e0, 58.0e0/
     data   y(  7),  y(  8),  y(  9),  y( 10),  y( 11),  y( 12)&
     &    /    29.0e0, 20.0e0, 10.0e0,  8.0e0,  3.0e0,  0.0e0/
     data   y( 13),  y( 14),  y( 15),  y( 16),  y( 17),  y( 18)&
     &    /     0.0e0, 2.0e0, 11.0e0, 27.0e0, 47.0e0, 63.0e0/
     data   y( 19),  y( 20),  y( 21),  y( 22),  y( 23),  y( 24)&
     &    /    60.0e0, 39.0e0, 28.0e0, 26.0e0, 22.0e0, 11.0e0/
     data   y( 25),  y( 26),  y( 27),  y( 28),  y( 29),  y( 30)&
     &    /    21.0e0, 40.0e0, 78.0e0,122.0e0,103.0e0, 73.0e0/
     data   y( 31),  y( 32),  y( 33),  y( 34),  y( 35),  y( 36)&
     &    /    47.0e0, 35.0e0, 11.0e0,  5.0e0, 16.0e0, 34.0e0/
     data   y( 37),  y( 38),  y( 39),  y( 40),  y( 41),  y( 42)&
     &    /    70.0e0, 81.0e0,111.0e0,101.0e0, 73.0e0, 40.0e0/
     data   y( 43),  y( 44),  y( 45),  y( 46),  y( 47),  y( 48)&
     &    /    20.0e0, 16.0e0,  5.0e0, 11.0e0, 22.0e0, 40.0e0/
     data   y( 49),  y( 50),  y( 51),  y( 52),  y( 53),  y( 54)&
     &    /    60.0e0, 80.9e0, 83.4e0, 47.7e0, 47.8e0, 30.7e0/
     data   y( 55),  y( 56),  y( 57),  y( 58),  y( 59),  y( 60)&
     &    /    12.2e0,  9.6e0, 10.2e0, 32.4e0, 47.6e0, 54.0e0/
     data   y( 61),  y( 62),  y( 63),  y( 64),  y( 65),  y( 66)&
     &    /    62.9e0, 85.9e0, 61.2e0, 45.1e0, 36.4e0, 20.9e0/
     data   y( 67),  y( 68),  y( 69),  y( 70),  y( 71),  y( 72)&
     &    /    11.4e0, 37.8e0, 69.8e0,106.1e0,100.8e0, 81.6e0/
     data   y( 73),  y( 74),  y( 75),  y( 76),  y( 77),  y( 78)&
     &    /    66.5e0, 34.8e0, 30.6e0,  7.0e0, 19.8e0, 92.5e0/
     data   y( 79),  y( 80),  y( 81),  y( 82),  y( 83),  y( 84)&
     &    /   154.4e0,125.9e0, 84.8e0, 68.1e0, 38.5e0, 22.8e0/
     data   y( 85),  y( 86),  y( 87),  y( 88),  y( 89),  y( 90)&
     &    /    10.2e0, 24.1e0, 82.9e0,132.0e0,130.9e0,118.1e0/
     data   y( 91),  y( 92),  y( 93),  y( 94),  y( 95),  y( 96)&
     &    /    89.9e0, 66.6e0, 60.0e0, 46.9e0, 41.0e0, 21.3e0/
     data   y( 97),  y( 98),  y( 99),  y(100),  y(101),  y(102)&
     &    /    16.0e0,  6.4e0,  4.1e0,  6.8e0, 14.5e0, 34.0e0/
     data   y(103),  y(104),  y(105),  y(106),  y(107),  y(108)&
     &    /    45.0e0, 43.1e0, 47.5e0, 42.2e0, 28.1e0, 10.1e0/
     data   y(109),  y(110),  y(111),  y(112),  y(113),  y(114)&
     &    /     8.1e0,  2.5e0,  0.0e0,  1.4e0,  5.0e0, 12.2e0/
     data   y(115),  y(116),  y(117),  y(118),  y(119),  y(120)&
     &    /    13.9e0, 35.4e0, 45.8e0, 41.1e0, 30.1e0, 23.9e0/
     data   y(121),  y(122),  y(123),  y(124),  y(125),  y(126)&
     &    /    15.6e0,  6.6e0,  4.0e0,  1.8e0,  8.5e0, 16.6e0/
     data   y(127),  y(128),  y(129),  y(130),  y(131),  y(132)&
     &    /    36.3e0, 49.6e0, 64.2e0, 67.0e0, 70.9e0, 47.8e0/
     data   y(133),  y(134),  y(135),  y(136),  y(137),  y(138)&
     &    /    27.5e0,  8.5e0, 13.2e0, 56.9e0,121.5e0,138.3e0/
     data   y(139),  y(140),  y(141),  y(142),  y(143),  y(144)&
     &    /   103.2e0, 85.7e0, 64.6e0, 36.7e0, 24.2e0, 10.7e0/
     data   y(145),  y(146),  y(147),  y(148),  y(149),  y(150)&
     &    /    15.0e0, 40.1e0, 61.5e0, 98.5e0,124.7e0, 96.3e0/
     data   y(151),  y(152),  y(153),  y(154),  y(155),  y(156)&
     &    /    66.6e0, 64.5e0, 54.1e0, 39.0e0, 20.6e0,  6.7e0/
     data   y(157),  y(158),  y(159),  y(160),  y(161),  y(162)&
     &    /     4.3e0, 22.7e0, 54.8e0, 93.8e0, 95.8e0, 77.2e0/
     data   y(163),  y(164),  y(165),  y(166),  y(167),  y(168)&
     &    /    59.1e0, 44.0e0, 47.0e0, 30.5e0, 16.3e0,  7.3e0/
     data   y(169),  y(170),  y(171),  y(172),  y(173),  y(174)&
     &    /    37.6e0, 74.0e0,139.0e0,111.2e0,101.6e0, 66.2e0/
     data   y(175),  y(176),  y(177),  y(178),  y(179),  y(180)&
     &    /    44.7e0, 17.0e0, 11.3e0, 12.4e0,  3.4e0,  6.0e0/
     data   y(181),  y(182),  y(183),  y(184),  y(185),  y(186)&
     &    /    32.3e0, 54.3e0, 59.7e0, 63.7e0, 63.5e0, 52.2e0/
     data   y(187),  y(188),  y(189),  y(190),  y(191),  y(192)&
     &    /    25.4e0, 13.1e0,  6.8e0,  6.3e0,  7.1e0, 35.6e0/
     data   y(193),  y(194),  y(195),  y(196),  y(197),  y(198)&
     &    /    73.0e0, 85.1e0, 78.0e0, 64.0e0, 41.8e0, 26.2e0/
     data   y(199),  y(200),  y(201),  y(202),  y(203),  y(204)&
     &    /    26.7e0, 12.1e0,  9.5e0,  2.7e0,  5.0e0, 24.4e0/
     data   y(205),  y(206),  y(207),  y(208),  y(209),  y(210)&
     &    /    42.0e0, 63.5e0, 53.8e0, 62.0e0, 48.5e0, 43.9e0/
     data   y(211),  y(212),  y(213),  y(214),  y(215),  y(216)&
     &    /    18.6e0,  5.7e0,  3.6e0,  1.4e0,  9.6e0, 47.4e0/
     data   y(217),  y(218),  y(219),  y(220),  y(221),  y(222)&
     &    /    57.1e0,103.9e0, 80.6e0, 63.6e0, 37.6e0, 26.1e0/
     data   y(223),  y(224),  y(225),  y(226),  y(227),  y(228)&
     &    /    14.2e0,  5.8e0, 16.7e0, 44.3e0, 63.9e0, 69.0e0/
     data   y(229),  y(230),  y(231),  y(232),  y(233),  y(234)&
     &    /    77.8e0, 64.9e0, 35.7e0, 21.2e0, 11.1e0,  5.7e0/
     data   y(235),  y(236),  y(237),  y(238),  y(239),  y(240)&
     &    /     8.7e0, 36.1e0, 79.7e0,114.4e0,109.6e0, 88.8e0/
     data   y(241),  y(242),  y(243),  y(244),  y(245),  y(246)&
     &    /    67.8e0, 47.5e0, 30.6e0, 16.3e0,  9.6e0, 33.2e0/
     data   y(247),  y(248),  y(249),  y(250),  y(251),  y(252)&
     &    /    92.6e0,151.6e0,136.3e0,134.7e0, 83.9e0, 69.4e0/
     data   y(253),  y(254),  y(255),  y(256),  y(257),  y(258)&
     &    /    31.5e0, 13.9e0,  4.4e0, 38.0e0,141.7e0,190.2e0/
     data   y(259),  y(260),  y(261)&
     &    /   184.8e0,159.0e0,112.3e0/
!
      call iprint(iprt)
      itest = 1
      ldstak = lds
!
      n = 261
      nprt = 1
      fd = 1.0e0/11.0e0
      fc = 1.0e0/22.0e0
      k = 41
!
!     TEST OF DEMOD
!
    5 write (iprt, 1016)
      call demod (y, n, fd, fc, k, ldstak)
      write (iprt, 1002) ierr
!
!     TEST OF DEMODS
!
      write (iprt, 1017)
      call demods (y, n, fd, fc, k, ampl, phas, ndem, nprt, ldstak)
      write (iprt, 1002) ierr
!
!     PRINT STORAGE FROM DEMODS
!
      if (ierr.eq.0) then
        write (iprt, 1004) (ampl(i), i = 1, ndem)
        write (iprt, 1004) (phas(i), i = 1, ndem)
      end if
!
      go to (100, 200, 300), itest
!
!     TEST MINIMUM PROBLEM SPECIFICATIONS
!
  100 itest = itest + 1
      n = 17
      k = 15
      nprt = -1
      go to 5
!
!     TEST ERROR CONDITIONS
!
  200 itest = itest + 1
      n = 0
      fd = 0.5e0
      fc = 0.3e0
      k = 1
      go to 5
!
  300 return
!
!     FORMAT STATEMENTS
!
 1002 format (8h ierr is, i5)
 1004 format (10f10.5)
 1016 format ('1', 13htest of demod)
 1017 format ('1', 14htest of demods)
!
      end
!UFS
      subroutine ufs(y, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
      real(kind=wp) :: alpha,delta,fmax,fmin,ymiss
     integer&
    &   iprt,ispcf,lacov,lagmax,ldsmin,ldstak,lnlppa,lpcv,lwork,&
     &   ly,nf,nprt,nw
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   acov(101),freq(101),spcf(101,4),work(101),xaxis(106),&
     &   yaxis(106)
     integer&
     &   isort(101),isym(106),lags(4),nlppa(1)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PARZEN,SETLAG,UFSDRV
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(101)
!        THE AUTOCOVARIANCE AT LAG ZERO (BIASED VARIANCE).
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISYM(106)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(1)
!        A DUMMY ARRAY WHEN THE SERIES DOES NOT CONTAIN MISSING VALUES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL SPCF(101,4)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     REAL WORK(101)
!        THE VECTOR OF LAG WINDOWS.
!     REAL XAXIS(106)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL Y(N)
!         THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     REAL YAXIS(106)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL YMISS
!        A DUMMY VARIABLE WHEN THE SERIES DO NOT CONTAIN MISSING VALUES
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'U','F','S',' ',' ',' '/
!
!     SET UP
!
      option(4) = .false.
      option(3) = .false.
      option(2) = .false.
      option(1) = .false.
!
      ldstak = 0
      ldsmin = 0
!
      ispcf = 101
      lacov = 101
      lnlppa = 1
      ly = n
      lpcv = 106
      lwork = 101
      nf = 101
      ymiss = 1.0e0
!
!     SET MAXIMUM LAG VALUE TO BE USED.
!     AND NUMBER OF LAG WINDOW TRUNCATION POINTS TO USE.
!
      call setlag(n, lagmax)
      nw = 4
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!     FOR SERIES WITH MISSING DATA.
!
     call ufsdrv(y, ly, ymiss, acov, nlppa, spcf, ispcf, nf, fmin,&
    &   fmax, freq, n, nw, lagmax, lags, work, lacov, lwork, delta,&
    &   isort, isym, xaxis, yaxis, lpcv, alpha, nprt, parzen, nmsub,&
     &   ldsmin, ldstak, option, lnlppa, ly)
!
!     CHECK FOR ERRORS
!
      if (ierr.eq.0) return
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL UFS (Y, N)')
      end
!XNLSD
      subroutine xnlsd(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DEMONSTRATE THE USER CALLABLE ROUTINES IN THE NONLINEAR
!     LEAST SQUARES FAMILY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
    &   idrvck,iprt,ivaprx,ivcv,ixm1,ldsa1,ldsmin,ldsn1a,ldsn1b,&
     &   m1,mit,n1,nnzw,npar1,npare,nprt,ntest
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   par1(10),pv(100),res(100),scale(10),sdpv(100),sdres(100),&
     &   stp(10),vcv(6,6),wt(100),xm1(10,2),y1(10)
     integer&
     &   ifixed(10)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DRV1A,FITXSP,IPRINT,LDSCMP,MDL1,NL2X,NLS,NLSC,NLSD,NLSDC,
!     +   NLSDS,NLSS,NLSW,NLSWC,NLSWD,NLSWDC,NLSWDS,NLSWS,NLSX1,
!     +   NLSX2,SETRV
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV1A
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
!        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(10)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM1
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSA1, LDSN1A, LDSN1B
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK
!        FOR THE ROUTINES WITH ANALYTIC DERIVATIVES AND
!        NUMERICAL DERIVATIVES, RESPECTIVELY.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M1
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL1
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N1
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
!     INTEGER NPAR1
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     REAL PAR1(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL PV(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(100)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     REAL SCALE(10)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     REAL SDPV(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF THE
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(10)
!        THE RCSTEP SIZE ARRAY.
!     REAL VCV(6,6)
!        THE COVARIANCE MATRIX.
!     REAL WT(100)
!        THE USER SUPPLIED WEIGHTS.
!     REAL XM1(10,2)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y1(10)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     DEFINE CONSTANTS
!
     data y1(1), y1(2), y1(3), y1(4), y1(5), y1(6)&
     &   /2.138e0, 3.421e0, 3.597e0, 4.340e0, 4.882e0, 5.660e0/
!
     data xm1(1,1), xm1(2,1), xm1(3,1), xm1(4,1), xm1(5,1), xm1(6,1)&
     &   /1.309e0, 1.471e0, 1.490e0, 1.565e0, 1.611e0, 1.680e0/
!
      call iprint(iprt)
!
     call nlsx2(n1, m1, ixm1, npar1, ifixed, stp, idrvck, mit, stopss,&
     &   stopp, scale, delta, ivaprx, nprt, ivcv)
!
      call setrv(wt, n1, 1.0e0)
!
     call ldscmp(6, 0, 60+2*npar1, 0, 0, 0,&
     &   'S', 94+n1*(3+npar1)+npar1*(3*npar1+35)/2, ldsa1)
     call ldscmp(14, 0, max(2*(n1+npar1),60+2*npar1), 0, 0, 0,&
     &   'S', max(10*n1,94+n1*(3+npar1)+npar1*(3*npar1+37)/2), ldsn1a)
     call ldscmp(14, 0, 60+2*npar1, 0, 0, 0,&
     &   'S', 94+n1*(3+npar1)+npar1*(3*npar1+37)/2, ldsn1b)
!
      ldsmin = max(ldsa1, ldsn1a, ldsn1b)
!
      if (ldsmin.le.ldstak) go to 5
!
      write (iprt, 1140) ldsmin
      return
!
    5 continue
!
      ntest = 0
!
!
!     **TEST ON NORMAL STATEMENT**
!
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1000)
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
      call nls(y1, xm1, n1, m1, ixm1, mdl1, par1, npar1, res, ldsn1a)
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1010)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlsc(y1, xm1, n1, m1, ixm1, mdl1, par1, npar1, res, ldsn1b,&
     &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1020)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlss(y1, xm1, n1, m1, ixm1, mdl1, par1, npar1, res, ldsn1b,&
    &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt,&
     &   npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1030)
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlsw(y1, wt, xm1, n1, m1, ixm1, mdl1, par1, npar1, res,&
     &   ldsn1a)
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1040)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlswc(y1, wt, xm1, n1, m1, ixm1, mdl1, par1, npar1, res,&
    &   ldsn1b, ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx,&
     &   nprt)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1050)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlsws(y1, wt, xm1, n1, m1, ixm1, mdl1, par1, npar1, res,&
    &   ldsn1b, ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx,&
     &   nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1060)
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlsd(y1, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1, res,&
     &   ldsa1)
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1070)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlsdc(y1, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1, res,&
    &   ldsa1, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1080)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlsds(y1, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1, res,&
    &   ldsa1, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1090)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlswd(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
     &   res, ldsa1)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1100)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlswdc(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
    &   res, ldsa1, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1110)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlswds(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
    &   res, ldsa1, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
!
!
!     TEST NL2SOL AND NL2SNO DIRECTLY
!
      write (iprt,1320)
      call nl2x(0.0_wp)
!
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (14h test of nls  )
 1010 format (15h test of nlsc  )
 1020 format (15h test of nlss  )
 1030 format (14h test of nlsw )
 1040 format (15h test of nlswc )
 1050 format (15h test of nlsws )
 1060 format (14h test of nlsd )
 1070 format (15h test of nlsdc )
 1080 format (15h test of nlsds )
 1090 format (14h test of nlswd)
 1100 format (15h test of nlswdc)
 1110 format (15h test of nlswds)
1120 format (/29h ***** returned results *****, 5x, 15h (-1 indicates ,&
     &   39hvalue not changed by called subroutine)//9h ierr is , i3)
 1130 format (15h normal problem)
 1140 format (45h1 *** ldstak must be greater than or equal to , i6)
 1320 format (42h1test of nl2sol and nl2sno called directly)
1330 format (54h1nonlinear least squares estimation subroutine test nu,&
     &   4hmber, i5/)
1340 format (24h input   -  ifixed(1) = , i6, 9x, 11h, stp(1) = ,&
    &   g15.8, 11h,    mit = ,i5, 11h, stopss = , g15.8, 10h, stopp = ,&
    &   g15.8/13x, 11hscale(1) = , g15.8, 11h,  delta = , g15.8,&
     &   11h, ivaprx = , i5, 11h,   nprt = , i5)
1350 format (//24h output  -  ifixed(1) = , i6, 9x, 11h, stp(1) = ,&
    &   g15.8, 11h,    mit = ,i5, 11h, stopss = , g15.8, 10h, stopp = ,&
    &   g15.8/13x, 11hscale(1) = , g15.8, 11h,  delta = , g15.8,&
     &   11h, ivaprx = , i5, 11h,   nprt = , i5//)
1360 format (24h input   -  ifixed(1) = , i6, 9x, 11h, idrvck = ,&
    &   i5, 10x, 11h,    mit = ,i5, 11h, stopss = , g15.8,&
    &   10h, stopp = , g15.8/&
    &   13x, 11hscale(1) = , g15.8, 11h,  delta = , g15.8,&
     &   11h, ivaprx = , i5, 11h,   nprt = , i6)
1370 format (//24h output  -  ifixed(1) = , i6, 9x, 11h, idrvck = ,&
    &   i5, 10x, 11h,    mit = ,i5, 11h, stopss = , g15.8,&
    &   10h, stopp = , g15.8/&
    &   13x, 11hscale(1) = , g15.8, 11h,  delta = , g15.8,&
     &   11h, ivaprx = , i5, 11h,   nprt = , i5//)
      end
!BFSF
      subroutine bfsf(yfft1, yfft2, n, lyfft, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     BIVARIATE SPECTRUM ANALYSIS (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,lyfft,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   yfft1(*),yfft2(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta,fmax,fmin,ymiss1,ymiss2
     integer&
    &   iccov,icspc2,ifp,index1,index2,inlppc,iphas,iprt,jccov,&
    &   jnlppc,lagmax,lagmx1,ldsmin,lpcv,lw,lwork,m,nall0,nf,nfft,&
     &   nprt,nw,work
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   ccov(101,2,2),ceven(101),codd(101),cspc2(101,4),freq(101),&
    &   phas(101,4),rstak(12),spcf1(101),spcf2(101),w(101),&
     &   xaxis(404),yaxis(404)
     integer&
     &   isym(404),lags(4),nlppc(1,1,1)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL BFSDRV,IPRINT,LDSCMP,PARZEN,SETESL,SETLAG,STKSET
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL CCOV(101,2,2)
!        THE COVARIANCES.
!     REAL CEVEN(101)
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     REAL CODD(101)
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     REAL CSPC2(101,4)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISYM(404)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTORS Y1 AND YFFT1 AND YFFT2
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS ON ENTRY
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NLPPC(1,1,1)
!        A DUMMY ARRAY.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL PHAS(101,4)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL SPCF1(101), SPCF2(101)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     REAL W(101)
!        THE WINDOWS.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE WORK VECTOR
!     REAL XAXIS(404)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YAXIS(404)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YMISS1, YMISS2
!        DUMMY VARIABLES.
!     REAL YFFT1(LYFFT)
!        THE FIRST TIME SERIES.
!     REAL YFFT2(LYFFT)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'B','F','S','F',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      option(1) = .true.
      option(2) = .false.
      option(3) = .false.
      option(4) = .false.
!
      iccov = 101
      jccov = 2
      m = 2
      index1 = 1
      index2 = 2
!
      icspc2 = 101
      iphas = 101
!
      ldsmin = 0
!
      nf = 101
      ymiss1 = 1.0e0
      ymiss2 = 1.0e0
      inlppc = 1
      jnlppc = 1
      lw = 101
      lpcv = 404
!
!     SET MAXIMUM LAG VALUE (LAGMAX)
!     SET NUMBER OF LAG WINDOW TRUCCATION POINTS (NW)
!     SET EXTENDED SERIES LENGTH (NFFT)
!
      call setlag(n, lagmax)
      nw = 4
      call setesl(n+lagmax, 4, nfft)
!
!     COMPUTE MINIMUM ALLOWABLE STACK LENGTH (LDSMIN)
!
      call ldscmp(1, 0, 0, 0, 0, 0, 'S', nfft, ldsmin)
!
!     SET SIZE OF WORK AREA
!     SET NUMBER OF OUTSTANDING ALLOCATIONS (NALL0)
!     SET THE STACK ALLOCATION TYPE (IFP)
!
      call stkset(ldstak, 4)
      nall0 = stkst(1)
!
      ifp = 3
!
!     SET THE STARTING LOCATIONS INTHE WORK AREA FOR VARIOUS ARRAYS
!
      if ((ldsmin.le.ldstak) .and. (ldsmin.ge.7)) then
         work = stkget(nfft,ifp)
         lwork = nfft
      else
         work = 1
         lwork = 1
      end if
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
     call bfsdrv(yfft1, yfft2, ymiss1, ymiss2, ccov, nlppc, spcf1,&
    &            spcf2, nf, fmin, fmax, freq, n, nw, lagmax, lags,&
    &            lagmx1, rstak(work), lwork, delta, isym, xaxis,&
    &            yaxis, lpcv, alpha, nprt, parzen, iccov, jccov, m,&
    &            index1, index2, cspc2, phas, icspc2, iphas, codd,&
    &            ceven, w, lw, nmsub, ldsmin, ldstak, option, nfft,&
     &            inlppc, jnlppc, lyfft)
!
      if (ierr.eq.0) return
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL BFSF (YFFT1, YFFT2, N, LYFFT, LDSTAK)')
      end
!LOGLMT
     subroutine loglmt (ilogy, ymn, ymx, ylabel, numrow, istep, dely,&
     &  ywidth, nlably, ydmn, ydmx)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ADJUST PLOT LIMITS FOR LOG PLOTS, AND COMPUTE LOG AXIS LABELS
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   dely,ydmn,ydmx,ymn,ymx,ywidth
     integer&
     &   ilogy,istep,nlably,numrow
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ylabel(20)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   ynlog,yxlog
     integer&
     &   iyn,iynlog,iyx,iyxlog,j,k
!
!  INTRINSIC FUNCTIONS
      intrinsic log10,min,mod,nint,real
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELY
!     INTEGER ILOGY, ISTEP, IYN, IYNLOG, IYX, IYXLOG, J, K
!     INTEGER NLABLY, NUMROW
!     REAL YLABEL(20)
!        THE Y-AXIS LABLES.
!     REAL YDMN, YDMX
!        THE Y-AXIS DATA LIMITS ACTUALLY USED.
!     REAL YMN, YMX
!        THE Y-AXIS PLOT LIMITS ACTUALLY USED.
!     REAL YNLOG, YWIDTH, YXLOG
!
      if (ilogy.eq.0) then
!
        ydmn = ymn
        ydmx = ymx
!
!       DETERMINE THE VALUE OF A DIVISION
!
        dely=ymx-ymn
        ywidth=dely/(numrow-1)
!
!       COMPUTE EVENLY SPACED LABELS FOR NON-LOG AXIS
!
        nlably = 0
        do 10 j = 1, numrow, istep
          nlably = nlably + 1
          ylabel(nlably) = ymx+(1-j)*ywidth
   10   continue
          if (mod(numrow,istep).eq.1) ylabel(nlably) = ymn
          if (ymx.eq.(-ymn) .and. mod(nlably,2).eq.1) then
             ylabel(nlably/2+1) = 0.0
          end if
      else
!
        ydmn = log10(ymn)
        ydmx = log10(ymx)
!
!       ADJUST AXIS LIMITS FOR LOG AXIS IF NECESSARY
!
        yxlog=log10(ymx)
        iyxlog=yxlog
        if (ymx.lt.1.0e0) iyxlog=iyxlog-1
        ynlog=log10(ymn)
        if ((yxlog-ynlog).le.0.92082e0) then
!
!         RANGE IS LESS THAN .9 DECADES
!
          iynlog=ynlog
          if (ymn.lt.1.0e0) iynlog=iynlog-1
          if (iyxlog.le.iynlog) then
!
!           VALUES FALL IN THE SAME DECADE
!
            ynlog=iynlog
            yxlog=ynlog+1.0e0
            iyxlog=yxlog
          else
!
!           VALUES FALL INTO TWO DECADES
!
            iyn=nint(ymn/(10.0e0**iynlog))
            ynlog=min(log10(iyn*(10.0e0**iynlog)),ynlog)
            yxlog=ynlog+1.0e0
            iyxlog=yxlog
          end if
        end if
        ymx=yxlog
        ymn=ynlog
!
!       DETERMINE THE VALUE OF A DIVISION
!
        dely=ymx-ymn
        ywidth=dely/(numrow-1)
!
!       COMPUTE AXIS LABELS
!
        ylabel(1)=10.0e0**yxlog
        iyx=ylabel(1)/(10.0e0**iyxlog)
        k=2
        if (yxlog-ynlog.gt.3.0e0) k=5
        if (yxlog-ynlog.gt.6.0e0) k=10
!
        nlably = 1
!
        if (yxlog-ynlog.le.12.0e0) then
!
!       SET NICE LABELS
!
          if (k.eq.10) iyx=1
          if (iyx.ne.1.and.(iyx-((iyx/k)*k)).ne.0) iyx=((iyx/k)*k)
          if (iyx.le.1) then
            iyx=10
            iyxlog=iyxlog-1
          end if
         if (ylabel(1)-iyx*(10.0e0**iyxlog).gt.0.0e0 .and.&
    &     yxlog-(yxlog-ynlog)/(2.0e0*(numrow-1)) .gt.&
     &     log10(real(iyx))+iyxlog) iyx=iyx+k
          iyx=iyx-k
          if (iyx.le.0) then
            iyx=10
            iyxlog=iyxlog-1
          end if
          do 155 j=2,20
             nlably=nlably+1
             ylabel(nlably)=iyx*(10.0e0**iyxlog)
             if (ylabel(nlably).le.10.0e0**ynlog) go to 156
             iyx=iyx-k
             if (iyx.gt.0) go to 155
             iyx=10
             iyxlog=iyxlog-1
  155     continue
  156     ylabel(nlably)=10.0e0**ynlog
        else
!
!         COMPUTE EVENLY SPACED LABELS
!
          do 160 j = istep, numrow, istep
            nlably = nlably + 1
            ylabel(nlably) = 10.0e0**(ymx+(1.0e0-j)*ywidth)
  160     continue
        end if
      end if
!
      return
      end
!UASCFT
      subroutine uascft (acov, lagmax, lacov, iar, phi, n, var)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE AUTOREGRESSIVE MODEL COEFFICIENTS
!     FOR AN ORDER IAR MODEL USING DURBINS RECURSIVE METHOD.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   var
     integer&
     &   iar,lacov,lagmax,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(lacov),phi(iar)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   rss
     integer&
     &   l
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL ARCOEF
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV)
!        THE ARRAY OF AUTOCOVARIANCE ESTIMATES.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER L
!        AN INDEX VARIABLE.
!     INTEGER LACOV
!        THE LENGTH OF THE ARRAY ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES.
!     REAL PHI(IAR)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     REAL RSS, VAR
!
!
      phi(1) = acov(2) / acov(1)
      rss = acov(1) * n * (1.0e0 - phi(1)*phi(1))
!
      if (iar .le. 1) go to 20
!
      do 10 l = 2, iar
         call arcoef(acov(2), phi, rss, l, lagmax, acov(1))
   10 continue
!
   20 var = rss / (n-iar-1)
!
      return
!
      end
!AMEMN
     subroutine amemn(y, weight, nnzw, wt, lwt, xm, n, m, ixm, nrests,&
    & aprxdv, ifixd, par, pare, npar, res, page, wide,&
    & hlfrpt, stp, lstp, mit, stopss, stopp, scale, lscale, delta,&
    & ivaprx, iptout, ndigit, rsd, rests, sdpvi, sdresi, vcvl, lvcvl,&
     & d, iwork, iiwork, rwork, irwork, nlhdr, npare, pvt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR PERFORMING NONLINEAR
!     LEAST SQUARES REGRESSION USING THE NL2 SOFTWARE PACKAGE
!     (IMPLEMENTING THE METHOD OF DENNIS, GAY AND WELSCH).
!     THIS SUBROUTINE WAS ADAPTED FROM SUBROUTINE NL2SOL.
!
!     REFERENCES
!
!     DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1979), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, (BEING REVISED).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: delta,rsd,stopp,stopss
     integer&
    &   iiwork,irwork,ivaprx,ixm,lscale,lstp,lvcvl,lwt,m,mit,n,&
     &   ndigit,nnzw,npar,npare,nrests,sdpvi,sdresi,vcvl
      logical aprxdv,hlfrpt,page,weight,wide
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   d(nrests,*),par(*),pare(*),pvt(*),res(*),rests(*),rwork(*),&
     &   scale(*),stp(*),wt(*),xm(ixm,*),y(*)
      integer ifixd(*),iptout(*),iwork(*)
!
!  SUBROUTINE ARGUMENTS
       external nlhdr
!
!  SCALARS IN COMMON
      integer ierr
!
!  LOCAL SCALARS
     integer&
    &   cnvcod,covmat,i,icnvcd,ivcvpt,qtr,rd,rdi,rsave,rsshlf,s,&
     &   scl
      logical cmpdrv,done,head,newitr,prtsmy
!
!  LOCAL ARRAYS
      integer iskull(10)
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL AMDRV,AMEFIN,AMEISM,DRV,MDLTS3,NL2ITR,NLERR,NLINIT,NLITRP,NLSUPK,REPCK
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL CMPDRV
!        THE VARIABLE USED TO INDICATE WHETHER DERIVATIVES MUST BE
!        COMPUTED (TRUE) OR NOT (FALSE).
!     INTEGER CNVCOD
!        A VALUE USED TO CONTROL THE PRINTING OF ITERATION REPORTS.
!     INTEGER COVMAT
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
!        OF THE BEGINNING OF THE VCV MATRIX.
!     REAL(KIND=WP) :: D(NRESTS,NPAR)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
!     REAL(KIND=WP) :: DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     LOGICAL DONE
!        THE VARIABLE USED TO INDICATE WHETHER THIS IS THE FINAL
!        COMPUTATION OF THE JACOBIAN OR NOT.
!     LOGICAL HEAD
!        THE VARIABLE USED TO INDICATE WHETHER A HEADING IS TO BE
!        PRINTED DURING A GIVEN CALL TO THE ITERATION REPORT (TRUE)
!        OR NOT (FALSE).
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER ICNVCD
!        THE LOCATION IN IWORK OF
!        THE CONVERGENCE CONDITION.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IIWORK
!        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
!     INTEGER IPTOUT(NDIGIT)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER IRWORK
!        THE DIMENSION OF THE REAL WORK VECTOR RWORK.
!     INTEGER ISKULL(10)
!        AN ERROR MESSAGE INDICATOR VARIABLE.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCVPT
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
!        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
!        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)
!        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                       *INVERSE(HESSIAN)
!     INTEGER IWORK(IIWORK)
!        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LVCVL
!        THE LENGTH OF THE VECTOR CONTAINING
!        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDLTS3
!        THE STARPAC FORMAT SUBROUTINE FOR COMPUTING THE ARIMA MODEL
!        RESIDUALS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     LOGICAL NEWITR
!        A FLAG USED TO INDICATE WHETHER A NEW ITERATION HAS BEEN
!        COMPLETED (TRUE) OR NOT (FALSE).
!     EXTERNAL NLHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL(KIND=WP) :: PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL(KIND=WP) :: PARE(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS, BUT ONLY
!        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
!     LOGICAL PRTSMY
!        THE VARIABLE USED TO INDICATE WHETHER THE SUMMARY
!        INFORMATION IS TO BE PRINTED (TRUE) OR NOT (FALSE).
!     REAL(KIND=WP) :: PVT(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER QTR
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
!        THE ARRAY Q TRANSPOSE R.
!     INTEGER RD
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK OF
!        THE DIAGONAL ELEMENTS OF THE R MATRIX OF THE Q - R
!        FACTORIZATION OF D.
!     INTEGER RDI
!        THE LOCATION IN RWORK OF THE DIAGONAL ELEMENTS OF THE R
!        MATRIX OF THE Q - R FACTORIZATION OF D.
!     REAL(KIND=WP) :: RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL(KIND=WP) :: RESTS(NRESTS)
!        THE RESIDUALS FROM THE ARIMA MODEL.
!     INTEGER RSAVE
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
!        THE ARRAY RSAVE.
!     REAL(KIND=WP) :: RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     INTEGER RSSHLF
!        THE LOCATION IN RWORK OF
!        HALF THE RESIDUAL SUM OF SQUARES.
!     REAL(KIND=WP) :: RWORK(IRWORK)
!        THE REAL WORK VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER S
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
!        THE ARRAY OF SECOND ORDER TERMS OF THE HESSIAN.
!     REAL(KIND=WP) :: SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     INTEGER SCL
!        THE INDEX IN RWORK OF THE 1ST VALUE OF THE USER SUPPLIED SCALE
!        VALUE.
!     INTEGER SDPVI
!        THE STARTING LOCATION IN RWORK OF
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     INTEGER SDRESI
!        THE STARTING LOCATION IN RWORK OF THE
!        THE STANDARDIZED RESIDUALS.
!     REAL(KIND=WP) :: STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!        PREDICTED DECREASE IN THE RESIDUAL STANDARD DEVIATION (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL(KIND=WP) :: STOPSS
!        THE STOPPING CRITERION FORTHE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL(KIND=WP) :: STP(LSTP)
!        THE DUMMY STEP SIZE ARRAY.
!     INTEGER VCVL
!        THE STARTING LOCATION IN RWORK OF THE LOWER HALF OF THE
!        VCV MATRIX, STORED ROW WISE.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL(KIND=WP) :: WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     REAL(KIND=WP) :: XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL(KIND=WP) :: Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     IWORK SUBSCRIPT VALUES
!
     data cnvcod /34/, icnvcd /1/, covmat /26/, qtr /49/, rd /51/,&
     &   rsave /52/, s/53/
      data rsshlf /10/
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
!     INITIALIZE CONTROL PARAMETERS
!
     call nlinit (nrests, ifixd, par, npar, pare, npare, mit, stopss,&
    &   stopp, scale, lscale, delta, ivaprx, aprxdv, ivcvpt, iwork,&
     &   iiwork, rwork, irwork, scl)
!
      cmpdrv = .true.
      done = .false.
      head = .true.
      newitr = .false.
      prtsmy = (iptout(1).ne.0)
!
!     COMPUTE RESIDUALS
!
   10 call mdlts3(par, npar, xm, n, m, ixm, rests)
!
!     PRINT INITIAL SUMMARY
!
      if (.not.prtsmy) go to 30
     call ameism(nlhdr, page, wide, hlfrpt, npar, m, n, nnzw, weight,&
    &   ifixd, par, scale, lscale, iwork, iiwork, rwork, irwork, rests,&
     &   aprxdv, stp, lstp, npare)
      prtsmy = .false.
!
   30 continue
!
      if (.not.cmpdrv) go to 50
!
      cmpdrv = .false.
!
   40 continue
!
!     PRINT ITERATION REPORT IF DESIRED
!
     if ((iptout(2).ne.0) .and. newitr) call nlitrp(nlhdr, head, page,&
    &   wide, iptout(2), npar, nnzw, iwork, iiwork, rwork, irwork,&
     &   ifixd, pare, npare)
!
!  ***  COMPUTE JACOBIAN  ***
!
      if (done) call mdlts3(par, npar, xm, n, m, ixm, rests)
!
     call amdrv(mdlts3, drv, done, ifixd, par, npar, xm, n, m, ixm,&
     &  nrests, rests, d, weight, wt, lwt, stp, lstp, rwork(scl), npare)
!
      if (done) go to 70
!
!     COMPUTE NEXT ITERATION
!
  50  continue
!          nl2itr(d(p),       iv(*), j(nn,p), n,      nn,     p,     r(n),  v(*),  x(p))
      call nl2itr(rwork(scl), iwork, d,       nrests, nrests, npare, rests, rwork, pare)
!
!     UNPACK PARAMETERS
!
      call nlsupk(pare, npare, par, ifixd, npar)
!
      newitr = (iwork(cnvcod).eq.0)
      if (iwork(1)-2) 10, 40, 60
!
   60 done = .true.
      go to 40
   70 continue
!
!     SET ERROR FLAGS, IF NECESSARY
!
      call nlerr(iwork(icnvcd), iskull)
!
!     FINISH COMPUTATIONS AND PRINT ANY DESIRED RESULTS
!
      call scopy(n, rests(nrests-n+1), 1, res(1), 1)
      do 75 i = 1, n
         pvt(i) = y(i) - res(i)
   75 continue
      sdpvi = iwork(rsave)
      sdresi = iwork(qtr)
      vcvl = iwork(covmat)
      if (vcvl.ge.1) go to 80
!
      vcvl = iwork(s)
      if (ierr.ne.0) go to 80
      iskull(1) = 1
      iskull(7) = 1
      ierr = 7
!
   80 continue
!
      lvcvl = npare*(npare+1)/2
!
      rdi = iwork(rd)
!
!     REPCK IS CALLED TO AVOID MODIFICATION OF NLS CODE.  FUTURE
!     REVISIONS OF NLS CODE SHOULD INCLUDE MODIFICATIONS NECESSARY
!     TO ELIMINATE NEED TO REPACK D FOR ARIMA CODE.
!
      call repck(d, nrests, npar, n)
     call amefin(y, weight, nnzw, wt, lwt, xm, n, m, ixm, ifixd, par,&
    &   npar, npare, res, page, wide, iptout, ndigit, rwork(rsshlf),&
    &   rsd, pvt, rwork(sdpvi), rwork(sdresi), rwork(rdi),&
     &   rwork(vcvl), lvcvl, d, nlhdr, ivcvpt, iskull, nrests)
!
      return
!
      end
!DRV2
      subroutine drv2(par, npar, xm, n, m, ixm, d)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DERIVATIVE FUNCTION FOR NLS FAMILY EXERCISER SUBROUTINE MDL2.
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   d(n,npar),par(npar),xm(ixm,m)
!
!  LOCAL SCALARS
     integer&
     &   i
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL PAR(NPAR)
!        MODEL PARAMETERS
!     REAL D(N,NPAR)
!        THE FIRST DERIVATIVE WITH RESPECT TO THE ITH PARAMETER
!     INTEGER I
!        ROW MARKER
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLESC
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS
!     REAL XM(IXM,M)
!        MODEL INDEPENDENT VARIABLE
!
!
      do 10 i=1,n
         d(i,1) = xm(i,1)
         d(i,2) = xm(i,2)
         d(i,3) = xm(i,3)**3
   10 continue
!
      return
!
      end
!LLSPWS
     subroutine llspws(y, wt, xm, n, ndeg, res, ldstak,&
     &   nprt, lpar, par, npar, rsd, pv, sdpv, sdres, vcv, ivcv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CALL FOR POLYNOMIAL MODEL LEAST SQUARES FIT
!     USER SUPPLIED WEIGHTS SPECIFIED
!     FULL STORAGE
!     USER CONTROL OF AUTOMATIC PRINTOUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   ivcv,ldstak,lpar,n,ndeg,npar,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),pv(*),res(*),sdpv(*),sdres(*),vcv(*),wt(*),xm(*),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,lpv,lsdpv,lsdres,lwt
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LLCNTP
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDEG
!        THE DEGREE OF THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     REAL PAR(LPAR)
!        THE PARAMETERS  TO BE ESTIMATED.
!     REAL PV(N)
!        THE PREDICTED VALUES.
!     REAL RES(N)
!        THE RESIDUALS.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     REAL SDPV(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(N)
!        THE STANDARDIZED RESIDUALS.
!     REAL VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(N)
!        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
!     REAL XM(N,1)
!        THE INDEPENDENT VARIABLE.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'L','L','S','P','W','S'/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      weight = .true.
      save = .true.
      lpv = n
      lsdpv = n
      lsdres = n
      lwt = n
!
     call llcntp(y, wt, lwt, xm, n, ndeg, npar, res, ldstak, nprt,&
    &   par, lpar, rsd, pv, lpv, sdpv, lsdpv, sdres, lsdres, vcv, ivcv,&
     &   nmsub, weight, save)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (//42h the correct form of the call statement is//&
    &   '       CALL LLSPWS (Y, WT, X, N, NDEG, RES, LSDTAK,'/&
    &   '      +             NPRT, LPAR, PAR, NPAR, RSD, PV, SDPV,'/&
     &   '      +             SDRES, VCV, IVCV)')
      end
!LLS
      subroutine lls(y, xm, n, ixm, npar, res, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CALL FOR GENERAL LINEAR MODEL LEAST SQUARES FIT
!     NO WEIGHTS SPECIFIED
!     NO STORAGE OTHER THAN RESIDUALS
!     FOUR PAGES AUTOMATIC PRINTOUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,ldstak,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   res(*),xm(*),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   iprt,ivcv,lpar,lpv,lsdpv,lsdres,lwt,nprt
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   par(1),pv(1),sdpv(1),sdres(1),vcv(1,1),wt(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LLCNTG
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     REAL PAR(1)
!        A DUMMY ARRAY FOR
!        THE PARAMETERS  TO BE ESTIMATED.
!     REAL PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUES.
!     REAL RES(N)
!        THE RESIDUALS.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     REAL SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARDIZED RESIDUALS.
!     REAL VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(1)
!        A DUMMY ARRAY FOR
!        THE WEIGHTS.
!     REAL XM(IXM,NPAR)
!        THE INDEPENDENT VARIABLE.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'L','L','S',' ',' ',' '/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      weight = .false.
      save = .false.
      nprt = 1111
      lpar = 1
      lpv = 1
      lsdpv = 1
      lsdres = 1
      ivcv = 1
      lwt = 1
!
     call llcntg(y, wt, lwt, xm, n, ixm, npar, res, ldstak, nprt,&
    &   par, lpar, rsd, pv, lpv, sdpv, lsdpv, sdres, lsdres, vcv, ivcv,&
     &   nmsub, weight, save)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (//42h the correct form of the call statement is//&
     &   50h       call lls (y, xm, n, ixm, npar, res, lsdtak))
      end
!LLSWS
     subroutine llsws(y, wt, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CALL FOR GENERAL LINEAR MODEL LEAST SQUARES FIT
!     USER SUPPLIED WEIGHTS SPECIFIED
!     FULL STORAGE
!     USER CONTROL OF AUTOMATIC PRINTOUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   ivcv,ixm,ldstak,n,npar,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),pv(*),res(*),sdpv(*),sdres(*),vcv(*),wt(*),xm(*),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,lpar,lpv,lsdpv,lsdres,lwt
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LLCNTG
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     REAL PAR(NPAR)
!        THE PARAMETERS  TO BE ESTIMATED.
!     REAL PV(N)
!        THE PREDICTED VALUES.
!     REAL RES(N)
!        THE RESIDUALS.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     REAL SDPV(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(N)
!        THE STANDARDIZED RESIDUALS.
!     REAL VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(N)
!        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
!     REAL XM(IXM,NPAR)
!        THE INDEPENDENT VARIABLE.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'L','L','S','W','S',' '/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      weight = .true.
      save = .true.
      lpar = npar
      lpv = n
      lsdpv = n
      lsdres = n
      lwt = n
!
     call llcntg(y, wt, lwt, xm, n, ixm, npar, res, ldstak, nprt,&
    &   par, lpar, rsd, pv, lpv, sdpv, lsdpv, sdres, lsdres, vcv, ivcv,&
     &   nmsub, weight, save)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (//42h the correct form of the call statement is//&
    & '       CALL LLSWS (Y, WT, XM, N, IXM, NPAR, RES, LSDTAK,'/&
     & '      +            NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)')
      end
!IPGMP
      subroutine ipgmp (per, freq, nf, n, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
!     THE INTEGRATED PERIODOGRAM OF A SERIES (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,n,nf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(*),per(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,isym,ldsmin,lpcv,nall0,nprt,peri,xaxis,yaxis
     logical&
     &   err01,err02,err03,head
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     character&
     &   llds(8)*1,ln(8)*1,lnf(8)*1,nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,IPGDV,IPRINT,LDSCMP,STKCLR,STKSET
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     REAL FREQ(NF)
!        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
!        INTEGRATED SPECTRUM VALUES ARE STORED.
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER ISYM
!        ...
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     CHARACTER*1 LLDS(8), LN(8), LNF(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER LPCV
!        ...
!     INTEGER N
!        THE ACTUAL NUMBER OF OBSERVATIONS IN THE SERIES FROM WHICH
!        THE PERIODOGRAM WAS COMPUTED.
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING ALLOCATIONS OF THE STACK AT THE
!        TIME OF THIS CALL.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        TO BE COMPUTED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A PAGE PLOT.
!     REAL PER(NF)
!        THE RAW PERIODOGRAM.
!     INTEGER PERI
!        THE STARTING LOCATION IN THE STACK FOR
!        THE VECTOR CONTAINING THE INTEGRATED PERIODOGRAM.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE X AXIS VALUES TO BE PLOTTED ARE STORED.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'I',       'P',       'G',       'M',       'P',       ' '/
     data&
    & llds(1), llds(2), llds(3), llds(4), llds(5),&
     &  llds(6), llds(7), llds(8) /'L','D','S','T','A','K',' ',' '/
     data&
    & ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /'N',' ',' ',' ',' ',' ',' ',' '/
     data&
    & lnf(1), lnf(2), lnf(3), lnf(4), lnf(5), lnf(6), lnf(7), lnf(8)&
     & /'N','F',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 17, 1, head, err01, ln)
!
      call eisge(nmsub, lnf, nf, (n+2)/2, 1, head, err02, lnf)
!
      if (err01) go to 5
!
      call ldscmp(4, 0, nf+103, 0, 0, 0, 'S', 3*nf+206, ldsmin)
!
      call eisge(nmsub, llds, ldstak, ldsmin, 9, head, err03, llds)
!
      if (err02 .or. err03) go to 5
      go to 10
!
    5 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   10 continue
!
!     SET THE SIZE OF THE WORK AREA
!
      call stkset(ldstak, 4)
!
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!
      nall0 = stkst(1)
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      lpcv = nf + 103
      nprt = 1
!
!     SUBDIVIDE THE STACK.
!
      isym = stkget(lpcv, 2)
      peri = stkget(nf, 3)
      xaxis = stkget(lpcv, 3)
      yaxis = stkget(lpcv, 3)
!
!     CALL THE MAIN DRIVER FOR COMPUTING (AND PLOTTING) THE INTEGRATED
!     PERIODOGRAM.
!
     call ipgdv (per, nf, n, rstak(peri), freq, rstak(xaxis),&
     &   rstak(yaxis), istak(isym), lpcv, nprt)
!
      call stkclr(nall0)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &  '       CALL IPGMP (PER, FREQ, NF, N, LDSTAK)')
      end
!XSTPLD
      subroutine xstpld(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,exmpt
     integer&
     &   i,iprt,ixm,ldsmin,m,n,neta,npar,nprt,ntest
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   par(10),scale(10),stp(10),xm(200,2)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LDSCMP,LSTVEC,MDL4,STPLS,STPLS1,STPLS2,STPLSC
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        *
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL4
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     REAL PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL SCALE(10)
!        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL STP(10)
!        THE SELECTED STEP SIZES FOR EACH PARAMETER.
!     REAL XM(200,2)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      call iprint(iprt)
!
!     SET PARAMETER VALUES
!
      call stpls1(n, m, ixm, par, npar, neta, exmpt, scale, nprt)
      call stpls2(npar, stp)
      call ldscmp(14, 0, 2*(n+npar), 0, 0, 0, 'S', 10*n, ldsmin)
!
      if (ldsmin.le.ldstak) go to 5
!
      write (iprt, 1020) ldsmin
      return
!
    5 continue
!
!     CREATE INDEPENDENT VARIABLE
!
      delta = 0.0625e0
      xm(1,1) = 0.0e0
      do 10 i=2,n
         xm(i,1) = xm(i-1,1) + delta
   10 continue
!
      ntest = 0
!
!     CHECK RESULTS FROM VALID CALLS
!
!     SIMPLE EXAMPLE
!
      call stpls1(n, m, ixm, par, npar, neta, exmpt, scale, nprt)
!
      ntest = ntest + 1
      write (iprt,1090) ntest
      write (iprt,1040)
      write (iprt,1000)
      call stpls2(npar, stp)
      call stpls(xm, n, m, ixm, mdl4, par, npar, ldsmin, stp)
      write (iprt,1050) ierr
      write (iprt,1080)
      call lstvec(4, stp)
!
      ntest = ntest + 1
      write (iprt,1090) ntest
      write (iprt,1040)
      write (iprt,1060) neta, exmpt, scale(1), nprt
      write (iprt,1010)
      call stpls2(npar, stp)
     call stplsc(xm, n, m, ixm, mdl4, par, npar, ldsmin, stp, neta,&
     &   exmpt, scale, nprt)
      write (iprt,1100) neta, exmpt, scale(1), nprt
      write (iprt,1050) ierr
      write (iprt,1080)
      call lstvec(4, stp)
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (15h test of stpls )
 1010 format (15h test of stplsc)
 1020 format (45h1 *** ldstak must be greater than or equal to , i6)
 1040 format (15h simple example)
1050 format (/29h ***** returned results *****, 5x, 15h (-1 indicates ,&
     &   39hvalue not changed by called subroutine)//9h ierr is , i3)
1060 format (19h input   -  neta = , i5, 10h, exmpt = , g15.8,&
     &   13h, scale(1) = , g15.8, 9h, nprt = , i5)
 1080 format (//23h returned values of stp)
1090 format (54h1derivative step size selection subroutine test number,&
     &   i5)
1100 format (//19h output  -  neta = , i5, 10h, exmpt = , g15.8,&
     &   13h, scale(1) = , g15.8, 9h, nprt = , i5//)
      end
!EXTEND
      real(kind=wp) function extend(x, i, n, sym)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!      THIS FUNCTION RETURNS THE ITH TERM IN THE SERIES X,
!     EXTENDING IF NECESSARY WITH EVEN OR ODD SYMMETRY ACCORDING
!     TO THE SIGN OF SYM, WHICH SHOULD BE EITHER PLUS OR MINUS ONE.
!     (THE VALUE ZERO WILL RESULT IN THE EXTENDED VALUE BEING ZERO.)
!     THIS ROUTINE IS TAKEN FROM BLOOMFIELDS BOOK, PAGE 179.
!
!     WRITTEN BY  -  PETER BLOOMFIELD
!     CODED BY  -  JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   sym
     integer&
     &   i,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   con
     integer&
     &   j
!
      j = i
      con = 1.0e0
   10 if (j .ge. 1) go to 20
      j = 2-j
      con = con * sym
   20 if (j .le. n) go to 30
      j = 2*n-j
      con = con * sym
      go to 10
   30 extend = x(j)*con
!
      return
!
      end
!UASS
     subroutine uass (y, n, iar, phi, lagmax, lag, nf, fmin, fmax,&
     &   nprt, spca, spcf, freq, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
!     SPECTRUM ESTIMATION (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fmax,fmin
     integer&
     &   iar,lag,lagmax,ldstak,n,nf,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(*),phi(*),spca(*),spcf(*),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta,fmn,fmx,var,ymean
     integer&
    &   acov,aic,ftest,ia,ifp,io,iprt,isort,isym,lacov,laic,&
     &   ldsmin,lpcv,lphi,lspc,lwork,nall0,work,xaxis,yaxis
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACVF,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UASDV,UASER,
!     +   UASVAR
!
!  INTRINSIC FUNCTIONS
      intrinsic max,min
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER ACOV
!        THE STARTING LOCATION IN RSTAK FOR THE ARRAY OF
!        THE AUTOCOVARIANCE ARRAY.
!     INTEGER AIC
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY CONTAINING THE AIC.
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
!        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
!     REAL FMN, FMX
!        THE MAXIMUM AND MINIMUM FREQUENCY ACTUALLY USED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     INTEGER FTEST
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IA
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON WHETHER OR NOT THE MODEL ORDER IS TO BE SELECTED OR
!        HAS BEEN PROVIDED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION IN ISTAK FOR
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN ISTAK FOR
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE COVARIANCE ARRAYS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE ARRAY AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER LSPC
!         THE LENGTH OF THE SPECTRUM ARRAYS.
!     INTEGER LWORK
!        THE LENGTH OF THE WORK ARRAY.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS OUTSTANDING WHEN THIS ROUTINE
!        WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
!        ARE TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE TYPE OF WINDOW TO BE USED.
!     REAL PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL SPCA(NF)
!        THE ARRAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!     REAL SPCF(NF)
!        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
!     REAL VAR
!        THE ONE STEP PREDICTION VARIANCE.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE STACK FOR
!        THE WORK ARRAY.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN RSTAK FOR
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL Y(N)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN RSTAK FOR
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'U',       'A',       'S',       'S',       ' ',       ' '/
!
      ifp = 3
!
!     SET UP FOR ERROR CHECKING
!
      option(1) = .false.
      option(2) = .false.
      option(3) = .false.
      option(4) = .true.
!
      io = 1
      if (nprt .eq. 0) io = 0
      ia = 1
      if (iar .ne. 0) ia = 0
!
     call ldscmp(7, 0, io*(2*nf+5), 0, 0, 0, 'S',&
     &   2*lagmax+2+ia*(3*lagmax+1)+io*(4*nf+10), ldsmin)
!
!     CALL ERROR CHECKING ROUTINE
!
     call uaser(nmsub, n, y, iar, phi, lagmax, lag, lacov,&
     &   nf, ldstak, ldsmin, n, n, option)
!
   10 if (ierr.ne.0) then
         ierr = 1
         call iprint (iprt)
         write (iprt, 1000)
         return
      end if
!
!     SET SIZE OF WORK AREA.
!
      call stkset (ldstak, 4)
!
!     SAVE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
!
      nall0 = stkst(1)
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      lspc = nf
      lpcv = 2*nf + 5
      lphi = lagmax
      lacov = lagmax + 1
      lwork = lagmax+1
!
      fmn = max(fmin, 0.0e0)
      fmx = min(fmax, 0.5e0)
      if (fmn.ge.fmx) then
        fmn = 0.0e0
        fmx = 0.5e0
      end if
!
      alpha = 0.95e0
      delta = 1.0e0
!
!     COMPUTE AUTOCOVARIANCES
!
      acov = stkget(lacov, ifp)
!
      call acvf (y, n, ymean, rstak(acov), lagmax, lacov)
!
      if (iar.ge.1) then
!
!     USER HAS CHOSEN ORDER AND SUPPLIED COEFFICIENTS.
!     COMPUTE RESIDUAL VARIANCE.
!
         call uasvar (y, ymean, n, iar, phi, var)
      end if
!
!     SET UP ADDITIONAL STACK WORK AREA, IF NEEDED.
!
      work = stkget(lwork, ifp)
!
      if (iar.eq.0) then
         laic = lagmax+1
         aic = stkget(laic, ifp)
         ftest = stkget(2*lagmax, ifp)
      else
         laic = lwork
         aic = work
         ftest = work
      end if
      if (nprt.eq.0) then
         xaxis = work
         yaxis = work
         isym = work
         isort = work
      else
         xaxis = stkget(lpcv, ifp)
         yaxis = stkget(lpcv, ifp)
         isym = stkget(lpcv, 2)
         isort = isym
      end if
!
      if (ierr.eq.1) go to 10
!
!     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
!
     call uasdv(rstak(acov), spca, spcf, lspc, iar, phi, nf, fmn,&
    &   fmx, freq, n, lagmax, rstak(ftest), rstak(aic), rstak(work),&
    &   lacov, lwork, delta, istak(isort), istak(isym), rstak(xaxis),&
    &   rstak(yaxis), lpcv, alpha, lag, laic, lphi, nprt, var, parzen,&
     &   nmsub)
!
      call stkclr(nall0)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    & '       CALL UASS (Y, N,'/&
    & '      +           IAR, PHI, LAGMAX, LAG, NF, FMIN, FMAX, NPRT,'/&
     & '      +           SPCA, SPCF, FREQ, LDSTAK)')
      end
!UASVAR
      subroutine uasvar (y, ymean, n, iar, phi, var)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE VARIANCE FOR A GIVEN SERIES
!     AND AUTOREGRESSIVE MODEL.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   var,ymean
     integer&
     &   iar,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   phi(iar),y(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   res,rss
     integer&
     &   i,iar1,j,k
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IAR1
!        THE VALUE IAR + 1.
!     INTEGER J, K
!        INDEX VALUES.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     REAL PHI(IAR)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     REAL RES
!        *
!     REAL RSS
!        THE ONE STEP PREDICTION RESIDUAL SUM OF SQUARES.
!     REAL VAR
!        THE ONE STEP PREDICTION VARIANCE.
!     REAL Y(N)
!         THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
      rss = 0.0e0
      iar1 = iar+1
      do 20 i = iar1, n
         res = y(i) - ymean
         do 10 j = 1, iar
            k = i-j
            res = res - phi(j) * (y(k)-ymean)
   10    continue
         rss = rss + res*res
   20 continue
!
      var = rss / (n-iar1)
!
      return
!
      end
!SPPML
      subroutine sppml(ym, ymiss, x, xmiss, n, isym, ilog)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH USER CONTROL OF PLOT SYMBOLS AND WITH MISSING
!     OBSERVATIONS (LOG OPTION).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: ymiss, xmiss
     integer&
     &   ilog,n
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: x(*),ym(*)
     integer&
     &   isym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xlb,xub,ylb,yub
     integer&
     &   iprt,ischck,isize,iym,lisym,m,nout
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
      real(kind=wp) :: ymmiss(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YMISS
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'S',       'P',       'P',       'M',       'L',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      ymmiss=ymiss
      m = 1
      iym = n
      multi = .false.
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 0.0e0
      xub = 0.0e0
      ischck = 1
      isize = -1
      nout = 0
      miss = .true.
      lisym = n
!
     call ppcnt (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL SPPML (Y, YMISS, X, XMISS, N, ISYM, ILOG)')
      end
!CCFS
     subroutine ccfs (ym, n, m, iym, lagmax, ccov, iccov, jccov,&
     &   nprt, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
!     CORRELATIONS AND COVARIANCES OF A MULTIVARIATE SERIES (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iccov,iym,jccov,lagmax,ldstak,m,n,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ccov(*),ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
    &   i,ifp,inlppc,io,iprt,iymfft,j,jnlppc,k,ldsmin,lyfft,nall0,&
     &   nfft,rhoc,sdrhoc,ymean,ymeanj,ymeank,ysd,ysdj,ysdk
     logical&
     &   isfft,islong,newpg
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   ndum(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACVF,CCFER,CCFMN,CCFOUT,IPRINT,LDSCMP,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  STATEMENT FUNCTIONS
     integer&
     &   i2,i3
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCOV(ICCOV, JCCOV, M)
!        THE CROSS COVARIANCE MATRIX.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ICCOV
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INLPPC
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
!        IN THE USERS PROGRAM.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON WHETHER PRINTED OUTPUT IS DESIRED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     LOGICAL ISLONG
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
!     INTEGER IYM
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YM AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IYMFFT
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER I2
!        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN YM
!     INTEGER I3
!        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN CCOV
!     INTEGER J
!        THE INDEX OF -SERIES 1- IN THE ARRAY YM.
!     INTEGER JCCOV
!        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
!        IN THE USERS PROGRAM.
!     INTEGER K
!        THE INDEX OF -SERIES 2- IN THE ARRAY YM.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER M
!        THE NUMBER OF SERIES BEING COMPARED, IE THE
!        NUMBER OF COLUMNS OF DATA IN YM.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     INTEGER NDUM(1)
!        A DUMMY DIMENSIONED VARIABLE.
!     LOGICAL NEWPG
!        AN INDICATOR VARIABLE USED TO DETERMINE WHEN A NEW PAGE
!        IS APPROPRIATE FOR THE OUTPUT.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPEDIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS GIVEN.
!     INTEGER RHOC
!        THE STARTING LOCATION IN DSTAK OF THE ARRAY RHOC.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SDRHOC
!        THE STARTING LOCATION IN THE WORK AREA FOR SDRHOC.
!     REAL YM(IYM, M)
!        THE MATRIX CONTAINING THE OBSERVED TIME SERIES
!     INTEGER YMEAN, YMEANJ, YMEANK
!        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
!        MEANS OF EACH OF THE SERIES, AND THE LOCATION IN
!        THE ARRAY FOR THE MEAN OF THE JTH AND KTH SERIES,
!        RESPECTIVELY.
!     INTEGER YSD, YSDJ, YSDK
!        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
!        STANDARD DEVIATIONS OF EACH OF THE SERIES, AND THE
!        LOCATION IN THE ARRAY FOR THE STANDARD DEVIATION OF
!        THE JTH AND KTH SERIES, RESPECTIVELY.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'C',       'C',       'F',       'S',       ' ',       ' '/
!
      i2(i,j) = i + (j-1)*iym
      i3(i,j,k) = i + (j-1)*iccov + (k-1)*jccov*iccov
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      inlppc = iccov
      jnlppc = jccov
      lyfft = n + lagmax
      iymfft = iym
      nfft = n
      isfft = .false.
      islong = .true.
!
      io = 1
      if (nprt .eq. 0) io = 0
!
     call ldscmp(2+2*io, 0, 0, 0, 0, 0, 'S',&
     &            2*m+io*(4*lagmax+2), ldsmin)
!
     call ccfer(nmsub, n, lagmax, ldstak, ldsmin, iccov, jccov,&
     &  inlppc, jnlppc, m, lyfft, nfft, iym, iymfft, isfft, islong)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      if (ierr.eq.0) then
!
!       SET UP THE WORK AREA.
!
        call stkset (ldstak, 4)
        nall0 = stkst(1)
!
        ifp = 3
!
        ymean = stkget(m, ifp)
        ysd = stkget(m, ifp)
        if (nprt.eq.0) then
          rhoc = ysd
          sdrhoc = ysd
        else
          rhoc = stkget(2*lagmax+1, ifp)
          sdrhoc = stkget(2*lagmax+1, ifp)
        end if
!
        if (ierr.eq.0) then
!
!         BEGIN LOOP FOR COMPUTATIONS
!
          newpg = .false.
!
          do 40 k = 1, m
!
             ymeank = ymean + k - 1
             ysdk = ysd + k - 1
!
            call acvf (ym(i2(1,k)), n, rstak(ymeank),&
     &                  ccov(i3(1,k,k)), lagmax, iccov)
             rstak(ysdk) = sqrt(ccov(i3(1,k,k)) * n / (n - 1))
!
             if ((k-1).le.0) go to 40
!
             do 30 j = 1, (k-1)
!
                ymeanj = ymean + j - 1
                ysdj = ysd + j - 1
!
               call ccfmn (ym(i2(1,j)), ym(i2(1,k)),&
    &                      n, lagmax, 2*lagmax+1,&
    &                      ccov(i3(1,j,j)), ccov(i3(1,k,k)),&
    &                      ccov(i3(1,j,k)), ccov(i3(1,k,j)),&
    &                      iccov, rstak(ymeanj), rstak(ymeank),&
     &                      rstak(rhoc), rstak(sdrhoc), nprt)
!
                if (nprt .eq. 0) go to 30
!
!         CALL ROUTINE TO PRINT OUT CORRELATIONS
!
               call ccfout (j, rstak(ymeanj), rstak(ysdj), n, n, k,&
    &             rstak(ymeank), rstak(ysdk), n, n, lagmax, 2*lagmax+1,&
    &             rstak(rhoc), rstak(sdrhoc), .false., ndum, ndum, 1,&
     &             0.0e0, 0.0e0, newpg)
!
                newpg = .true.
!
   30        continue
   40     continue
        end if
!
        call stkclr(nall0)
      end if
!
      if (ierr.ne.0) then
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        ierr = 1
        call iprint (iprt)
        write (iprt, 1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format(/42h the correct form of the call statement is//&
    &   '       CALL CCFS (YM, N, M, IYM,'/&
     &   '      +           LAGMAX, CCOV, ICCOV, JCCOV, NPRT, LDSTAK)')
      end
!AIME
      subroutine aime (y, n, mspec, nfac, par, npar, res, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR ARIMA ESTIMATION
!     (CONTROL CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,n,nfac,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),res(*),y(*)
     integer&
     &   mspec(4,*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
    &   iprt,ivaprx,ivcv,lifixd,lpv,lscale,lsdpv,lsdres,lstp,mit,&
     &   npare,nprt
     logical&
     &   save
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   pv(1),scale(1),sdpv(1),sdres(1),stp(1),vcv(1,1)
     integer&
     &   ifixed(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AMEDRV,IPRINT
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!        IF IFIXED(1).LT.0, THEN IFIXED(I)=DEFAULT,I=1,...,NPAR, AND THE
!                           DIMENSION OF IFIXED WILL BE ASSUMED TO BE 1.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE FOR
!        IVAPRX LE 0, VCV = THE DEFAULT OPTION
!        IVAPRX EQ 1, VCV = INVERSE(TRANSPOSE(J)*J)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2, VCV = INVERSE(H)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4, VCV = INVERSE(TRANSPOSE(J)*J)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5, VCV = INVERSE(H)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7, VCV = THE DEFAULT OPTION
!        WITH J REPRESENTING THE JACOBIAN AND H THE HESSIAN.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE DIMENSION OF VECTOR IFIXED.
!     INTEGER LPV
!        THE DIMENSION OF VECTOR PV.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER LSDPV
!        THE DIMENSION OF VECTOR SDPV.
!     INTEGER LSDRES
!        THE DIMENSION OF VECTOR SDRES.
!     INTEGER LSTP
!        THE DIMENSION OF VECTOR STP.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER MSPEC(4,NFAC)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PV(1)
!        THE PREDICTED VALUE OF THE FIT, UNUSED WHEN SAVE = FALSE.
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(1)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!        IF SCALE(1).LE.0, THEN SCALE(I)=DEFAULT,I=1,...,NPAR, AND THE
!                          DIMENSION OF SCALE WILL BE ASSUMED TO BE 1.
!     REAL SDPV(1)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES, UNUSED
!        WHEN SAVE = FALSE.
!     REAL SDRES(1)
!        THE STANDARDIZED RESIDUALS, UNUSED WHEN SAVE = FALSE.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(1)
!        THE STEP SIZE ARRAY.
!        IF STP(1).LE.0, THEN STP(I)=DEFAULT,I=1,...,NPAR, AND THE
!                        DIMENSION OF STP WILL BE ASSUMED TO BE 1.
!     REAL VCV(1,1)
!        THE VARIANCE-COVARIANCE MATRIX, UNUSED WHEN SAVE = FALSE.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'A','I','M','E',' ',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      save = .false.
!
      lifixd = 1
      ifixed(1) = -1
      lstp = 1
      stp(1) = 0.0e0
      mit = -1
      stopss = -1.0e0
      stopp = -1.0e0
      lscale = 1
      scale(1) = 0.0e0
      delta = -1.0e0
      ivaprx = -1
      nprt = -1
      lpv = 1
      lsdpv = 1
      lsdres = 1
      ivcv = 1
!
     call amedrv(y, n, mspec, nfac, par, npar, res,&
    &   ldstak, ifixed, lifixd, stp, lstp, mit, stopss, stopp, scale,&
    &   lscale, delta, ivaprx, nprt, rsd, pv, lpv, sdpv, lsdpv, sdres,&
     &   lsdres, vcv, ivcv, nmsub, save, npare)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
!
1000 format (/' THE CORRECT FORM OF THE CALL STATEMENT IS'//&
     &  '       CALL AIME (Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK)')
      end
!UASVS
     subroutine uasvs (acov, lagmax, y, n, iar, phi, lag, nf,&
     &   fmin, fmax, nprt, spca, spcf, freq, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
!     SPECTRUM ESTIMATION WHEN THE ACVF HAVE PREVIOUSLY BEEN
!     COMPUTED AND STORED (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fmax,fmin
     integer&
     &   iar,lag,lagmax,ldstak,n,nf,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(*),freq(*),phi(*),spca(*),spcf(*),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta,fmn,fmx,var,ymean
     integer&
    &   aic,ftest,ia,ifp,io,iprt,isort,isym,lacov,laic,ldsmin,&
     &   lpcv,lphi,lspc,lwork,nall0,work,xaxis,yaxis
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AMEAN,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UASDV,UASER,
!     +   UASVAR
!
!  INTRINSIC FUNCTIONS
      intrinsic max,min
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LAGMAX+1)
!        THE ARRAY OF AUTOCOVARIANCE ESTIMATES.
!     INTEGER AIC
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY CONTAINING THE AIC.
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
!        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
!     REAL FMN, FMX
!        THE MAXIMUM AND MINIMUM FREQUENCY ACTUALLY USED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     INTEGER FTEST
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IA
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON WHETHER OR NOT THE MODEL ORDER IS TO BE SELECTED OR
!        HAS BEEN PROVIDED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION IN ISTAK FOR
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN ISTAK FOR
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE COVARIANCE ARRAYS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE ARRAY AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER LSPC
!         THE LENGTH OF THE SPECTRUM ARRAYS.
!     INTEGER LWORK
!        THE ACTUAL LENGTH OF THE WORK ARRAY.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS OUTSTANDING WHEN THIS ROUTINE
!        WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
!        ARE TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE TYPE OF WINDOW TO BE USED.
!     REAL PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL SPCA(NF)
!        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!     REAL SPCF(NF)
!        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
!     REAL VAR
!        THE ONE STEP PREDICTION VARIANCE.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE STACK FOR
!        THE WORK ARRAY.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN RSTAK FOR
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL Y(N)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN RSTAK FOR
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'U',       'A',       'S',       'V',       'S',       ' '/
!
      ifp = 3
!
!     SET UP FOR ERROR CHECKING
!
      option(1) = .false.
      option(2) = .false.
      option(3) = .true.
      option(4) = .true.
!
      lacov = lagmax+1
!
      io = 1
      if (nprt .eq. 0) io = 0
      ia = 1
      if (iar .ne. 0) ia = 0
!
     call ldscmp(6, 0, io*(2*nf+5), 0, 0, 0, 'S',&
     &   lagmax + 1 + ia*(3*lagmax+1) + io*(4*nf+10), ldsmin)
!
!     CALL ERROR CHECKING ROUTINE
!
     call uaser(nmsub, n, acov, iar, phi, lagmax, lag, lacov,&
     &   nf, ldstak, ldsmin, n, n, option)
!
    5 if (ierr.ne.0) then
         ierr = 1
         call iprint (iprt)
         write (iprt, 1000)
         return
      end if
!
!     SET SIZE OF WORK AREA.
!
      call stkset (ldstak, 4)
!
!     SAVE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
!
      nall0 = stkst(1)
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      lspc = nf
      lpcv = 2*nf + 5
      lphi = lagmax
      lwork = lagmax+1
!
      fmn = max(fmin, 0.0e0)
      fmx = min(fmax, 0.5e0)
      if (fmn.ge.fmx) then
        fmn = 0.0e0
        fmx = 0.5e0
      end if
!
      alpha = 0.95e0
      delta = 1.0e0
!
      if (iar.ge.1) then
!
!     USER HAS CHOSEN ORDER AND SUPPLIED COEFFICIENTS.
!     COMPUTE RESIDUAL VARIANCE.
!
         call amean (y, n, ymean)
         call uasvar (y, ymean, n, iar, phi, var)
      end if
!
!     SET UP ADDITIONAL STACK WORK AREA, IF NEEDED.
!
      work = stkget(lwork,ifp)
      if (iar.eq.0) then
         laic = lagmax+1
         aic = stkget(laic, ifp)
         ftest = stkget(2*lagmax, ifp)
      else
         laic = lwork
         aic = work
         ftest = work
      end if
      if (nprt.eq.0) then
         xaxis = work
         yaxis = work
         isym = work
         isort = work
      else
         xaxis = stkget(lpcv, ifp)
         yaxis = stkget(lpcv, ifp)
         isym = stkget(lpcv, 2)
         isort = isym
      end if
!
      if (ierr.eq.1) go to 5
!
!     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
!
     call uasdv(acov, spca, spcf, lspc, iar, phi, nf, fmn,&
    &   fmx, freq, n, lagmax, rstak(ftest), rstak(aic), rstak(work),&
    &   lacov, lwork, delta, istak(isort), istak(isym), rstak(xaxis),&
    &   rstak(yaxis), lpcv, alpha, lag, laic, lphi, nprt, var, parzen,&
     &   nmsub)
!
      call stkclr(nall0)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &  '       CALL UASVS (ACOV, LAGMAX, Y, N,'/&
    &  '      +            IAR, PHI, LAG, NF, FMIN, FMAX, NPRT,'/&
     &  '      +            SPCA, SPCF, FREQ, LDSTAK)')
      end
!ACFMN
     subroutine acfmn(y, n, lagmax, rho, sdrho, ymean, prho, aic,&
    &   ftest, phi, iar, ospvar, acov, lacov, laic, chia, chiap, work,&
     &   nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING AUTOCORRELATIONS AND
!     PARTIAL AUTOCORRELATIONS OF A TIME SERIES .
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   chia,chiap,ospvar,ymean
     integer&
     &   iar,lacov,lagmax,laic,n,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   acov(*),aic(*),ftest(2,*),phi(*),prho(*),rho(*),sdrho(*),&
     &   work(*),y(*)
!
!  LOCAL SCALARS
     integer&
     &   i
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL ACFSD,ACVF,AOS,CHIRHO
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV)
!        THE AUTOCOVARIANCE FUNCTION ESTIMATE VECTOR.
!     REAL AIC(LAIC)
!        THE ARRAY CONTAINING AKAIAES CRITERION FOR EACH ORDER.
!     REAL CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     REAL FTEST(2, LAGMAX)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     REAL OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED ORDER (IAR).
!     REAL PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER (IAR).
!     REAL PRHO(LAGMAX)
!        THE ARRAY IN WHICH THE PARTIAL AUTOCORRELATIONS ARE STORED
!     REAL RHO(LAGMAX)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
!     REAL SDRHO(LAGMAX)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!     REAL WORK(LAGMAX)
!        AN ARRAY USED IN THE COMPUTATIONS OF THE PARTIAL
!        AUTOCORRELATIONS COEFFICIENTS.
!        ARE STORED
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!     COMPUTE AUTOCOVARIANCESS AND STANDARD DEVIATION OF THE SERIES.
!
      call acvf(y, n, ymean, acov, lagmax, lacov)
!
      if (acov(1) .eq. 0.0e0) return
!
!     COMPUTE PARTIAL AUTOCORRELATIONS AND THE AUTOREGRESSIVE MODEL
!     ORDER SELECTION STATISTICS.
!
     call aos (n, lagmax, acov, prho, iar, ospvar, phi, work,&
     &   aic, ftest, lacov, laic)
!
      if (nprt .eq. 0) return
!
!     COMPUTE AUTOCORRELATIONS
!
      do 10 i = 1, lagmax
         rho(i) = acov(i+1) / acov(1)
   10 continue
!
!     COMPUTE STANDARD ERROR OF AUTOCORRELATIONS.
!
      call acfsd (rho, sdrho, lagmax, n)
!
!     COMPUTE CHI STATISTIC BASED ON AUTOCORRELATION VALUES
!
      call chirho (rho, n, lagmax, chia, chiap)
!
      return
      end
!ERVII
     subroutine ervii (nmsub, nmvar, y, n, ylb, yub, nvmx,&
     &   head, msgtyp, nv, error)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS FOR VALUES IN THE INPUT VECTOR   Y
!     WHICH ARE OUTSIDE THE (INCLUSIVE) LIMITS YLB TO YUB, PRINTS
!     AN ERROR MESSAGE IF THE NUMBER OF VIOLATIONS EXCEEDS THE LARGEST
!     NUMBER OF VIOLATIONS ALLOWED, AND RETURNS THE NUMBER OF
!     VIOLATIONS AND AN ERROR FLAG INDICATING THE RESULTS.  THREE
!     MESSAGES ARE AVAILABLE, SPECIFIED BY    MSGTYP   .
!        IF (MSGTYP = 0) NO VIOLATIONS ARE ALLOWED.
!        IF (MSGTYP = 1) THE NUMBER OF VIOLATIONS MUST
!                        BE LESS THAN   NVMX   .
!        IF (MSGTYP = 2) VIOLATIONS ARE COUNTED ONLY IF THE
!                        THE FIRST ELEMENT IS NOT IN VIOLATION.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ylb,yub
     integer&
     &   msgtyp,n,nv,nvmx
     logical&
     &   error,head
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*)
     character&
     &   nmsub(6)*1,nmvar(8)*1
!
!  LOCAL SCALARS
     integer&
     &   i,iprt,nnv,nnvmn
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        THE VALUE RETURNED FROM THE ERROR CHECKING ROUTINES TO INDICATE
!        WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED (TRUE)
!        OR NOT (FALSE).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        THE INDICATOR VARIABLE FOR THE TYPE OF MESSAGE.
!        IF (MSGTYP = 0) NO VIOLATIONS ARE ALLOWED.
!        IF (MSGTYP = 1) THE NUMBER OF VIOLATIONS MUST
!                        BE LESS THAN   NVMX   .
!        IF (MSGTYP = 2) VIOLATIONS ARE COUNTED ONLY IF THE
!                        THE FIRST ELEMENT IS NOT IN VIOLATION.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE PARAMETERS NAME.
!     INTEGER NNV
!        THE NUMBER OF VALUES NOT IN VIOLATION.
!     INTEGER NNVMN
!        THE SMALLEST NUMBER OF VALUES NOT IN VIOLATION ALLOWED.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND.
!     INTEGER NVMX
!        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
!     REAL Y(N)
!        THE VECTOR BEING TESTED.
!     REAL YLB, YUB
!        THE (INCLUSIVE) RANGE THAT THE VECTOR IS BEING TESTED
!        AGAINST.
!
      error = .false.
!
      if (n .le. 0) return
!
!     TEST WHETHER TESTING IS NECESSRY
!
     if ((msgtyp .eq. 2) .and.&
     &    (y(1) .lt. ylb) .or. (y(1) .gt. yub)) return
!
!     CHECK FOR VIOLATIONS
!
      nv = 0
      do 10 i = 1, n
         if ((y(i).lt.ylb) .or. (y(i).gt.yub)) nv = nv + 1
   10 continue
!
      if (nv .le. nvmx) return
!
!     VIOLATIONS FOUND
!
      error = .true.
      call iprint(iprt)
!
      call ehdr(nmsub, head)
!
      nnv = n - nv
      nnvmn = n - nvmx
!
     if (msgtyp .eq. 0)&
     &   write(iprt, 1010) (nmvar(i), i = 1, 6), ylb, yub, nv
     if (msgtyp .eq. 1)&
    &   write(iprt, 1020) (nmvar(i), i = 1, 6), ylb, yub,&
     &   nnvmn, nnv
     if (msgtyp .eq. 2)&
     &   write(iprt, 1030) (nmvar(i), i = 1, 6), ylb, yub
!
      return
!
!     FORMAT STATEMENTS
!
1010 format(/&
    &   26h the values in the vector , 6a1,&
    &   26h must all be in the range , 1pe14.7, 3h to/&
    &   1x, 1pe14.7,&
    &      52h, inclusive. the number of values outside this range,&
     &   4h is , i5, '.')
1020 format(/&
    &   36h the number of values in the vector , 6a1,&
    &   14h in the range , 1pe14.7, 3h to/&
    &   1x, 1pe14.7, 34h, inclusive, must equal or exceed , i5, '.'/&
     &   ' THE NUMBER OF VALUES IN THIS RANGE IS ', i5, '.')
1030 format(/&
    &   34h if the first value of the vector , 6a1,&
    &   16h is in the range, 1pe14.7, 3h to/&
    &   1x, 1pe14.7,&
     &      52h inclusive, all of the values must be in this range.)
!
      end
!FLTARM
      subroutine fltarm (y, ymiss, n, iar, phi, yf, yfmiss, nyf)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE FILTERS THE INPUT SERIES Y, WHICH CONTAINS MISSING
!     DATA, USING THE IAR TERMS OF THE AUTOREGRESSIVE FILTER PHI,
!     COPYING THE FILTERED SERIES INTO YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: yfmiss,ymiss
     integer&
     &   iar,n,nyf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   phi(*),y(*),yf(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm,temp
     integer&
     &   i,i1,j,k
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
     logical&
     &   mvchk
!       EXTERNAL R1MACH,MVCHK
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IAR
!        THE NUMBER OF FILTER TERMS.
!     INTEGER I1, J, K
!        INDEXING VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     REAL PHI(IAR)
!        THE ARRAY IN WHICH THE FILTER COEFFICIENTS ARE STORED.
!     REAL TEMP
!        A TEMPORARY STORAGE LOCATION.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!     REAL YFMISS
!        THE MISSING VALUE CODE USED IN THE FILTERED SERIES TO
!        INDICATE THE VALUE COULD NOT BE COMPUTED DUE TO MISSING DATA.
!     REAL YMISS
!        THE MISSING VALUE CODE USED IN THE INPUT SERIES TO INDICATE
!        AN OBSERVATION IS MISSING.
!
      fplm = r1mach(2)
!
      yfmiss = fplm
!
      do 10 i = 1, n
         yf(i) = y(i)
   10 continue
!
      nyf = n - iar
!
      do 50 i = 1, nyf
         temp = yfmiss
         k = i + iar
         if (mvchk(yf(k), ymiss)) go to 40
         temp = yf(k)
         do 30 j = 1, iar
            k = k - 1
            if (.not. mvchk(yf(k), ymiss)) go to 20
            temp = yfmiss
            go to 40
   20       continue
            temp = temp - phi(j) * yf(k)
   30    continue
   40    yf(i) = temp
   50 continue
!
      i1 = nyf + 1
!
      do 60 i = i1, n
         yf(i) = 0.0e0
   60 continue
      return
      end
!RELCOM
      subroutine relcom(n, v, w, reltol, abstol, nfail, ifail)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES THE NUMBER OF TIMES THE
!     RELATIVE DIFFERENCE BETWEEN V(I) AND W(I), I = 1, 2, ..., N,
!     IS GREATER THAN   RELTOL  .
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   abstol,reltol
     integer&
     &   n,nfail
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   v(n),w(n)
     integer&
     &   ifail(n)
!
!  LOCAL SCALARS
     integer&
     &   i
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ABSTOL
!        THE ABSOLUTE TOLERANCE USED IN THE COMPARISON.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IFAIL(N)
!        AN INDICATOR VARIABLE DESIGNATING WHETHER OR NOT THE COMPARISON
!        FAILED OR NOT, WHERE 0 INDICATES NOT FAILURE AND 1 INDICATES
!        FALURE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAIL
!        THE TOTAL NUMBER OF FAILURES.
!     REAL RELTOL
!        THE RELATIVE TOLERANCE USED IN THE COMPARISON.
!     REAL V(N), W(N)
!        THE VALUES BEING COMPARED.
!
      nfail = 0
!
      do 30 i = 1, n
        if ((abs(v(i)-w(i)).le.reltol*max(abs(v(i)),abs(w(i)))) .or.&
    &       (((v(i).eq.0.0e0).or.(w(i).eq.0.0e0)).and.&
     &        (abs(v(i)-w(i)).le.abstol))) then
            ifail(i) = 0
         else
            ifail(i) = 1
            nfail = nfail + 1
         end if
   30 continue
!
      return
!
      end
!CCFFS
     subroutine ccffs (ymfft, n, m, iymfft, lagmax,&
     &   ccov, iccov, jccov, nprt, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
!     CORRELATIONS AND COVARIANCES OF A MULTIVARIATE SERIES USING THE
!     SINGLETON FFT (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iccov,iymfft,jccov,lagmax,ldstak,m,n,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ccov(*),ymfft(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
    &   i,ifp,inlppc,io,iprt,iym,j,jnlppc,k,ldsmin,lyfft,nall0,&
     &   nfft,rhoc,sdrhoc,work,ymean,ymeanj,ymeank,ysd,ysdj,ysdk
     logical&
     &   isfft,islong,newpg
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   ndum(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACVFF,CCFER,CCFMNF,CCFOUT,FFTLEN,IPRINT,LDSCMP,STKCLR,
!     +   STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  STATEMENT FUNCTIONS
     integer&
     &   i2,i3
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCOV(ICCOV, JCCOV, M)
!        THE CROSS COVARIANCE MATRIX.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ICCOV
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INLPPC
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
!        IN THE USERS PROGRAM.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON WHETHER PRINTED OUTPUT IS DESIRED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     LOGICAL ISLONG
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
!     INTEGER IYM
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YM AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IYMFFT
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER I2
!        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN YMFFT
!     INTEGER I3
!        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN CCOV
!     INTEGER J
!        THE INDEX OF -SERIES 1- IN THE ARRAY YMFFT.
!     INTEGER JCCOV
!        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
!        IN THE USERS PROGRAM.
!     INTEGER K
!        THE INDEX OF -SERIES 2- IN THE ARRAY YMFFT.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE NUMBER OF LOCATIONS IN EACH COLUMN OF YMFFT ALLOWED FOR
!        THE EXTENDED SERIES.
!     INTEGER M
!        THE NUMBER OF SERIES BEING COMPARED, IE THE
!        NUMBER OF COLUMNS OF DATA IN YMFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     INTEGER NDUM(1)
!        A DUMMY DMENSIONED ARRAY.
!     LOGICAL NEWPG
!        AN INDICATOR VARIABLE USED TO DETERMINE WHEN A NEW PAGE
!        IS APPROPRIATE FOR THE OUTPUT.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPEDIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS GIVEN.
!     INTEGER RHOC
!        THE STARTING LOCATION IN STAK/DSTAK OF THE ARRAY RHOC.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SDRHOC
!        THE STARTING LOCATION IN THE WORK AREA FOR SDRHOC.
!     INTEGER WORK
!        THE STARGING LOCATION IN DSTAK OF
!        THE WORK VECTOR NEEDED BY THE FFT.
!     INTEGER YMEAN, YMEANJ, YMEANK
!        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
!        MEANS OF EACH OF THE SERIES, AND THE LOCATION IN
!        THE ARRAY FOR THE MEAN OF THE JTH AND KTH SERIES,
!        RESPECTIVELY.
!     REAL YMFFT(IYMFFT, M)
!        THE MATRIX CONTAINING THE OBSERVED TIME SERIES
!     INTEGER YSD, YSDJ, YSDK
!        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
!        STANDARD DEVIATIONS OF EACH OF THE SERIES, AND THE
!        LOCATION IN THE ARRAY FOR THE STANDARD DEVIATION OF
!        THE JTH AND KTH SERIES, RESPECTIVELY.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'C',       'C',       'F',       'F',       'S',       ' '/
!
      i2(i,j) = i + (j-1)*iymfft
      i3(i,j,k) = i + (j-1)*iccov + (k-1)*jccov*iccov
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      inlppc = iccov
      iym = iymfft
      jnlppc = jccov
      lyfft = iymfft
      m = 2
      isfft = .true.
      islong = .true.
!
      io = 1
      if (nprt .eq. 0) io = 0
!
!     SET LENGTH OF EXTENDED SERIES
!
      if ((n.ge.3) .and. (lagmax.ge.1)) then
         call fftlen (n+lagmax, 4, nfft)
      else
         nfft = n
      end if
!
     call ldscmp(3+2*io, 0, 0, 0, 0, 0, 'S',&
     &            2*m+nfft+io*(4*lagmax+2), ldsmin)
!
     call ccfer(nmsub, n, lagmax, ldstak, ldsmin, iccov, jccov,&
     &  inlppc, jnlppc, m, lyfft, nfft, iym, iymfft, isfft, islong)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      if (ierr.eq.0) then
!
!       SET UP THE WORK AREA.
!
        call stkset (ldstak, 4)
        nall0 = stkst(1)
!
        ifp = 3
!
        ymean = stkget(m, ifp)
        ysd = stkget(m, ifp)
        if (nprt.eq.0) then
          rhoc = ysd
          sdrhoc = ysd
        else
          rhoc = stkget(2*lagmax+1, ifp)
          sdrhoc = stkget(2*lagmax+1, ifp)
        end if
        work = stkget(nfft, ifp)
!
        if (ierr.eq.0) then
!
!         BEGIN LOOP FOR COMPUTATIONS
!
          newpg = .false.
!
          do 40 k = 1, m
!
             ymeank = ymean + k - 1
             ysdk = ysd + k - 1
!
            call acvff (ymfft(i2(1,k)), n, nfft, rstak(ymeank),&
    &                   ccov(i3(1,k,k)), lagmax, iccov, lyfft,&
     &                   rstak(work), nfft)
             rstak(ysdk) = sqrt(ccov(i3(1,k,k)) * n / (n - 1))
!
             if ((k-1).le.0) go to 40
!
             do 30 j = 1, (k-1)
!
                ymeanj = ymean + j - 1
                ysdj = ysd + j - 1
!
               call ccfmnf(ymfft(i2(1,j)), ymfft(i2(1,k)),&
    &                      n, nfft, lagmax, 2*lagmax+1,&
    &                      ccov(i3(1,j,j)), ccov(i3(1,k,k)),&
    &                      ccov(i3(1,j,k)), ccov(i3(1,k,j)),&
    &                      iccov, rstak(rhoc), rstak(sdrhoc), nprt,&
     &                      lyfft, rstak(work), nfft)
!
                if (nprt .eq. 0) go to 30
!
!         CALL ROUTINE TO PRINT OUT CORRELATIONS
!
               call ccfout (j, rstak(ymeanj), rstak(ysdj), n, n, k,&
    &             rstak(ymeank), rstak(ysdk), n, n, lagmax, 2*lagmax+1,&
    &             rstak(rhoc), rstak(sdrhoc), .false., ndum, ndum, 1,&
     &             0.0e0, 0.0e0, newpg)
!
                newpg = .true.
!
   30        continue
   40     continue
        end if
!
        call stkclr(nall0)
      end if
!
      if (ierr.ne.0) then
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        ierr = 1
        call iprint (iprt)
        write (iprt, 1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format(/42h the correct form of the call statement is//&
    & '       CALL CCFFS (YMFFT, N, M, IYMFFT,'/&
     & '      +            LAGMAX, CCOV, ICCOV, JCCOV, NPRT, LDSTAK)')
      end
!CCVFF
     subroutine ccvff (yfft1, yfft2, n, nfft, lagmax, ccov12, ccov21,&
     &   iccov, lyfft, work, lwork)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE CROSS COVARIANCE FUNCTION
!     BETWEEN TWO SERIES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iccov,lagmax,lwork,lyfft,n,nfft
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   ccov12(iccov),ccov21(iccov),work(lwork),yfft1(lyfft),&
     &   yfft2(lyfft)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fac
     integer&
     &   i,isn,j,lag,nf,nf2,nfft2
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL FFT,REALTR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCOV12(ICCOV), CCOV21(ICCOV)
!        THE ARRAYS IN WHICH THE CCVF FOR SERIES 1 LAGGED
!        BEHIND SERIES 2 AND VISA VERSA, RESPECTIVELY, ARE STORED.
!     REAL FAC
!        THE APPROPRIATE FACTOR USED TO SCALE THE CCVF.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER ICCOV
!        THE DIMENSION OF THE ARRAYS CCOV12 AND CCOV21.
!     INTEGER LAG, LAGMAX
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        CROSS CORRELATION BEING COMPUTED, AND THE MAXIMUM LAG
!        VALUE TO BE USED.
!     INTEGER LWORK
!        THE DIMENSION OF THE VECTOR WORK.
!     INTEGER LYFFT
!        THE ACTUAL LENGTH OF THE ARRAYS YFFT1 AND YFFT2.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NF
!        THE NUMBER OF FOURIER FREQUENCIES.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NFFT2
!        THE EFFECTIVE NUMBER OF OBSERVATIONS FOR THE FFT TRANSFORM.
!     INTEGER NF2
!        TWICE THE NUMBER OF FOURIER FREQUENCIES.
!     REAL WORK(LWORK)
!        THE WORK ARRAY NEEDED FOR THE COMPUTATIONS.
!     REAL YFFT1(LYFFT), YFFT2(LYFFT)
!        THE VECTORS CONTAINING THE OBSERVED SERIES ALREADY PROCESSED
!        BY ONE PASS OF A FFT.
!
      nfft2 = (nfft-2) / 2
      nf = nfft2 + 1
      nf2 = nf * 2
!
!     COMPUTE THE CROSS COVARIANCES
!
      do 10 i = 2, nf2, 2
         work(i-1) = yfft1(i-1)*yfft2(i-1) + yfft1(i)*yfft2(i)
         work(i) = yfft1(i)*yfft2(i-1) - yfft1(i-1)*yfft2(i)
   10 continue
!
      fac = 1.0e0 / (4 * (nfft-2) * n)
!
      isn = -2
!
      call realtr (work, work(2), nfft2, isn)
!
      call fft (work, work(2), nfft2, nfft2, nfft2, isn)
!
      ccov12(1) = work(1) * fac
      ccov21(1) = ccov12(1)
!
      do 20 lag = 1, lagmax
         ccov21(lag+1) = work(lag+1) * fac
!
         j = nfft - 1 - lag
         ccov12(lag+1) = work(j) * fac
   20 continue
!
      return
      end
!XBFS
      subroutine xbfs(lds,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE FOURIER SPECTRUM ANALYSIS ROUTINES
!
!     SERIES Y1 AND Y2 ARE LISTED AS SERIES X1 AND X2 ON PAGE OF 361 OF
!     JENKINS AND WATTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lds
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
      real(kind=wp) :: cmiss,fmax,fmin,ymiss,ymiss1,ymiss2
     integer&
    &   i,iccov,icspc2,index1,index2,inlppc,iphas,iprt,ispcf,j,&
     &   jccov,jnlppc,lacov,lagmax,ldstak,lyfft,n,nf,nprt,nw
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   ccov(101,2,2),cspc2(300,2),freq(300),phas(300,2),y1(150),&
     &   y2(150),yfft1(400),yfft2(400),ym(150,2),ymmiss(4)
     integer&
     &   lags(4),nlppc(101,2,2)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL BFS,BFSF,BFSFS,BFSM,BFSMS,BFSMV,BFSMVS,BFSS,BFSV,BFSVS,
!     +   CCFMS,CCFS,IPRINT,NRAND,SETIV,SETRV
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (ym(1,1),y1(1))
      equivalence (ym(1,2),y2(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CMISS
!         THE MISSING VALUE CODE FOR THE RETURNED CCVF ESTIMATES.
!     REAL CCOV(101,2,2)
!        THE COVARIANCES.
!     REAL CSPC2(300,2)
!        THE SQUARED COHERENCY COMPONENT OF THE SPECTRUM.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCIES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(300)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISPCF
!         THE ACTUAL DIMENSION FOR THE SPECTRUM ARRAYS.
!     INTEGER J
!        INDEX VARIABLE.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCOVARIANCE BEING COMPUTED AND THE MAXIMUM LAG TO BE USED,
!        RESPECTIVELY.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDS, LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTORS YFFT AND ZFFT, RESPECTIVELY..
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC(101,2,2)
!        THE NUMBERS OF LAGGED PRODUCT PAIRS USED FOR EACH ACVF.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE NUMBER OF DIFFERENT LAG WINDOW TRUNCATION POINTS SPECIFIED,
!        AND THEREFORE, THE NUMBER OF PLOTS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     REAL PHAS(300,2)
!        THE PHASE COMPONENT OF THE SPECTRUM.
!     REAL YFFT1(400), YFFT2(400)
!        THE VECTORS OF THE OBSERVED TIME SERIES TO BE ANALYZED USING
!        THE FFT.
!     REAL YMISS, YMISS1, YMISS2, YMMISS(4)
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!     REAL YM(150,2)
!        THE MULTIVARIATE REPRESENTATION OF THE DATA
!     REAL Y1(150), Y2(150)
!         THE VECTORS CONTAINING THE TIME SERIES FROM JENKINS AND WATTS.
!
     data   y1(  1),  y1(  2),  y1(  3),  y1(  4),  y1(  5),  y1(  6)&
     &    /-0.88_wp, -0.16_wp, -1.87_wp, -1.12_wp,  1.38_wp,  2.13_wp/
     data   y1(  7),  y1(  8),  y1(  9),  y1( 10),  y1( 11),  y1( 12)&
     &    / 2.76_wp,  0.56_wp, -0.69_wp, -1.79_wp, -3.82_wp, -2.38_wp/
     data   y1( 13),  y1( 14),  y1( 15),  y1( 16),  y1( 17),  y1( 18)&
     &    / 1.00_wp,  0.70_wp, -0.15_wp,  0.98_wp,  0.11_wp, -0.35_wp/
     data   y1( 19),  y1( 20),  y1( 21),  y1( 22),  y1( 23),  y1( 24)&
     &    /-0.73_wp,  0.89_wp, -1.63_wp, -0.44_wp, -1.37_wp, -1.71_wp/
     data   y1( 25),  y1( 26),  y1( 27),  y1( 28),  y1( 29),  y1( 30)&
     &    /-1.22_wp, -2.00_wp, -0.22_wp,  0.38_wp,  1.31_wp,  0.71_wp/
     data   y1( 31),  y1( 32),  y1( 33),  y1( 34),  y1( 35),  y1( 36)&
     &    / 0.32_wp,  0.48_wp, -1.88_wp, -0.94_wp, -1.54_wp, -0.13_wp/
     data   y1( 37),  y1( 38),  y1( 39),  y1( 40),  y1( 41),  y1( 42)&
     &    / 1.02_wp,  0.02_wp, -0.77_wp,  0.11_wp, -0.60_wp, -0.52_wp/
     data   y1( 43),  y1( 44),  y1( 45),  y1( 46),  y1( 47),  y1( 48)&
     &    /-0.09_wp,  1.23_wp,  1.46_wp,  0.61_wp,  0.42_wp,  2.16_wp/
     data   y1( 49),  y1( 50),  y1( 51),  y1( 52),  y1( 53),  y1( 54)&
     &    / 3.18_wp,  2.10_wp,  0.37_wp, -0.24_wp,  0.57_wp, -0.53_wp/
     data   y1( 55),  y1( 56),  y1( 57),  y1( 58),  y1( 59),  y1( 60)&
     &    / 2.44_wp,  1.02_wp, -0.53_wp, -2.49_wp, -2.12_wp, -1.04_wp/
     data   y1( 61),  y1( 62),  y1( 63),  y1( 64),  y1( 65),  y1( 66)&
     &    /-0.12_wp, -1.88_wp, -1.50_wp,  1.54_wp,  3.33_wp,  3.08_wp/
     data   y1( 67),  y1( 68),  y1( 69),  y1( 70),  y1( 71),  y1( 72)&
     &    / 1.71_wp,  0.79_wp,  1.55_wp,  0.89_wp, -0.89_wp, -1.18_wp/
     data   y1( 73),  y1( 74),  y1( 75),  y1( 76),  y1( 77),  y1( 78)&
     &    / 0.89_wp,  1.71_wp,  3.05_wp,  0.15_wp, -1.04_wp,  0.12_wp/
     data   y1( 79),  y1( 80),  y1( 81),  y1( 82),  y1( 83),  y1( 84)&
     &    / 0.08_wp,  0.11_wp, -2.62_wp, -1.28_wp,  1.07_wp,  3.20_wp/
     data   y1( 85),  y1( 86),  y1( 87),  y1( 88),  y1( 89),  y1( 90)&
     &    / 1.92_wp,  0.53_wp, -1.08_wp,  0.49_wp, -0.58_wp,  0.17_wp/
     data   y1( 91),  y1( 92),  y1( 93),  y1( 94),  y1( 95),  y1( 96)&
     &    / 1.15_wp, -0.97_wp, -1.63_wp,  1.14_wp, -0.67_wp, -0.88_wp/
     data   y1( 97),  y1( 98),  y1( 99),  y1(100)&
     &    /-0.07_wp,  0.24_wp,  0.55_wp, -2.16_wp/
     data   y2(  1),  y2(  2),  y2(  3),  y2(  4),  y2(  5),  y2(  6)&
     &    / 0.79_wp,  1.12_wp, -1.10_wp, -2.39_wp, -1.75_wp, -0.82_wp/
     data   y2(  7),  y2(  8),  y2(  9),  y2( 10),  y2( 11),  y2( 12)&
     &    /-0.36_wp,  1.27_wp,  1.75_wp,  2.44_wp,  0.36_wp, -2.10_wp/
     data   y2( 13),  y2( 14),  y2( 15),  y2( 16),  y2( 17),  y2( 18)&
     &    /-1.93_wp, -1.30_wp, -1.75_wp, -0.34_wp,  0.74_wp,  0.49_wp/
     data   y2( 19),  y2( 20),  y2( 21),  y2( 22),  y2( 23),  y2( 24)&
     &    / 0.70_wp,  0.71_wp,  0.09_wp,  0.59_wp,  1.54_wp,  0.14_wp/
     data   y2( 25),  y2( 26),  y2( 27),  y2( 28),  y2( 29),  y2( 30)&
     &    / 0.55_wp, -1.40_wp, -2.55_wp, -1.66_wp, -0.43_wp,  0.58_wp/
     data   y2( 31),  y2( 32),  y2( 33),  y2( 34),  y2( 35),  y2( 36)&
     &    / 2.18_wp, -0.24_wp,  0.58_wp, -0.18_wp, -1.55_wp, -0.64_wp/
     data   y2( 37),  y2( 38),  y2( 39),  y2( 40),  y2( 41),  y2( 42)&
     &    /-1.09_wp,  0.90_wp, -0.66_wp, -0.35_wp,  0.48_wp,  0.50_wp/
     data   y2( 43),  y2( 44),  y2( 45),  y2( 46),  y2( 47),  y2( 48)&
     &    / 0.05_wp, -0.68_wp,  0.24_wp,  0.58_wp, -1.26_wp, -0.25_wp/
     data   y2( 49),  y2( 50),  y2( 51),  y2( 52),  y2( 53),  y2( 54)&
     &    / 0.25_wp,  2.18_wp,  2.96_wp,  1.56_wp, -0.36_wp, -0.59_wp/
     data   y2( 55),  y2( 56),  y2( 57),  y2( 58),  y2( 59),  y2( 60)&
     &    /-0.12_wp,  3.03_wp,  2.11_wp,  0.78_wp,  0.89_wp, -1.45_wp/
     data   y2( 61),  y2( 62),  y2( 63),  y2( 64),  y2( 65),  y2( 66)&
     &    /-0.36_wp, -0.37_wp, -1.39_wp, -4.19_wp, -0.73_wp, -0.98_wp/
     data   y2( 67),  y2( 68),  y2( 69),  y2( 70),  y2( 71),  y2( 72)&
     &    / 0.36_wp,  0.06_wp, -1.94_wp, -0.08_wp,  0.17_wp,  1.00_wp/
     data   y2( 73),  y2( 74),  y2( 75),  y2( 76),  y2( 77),  y2( 78)&
     &    /-0.05_wp,  0.43_wp,  0.15_wp,  2.69_wp,  0.57_wp,  0.29_wp/
     data   y2( 79),  y2( 80),  y2( 81),  y2( 82),  y2( 83),  y2( 84)&
     &    / 1.10_wp,  0.48_wp, -1.06_wp, -2.28_wp, -2.03_wp, -0.75_wp/
     data   y2( 85),  y2( 86),  y2( 87),  y2( 88),  y2( 89),  y2( 90)&
     &    / 1.00_wp,  1.71_wp,  0.58_wp,  1.97_wp,  0.99_wp,  1.94_wp/
     data   y2( 91),  y2( 92),  y2( 93),  y2( 94),  y2( 95),  y2( 96)&
     &    / 2.18_wp,  3.14_wp,  0.60_wp,  0.51_wp,  1.35_wp,  0.56_wp/
     data   y2( 97),  y2( 98),  y2( 99),  y2(100)&
     &    / 0.11_wp,  0.00_wp,  2.34_wp,  1.88_wp/
!
!
      call iprint(iprt)
      call setrv(ymmiss, 4, 0.89_wp)
!
!     CHECK ERROR HANDLING
!
!        TEST 1  -  MISCELANEOUS ERROR CHECKING
!
      write (iprt, 2000)
      lagmax = -1
      n = -10
      index1 = 0
      index2 = 0
      iccov = 0
      jccov = 0
      inlppc = 0
      jnlppc = 0
      icspc2 = -10
      iphas = -10
      lacov = -11
      lyfft = -11
      nw = -1
      nf = -5
      fmin = 0.5_wp
      fmax = 0.0_wp
      nprt = -1
      ispcf = -20
      ldstak = 0
      ymiss1 = 0.89_wp
      ymiss2 = 0.89_wp
!
      write(iprt, 1001)
      call bfs (y1, y2, n)
      write (iprt, 1002) ierr
!
      write(iprt, 1003)
     call bfss(y1, y2, n, nw, lags, nf, fmin, fmax, nprt,&
     &   cspc2, icspc2, phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
      write(iprt, 1019)
      call bfsf (yfft1, yfft2, n, lyfft, ldstak)
      write (iprt, 1002) ierr
!
      write(iprt, 1020)
     call bfsfs(yfft1, yfft2, n, lyfft, ldstak, nw, lags, nf, fmin,&
     &   fmax, nprt, cspc2, icspc2, phas, iphas, freq)
      write (iprt, 1002) ierr
!
      write(iprt, 1005)
      call bfsm (y1, ymiss1, y2, ymiss2, n)
      write (iprt, 1002) ierr
!
      write(iprt, 1006)
     call bfsms(y1, ymiss1, y2, ymiss2, n, nw, lags, nf, fmin,&
     &   fmax, nprt, cspc2, icspc2, phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
      write (iprt, 1007)
      call bfsv(ccov, index1, index2, n, lagmax, iccov, jccov)
      write (iprt, 1002) ierr
!
      write (iprt, 1008)
     call bfsvs (ccov, index1, index2, n, iccov, jccov,&
    &   nw, lags, nf, fmin, fmax, nprt, cspc2, icspc2, phas, iphas,&
     &   freq, ldstak)
      write (iprt, 1002) ierr
!
      write (iprt, 1021)
     call bfsmv(ccov, nlppc, index1, index2, n, lagmax, iccov, jccov,&
     &   inlppc, jnlppc)
      write (iprt, 1002) ierr
!
      write (iprt, 1022)
     call bfsmvs (ccov, nlppc, index1, index2, n, iccov, jccov,&
    &   inlppc, jnlppc, nw, lags, nf, fmin, fmax, nprt, cspc2, icspc2,&
     &   phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
!        TEST 2  -  MISCELANEOUS ERROR CHECKING (CONTINUED)
!
      write (iprt, 2010)
      n = 100
      lagmax = 40
      index1 = 0
      index2 = 0
      iccov = 0
      jccov = 0
      inlppc = 0
      jnlppc = 0
      icspc2 = 300
      iphas = 300
      lacov = 101
      lyfft = -11
      nw = 2
      lags(1) = 0
      lags(2) = 100
      nf = 202
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 3
      ispcf = 101
      ldstak = 0
!
      write(iprt, 1003)
     call bfss(y1, y2, n, nw, lags, nf, fmin, fmax, nprt,&
     &   cspc2, icspc2, phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
      write(iprt, 1019)
      call bfsf (yfft1, yfft2, n, lyfft, ldstak)
      write (iprt, 1002) ierr
!
      write(iprt, 1020)
     call bfsfs(yfft1, yfft2, n, lyfft, ldstak, nw, lags, nf, fmin,&
     &   fmax, nprt, cspc2, icspc2, phas, iphas, freq)
      write (iprt, 1002) ierr
!
      write(iprt, 1006)
     call bfsms(y1, ymiss1, y2, ymiss2, n, nw, lags, nf, fmin,&
     &   fmax, nprt, cspc2, icspc2, phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
      write (iprt, 1008)
     call bfsvs (ccov, index1, index2, n, iccov, jccov,&
    &   nw, lags, nf, fmin, fmax, nprt, cspc2, icspc2, phas, iphas,&
     &   freq, ldstak)
      write (iprt, 1002) ierr
!
      write (iprt, 1022)
     call bfsmvs (ccov, nlppc, index1, index2, n, iccov, jccov,&
    &   inlppc, jnlppc, nw, lags, nf, fmin, fmax, nprt, cspc2, icspc2,&
     &   phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
!        TEST 3  -  LDSTAK TOO SMALL
!
      write (iprt, 2030)
      n = 100
      index1 = 2
      index2 = 1
      iccov = 101
      jccov = 2
      inlppc = 101
      jnlppc = 2
      icspc2 = 300
      iphas = 300
      lagmax = 99
      lacov = 101
      lyfft = 400
      nw = 2
      lags(1) = 8
      lags(2) = 16
      nf = 26
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 1
      ispcf = 101
      ldstak = 0
!
      write(iprt, 1003)
     call bfss(y1, y2, n, nw, lags, nf, fmin, fmax, nprt,&
     &   cspc2, icspc2, phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
      write(iprt, 1019)
      call bfsf (yfft1, yfft2, n, lyfft, ldstak)
      write (iprt, 1002) ierr
!
      write(iprt, 1020)
     call bfsfs(yfft1, yfft2, n, lyfft, ldstak, nw, lags, nf, fmin,&
     &   fmax, nprt, cspc2, icspc2, phas, iphas, freq)
      write (iprt, 1002) ierr
!
      write(iprt, 1006)
     call bfsms(y1, ymiss1, y2, ymiss2, n, nw, lags, nf, fmin,&
     &   fmax, nprt, cspc2, icspc2, phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
      write (iprt, 1008)
     call bfsvs (ccov, index1, index2, n, iccov, jccov,&
    &   nw, lags, nf, fmin, fmax, nprt, cspc2, icspc2, phas, iphas,&
     &   freq, ldstak)
      write (iprt, 1002) ierr
!
      write (iprt, 1022)
     call bfsmvs (ccov, nlppc, index1, index2, n, iccov, jccov,&
    &   inlppc, jnlppc, nw, lags, nf, fmin, fmax, nprt, cspc2, icspc2,&
     &   phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
!        TEST 4  -  ALL DATA AND COVARIANCES MISSING
!
      write (iprt, 2040)
      n = 100
      lagmax = 99
      icspc2 = 300
      iphas = 300
      lacov = 101
      lyfft = 400
      nw = 2
      lags(1) = 8
      lags(2) = 16
      nf = 26
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 1
      ispcf = 101
      ldstak = lds
      call setrv(yfft1, n, ymiss1)
      call setrv(yfft2, n, ymiss2)
      call setrv(ccov, 404, 0.0_wp)
      call setiv(nlppc, 404, 0)
!
      write(iprt, 1005)
      call bfsm (yfft1, ymiss1, yfft2, ymiss2, n)
      write (iprt, 1002) ierr
!
      write(iprt, 1006)
     call bfsms(yfft1, ymiss1, yfft2, ymiss2, n, nw, lags, nf, fmin,&
     &   fmax, nprt, cspc2, icspc2, phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
      write (iprt, 1021)
     call bfsmv(ccov, nlppc, index1, index2, n, lagmax, iccov, jccov,&
     &   inlppc, jnlppc)
      write (iprt, 1002) ierr
!
      write (iprt, 1022)
     call bfsmvs (ccov, nlppc, index1, index2, n, iccov, jccov,&
    &   inlppc, jnlppc, nw, lags, nf, fmin, fmax, nprt, cspc2, icspc2,&
     &   phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
!        TEST 5  -  EVERY OTHER VALUE MISSING
!
      write (iprt, 2050)
      n = 100
      lagmax = 99
      icspc2 = 300
      iphas = 300
      lacov = 101
      lyfft = 400
      nw = 2
      lags(1) = 8
      lags(2) = 16
      nf = 26
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 1
      ispcf = 101
      ldstak = lds
      call setrv(yfft1, n, ymiss1)
      call setrv(yfft2, n, ymiss2)
      do 10 i = 1, n, 2
         yfft1(i) = y1(i)
         yfft2(i) = y2(i)
   10 continue
!
      write(iprt, 1005)
      call bfsm (yfft1, ymiss1, yfft2, ymiss2, n)
      write (iprt, 1002) ierr
!
      write(iprt, 1006)
     call bfsms(yfft1, ymiss1, yfft2, ymiss2, n, nw, lags, nf, fmin,&
     &   fmax, nprt, cspc2, icspc2, phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
!     CHECK RESULTS FROM VALID CALL
!
      write(iprt, 2020)
      ymiss = 1.16_wp
      n = 100
      lagmax = 99
      icspc2 = 300
      iphas = 300
      lacov = 101
      lyfft = 400
      nw = 2
      lags(1) = 8
      lags(2) = 16
      nf = 26
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 1
      ispcf = 101
      ldstak = lds
!
!     TEST OF BFS
!
      write(iprt, 1001)
      call bfs (y1, y2, n)
      write (iprt, 1002) ierr
!
!     TEST OF BFSS
!
      write(iprt, 2020)
      write(iprt, 1003)
     call bfss(y1, y2, n, nw, lags, nf, fmin,&
     &   fmax, nprt, cspc2, icspc2, phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM BFSS
!
     write (iprt, 1004) (freq(i), (cspc2(i,j), phas(i,j),j=1,nw),&
     &   i=1,nf)
!
!     TEST OF BFSF
!
      write(iprt, 2020)
      write(iprt, 1019)
      call scopy(n, y1, 1, yfft1, 1)
      call scopy(n, y2, 1, yfft2, 1)
      call bfsf (yfft1, yfft2, n, lyfft, ldstak)
      write (iprt, 1002) ierr
!
!     TEST OF BFSFS
!
      write(iprt, 2020)
      write(iprt, 1020)
      call scopy(n, y1, 1, yfft1, 1)
      call scopy(n, y2, 1, yfft2, 1)
     call bfsfs(yfft1, yfft2, n, lyfft, ldstak, nw, lags, nf, fmin,&
     &   fmax, nprt, cspc2, icspc2, phas, iphas, freq)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM BFSFS
!
     write (iprt, 1004) (freq(i), (cspc2(i,j), phas(i,j),j=1,nw),&
     &   i=1,nf)
!
!     TEST OF BFSM
!
      write(iprt, 2020)
      write(iprt, 1005)
      call bfsm (y1, ymiss1, y2, ymiss2, n)
      write (iprt, 1002) ierr
!
!     TEST OF BFSMS
!
      write(iprt, 2020)
      write(iprt, 1006)
     call bfsms(y1, ymiss1, y2, ymiss2, n, nw, lags, nf, fmin,&
     &   fmax, nprt, cspc2, icspc2, phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM BFSMS
!
     write (iprt, 1004) (freq(i), (cspc2(i,j), phas(i,j),j=1,nw),&
     &   i=1,nf)
!
!     TEST OF BFSV
!
      write(iprt, 2020)
     call ccfs (ym, n, 2, 150, lagmax, ccov, iccov, jccov, 0,&
     &   ldstak)
      write (iprt, 1007)
      call bfsv(ccov, index1, index2, n, lagmax, iccov, jccov)
      write (iprt, 1002) ierr
!
!     TEST OF BFSVS
!
      write(iprt, 2020)
      write (iprt, 1008)
     call bfsvs(ccov, index1, index2, n, iccov, jccov, nw, lags, nf,&
     &   fmin, fmax, nprt, cspc2, icspc2, phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM BFSVS
!
     write (iprt, 1004) (freq(i), (cspc2(i,j), phas(i,j),j=1,nw),&
     &   i=1,nf)
!
!     TEST OF BFSMV
!
      write(iprt, 2020)
     call ccfms (ym, ymmiss, n, 2, 150, lagmax, ccov, cmiss, iccov,&
     &  jccov, nlppc, inlppc, jnlppc, 0, ldstak)
      write (iprt, 1021)
     call bfsmv(ccov, nlppc, index1, index2, n, lagmax, iccov,&
     &  jccov, inlppc, jnlppc)
      write (iprt, 1002) ierr
!
!     TEST OF BFSMVS
!
      write(iprt, 2020)
      write (iprt, 1022)
     call bfsmvs(ccov, nlppc, index1, index2, n, iccov,&
    &  jccov, inlppc, jnlppc, nw, lags, nf, fmin, fmax, nprt,&
     &  cspc2, icspc2, phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM BFSMVS
!
     write (iprt, 1004) (freq(i), (cspc2(i,j), phas(i,j),j=1,nw),&
     &   i=1,nf)
!
!     MINIMUM PROBLEM SIZE
!
      ymiss = 1.16_wp
      n = 17
      lagmax = 1
      icspc2 = 1
      iphas = 1
      lacov = 101
      lyfft = 400
      nw = 1
      lags(1) = 1
      lags(2) = 16
      nf = 1
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 1
      ispcf = 101
      ldstak = lds
!
!     TEST OF BFS
!
      write(iprt, 2060)
      write(iprt, 1001)
      call bfs(y1, y2, n)
      write (iprt, 1002) ierr
!
!     TEST OF BFSS
!
      write(iprt, 2060)
      write(iprt, 1003)
     call bfss(y1, y2, n, nw, lags, nf, fmin,&
     &   fmax, nprt, cspc2, icspc2, phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM BFSS
!
     write (iprt, 1004) (freq(i), (cspc2(i,j), phas(i,j),j=1,nw),&
     &   i=1,nf)
!
!     CHECK HANDLING OF FMIN AND FMAX
!
      ymiss = 1.16_wp
      n = 100
      lagmax = 99
      icspc2 = 300
      iphas = 300
      lacov = 101
      lyfft = 400
      nw = 2
      lags(1) = 8
      lags(2) = 16
      nf = 26
      fmin = 0.45_wp
      fmax = 0.5_wp
      nprt = 1
      ispcf = 101
      ldstak = lds
!
!     TEST OF BFSS
!
      write(iprt, 2070)
      write(iprt, 1003)
     call bfss(y1, y2, n, nw, lags, nf, fmin,&
     &   fmax, nprt, cspc2, icspc2, phas, iphas, freq, ldstak)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM BFSS
!
     write (iprt, 1004) (freq(i), (cspc2(i,j), phas(i,j),j=1,nw),&
     &   i=1,nf)
!
!     CHECK RESULTS FOR WHITE NOISE SPECTRUM
!
      ymiss = 1.16_wp
      call nrand(yfft1, n, 12343)
      call nrand(yfft2, n, 34523)
      n = 100
      lagmax = 99
      icspc2 = 300
      iphas = 300
      lacov = 101
      lyfft = 400
      nw = 2
      lags(1) = 8
      lags(2) = 16
      nf = 26
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 1
      ispcf = 101
      ldstak = lds
!
!     TEST OF BFSFS
!
      write(iprt, 2080)
      write(iprt, 1003)
     call bfsfs(yfft1, yfft2, n, lyfft, ldstak, nw, lags, nf, fmin,&
     &   fmax, nprt, cspc2, icspc2, phas, iphas, freq)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM BFSS
!
     write (iprt, 1004) (freq(i), (cspc2(i,j), phas(i,j),j=1,nw),&
     &   i=1,nf)
!
      return
!
!     FORMAT STATEMENTS
!
 1001 format (12h test of bfs)
 1002 format (8h ierr is, i5/)
 1003 format (13h test of bfss)
 1004 format (5(1x, e15.7))
 1005 format (13h test of bfsm)
 1006 format (14h test of bfsms)
 1007 format (13h test of bfsv)
 1008 format (14h test of bfsvs)
 1019 format (13h test of bfsf)
 1020 format (14h test of bfsfs)
 1021 format (14h test of bfsmv)
 1022 format (15h test of bfsmvs)
 2000 format (32h1check error handling  -  test 1)
 2010 format (32h1check error handling  -  test 2)
 2020 format (14h1valid problem)
 2030 format (14h1lds too small)
 2040 format (33h1all data and covariances missing)
 2050 format (31h1every other data value missing)
 2060 format (21h1minimum problem size)
 2070 format (32h1check handling of fmin and fmax)
 2080 format (21h1white noise spectrum)
      end
!OBSSM2
      subroutine obssm2(n, y, pvt, sdpvt, res, sdrest, ifirst, ilast)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBOUTINE LISTS THE DATA SUMMARY FOR THE ARIMA ESTIMATION
!     SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ifirst,ilast,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   pvt(n),res(n),sdpvt(n),sdrest(n),y(n)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm
     integer&
     &   i,iprt
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIRST, ILAST
!        THE FIRST AND LAST INDICES TO BE LISTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     REAL PVT(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL SDPVT(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDREST(N)
!        THE STANDARDIZED RESIDUALS.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
      fplm = r1mach(2)
!
      call iprint(iprt)
!
      do 140 i=ifirst,ilast
!
!     PRINT DATA SUMMARY.
!
        if ((sdpvt(i).ne.fplm) .and. (sdrest(i).ne.fplm))&
    &      write (iprt, 1060) i, y(i), pvt(i), sdpvt(i), res(i),&
     &      sdrest(i)
        if ((sdpvt(i).ne.fplm) .and. (sdrest(i).eq.fplm))&
     &      write (iprt, 1050) i, y(i), pvt(i), sdpvt(i), res(i)
        if ((sdpvt(i).eq.fplm) .and. (sdrest(i).eq.fplm))&
     &      write (iprt, 1080) i, y(i), pvt(i), res(i)
!
  140 continue
!
      return
!
!     FORMAT STATEMENTS
!
 1050 format (1x, i4, 4e16.8, 4x, 4hnc *, 1x, e9.3)
 1060 format (1x, i4, 4e16.8, 1x, f7.2, 1x, e9.3)
1080 format (1x, i4, 2e16.8, 8x, 4hnc *, 4x, e16.8, 4x, 4hnc *,&
     &   1x, e9.3)
      end
!AMFOUT
     subroutine amfout(f, fsd, n, nfcst, ifcsto, ifo, nfcsto, y,&
     &  t975, page)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES ARIMA FORECASTING OUTPUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   t975
     integer&
     &   ifo,n,nfcst,nfcsto
     logical&
     &   page
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   f(*),fsd(*),y(*)
     integer&
     &   ifcsto(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fl,fu,scale,ymn,ymx
     integer&
     &   i,iend,if,ilim,inter,ipf,ipfl,ipfu,iprt,ipy,iy,j
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ylim(4)
     character&
     &   line(53)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AMFHDR,IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic int,max,min
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL F(NFCST)
!        THE FORECASTS.
!     REAL FL
!        THE LOWER 95 PERCENT CONFIDENCE LIMIT FOR THE FORECAST
!     REAL FSD(NFCST)
!        THE STANDARD DEVIATIONS OF THE FORECASTS.
!     REAL FU
!        THE UPPER 95 PERCENT CONFIDENCE LIMIT FOR THE FORECAST
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IEND
!        THE LAST LOCATION IN THE PLOT STRING.
!     INTEGER IF
!        AN INDEX VARIABLE.
!     INTEGER IFCSTO(NFCSTO)
!        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
!     INTEGER IFO
!        THE INDEX OF THE ORIGIN BEING USED.
!     INTEGER ILIM
!        THE NUMBER OF LOCATIONS IN YLIM.
!     INTEGER INTER
!        THE NUMBER OF PLOT INTERVALS.
!     INTEGER IPF
!        THE LOCATION IN THE PLOT STRING OF THE FORECAST.
!     INTEGER IPFL
!        THE LOCATION IN THE PLOT STRING OF THE FORECAST LOWER
!        CONFIDENCE LIMIT.
!     INTEGER IPFU
!        THE LOCATION IN THE PLOT STRING OF THE FORECAST UPPER
!        CONFIDENCE LIMIT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IPY
!        THE LOCATION IN THE PLOT STRING OF THE OBSERVED VALUE.
!     INTEGER IY
!        AN INDEX VARIABLE.
!     INTEGER J
!        AN INDEX VARIABLE.
!     CHARACTER*1 LINE(53)
!        THE ARRAY OF SYMBOLS TO BE PLOTTED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFCST
!        THE NUMBER OF FORECASTS.
!     INTEGER NFCSTO
!        THE NUMBER OF THE ORIGINS.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL SCALE
!        THE PLOT SCALE.
!     REAL T975
!        THE VALUE OF THE 97.5 PERCENT POINT FUNCTION FOR THE
!        T DISTRIBUTION.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!     REAL YLIM(4)
!        THE VALUES OF THE AXIS LABELS.
!     REAL YMN
!        THE MINIMUM VALUE TO BE PLOTTED.
!     REAL YMX
!        THE MAXIMUM VALUE TO BE PLOTTED.
!
!     SET VARIABLES FOR PLOTS
!
      call iprint(iprt)
      inter = 50
      iend = inter + 1
      ilim = 4
!
!     COMPUTE SCALE FOR PLOT
!
      ymn = f(nfcst)-t975*fsd(nfcst)
      ymx = f(nfcst)+t975*fsd(nfcst)
      iy = ifcsto(ifo)
      do 10 i = 1, nfcst
        ymn = min(ymn, f(i)-t975*fsd(i))
        ymx = max(ymx, f(i)+t975*fsd(i))
        if ((iy.ge.1) .and. (iy.le.n)) then
          ymn = min(ymn, y(iy))
          ymx = max(ymx, y(iy))
          iy = iy + 1
        end if
   10 continue
      if (ifcsto(ifo).ge.2) then
        do 20 iy = max(ifcsto(ifo)-4, 1), ifcsto(ifo)-1
          ymn = min(ymn, y(iy))
          ymx = max(ymx, y(iy))
   20   continue
      end if
!
      scale = (ymx-ymn) / inter
!
!     PRINT PLOT HEADINGS
!
      do 30 i = 1, ilim
        ylim(i) = ymn + scale*i*10.0e0
   30 continue
!
      call amfhdr(page, .true., 0)
      write (iprt, 1030) ifo
     write (iprt, 1000) ymn, ylim(2), ylim(4),&
     &  ylim(1), ylim(4), ymx
!
!     BEGIN PLOTTING
!
      do 80 i=max(ifcsto(ifo)-4,1), ifcsto(ifo)+nfcst
         if (i.ne.ifcsto(ifo)) then
           do 40 j = 1, iend
             line(j) = ' '
   40      continue
         else
           do 50 j = 1, iend
             line(j) = '.'
   50      continue
         end if
         if (i.le.ifcsto(ifo)) then
           ipy = int(((y(i)-ymn) / scale) + 1.5e0)
           line(ipy) = '*'
           write (iprt, 1020) i, (line(j),j=1,iend), i, y(i)
         else
           if = i-ifcsto(ifo)
           fl = f(if) - t975*fsd(if)
           fu = f(if) + t975*fsd(if)
           if (i.le.n) then
             ipfl = int(((fl-ymn) / scale) + 1.5e0)
             ipfu = int(((fu-ymn) / scale) + 1.5e0)
             do 60 j = ipfl, ipfu
               line(j) = '-'
   60        continue
             line(ipfl) = '('
             line(ipfu) = ')'
             ipy = int(((y(i)-ymn) / scale) + 1.5e0)
             line(ipy) = '*'
             ipf = int(((f(if)-ymn) / scale) + 1.5e0)
             if (ipf.ne.ipy) then
               line(ipf) = 'X'
             else
               line(ipf) = '2'
             end if
            write (iprt, 1010) i, (line(j),j=1,iend), i,&
     &         f(if), fl, fu, y(i)
           else
             ipfl = int(((fl-ymn) / scale) + 1.5e0)
             ipfu = int(((fu-ymn) / scale) + 1.5e0)
             do 70 j = ipfl, ipfu
               line(j) = '-'
   70        continue
             line(ipfl) = '('
             line(ipfu) = ')'
             ipf = int(((f(if)-ymn) / scale) + 1.5e0)
             line(ipf) = 'X'
            write (iprt, 1010) i, (line(j),j=1,iend), i,&
     &         f(if), fl, fu
           end if
         end if
   80 continue
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (//&
    &  82x, ' --------------------95  PERCENT'/&
    &  1x, 3(g15.8, 5x), 21x,&
    &  ' --------------CONFIDENCE LIMITS',&
    &  ' ---------ACTUAL'/&
    &  11x, 2(g15.8, 5x), g15.8,&
    &  ' ------FORECASTS ----------LOWER',&
    &  ' ----------UPPER -------IF KNOWN'/&
    &  9x, 5('I---------'), 'I', 6x,&
    &  ' ------------[X] ------------[(]',&
     &  ' ------------[)] ------------[*]')
 1010 format (2x, i5, 1x, 'I', 51a1, 'I', i5, 4(1x, g15.8))
 1020 format (2x, i5, 1x, 'I', 51a1, 'I', i5, 49x, g15.8)
 1030 format (//' FORECASTS FOR ORIGIN ', i2)
!
      end
!CMPFD
      subroutine cmpfd(n,stp,pvstp,pv,fd)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES A FINITE DIFFERENCE DERIVATIVE,
!     ASSUMING THAT IF THE DIFFERENCE BETWEEN PVSTP(I) AND PV(I) IS
!     SMALL ENOUGH THE DERIVATIVE IS ZERO.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 30, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   stp
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   fd(*),pv(*),pvstp(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplrs
     integer&
     &   i
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
!       EXTERNAL R1MACH
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,min
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE.
!     REAL FD(N)
!        THE FINITE-DIFFERENCE DERIVATIVE.
!     REAL FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     REAL PV(N)
!        THE PREDICTED VALUES AT THE CURRENT PARAMETER VALUE.
!     REAL PVSTP(N)
!        THE PREDICTED VALUES AT THE CURRENT PARAMETER VALUE PLUS STP.
!     REAL STP
!        THE STEP.
!
      fplrs = r1mach(4)
!
      do 10 i=1,n
         fd(i) = pvstp(i) - pv(i)
         if (abs(fd(i)).ge.5*fplrs*min(abs(pvstp(i)),abs(pv(i)))) then
            fd(i) = fd(i) / stp
         else
            fd(i) = 0.0e0
         end if
   10 continue
      return
      end
!XXCH2
      subroutine xxch2(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE PAGE PLOT FAMILY OF ROUTINES.
!
!     DATA IS THE AIRLINE DATA LISTED ON PAGE 531 OF BOX AND JENKINS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JULY 22, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iprt,iym,m,n
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   air(144),x(12),ym(12,12)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,MPP
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (air(1),ym(1,1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AIR(144)
!        THE AIRLINE DATA.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER IYM
!        THE EXACT VALUE OF THE FIRST DIMENSION OF THE MATRIX YM.
!     INTEGER LDSTAK
!        A DUMMY VARIABLE FOR THIS TEST SUBPROGRAM.
!     INTEGER M
!        THE NUMBER OF COLUMNS OF DATA IN YM.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN EACH COLUMN OF YM.
!     REAL X(12)
!        VECTOR OF OBSERVATIONS FOR X(HORIZONTAL) COORDINATES
!     REAL YM(12,12)
!        MULTIVARIATE OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES.
!
!
     data    x(  1),   x(  2),   x(  3),   x(  4),   x(  5),   x(  6)&
     &    /   1.0e0,    2.0e0,    3.0e0,    4.0e0,    5.0e0,    6.0e0/
     data    x(  7),   x(  8),   x(  9),   x( 10),   x( 11),   x( 12)&
     &    /   7.0e0,    8.0e0,    9.0e0,   10.0e0,   11.0e0,   12.0e0/
!
     data  air(  1), air(  2), air(  3), air(  4), air(  5), air(  6)&
     &    / 112.0e0,  118.0e0,  132.0e0,  129.0e0,  121.0e0,  135.0e0/
     data  air(  7), air(  8), air(  9), air( 10), air( 11), air( 12)&
     &    / 148.0e0,  148.0e0,  136.0e0,  119.0e0,  104.0e0,  118.0e0/
     data  air( 13), air( 14), air( 15), air( 16), air( 17), air( 18)&
     &    / 115.0e0,  126.0e0,  141.0e0,  135.0e0,  125.0e0,  149.0e0/
     data  air( 19), air( 20), air( 21), air( 22), air( 23), air( 24)&
     &    / 170.0e0,  170.0e0,  158.0e0,  133.0e0,  114.0e0,  140.0e0/
     data  air( 25), air( 26), air( 27), air( 28), air( 29), air( 30)&
     &    / 145.0e0,  150.0e0,  178.0e0,  163.0e0,  172.0e0,  178.0e0/
     data  air( 31), air( 32), air( 33), air( 34), air( 35), air( 36)&
     &    / 199.0e0,  199.0e0,  184.0e0,  162.0e0,  146.0e0,  166.0e0/
     data  air( 37), air( 38), air( 39), air( 40), air( 41), air( 42)&
     &    / 171.0e0,  180.0e0,  193.0e0,  181.0e0,  183.0e0,  218.0e0/
     data  air( 43), air( 44), air( 45), air( 46), air( 47), air( 48)&
     &    / 230.0e0,  242.0e0,  209.0e0,  191.0e0,  172.0e0,  194.0e0/
     data  air( 49), air( 50), air( 51), air( 52), air( 53), air( 54)&
     &    / 196.0e0,  196.0e0,  236.0e0,  235.0e0,  229.0e0,  243.0e0/
     data  air( 55), air( 56), air( 57), air( 58), air( 59), air( 60)&
     &    / 264.0e0,  272.0e0,  237.0e0,  211.0e0,  180.0e0,  201.0e0/
     data  air( 61), air( 62), air( 63), air( 64), air( 65), air( 66)&
     &    / 204.0e0,  188.0e0,  235.0e0,  227.0e0,  234.0e0,  264.0e0/
     data  air( 67), air( 68), air( 69), air( 70), air( 71), air( 72)&
     &    / 302.0e0,  293.0e0,  259.0e0,  229.0e0,  203.0e0,  229.0e0/
     data  air( 73), air( 74), air( 75), air( 76), air( 77), air( 78)&
     &    / 242.0e0,  233.0e0,  267.0e0,  269.0e0,  270.0e0,  315.0e0/
     data  air( 79), air( 80), air( 81), air( 82), air( 83), air( 84)&
     &    / 364.0e0,  347.0e0,  312.0e0,  274.0e0,  237.0e0,  278.0e0/
     data  air( 85), air( 86), air( 87), air( 88), air( 89), air( 90)&
     &    / 284.0e0,  277.0e0,  317.0e0,  313.0e0,  318.0e0,  374.0e0/
     data  air( 91), air( 92), air( 93), air( 94), air( 95), air( 96)&
     &    / 413.0e0,  405.0e0,  355.0e0,  306.0e0,  271.0e0,  306.0e0/
     data  air( 97), air( 98), air( 99), air(100), air(101), air(102)&
     &    / 315.0e0,  301.0e0,  356.0e0,  348.0e0,  355.0e0,  422.0e0/
     data  air(103), air(104), air(105), air(106), air(107), air(108)&
     &    / 465.0e0,  467.0e0,  404.0e0,  347.0e0,  305.0e0,  336.0e0/
     data  air(109), air(110), air(111), air(112), air(113), air(114)&
     &    / 340.0e0,  318.0e0,  362.0e0,  348.0e0,  363.0e0,  435.0e0/
     data  air(115), air(116), air(117), air(118), air(119), air(120)&
     &    / 491.0e0,  505.0e0,  404.0e0,  359.0e0,  310.0e0,  337.0e0/
     data  air(121), air(122), air(123), air(124), air(125), air(126)&
     &    / 360.0e0,  342.0e0,  406.0e0,  396.0e0,  420.0e0,  472.0e0/
     data  air(127), air(128), air(129), air(130), air(131), air(132)&
     &    / 548.0e0,  559.0e0,  463.0e0,  407.0e0,  362.0e0,  405.0e0/
     data  air(133), air(134), air(135), air(136), air(137), air(138)&
     &    / 417.0e0,  391.0e0,  419.0e0,  461.0e0,  472.0e0,  535.0e0/
     data  air(139), air(140), air(141), air(142), air(143), air(144)&
     &    / 622.0e0,  606.0e0,  508.0e0,  461.0e0,  390.0e0,  432.0e0/
!
!     DEFINE CONSTANTS
!
      call iprint(iprt)
      iym = 12
      n = 12
      m = 12
!
!     WRITE HEADER
!
      write(iprt, 1000)
!
!     RUN SIMPLE TEST OF MPP
!
      write(iprt, 1100)
      call mpp(ym, x, n, m, iym)
      write (iprt,2000) ierr
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format ('1*CH2')
 1100 format (' SIMPLE TEST OF MPP')
 2000 format (/' THE VALUE OF IERR IS ', i4)
      end
!XXCH1
      subroutine xxch1(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE PAGE PLOT AND STATISTICAL ANALYSIS FAMILIES OF ROUTINES.
!
!     DATA SET IS 84 RELATIVE HUMIDITY MEASUREMENTS FROM PIKES PEAK.
!
!     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   i,iprt,n
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   x(100),y(100)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PP,STAT
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        ERROR FLAG
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER N
!        THE LENGTH OF THE VECTOR Y.
!     REAL X(100)
!        THE ORDER INDICES OF THE DATA.
!     REAL Y(100)
!        DATA VECTOR FOR TESTS.
!
!
      data n /84/
!
     data y( 1), y( 2), y( 3), y( 4)&
     &    / 0.6067e0, 0.6087e0, 0.6086e0, 0.6134e0/
     data y( 5), y( 6), y( 7)&
     &    / 0.6108e0, 0.6138e0, 0.6125e0/
     data y( 8), y( 9), y(10), y(11)&
     &    / 0.6122e0, 0.6110e0, 0.6104e0, 0.7213e0/
     data y(12), y(13), y(14)&
     &    / 0.7078e0, 0.7021e0, 0.7004e0/
     data y(15), y(16), y(17), y(18)&
     &    / 0.6981e0, 0.7242e0, 0.7268e0, 0.7418e0/
     data y(19), y(20), y(21)&
     &    / 0.7407e0, 0.7199e0, 0.6225e0/
     data y(22), y(23), y(24), y(25)&
     &    / 0.6254e0, 0.6252e0, 0.6267e0, 0.6218e0/
     data y(26), y(27), y(28)&
     &    / 0.6178e0, 0.6216e0, 0.6192e0/
     data y(29), y(30), y(31), y(32)&
     &    / 0.6191e0, 0.6250e0, 0.6188e0, 0.6233e0/
     data y(33), y(34), y(35)&
     &    / 0.6225e0, 0.6204e0, 0.6207e0/
     data y(36), y(37), y(38), y(39)&
     &    / 0.6168e0, 0.6141e0, 0.6291e0, 0.6231e0/
     data y(40), y(41), y(42)&
     &    / 0.6222e0, 0.6252e0, 0.6308e0/
     data y(43), y(44), y(45), y(46)&
     &    / 0.6376e0, 0.6330e0, 0.6303e0, 0.6301e0/
     data y(47), y(48), y(49)&
     &    / 0.6390e0, 0.6423e0, 0.6300e0/
     data y(50), y(51), y(52), y(53)&
     &    / 0.6260e0, 0.6292e0, 0.6298e0, 0.6290e0/
     data y(54), y(55), y(56)&
     &    / 0.6262e0, 0.5952e0, 0.5951e0/
     data y(57), y(58), y(59), y(60)&
     &    / 0.6314e0, 0.6440e0, 0.6439e0, 0.6326e0/
     data y(61), y(62), y(63)&
     &    / 0.6392e0, 0.6417e0, 0.6412e0/
     data y(64), y(65), y(66), y(67)&
     &    / 0.6530e0, 0.6411e0, 0.6355e0, 0.6344e0/
     data y(68), y(69), y(70)&
     &    / 0.6623e0, 0.6276e0, 0.6307e0/
     data y(71), y(72), y(73), y(74)&
     &    / 0.6354e0, 0.6197e0, 0.6153e0, 0.6340e0/
     data y(75), y(76), y(77)&
     &    / 0.6338e0, 0.6284e0, 0.6162e0/
     data y(78), y(79), y(80), y(81)&
     &    / 0.6252e0, 0.6349e0, 0.6344e0, 0.6361e0/
     data y(82), y(83), y(84)&
     &    / 0.6373e0, 0.6337e0, 0.6383e0/
!
!     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
!
      call iprint(iprt)
!
      do 10 i=1,n
         x(i) = i
   10 continue
!
!     PRINT HEADING
!
      write (iprt,1000)
!
!     PERFORM SIMPLE TEST OF PP
!
      write (iprt,1100)
      call pp(y, x, n)
      write (iprt,2000) ierr
!
!     PERFORM SIMPLE TEST OF STAT
!
      write (iprt,1200)
      call stat(y, n, ldstak)
      write (iprt,2000) ierr
!
      return
!
!     FORMATS
!
 1000 format ('1*CH1')
 1100 format (' SIMPLE TEST OF PP')
 1200 format ('1SIMPLE TEST OF STAT')
 2000 format (/' THE VALUE OF IERR IS ', i4)
      end
!IPGMPS
      subroutine ipgmps (per, freq, nf, n, ldstak, peri, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING
!     THE INTEGRATED PERIODOGRAM OF A SERIES (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,n,nf,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(*),per(*),peri(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,isym,ldsmin,lpcv,nall0,xaxis,yaxis
     logical&
     &   err01,err02,err03,head
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     character&
     &   llds(8)*1,ln(8)*1,lnf(8)*1,nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,IPGDV,IPRINT,LDSCMP,STKCLR,STKSET
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     REAL FREQ(NF)
!        THE ARRAY IN WHICH THE FREQUENCIES CORRESPONDING TO THE
!        INTEGRATED SPECTRUM VALUES ARE STORED.
!     LOGICAL HEAD
!        A VARIABLE USED TO INDICATE WHETHER A HEADING IS NEEDED FOR
!        ERROR MESSAGES (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     CHARACTER*1 LLDS(8), LN(8), LNF(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE PARAMETER(S) CHECKED
!        FOR ERRORS.
!     INTEGER N
!        THE ACTUAL NUMBER OF OBSERVATIONS IN THE SERIES FROM WHICH
!        THE PERIODOGRAM WAS COMPUTED.
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING ALLOCATIONS OF THE STACK AT THE
!        TIME OF THIS CALL.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        COMPUTED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A PAGE PLOT.
!     REAL PER(NF)
!        THE INTEGRATED PERIODOGRAM.
!     REAL PERI(NF)
!        THE VECTOR IN WHICH THE INTEGRATED PERIODOGRAM IS STORED.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE X AXIS VALUES TO BE PLOTTED ARE STORED.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE STACK FOR
!        THE ARRAY IN WHICH THE Y AXIS VALUES TO BE PLOTTED ARE STORED.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'I',       'P',       'G',       'M',       'P',       'S'/
     data&
    & llds(1), llds(2), llds(3), llds(4), llds(5),&
     &  llds(6), llds(7), llds(8) /'L','D','S','T','A','K',' ',' '/
     data&
    & ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /'N',' ',' ',' ',' ',' ',' ',' '/
     data&
    & lnf(1), lnf(2), lnf(3), lnf(4), lnf(5), lnf(6), lnf(7), lnf(8)&
     & /'N','F',' ',' ',' ',' ',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 17, 1, head, err01, ln)
!
      call eisge(nmsub, lnf, nf, (n+2)/2, 1, head, err02, lnf)
!
      if (err01) go to 5
!
      if (nprt .eq. 0) then
        ldsmin = 0
      else
        call ldscmp(3, 0, nf+103, 0, 0, 0, 'S', 2*nf+206, ldsmin)
      end if
!
      call eisge(nmsub, llds, ldstak, ldsmin, 9, head, err03, llds)
!
      if (err02 .or. err03) go to 5
      go to 10
!
    5 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   10 continue
!
!     SET THE SIZE OF THE WORK AREA
!
      call stkset(ldstak, 4)
!
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!
      nall0 = stkst(1)
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      lpcv = nf + 103
!
!     SUBDIVIDE THE STACK.
!
      if (nprt .eq. 0) then
         isym = 1
         xaxis = 1
         yaxis = 1
      else
         isym = stkget(lpcv, 2)
         xaxis = stkget(lpcv, 3)
         yaxis = stkget(lpcv, 3)
      end if
!
!     CALL THE MAIN DRIVER FOR COMPUTING (AND PLOTTING) THE INTEGRATED
!     PERIODOGRAM.
!
     call ipgdv (per, nf, n, peri, freq, rstak(xaxis),&
     &   rstak(yaxis), istak(isym), lpcv, nprt)
!
      call stkclr(nall0)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &  '       CALL IPGMPS (PER, FREQ, NF, N, LDSTAK, PERI, NPRT)')
      end
!NRANDC
      subroutine nrandc(y, n, iseed, ymean, sigma)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE GENERATES N NORMALLY DISTRIBUTED PSEUDO-
!     RANDOM NUMBERS WITH MEAN YMEAN AND STANDARD DEVIATION SIGMA.  THE
!     NUMBERS GENERATED ARE DETERMINED BY ISEED.  THEY ARE RETURNED IN Y
!
!     ORIGIN - CONCEIVED BY DR. PETER TRYON TO FACILITATE USE OF
!          EXISTING RANDOM NUMBER GENERATOR
!
!     WRITTEN BY -
!          JOHN E. KOONTZ AND JANET R. DONALDSON
!          STATISTICAL ENGINEERING DIVISION
!          NATIONAL BUREAU OF STANDARDS,
!          BOULDER, COLORADO 80302
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   sigma,ymean
     integer&
     &   iseed,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   i,iprt,iseedu
     logical&
     &   err01,err02,head
!
!  LOCAL ARRAYS
     character&
     &   ln(8)*1,lone(8)*1,lsigma(8)*1,lzero(8)*1,nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!     REAL(TYPE=WP) :: RANDN
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,EISRNG,ERSGE,IPRINT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!          THE INDEX OF THE COMPUTING LOOP
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THEIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN FOUND.
!     INTEGER IPRT
!        THE STANDARD OUTPUT FILE UNIT NUMBER
!     INTEGER ISEED
!        THE ISEED TO THE RANDOM NUMBER GENERATOR.
!        ISEED MUST LIE BETWEEN 0 AND 2**((MIN(32,I1MACH(8)+1))-1) -1,
!        INCLUSIVE.  IF ISEED IS NOT EQUAL TO 0, ISEED MUST BE ODD.
!     INTEGER ISEEDU
!        THE VALUE OF THE SEED ACTUALLY USED.
!     CHARACTER*1 LN(8), LONE(8), LSIGMA(8), LZERO(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE VARIABLES(S) CHECKED
!        FOR ERRORS
!     INTEGER N
!        THE LENGTH OF DATA SET GENERATED
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THIS SUBROUTINE
!     REAL SIGMA
!        THE STANDARD DEVIATION OF THE GENERATED VALUES.
!     REAL Y(N)
!        THE GENERATED RANDOM VALUES.
!     REAL YMEAN
!        THE MEAN OF THE GENERATED VALUES.
!
     data  nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6)&
     &   /       'N',      'R',      'A',      'N',      'D',      'C'/
     data     ln(1),    ln(2),    ln(3),    ln(4),    ln(5),    ln(6),&
     &         ln(7),    ln(8)/'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
     data   lone(1),  lone(2),  lone(3),  lone(4),  lone(5),  lone(6),&
     &       lone(7),  lone(8)/'O', 'N', 'E', ' ', ' ', ' ', ' ', ' '/
     data lsigma(1),lsigma(2),lsigma(3),lsigma(4),lsigma(5),lsigma(6),&
     &     lsigma(7),lsigma(8)/'S', 'I', 'G', 'M', 'A', ' ', ' ', ' '/
     data  lzero(1), lzero(2), lzero(3), lzero(4), lzero(5), lzero(6),&
     &      lzero(7), lzero(8)/'Z', 'E', 'R', 'O', ' ', ' ', ' ', ' '/
!
      ierr = 0
!
      head = .true.
!
!     CHECK FOR INPUT ERRORS
!
      call eisge(nmsub, ln, n, 1, 2, head, err01, lone)
      call ersge(nmsub, lsigma, sigma, 0.0e0, 2, head, err02, lzero)
      call eisrng(nmsub, iseed, iseedu, head)
!
      if (err01.or.err02) then
!
        call iprint(iprt)
        write (iprt,1000)
        ierr = 1
!
      else
!
!     GENERATE THE PSEUDO-RANDOM NUMBERS
!
        y(1) = randn(iseedu,typ=0.0_wp)
        do 20 i=1,n
           y(i) = randn(0,typ=0.0_wp)*sigma + ymean
   20   continue
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL NRANDC (Y, N, ISEED, YMEAN, SIGMA)')
      end
!ACFSDM
      subroutine acfsdm (rho, sdrho, nc, n, nlppa)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE STANDARD ERROR OF THE AUTOCORRELATIONS
!     WHEN MISSING DATA ARE INVOLVED.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n,nc
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   rho(*),sdrho(*)
     integer&
     &   nlppa(*)
!
!  LOCAL SCALARS
     integer&
     &   k,klast,lag
!
!  INTRINSIC FUNCTIONS
      intrinsic min,real,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER KLAST
!        THE LAST LAG VALUE TO BE USED.
!     INTEGER LAG
!        THE INDEX VARIABLE USED TO INDICATE THE AUTOCORRELATION
!        BEING EXAMINED.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NC
!        THE NUMBER OF AUTOCORRELATIONS COMPUTED
!     INTEGER NLPPA(NC)
!        THE ARRAY IN WHICH THE NUMBER OF OBSERVATIONS USED TO
!        COMPUTE EACH AUTOCORRELATION AND PARTIAL AUTOCORRELATION
!        IS STORED
!     REAL RHO(NC)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
!     REAL SDRHO(NC)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!        ARE STORED
!
      sdrho(1) = sqrt(real(nlppa(1))) * (n-1) / (n * nlppa(1))
      if (nc .eq. 1) return
      do 20 lag = 2, nc
         sdrho(lag) = 0.0e0
         klast = min(lag-1, n-lag)
         do 10 k = 1, klast
            sdrho(lag) = sdrho(lag) + (n-lag-k) * rho(k) * rho(k)
   10    continue
        sdrho(lag) = sqrt((n-lag) + 2.0e0 * sdrho(lag)) *&
     &      (n-lag) / (n*nlppa(lag))
   20 continue
      return
      end
!STPOUT
     subroutine stpout(head, n, exm, nexmpt, neta, j, par, npar, stp,&
    &   nfail, ifail, scale, lscale, hdr, page, wide, isubhd, nprt,&
     &   prtfxd, ifixd)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS THE RESULTS OF THE STEP SIZE SELECTING
!     SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   exm
     integer&
     &   isubhd,j,lscale,n,neta,nexmpt,npar,nprt
     logical&
     &   head,page,prtfxd,wide
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),scale(lscale),stp(npar)
     integer&
     &   ifail(n),ifixd(npar),nfail(npar)
!
!  SUBROUTINE ARGUMENTS
       external hdr
!
!  LOCAL SCALARS
     integer&
     &   i,iprt,k,nflabs,nk,nperl
     logical&
     &   sameln
     character&
     &   blank*1,c*1,f*1,plus*1
!
!  LOCAL ARRAYS
     integer&
     &   index(25)
     character&
     &   fixed(3)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL FIXPRT,IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic iabs
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     CHARACTER*1 BLANK
!        THE CHARACTER BLANK.
!     CHARACTER*1 C
!        THE CHARACTER FLAG INDICATING HIGH CURVATURE.
!     REAL EXM
!        THE PROPORTION OF OBSERVATIONS ACTUALLY USED FOR WHICH THE
!        COMPUTED NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE
!        EXEMPTED FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     CHARACTER*1 F
!        THE CHARACTER FLAG INDICATING NUMBER OF OBSERVATIONS
!        FAILING SELECTION CRITERIA EXCEEDED EXEMPTED NUMBER.
!     CHARACTER*1 FIXED(3)
!        THE CHARACTERS USED TO LABEL THE PARAMETERS FIXED OR NOT.
!     EXTERNAL HDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IFAIL(N)
!        THE ARRAY OF INDICATOR VARIABLES DESIGNATING WHETHER
!        THE STEP SIZE SELECTED WAS SATISFACTORY FOR A GIVEN
!        OBSERVATION AND PARAMETER.
!     INTEGER INDEX(25)
!        THE ROW NUMBERS OF OBSERVATIONS FOR WHICH THE STEP SIZE
!        SELECTED FAILED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXD(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXD(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NEXMPT
!        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
!        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
!        SIZE STILL BE CONSIDERED OK.
!     INTEGER NFAIL(NPAR)
!        THE NUMBER OF OBSERVATIONS FOR WHICH THE SELECTED STEP
!        SIZE DOES NOT MEET THE CRITERIA.
!     INTEGER NFLABS
!        THE ABSOLUTE VALUE OF NFAIL.
!     INTEGER NK
!        AN INDEX VARIABLE.
!     INTEGER NPERL
!        THE NUMBER OF OBSERVATIONS TO BE PRINTED PER LINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE OUTPUT
!        IS TO BEGIN ON A NEW PAGE.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
!        PARAMETERS ARE STORED.
!     CHARACTER*1 PLUS
!        THE CHARACTER PLUS.
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     LOGICAL SAMELN
!        AN INDICATOR VALUE TO DESIGNATE WHETHER THE LINE IS TO BE
!        PRINTED ON THE SAME LINE AS THE PREVIOUS LINE PRINTED (TRUE)
!        OR NOT (FALSE).
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL STP(NPAR)
!        THE SELECTED STEP SIZE.
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!
      data blank /' '/, plus /'+'/
      call iprint(iprt)
!
!     INITIALIZE ARRAY FIXED
!
      do 10 k=1,3
         fixed(k) = blank
   10 continue
!
      if (head) then
!
!     PRINT HEADING
!
         head = .false.
!
         call hdr(page, wide, isubhd)
         if (prtfxd) then
            write (iprt,1000)
         else
            write (iprt,1010)
         end if
!
!     PRINT INFORMATION OTHERWISE SUPPRESSED BY PRINT CONTROL
!
         do 20 i=1,j-1
            if (prtfxd) call fixprt(ifixd(i), fixed)
            if (ifixd(i).eq.0) then
               f = blank
               c = blank
               nflabs = iabs(nfail(i))
               if (nflabs.gt.nexmpt) f = plus
               if (nfail(i).lt.0) c = plus
               if (scale(1).gt.0.0e0) then
                 write (iprt,1020) i, (fixed(k),k=1,3), par(i),&
    &                              scale(i),&
     &                              stp(i), nflabs, f, c
               else
                 write (iprt,1040) i, (fixed(k),k=1,3), par(i),&
     &                              stp(i), nflabs, f, c
               end if
               if (nflabs.gt.nexmpt) write (iprt,1030)
            else
               write (iprt,1045) i, (fixed(k),k=1,3), par(i)
            end if
   20    continue
      end if
!
!     PRINT INFORMATION FOR CURRENT PARAMETER
!
      i = j
      if (prtfxd) call fixprt(ifixd(i), fixed)
      if (ifixd(i).eq.0) then
         f = blank
         c = blank
         nflabs = iabs(nfail(i))
         if (nflabs.gt.nexmpt) f = plus
         if (nfail(i).lt.0) c = plus
         if (scale(1).gt.0.0e0) then
           write (iprt,1020) i, (fixed(k),k=1,3), par(i),&
    &                        scale(i),&
     &                        stp(i), nflabs, f, c
         else
           write (iprt,1040) i, (fixed(k),k=1,3), par(i),&
     &                        stp(i), nflabs, f, c
         end if
         if (nflabs.ge.1) then
            if ((nprt.eq.0) .and. (nflabs.le.nexmpt)) then
               write (iprt,1030)
            else
!
!     PRINT ROW NUMBERS
!
               nperl = 7
!
               sameln = .true.
               nk = 0
               do 60 i=1,n
                  if (ifail(i).eq.0) go to 60
                  nk = nk + 1
                  index(nk) = i
                  if (nk.lt.nperl) go to 60
                  if (sameln) then
                     write (iprt,1050) (index(k),k=1,nk)
                  else
                     write (iprt,1060) (index(k),k=1,nk)
                  end if
                  sameln = .false.
                  nk = 0
   60          continue
               if (sameln) then
                  write (iprt,1050) (index(k),k=1,nk)
               else
                  write (iprt,1060) (index(k),k=1,nk)
               end if
            end if
         end if
      else
         write (iprt,1045) i, (fixed(k),k=1,3), par(i)
      end if
      if (j.lt.npar) return
!
!     PRINT FINAL NOTES AND SUMMARY
!
      write (iprt,1070)
      if (nprt.ne.0) go to 100
      do 90 i=1,npar
         if (ifixd(i).eq.0) then
            if (iabs(nfail(i)).gt.nexmpt) go to 90
            write (iprt,1080)
            go to 100
         end if
   90 continue
!
  100 continue
!
!     PRINT CONTROL VALUES USED.
!
      write (iprt,1090) neta
      write (iprt,1100) exm
      write (iprt,1110) nexmpt
      write (iprt,1120) n
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (//50x, 13hstep size for, 4x, 25hobservations failing step,&
    &   24h size selection criteria/50x, 13happroximating, 21x, 1h*/7x,&
    &   24hparameter starting value, 6x, 5hscale, 10x, 10hderivative,&
    &   7x, 5hcount, 5x, 5hnotes, 5x, 10hrow number/1x, 5hindex, 2x,&
    &   5hfixed, 6x, 5h(par), 12x, 7h(scale), 11x, 5h(stp), 21x, 3hf c/&
     &   )
1010 format (//50x, 13hstep size for, 4x, 25hobservations failing step,&
    &   24h size selection criteria/18x, 9hparameter, 23x, 9happroxima,&
    &   4hting, 21x, 1h*/16x, 14hstarting value, 7x, 5hscale, 10x,&
    &   10hderivative, 7x, 5hcount, 5x, 5hnotes, 5x, 13hrow number(s)/&
    &   1x, 5hindex, 13x, 5h(par), 12x, 7h(scale), 11x, 5h(stp), 21x,&
     &   3hf c/)
 1020 format (1x, i3, 5x, 3a1, 3g17.8, 5x, i5, 7x, a1, 1x, a1)
 1030 format ('+', 89x, 2h**)
1040 format (1x, i3, 5x, 3a1, g17.8, 7x, 7hdefault, 3x, g17.8, 5x, i5,&
     &   7x, a1, 1x, a1)
1045 format (1x, i3, 5x, 3a1, g17.8, 9x, '---', 14x, '---',&
     &        14x, '-')
 1050 format ('+', 86x, 7i5)
 1060 format (87x, 7i5)
1070 format (//1x, 36h*  notes.  a plus (+) in the columns, 8h headed ,&
    &   33hf or c has the following meaning.//4x, 17hf - number of obs,&
    &   27hervations failing step size, 27h selection criteria exceeds/&
    &   8x, 29hnumber of exemptions allowed.//4x, 17hc - high curvatur,&
    &   30he in the model is suspected as, 13h the cause of/8x,&
     &   19hall failures noted.)
1080 format (//46h ** row numbers are only listed when number of,&
    &   26h observations failing step/4x, 25hsize selection criteria e,&
     &   27hxceeds number of exemptions, 9h allowed.)
1090 format (/43h number of reliable digits in model results, 25x,&
     &   6h(neta), 1x, i5)
1100 format (/41h proportion of observations exempted from, 8h selecti,&
     &   11hon criteria, 7x, 7h(exmpt), 2x, f6.4)
1110 format (/37h number of observations exempted from, 11h selection ,&
     &   8hcriteria, 19x, i5)
 1120 format (/23h number of observations, 48x, 3h(n), 1x, i5)
      end
!BFSS
     subroutine bfss(y1, y2, n, nw, lags, nf, fmin, fmax, nprt, cspc2,&
     &   icspc2, phas, iphas, freq, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     BIVARIATE SPECTRUM ANALYSIS (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fmax,fmin
     integer&
     &   icspc2,iphas,ldstak,n,nf,nprt,nw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   cspc2(*),freq(*),phas(*),y1(*),y2(*)
     integer&
     &   lags(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta,ymiss1,ymiss2
     integer&
    &   ccov,ccov11,ccov12,ccov21,ccov22,ceven,codd,i,iccov,ifp,&
    &   index1,index2,inlppc,io,iprt,isym,jccov,jnlppc,lagmax,&
    &   lagmx1,ldsmin,lpcv,lw,lwork,ly,m,nall0,spcf1,spcf2,w,work,&
     &   xaxis,yaxis
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12),nlppc(1,1,1)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL BFSDRV,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     INTEGER CCOV, CCOV11, CCOV12, CCOV21, CCOV22
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE COVARIANCES.
!     INTEGER CEVEN
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     INTEGER CODD
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     REAL CSPC2(ICSPC2,NW)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC(1,1,1)
!        A DUMMY ARRAY.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT = 1 THE PLOT IS PROVIDED.
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL PHAS(IPHAS,NW)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SPCF1, SPCF2
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     INTEGER W
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE WINDOWS.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR THE VECTOR WORK.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YMISS1, YMISS2
!        DUMMY VARIABLES.
!     REAL Y1(N)
!        THE FIRST TIME SERIES.
!     REAL Y2(N)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'B','F','S','S',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      option(1) = .false.
      option(2) = .false.
      option(3) = .false.
      option(4) = .true.
!
!     SET MAXIMUM LAG VALUE TO BE USED (LAGMAX).
!
      if (nw.ge.1) then
         lagmax = lags(1)
         do 10 i=1,nw
            lagmax = max(lagmax,lags(i))
   10    continue
      else
         lagmax = n - 1
      end if
      lagmx1 = lagmax + 1
!
      iccov = lagmax + 1
      jccov = 2
      inlppc = 1
      jnlppc = 1
      m = 2
      index1 = 1
      index2 = 2
!
!     COMPUTE THE MINIMUM ALLOWABLE STACK AREA (LDSMIN)
!
      io = 1
      if (nprt.eq.0) io = 0
!
     call ldscmp(9, 0, io*4*nf, 0, 0, 0, 'S',&
     &            7*lagmax+7+io*8*nf, ldsmin)
!
      ly = n
      ymiss1 = 1.0e0
      ymiss2 = 1.0e0
      lpcv = 4*nf
      lw = lagmax + 1
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING STACK ALLOCATIONS (NALL0).
!     SET THE STACK ALLOCATION TYPE (IFP)
!
      call stkset(ldstak, 4)
      nall0 = stkst(1)
!
      ifp = 3
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS
!
      if ((ldsmin.gt.ldstak) .or. (ldsmin.le.6)) then
         ccov = 1
         ceven = 1
         codd = 1
         spcf1 = 1
         spcf2 = 1
         w = 1
!
         ccov11 = 1
         ccov21 = 1
         ccov12 = 1
         ccov22 = 1
!
         isym = 1
         xaxis = 1
         yaxis = 1
      else
         ccov = stkget(4*lagmx1,ifp)
         ceven = stkget(lagmx1,ifp)
         codd = stkget(lagmx1,ifp)
         spcf1 = stkget(nf,ifp)
         spcf2 = stkget(nf,ifp)
         w = stkget(lw,ifp)
!
         ccov11 = ccov
         ccov21 = ccov + lagmx1
         ccov12 = ccov21 + lagmx1
         ccov22 = ccov12 + lagmx1
!
         if (nprt.eq.0) then
            isym = w
            xaxis = w
            yaxis = w
         else
            isym = stkget(lpcv,2)
            xaxis = stkget(lpcv,ifp)
            yaxis = stkget(lpcv,ifp)
        end if
      end if
!
      work = w
      lwork = lw
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
     call bfsdrv(y1, y2, ymiss1, ymiss2, rstak(ccov), nlppc,&
    &   rstak(spcf1), rstak(spcf2), nf, fmin, fmax, freq, n, nw,&
    &   lagmax, lags, lagmx1, rstak(work), lwork, delta, istak(isym),&
    &   rstak(xaxis), rstak(yaxis), lpcv, alpha, nprt, parzen, iccov,&
    &   jccov, m, index1, index2, cspc2, phas, icspc2, iphas,&
    &   rstak(codd), rstak(ceven), rstak(w), lw, nmsub, ldsmin,&
     &   ldstak, option, n, inlppc, jnlppc, ly)
!
      call stkclr(nall0)
!
!     CHECK FOR ERRORS
!
      if (ierr.eq.0) return
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL BFSS (Y1, Y2, N,'/&
    &   '      +           NW, LAGS, NF, FMIN, FMAX, NPRT,'/&
     &   '      +           CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)')
      end
!FFT
      subroutine fft(a, b, ntot, n, nspan, isn)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  MULTIVARIATE COMPLEX FOURIER TRANSFORM, COMPUTED IN PLACE
!    USING MIXED-RADIX FAST FOURIER TRANSFORM ALGORITHM.
!  BY R. C. SINGLETON, STANFORD RESEARCH INSTITUTE, OCT. 1968
!  ARRAYS A AND B ORIGINALLY HOLD THE REAL AND IMAGINARY
!    COMPONENTS OF THE DATA, AND RETURN THE REAL AND
!    IMAGINARY COMPONENTS OF THE RESULTING FOURIER COEFFICIENTS.
!  MULTIVARIATE DATA IS INDEXED ACCORDING TO THE FORTRAN
!    ARRAY ELEMENT SUCCESSOR FUNCTION, WITHOUT LIMIT
!    ON THE NUMBER OF IMPLIED MULTIPLE SUBSCRIPTS.
!    THE SUBROUTINE IS CALLED ONCE FOR EACH VARIATE.
!    THE CALLS FOR A MULTIVARIATE TRANSFORM MAY BE IN ANY ORDER.
!  NTOT IS THE TOTAL NUMBER OF COMPLEX DATA VALUES.
!  N IS THE DIMENSION OF THE CURRENT VARIABLE.
!  NSPAN/N IS THE SPACING OF CONSECUTIVE DATA VALUES
!    WHILE INDEXING THE CURRENT VARIABLE.
!  THE SIGN OF ISN DETERMINES THE SIGN OF THE COMPLEX
!    EXPONENTIAL, AND THE MAGNITUDE OF ISN IS NORMALLY ONE.
!  A TRI-VARIATE TRANSFORM WITH A(N1,N2,N3), B(N1,N2,N3)
!    IS COMPUTED BY
!      CALL FFT(A,B,N1*N2*N3,N1,N1,1)
!      CALL FFT(A,B,N1*N2*N3,N2,N1*N2,1)
!      CALL FFT(A,B,N1*N2*N3,N3,N1*N2*N3,1)
!  FOR A SINGLE-VARIATE TRANSFORM,
!    NTOT = N = NSPAN = (NUMBER OF COMPLEX DATA VALUES), F.G.
!      CALL FFT(A,B,N,N,N,1)
!  THE DATA MAY ALTERNATIVELY BE STORED IN A SINGLE COMPLEX
!    ARRAY A, THEN THE MAGNITUDE OF ISN CHANGED TO TWO TO
!    GIVE THE CORRECT INDEXING INCREMENT AND A(2) USED TO
!    PASS THE INITIAL ADDRESS FOR THE SEQUENCE OF IMAGINARY
!    VALUES, E.G.
!      CALL FFT(A,A(2),NTOT,N,NSPAN,2)
!  ARRAYS AT(MAXF), CK(MAXF), BT(MAXF), SK(MAXF), AND NP(MAXP)
!    ARE USED FOR TEMPORARY STORAGE.  IF THE AVAILABEL STORAGE
!    IS INSUFFICIENT, THE PROGRAM IS TERMINATED BY A STOP.
!    MAXF MUST BE .GE. THE MAXIMUM PRIME FACTOR OF N.
!    MAXP MUST BE .GT. THE NUMBER OF PRIME FACTORS OF N.
!
!     NB. THE ABOVE DESCRIPTION OF MAXP APPEARS TO BE INCORRECT.
!         MAXP SEEMS TO BE THE MAXIMUM SIZE OF THE SQUARE FREE
!         PORTION K OF N.
!
!    IN ADDITION, IF THE SQUARE-FREE PORTION K OF N HAS TWO OR
!    MORE PRIME FACTORS, THEN MAXP MUST BE .GE. K-1.
!     DIMENSION A(1), B(1)
!  ARRAY STORAGE IN NFAC FOR A MAXIMUM OF 11 FACTORS OF N.
!  IF N HAS MORE THAN ONE SQUARE-FREE FACTOR, THE PRODUCT OF THE
!    SQUARE-FREE FACTORS MUST BE .LE. 210
!     DIMENSION NFAC(11), NP(209)
!  ARRAY STORAGE FOR MAXIMUM PRIME FACTOR OF 23
!     DIMENSION AT(23), CK(23), BT(23), SK(23)
!
!
!  VARIABLE DECLARATIONS
!
!  PARAMETERS
     integer&
     &   maxf1
      parameter (maxf1=23)
     integer&
     &   maxp1
      parameter (maxp1=209)
!
!  SCALAR ARGUMENTS
     integer&
     &   isn,n,nspan,ntot
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   a(*),b(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   aa,aj,ajm,ajp,ak,akm,akp,bb,bj,bjm,bjp,bk,bkm,bkp,c1,c2,c3,&
     &   c72,cd,rad,radf,s1,s120,s2,s3,s72,sd
     integer&
    &   i,ii,inc,iprt,j,jc,jf,jj,k,k1,k2,k3,k4,kk,ks,kspan,kspnn,&
     &   kt,m,maxf,maxp,nn,nt
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   at(maxf1),bt(maxf1),ck(maxf1),sk(maxf1)
     integer&
     &   nfac(11),np(maxp1)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic atan,cos,mod,sin,sqrt
!
!  EQUIVALENCES
      equivalence (i,ii)
!
!  THE FOLLOWING TWO CONSTANTS SHOULD AGREE WITH THE ARRAY DIMENSIONS.
      maxf = maxf1
      maxp = maxp1
      if (n.lt.2) return
!
!  INITIALIZE VARIABLES
!
      c1 = 0
      c2 = 0
      c3 = 0
      s1 = 0
      s2 = 0
      s3 = 0
      k1 = 0
      k2 = 0
      k3 = 0
      k4 = 0
!
      inc = isn
      rad = 8.0e0*atan(1.0e0)
      s72 = rad/5.0e0
      c72 = cos(s72)
      s72 = sin(s72)
      s120 = sqrt(0.75e0)
      if (isn.ge.0) go to 10
      s72 = -s72
      s120 = -s120
      rad = -rad
      inc = -inc
   10 nt = inc*ntot
      ks = inc*nspan
      kspan = ks
      nn = nt - inc
      jc = ks/n
      radf = rad*jc*0.5e0
      i = 0
      jf = 0
!  DETERMINE THE FACTORS OF N
      m = 0
      k = n
      go to 30
   20 m = m + 1
      nfac(m) = 4
      k = k/16
   30 if (k-(k/16)*16.eq.0) go to 20
      j = 3
      jj = 9
      go to 50
   40 m = m + 1
      nfac(m) = j
      k = k/jj
   50 if (mod(k,jj).eq.0) go to 40
      j = j + 2
      jj = j**2
      if (jj.le.k) go to 50
      if (k.gt.4) go to 60
      kt = m
      nfac(m+1) = k
      if (k.ne.1) m = m + 1
      go to 100
   60 if (k-(k/4)*4.ne.0) go to 70
      m = m + 1
      nfac(m) = 2
      k = k/4
   70 kt = m
      j = 2
   80 if (mod(k,j).ne.0) go to 90
      m = m + 1
      nfac(m) = j
      k = k/j
   90 j = ((j+1)/2)*2 + 1
      if (j.le.k) go to 80
  100 if (kt.eq.0) go to 120
      j = kt
  110 m = m + 1
      nfac(m) = nfac(j)
      j = j - 1
      if (j.ne.0) go to 110
!  COMPUTE FOURIER TRANSFORM
  120 sd = radf/kspan
      cd = 2.0e0*sin(sd)**2
      sd = sin(sd+sd)
      kk = 1
      i = i + 1
      if (nfac(i).ne.2) go to 170
!  TRANSFORM FOR FACTOR OF 2 (INCLUDING ROTATION FACTOR)
      kspan = kspan/2
      k1 = kspan + 2
  130 k2 = kk + kspan
      ak = a(k2)
      bk = b(k2)
      a(k2) = a(kk) - ak
      b(k2) = b(kk) - bk
      a(kk) = a(kk) + ak
      b(kk) = b(kk) + bk
      kk = k2 + kspan
      if (kk.le.nn) go to 130
      kk = kk - nn
      if (kk.le.jc) go to 130
      if (kk.gt.kspan) go to 360
  140 c1 = 1.0e0 - cd
      s1 = sd
  150 k2 = kk + kspan
      ak = a(kk) - a(k2)
      bk = b(kk) - b(k2)
      a(kk) = a(kk) + a(k2)
      b(kk) = b(kk) + b(k2)
      a(k2) = c1*ak - s1*bk
      b(k2) = s1*ak + c1*bk
      kk = k2 + kspan
      if (kk.lt.nt) go to 150
      k2 = kk - nt
      c1 = -c1
      kk = k1 - k2
      if (kk.gt.k2) go to 150
      ak = c1 - (cd*c1+sd*s1)
      s1 = (sd*c1-cd*s1) + s1
!  THE FOLLOWING THREE STATEMENTS COMPENSATE FOR TRUNCATION ERROR
      c1 = 0.5e0/(ak**2+s1**2) + 0.5e0
      s1 = c1*s1
      c1 = c1*ak
      kk = kk + jc
      if (kk.lt.k2) go to 150
      k1 = k1 + inc + inc
      kk = (k1-kspan)/2 + jc
      if (kk.le.jc+jc) go to 140
      go to 120
!  TRANSFORM FOR FACTOR OF 3 (OPTIONAL CODE)
  160 k1 = kk + kspan
      k2 = k1 + kspan
      ak = a(kk)
      bk = b(kk)
      aj = a(k1) + a(k2)
      bj = b(k1) + b(k2)
      a(kk) = ak + aj
      b(kk) = bk + bj
      ak = -0.5e0*aj + ak
      bk = -0.5e0*bj + bk
      aj = (a(k1)-a(k2))*s120
      bj = (b(k1)-b(k2))*s120
      a(k1) = ak - bj
      b(k1) = bk + aj
      a(k2) = ak + bj
      b(k2) = bk - aj
      kk = k2 + kspan
      if (kk.lt.nn) go to 160
      kk = kk - nn
      if (kk.le.kspan) go to 160
      go to 320
!  TRANSFORM FOR FACTOR OF 4
  170 if (nfac(i).ne.4) go to 260
      kspnn = kspan
      kspan = kspan/4
  180 c1 = 1.0e0
      s1 = 0
  190 k1 = kk + kspan
      k2 = k1 + kspan
      k3 = k2 + kspan
      akp = a(kk) + a(k2)
      akm = a(kk) - a(k2)
      ajp = a(k1) + a(k3)
      ajm = a(k1) - a(k3)
      a(kk) = akp + ajp
      ajp = akp - ajp
      bkp = b(kk) + b(k2)
      bkm = b(kk) - b(k2)
      bjp = b(k1) + b(k3)
      bjm = b(k1) - b(k3)
      b(kk) = bkp + bjp
      bjp = bkp - bjp
      if (isn.lt.0) go to 220
      akp = akm - bjm
      akm = akm + bjm
      bkp = bkm + ajm
      bkm = bkm - ajm
      if (s1.eq.0.0e0) go to 230
  200 a(k1) = akp*c1 - bkp*s1
      b(k1) = akp*s1 + bkp*c1
      a(k2) = ajp*c2 - bjp*s2
      b(k2) = ajp*s2 + bjp*c2
      a(k3) = akm*c3 - bkm*s3
      b(k3) = akm*s3 + bkm*c3
      kk = k3 + kspan
      if (kk.le.nt) go to 190
  210 c2 = c1 - (cd*c1+sd*s1)
      s1 = (sd*c1-cd*s1) + s1
      c1 = 0.5e0/(c2**2+s1**2) + 0.5e0
      s1 = c1*s1
      c1 = c1*c2
      c2 = c1**2 - s1**2
      s2 = 2.0e0*c1*s1
      c3 = c2*c1 - s2*s1
      s3 = c2*s1 + s2*c1
      kk = kk - nt + jc
      if (kk.le.kspan) go to 190
      kk = kk - kspan + inc
      if (kk.le.jc) go to 180
      if (kspan.eq.jc) go to 360
      go to 120
  220 akp = akm + bjm
      akm = akm - bjm
      bkp = bkm - ajm
      bkm = bkm + ajm
      if (s1.ne.0.0e0) go to 200
  230 a(k1) = akp
      b(k1) = bkp
      a(k2) = ajp
      b(k2) = bjp
      a(k3) = akm
      b(k3) = bkm
      kk = k3 + kspan
      if (kk.le.nt) go to 190
      go to 210
!  TRANSFORM FOR FACTOR OF 5 (OPTIONAL CODE)
  240 c2 = c72**2 - s72**2
      s2 = 2.0e0*c72*s72
  250 k1 = kk + kspan
      k2 = k1 + kspan
      k3 = k2 + kspan
      k4 = k3 + kspan
      akp = a(k1) + a(k4)
      akm = a(k1) - a(k4)
      bkp = b(k1) + b(k4)
      bkm = b(k1) - b(k4)
      ajp = a(k2) + a(k3)
      ajm = a(k2) - a(k3)
      bjp = b(k2) + b(k3)
      bjm = b(k2) - b(k3)
      aa = a(kk)
      bb = b(kk)
      a(kk) = aa + akp + ajp
      b(kk) = bb + bkp + bjp
      ak = akp*c72 + ajp*c2 + aa
      bk = bkp*c72 + bjp*c2 + bb
      aj = akm*s72 + ajm*s2
      bj = bkm*s72 + bjm*s2
      a(k1) = ak - bj
      a(k4) = ak + bj
      b(k1) = bk + aj
      b(k4) = bk - aj
      ak = akp*c2 + ajp*c72 + aa
      bk = bkp*c2 + bjp*c72 + bb
      aj = akm*s2 - ajm*s72
      bj = bkm*s2 - bjm*s72
      a(k2) = ak - bj
      a(k3) = ak + bj
      b(k2) = bk + aj
      b(k3) = bk - aj
      kk = k4 + kspan
      if (kk.lt.nn) go to 250
      kk = kk - nn
      if (kk.le.kspan) go to 250
      go to 320
!  TRANSFORM FOR ODD FACTORS
  260 k = nfac(i)
      kspnn = kspan
      kspan = kspan/k
      if (k.eq.3) go to 160
      if (k.eq.5) go to 240
      if (k.eq.jf) go to 280
      jf = k
      s1 = rad/k
      c1 = cos(s1)
      s1 = sin(s1)
      if (jf.gt.maxf) go to 590
      ck(jf) = 1.0e0
      sk(jf) = 0.0e0
      j = 1
  270 ck(j) = ck(k)*c1 + sk(k)*s1
      sk(j) = ck(k)*s1 - sk(k)*c1
      k = k - 1
      ck(k) = ck(j)
      sk(k) = -sk(j)
      j = j + 1
      if (j.lt.k) go to 270
  280 k1 = kk
      k2 = kk + kspnn
      aa = a(kk)
      bb = b(kk)
      ak = aa
      bk = bb
      j = 1
      k1 = k1 + kspan
  290 k2 = k2 - kspan
      j = j + 1
      at(j) = a(k1) + a(k2)
      ak = at(j) + ak
      bt(j) = b(k1) + b(k2)
      bk = bt(j) + bk
      j = j + 1
      at(j) = a(k1) - a(k2)
      bt(j) = b(k1) - b(k2)
      k1 = k1 + kspan
      if (k1.lt.k2) go to 290
      a(kk) = ak
      b(kk) = bk
      k1 = kk
      k2 = kk + kspnn
      j = 1
  300 k1 = k1 + kspan
      k2 = k2 - kspan
      jj = j
      ak = aa
      bk = bb
      aj = 0.0e0
      bj = 0.0e0
      k = 1
  310 k = k + 1
      ak = at(k)*ck(jj) + ak
      bk = bt(k)*ck(jj) + bk
      k = k + 1
      aj = at(k)*sk(jj) + aj
      bj = bt(k)*sk(jj) + bj
      jj = jj + j
      if (jj.gt.jf) jj = jj - jf
      if (k.lt.jf) go to 310
      k = jf - j
      a(k1) = ak - bj
      b(k1) = bk + aj
      a(k2) = ak + bj
      b(k2) = bk - aj
      j = j + 1
      if (j.lt.k) go to 300
      kk = kk + kspnn
      if (kk.le.nn) go to 280
      kk = kk - nn
      if (kk.le.kspan) go to 280
!  MULTIPLY BY ROTATION FACTOR (EXCEPT FOR FACTORS OF 2 AND 4)
  320 if (i.eq.m) go to 360
      kk = jc + 1
  330 c2 = 1.0e0 - cd
      s1 = sd
  340 c1 = c2
      s2 = s1
      kk = kk + kspan
  350 ak = a(kk)
      a(kk) = c2*ak - s2*b(kk)
      b(kk) = s2*ak + c2*b(kk)
      kk = kk + kspnn
      if (kk.le.nt) go to 350
      ak = s1*s2
      s2 = s1*c2 + c1*s2
      c2 = c1*c2 - ak
      kk = kk - nt + kspan
      if (kk.le.kspnn) go to 350
      c2 = c1 - (cd*c1+sd*s1)
      s1 = s1 + (sd*c1-cd*s1)
      c1 = 0.5e0/(c2**2+s1**2) + 0.5e0
      s1 = c1*s1
      c2 = c1*c2
      kk = kk - kspnn + jc
      if (kk.le.kspan) go to 340
      kk = kk - kspan + jc + inc
      if (kk.le.jc+jc) go to 330
      go to 120
!  PERMUTE THE RESULTS TO NORMAL ORDER--- DONE IN TWO STAGES
!  PERMUTATION FOR SQUARE FACTORS OF N
  360 np(1) = ks
      if (kt.eq.0) go to 450
      k = kt + kt + 1
      if (m.lt.k) k = k - 1
      j = 1
      np(k+1) = jc
  370 np(j+1) = np(j)/nfac(j)
      np(k) = np(k+1)*nfac(j)
      j = j + 1
      k = k - 1
      if (j.lt.k) go to 370
      k3 = np(k+1)
      kspan = np(2)
      kk = jc + 1
      k2 = kspan + 1
      j = 1
      if (n.ne.ntot) go to 410
!  PERMUTATION FOR SINGLE-VARIATE TRANSFORM (OPTIONAL CODE)
  380 ak = a(kk)
      a(kk) = a(k2)
      a(k2) = ak
      bk = b(kk)
      b(kk) = b(k2)
      b(k2) = bk
      kk = kk + inc
      k2 = kspan + k2
      if (k2.lt.ks) go to 380
  390 k2 = k2 - np(j)
      j = j + 1
      k2 = np(j+1) + k2
      if (k2.gt.np(j)) go to 390
      j = 1
  400 if (kk.lt.k2) go to 380
      kk = kk + inc
      k2 = kspan + k2
      if (k2.lt.ks) go to 400
      if (kk.lt.ks) go to 390
      jc = k3
      go to 450
!  PERMUTATION FOR MULTIVARIATE TRANSFORM
  410 k = kk + jc
  420 ak = a(kk)
      a(kk) = a(k2)
      a(k2) = ak
      bk = b(kk)
      b(kk) = b(k2)
      b(k2) = bk
      kk = kk + inc
      k2 = k2 + inc
      if (kk.lt.k) go to 420
      kk = kk + ks - jc
      k2 = k2 + ks - jc
      if (kk.lt.nt) go to 410
      k2 = k2 - nt + kspan
      kk = kk - nt + jc
      if (k2.lt.ks) go to 410
  430 k2 = k2 - np(j)
      j = j + 1
      k2 = np(j+1) + k2
      if (k2.gt.np(j)) go to 430
      j = 1
  440 if (kk.lt.k2) go to 410
      kk = kk + jc
      k2 = kspan + k2
      if (k2.lt.ks) go to 440
      if (kk.lt.ks) go to 430
      jc = k3
  450 if (2*kt+1.ge.m) return
      kspnn = np(kt+1)
!  PERMUTATION FOR SQUARE-FREE FACTORS OF N
      j = m - kt
      nfac(j+1) = 1
  460 nfac(j) = nfac(j)*nfac(j+1)
      j = j - 1
      if (j.ne.kt) go to 460
      kt = kt + 1
      nn = nfac(kt) - 1
      if (nn.gt.maxp) go to 590
      jj = 0
      j = 0
      go to 490
  470 jj = jj - k2
      k2 = kk
      k = k + 1
      kk = nfac(k)
  480 jj = kk + jj
      if (jj.ge.k2) go to 470
      np(j) = jj
  490 k2 = nfac(kt)
      k = kt + 1
      kk = nfac(k)
      j = j + 1
      if (j.le.nn) go to 480
!  DETERMINE THE PERMUTATION CYCLES OF LENGTH GREATER THAN 1
      j = 0
      go to 510
  500 k = kk
      kk = np(k)
      np(k) = -kk
      if (kk.ne.j) go to 500
      k3 = kk
  510 j = j + 1
      kk = np(j)
      if (kk.lt.0) go to 510
      if (kk.ne.j) go to 500
      np(j) = -j
      if (j.ne.nn) go to 510
      maxf = inc*maxf
!  REORDER A AND B, FOLLOWING THE PERMUTATION CYCLES
      go to 580
  520 j = j - 1
      if (np(j).lt.0) go to 520
      jj = jc
  530 kspan = jj
      if (jj.gt.maxf) kspan = maxf
      jj = jj - kspan
      k = np(j)
      kk = jc*k + ii + jj
      k1 = kk + kspan
      k2 = 0
  540 k2 = k2 + 1
      at(k2) = a(k1)
      bt(k2) = b(k1)
      k1 = k1 - inc
      if (k1.ne.kk) go to 540
  550 k1 = kk + kspan
      k2 = k1 - jc*(k+np(k))
      k = -np(k)
  560 a(k1) = a(k2)
      b(k1) = b(k2)
      k1 = k1 - inc
      k2 = k2 - inc
      if (k1.ne.kk) go to 560
      kk = k2
      if (k.ne.j) go to 550
      k1 = kk + kspan
      k2 = 0
  570 k2 = k2 + 1
      a(k1) = at(k2)
      b(k1) = bt(k2)
      k1 = k1 - inc
      if (k1.ne.kk) go to 570
      if (jj.ne.0) go to 530
      if (j.ne.1) go to 520
  580 j = k3 + 1
      nt = nt - kspnn
      ii = nt - inc + 1
      if (nt.ge.0) go to 520
      return
!  ERROR FINISH, INSUFFICIENT ARRAY STORAGE
  590 isn = 0
      call iprint(iprt)
      write(iprt, 1000)
!
!     NB.  THE FOLLOWING STOP SHOULD BE CHANGED TO A RETURN WHEN
!          THE TIME SERIES ROUTINES ARE MODIFIED FOR STARPAC.
!
      stop
!
!     FORMAT STATEMENTS
!
1000 format (' ', 17('*')/18h * error message */1x, 17('*')//&
    &   45h array bounds exceeded within subroutine fft./&
    &   44h please bring this error to the attention of/&
    &   22h    janet r. donaldson/&
    &   16h    303-497-5114/&
     &   16h    fts 320-5114)
      end
!DCKER
      subroutine dcker(nmsub, n, m, ixm, npar, ldstak, scale, lscale)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE ERROR CHECKING ROUTINE FOR DERIVATIVE CHECKING
!     ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,ldstak,lscale,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   scale(*)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   i,ldsmin,nv
     logical&
     &   head
!
!  LOCAL ARRAYS
     logical&
     &   error(10)
     character&
    &   lixm(8)*1,llds(8)*1,lm(8)*1,ln(8)*1,lnpar(8)*1,&
     &   lscl(8)*1,lzero(8)*1
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL EISGE,EISLE,ERVGT,LDSCMP
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR(10)
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LIXM(8), LLDS(8), LM(8), LN(8), LNPAR(8), LSCL(8),
!    *   LZERO(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND BY THE SCALE CHECKING ROUTINE.
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!
!     SET UP NAME ARRAYS
!
     data lixm(1), lixm(2), lixm(3), lixm(4), lixm(5), lixm(6),&
     &   lixm(7), lixm(8) /'I','X','M',' ',' ',' ',' ',' '/
     data lm(1), lm(2), lm(3), lm(4), lm(5), lm(6), lm(7), lm(8) /'M',&
     &   ' ',' ',' ',' ',' ',' ',' '/
     data llds(1), llds(2), llds(3), llds(4), llds(5),&
    &   llds(6), llds(7), llds(8) /'L','D','S','T','A','K',' ',&
     &   ' '/
     data ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8) /'N',&
     &   ' ',' ',' ',' ',' ',' ',' '/
     data lnpar(1), lnpar(2), lnpar(3), lnpar(4), lnpar(5),&
    &   lnpar(6), lnpar(7), lnpar(8) /'N','P',' ',' ',' ',' ',' ',&
     &   ' '/
     data lscl(1), lscl(2), lscl(3), lscl(4), lscl(5),&
    &   lscl(6), lscl(7), lscl(8) /'S','C','A','L','E',' ',' ',&
     &   ' '/
     data lzero(1), lzero(2), lzero(3), lzero(4), lzero(5),&
     &   lzero(6), lzero(7), lzero(8) /'Z','E','R','O',' ',' ',' ',' '/
!
!     ERROR CHECKING
!
      do 10 i=1,10
         error(i) = .false.
   10 continue
!
      ierr = 0
      head = .true.
!
      call eisge(nmsub, ln, n, 1, 1, head, error(1), ln)
!
      call eisge(nmsub, lm, m, 1, 1, head, error(2), lm)
!
      call eisge(nmsub, lixm, ixm, n, 3, head, error(3), ln)
!
      call eisle(nmsub, lnpar, npar, n, 2, head, error(4), ln)
!
     call ldscmp(5, 0, 2*npar+1, 0, 0, 0, 'S',&
     &            n*npar + npar + n, ldsmin)
!
     if ((.not.error(1)) .and. (.not.error(4)))&
    &   call eisge(nmsub, llds, ldstak, ldsmin, 9, head, error(5),&
     &   llds)
!
     call ervgt(nmsub, lscl, scale, lscale, 0.0e0, 0, head, 6, nv,&
     &   error(9), lzero)
!
      do 20 i=1,10
         if (error(i)) go to 30
   20 continue
      return
!
   30 continue
      ierr = 1
      return
!
      end
!OBSSUM
     subroutine obssum(n, m, xm, y, pv, sdpv, res, sdres, wt, ixm,&
     &   weight, k, ifirst, ilast, jcol1, jcolm)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBOUTINE LISTS THE DATA SUMMARY FOR THE
!     LEAST SQUARES SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29,  1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ifirst,ilast,ixm,jcol1,jcolm,k,m,n
     logical&
     &   weight
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   pv(n),res(n),sdpv(n),sdres(n),wt(n),xm(ixm,m),y(n)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm
     integer&
     &   i,iprt,j
     character&
     &   string*20,fmt1*160,fmt2*160,fmt3*160
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      LOGICAL
!     +   MVCHK
!      EXTERNAL R1MACH,MVCHK
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     CHARACTER*160 FMT1,FMT2,FMT3
!        THE FORMATS USED TO PRINT THE INFORMATION.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS HAVE
!        BEEN DETECTED.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED.
!     INTEGER IFIRST, ILAST
!        THE FIRST AND LAST INDICES TO BE LISTED.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER JCOLM
!        THE LAST COLUMN OF THE INDEPENDENT VARIABLE TO BE PRINTED.
!     INTEGER JCOL1
!        THE FIRST COLUMN OF THE INDEPENDENT VARIABLE TO BE PRINTED.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     REAL PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     CHARACTER*20 STRING
!        CHARACTER STRING USED TO BUILD THE FORMATS.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(N)
!        THE USER SUPPLIED WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
      fplm = r1mach(2)
!
      call iprint(iprt)
!
!     CONSTRUCT FORMAT
!
      if (k.eq.1) then
         string = '1X,I4,15X,G15.8,15X,'
      else if (k.eq.2) then
         string = '1X,I4,7X,2G15.8,8X, '
      else
         string = '1X,I4,3G15.8,       '
      end if
      write (fmt1,1020) string
      write (fmt2,1030) string
      write (fmt3,1040) string
!
      do 140 i=ifirst, ilast
         if (mvchk(sdpv(i),fplm)) then
            if (weight) then
              write (iprt, fmt1) i, (xm(i,j),j=jcol1,jcolm),&
     &                            y(i), pv(i), res(i), wt(i)
            else
              write (iprt, fmt1) i, (xm(i,j),j=jcol1,jcolm),&
     &                            y(i), pv(i), res(i)
            end if
         else
            if (mvchk(sdres(i),fplm)) then
               if (weight) then
                 write (iprt, fmt2) i, (xm(i,j),j=jcol1,jcolm),&
     &                               y(i), pv(i), sdpv(i), res(i), wt(i)
               else
                 write (iprt, fmt2) i, (xm(i,j),j=jcol1,jcolm),&
     &                               y(i), pv(i), sdpv(i), res(i)
               end if
            else
               if (weight) then
                 write (iprt, fmt3) i, (xm(i,j),j=jcol1,jcolm),&
    &                               y(i), pv(i), sdpv(i), res(i),&
     &                               sdres(i), wt(i)
               else
                 write (iprt, fmt3) i, (xm(i,j),j=jcol1,jcolm),&
    &                               y(i), pv(i), sdpv(i), res(i),&
     &                               sdres(i)
               end if
            end if
         end if
  140 continue
!
      return
!
!     FORMAT STATEMENTS
!
 1020 format ('(',a20,'2G16.8,8X,4HNC *,4X,G16.8,4X,4HNC *,1X,E9.3)')
 1030 format ('(',a20,'4G16.8,4X,4HNC *,1X,E9.3)')
 1040 format ('(',a20,'4G16.8,1X,F7.2,1X,E9.3)')
      end
!UFSF
      subroutine ufsf(yfft, n, lyfft, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS USING THE FFT (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,lyfft,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   yfft(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
      real(kind=wp) :: alpha,delta,fmax,fmin,ymiss
     integer&
    &   ifp,iprt,ispcf,lacov,lagmax,ldsmin,lnlppa,lpcv,lwork,&
     &   nall0,nf,nfft,nprt,nw,work
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   acov(101),freq(101),rstak(12),spcf(101,4),xaxis(106),&
     &   yaxis(106)
     integer&
     &   isort(101),isym(106),lags(4),nlppa(1)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LDSCMP,PARZEN,SETESL,SETLAG,STKSET,UFSDRV
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(101)
!        THE AUTOCOVARIANCE AT LAG ZERO (BIASED VARIANCE).
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP = 3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISYM(106)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
!       THIS ROUTINE WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NLPPA(1)
!        A DUMMY ARRAY WHEN THE SERIES DOES NOT CONTAIN MISSING VALUES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL SPCF(101,4)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY WORK.
!     REAL XAXIS(106)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL YFFT(LYFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     REAL YAXIS(106)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL YMISS
!        A DUMMY VARIABLE WHEN THE SERIES DO NOT CONTAIN MISSING VALUES
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'U','F','S','F',' ',' '/
!
!     SET UP
!
      option(4) = .false.
      option(3) = .false.
      option(2) = .false.
      option(1) = .true.
!
!     SET MAXIMUM LAG VALUE TO BE USED.
!     SET EXTENDED SERIES LENGTH.
!     SET NUMBER OF LAG WINDOW TRUNCATION POINTS TO USE.
!
      call setlag(n, lagmax)
      call setesl(n+lagmax, 4, nfft)
      nw = 4
!
      ispcf = 101
      lacov = 101
      lnlppa = 1
      lpcv = 106
      lwork = nfft
      nf = 101
      ymiss = 1.0e0
!
!     COMPUTE MIIMUM ALLOWABLE STACK LENGTH
!
      call ldscmp(1, 0, 0, 0, 0, 0, 'S', nfft, ldsmin)
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!     SET THE STACK ALLOCATION TYPE.
!
      call stkset(ldstak, 4)
      nall0 = stkst(1)
!
      ifp = 3
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
!
      if ((ldsmin.le.ldstak) .and. (ldsmin.ge.7)) then
         work = stkget(lwork,ifp)
      else
         work = 1
      end if
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!     FOR SERIES WITH MISSING DATA.
!
     call ufsdrv(yfft, lyfft, ymiss, acov, nlppa, spcf, ispcf, nf,&
    &   fmin, fmax, freq, n, nw, lagmax, lags, rstak(work), lacov,&
    &   lwork, delta, isort, isym, xaxis, yaxis, lpcv, alpha, nprt,&
     &   parzen, nmsub, ldsmin, ldstak, option, lnlppa, nfft)
!
!     CHECK FOR ERRORS
!
      if (ierr.eq.0) return
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL UFSF (YFFT, N, LYFFT, LDSTAK)')
      end
!XSTPLE
      subroutine xstple(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,exmpt
     integer&
     &   i,iprt,ixm,ldsmin,m,n,neta,npar,nprt,ntest
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   par(10),scale(10),stp(10),xm(200,2)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LDSCMP,MDL4,STPLS,STPLS1,STPLS2,STPLSC
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        *
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL4
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     REAL PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL SCALE(10)
!        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL STP(10)
!        THE SELECTED STEP SIZES FOR EACH PARAMETER.
!     REAL XM(200,2)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      call iprint(iprt)
!
!     SET PARAMETER VALUES
!
      call stpls1(n, m, ixm, par, npar, neta, exmpt, scale, nprt)
      call stpls2(npar, stp)
      call ldscmp(14, 0, 2*(n+npar), 0, 0, 0, 'S', 10*n, ldsmin)
!
      if (ldsmin.le.ldstak) go to 5
!
      write (iprt, 1040) ldsmin
      return
!
    5 continue
!
!     CREATE INDEPENDENT VARIABLE
!
      delta = 0.0625e0
      xm(1,1) = 0.0e0
      do 10 i=2,n
         xm(i,1) = xm(i-1,1) + delta
   10 continue
!
      ntest = 0
!     CHECK ERROR HANDLING
!
!        TEST 1  -  MISCELANEOUS ERROR CHECKING
!
      n = -5
      m = -5
      ixm = -10
      npar = -10
!
!
      ntest = ntest + 1
      write (iprt,1090) ntest
      write (iprt,1020)
      write (iprt,1000)
      ierr = -1
      call stpls(xm, n, m, ixm, mdl4, par, npar, ldstak, stp)
      write (iprt,1050) ierr
      write (iprt,1010)
      ierr = -1
     call stplsc(xm, n, m, ixm, mdl4, par, npar, ldstak, stp, neta,&
     &   exmpt, scale, nprt)
      write (iprt,1050) ierr
!
!        TEST 2  -  MISCELANEOUS ERROR CHECKING (CONTINUED)
!
      call stpls1(n, m, ixm, par, npar, neta, exmpt, scale, nprt)
      scale(2) = 0.0e0
!
      ntest = ntest + 1
      write (iprt,1090) ntest
      write (iprt,1030)
      write (iprt,1000)
      ierr = -1
      call stpls(xm, n, m, ixm, mdl4, par, npar, ldsmin-1, stp)
      write (iprt,1050) ierr
      write (iprt,1010)
      ierr = -1
     call stplsc(xm, n, m, ixm, mdl4, par, npar, ldsmin-1, stp, neta,&
     &   exmpt, scale, nprt)
      write (iprt,1050) ierr
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (15h test of stpls )
 1010 format (15h test of stplsc)
 1020 format (32h check error handling  -  test 1)
 1030 format (32h check error handling  -  test 2)
 1040 format (45h1 *** ldstak must be greater than or equal to , i6)
1050 format (/29h ***** returned results *****, 5x, 15h (-1 indicates ,&
     &   39hvalue not changed by called subroutine)//9h ierr is , i3)
1090 format (54h1derivative step size selection subroutine test number,&
     &   i5)
      end
!SRTRRI
      subroutine srtrri(a, rr, la, ir)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SORTS THE LENGTH LA INTEGER ARRAY IR, THE LENGTH LA
!     ARRAY A, AND THE LENGTH LA ARRAY RR INTO ASCENDING
!     ORDER, BASED ON THE VALUES IN IR.  THE INTEGER ARRAY IR
!     CONSTITUTES THE KEY.  THE OTHER ARRAYS ARE CARRIED ALONG.
!     ORDINARILY THE ARRAY IR CONTAINS THE PERMUTATION VECTOR
!     RESULTING FROM AN APPLICATION OF THE ROUTINE SRTIRR, SO THAT
!     SORTING ON IR RESTORES A TO THE ORDER THAT IT HAD BEFORE
!     SRTIRR WAS APPLIED.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!        (BASED CLOSELY ON THE IMSL CDC LIBRARY 3 ROUTINE VSORTP)
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   la
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   a(la),rr(la)
     integer&
     &   ir(la)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   r,rt,rtt,t,tt
     integer&
     &   i,ij,it,itt,j,k,l,m
!
!  LOCAL ARRAYS
     integer&
     &   il(21),iu(21)
!
!  INTRINSIC FUNCTIONS
      intrinsic int
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL A(LA)
!        INPUT/OUTPUT PARAMETER.  THE ARRAY TO BE SORTED ON
!        THE BASIS OF THE VALUES IN IR.  IF IR IS A PERMUTATION
!        VECTOR PRODUCED ORIGINALLY IN A SORT OF A, THEN THIS
!        OPERATION RESTORES A TO ITS ORIGINAL ORDER.
!     INTEGER I
!        *
!     INTEGER IJ
!        *
!     INTEGER IL(21)
!        *
!     INTEGER IR(LA)
!        INPUT/OUTPUT PARAMETER.  THE INTEGER KEY ARRAY.  ORDINARILY
!        IT WILL BE A PERMUTATION VECTOR PRODUCED BY SOME PREVIOUS
!        SORT OF A AND RR ON A, SO THAT SORTING ON IR WILL RESTORE
!        A TO ITS ORIGINAL ORDER.
!     INTEGER IT
!        *
!     INTEGER ITT
!        *
!     INTEGER IU(21)
!        *
!     INTEGER J
!        *
!     INTEGER K
!        *
!     INTEGER L
!        *
!     INTEGER LA
!        INPUT PARAMETER.  THE LENGTH OF THE INPUT/OUTPUT PARAMETERS
!        A, RR, AND IR.
!     INTEGER M
!        *
!     REAL R
!        *
!     REAL RR(LA)
!        INPUT/OUTPUT PARAMETER.  THE ARRAY CARRIED ALONG IN
!        THE SORT.  IT MIGHT BE THE SET OF WEIGHTS FOR A.
!     REAL RT
!        *
!     REAL RTT
!        *
!     REAL T
!        *
!     REAL TT
!        *
!
      m = 1
      i = 1
      j = la
      r = .375e0
   10 if (i.eq.j) go to 90
      if (r.gt.0.5898437e0) go to 20
      r = r + 3.90625e-2
      go to 30
   20 r = r - .21875e0
   30 k = i
!                                  SELECT A CENTRAL ELEMENT OF THE
!                                  ARRAY AND SAVE IT IN LOCATION IT
      ij = i + int((j-i)*r)
      t = a(ij)
      it = ir(ij)
      rt = rr(ij)
!                                  IF FIRST ELEMENT OF ARRAY IS GREATER
!                                  THAN IT, INTERCHANGE WITH IT
      if (ir(i).le.it) go to 40
      a(ij) = a(i)
      a(i) = t
      t = a(ij)
      ir(ij) = ir(i)
      ir(i) = it
      it = ir(ij)
      rr(ij) = rr(i)
      rr(i) = rt
      rt = rr(ij)
   40 l = j
!                                  IF LAST ELEMENT OF ARRAY IS LESS THAN
!                                  IT, INTERCHANGE WITH IT
      if (ir(j).ge.it) go to 60
      a(ij) = a(j)
      a(j) = t
      t = a(ij)
      ir(ij) = ir(j)
      ir(j) = it
      it = ir(ij)
      rr(ij) = rr(j)
      rr(j) = rt
      rt = rr(ij)
!                                  IF FIRST ELEMENT OF ARRAY IS GREATER
!                                  THAN IT, INTERCHANGE WITH IT
      if (ir(i).le.it) go to 60
      a(ij) = a(i)
      a(i) = t
      t = a(ij)
      ir(ij) = ir(i)
      ir(i) = it
      it = ir(ij)
      rr(ij) = rr(i)
      rr(i) = rt
      rt = rr(ij)
      go to 60
   50 tt = a(l)
      a(l) = a(k)
      a(k) = tt
      itt = ir(l)
      ir(l) = ir(k)
      ir(k) = itt
      rtt = rr(l)
      rr(l) = rr(k)
      rr(k) = rtt
!                                  FIND AN ELEMENT IN THE SECOND HALF OF
!                                  THE ARRAY WHICH IS SMALLER THAN IT
   60 l = l - 1
      if (ir(l).gt.it) go to 60
!                                  FIND AN ELEMENT IN THE FIRST HALF OF
!                                  THE ARRAY WHICH IS GREATER THAN IT
   70 k = k + 1
      if (ir(k).lt.it) go to 70
!                                  INTERCHANGE THESE ELEMENTS
      if (k.le.l) go to 50
!                                  SAVE UPPER AND LOWER SUBSCRIPTS OF
!                                  THE ARRAY YET TO BE SORTED
      if (l-i.le.j-k) go to 80
      il(m) = i
      iu(m) = l
      i = k
      m = m + 1
      go to 100
   80 il(m) = k
      iu(m) = j
      j = l
      m = m + 1
      go to 100
!                                  BEGIN AGAIN ON ANOTHER PORTION OF
!                                  THE UNSORTED ARRAY
   90 m = m - 1
      if (m.eq.0) return
      i = il(m)
      j = iu(m)
  100 if (j-i.ge.1) go to 30
      if (i.eq.1) go to 10
      i = i - 1
  110 i = i + 1
      if (i.eq.j) go to 90
      t = a(i+1)
      it = ir(i+1)
      rt = rr(i+1)
      if (ir(i).le.it) go to 110
      k = i
  120 a(k+1) = a(k)
      ir(k+1) = ir(k)
      rr(k+1) = rr(k)
      k = k - 1
      if (it.lt.ir(k)) go to 120
      a(k+1) = t
      ir(k+1) = it
      rr(k+1) = rt
      go to 110
      end
!NLCMP
     subroutine nlcmp (y, weight, wt, lwt, n, npar, npare,&
    &   res, d, rd, cond, vcvl, lvcvl, nnzw, idf, rsshlf, rss, rsd,&
     &   yss, exact, pvt, sdpvt, sdrest, iskull)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES VARIOUS STATISTICS AND VALUES RETURNED
!     AND/OR PRINTED BY THE NLS FAMILY OF ROUTINES WHEN WEIGHTS ARE
!     INVOLVED.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   cond,rsd,rss,rsshlf,yss
     integer&
     &   idf,lvcvl,lwt,n,nnzw,npar,npare
     logical&
     &   exact,weight
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   d(n,npar),pvt(n),rd(n),res(n),sdpvt(n),sdrest(n),vcvl(lvcvl),&
     &   wt(lwt),y(n)
     integer&
     &   iskull(10)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fac,fplm,rvar,sm,tj,wti,wtsum,ywtsm,ywtysm
     integer&
     &   i,j,jk,k
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
!       EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL FITEXT
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max,sqrt
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL COND
!        THE CONDITION NUMBER OF D.
!     REAL D(N,NPAR)
!        THE FIRST DERIVATIVE OF THE MODEL (JACOBIAN).
!     LOGICAL EXACT
!        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
!        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
!     REAL FAC
!        A FACTOR USED TO CORRECT FOR ZERO WEIGHTED OBSERVATIONS IN
!        THE VARIANCE COVARIANCE COMPUTATION.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IDF
!        THE DEGREES OF FREEDOM IN THE FIT.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER ISKULL(10)
!        AN ERROR MESSAGE INDICATOR VARIABLE.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER JK
!        THE INDEX OF THE (J,K)TH ELEMENT OF THE VARIANCE-COVARIANCE
!        MATRIX.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER LVCVL
!        THE DIMENSION OF VECTOR VCVL.
!     INTEGER LWT
!        THE DIMENSION OF VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     REAL PVT(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
!     REAL RD(N)
!        THE DIAGONAL ELEMENTS OF THE R MATRIX OF THE Q - R
!        FACTORIZATION OF D.
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     REAL RSS
!        THE RESIDUAL SUM OF SQUARES.
!     REAL RSSHLF
!        HALF THE RESIDUAL SUM OF SQUARES.
!     REAL RVAR
!        THE RESIDUAL VARIANCE.
!     REAL SDPVT(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDREST(N)
!        THE STANDARDIZED RESIDUALS.
!     REAL SM
!        A VARIABLE USED FOR SUMMATION.
!     REAL TJ
!        ...
!     REAL VCVL(LVCVL)
!        THE LOWER HALF OF THE VARIANCE-COVARIANCE MATRIX, STORED
!        ROW WISE.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     REAL WTI
!        THE ACTUAL WEIGHT USED FOR THE ITH OBSERVATION.
!     REAL WTSUM
!        THE SUM OF THE WEIGHTS.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!     REAL YSS
!        THE SUM OF THE SQUARES ABOUT THE MEAN Y VALUE.
!     REAL YWTSM
!        THE SUM OF THE VALUES Y(I)*WT(I), I=1,N.
!     REAL YWTYSM
!        THE SUM OF THE VALUES Y(I)*WT(I)*WT(I), I=1,N.
!
      fplm = r1mach(2)
!
!     COMPUTE RESIDUALS
!
      do 10 i=1,n
         res(i) = y(i) - pvt(i)
   10 continue
!
!     COMPUTE VARIOUS STATISTICS
!
      idf = nnzw - npare
      rss = 2.0e0*rsshlf
      rvar = 0.0e0
      if (idf.ge.1) rvar = rss/idf
      rsd = sqrt(rvar)
      ywtsm = 0.0e0
      ywtysm = 0.0e0
      wtsum = 0.0e0
      do 20 i=1,n
         wti = 1.0e0
         if (weight) wti = wt(i)
         ywtsm = ywtsm + y(i)*wti
         ywtysm = ywtysm + y(i)*wti*y(i)
         wtsum = wtsum + wti
   20 continue
      yss = max(ywtysm-(ywtsm*ywtsm)/wtsum,0.0e0)
!
      call fitext(rss, yss, exact)
!
      cond = fplm
      if (rd(npare).ne.0.0e0) cond = abs(rd(1)/rd(npare))
!
      if (ierr.ne.0) return
!
!     CORRECT FOR DEGREES OF FREEDOM IF NECESSARY BECAUSE OF ZERO
!     WEIGHTED OBSERVATIONS.
!
      if (n.eq.nnzw) go to 40
!
      fac = n-npare
      if (idf.ge.1) fac = fac/idf
      do 30 i=1,lvcvl
         vcvl(i) = vcvl(i)*fac
   30 continue
!
   40 continue
!
!     IF THE RESIDUAL SUM OF SQUARES IS IDENTICALLY ZERO, THEN
!     NO FURTHER COMPUTATIONS ARE NECESSARY
!
      if ((idf.le.0) .or. exact) return
!
!     IF THE STANDARD DEVIATIONS OF THE PREDICTED VALUES AND
!     STANDARDIZED RESIDUALS ARE NOT SAVED OR PRINTED, THEN NO
!     FURTHER COMPUTATIONS ARE NECESSARY.
!
!     COMPUTE THE STANDARD DEVIATIONS OF THE PREDICTED VALUES (SDPVT)
!
      do 90 i=1,n
         sm = 0.0e0
         do 60 j=1,npare
            tj = 0.0e0
            do 50 k=1,npare
               if (j.ge.k) then
                  jk = j*(j-1)/2 + k
               else
                  jk = k*(k-1)/2 + j
               end if
               tj = tj + vcvl(jk)*d(i,k)
   50       continue
               sm = sm + d(i,j)*tj
   60    continue
         if (sm.lt.0.0e0) sm = 0.0e0
         sdpvt(i) = sqrt(sm)
!
         sdrest(i) = fplm
         wti = 1.0e0
         if (weight) wti = wt(i)
         if (wti.eq.0.0e0) go to 90
!
         if (rvar/wti-sm.le.0.0e0) go to 70
         go to 80
!
!           THEN
!
   70    sdrest(i) = fplm
         iskull(1) = 1
         iskull(4) = 1
         ierr = 4
         go to 90
!
!           ELSE
!
   80    sdrest(i) = res(i)/sqrt(rvar/wti-sm)
!
!        END IF
!
   90 continue
!
      return
!
      end
!STATER
      subroutine stater(nmsub, wt, n, ldstak, wts, nnzw, stack, ierr)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE CHECKS INPUT PARAMETERS TO THE USER
!     CALLABLE MEMBERS OF THE STAT FAMILY OF ROUTINES
!     FOR ERRORS AND REPORTS ANY THAT IT FINDS, BESIDES
!     RETURNING A FLAG INDICATING THAT ERRORS HAVE BEEN
!     FOUND.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ierr,ldstak,n,nnzw
     logical&
     &   stack,wts
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   wt(*)
     character&
     &   nmsub(6)*1
!
!  LOCAL SCALARS
     integer&
     &   ldsmin,nzw
     logical&
     &   head,ier1,ier2,ier3
!
!  LOCAL ARRAYS
     character&
     &   llds(8)*1,ln(8)*1,lthree(8)*1,lwt(8)*1
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL EISGE,ERVWT,LDSCMP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        OUTPUT PARAMETER.  A FLAG INDICATING WHETHER OR
!        NOT AN ERROR HAS BEEN FOUND.  0 = OK, 1 = ERROR.
!     LOGICAL IER1
!        TRUE IF N .LT. 3
!     LOGICAL IER2
!        TRUE IF LDSTAK .LT. (N + 13)/2.0E0
!     LOGICAL IER3
!        TRUE IF SOME WT .LT. 0.0E0 OR NNZW .LT. 3
!     INTEGER LDSMIN
!        MINIMUM LENGTH OF FRAMEWORK AREA IN DOUBLE
!        PRECISION ELEMENTS.
!     INTEGER LDSTAK
!        INPUT PARAMETER.  THE NUMBER OF LOCATIONS PROVIDED IN
!        THE FRAMEWORK AREA.
!     CHARACTER*1 LLDS(8), LN(8), LTHREE(8), LWT(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) FO THE VARIALBE(S) CHECKED
!        FOR ERRORS
!     INTEGER N
!        INPUT PARAMETER.  THE NUMBER OF ELEMENTS IN Y AND WT.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE
!     INTEGER NNZW
!        OUTPUT PARAMETER.  IF WTS, THEN SET EQUAL TO THE
!        NUMBER OF VALUES IN WT WHICH ARE POSITIVE.  ELSE,
!        UNDEFINED.
!     INTEGER NZW
!        THE NUMBER OF ZERO WEIGHTS.
!     LOGICAL STACK
!        A FLAG INDICATING WHETHER THIS ROUTINE USES THE STACK (TRUE)
!        OR NOT (FALSE).
!     REAL WT(N)
!        INPUT PARAMETER.  THE VECTOR OF WEIGHTS CORRESPONDING
!        TO THE VECTOR Y.
!     LOGICAL WTS
!        INPUT PARAMETER.  A FLAG INDICATING WHETHER OR NOT
!        THERE IS REALLY A VECTOR WT (TRUE), OR ONLY A DUMMY PARAMETER
!        (FALSE).
!
!     INITIALIZE NAME VECTORS
!
     data llds(1), llds(2), llds(3), llds(4), llds(5), llds(6),&
     &  llds(7), llds(8) / 'L', 'D', 'S', 'T', 'A', 'K', ' ', ' '/
     data     ln(1),    ln(2),    ln(3),    ln(4),    ln(5),    ln(6),&
     &  ln(7), ln(8)  / 'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
     data lthree(1),lthree(2),lthree(3),lthree(4),lthree(5),lthree(6),&
     &  lthree(7), lthree(8) / 'T', 'H', 'R', 'E', 'E', ' ', ' ', ' '/
     data    lwt(1),   lwt(2),   lwt(3),   lwt(4),   lwt(5),   lwt(6),&
     &  lwt(7), lwt(8) / 'W', 'T', ' ', ' ', ' ', ' ', ' ', ' '/
!
!     INITIALIZE ERROR FLAGS
!
      ier1 = .false.
      ier2 = .false.
      ier3 = .false.
!
      ierr = 0
!
      head = .true.
!
!     CHECK TO SEE THAT THERE ARE AT LEAST THREE DATA POINTS.
!
      call eisge(nmsub, ln, n, 3, 2, head, ier1, lthree)
!
!     CHECK TO SEE THAT AN AMOUNT OF WORK AREA EQUAL
!     IN LENGTH TO THE REQUIREMENTS OF THE PERMUTATION
!     VECTOR WILL BE AVAILABLE.
!
      if (stack) then
         call ldscmp(1, 0, n, 0, 0, 0, 'S', 0, ldsmin)
         call eisge(nmsub, llds, ldstak, ldsmin, 9, head, ier2, llds)
      end if
!
!     IF THERE ARE WEIGHTS
!     CHECK TO SEE THAT AT LEAST THREE DATA ITEMS HAVE NONZERO WEIGHTS.
!
      nnzw = n
      if (wts) then
        call ervwt(nmsub, lwt, wt, n, 3, head, nnzw, nzw, 1, ier3,&
     &              lthree)
      end if
!
!     SEE IF ANY ERRORS WERE FOUND.
!
      if (ier1 .or. ier2 .or. ier3) ierr = 1
      return
      end
!CCVFM
     subroutine ccvfm(y1, y1miss, y2, y2miss, n, nc, y1mean, y2mean,&
     &   ccov12, ccov21, iccov, nlpp12, nlpp21)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE CROSS COVARIANCE FUNCTION
!     BETWEEN TWO SERIES WHEN MISSING DATA ARE INVOLVED.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   y1mean,y1miss,y2mean,y2miss
     integer&
     &   iccov,n,nc
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ccov12(iccov),ccov21(iccov),y1(n),y2(n)
     integer&
     &   nlpp12(iccov),nlpp21(iccov)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   dotxy,fplm
     integer&
     &   lag,ndotxy
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
!       EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL DOTCM
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCOV12(ICCOV), CCOV21(ICCOV)
!        THE ARRAYS IN WHICH THE CCVF FOR SERIES 1 LAGGED
!        BEHIND SERIES 2 AND VISA VERSA, RESPECTIVELY, ARE
!        STORED.
!     REAL DOTXY
!        VARIOUS CROSS PRUDUCTS BETWEEN SERIES Y1 AND Y2.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER ICCOV
!        THE ROW DIMENSION OF THE ARRAYS CCOV12 AND CCOV21.
!     INTEGER LAG
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCORRELATION BEING COMPUTED.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NC
!        THE NUMBER OF CROSS CORRELATIONS DESIRED.
!     INTEGER NLPP12(ICCOV), NLPP21(ICCOV)
!        THE NUMBER OF LAGGED PRODUCT PAIRS USED TO COMPUTE THE CCVF
!        FOR EACH PAIR OF SERIES AT EACH LAG.
!     INTEGER NDOTXY
!        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY.
!     REAL Y1(N), Y1MEAN, Y1MISS
!        THE FIRST SERIES, AND ITS MEAN, AND MISSING VALUE CODE.
!     REAL Y2(N), Y2MEAN, Y2MISS
!        THE SECOND SERIES, AND ITS MEAN, AND MISSING VALUE CODE.
!
      fplm = r1mach(2)
!
!     COMPUTE THE CROSS COVARIANCES
!
     call dotcm (y1, y1mean, y1miss, n, y2, y2mean, y2miss, n, dotxy,&
     &   ndotxy)
!
      nlpp12(1) = ndotxy
      ccov12(1) = fplm
      if (ndotxy .ge. 1) ccov12(1) = dotxy / ndotxy
!
      ccov21(1) = ccov12(1)
      nlpp21(1) = ndotxy
!
      do 10 lag = 1, nc
!
        call dotcm (y1, y1mean, y1miss, n, y2(lag+1), y2mean, y2miss,&
     &       n-lag, dotxy, ndotxy)
!
         nlpp12(lag+1) = ndotxy
         ccov12(lag+1) = fplm
        if (ndotxy .ge. 1)&
     &      ccov12(lag+1) = dotxy * (n-lag) / (n*ndotxy)
!
        call dotcm (y2, y2mean, y2miss, n, y1(lag+1), y1mean, y1miss,&
     &      n-lag, dotxy, ndotxy)
!
         nlpp21(lag+1) = ndotxy
         ccov21(lag+1) = fplm
        if (ndotxy .ge. 1)&
     &      ccov21(lag+1) = dotxy * (n-lag) / (n*ndotxy)
!
   10 continue
!
      return
      end
!MPPMC
     subroutine mppmc(ym, ymmiss, x, xmiss, n, m, iym, ilog, isize,&
     &   nout, ylb, yub, xlb, xub)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH MULTIPLE Y-AXIS VALUES AND WITH MISSING
!     OBSERVATIONS (LONG CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   xlb,xmiss,xub,ylb,yub
     integer&
     &   ilog,isize,iym,m,n,nout
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),ym(*),ymmiss(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iprt,ischck,lisym
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(N,M)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(M)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'M',       'P',       'P',       'M',       'C',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      multi = .true.
      ischck = 2
      miss = .true.
      lisym = 1
!
     call ppcnt (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL MPPMC (YM, YMMISS, X, XMISS, N, M, IYM, ILOG,'/&
     &   '      +            ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      end
!NLMN
subroutine nlmn(y, weight, nnzw, wt, lwt, xm, n, m, ixm, mdl,&
    &   nldrv, aprxdv, drv, ifixd, par, pare, npar, res, page, wide,&
    &   hlfrpt, stp, lstp, mit, stopss, stopp, scale, lscale, delta,&
    &   ivaprx, iptout, ndigit, rsd, pv, sdpvi, sdresi, vcvl, lvcvl, d,&
    &   iwork, iiwork, rwork, irwork, nlhdr, npare)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLING SUBROUTINE FOR PERFORMING NONLINEAR
!     LEAST SQUARES REGRESSION USING THE NL2 SOFTWARE PACKAGE
!     (IMPLEMENTING THE METHOD OF DENNIS, GAY AND WELSCH).
!     THIS SUBROUTINE WAS ADAPTED FROM SUBROUTINE NL2SOL.
!
!     REFERENCES
!
!     DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1979), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, (BEING REVISED).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
   real(kind=wp) :: delta,rsd,stopp,stopss
   integer iiwork,irwork,ivaprx,ixm,lscale,lstp,lvcvl,lwt,m,mit,n,ndigit,nnzw,npar,npare,sdpvi,sdresi,vcvl
   logical aprxdv,hlfrpt,page,weight,wide
!
!  ARRAY ARGUMENTS
   real(kind=wp) :: d(n,npar),par(npar),pare(npar),pv(n),res(n),rwork(irwork),scale(lscale),stp(lstp),wt(lwt),xm(ixm,m),y(n)
   integer ifixd(npar),iptout(ndigit),iwork(iiwork)
!
!  SUBROUTINE ARGUMENTS
   external drv,mdl,nldrv,nlhdr
!
!  SCALARS IN COMMON
   integer ierr
!
!  LOCAL SCALARS
   real(kind=wp) :: wtsqrt
   integer cnvcod,covmat,i,icnvcd,ivcvpt,qtr,rd,rdi,rsave,rsshlf,s,scl
   logical cmpdrv,done,head,newitr,prtsmy
!
!  LOCAL ARRAYS
   integer iskull(10)
!
!  EXTERNAL SUBROUTINES
!  EXTERNAL NL2ITR,NLERR,NLFIN,NLINIT,NLISM,NLITRP,NLSUPK
!
!  INTRINSIC FUNCTIONS
   intrinsic sqrt
!
!  COMMON BLOCKS
   common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL CMPDRV
!        THE VARIABLE USED TO INDICATE WHETHER DERIVATIVES MUST BE
!        COMPUTED (TRUE) OR NOT (FALSE).
!     INTEGER CNVCOD
!        A VALUE USED TO CONTROL THE PRINTING OF ITERATION REPORTS.
!     INTEGER COVMAT
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
!        OF THE BEGINNING OF THE VCV MATRIX.
!     REAL(KIND=WP) :: D(N,NPAR)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
!     REAL(KIND=WP) :: DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     LOGICAL DONE
!        THE VARIABLE USED TO INDICATE WHETHER THIS IS THE FINAL
!        COMPUTATION OF THE JACOBIAN OR NOT.
!     LOGICAL HEAD
!        THE VARIABLE USED TO INDICATE WHETHER A HEADING IS TO BE
!        PRINTED DURING A GIVEN CALL TO THE ITERATION REPORT (TRUE)
!        OR NOT (FALSE).
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER ICNVCD
!        THE LOCATION IN IWORK OF
!        THE CONVERGENCE CONDITION.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IIWORK
!        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
!     INTEGER IPTOUT(NDIGIT)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER IRWORK
!        THE DIMENSION OF THE REAL WORK VECTOR RWORK.
!     INTEGER ISKULL(10)
!        AN ERROR MESSAGE INDICATOR VARIABLE.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCVPT
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
!        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
!        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)
!        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                       *INVERSE(HESSIAN)
!     INTEGER IWORK(IIWORK)
!        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LVCVL
!        THE LENGTH OF THE VECTOR CONTAINING
!        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     LOGICAL NEWITR
!        A FLAG USED TO INDICATE WHETHER A NEW ITERATION HAS BEEN
!        COMPLETED (TRUE) OR NOT (FALSE).
!     EXTERNAL NLDRV
!        THE NAME OF THE ROUTINE WHICH CALCULATED THE DERIVATIVES
!     EXTERNAL NLHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL(KIND=WP) :: PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL(KIND=WP) :: PARE(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS, BUT ONLY
!        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
!     LOGICAL PRTSMY
!        THE VARIABLE USED TO INDICATE WHETHER THE SUMMARY
!        INFORMATION IS TO BE PRINTED (TRUE) OR NOT (FALSE).
!     REAL(KIND=WP) :: PV(N)
!        THE PREDICTED VALUES.
!     INTEGER QTR
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
!        THE ARRAY Q TRANSPOSE R.
!     INTEGER RD
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK OF
!        THE DIAGONAL ELEMENTS OF THE R MATRIX OF THE Q - R
!        FACTORIZATION OF D.
!     INTEGER RDI
!        THE LOCATION IN RWORK OF THE DIAGONAL ELEMENTS OF THE R
!        MATRIX OF THE Q - R FACTORIZATION OF D.
!     REAL(KIND=WP) :: RES(N)
!        THE RESIDUALS FROM THE FIT.
!     INTEGER RSAVE
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
!        THE ARRAY RSAVE.
!     REAL(KIND=WP) :: RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     INTEGER RSSHLF
!        THE LOCATION IN RWORK OF
!        HALF THE RESIDUAL SUM OF SQUARES.
!     REAL(KIND=WP) :: RWORK(IRWORK)
!        THE REAL WORK VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER S
!        THE LOCATION IN IWORK OF THE STARTING LOCATION IN RWORK
!        THE ARRAY OF SECOND ORDER TERMS OF THE HESSIAN.
!     REAL(KIND=WP) :: SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     INTEGER SCL
!        THE INDEX IN RWORK OF THE 1ST VALUE OF THE USER SUPPLIED SCALE
!        VALUE.
!     INTEGER SDPVI
!        THE STARTING LOCATION IN RWORK OF
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     INTEGER SDRESI
!        THE STARTING LOCATION IN RWORK OF THE
!        THE STANDARDIZED RESIDUALS.
!     REAL(KIND=WP) :: STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!        PREDICTED DECREASE IN THE RESIDUAL STANDARD DEVIATION (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL(KIND=WP) :: STOPSS
!        THE STOPPING CRITERION FORTHE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL(KIND=WP) :: STP(LSTP)
!        THE DUMMY STEP SIZE ARRAY.
!     INTEGER VCVL
!        THE STARTING LOCATION IN RWORK OF THE LOWER HALF OF THE
!        VCV MATRIX, STORED ROW WISE.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL(KIND=WP) :: WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     REAL(KIND=WP) :: WTSQRT
!        THE SQUARE ROOT OF THE USER SUPPLIED WEIGHTS.
!     REAL(KIND=WP) :: XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL(KIND=WP) :: Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     IWORK SUBSCRIPT VALUES
!
     data cnvcod /34/, icnvcd /1/, covmat /26/, qtr /49/, rd /51/, rsave /52/, s/53/
      data rsshlf /10/
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
!     INITIALIZE CONTROL PARAMETERS
!
   call nlinit(n,ifixd,par,npar,pare,npare,mit,stopss,stopp,scale,lscale,delta,ivaprx,aprxdv,ivcvpt,iwork,iiwork,rwork,irwork,scl)
!
      cmpdrv = .true.
      done = .false.
      head = .true.
      newitr = .false.
      prtsmy = (iptout(1).ne.0)
!
!
!     COMPUTE RESIDUALS
!
   10 call mdl(par, npar, xm, n, m, ixm, pv)
!
      do 20 i=1,n
         wtsqrt = 1.0_wp
         if (weight) wtsqrt = sqrt(wt(i))
         res(i) = wtsqrt*(y(i)-pv(i))
   20 continue
!
!     PRINT INITIAL SUMMARY
!
      if (.not.prtsmy) go to 30
     call nlism(nlhdr, page, wide, hlfrpt, npar, m, n, nnzw, weight,&
    &   ifixd, par, scale, iwork, iiwork, rwork, irwork, res, aprxdv,&
     &   stp, lstp, npare)
      prtsmy = .false.
!
   30 continue
!
      if (.not.cmpdrv) go to 50
!
      cmpdrv = .false.
!
   40 continue
!
!     PRINT ITERATION REPORT IF DESIRED
!
     if ((iptout(2).ne.0) .and. newitr) call nlitrp(nlhdr, head, page,&
    &   wide, iptout(2), npar, nnzw, iwork, iiwork, rwork, irwork,&
     &   ifixd, pare, npare)
!
!  ***  COMPUTE JACOBIAN  ***
!
      if (done) call mdl(par, npar, xm, n, m, ixm, pv)
!
     call nldrv (mdl, drv, done, ifixd, par, npar, xm, n, m, ixm,&
     &   pv, d, weight, wt, lwt, stp, lstp, rwork(scl), npare)
!
      if (done) go to 70
!
!     COMPUTE NEXT ITERATION
!
   50 continue
!          nl2itr(d(p),       iv(*),    j(nn,p), n, nn, p,     r(n), v(*),  x(p))
      call nl2itr(rwork(scl), iwork(:), d(:,:),  n, n,  npare, res,  rwork, pare)
!
!     UNPACK PARAMETERS
!
      call nlsupk(pare, npare, par, ifixd, npar)
!
      newitr = (iwork(cnvcod).eq.0)
      if (iwork(1)-2) 10, 40, 60
!
   60 done = .true.
      go to 40
   70 continue
!
!     SET ERROR FLAGS, IF NECESSARY
!
      call nlerr(iwork(icnvcd), iskull)
!
!     FINISH COMPUTATIONS AND PRINT ANY DESIRED RESULTS
!
!     EQUIVALENCE LOCATIONS WITHIN RWORK.
!
      sdpvi = iwork(rsave)
      sdresi = iwork(qtr)
      vcvl = iwork(covmat)
      if (vcvl.ge.1) go to 80
!
      vcvl = iwork(s)
      if (ierr.ne.0) go to 80
      iskull(1) = 1
      iskull(7) = 1
      ierr = 7
!
   80 continue
!
      lvcvl = npare*(npare+1)/2
!
      rdi = iwork(rd)
!
     call nlfin(y, weight, nnzw, wt, lwt, xm, n, m, ixm, ifixd, par,&
    &   npar, npare, res, page, wide, iptout, ndigit, rwork(rsshlf),&
    &   rsd, pv, rwork(sdpvi), rwork(sdresi), rwork(rdi), rwork(vcvl),&
     &   lvcvl, d, nlhdr, ivcvpt, iskull)
!
end subroutine nlmn
!VPML
      subroutine vpml(ym, ymiss, n, ns, ilog)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA (LOG PLOT OPTION).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: ymiss
     integer&
     &   ilog,n,ns
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ibar,iprt,irlin,ischck,isize,iym,lisym,m
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
      real(kind=wp) :: ymmiss(1)
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMISS
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  ' ',       'V',       'P',       'M',       'L',       ' '/
!
!     SET DEFAULT VALUES
!
      ymmiss=ymiss
      m = 1
      iym = n
      multi = .false.
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 1.0e0
      xinc = 1.0e0
      ischck = 0
      isize = -1
      miss = .true.
      lisym = 1
      irlin = -1
      ibar = 0
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ymmiss, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &  '       CALL VPML (Y, YMISS, N, NS, ILOG)')
      end
!PPCNT
     subroutine ppcnt (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLING ROUTINE FOR USER CALLED PAGE PLOT ROUTINES
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   xlb,xmiss,xub,ylb,yub
     integer&
     &   ilog,ischck,isize,iym,lisym,m,n,nout
     logical&
     &   miss,multi
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),ym(*),ymmiss(*)
     integer&
     &   isym(*)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xmn,xmx,ymn,ymx
     logical&
     &   error,xcheck
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL PLTCHK,PPLMT,PPMN,VERSP
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        A VALUE INDICATING WHETHER AN ERROR WAS DETECTEC (TRUE)
!        OR NOT (FALSE).
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(LISYM)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING, NOT USED IN SOME CASES
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     LOGICAL XCHECK
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER X-AXIS VALUES
!        ARE TO BE CHECKED (XCHECK = .TRUE.) OR NOT (XCHECK = .FALSE.)
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XMN, XMX
!        THE X-AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(IYM,M)
!        VECTOR OF OBSERVATIONS FOR THE Y (VERTICAL) COORDINATES
!     REAL YMMISS(M)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YMN, YMX
!        THE Y-AYIS LOWER AND UPPER LIMITS ACTUALLY USED.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     COMMENCE BODY OF ROUTINE
!
      xcheck = .true.
     call pltchk (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
     &   ylb, yub, xlb, xub, nmsub, miss, xcheck)
!
      if (ierr.eq.0) then
!
!       DETERMINE THE BOUNDS FOR THE X AND Y AXIS AND COMPLETE ERROR
!       CHECKING
!
       call pplmt (ym, ymmiss, x, xmiss, n, m, iym, ylb, yub, ymn, ymx,&
     &    xlb, xub, xmn, xmx, error, nmsub, miss)
!
        if (error) then
          ierr = 1
        else
!
!       PRINT PLOT
!
        if (isize.le.9) then
          call versp(.true.)
        else
          call versp(.false.)
        end if
       call ppmn (ym, ymmiss, x, xmiss, n, m, iym, ischck, isym,&
     &    lisym, isize, nout, ymn, ymx, xmn, xmx, miss, ilog)
!
        end if
      end if
!
      return
!
      end
!FLTSL
      subroutine fltsl (y, n, k, h, yf, nyf)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE FILTERS THE INPUT SERIES Y USING THE K TERMS
!     OF H, COPYING THE FILTERED SERIES INTO YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   k,n,nyf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   h(k),y(n),yf(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   temp
     integer&
     &   i,i1,ihm,ihp,ikmid,im,ip,j,khalf,kmid
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL H(K)
!        THE ARRAY IN WHICH THE FILTER COEFFICIENTS ARE STORED.
!     INTEGER I, IHM, IHP, IKMID, IM, IP
!        INDEXING VARIABLES.
!     INTEGER J
!        AN INDEXING VARIABLE.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS.
!     INTEGER KHALF, KMID
!        THE HALF LENGTH OF THE FILTER AND THE MIDPOINT OF THE FILTER.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     REAL TEMP
!        A TEMPORY STORAGE LOCATION.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
      do 10 i = 1, n
         yf(i) = y(i)
   10 continue
!
      nyf = n - (k - 1)
!
      khalf = (k - 1) / 2
!
      kmid = khalf + 1
!
      do 30 i = 1, nyf
         ikmid = i + khalf
         temp = h(kmid) * yf(ikmid)
         do 20 j = 1, khalf
            ip = ikmid + j
            ihp = kmid + j
            im = ikmid - j
            ihm = kmid - j
            temp = temp + h(ihp)*yf(ip) + h(ihm)*yf(im)
   20    continue
         yf(i) = temp
   30 continue
!
      i1 = nyf + 1
!
      do 40 i = i1, n
         yf(i) = 0.0e0
   40 continue
      return
      end
!SUMWDS
     subroutine sumwds(x, w, n, lo, mid, hi, xmeanw, sumda, sumwd2,&
     &   sumd2, sumd3, sumd4)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO CALCULATE WEIGHTED AND UNWEIGHTED SUMS
!     OF POWERS OF DIFFERENCES FROM THE WEIGHTED MEAN FOR A
!     SORTED VECTOR IN WHICH THE MIDTH ELEMENT IS THE ELEMENT
!     CLOSEST TO ZERO.  USED BY THE STAT FAMILY.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   sumd2,sumd3,sumd4,sumda,sumwd2,xmeanw
     integer&
     &   hi,lo,mid,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   w(n),x(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   diff
     integer&
     &   curhi,curlo,i,irev
!
!  INTRINSIC FUNCTIONS
      intrinsic abs
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CURHI
!        THE UPPER BOUND OF THE CURRENT INTERVAL.
!     INTEGER CURLO
!        THE LOWER BOUND OF THE CURRENT INTERVAL.
!     REAL DIFF
!        THE DIFFERENCES BETWEEN X(I) AND XMEANW.
!     INTEGER HI
!        INPUT PARAMETER.  THE UPPER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER I
!        A LOOP PARAMETER.
!     INTEGER IREV
!        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
!        IN THE REVERSE ORDER.
!     INTEGER LO
!        INPUT PARAMETER.  THE LOWER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER MID
!        INPUT PARAMETER.  THE INDEX OF THE ELEMENT IN X CLOSEST TO
!        ZERO IN VALUE.  THE POINT OUT FROM WHICH THE SUMMING IS
!        DONE.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
!     REAL SUMDA
!        OUTPUT PARAMETER.  THE SUM OF THE ABSOLUTE VALUES OF THE
!        DIFFERENCES DIFF.
!     REAL SUMD2
!        OUTPUT PARAMETER.  THE SUM OF THE SQUARES OF THE
!        DIFFERENCES DIFF.
!     REAL SUMD3
!        OUTPUT PARAMETER.  THE SUM OF THE CUBES OF THE
!        DIFFERENCES DIFF.
!     REAL SUMD4
!        OUTPUT PARAMETER.  THE SUM OF THE HYPERCUBES OF THE
!        DIFFERENCES DIFF.
!     REAL SUMWD2
!        OUTPUT PARAMETER.  THE WEIGHTED SUM OF THE SQUARES OF
!        THE DIFFERENCES DIFF.
!     REAL W(N)
!        INPUT PARAMETER.  THE ARRAY OF WEIGHTS.
!     REAL X(N)
!        INPUT PARAMETER.  THE DATA ARRAY X IN WHICH THE SUMS ARE TAKEN.
!     REAL XMEANW
!        INPUT PARAMETER.  THE WEIGHTED MEAN OF X.
!
!     INITIALIZE SUMMATION VARIABLES.
!
      sumda = 0.0e0
      sumwd2 = 0.0e0
      sumd2 = 0.0e0
      sumd3 = 0.0e0
      sumd4 = 0.0e0
      if (w(mid).eq.0.0e0) go to 10
      diff = x(mid) - xmeanw
      sumda = abs(diff)
      sumwd2 = w(mid)*diff*diff
      sumd2 = diff*diff
      sumd3 = diff*diff*diff
      sumd4 = diff*diff*diff*diff
   10 curlo = mid - 1
      curhi = mid + 1
!
!     SUM OUTWARDS, BOULDER, COLORADO FROM THE VALUE NEAREST ZERO.  THAT
!     THE LEAST IN MAGNITUDE TO THE GREATEST.
!
   20 if (curhi.gt.hi .or. curlo.lt.lo) go to 60
      if (abs(x(curhi)).lt.abs(x(curlo))) go to 40
      if (w(curlo).eq.0.0e0) go to 30
      diff = x(curlo) - xmeanw
      sumda = sumda + abs(diff)
      sumwd2 = sumwd2 + w(curlo)*diff*diff
      sumd2 = sumd2 + diff*diff
      sumd3 = sumd3 + diff*diff*diff
      sumd4 = sumd4 + diff*diff*diff*diff
   30 curlo = curlo - 1
      go to 20
   40 if (w(curhi).eq.0.0e0) go to 50
      diff = x(curhi) - xmeanw
      sumda = sumda + abs(diff)
      sumwd2 = sumwd2 + w(curhi)*diff*diff
      sumd2 = sumd2 + diff*diff
      sumd3 = sumd3 + diff*diff*diff
      sumd4 = sumd4 + diff*diff*diff*diff
   50 curhi = curhi + 1
      go to 20
!
!     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
!     CENTER ZERO POINT.
!
   60 if (curhi.gt.hi) go to 80
      do 70 i=curhi,hi
         if (w(i).eq.0.0e0) go to 70
         diff = x(i) - xmeanw
         sumda = sumda + abs(diff)
         sumwd2 = sumwd2 + w(i)*diff*diff
         sumd2 = sumd2 + diff*diff
         sumd3 = sumd3 + diff*diff*diff
         sumd4 = sumd4 + diff*diff*diff*diff
   70 continue
   80 if (curlo.lt.lo) go to 100
      do 90 irev=lo,curlo
         i = lo - irev + curlo
         if (w(i).eq.0.0e0) go to 90
         diff = x(i) - xmeanw
         sumda = sumda + abs(diff)
         sumwd2 = sumwd2 + w(i)*diff*diff
         sumd2 = sumd2 + diff*diff
         sumd3 = sumd3 + diff*diff*diff
         sumd4 = sumd4 + diff*diff*diff*diff
   90 continue
  100 return
      end
!BFSMN
     subroutine bfsmn(spcf1, spcf2, ceven, codd, w, lw, lag, df, nprt,&
    &   nf, cspc2, phas, freq, npts, xaxis, yaxis, isym, lpcv, alpha,&
     &   lagmx1, delta)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE SQUARED COHERENCY AND PHASE COMPONENTS
!     OF A BIVARIATE SPECTRUM.
!
!     REFERENCE - JENKINS AND WATTS
!                 SPECTRAL ANALYSIS AND ITS APPLICATIONS
!
!     WRITTEN BY - STEPHEN M. KEEFER AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   alpha,delta,df
     integer&
     &   lag,lagmx1,lpcv,lw,nf,nprt,npts
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   ceven(*),codd(*),cspc2(*),freq(*),phas(*),spcf1(*),spcf2(*),&
     &   w(*),xaxis(*),yaxis(*)
     integer&
     &   isym(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   arg,barl,barq,bary,c,ci,fac,fplm,fplrs,fpspm,g,pi,pit2,sn,v0,&
     &   v1,v2,z0,z1,z2
     integer&
     &   i,k
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   ppfnml,r1mach
!       EXTERNAL PPFNML,R1MACH
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL GETPI
!
!  INTRINSIC FUNCTIONS
      intrinsic atan2,cos,log,sign,sin,sqrt,tanh
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL ARG
!        AN ARGUMENT USED IN THE SPECTRUM COMPUTATIONS.
!     REAL BARL
!        THE SMOOTHED COSPECTRAL ESTIMATES.
!     REAL BARQ
!        THE SMOOTHED QUADRATURE SPECTRAL ESTIMATES.
!     REAL BARY
!        A TRANSFORMATION OF THE SQUARED COHERENCY COMPONENT.
!     REAL C
!        AN ARGUMENT USED IN THE SPECTRUM COMPUTATIONS.
!     REAL CEVEN(LAGMX1)
!        THE SUMS OF THE COVARIANCES FOR EACH LAG.
!     REAL CI
!        THE CONFIDENCE INTERVAL FOR THE SQUARED COHERENCY COMPONENT.
!     REAL CODD(LAGMX1)
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     REAL CSPC2(NF)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL DF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     REAL FAC
!        THE CONVERSION FACTOR FROM RADIANS TO DEGREES.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     REAL FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     REAL FPSPM
!        THE FLOATING POINT SMALLEST POSITIVE MAGNITUDE.
!     REAL FREQ(NF)
!        THE FREQUENCIES AT WHICH THE SPECTRUM IS COMPUTED.
!     REAL G
!        AN ARGUMENT USED IN THE COMPUTATION OF THE ALPHA PERCENT
!        SIGNIFICANCE LEVEL.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER ISYM(LPCV)
!        THE VECTOR CONTAINING THE CODES FOR THE PLOT SYMBOLS.
!     INTEGER K
!         AN INDEX VALUE.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGMX1
!        THE VALUE LAGMAX+1.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!         THE LENGTH OF VECTOR W.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT = 2 THE PLOT IS PROVIDED.
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     REAL PHAS(NF)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL PI, PIT2
!        THE VALUE OF PI AND PI*2.
!     REAL SN
!        AN ARGUMENT USED IN THE COMPUTATION OF THE SPECTRUM.
!     REAL SPCF1(NF), SPCF2(NF)
!        THE UNIVARIATE SPECTRUM FOR EACH SERIES.
!     REAL V0, V1, V2
!        ARGUMENTS USED IN THE COMPUTATION OF THE SPECTRUM.
!     REAL W(LW)
!        THE WINDOW.
!     REAL XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL Z0, Z1, Z2
!        ARGUMENTS USED IN THE COMPUTATION OF THE SPECTRUM.
!
!
      call getpi(pi)
      pit2 = pi*2.0e0
!
      fpspm = r1mach(1)
      fplm = r1mach(2)
      fplrs = r1mach(4)
!
      fac = 180.0e0/pi
!
!
!     COMPUTE SMOOTHED CO-SPECTRAL ESTIMATE
!
      do 40 i=1,nf
!
!           COMPUTE SMOOTHED CO- AND QUADRATURE SPECTRA USING
!           THE ALGORITHM SHOWN ON PAGE 420 OF JENKINS AND WATTS
!
         if (freq(i).eq.0.0e0) then
            c = 1.0e0
            sn = 0.0e0
         else if (freq(i).eq.0.25e0) then
            c = 0.0e0
            sn = 1.0e0
         else if (freq(i).eq.0.5e0) then
            c = -1.0e0
            sn = 0.0
         else
            arg = pit2*freq(i)
            c = cos(arg)
            sn = sin(arg)
         end if
         v0 = 0.0e0
         v1 = 0.0e0
         z0 = 0.0e0
         z1 = 0.0e0
         do 10 k=lag-1,1,-1
            v2 = 2.0e0*c*v1 - v0 + w(k+1)*ceven(k+1)
            z2 = 2.0e0*c*z1 - z0 + w(k+1)*codd(k+1)
            v0 = v1
            v1 = v2
            z0 = z1
            z1 = z2
   10    continue
         barl = delta*(ceven(1)+2.0e0*(v1*c-v0))
         barq = 2.0e0*delta*z1*sn
!
!     COMPUTE THE SMOOTHED SQUARED COHERENCY SPECTRA
!
         if (spcf1(i)*spcf2(i).gt.0.0e0) then
            cspc2(i) = (barl*barl+barq*barq)
            cspc2(i) = cspc2(i)/(spcf1(i)*spcf2(i))
         else
            cspc2(i) = fplm
         end if
!
!     COMPUTE PHASE (IN RADIANS)
!
         if ((barq.ne.0.0e0) .or. (barl.ne.0.0e0)) then
            phas(i) = atan2(-barq,barl)
         else
            if (i.eq.1) then
               phas(i) = 0.0e0
            else
               phas(i) = sign(pi,phas(i-1))
            end if
         end if
   40 continue
!
      if (nprt.eq.0) return
!
!     COMPUTE SMOOTHED SQUARED COHERENCY PLOT VECTORS
!
      ci = ppfnml(alpha)*sqrt(1.0e0/df)
      g = 2.0e0/df
      g = 1.0e0 - (1.0e0-alpha)**(g/(1.0e0-g))
      npts = 0
      do 60 i=1,nf
         npts = npts + 1
!
!     COMPUTE 95 PER CENT SIGNIFICANCE LEVEL
!
         yaxis(npts) = g
         xaxis(npts) = freq(i)
         isym(npts) = 4
         if (spcf1(i)*spcf2(i).le.0.0e0) go to 60
!
!     COMPUTE COHERENCE SPECTRAL ESTIMATE
!
         if (cspc2(i).gt.1.0e0) go to 60
         npts = npts + 1
         yaxis(npts) = cspc2(i)
         xaxis(npts) = freq(i)
         isym(npts) = 1
         if (cspc2(i).lt.g) go to 60
!
!     COMPUTE CONFIDENCE INTERVAL
!
         bary = sqrt(cspc2(i))
         bary = 0.5e0*(log((1.0e0+bary)/(1.0e0-bary)))
         npts = npts + 1
         yaxis(npts) = (tanh(bary+ci))*(tanh(bary+ci))
         xaxis(npts) = freq(i)
         isym(npts) = 2
         npts = npts + 1
         yaxis(npts) = (tanh(bary-ci))*(tanh(bary-ci))
         xaxis(npts) = freq(i)
         isym(npts) = 2
   60 continue
!
      return
!
      end
!BFSMS
     subroutine bfsms (y1, ymiss1, y2, ymiss2, n, nw, lags, nf, fmin,&
     &   fmax, nprt, cspc2, icspc2, phas, iphas, freq, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
!     FOURIER SPECTRUM ANALYSIS OF SERIES WITH MISSING OBSERVATIONS
!     (LONG CALL)
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fmax,fmin,ymiss1,ymiss2
     integer&
     &   icspc2,iphas,ldstak,n,nf,nprt,nw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   cspc2(*),freq(*),phas(*),y1(*),y2(*)
     integer&
     &   lags(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta
     integer&
    &   ccov,ceven,codd,i,iccov,ifp,index1,index2,inlppc,io,iprt,&
    &   isym,jccov,jnlppc,lagmax,lagmx1,ldsmin,lpcv,lw,lwork,ly,m,&
     &   nall0,nlppc,spcf1,spcf2,w,work,xaxis,yaxis
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL BFSDRV,ECVF,IPRINT,LDSCMP,PARZEN,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     INTEGER CCOV
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE COVARIANCES.
!     INTEGER CEVEN
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     INTEGER CODD
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     REAL CSPC2(ICSPC2,NW)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR WORK.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC
!        THE STARTING LOCATION IN THE WORK AREA FOR NLPPC
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL PHAS(IPHAS,NW)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SPCF1, SPCF2
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     INTEGER W
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE WINDOWS.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR THE VECTOR WORK.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YMISS1, YMISS2
!        DUMMY VARIABLES.
!     REAL Y1(N)
!        THE FIRST TIME SERIES.
!     REAL Y2(N)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'B','F','S','M','S',' '/
!
!     SET UP FOR ERROR CHECKING
!
      option(1) = .false.
      option(2) = .true.
      option(3) = .false.
      option(4) = .true.
!
!     SET MAXIMUM LAG VALUE TO BE USED (LAGMAX).
!
      lagmax = n - 1
      if (nw.le.0) go to 20
      lagmax = lags(1)
      do 10 i=1,nw
         lagmax = max(lagmax,lags(i))
   10 continue
   20 continue
      lagmx1 = lagmax + 1
!
      iccov = lagmax + 1
      jccov = 2
      inlppc = lagmax + 1
      jnlppc = 2
      m = 2
      index1 = 1
      index2 = 2
!
!     COMPUTE THE MINIMUM ALLOWABLE STACK AREA (LDSMIN)
!
      io = 1
      if (nprt.eq.0) io = 0
!
     call ldscmp(10, 0, 4*lagmax + 4 + io*4*nf, 0, 0, 0, 'S',&
     &  7*lagmax+7+2*nf+io*8*nf, ldsmin)
!
      ly = n
      lpcv = 4*nf
      lw = lagmx1
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING STACK ALLOCATIONS (NALL0).
!     SET THE STACK ALLOCATION TYPE (IFP)
!
      call stkset(ldstak, 4)
      nall0 = stkst(1)
!
      ifp = 3
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS
!
      if ((ldsmin.gt.ldstak) .or. (ldsmin.le.6)) then
         ccov = 1
         nlppc = 1
         ceven = 1
         codd = 1
         spcf1 = 1
         spcf2 = 1
         w = 1
!
         isym = 1
         xaxis = 1
         yaxis = 1
      else
         ccov = stkget(4*lagmx1,ifp)
         nlppc = stkget(4*lagmx1,2)
         ceven = stkget(lagmx1,ifp)
         codd = stkget(lagmx1,ifp)
         spcf1 = stkget(nf,ifp)
         spcf2 = stkget(nf,ifp)
         w = stkget(lw,ifp)
         if (nprt.eq.0) then
            isym = w
            xaxis = w
            yaxis = w
         else
            isym = stkget(lpcv,2)
            xaxis = stkget(lpcv,ifp)
            yaxis = stkget(lpcv,ifp)
         end if
      end if
!
      work = w
      lwork = lw
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
     call bfsdrv(y1, y2, ymiss1, ymiss2, rstak(ccov), istak(nlppc),&
    &   rstak(spcf1), rstak(spcf2), nf, fmin, fmax, freq, n, nw,&
    &   lagmax, lags, lagmx1, rstak(work), lwork, delta, istak(isym),&
    &   rstak(xaxis), rstak(yaxis), lpcv, alpha, nprt, parzen, iccov,&
    &   jccov, m, index1, index2, cspc2, phas, icspc2, iphas,&
    &   rstak(codd), rstak(ceven), rstak(w), lw, nmsub, ldsmin,&
     &   ldstak, option, n, inlppc, jnlppc, ly)
!
      call stkclr(nall0)
!
!     CHECK FOR ERRORS
!
      if (ierr.ne.0) then
        if (ierr.eq.2) call ecvf(nmsub)
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &  '       CALL BFSMS (Y1, YMISS1, Y2, YMISS2, N,'/&
    &  '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/&
     &  '      +            CSPC2, ICSPC2, PHAS, IPHAS, FREQ, LDSTAK)')
      end
!SRTIRR
      subroutine srtirr(ir, rr, la, a)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SORTS THE LENGTH LA ARRAY A, THE LENGTH LA
!     INTEGER ARRAY IR, AND THE LENGTH LA ARRAY RR INTO
!     ASCENDING ORDER, BASED ON THE VALUES IN A.  THE ARRAY
!     A CONSTITUTES THE SORTING KEY.  THE OTHER TWO ARRAYS ARE
!     CARRIED ALONG.  ORDINARILY THE ARRAY IR CONTAINS THE
!     VALUES 1, ..., LA INITIALLY, SO THAT THE THREE ARRAYS CAN
!     LATER BE SORTED AGAIN WITH IR AS THE KEY, IN ORDER TO
!     RESTORE A AND RR TO THEIR ORIGINAL ORDER.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!        (BASED CLOSELY ON THE IMSL CDC LIBRARY 3 ROUTINE VSORTP)
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   la
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   a(la),rr(la)
     integer&
     &   ir(la)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   r,rt,rtt,t,tt
     integer&
     &   i,ij,it,itt,j,k,l,m
!
!  LOCAL ARRAYS
     integer&
     &   il(21),iu(21)
!
!  INTRINSIC FUNCTIONS
      intrinsic int
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL A(LA)
!        INPUT/OUTPUT PARAMETER.  THE KEY ARRAY.
!     INTEGER I
!        *
!     INTEGER IJ
!        *
!     INTEGER IL(21)
!        *
!     INTEGER IR(LA)
!        INPUT/OUTPUT PARAMETER.  THE INTEGER ARRAY CARRIED ALONG
!        IN THE SORT.  INITIALLY IT SHOULD CONTAIN 1, ..., LA.
!        ON EXIT IT CONTAINS THE PERMUTATION VECTOR OF THE SORT.
!        SORTING ON THE PERMUTATION VECTOR WILL RESTORE THE KEY
!        ARRAY A AND THE ARRAY RR TO THEIR ORIGINAL ORDERS.
!     INTEGER IT
!        *
!     INTEGER ITT
!        *
!     INTEGER IU(21)
!        *
!     INTEGER J
!        *
!     INTEGER K
!        *
!     INTEGER L
!        *
!     INTEGER LA
!        INPUT PARAMETER.  THE LENGTH OF THE INPUT/OUTPUT PARAMETERS
!        A, IR, AND RR.
!     INTEGER M
!        *
!     REAL R
!        *
!     REAL RR(LA)
!        INPUT/OUTPUT PARAMETER.  THE ARRAY CARRIED ALONG IN
!        THE SORT.  IT MIGHT BE THE SET OF WEIGHTS FOR A.
!     REAL RT
!        *
!     REAL RTT
!        *
!     REAL T
!        *
!     REAL TT
!
      m = 1
      i = 1
      j = la
      r = .375e0
   10 if (i.eq.j) go to 90
      if (r.gt.0.5898437e0) go to 20
      r = r + 3.90625e-2
      go to 30
   20 r = r - .21875e0
   30 k = i
!                                  SELECT A CENTRAL ELEMENT OF THE
!                                  ARRAY AND SAVE IT IN LOCATION T
      ij = i + int((j-i)*r)
      t = a(ij)
      it = ir(ij)
      rt = rr(ij)
!                                  IF FIRST ELEMENT OF ARRAY IS GREATER
!                                  THAN T, INTERCHANGE WITH T
      if (a(i).le.t) go to 40
      a(ij) = a(i)
      a(i) = t
      t = a(ij)
      ir(ij) = ir(i)
      ir(i) = it
      it = ir(ij)
      rr(ij) = rr(i)
      rr(i) = rt
      rt = rr(ij)
   40 l = j
!                                  IF LAST ELEMENT OF ARRAY IS LESS THAN
!                                  T, INTERCHANGE WITH T
      if (a(j).ge.t) go to 60
      a(ij) = a(j)
      a(j) = t
      t = a(ij)
      ir(ij) = ir(j)
      ir(j) = it
      it = ir(ij)
      rr(ij) = rr(j)
      rr(j) = rt
      rt = rr(ij)
!                                  IF FIRST ELEMENT OF ARRAY IS GREATER
!                                  THAN T, INTERCHANGE WITH T
      if (a(i).le.t) go to 60
      a(ij) = a(i)
      a(i) = t
      t = a(ij)
      ir(ij) = ir(i)
      ir(i) = it
      it = ir(ij)
      rr(ij) = rr(i)
      rr(i) = rt
      rt = rr(ij)
      go to 60
   50 tt = a(l)
      a(l) = a(k)
      a(k) = tt
      itt = ir(l)
      ir(l) = ir(k)
      ir(k) = itt
      rtt = rr(l)
      rr(l) = rr(k)
      rr(k) = rtt
!                                  FIND AN ELEMENT IN THE SECOND HALF OF
!                                  THE ARRAY WHICH IS SMALLER THAN T
   60 l = l - 1
      if (a(l).gt.t) go to 60
!                                  FIND AN ELEMENT IN THE FIRST HALF OF
!                                  THE ARRAY WHICH IS GREATER THAN T
   70 k = k + 1
      if (a(k).lt.t) go to 70
!                                  INTERCHANGE THESE ELEMENTS
      if (k.le.l) go to 50
!                                  SAVE UPPER AND LOWER SUBSCRIPTS OF
!                                  THE ARRAY YET TO BE SORTED
      if (l-i.le.j-k) go to 80
      il(m) = i
      iu(m) = l
      i = k
      m = m + 1
      go to 100
   80 il(m) = k
      iu(m) = j
      j = l
      m = m + 1
      go to 100
!                                  BEGIN AGAIN ON ANOTHER PORTION OF
!                                  THE UNSORTED ARRAY
   90 m = m - 1
      if (m.eq.0) return
      i = il(m)
      j = iu(m)
  100 if (j-i.ge.1) go to 30
      if (i.eq.1) go to 10
      i = i - 1
  110 i = i + 1
      if (i.eq.j) go to 90
      t = a(i+1)
      it = ir(i+1)
      rt = rr(i+1)
      if (a(i).le.t) go to 110
      k = i
  120 a(k+1) = a(k)
      ir(k+1) = ir(k)
      rr(k+1) = rr(k)
      k = k - 1
      if (t.lt.a(k)) go to 120
      a(k+1) = t
      ir(k+1) = it
      rr(k+1) = rt
      go to 110
      end
!XNRAND
      subroutine xnrand(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS PROGRAM TESTS FEATURES OF THE NRAND FAMILY TO ENSURE THAT
!     ALL ASPECTS OF THE NRAND FAMILY ROUTINES WORK CORRECTLY.
!
!     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   sigma,ymean
     integer&
     &   i,iprt,iseed,n
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   y(1000)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL HIST,IPRINT,NRAND,NRANDC
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IERR
!        FLAG TO INDICATE PRESENCE OF ERROR DETECTED BY PRECEDING
!        STARPAC CALL.  (0 IS OK, 1 IS ERROR)
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER ISEED
!        THE SEED FOR THE RANDOM NUMBER GENERATOR.
!     INTEGER LDSTAK
!        AMOUNT OF WORK AREA.  SIZE OF DSTAK.
!     INTEGER N
!        THE LENGTH OF THE VECTOR Y.
!     REAL SIGMA
!        THE S.D. OF THE SAMPLE.
!     REAL Y(1000)
!        DATA VECTOR FOR TESTS.
!     REAL YMEAN
!        THE MEAN OF THE SAMPLE.
!
!
!     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
!
      call iprint(iprt)
!
!     CHECK FOR SUFFICIENT WORK AREA LENGTH.
!
      if (ldstak.lt.1000) then
        write (iprt, 1000)
         return
      end if
!
!     HEADING.
!
      write (iprt,1150)
!
!     TEST 1.  CHECK ALL ERROR MESSAGES.
!
      write (iprt,1160)
!
!     ERROR 1, ZERO OR FEWER ELEMENTS OR NEGATIVE STANDARD DEVIATION.
!
      iseed = 0
      sigma = -1
      n = 0
      ymean = 0.0e0
      call nrand(y, n, iseed)
      write (iprt,1170) ierr
      call nrandc(y, n, iseed, ymean, sigma)
      write (iprt,1170) ierr
!
!     COMPARE RESULTS
!
      iseed = 334
      n = 10
      ymean = 0.0e0
      sigma = 1.0e0
!
      write (iprt, 1120) n, iseed
      call nrand (y, n, iseed)
      write (iprt, 1100) (y(i),i=1,n)
!
      iseed = 333
      write (iprt, 1130) n, ymean, sigma, iseed
      call nrandc (y, n, iseed, ymean, sigma)
      write (iprt, 1100) (y(i),i=1,n)
!
      iseed = 13531
      n = 1000
      ymean = 0.0e0
      sigma = 1.0e0
!
      write (iprt, 1120) n, iseed
      call nrand (y, n, iseed)
      call hist (y, n, ldstak)
!
      write (iprt, 1130) n, ymean, sigma, iseed
      call nrandc (y, n, iseed, ymean, sigma)
      call hist (y, n, ldstak)
!
      iseed = 99999
      n = 1000
      ymean = 4.0e0
      sigma = 4.0e0
!
      write (iprt, 1120) n, iseed
      call nrand (y, n, iseed)
      call hist (y, n, ldstak)
!
      write (iprt, 1130) n, ymean, sigma, iseed
      call nrandc (y, n, iseed, ymean, sigma)
      call hist (y, n, ldstak)
!
      return
!
!     FORMATS
!
1000 format ('1THE DIMENSION OF DSTAK AND THE VALUE OF LDSTAK NEEDED'/&
    &  ' FOR NRANDX MUST EQUAL OR EXCEED 1000.  CHANGE DRIVER'/&
     &  ' AND RECALL NRANDX.')
 1100 format (5e15.8)
1120 format ('1GENERATE ', i4,&
     &  ' STANDARD NORMAL NUMBERS USING ISEED = ', i5)
1130 format ('1GENERATE ', i4,&
    &  ' NORMALLY DISTRIBUTED NUMBERS WITH YMEAN = ', f5.2,&
     &  ' AND SIGMA = ', f5.2, ' USING ISEED = ', i5)
 1150 format ('1TEST RUNS FOR THE NRAND FAMILY OF ROUTINES.')
1160 format(' TEST 1.  GENERATE EACH OF THE POSSIBLE ',&
     &   15herror messages.)
 1170 format(/22h the value of ierr is , i4//)
      end
!UASF
      subroutine uasf (yfft, n, lyfft, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
!     SPECTRUM ESTIMATION USING THE FFT (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,lyfft,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   yfft(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta,fmax,fmin,var,ymean
     integer&
    &   iar,ifp,iprt,lacov,lag,lagmax,laic,ldsmin,lpcv,lphi,lspc,&
     &   lwork,nall0,nf,nfft,nprt,work
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   acov(101),aic(101),freq(101),ftest(2,100),phi(100),rstak(12),&
     &   spca(101),spcf(101),xaxis(207),yaxis(207)
     integer&
     &   isort(101),istak(12),isym(207)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACVFF,IPRINT,LDSCMP,PARZEN,SETESL,SETLAG,STKCLR,STKSET,
!     +   UASDV,UASER
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
      equivalence (isym(1),isort(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(101)
!        THE AUTOCOVARIANCE COMPUTED FROM THE LAG PRODUCT PAIRS.
!     REAL AIC(101)
!        THE ARRAY CONTAINING AKIAKES CRITERIA FOR EACH ORDER.
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
!        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
!     REAL FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     REAL FTEST(2, 100)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LSPC
!         THE LENGTH OF THE SPECTRUM ARRAYS.
!     INTEGER ISYM(207)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE COVARIANCE ARRAYS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE ARRAY AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER LWORK
!        THE LENGTH OF THE WORK ARRAY.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
!        THIS ROUTINE WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
!        ARE TO BE ESTIMATED.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE TYPE OF WINDOW TO BE USED.
!     REAL PHI(100)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL SPCA(101)
!        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!     REAL SPCF(101)
!        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
!     REAL VAR
!        THE ONE STEP PREDICTION VARIANCE.
!     INTEGER WORK
!        THE STARTING LOCATION IN RSTAK FOR
!        THE WORK VECTOR.
!     REAL XAXIS(207)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL YAXIS(207)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL YFFT(LYFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'U',       'A',       'S',       'F',       ' ',       ' '/
!
      ifp = 3
!
!     SET UP FOR ERROR CHECKING
!
      option(1) = .true.
      option(2) = .false.
      option(3) = .false.
      option(4) = .false.
!
      lag = 0
      iar = 0
      nf = 101
      fmin = 0.0e0
      fmax = 0.5e0
      nprt = -1
!
!     SET THE MAXIMUM NUMBER OF LAGS TO BE USED.
!
      call setlag(n, lagmax)
!
!     SET LENGTH OF EXTENDED SERIES
!
      call setesl(n+lagmax, 4, nfft)
!
      call ldscmp(1, 0, 0, 0, 0, 0, 'S', nfft, ldsmin)
!
     call uaser(nmsub, n, acov, iar, phi, lagmax, lag, lacov,&
     &   nf, ldstak, ldsmin, lyfft, nfft, option)
!
      if (ierr.ne.0) then
         ierr = 1
         call iprint (iprt)
         write (iprt, 1000)
         return
      end if
!
!     SET THE SIZE OF THE WORK AREA
!
      call stkset(ldstak, 4)
!
!     SAVE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
!
      nall0 = stkst(1)
!
!     SET VARIOUS PROGRAM PARAMETERS.
!
      lpcv = 207
      lspc = 101
      lphi = 100
      laic = 101
      lacov = 101
      lwork = nfft
!
      alpha = 0.95e0
      delta = 1.0e0
!
!     SUBDIVIDE THE WORK AREA
!
      work = stkget(lwork, ifp)
!
!     COMPUTE AUTOCOVARIANCES
!
     call acvff (yfft, n, nfft, ymean, acov, lagmax, lacov, lyfft,&
     &   rstak(work), lwork)
!
!     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
!
     call uasdv(acov, spca, spcf, lspc, iar, phi, nf, fmin, fmax, freq,&
    &   n, lagmax, ftest, aic, rstak(work), lacov, lwork, delta, isort,&
    &   isym, xaxis, yaxis, lpcv, alpha, lag, laic, lphi, nprt, var,&
     &   parzen, nmsub)
!
      call stkclr(nall0)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &  '       CALL UASF (YFFT, N, LYFFT, LDSTAK)')
      end
!ERAGT
     subroutine eragt (nmsub, nmvar, ym, n, m, iym, ymmn, nvmx,&
     &   head, msgtyp, nv, error, nmmin)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS TO ENSURE THAT NO VALUES, OR ONLY A MAXIMUM
!     OF NVMX, ARE NOT GREATER THAN A SPECIFIED LOWER BOUND YMMN,
!     WITH NAME NMMIN.   THE CHECKING OPTION IS SPECIFIED
!     WITH MSGTYP.  IF AN ERROR IS FOUND, THE ERROR IS PRINTED AND
!     AN ERROR FLAG AND THE NUMBER OF VIOLATINS ARE RETURNED.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ymmn
     integer&
     &   iym,m,msgtyp,n,nv,nvmx
     logical&
     &   error,head
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(*)
     character&
     &   nmmin(8)*1,nmsub(6)*1,nmvar(8)*1
!
!  LOCAL SCALARS
     integer&
     &   i,j
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL ERAGTP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IYM
!        THE FIRST DIMENSION OF THE ARRAY YM.
!     INTEGER J
!        AN INDEXING VARIABLE.
!     INTEGER M
!        THE NUMBER OF COLUMNS OF DATA IN YM.
!     INTEGER MSGTYP
!        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
!        IF (MSGTYP.GE.3) THE MESSAGE PRINTED WILL USE NMMIN
!        OTHERWISE IT WILL USE YMMN.
!        IF (MSGTYP = 1 OR 3) NO VIOLATIONS ARE ALLOWED.
!        IF (MSGTYP = 2 OR 4) THE NUMBER OF VIOLATIONS MUST
!                             BE LESS THAN   NVMX   .
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE PARAMETERS NAME.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND.
!     INTEGER NVMX
!        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
!     REAL YM(IYM,M)
!        THE ARRAY BEING TESTED.
!     REAL YMMN
!        THE MINIMUM ACCEPTABLE VALUE.
!
      error = .false.
!
      if ((n.le.0) .or. (m.le.0)) return
!
!     CHECK FOR VIOLATIONS
!
      nv = 0
      do 5 i = 1, n
         do 1 j = 1, m
            if (ym(i+(j-1)*iym) .le. ymmn) nv = nv + 1
    1    continue
    5 continue
!
      if (nv .le. nvmx) return
!
!     VIOLATIONS FOUND
!
      error = .true.
!
     call eragtp (nmsub, nmvar, ymmn, nvmx, head, msgtyp, nv,&
     &   nmmin)
!
      return
!
      end
!LLSS
     subroutine llss(y, xm, n, ixm, npar, res, ldstak,&
     &   nprt, par, rsd, pv, sdpv, sdres, vcv, ivcv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CALL FOR GENERAL LINEAR MODEL LEAST SQUARES FIT
!     NO WEIGHTS SPECIFIED
!     FULL STORAGE
!     USER CONTROL OF AUTOMATIC PRINTOUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   ivcv,ixm,ldstak,n,npar,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),pv(*),res(*),sdpv(*),sdres(*),vcv(*),xm(*),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,lpar,lpv,lsdpv,lsdres,lwt
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   wt(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LLCNTG
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     REAL PAR(NPAR)
!        THE PARAMETERS  TO BE ESTIMATED.
!     REAL PV(N)
!        THE PREDICTED VALUES.
!     REAL RES(N)
!        THE RESIDUALS.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     REAL SDPV(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(N)
!        THE STANDARDIZED RESIDUALS.
!     REAL VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(1)
!        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
!     REAL XM(IXM,NPAR)
!        THE INDEPENDENT VARIABLE.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'L','L','S','S',' ',' '/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      weight = .false.
      save = .true.
      lpar = npar
      lpv = n
      lsdpv = n
      lsdres = n
      lwt = 1
!
     call llcntg(y, wt, lwt, xm, n, ixm, npar, res, ldstak, nprt,&
    &   par, lpar, rsd, pv, lpv, sdpv, lsdpv, sdres, lsdres, vcv, ivcv,&
     &   nmsub, weight, save)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (//42h the correct form of the call statement is//&
    &  '       CALL LLSS (Y, XM, N, IXM, NPAR, RES, LSDTAK,'/&
     &  '      +           NPRT, PAR, RSD, PV, SDPV, SDRES, VCV, IVCV)')
      end
!SVPC
     subroutine svpc(ym, n, ns, isym, ilog, isize, irlin, ibar,&
     &   ylb, yub, xlb, xinc)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH USER CONTROL OF THE PLOT SYMBOLS USED (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ibar,ilog,irlin,isize,n,ns
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(*)
     integer&
     &   isym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iprt,ischck,iym,lisym,m
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'S',       'V',       'P',       'C',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      m = 1
      iym = n
      multi = .false.
      ischck = 1
      miss = .false.
      lisym = n
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ym, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &  '       CALL SVPC (Y, N, NS, ISYM, ILOG,'/&
     &  '      +           ISIZE, IRLIN, IBAR, YLB, YUB, XLB, XINC)')
      end
!STATS
      subroutine stats(y, n, ldstak, sts, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES 53 DIFFERENT STATISTICS FOR A VECTOR
!     Y, WITH NO WEIGHTS SPECIFIED.  ONE PAGE OF AUTOMATIC
!     PRINTOUT IS PRODUCED.
!
!     WRITTEN BY - JANET R. DONALDSON, JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!        (EXTENSIVE REVISION OF OLDER VERSION)
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,n,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   sts(53),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,sumd2,sumd3,sumd4,sumda,sumdi,sumt1
     integer&
     &   idp,iint,iprt,lsort,mid,nall0,nnzw
     logical&
     &   stack,wts
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   wt(1)
     integer&
     &   istak(12)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL GENI,IPRINT,SRTIR,SRTRI,STAT1,STAT2,STATER,STKCLR,STKSET,
!     +   SUMBS,SUMDS,SUMID,SUMOT,SUMSS,SUMTS
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        THE PERCENTAGE TO TRIM FROM EACH END IN THE TRIMMED
!        MEANS.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDP
!        FRAMEWORK CODE VALUE FOR DOUBLE PRECISION NUMBERS.
!     INTEGER IERR
!        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
!        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
!        SOME ERROR EXISTS.
!     INTEGER IINT
!        THE CODE VALUE FOR INTEGER FOR FRAMEWORK.
!     INTEGER IPRT
!        THE NUMBER OF THE STANDARD OUTPUT UNIT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
!        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
!     INTEGER LSORT
!        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION
!        VECTOR.
!     INTEGER MID
!        IN THE SORTED ARRAY Y, A POINT EQUAL TO OR THE POINT
!        CLOSEST TO, ZERO.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
!        WAS CALLED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        INPUT PARAMETER.  FLAG TO CONTROL OUTPUT.
!        0 MEANS NO OUTPUT.  OTHER VALUES MEAN OUTPUT.
!     INTEGER NNZW
!        NUMBER OF NONZERO WEIGHTS.
!     LOGICAL STACK
!        A FLAG INDICATING WHETHER THIS ROUTINE USES THE STACK (TRUE)
!        OR NOT (FALSE).
!     REAL STS(53)
!        OUTPUT PARAMETER.  THE VECTOR OF THE 53 STATISTICS COMPUTED.
!     REAL SUMDA
!        THE SUM OF THE ABSOLUTE VALUES OF THE DIFFERENCES FROM
!        THE MEAN.
!     REAL SUMDI
!        THE SUM OF THE PRODUCTS OF THE INDEX AND DIFFERENCES.
!     REAL SUMD2
!        THE SUM OF THE SQUARE OF THE DIFFERENCES.
!     REAL SUMD3
!        THE SUM OF THE CUBE OF THE DIFFERENCES.
!     REAL SUMD4
!        THE SUM OF THE 4TH POWERS OF THE DIFFERENCES.
!     REAL SUMT1
!        THE TRIMMED UNWEIGHTED SIMPLE SUM OF ELEMENTS IN Y.
!     REAL WT(1)
!        THE DUMMY WEIGHTS VECTOR.
!     LOGICAL WTS
!        A FLAG INDICATING WHETHER THERE ARE WEIGHTS (TRUE)
!        OR NOT (FALSE).
!     REAL Y(N)
!        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
!        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
!        TO ITS ORIGINAL ORDER AFTERWARDS.
!
!
!     INITIALIZE NAME VECTORS
!
     data  nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6)&
     &   /       'S',      'T',      'A',      'T',      'S',      ' '/
!
      data alpha /0.25e0/
      data idp /4/
      data iint /2/
      data wts /.false./
      data stack /.true./
!
!     CHECK FOR ERRORS IN THE INPUT PARAMETERS.
!
      call stater(nmsub, wt, n, ldstak, wts, nnzw, stack, ierr)
      if (ierr.ne.0) then
!
!     SET UP THE OUTPUT UNIT NUMBER.
!
         call iprint(iprt)
         write (iprt,1000)
         return
      end if
!
!     SET UP FRAMEWORK AREA
!
      call stkset (ldstak, idp)
      nall0 = stkst(1)
!
!     SET UP LSORT, THE PERMUTATION VECTOR.
!
      lsort = stkget(n,iint)
      call geni(istak(lsort), n, 1, 1)
!
!     SORT THE VECTOR Y.
!
      call srtir(istak(lsort), n, y)
!
!     COMPUTE THE STATISTICS WHICH USE A SORTED ARRAY.
!
     call stat1(y, n, sts(5), sts(34), sts(35), sts(6),&
     &   sts(11), 10, 0.0e0, 0.0e0, sts(44))
!
!     CALCULATE SUMS OF THE SORTED ARRAY.
!
      call sumbs(y, n, 1, mid, n)
     call sumss(y, n, 1, mid, n, sts(38), sts(39), sts(42),&
     &   sts(3))
      sts(4) = sts(3)
      call sumts(y, n, alpha, sumt1, sts(7))
      sts(8) = sts(7)
      call sumds(y, n, 1, mid, n, sts(3), sumda, sumd2, sumd3, sumd4)
!
!     RESTORE THE VECTOR Y TO ITS ORIGINAL ORDER.
!
      call srtri(y, n, istak(lsort))
!
!     COMPUTE REST OF STATISTICS.
!
      call sumid(y, n, sts(3), sumdi)
      call stat2(y, n, sts, sumda, sumdi, sumd2, sumd3, sumd4)
      if (nprt.ne.0) call sumot(sts, n, n, wts)
!
!     RETURN THE VECTOR LSORT.
!
      call stkclr(nall0)
      return
!
!     FORMAT STATEMENTS.
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL STATS (Y, N, LDSTAK, STS, NPRT)')
      end
!PPML
      subroutine ppml(ym, ymiss, x, xmiss, n, ilog)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT FOR DATA WITH MISSING OBSERVATIONS (LOG OPTION).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: ymiss, xmiss
     integer&
     &   ilog,n
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: x(*),ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xlb,xub,ylb,yub
     integer&
     &   iprt,ischck,isize,iym,lisym,m,nout
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
      real(kind=wp) :: ymmiss(1)
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YMISS
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'P',       'P',       'M',       'L',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      ymmiss=ymiss
      m = 1
      iym = n
      multi = .false.
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 0.0e0
      xub = 0.0e0
      ischck = 0
      isize = -1
      nout = 0
      miss = .true.
      lisym = 1
!
     call ppcnt (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL PPML (Y, YMISS, X, XMISS, N, ILOG)')
      end
!XUFS
      subroutine xufs(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE FOURIER SPECTRUM ANALYSIS ROUTINES
!
!     SERIES Y IS THE FIRST 50 VALUES OF THE SERIES LISTED ON PAGE
!     318 OF JENKINS AND WATTS.  THE SPECTRUM OF THIS SERIES IS SHOWN
!     FOR VARIOUS BANDWIDTH ON PAGE 270 OF JENKINS AND WATTS.
!
!     SERIES Z IS THE WOLF SUNSPOT NUMBERS FROM 1700 TO 1960 AS
!     TABULATED BY WALDMEIER.  THE RAW AND SMOOTHED PERIODOGRAMS OF
!     TAPERED SERIES ARE SHOWN ON PAGES 95 AND 176, RESPECTIVELY, OF
!     BLOOMFIELD.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
      real(kind=wp) :: amiss,fmax,fmin,ymiss
     integer&
     &   i,iar,iprt,ispcf,j,lacov,lagmax,lds,lyfft,nf,nprt,nw,ny
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   acov(101),freq(300),phi(100),spcf(101,4),y(150),yfft(400)
     integer&
     &   lags(4),nlppa(101)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACFMS,ACFS,IPRINT,NRAND,SETRV,UFS,UFSF,UFSFS,UFSM,
!     +   UFSMS,UFSMV,UFSMVS,UFSS,UFSV,UFSVS
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(101)
!        THE AUTOCOVARIANCE VECTOR.
!     REAL AMISS
!         THE MISSING VALUE CODE FOR THE RETURNED ACVF ESTIMATES.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCIES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(300)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE MODEL TO BE USED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISPCF
!         THE ACTUAL DIMENSION FOR THE SPECTRUM ARRAYS.
!     INTEGER J
!        INDEX VARIABLE.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCOVARIANCE BEING COMPUTED AND THE MAXIMUM LAG TO BE USED,
!        RESPECTIVELY.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDS
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(101)
!        THE NUMBERS OF LAGGED PRODUCT PAIRS USED FOR EACH ACVF.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT = 0 THE PLOT IS SUPPRESSED, IF
!        NPRT = 2 THE PLOT IS DECIBELS/LINEAR, IF
!        NPRT = 2 THE PLOT IS LOG/LINEAR, IF
!        NPRT = 3 THE PLOT IS DECIBELS/LOG, AND IF
!        NPRT = 4 THE PLOT IS LOG/LOG.
!     INTEGER NW
!        THE NUMBER OF DIFFERENT LAG WINDOW TRUNCATION POINTS SPECIFIED,
!        AND THEREFORE, THE NUMBER OF PLOTS.
!     INTEGER NY
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     REAL PHI(100)
!        THE VECTOR OF THE ORDER IAR AUTOREGRESSIVE MODEL COEFFICIENTS.
!     REAL SPCF(101, 4)
!        THE ARRAYS IN WHICH THE FOURIER SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     REAL Y(150)
!         THE ARRAY CONTAINING THE TIME SERIES FROM JENKINS AND WATTS.
!     REAL YFFT(400)
!        THE VECTOR OF THE OBSERVED TIME SERIES TO BE ANALYZED USING
!        THE FFT.
!     REAL YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!
!
     data   y(  1), y(  2), y(  3), y(  4), y(  5), y(  6)&
     &    /-0.88_wp, -0.12_wp, -0.89_wp, -1.38_wp, -0.07_wp,  1.03_wp/
     data   y(  7), y(  8), y(  9), y( 10), y( 11), y( 12)&
     &    / 2.14_wp,  0.35_wp, -1.10_wp, -1.78_wp, -2.76_wp, -1.77_wp/
     data   y( 13), y( 14), y( 15), y( 16), y( 17), y( 18)&
     &    / 0.98_wp,  1.00_wp, -0.70_wp, -1.01_wp, -1.30_wp, -0.85_wp/
     data   y( 19), y( 20), y( 21), y( 22), y( 23), y( 24)&
     &    /-0.46_wp,  1.63_wp,  0.06_wp, -0.17_wp, -1.01_wp, -1.04_wp/
     data   y( 25), y( 26), y( 27), y( 28), y( 29), y( 30)&
     &    /-0.66_wp, -1.12_wp, -0.51_wp, -0.71_wp, -0.20_wp, -0.13_wp/
     data   y( 31), y( 32), y( 33), y( 34), y( 35), y( 36)&
     &    / 0.14_wp,  1.59_wp, -0.76_wp, -1.08_wp, -1.77_wp, -1.20_wp/
     data   y( 37), y( 38), y( 39), y( 40), y( 41), y( 42)&
     &    / 0.45_wp, -0.07_wp, -0.63_wp, -0.35_wp, -0.87_wp, -0.62_wp/
     data   y( 43), y( 44), y( 45), y( 46), y( 47), y( 48)&
     &    / 0.28_wp,  1.90_wp,  2.14_wp,  1.05_wp,  0.31_wp,  1.07_wp/
     data   y( 49), y( 50)&
     &    / 2.67_wp,  2.44_wp/
!
      call iprint(iprt)
!
!     CHECK ERROR HANDLING
!
!        TEST 1  -  MISCELANEOUS ERROR CHECKING
!
      write (iprt, 2000)
      ymiss = 1.16_wp
      lagmax = -1
      ny = -10
      lacov = 101
      lyfft = -11
      nw = -1
      nf = -5
      fmin = 0.5_wp
      fmax = 0.0_wp
      nprt = -1
      ispcf = -20
      lds = 0
      write(iprt, 1001)
      call ufs (y, ny)
      write (iprt, 1002) ierr
      write(iprt, 1003)
     call ufss(y, ny, nw, lags, nf, fmin, fmax, nprt, spcf,&
     &   ispcf, freq, lds)
      write (iprt, 1002) ierr
      write(iprt, 1019)
      call ufsf (yfft, ny, lyfft, lds)
      write (iprt, 1002) ierr
      write(iprt, 1020)
     call ufsfs(yfft, ny, lyfft, lds, nw, lags, nf, fmin, fmax, nprt,&
     &   spcf, ispcf, freq)
      write (iprt, 1002) ierr
      write(iprt, 1005)
      call ufsm (y, ymiss, ny)
      write (iprt, 1002) ierr
      write(iprt, 1006)
     call ufsms(y, ymiss, ny, nw, lags, nf, fmin, fmax, nprt, spcf,&
     &   ispcf, freq, lds)
      write (iprt, 1002) ierr
      write (iprt, 1007)
      call ufsv(acov, lagmax, ny)
      write (iprt, 1002) ierr
      write (iprt, 1008)
     call ufsvs (acov, lagmax, ny, nw, lags, nf,&
     &   fmin, fmax, nprt, spcf, ispcf, freq, lds)
      write (iprt, 1002) ierr
      write (iprt, 1021)
      call ufsmv(acov, nlppa, lagmax, ny)
      write (iprt, 1002) ierr
      write (iprt, 1022)
     call ufsmvs (acov, nlppa, lagmax, ny, nw, lags, nf,&
     &   fmin, fmax, nprt, spcf, ispcf, freq, lds)
      write (iprt, 1002) ierr
!
!        TEST 2  -  MISCELANEOUS ERROR CHECKING (CONTINUED)
!
      write (iprt, 2010)
      ymiss = 1.16_wp
      ny = 50
      lagmax = 55
      lyfft = -11
      nw = 2
      lags(1) = 0
      lags(2) = 50
      nf = 51
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 3
      ispcf = 20
      lds = 0
      write(iprt, 1003)
     call ufss(y, ny, nw, lags, nf, fmin, fmax, nprt, spcf,&
     &   ispcf, freq, lds)
      write (iprt, 1002) ierr
      write(iprt, 1019)
      call ufsf (yfft, ny, lyfft, lds)
      write (iprt, 1002) ierr
      write(iprt, 1020)
     call ufsfs(yfft, ny, lyfft, lds, nw, lags, nf, fmin, fmax, nprt,&
     &   spcf, ispcf, freq)
      write (iprt, 1002) ierr
      write(iprt, 1006)
     call ufsms(y, ymiss, ny, nw, lags, nf, fmin, fmax, nprt, spcf,&
     &   ispcf, freq, lds)
      write (iprt, 1002) ierr
      write (iprt, 1008)
     call ufsvs (acov, lagmax, ny, nw, lags, nf,&
     &   fmin, fmax, nprt, spcf, ispcf, freq, lds)
      write (iprt, 1002) ierr
      write (iprt, 1022)
     call ufsmvs (acov, nlppa, lagmax, ny, nw, lags, nf,&
     &   fmin, fmax, nprt, spcf, ispcf, freq, lds)
      write (iprt, 1002) ierr
!
!        TEST 3  -  LDS TOO SMALL
!
      write (iprt, 2030)
      ymiss = 1.16_wp
      ny = 50
      lagmax = 49
      lyfft = 400
      nw = 2
      lags(1) = 0
      lags(2) = 50
      nf = 51
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 3
      ispcf = 101
      lds = 0
      write(iprt, 1003)
     call ufss(y, ny, nw, lags, nf, fmin, fmax, nprt, spcf,&
     &   ispcf, freq, lds)
      write (iprt, 1002) ierr
      write(iprt, 1019)
      call ufsf (yfft, ny, lyfft, lds)
      write (iprt, 1002) ierr
      write(iprt, 1020)
     call ufsfs(yfft, ny, lyfft, lds, nw, lags, nf, fmin, fmax, nprt,&
     &   spcf, ispcf, freq)
      write (iprt, 1002) ierr
      write(iprt, 1006)
     call ufsms(y, ymiss, ny, nw, lags, nf, fmin, fmax, nprt, spcf,&
     &   ispcf, freq, lds)
      write (iprt, 1002) ierr
      write (iprt, 1008)
     call ufsvs (acov, lagmax, ny, nw, lags, nf,&
     &   fmin, fmax, nprt, spcf, ispcf, freq, lds)
      write (iprt, 1002) ierr
      write (iprt, 1022)
     call ufsmvs (acov, nlppa, lagmax, ny, nw, lags, nf,&
     &   fmin, fmax, nprt, spcf, ispcf, freq, lds)
      write (iprt, 1002) ierr
!
!        TEST 4  -  ALL DATA AND COVARIANCES MISSING
!
      write (iprt, 2040)
      ymiss = 1.16_wp
      ny = 50
      lagmax = 49
      lyfft = 400
      nw = 2
      lags(1) = 8
      lags(2) = 16
      nf = 51
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 3
      ispcf = 101
      lds = 700
      call setrv(yfft, ny, ymiss)
      call setrv(acov, lagmax, 0.0_wp)
      do 5 i = 1, lagmax
         nlppa(i) = 0
    5 continue
      write (iprt, 1005)
      call ufsm(yfft, ymiss, ny)
      write (iprt, 1002) ierr
      write(iprt, 1006)
     call ufsms(yfft, ymiss, ny, nw, lags, nf, fmin, fmax, nprt, spcf,&
     &   ispcf, freq, lds)
      write (iprt, 1002) ierr
      write (iprt, 1021)
      call ufsmv (acov, nlppa, lagmax, ny)
      write (iprt, 1002) ierr
      write (iprt, 1022)
     call ufsmvs (acov, nlppa, lagmax, ny, nw, lags, nf,&
     &   fmin, fmax, nprt, spcf, ispcf, freq, lds)
      write (iprt, 1002) ierr
!
!        TEST 5  -  EVERY OTHER VALUE MISSING
!
      write (iprt, 2050)
      ymiss = 1.16_wp
      ny = 50
      lagmax = 49
      lyfft = 400
      nw = 2
      lags(1) = 8
      lags(2) = 16
      nf = 51
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 3
      ispcf = 101
      lds = 700
      call setrv(yfft, ny, ymiss)
      do 10 i = 1, ny, 2
         yfft(i) = y(i)
   10 continue
      write (iprt, 1005)
      call ufsm(yfft, ymiss, ny)
      write (iprt, 1002) ierr
      write(iprt, 1006)
     call ufsms(yfft, ymiss, ny, nw, lags, nf, fmin, fmax, nprt, spcf,&
     &   ispcf, freq, lds)
      write (iprt, 1002) ierr
!
!     CHECK RESULTS FROM VALID CALL
!
      ymiss = 1.16_wp
      ny = 50
      lagmax = 49
      lyfft = 400
      nw = 2
      lags(1) = 8
      lags(2) = 16
      nf = 51
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 2
      ispcf = 101
      lds = ldstak
!
!     TEST OF UFS
!
      write(iprt, 2020)
      write(iprt, 1001)
      call ufs (y, ny)
      write (iprt, 1002) ierr
!
!     TEST OF UFSS
!
      write(iprt, 2020)
      write(iprt, 1003)
     call ufss(y, ny, nw, lags, nf, fmin, fmax, nprt, spcf,&
     &   ispcf, freq, lds)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM UFSS
!
      write (iprt, 1004) (freq(i), (spcf(i,j),j=1,nw), i=1,nf)
!
!     TEST OF UFSF
!
      write(iprt, 2020)
      write(iprt, 1019)
      call scopy(ny, y, 1, yfft, 1)
      call ufsf (yfft, ny, lyfft, lds)
      write (iprt, 1002) ierr
!
!     TEST OF UFSFS
!
      write(iprt, 2020)
      write(iprt, 1020)
      call scopy(ny, y, 1, yfft, 1)
     call ufsfs(yfft, ny, lyfft, lds, nw, lags, nf, fmin, fmax, nprt,&
     &   spcf, ispcf, freq)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM UFSFS
!
      write (iprt, 1004) (freq(i), (spcf(i,j),j=1,nw), i=1,nf)
!
!     TEST OF UFSM
!
      write(iprt, 2020)
      write(iprt, 1005)
      call ufsm (y, ymiss, ny)
      write (iprt, 1002) ierr
!
!     TEST OF UFSMS
!
      write(iprt, 2020)
      write(iprt, 1006)
     call ufsms(y, ymiss, ny, nw, lags, nf, fmin, fmax, nprt, spcf,&
     &   ispcf, freq, lds)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM UFSMS
!
      write (iprt, 1004) (freq(i), (spcf(i,j),j=1,nw), i=1,nf)
!
!     TEST OF UFSV
!
      write(iprt, 2020)
      call acfs (y, ny, lagmax, lacov, acov, iar, phi, 0, lds)
      write (iprt, 1007)
      call ufsv(acov, lagmax, ny)
      write (iprt, 1002) ierr
!
!     TEST OF UFSVS
!
      write(iprt, 2020)
      write (iprt, 1008)
     call ufsvs (acov, lagmax, ny, nw, lags, nf,&
     &   fmin, fmax, nprt, spcf, ispcf, freq, lds)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM UFSVS
!
      write (iprt, 1004) (freq(i), (spcf(i,j),j=1,nw), i=1,nf)
!
!     TEST OF UFSMV
!
      write(iprt, 2020)
     call acfms (y, ymiss, ny, lagmax, lacov, acov, amiss, nlppa,&
     &   0, lds)
      write (iprt, 1021)
      call ufsmv(acov, nlppa, lagmax, ny)
      write (iprt, 1002) ierr
!
!     TEST OF UFSMVS
!
      write(iprt, 2020)
      write (iprt, 1022)
     call ufsmvs (acov, nlppa, lagmax, ny, nw, lags, nf,&
     &   fmin, fmax, nprt, spcf, ispcf, freq, lds)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM UFSMVS
!
      write (iprt, 1004) (freq(i), (spcf(i,j),j=1,nw), i=1,nf)
!
!     MINIMUM PROBLEM SIZE
!
      ymiss = 1.16_wp
      ny = 17
      lagmax = 1
      lyfft = 400
      nw = 2
      lags(1) = 1
      lags(2) = 16
      nf = 1
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 2
      ispcf = 101
      lds = 700
!
!     TEST OF UFS
!
      write (iprt, 2060)
      write(iprt, 1001)
      call ufs (y, ny)
      write (iprt, 1002) ierr
!
!     TEST OF UFSS
!
      write(iprt, 2060)
      write(iprt, 1003)
     call ufss(y, ny, nw, lags, nf, fmin, fmax, nprt, spcf,&
     &   ispcf, freq, lds)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM UFSS
!
      write (iprt, 1004) (freq(i), (spcf(i,j),j=1,nw), i=1,nf)
!
!     CHECK HANDLING OF FMIN AND FMAX
!
      ymiss = 1.16_wp
      ny = 50
      lagmax = 49
      lyfft = 400
      nw = 2
      lags(1) = 8
      lags(2) = 16
      nf = 51
      fmin = 0.45_wp
      fmax = 0.5_wp
      nprt = 2
      ispcf = 101
      lds = 700
!
!     TEST OF UFSS
!
      write(iprt, 2070)
      write(iprt, 1003)
     call ufss(y, ny, nw, lags, nf, fmin, fmax, nprt, spcf,&
     &   ispcf, freq, lds)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM UFSS
!
      write (iprt, 1004) (freq(i), (spcf(i,j),j=1,nw), i=1,nf)
!
!     WHITE NOISE SPECTRUM
!
      ymiss = 1.16_wp
      call nrand(yfft, ny, 12345)
      ny = 50
      lagmax = 49
      lyfft = 400
      nw = 2
      lags(1) = 8
      lags(2) = 16
      nf = 51
      fmin = 0.0_wp
      fmax = 0.5_wp
      nprt = 2
      ispcf = 101
      lds = 700
!
!     TEST OF UFSS
!
      write(iprt, 2080)
      write(iprt, 1003)
     call ufss(yfft, ny, nw, lags, nf, fmin, fmax, nprt, spcf,&
     &   ispcf, freq, lds)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VALUES FROM UFSS
!
      write (iprt, 1004) (freq(i), (spcf(i,j),j=1,nw), i=1,nf)
!
      return
!
!     FORMAT STATEMENTS
!
 1001 format (12h test of ufs)
 1002 format (/8h ierr is, i5/)
 1003 format (13h test of ufss)
 1004 format (3(1x, e16.8))
 1005 format (13h test of ufsm)
 1006 format (14h test of ufsms)
 1007 format (13h test of ufsv)
 1008 format (14h test of ufsvs)
 1019 format (13h test of ufsf)
 1020 format (14h test of ufsfs)
 1021 format (14h test of ufsmv)
 1022 format (15h test of ufsmvs)
 2000 format (32h1check error handling  -  test 1)
 2010 format (32h1check error handling  -  test 2)
 2020 format (14h1valid problem)
 2030 format (14h1lds too small)
 2040 format (33h1all data and covariances missing)
 2050 format (31h1every other data value missing)
 2060 format (21h1minimum problem size)
 2070 format (32h1check handling of fmin and fmax)
 2080 format (21h1white noise spectrum)
      end
!NLCNT
     subroutine nlcnt(y, wt, lwt, xm, n, m, ixm, mdl, nldrv, aprxdv,&
    &   drv, par, npar, res, ifixed, lifixd, stp, lstp, mit, stopss,&
    &   stopp, scale, lscale, delta, ivaprx, rsd, pv, lpv, sdpv,&
    &   lsdpv, sdres, lsdres, vcv, ivcv, weight, save, nnzw, npare,&
     &   nlhdr, page, wide, iptout, ndigit, hlfrpt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
    &   ivaprx,ivcv,ixm,lifixd,lpv,lscale,lsdpv,lsdres,lstp,lwt,m,&
     &   mit,n,ndigit,nnzw,npar,npare
     logical&
     &   aprxdv,hlfrpt,page,save,weight,wide
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   par(*),pv(*),res(*),scale(*),sdpv(*),sdres(*),stp(*),vcv(*),&
     &   wt(*),xm(*),y(*)
     integer&
     &   ifixed(*),iptout(5)
!
!  SUBROUTINE ARGUMENTS
       external drv,mdl,nldrv,nlhdr
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
    &   d,ifixd,ifp,iiwork,irwork,iwork,lvcvl,nall0,pare,pvi,&
     &   rwork,sdpvi,sdresi,vcvl
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
!
!  EXTERNAL FUNCTIONS
     integer&
     &   stkst
!       EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL CPYASF,CPYVII,NLMN,SETIV,STKCLR
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     INTEGER D
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE ARRAY IN WHICH THE NUMERICAL DERIVATIVES WITH RESPECT TO
!        EACH PARAMETER ARE STORED.
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD
!        THE STARTING LOCATION IN ISTAK OF
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IIWORK
!        THE DIMENSION OF THE INTEGER WORK VECTOR IWORK.
!     INTEGER IPTOUT(5)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER IRWORK
!        THE DIMENSION OF THE REAL WORK VECTOR RWORK.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IWORK
!        THE STARTING LOCATION IN ISTAK OF
!        THE INTEGER WORK SPACE VECTOR USED BY THE NL2 SUBROUTINES.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LVCVL
!        THE LENGTH OF THE VECTOR CONTAINING
!        THE LOWER HALF OF THE VCV MATRIX, STORED ROW WISE.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        NUMBER OF ALLOCATIONS ON ENTRY.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     EXTERNAL NLDRV
!        THE NAME OF THE ROUTINE WHICH CALCULATES THE DERIVATIVES.
!     EXTERNAL NLHDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARE
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE CURRENT ESTIMATES OF THE PARAMETERS, BUT ONLY
!        THOSE TO BE OPTIMIZED (NOT THOSE WHOSE VALUES ARE FIXED).
!     REAL PV(LPV)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     INTEGER PVI
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE PREDICTED VALUES.
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER RWORK
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE REAL WORK VECTOR USED BY THE NL2 SUBROUTINES.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(LSCALE)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(LSDPV)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     INTEGER SDPVI
!        THE STARTING LOCATION IN RWORK OF
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(LSDRES)
!        THE STANDARDIZED RESIDUALS.
!     INTEGER SDRESI
!        THE STARTING LOCATION IN RWORK OF THE
!        THE STANDARDIZED RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(LSTP)
!        THE STEP SIZE ARRAY.
!     REAL VCV(IVCV,NPAR)
!        THE VARIANCE-COVARIANCE MATRIX.
!     INTEGER VCVL
!        THE STARTING LOCATION IN RWORK OF
!        THE VARIANCE-COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL WT(LWT)
!        THE WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET VARIOUS PROGRAM VALUES
!
      nall0 = stkst(1)
!
      ifp = 3
!
      ierr = 0
!
!     SUBDIVIDE WORK AREA FOR LEAST SQUARES ANALYSIS
!
      iiwork = npare + 60
      irwork = 94 + 2*n + npare*(3*npare+33)/2
!
      ifixd = stkget(npar,2)
      iwork = stkget(iiwork,2)
!
      d = stkget(n*npar,ifp)
      pare = stkget(npare,ifp)
      pvi = stkget(n,ifp)
      rwork = stkget(irwork,ifp)
!
      if (ierr.eq.1) return
!
!     SET VALUES FOR IFIXD
!
      if (ifixed(1).ge.0) call cpyvii(npar, ifixed, 1, istak(ifixd), 1)
      if (ifixed(1).lt.0) call setiv(istak(ifixd), npar, 0)
!
     call nlmn(y, weight, nnzw, wt, lwt, xm, n, m, ixm, mdl, nldrv,&
    &   aprxdv, drv, istak(ifixd), par, rstak(pare), npar, res, page,&
    &   wide, hlfrpt, stp, lstp, mit, stopss, stopp, scale, lscale,&
    &   delta, ivaprx, iptout, ndigit, rsd, rstak(pvi), sdpvi,&
    &   sdresi, vcvl, lvcvl, rstak(d), istak(iwork), iiwork,&
     &   rstak(rwork), irwork, nlhdr, npare)
!
      if (.not.save) go to 10
!
      sdpvi = rwork + sdpvi - 1
      sdresi = rwork + sdresi - 1
      vcvl = rwork + vcvl - 1
!
      call scopy(n, rstak(pvi), 1, pv, 1)
      call scopy(n, rstak(sdpvi), 1, sdpv, 1)
      call scopy(n, rstak(sdresi), 1, sdres, 1)
      call cpyasf(npare, rstak(vcvl), lvcvl, vcv, ivcv)
!
   10 call stkclr(nall0)
!
      return
!
      end
!AMEPT1
      subroutine amept1(n, y, pvt, sdpvt, res, sdrest, iptout, ndigit)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBOUTINE PRINTS THE DATA SUMMARY FOR THE NONLINEAR
!     LEAST SQUARES SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n,ndigit
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   pvt(*),res(*),sdpvt(*),sdrest(*),y(*)
     integer&
     &   iptout(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm
     integer&
     &   i,iprt,nmax
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,OBSSM2
!
!  INTRINSIC FUNCTIONS
      intrinsic max,min
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IPTOUT(NDIGIT)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     INTEGER NMAX
!        THE MAXIMUM NUMBER OF ROWS TO BE PRINTED.
!     REAL PVT(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL SDPVT(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDREST(N)
!        THE STANDARDIZED RESIDUALS.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
      fplm = r1mach(2)
!
      call iprint(iprt)
!
      write (iprt,1100)
      write (iprt,1000)
      write (iprt, 1110)
!
      nmax = n
     if ((max(iptout(3),1).eq.1) .and. (n.ge.45))&
     &  nmax = min(n,40)
!
!     PRINT OBSERVATION SUMMARY
!
      call obssm2(n, y, pvt, sdpvt, res, sdrest, 1, nmax)
!
      if (nmax.ge.n) go to 200
!
      do 195 i = 1, 3
         write (iprt, 1150)
  195 continue
!
!     PRINT LAST LINE OF OUTPUT
!
      call obssm2(n, y, pvt, sdpvt, res, sdrest, n, n)
!
  200 continue
!
      if ((ierr.eq.4)) write (iprt, 1080)
      if ((ierr.gt.0) .and. (ierr.ne.4)) write (iprt, 1090)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/ 5x, 16x, '  -----PREDICTED  ----STD DEV OF', 16x,&
    &   '  ---STD'/&
    &   2x, 3hrow, '  --------SERIES  ---------VALUE',&
     &   '  ----PRED VALUE  ------RESIDUAL  ---RES')
1080 format (// 37h *  nc  -  value not computed because,&
     &   48h the standard deviation of the residual is zero.)
1090 format (// 29h *  nc  -  value not computed,&
    &   54h because convergence problems prevented the covariance,&
     &   28h matrix from being computed.)
 1100 format (//' RESULTS FROM LEAST SQUARES FIT'/ 1x, 31('-'))
 1110 format (' ')
 1150 format (4x, '.', 4(15x, '.'), 7x, '.')
      end
!FITPT1
     subroutine fitpt1(n, m, xm, y, pv, sdpv, res, sdres, wt, ixm,&
     &   nnzw, weight, iptout)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBOUTINE PRINTS THE DATA SUMMARY FOR THE NONLINEAR
!     LEAST SQUARES SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iptout,ixm,m,n,nnzw
     logical&
     &   weight
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   pv(n),res(n),sdpv(n),sdres(n),wt(n),xm(ixm,m),y(n)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm
     integer&
     &   i,iprt,jcol1,jcolm,k,nmax
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,OBSSUM
!
!  INTRINSIC FUNCTIONS
      intrinsic min
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS HAVE
!        BEEN DETECTED.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPTOUT
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER JCOLM
!        THE LAST COLUMN OF THE INDEPENDENT VARIABLE TO BE PRINTED.
!     INTEGER JCOL1
!        THE FIRST COLUMN OF THE INDEPENDENT VARIABLE TO BE PRINTED.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NMAX
!        THE MAXIMUM NUMBER OF ROWS TO BE PRINTED.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     REAL PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(N)
!        THE USER SUPPLIED WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
      fplm = r1mach(2)
!
      call iprint(iprt)
!
      write (iprt,1100)
!
      if (weight) then
         write (iprt,1010)
      else
         write (iprt,1000)
      end if
      write (iprt, 1110)
!
!     TEST WHETHER COLUMN VECTOR XM(*, 1) = VECTOR 1.0E0
!
      do 10 i=1,n
         if (xm(i,1).ne.1.0e0) go to 20
   10 continue
      go to 30
!
!     NOT A UNIT VECTOR
!
   20 jcol1 = 1
      jcolm = min(m,3)
      go to 40
!
!     UNIT VECTOR
!
   30 jcolm = min(m,4)
      jcol1 = min(2,jcolm)
   40 k = jcolm - jcol1 + 1
!
      nmax = n
      if ((iptout.eq.1) .and. (n.ge.45)) nmax = min(n,40)
!
!     PRINT OBSERVATION SUMMARY
!
     call obssum(n, m, xm, y, pv, sdpv, res, sdres, wt, ixm,&
     &   weight, k, 1, nmax, jcol1, jcolm)
!
      if (nmax.ge.n) go to 200
!
      do 195 i = 1, 3
!
         go to (160, 170, 180), k
  160    write (iprt,1120)
         go to 190
  170    write (iprt,1130)
         go to 190
  180    write (iprt,1140)
!
  190    continue
         write (iprt, 1150)
         if (weight) write (iprt, 1160)
!
  195 continue
!
!     PRINT LAST LINE OF OUTPUT
!
     call obssum(n, m, xm, y, pv, sdpv, res, sdres, wt, ixm,&
     &   weight, k, n, n, jcol1, jcolm)
!
  200 continue
!
      if ((nnzw.lt.n) .and. (ierr.eq.0)) write (iprt, 1060)
      if ((nnzw.lt.n) .and. (ierr.eq.4)) write (iprt, 1070)
      if ((nnzw.eq.n) .and. (ierr.eq.4)) write (iprt, 1080)
      if ((ierr.gt.0) .and. (ierr.ne.4)) write (iprt, 1090)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/53x, 9hdependent, 7x, 9hpredicted, 5x, 12h std dev of ,&
    &   24x, 4hstd /&
    &   2x, 3hrow, 13x, 16hpredictor values, 20x, 8hvariable, 8x,&
     &   6h value, 8x, 12hpred value  , 6x, 9hresidual , 8x, 3hres)
1010 format (/53x, 9hdependent, 7x, 9hpredicted, 5x, 12h std dev of ,&
    &   24x, 4hstd /&
    &   2x, 3hrow, 13x, 16hpredictor values, 20x, 8hvariable, 8x,&
    &   6h value, 8x, 12hpred value  , 6x, 9hresidual , 8x, 3hres,&
     &   4x, 6hweight)
1060 format (// 37h *  nc  -  value not computed because,&
     &   20h the weight is zero.)
1070 format (// 44h *  nc  -  value not computed because either,&
    &   53h the weight or the standard deviation of the residual,&
     &   9h is zero.)
1080 format (// 37h *  nc  -  value not computed because,&
     &   48h the standard deviation of the residual is zero.)
1090 format (// 29h *  nc  -  value not computed,&
    &   54h because convergence problems prevented the covariance,&
     &   28h matrix from being computed.)
 1100 format (//31h results from least squares fit/ 1x, 31('-'))
 1110 format (' ')
 1120 format (4x, '.', 25x, '.')
 1130 format (4x, '.', 3x, 2(14x, '.'))
 1140 format (4x, '.', 10x, '.', 2(14x, '.'))
 1150 format ('+', 49x, 11x, '.', 3(15x, '.'), 11x, '.')
 1160 format ('+', 130x, '.')
      end
!DIFM
      subroutine difm (y, ymiss, n, yf, yfmiss, nyf)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PERFORMS A FIRST DIFFERENCE FILTERING OPERATION,
!     RETURNING THE FILTERED SERIES IN YF, FOR AN INPUT SERIES
!     CONTAINING MISSING VALUES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: yfmiss,ymiss
     integer&
     &   n,nyf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*),yf(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iar,iprt
     logical&
     &   err01,head
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   phi(1)
     character&
     &   ln(8)*1,nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,FLTARM,IPRINT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     CHARACTER*1 LN(8)
!        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES N.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     REAL PHI(1)
!        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!     REAL YFMISS
!        THE MISSING VALUE CODE USED IN THE FILTERED SERIES TO
!        INDICATE THE VALUE COULD NOT BE COMPUTED DUE TO MISSING DATA.
!     REAL YMISS
!        THE MISSING VALUE CODE USED IN THE INPUT SERIES TO INDICATE
!        AN OBSERVATION IS MISSING.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'D',       'I',       'F',       'M',       ' ',       ' '/
     data&
    &  ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 3, 1, head, err01, ln)
!
      if (.not. err01) go to 10
!
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   10 continue
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      iar = 1
      phi(1) = 1.0e0
!
      call fltarm (y, ymiss, n, iar, phi, yf, yfmiss, nyf)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   47h       call difm (y, ymiss, n, yf, yfmiss, nyf))
      end
!STPER
      subroutine stper(nmsub, n, m, ixm, npar, ldstak, scale, lscale)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE ERROR CHECKING ROUTINE FOR STEP SIZE SELECTION
!     ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,ldstak,lscale,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   scale(*)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   i,ldsmin,nv
     logical&
     &   head
!
!  LOCAL ARRAYS
     logical&
     &   error(10)
     character&
    &   lixm(8)*1,llds(8)*1,lm(8)*1,ln(8)*1,lnpar(8)*1,&
     &   lone(8)*1,lscl(8)*1,lzero(8)*1
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL EISGE,ERVGT,LDSCMP
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR(10)
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LIXM(8), LLDS(8), LM(8), LN(8), LNPAR(8), LONE(8),
!    +            LSCL(8), LZERO(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND.
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!
!     SET UP NAME ARRAYS
!
     data lixm(1), lixm(2), lixm(3), lixm(4), lixm(5), lixm(6),&
     &   lixm(7), lixm(8) /'I','X','M',' ',' ',' ',' ',' '/
     data llds(1), llds(2), llds(3), llds(4), llds(5), llds(6),&
     &   llds(7), llds(8) /'L','D','S','T','A','K',' ',' '/
     data lm(1), lm(2), lm(3), lm(4), lm(5), lm(6), lm(7), lm(8) /'M',&
     &   ' ',' ',' ',' ',' ',' ',' '/
     data ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8) /'N',&
     &   ' ',' ',' ',' ',' ',' ',' '/
     data lnpar(1), lnpar(2), lnpar(3), lnpar(4), lnpar(5),&
    &   lnpar(6), lnpar(7), lnpar(8) /'N','P','A','R',' ',' ',' ',&
     &   ' '/
     data lone(1), lone(2), lone(3), lone(4), lone(5),&
    &   lone(6), lone(7), lone(8) /' ',' ','O','N','E',' ',' ',&
     &   ' '/
     data lscl(1), lscl(2), lscl(3), lscl(4), lscl(5),&
    &   lscl(6), lscl(7), lscl(8) /'S','C','A','L','E',' ',' ',&
     &   ' '/
     data lzero(1), lzero(2), lzero(3), lzero(4), lzero(5),&
     &   lzero(6), lzero(7), lzero(8) /'Z','E','R','O',' ',' ',' ',' '/
!
!     ERROR CHECKING
!
      do 10 i=1,10
         error(i) = .false.
   10 continue
!
      ierr = 0
      head = .true.
!
      call eisge(nmsub, ln, n, 1, 2, head, error(1), lone)
!
      call eisge(nmsub, lm, m, 1, 2, head, error(2), lone)
!
      call eisge(nmsub, lixm, ixm, n, 3, head, error(3), ln)
!
      call eisge(nmsub, lnpar, npar, 1, 2, head, error(4), lone)
!
     call ldscmp(14, 0, 2*(n+npar), 0, 0, 0, 'S', 9*n + max(n,npar),&
     &            ldsmin)
!
     if ((.not.error(1)) .and. (.not.error(4)))&
    &   call eisge(nmsub, llds, ldstak, ldsmin, 9, head, error(5),&
     &   llds)
!
     call ervgt(nmsub, lscl, scale, lscale, 0.0e0, 0, head, 6, nv,&
     &   error(9), lzero)
!
!
      do 20 i=1,10
         if (error(i)) go to 30
   20 continue
      return
!
   30 continue
      ierr = 1
      return
!
      end
!NLSDC
     subroutine nlsdc(y, xm, n, m, ixm, mdl, drv, par, npar, res,&
    &   ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING ANALYTIC DERIVATIVES WITH USER
!     SUPPLIED CONTROL PARAMETERS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,stopp,stopss
     integer&
     &   idrvck,ivaprx,ixm,ldstak,m,mit,n,npar,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),res(*),scale(*),xm(*),y(*)
     integer&
     &   ifixed(*)
!
!  SUBROUTINE ARGUMENTS
       external drv,mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   iprt,ivcv,lifixd,lpv,lscale,lsdpv,lsdres,lwt,nnzw,npare
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   pv(1),sdpv(1),sdres(1),vcv(1,1),wt(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,NLCNTA
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE DERIVATIVES WE
!        CHECKED OR NOT.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(NPAR)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL VCV(1,1)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(1)
!        THE DUMMY ARRAY FOR THE WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'N','L','S','D','C',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      weight = .false.
      save = .false.
!
      wt(1) = 1.0e0
      lifixd = npar
      lpv = 1
      lscale = npar
      lsdpv = 1
      lsdres = 1
      lwt = 1
      ivcv = 1
!
     call nlcnta(y, wt, lwt, xm, n, m, ixm, mdl, drv, par, npar, res,&
    &   ldstak, ifixed, lifixd, idrvck, mit, stopss, stopp, scale,&
    &   lscale, delta, ivaprx, nprt, rsd, pv, lpv, sdpv, lsdpv, sdres,&
     &   lsdres, vcv, ivcv, nmsub, weight, save, nnzw, npare)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL NLSDC (Y, XM, N, M, IXM, NLSMDL, NLSDRV,'/&
    &   '      +            PAR, NPAR, RES, LDSTAK,'/&
    &   '      +            IFIXED, IDRVCK, MIT, STOPSS, STOPP,'/&
     &   '      +            SCALE, DELTA, IVAPRX, NPRT)')
      end
!XNLST
      subroutine xnlst(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DEMONSTRATE THE USER CALLABLE ROUTINES IN THE NONLINEAR
!     LEAST SQUARES FAMILY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
    &   i,idrvck,iprt,ivaprx,ivcv,ixm1,ixm2,ixm3,ldsa1,ldsmin,&
    &   ldsn1b,m1,m2,m3,mit,n1,n2,n3,nnzw,npar1,npar2,npar3,npare,&
     &   nprt,ntest
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   par1(10),par2(10),par3(10),pv(100),res(100),scale(10),&
    &   sdpv(100),sdres(100),stop(8),stp(10),vcv(6,6),wt(100),&
     &   xm1(10,2),xm2(10,3),xm3(101,5),y1(10),y2(10),y3(100)
     integer&
     &   ifixed(10),ivctst(9)
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DRV1A,DRV2,DRV3,FITXSP,IPRINT,LDSCMP,MDL1,MDL2,MDL3,NLSC,
!     +   NLSDC,NLSDS,NLSS,NLSWC,NLSWDC,NLSWDS,NLSWS,NLSX1,NLSX2,
!     +   SETRV
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV1A, DRV2, DRV3
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
!        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(10)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCTST(9)
!        VARIANCE-COVARIANCE CODE TEST VALUES.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM1, IXM2, IXM3
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSA1, LDSN1B
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK
!        FOR THE ROUTINES WITH ANALYTIC DERIVATIVES AND
!        NUMERICAL DERIVATIVES, RESPECTIVELY.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M1, M2, M3
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL1, MDL2, MDL3
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N1, N2, N3
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
!     INTEGER NPAR1, NPAR2, NPAR3
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     REAL PAR1(10), PAR2(10), PAR3(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL PV(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(100)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     REAL SCALE(10)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     REAL SDPV(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF THE
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOP(8)
!        STOPPING CRITERIA TEST VARIABLE.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(10)
!        THE RCSTEP SIZE ARRAY.
!     REAL VCV(6,6)
!        THE COVARIANCE MATRIX.
!     REAL WT(100)
!        THE USER SUPPLIED WEIGHTS.
!     REAL XM1(10,2), XM2(10,3), XM3(101,5)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y1(10), Y2(10), Y3(100)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     DEFINE CONSTANTS
!
     data y1(1), y1(2), y1(3), y1(4), y1(5), y1(6)&
     &   /2.138e0, 3.421e0, 3.597e0, 4.340e0, 4.882e0, 5.660e0/
!
     data xm1(1,1), xm1(2,1), xm1(3,1), xm1(4,1), xm1(5,1), xm1(6,1)&
     &   /1.309e0, 1.471e0, 1.490e0, 1.565e0, 1.611e0, 1.680e0/
!
      data n2 /10/, m2 /3/, ixm2 /10/, npar2 /3/
!
      data n3 /50/, m3 /5/, ixm3 /101/, npar3 /5/
!
      call iprint(iprt)
!
     call nlsx2(n1, m1, ixm1, npar1, ifixed, stp, idrvck, mit, stopss,&
     &   stopp, scale, delta, ivaprx, nprt, ivcv)
!
      call setrv(wt, n3, 1.0e0)
!
     call ldscmp(6, 0, 60+2*npar1, 0, 0, 0,&
     &   'S', 94+n1*(3+npar1)+npar1*(3*npar1+35)/2, ldsa1)
     call ldscmp(14, 0, 60+2*npar1, 0, 0, 0,&
     &   'S', 94+n1*(3+npar1)+npar1*(3*npar1+37)/2, ldsn1b)
     call ldscmp(14, 0, max(2*(n3+npar3),60+2*npar3), 0, 0, 0,&
     &   'S', max(10*n3,94+n3*(3+npar3)+npar3*(3*npar3+37)/2), ldsmin)
!
      if (ldsmin.le.ldstak) go to 5
!
      write (iprt, 1000) ldsmin
      return
!
    5 continue
!
      do 10 i=1,n2
         y2(i) = 0.0e0
         xm2(i,1) = i
         xm2(i,2) = i + 0.125e0
         xm2(i,3) = i + 0.25e0
   10 continue
!
      do 20 i=1,n3
         xm3(i,1) = 1.0e0
         xm3(i,2) = i
         xm3(i,3) = xm3(i,2)*xm3(i,2)
         xm3(i,4) = xm3(i,3)*xm3(i,2)
         xm3(i,5) = xm3(i,4)*xm3(i,2)
         y3(i) = xm3(i,1) + xm3(i,2) + xm3(i,3) + xm3(i,4) + xm3(i,5)
   20 continue
!
      ntest = 0
!
!
!
!     **TEST CHECKING OF CONTROL CRITERIA**
!
      write (iprt,1240)
!
      stop(1) = rmdcon(3,typ=0.0_wp)
      stop(2) = 0.1e0
      stop(3) = 0.9e0*rmdcon(3,typ=0.0_wp)
      stop(4) = 0.11e0
      stop(5) = 0.0e0
      stop(6) = 1.0e0
      stop(7) = -1.0e0
      stop(8) = 1.1e0
!
      nprt = 11000
      mit = 0
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1250) mit
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
      write (iprt,1100)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp, scale(1),&
     &   delta, ivaprx, nprt
     call nlswdc(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
    &   res, ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp, scale(1),&
     &   delta, ivaprx, nprt
      write (iprt,1120) ierr
!
      mit = 1
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1250) mit
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
      write (iprt,1100)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp, scale(1),&
     &   delta, ivaprx, nprt
     call nlswdc(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
    &   res, ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp, scale(1),&
     &   delta, ivaprx, nprt
      write (iprt,1120) ierr
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1250) mit
     call nlsx1(2, par2, npar2, pv, sdpv, res, sdres, vcv, n2, ivcv,&
     &   nnzw, npare, rsd)
      write (iprt,1050)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsws(y2, wt, xm2, n2, m2, ixm2, mdl2, par2, npar2, res,&
    &   ldstak, ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx,&
     &   nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par2, pv, sdpv, res, sdres, vcv, n2, npar2, ivcv,&
     &   nnzw, npare, rsd)
!
     call nlsx2(n1, m1, ixm1, npar1, ifixed, stp, idrvck, mit, stopss,&
     &   stopp, scale, delta, ivaprx, nprt, ivcv)
      do 40 i=1,4
         ntest = ntest + 1
         write (iprt,1330) ntest
         write (iprt,1260) stop(i)
        call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1,&
     &      ivcv, nnzw, npare, rsd)
         write (iprt,1100)
        write (iprt,1360) ifixed(1), idrvck, mit, stop(i), stopp,&
     &      scale(1), delta, ivaprx, nprt
        call nlswdc(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1,&
    &      npar1, res, ldstak, ifixed, idrvck, mit, stop(i), stopp,&
     &      scale, delta, ivaprx, nprt)
        write (iprt,1370) ifixed(1), idrvck, mit, stop(i), stopp,&
     &      scale(1), delta, ivaprx, nprt
         write (iprt,1120) ierr
   40 continue
      do 50 i=5,8
         ntest = ntest + 1
         write (iprt,1330) ntest
         write (iprt,1270) stop(i)
        call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1,&
     &      ivcv, nnzw, npare, rsd)
         write (iprt,1100)
        write (iprt,1360) ifixed(1), idrvck, mit, stopss, stop(i),&
     &      scale(1), delta, ivaprx, nprt
        call nlswdc(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1,&
    &      npar1, res, ldstak, ifixed, idrvck, mit, stopss, stop(i),&
     &      scale, delta, ivaprx, nprt)
        write (iprt,1370) ifixed(1), idrvck, mit, stopss, stop(i),&
     &      scale(1), delta, ivaprx, nprt
         write (iprt,1120) ierr
   50 continue
      nprt = 100000
      do 60 i=1,6
         ntest = ntest + 1
         write (iprt,1330) ntest
         write (iprt,1280) nprt
        call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1,&
     &      ivcv, nnzw, npare, rsd)
         write (iprt,1110)
        write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &      scale(1), delta, ivaprx, nprt
        call nlswds(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1,&
    &      npar1, res, ldsa1, ifixed, idrvck, mit, stopss, stopp,&
    &      scale, delta, ivaprx, nprt, nnzw, npare, rsd, pv, sdpv,&
     &      sdres, vcv, ivcv)
        write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &      scale(1), delta, ivaprx, nprt
         write (iprt,1120) ierr
        call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &      nnzw, npare, rsd)
         nprt = nprt/10
   60 continue
      nprt = 11000
      do 70 i=1,2
         ntest = ntest + 1
         write (iprt,1330) ntest
         write (iprt,1280) nprt
        call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1,&
     &      ivcv, nnzw, npare, rsd)
         write (iprt,1110)
        write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &      scale(1), delta, ivaprx, nprt
        call nlswds(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1,&
    &      npar1, res, ldsa1, ifixed, idrvck, mit, stopss, stopp,&
    &      scale, delta, ivaprx, nprt, nnzw, npare, rsd, pv, sdpv,&
     &      sdres, vcv, ivcv)
        write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &      scale(1), delta, ivaprx, nprt
         write (iprt,1120) ierr
        call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &      nnzw, npare, rsd)
         nprt = 11001
   70 continue
!
      nprt = 0
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1280) nprt
!
      write (iprt,1010)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlsc(y1, xm1, n1, m1, ixm1, mdl1, par1, npar1, res, ldsn1b,&
     &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1280) nprt
      write (iprt,1020)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlss(y1, xm1, n1, m1, ixm1, mdl1, par1, npar1, res, ldsn1b,&
    &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt,&
     &   npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1280) nprt
      write (iprt,1040)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlswc(y1, wt, xm1, n1, m1, ixm1, mdl1, par1, npar1, res,&
    &   ldsn1b, ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx,&
     &   nprt)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1280) nprt
      write (iprt,1050)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlsws(y1, wt, xm1, n1, m1, ixm1, mdl1, par1, npar1, res,&
    &   ldsn1b, ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx,&
     &   nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1280) nprt
      write (iprt,1070)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlsdc(y1, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1, res,&
    &   ldsa1, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1280) nprt
      write (iprt,1080)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlsds(y1, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1, res,&
    &   ldsa1, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1280) nprt
      write (iprt,1100)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlswdc(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
    &   res, ldsa1, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1280) nprt
      write (iprt,1110)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlswds(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
    &   res, ldsa1, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
      nprt = -1
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1280) nprt
      write (iprt,1110)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlswds(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
    &   res, ldsa1, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
!
!     **TEST PARAMETER HANDLING**
!
      write (iprt,1190)
!
!     ALL ZERO
!
     call nlsx2(n1, m1, ixm1, npar1, ifixed, stp, idrvck, mit, stopss,&
     &   stopp, scale, delta, ivaprx, nprt, ivcv)
      stp(1) = -1.0e0
      scale(1) = -1.0e0
      delta = -1.0e0
      nprt = 11000
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1200)
     call nlsx1(4, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
      write (iprt,1010)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsc(y1, xm1, n1, m1, ixm1, mdl1, par1, npar1, res, ldstak,&
     &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
     call nlsx1(4, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1200)
      write (iprt,1100)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlswdc(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
    &   res, ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
!
!
!     **TEST WITH CONSTANT Y**
!
!     CONSTANT Y=0
!
      nprt = 21222
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1210)
     call nlsx1(2, par2, npar2, pv, sdpv, res, sdres, vcv, n2, ivcv,&
     &   nnzw, npare, rsd)
      write (iprt,1050)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsws(y2, wt, xm2, n2, m2, ixm2, mdl2, par2, npar2, res,&
    &   ldstak, ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx,&
     &   nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par2, pv, sdpv, res, sdres, vcv, n2, npar2, ivcv,&
     &   nnzw, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1210)
      write (iprt,1110)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(2, par2, npar2, pv, sdpv, res, sdres, vcv, n2, ivcv,&
     &   nnzw, npare, rsd)
     call nlswds(y2, wt, xm2, n2, m2, ixm2, mdl2, drv2, par2, npar2,&
    &   res, ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par2, pv, sdpv, res, sdres, vcv, n2, npar2, ivcv,&
     &   nnzw, npare, rsd)
!
!     **TEST WITH LINEAR MODEL**
!
      nprt = 11212
      ivaprx = 1
!
      do 80 i=1,npar3
         ifixed(i) = 0
   80 continue
      ifixed(1) = 1
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1220)
      write (iprt,1010)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(3, par3, npar3, pv, sdpv, res, sdres, vcv, n3, ivcv,&
     &   nnzw, npare, rsd)
     call nlsc(y3, xm3, n3, m3, ixm3, mdl3, par3, npar3, res, ldstak,&
     &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1220)
      nprt = 11111
      write (iprt,1070)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(3, par3, npar3, pv, sdpv, res, sdres, vcv, n3, ivcv,&
     &   nnzw, npare, rsd)
     call nlsdc(y3, xm3, n3, m3, ixm3, mdl3, drv3, par3, npar3, res,&
    &   ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
!
!     **TEST XM**
!
!
!     FIRST COLUMN ZERO
!
      call setrv(y2, n2, 2.0e0)
      call setrv(xm2(1,1), n2, 0.0e0)
!
      nprt = 11000
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1310)
     call nlsx1(2, par2, npar2, pv, sdpv, res, sdres, vcv, n2, ivcv,&
     &   nnzw, npare, rsd)
      write (iprt,1110)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlswds(y2, wt, xm2, n2, m2, ixm2, mdl2, drv2, par2, npar2,&
    &   res, ldstak, ifixed, idrvck, mit, stopss, stopp, scale,&
    &   delta, ivaprx, nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv,&
     &   ivcv)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par2, pv, sdpv, res, sdres, vcv, n2, npar2, ivcv,&
     &   nnzw, npare, rsd)
!
!     2 COLUMNS ZERO
!
      call setrv(xm2(1,2), n2, 0.0e0)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1300)
      write (iprt,1110)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsx1(2, par2, npar2, pv, sdpv, res, sdres, vcv, n2, ivcv,&
     &   nnzw, npare, rsd)
     call nlswds(y2, wt, xm2, n2, m2, ixm2, mdl2, drv2, par2, npar2,&
    &   res, ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par2, pv, sdpv, res, sdres, vcv, n2, npar2, ivcv,&
     &   nnzw, npare, rsd)
!
!     **TEST VARIANCE-COVARIANCE MATRIX COMPUTATIONS**
!
!
      ivctst(1) = -1
      ivctst(2) = 0
      ivctst(3) = 1
      ivctst(4) = 2
      ivctst(5) = 3
      ivctst(6) = 4
      ivctst(7) = 5
      ivctst(8) = 6
      ivctst(9) = 7
      nprt = 2
      do 90 i=1,9
         ntest = ntest + 1
         write (iprt,1330) ntest
         write (iprt,1380)
        call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1,&
     &      ivcv, nnzw, npare, rsd)
         write (iprt,1110)
        write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &      scale(1), delta, ivctst(i), nprt
        call nlswds(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1,&
    &      npar1, res, ldstak, ifixed, idrvck, mit, stopss, stopp,&
    &      scale, delta, ivctst(i), nprt, nnzw, npare, rsd, pv, sdpv,&
     &      sdres, vcv, ivcv)
        write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &      scale(1), delta, ivctst(i), nprt
         write (iprt,1120) ierr
        call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &      nnzw, npare, rsd)
   90 continue
!
!     **TEST WITH 2 ZERO WEIGHTS**
!
      nprt = 22222
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1290)
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
      wt(3) = 0.0e0
      wt(5) = 0.0e0
      write (iprt,1110)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlswds(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
    &   res, ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par1, pv, sdpv, res, sdres, vcv, n1, npar1, ivcv,&
     &   nnzw, npare, rsd)
!
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (45h1 *** ldstak must be greater than or equal to , i6)
 1010 format (15h test of nlsc  )
 1020 format (15h test of nlss  )
 1040 format (15h test of nlswc )
 1050 format (15h test of nlsws )
 1070 format (15h test of nlsdc )
 1080 format (15h test of nlsds )
 1100 format (15h test of nlswdc)
 1110 format (15h test of nlswds)
1120 format (/29h ***** returned results *****, 5x, 15h (-1 indicates ,&
     &   39hvalue not changed by called subroutine)//9h ierr is , i3)
 1190 format (28h **test parameter handling**)
 1200 format (20h all parameters zero)
 1210 format (30h **test with constant zero y**)
 1220 format (22h **test linear model**)
 1240 format (26h **test control criteria**)
 1250 format (34h --maximum number of iterations = , i5)
 1260 format (12h --stopss = , g14.8)
 1270 format (11h --stopp = , g14.8)
 1280 format (10h --nprt = , i6)
 1290 format (29h **test with 2 zero weights**)
 1300 format (19h **2 columns zero**)
 1310 format (18h **1 column zero**)
1330 format (54h1nonlinear least squares estimation subroutine test nu,&
     &   4hmber, i5/)
1340 format (24h input   -  ifixed(1) = , i6, 9x, 11h, stp(1) = ,&
    &   g15.8, 11h,    mit = ,i5, 11h, stopss = , g15.8, 10h, stopp = ,&
    &   g15.8/13x, 11hscale(1) = , g15.8, 11h,  delta = , g15.8,&
     &   11h, ivaprx = , i5, 11h,   nprt = , i6)
1350 format (//24h output  -  ifixed(1) = , i6, 9x, 11h, stp(1) = ,&
    &   g15.8, 11h,    mit = ,i5, 11h, stopss = , g15.8, 10h, stopp = ,&
    &   g15.8/13x, 11hscale(1) = , g15.8, 11h,  delta = , g15.8,&
     &   11h, ivaprx = , i5, 11h,   nprt = , i6//)
1360 format (24h input   -  ifixed(1) = , i6, 9x, 11h, idrvck = ,&
    &   i5, 10x, 11h,    mit = ,i5, 11h, stopss = , g15.8,&
    &   10h, stopp = , g15.8/&
    &   13x, 11hscale(1) = , g15.8, 11h,  delta = , g15.8,&
     &   11h, ivaprx = , i5, 11h,   nprt = , i6)
1370 format (//24h output  -  ifixed(1) = , i6, 9x, 11h, idrvck = ,&
    &   i5, 10x, 11h,    mit = ,i5, 11h, stopss = , g15.8,&
    &   10h, stopp = , g15.8/&
    &   13x, 11hscale(1) = , g15.8, 11h,  delta = , g15.8,&
     &   11h, ivaprx = , i5, 11h,   nprt = , i6//)
1380 format (54h test handling of variance-covariance computation code,&
     &   'S')
      end
!AMEANM
      subroutine ameanm (y, ymiss, n, nused, ymean)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE ARITHMETIC MEAN OF A SERIES WHEN MISSING
!     DATA ARE INVOLVED.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: ymean,ymiss
     integer&
     &   n,nused
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   sumy
     integer&
     &   i
!
!  EXTERNAL FUNCTIONS
     logical&
     &   mvchk
!       EXTERNAL MVCHK
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NUSED
!        THE NUMBER OF ACTIVE NUMBER OF OBSERVATIONS.
!     REAL SUMY
!        THE VARIABLE USED TO SUM THE NON-MISSING Y VALUES.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     REAL YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!
      nused = 0
      sumy = 0.0e0
      do 10 i = 1, n
         if (mvchk(y(i), ymiss)) go to 10
         sumy = sumy + y(i)
         nused = nused + 1
   10 continue
      if (nused.ge.1) then
         ymean = sumy / nused
      else
         ymean = sumy
      end if
      return
      end
!ETAMDL
     subroutine etamdl(mdl, par, npar, xm, n, m, ixm, eta, neta,&
     &   partmp, pv, nrowin)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO COMPUTE NOISE AND NUMBER OF GOOD DIGITS IN
!     RESULTS OF MODEL ROUTINE AT ROW <NROW>.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   eta
     integer&
     &   ixm,m,n,neta,npar,nrowin
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),partmp(npar),pv(n),xm(ixm,m)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   a,b,fac,fplrs,j,rsssm,rsssmj,sqrtmp
     integer&
     &   i,k,nrow
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rss(5)
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
!       EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL SETROW
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,log10,max,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL A, B
!        PARAMETERS OF THE FIT.
!     REAL ETA
!        THE NOISE IN THE MODEL RESULTS.
!     REAL FAC
!        A FACTOR USED IN THE COMPUTATIONS.
!     REAL FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     REAL J
!        THE VALUE FLOAT(I-3).
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER M
!        NUMBER OF VARIABLES
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        NUMBER OF OBSERVATIONS
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL RESULTS.
!     INTEGER NPAR
!        NUMBER OF PARAMETERS
!     INTEGER NROW
!        THE ROW NUMBER ACTUALLY USED.
!     INTEGER NROWIN
!        THE INPUT NUMBER OF THE ROW BEING CHECKED.
!     REAL PAR(NPAR)
!        MODEL PARAMETERS
!     REAL PARTMP(NPAR)
!        MODIFIED MODEL PARAMETERS
!     REAL PV(N)
!        PREDICTED VALUES
!     REAL RSS(5)
!        THE RESIDUAL SUM OF SQUARES FOR EACH VALUE OF J.
!     REAL RSSSM
!        THE SUM OF THE RESIDUAL SUM OF SQUARES FOR EACH SET OF
!        PARAMETER VALUES.
!     REAL RSSSMJ
!        THE SUM OF THE RESIDUAL SUM OF SQUARES TIMES J FOR EACH
!        SET OF PARAMETER VALUES.
!     REAL SQRTMP
!        THE SQUARE ROOT OF MACHINE PRECISION (FPLRS).
!     REAL XM(IXM,M)
!        INDEPENDENT VARIABLES
!
      fplrs = r1mach(4)
!
!     SELECT FIRST ROW OF INDEPENDENT VARIABLES WHICH CONTAINS NO ZEROS
!
      call setrow(nrowin, xm, n, m, ixm, nrow)
!
      sqrtmp = sqrt(fplrs)
      rsssm = 0.0e0
      rsssmj = 0.0e0
      do 20 i=1,5
         j = i-3
         do 10 k=1,npar
            partmp(k) = par(k)*(1.0e0+j*sqrtmp)
   10    continue
         call mdl(partmp, npar, xm, n, m, ixm, pv)
!
         rss(i) = pv(nrow)
!
         rsssm = rsssm + rss(i)
         rsssmj = rsssmj + j*rss(i)
   20 continue
      a = 0.2e00*rsssm
      b = 0.1e00*rsssmj
      fac = 1.0e0
      if (rss(3).ne.0.0e0) fac = fac/rss(3)
      do 30 i=1,5
         j = i-3
         rss(i) = abs((rss(i)-(a+j*b))*fac)
   30 continue
      eta = max(rss(1),rss(2),rss(3),rss(4),rss(5),fplrs)
      neta = -log10(eta)
      eta = 10.0e0**(-neta)
      return
      end
!NLS
      subroutine nls(y, xm, n, m, ixm, mdl, par, npar, res, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
!     (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,ldstak,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),res(*),xm(*),y(*)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
    &   iprt,ivaprx,ivcv,lifixd,lpv,lscale,lsdpv,lsdres,lstp,lwt,&
     &   mit,nnzw,npare,nprt
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   pv(1),scale(1),sdpv(1),sdres(1),stp(1),vcv(1,1),wt(1)
     integer&
     &   ifixed(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,NLCNTN
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(1)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(1)
!        THE STEP SIZE ARRAY.
!     REAL VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(1)
!        THE DUMMY ARRAY FOR THE WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'N','L','S',' ',' ',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      weight = .false.
      save = .false.
!
      wt(1) = 1.0e0
      stp(1) = -1.0e0
      mit = -1
      stopss = -1.0e0
      stopp = -1.0e0
      scale(1) = -1.0e0
      delta = -1.0e0
      nprt = -1
      ifixed(1) = -1
      ivaprx = 0
      lifixd = 1
      lpv = 1
      lstp = 1
      lscale = 1
      lsdpv = 1
      lsdres = 1
      lwt = 1
      ivcv = 1
!
     call nlcntn(y, wt, lwt, xm, n, m, ixm, mdl, par, npar, res,&
    &   ldstak, ifixed, lifixd, stp, lstp, mit, stopss, stopp, scale,&
    &   lscale, delta, ivaprx, nprt, rsd, pv, lpv, sdpv, lsdpv, sdres,&
     &   lsdres, vcv, ivcv, nmsub, weight, save, nnzw, npare)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL NLS (Y, XM, N, M, IXM, NLSMDL,'/&
     &   '      +          PAR, NPAR, RES, LDSTAK)')
      end
!NLCNTN
     subroutine nlcntn(y, wt, lwt, xm, n, m, ixm, mdl, par, npar, res,&
    &   ldstak, ifixed, lifixd, stp, lstp, mit, stopss, stopp, scale,&
    &   lscale, delta, ivcvop, nprt, rsd, pv, lpv, sdpv, lsdpv, sdres,&
     &   lsdres, vcv, ivcv, nmsub, weight, save, nnzw, npare)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
    &   ivcv,ivcvop,ixm,ldstak,lifixd,lpv,lscale,lsdpv,lsdres,&
     &   lstp,lwt,m,mit,n,nnzw,npar,npare,nprt
     logical&
     &   save,weight
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   par(*),pv(*),res(*),scale(*),sdpv(*),sdres(*),stp(*),vcv(*),&
     &   wt(*),xm(*),y(*)
     integer&
     &   ifixed(*)
     character&
     &   nmsub(6)*1
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   exmpt
     integer&
     &   ifp,is,isubhd,ldsmin,nall0,ndigit,neta,stpi
     logical&
     &   aprxdv,hlfrpt,page,prtfxd,wide
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   iptout(5),istak(12)
!
!  EXTERNAL FUNCTIONS
     integer&
     &   icnti,stkst
!       EXTERNAL ICNTI,STKST
!
!  EXTERNAL SUBROUTINES
       external drv,ldscmp,nlcnt,nldrvn,nler,nlhdrn,prtcnt,stkclr,&
     &   stkset,stpcnt
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IPTOUT(5)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER IS
!        A VALUE USED TO DETERMINE THE AMOUNT OF WORK SPACE NEEDED
!        BASED ON WHETHER STEP SIZES ARE INPUT OR ARE TO BE CALCULATED.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISUBHD
!        AN INTEGER VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IVCVOP
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVCVOP LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVCVOP EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVCVOP EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVCVOP EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVCVOP EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVCVOP EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVCVOP EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVCVOP GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        NUMBER OF ALLOCATIONS ON ENTRY.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL RESULTS.
!     EXTERNAL NLDRVN
!        THE NAME OF THE ROUTINE WHICH CALCULATES THE DERIVATIVES.
!     EXTERNAL NLHDRN
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     REAL PV(LPV)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(LSCALE)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(LSDPV)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(LSDRES)
!        THE STANDARDIZED RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(LSTP)
!        THE STEP SIZE ARRAY.
!     INTEGER STPI
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE STEP SIZE ARRAY.
!     REAL VCV(IVCV,NPAR)
!        THE VARIANCE-COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL WT(LWT)
!        THE WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET VARIOUS PROGRAM VALUES
!
      hlfrpt = .false.
      aprxdv = .true.
      prtfxd = .true.
      exmpt = -1.0e0
      neta = 0
!
      wide = .true.
      page = .false.
!
      ndigit = 5
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      if ((ifixed(1).ge.0) .and. (npar.ge.1)) then
         npare = icnti(ifixed,npar,0)
      else
         npare = npar
      end if
!
      if (stp(1).le.0.0e0) then
         is = 1
      else
         is = 0
      end if
!
     call ldscmp(14, 0, max(is*2*(n+npar),60+npar+npare), 0, 0, 0,&
    &   'S',&
    &   max(is*(9*n+max(n,npar)),94+n*(3+npar)+npare*(3*npare+37)/2),&
     &   ldsmin)
!
     call nler (nmsub, weight, wt, lwt, n, m, ixm,&
    &   ifixed, lifixd, npar, npare,&
     &   ldstak, ldsmin, stp, lstp, scale, lscale, ivcv, save, nnzw)
!
      if (ierr.ne.0) return
!
      call stkset(ldstak, 4)
!
!     SET PRINT CONTROL VALUES
!
      call prtcnt(nprt, ndigit, iptout)
!
!     SUBDIVIDE WORKSPACE FOR STEP SIZES
!
      nall0 = stkst(1)
!
      ifp = 3
!
      stpi = stkget(npar,ifp)
!
!     COPY SUPPLIED STEP SIZES TO WORK SPACE
!
      call scopy(lstp, stp, 1, rstak(stpi), 1)
!
      if (ierr.ne.0) go to 10
!
!     SELECT STEP SIZES, IF DESIRED
!
      isubhd = 1
!
     if (stp(1).le.0.0e0) call stpcnt(xm, n, m, ixm, mdl, par, npar,&
    &   rstak(stpi), exmpt, neta, scale, lscale, iptout(1), nlhdrn,&
     &   page, wide, isubhd, hlfrpt, prtfxd, ifixed, lifixd)
!
     call nlcnt(y, wt, lwt, xm, n, m, ixm, mdl, nldrvn, aprxdv, drv,&
    &   par, npar, res, ifixed, lifixd, rstak(stpi), npar, mit,&
    &   stopss, stopp, scale, lscale, delta, ivcvop, rsd, pv, lpv,&
    &   sdpv, lsdpv, sdres, lsdres, vcv, ivcv, weight, save, nnzw,&
     &   npare, nlhdrn, page, wide, iptout, ndigit, hlfrpt)
!
   10 continue
!
      call stkclr(nall0)
!
      return
!
      end
!MDLTS3
      subroutine mdlts3 (par, npar, xm, n, m, ixm, rests)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR ESTIMATING BOX-JENKINS
!     ARIMA MODELS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 4, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),rests(nrests),xm(ixm,m)
!
!  SCALARS IN COMMON
     integer&
    &   iflag,mbo,mbol,mspect,nfact,nparar,npardf,nparma,nrests,&
     &   parar,pardf,parma,t,temp
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   pmu
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL MDLTS2
!
!  COMMON BLOCKS
      common /cstak/dstak
     common /mdltsc/mspect,nfact,pardf,npardf,parar,nparar,parma,&
     &   nparma,mbo,mbol,t,temp,nrests,iflag
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IFLAG
!        AN INDICATOR VARIABLE DESIGNATING WHETHER THE BACK FORECASTS
!        WERE ESSENTIALLY ZERO (IFLAG=0) OR NOT (IFLAG=1).
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IXM
!        THE FIRST DIMENSION OF MATRIX XM.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBOL
!        THE MAXIMUM BACK ORDER ON THE LEFT
!     INTEGER MSPECT
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFACT
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARAR
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE AUTOREGRESSIVE PARAMETERS
!     INTEGER PARDF
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
!     INTEGER PARMA
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE MOVING AVERAGE PARAMETERS
!     REAL PMU
!        THE VALUE OF MU, I.E., THE TREND OR MEAN.
!     REAL RESTS(NRESTS)
!        THE RESIDUALS FROM THE ARIMA MODEL.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER T
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR.
!     INTEGER TEMP
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR
!     REAL XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!
!
!     COMPUTE RESIDUALS
!
     call mdlts2 (par, rests, xm(1,1), npar, n, nfact, istak(mspect),&
    &  pmu, rstak(pardf), npardf, rstak(t), rstak(temp), rstak(parar),&
     &  rstak(parma), mbo, n-nrests+1, n, iflag)
!
      return
      end
!BFSM
      subroutine bfsm(y1, ymiss1, y2, ymiss2, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
!     FOURIER SPECTRUM ANALYSIS OF SERIES WITH MISSING OBSERVATIONS
!     (SHORT CALL)
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ymiss1,ymiss2
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y1(*),y2(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta,fmax,fmin
     integer&
    &   iccov,icspc2,index1,index2,inlppc,iphas,iprt,jccov,jnlppc,&
     &   lagmax,lagmx1,ldsmin,ldstak,lpcv,lw,ly,m,nf,nprt,nw
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   ccov(101,2,2),ceven(101),codd(101),cspc2(101,4),freq(101),&
    &   phas(101,4),spcf1(101),spcf2(101),w(101),xaxis(404),&
     &   yaxis(404)
     integer&
     &   isym(404),lags(4),nlppc(101,2,2)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL BFSDRV,ECVF,IPRINT,PARZEN,SETLAG
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL CCOV(101,2,2)
!        THE COVARIANCES.
!     REAL CEVEN(101)
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     REAL CODD(101)
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     REAL CSPC2(101,4)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISYM(404)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC(101,2,2)
!        THE NUMBER OF OBSERVATIONS IN EACH COVARIANCE ESTIMATE
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL PHAS(101,4)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL SPCF1(101), SPCF2(101)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     REAL W(101)
!        THE WINDOWS.
!     REAL XAXIS(404)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YAXIS(404)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YMISS1, YMISS2
!        THE MISSING VALUE CODES
!     REAL Y1(N)
!        THE FIRST TIME SERIES.
!     REAL Y2(N)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'B','F','S','M',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      option(1) = .false.
      option(2) = .true.
      option(3) = .false.
      option(4) = .false.
!
      iccov = 101
      jccov = 2
      m = 2
      index1 = 1
      index2 = 2
!
      icspc2 = 101
      iphas = 101
!
      ldstak = 0
      ldsmin = 0
!
      nf = 101
      inlppc = 101
      jnlppc = 2
      lw = 101
      ly = n
      lpcv = 404
!
!     SET MAXIMUM LAG VALUE (LAGMAX)
!     SET NUMBER OF LAG WINDOW TRUCCATION POINTS (NW)
!
      call setlag(n, lagmax)
      nw = 4
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
     call bfsdrv(y1, y2, ymiss1, ymiss2, ccov, nlppc, spcf1, spcf2,&
    &   nf, fmin, fmax, freq, n, nw, lagmax, lags, lagmx1, w, lw,&
    &   delta, isym, xaxis, yaxis, lpcv, alpha, nprt, parzen, iccov,&
    &   jccov, m, index1, index2, cspc2, phas, icspc2, iphas, codd,&
    &   ceven, w, lw, nmsub, ldsmin, ldstak, option, n, inlppc,&
     &   jnlppc, ly)
!
      if (ierr.ne.0) then
        if (ierr.eq.2) call ecvf(nmsub)
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL BFSM (Y1, YMISS1, Y2, YMISS2, N)')
      end
!UFSS
     subroutine ufss(y, n, nw, lags, nf, fmin, fmax, nprt,&
     &   spcf, ispcf, freq, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fmax,fmin
     integer&
     &   ispcf,ldstak,n,nf,nprt,nw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(*),spcf(*),y(*)
     integer&
     &   lags(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
      real(kind=wp) :: alpha,delta,ymiss
     integer&
    &   acov,i,ifp,io,iprt,isort,isym,lacov,lagmax,ldsmin,lnlppa,&
     &   lpcv,lwork,ly,nall0,work,xaxis,yaxis
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12),nlppa(1)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
     integer&
     &   stkst
!       EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UFSDRV
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER ACOV
!        THE STARTING LOCATION IN RSTAK FOR THE ACVF VECTOR.
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE SPECTRUM
!        IS TO BE COMPUTED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF ERR01, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION FOR THE ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY ISYM.
!     INTEGER LACOV
!        THE LENGTH OF VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
!        THIS ROUTINE WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(1)
!        A DUMMY ARRAY FOR SERIES WITHOUT MISSING VALUES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL SPCF(ISPCF,NW)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY WINDOW.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY XAXIS.
!     REAL Y(N)
!         THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY YAXIS.
!     REAL YMISS
!        THE MISSING VALUE CODE FOR THE SERIES.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'U','F','S','S',' ',' '/
!
!     SET UP
!
      option(4) = .true.
      option(3) = .false.
      option(2) = .false.
      option(1) = .false.
!
!     SET MAXIMUM LAG VALUE TO BE USED.
!
      lagmax = n - 1
      if (nw.le.0) go to 20
      lagmax = lags(1)
      do 10 i=1,nw
         lagmax = max(lagmax,lags(i))
   10 continue
   20 continue
      lacov = lagmax + 1
      lnlppa = 1
!
!     COMPUTE MINIMUM ALLOWABLE STACK LENGTH
!
      io = 1
      if (nprt.eq.0) io = 0
!
     call ldscmp(5, 0, io*(nf+5), 0, 0, 0, 'S',&
     &   2*lagmax+2+io*(2*nf+10), ldsmin)
!
      ly = n
      lpcv = nf + 5
      lwork = lagmax+1
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!     SET THE STACK ALLOCATION TYPE.
!
      call stkset(ldstak, 4)
      nall0 = stkst(1)
!
      ifp = 3
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
!
      if ((ldsmin.gt.ldstak) .or. (ldsmin.le.6)) then
         acov = 1
         work = 1
         xaxis = 1
         yaxis = 1
         isym = 1
         isort = 1
      else
         acov = stkget(lacov,ifp)
         work = stkget(lwork,ifp)
         if (nprt.ne.0) then
            xaxis = stkget(lpcv,ifp)
            yaxis = stkget(lpcv,ifp)
            isym = stkget(lpcv,2)
            isort = isym
         else
            xaxis = work
            yaxis = work
            isym = work
            isort = isym
         end if
      end if
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!
     call ufsdrv(y, ly, ymiss, rstak(acov), nlppa, spcf, ispcf,&
    &   nf, fmin, fmax, freq, n, nw, lagmax, lags, rstak(work), lacov,&
    &   lwork, delta, istak(isort), istak(isym), rstak(xaxis),&
    &   rstak(yaxis), lpcv, alpha, nprt, parzen, nmsub, ldsmin, ldstak,&
     &   option, lnlppa, ly)
!
      call stkclr(nall0)
!
!     CHECK FOR ERRORS
!
      if (ierr.eq.0) return
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL UFSS (Y, N,'/&
    &   '      +           NW, LAGS, NF, FMIN, FMAX, NPRT,'/&
     &   '      +           SPCF, ISPCF, FREQ, LDSTAK)')
      end
!CCFSDM
     subroutine ccfsdm (ccov11, ccov22, sdrhoc, lagmax, ncc, laglst, n,&
     &   nlpp12, nlpp21, iccov, inlppc)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING THE STANDARD ERROR
!     OF THE CROSS CORRELATIONS WHEN THERE ARE MISSING VALUES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iccov,inlppc,laglst,lagmax,n,ncc
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ccov11(iccov),ccov22(iccov),sdrhoc(ncc)
     integer&
     &   nlpp12(inlppc),nlpp21(inlppc)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   div,fplm,sum
     integer&
     &   i,ilast,k,k0,km,kp
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
!       EXTERNAL R1MACH
!
!  INTRINSIC FUNCTIONS
      intrinsic min,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCOV11(ICCOV), CCOV22(ICCOV)
!        THE ARRAYS IN WHICH THE AUTOCOVARIANCES ARE STORED.
!     REAL DIV
!        THE SQUARE ROOT OF THE PRODUCT OF THE AUTOCOVARIANCE
!        FUNCTION VALUES AT LAG ZERO.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        INDEXING VARIABLES.
!     INTEGER ICCOV
!        THE DIMENSION OF THE COVARIANCE VECTORS.
!     INTEGER ILAST
!        THE LAST LAG AT WHICH THE STANDARD ERRORS ARE TO BE COMPUTED.
!     INTEGER INLPPC
!        THE DIMENSION OF THE LAGGED PRODUCT PAIR COUNT VECTORS.
!     INTEGER K
!        INDEXING VARIABLES.
!     INTEGER KM, KP, K0
!        THE LOCATIONS IN THE ARRAYS -RHOC- AND -SDRHOC-
!        OF THE LAG -K, K AND 0, RESPECTIVELY.
!     INTEGER LAGLST
!        THE LAST AUTOCORRELATION COMPUTED BEFORE A MISSING
!        AUTOCORRELATION WAS INCOUNTERED IN EITHER SERIES.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE USED.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NCC
!       THE NUMBER OF CROSS CORRELATIONS COMPUTED.
!     INTEGER NLPP12(INLPPC), NLPP21(INLPPC)
!        THE ARRAYS IN WHICH THE NUMBER OF OBSERVATIONS USED TO
!        COMPUTE EACH CROSS CORRELATION ARE STORED.
!     REAL SDRHOC(NCC)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE CROSS CORRELATION
!        ARE STORED
!     REAL SUM
!         A SUMMING VARIABLE.
!
      fplm = r1mach(2)
!
      div = ccov11(1) * ccov22(1)
!
      k0 = lagmax + 1
!
      sum = 0.0e0
      do 10 i = 1, laglst
         sum = sum + ccov11(i+1) * ccov22(i+1)
   10 continue
      sum = sum / div
      sdrhoc(k0) = fplm
     if (nlpp12(1) .ge. 1) sdrhoc(k0) =&
     &   sqrt(n + 2.0e0 * sum) / nlpp12(1)
!
      do 30 k = 1, lagmax
         sum = 0.0e0
         ilast = min(laglst, n-laglst)
         do 20 i = 1, ilast
            sum = sum + (n-k-i) * ccov11(i+1) * ccov22(i+1)
   20    continue
         sum = sum / div
         km = k0 - k
         sdrhoc(km) = fplm
        if (nlpp21(k+1) .ge. 1) sdrhoc(km) =&
     &      sqrt((n - k) + 2.0e0 * sum) * (n - k)/ (n * nlpp21(k+1))
!
         kp = k0 + k
         sdrhoc(kp) = fplm
        if (nlpp12(k+1) .ge. 1) sdrhoc(kp) =&
     &      sqrt((n - k) + 2.0e0 * sum) * (n - k) / (n * nlpp12(k+1))
   30 continue
!
      return
      end
!XPGM
      subroutine xpgm(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST THE TIME SERIES PERIODOGRAM AND TIME SERIES
!     UTILITY SUBROUTINES
!
!     SERIES Y IS THE FIRST 50 VALUES OF THE SERIES LISTED ON PAGE
!     318 OF JENKINS AND WATTS.  THE SPECTRUM OF THIS SERIES IS SHOWN
!     FOR VARIOUS BANDWIDTH ON PAGE 270 OF JENKINS AND WATTS.
!
!     SERIES Z IS THE WOLF SUNSPOT NUMBERS FROM 1700 TO 1960 AS
!     TABULATED BY WALDMEIER.  THE RAW AND SMOOTHED PERIODOGRAMS OF
!     TAPERED SERIES ARE SHOWN ON PAGES 95 AND 176, RESPECTIVELY, OF
!     BLOOMFIELD.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   taperp
     integer&
    &   i,iextnd,iprt,itest,lab,lfreq,lper,lperi,lzfft,nf,nfft,nk,&
     &   nprt,ntemp,ny,nz
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   ab(600),freq(300),per(300),perf(300),peri(300),y(150),&
     &   yfft(400),z(275),zfft(600),zt(275)
     integer&
     &   k(10)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL CENTER,FFTLEN,FFTR,IPGM,IPGMP,IPGMPS,IPGMS,IPRINT,MDFLT,
!     +   PGM,PGMS,PPL,TAPER
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AB(600)
!        THE VECTOR OF THE NF REAL AND IMAGINARY COMPONENTS OF THE
!        FOURIER COEFFICIENTS.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FREQ(300)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IEXTND
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO
!        (IEXTND .EQ. 0) OR THE SERIES MEAN (IEXTND .NE. 0) IS TO BE
!        USED TO EXTEND THE SERIES.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ITEST
!        THE NUMBER OF THE TEST SET BEING PERFORMED
!     INTEGER K(10)
!        THE VECTOR OF THE MODIFIED DANIEL FILTER LENGTHS.
!     INTEGER LAB
!        THE LENGTH OF THE VECTOR AB.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LFREQ
!        THE LENGTH OF THE VECTOR FREQ.
!     INTEGER LPER
!        THE LENGTH OF THE VECTOR PER.
!     INTEGER LPERI
!        THE LENGTH OF THE VECTOR PERI.
!     INTEGER LZFFT
!        THE LENGTH OF THE VECTORS YFFT AND ZFFT, RESPECTIVELY..
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NFFT
!        THE EXTENDED SERIES LENGTH.
!     INTEGER NK
!        THE NUMBER OF MODIFIED DANIEL FILTERS TO BE APPLIED.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        FOR THE PERIODOGRAM ROUTINES
!        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .EQ.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
!        IF NPRT .GE.  2, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!        AND FOR THE INTEGRATED PERIODOGRAM ROUTINES
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .NE.  0, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         INTEGRATED PERIODOGRAM
!     INTEGER NTEMP
!        A TEMPORARY STORAGE LOCATION
!     INTEGER NY
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     INTEGER NZ
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Z.
!     REAL PER(300)
!        THE SERIES PERIODOGRAM.
!     REAL PERF(300)
!        THE FILTERED (SMOOTHED) PERIODOGRAM.
!     REAL PERI(300)
!        THE SERIES INTEGRATED PERIODOGRAM.
!     REAL TAPERP
!        THE PERCENT OF THE SERIES TO BE TAPERED.
!     REAL Y(150)
!         THE ARRAY CONTAINING THE TIME SERIES FROM JENKINS AND WATTS.
!     REAL YFFT(400)
!        THE VECTOR OF THE OBSERVED TIME SERIES TO BE ANALYZED USING
!        THE FFT.
!     REAL Z(275)
!        THE ARRAY OF THE WOLF SUNSPOT NUMBERS.
!     REAL ZFFT(600)
!        THE VECTOR OF THE TAPERED WOLF SUNSPOT NUMBERS TO BE
!        ANALYZED USING THE FFT.
!     REAL ZT(275)
!        THE ARRAY OF THE TAPERED SUNSPOT NUMBERS.
!
     data   y(  1),  y(  2),  y(  3),  y(  4),  y(  5),  y(  6)&
     &    / -.88_wp,  -.12_wp,  -.89_wp, -1.38_wp,  -.07_wp,  1.03_wp/
     data   y(  7),  y(  8),  y(  9),  y( 10),  y( 11),  y( 12)&
     &    / 2.14_wp,   .35_wp, -1.10_wp, -1.78_wp, -2.76_wp, -1.77_wp/
     data   y( 13),  y( 14),  y( 15),  y( 16),  y( 17),  y( 18)&
     &    /  .98_wp,  1.00_wp,  -.70_wp, -1.01_wp, -1.30_wp,  -.85_wp/
     data   y( 19),  y( 20),  y( 21),  y( 22),  y( 23),  y( 24)&
     &    / -.46_wp,  1.63_wp,   .06_wp,  -.17_wp, -1.01_wp, -1.04_wp/
     data   y( 25),  y( 26),  y( 27),  y( 28),  y( 29),  y( 30)&
     &    / -.66_wp, -1.12_wp,  -.51_wp,  -.71_wp,  -.20_wp,  -.13_wp/
     data   y( 31),  y( 32),  y( 33),  y( 34),  y( 35),  y( 36)&
     &    /  .14_wp,  1.59_wp,  -.76_wp, -1.08_wp, -1.77_wp, -1.20_wp/
     data   y( 37),  y( 38),  y( 39),  y( 40),  y( 41),  y( 42)&
     &    /  .45_wp,  -.07_wp,  -.63_wp,  -.35_wp,  -.87_wp,  -.62_wp/
     data   y( 43),  y( 44),  y( 45),  y( 46),  y( 47),  y( 48)&
     &    /  .28_wp,  1.90_wp,  2.14_wp,  1.05_wp,   .31_wp,  1.07_wp/
     data   y( 49),  y( 50)&
     &    / 2.67_wp,  2.44_wp/
!
     data   z(  1),  z(  2),  z(  3),  z(  4),  z(  5),  z(  6)&
     &    /  5.0_wp,  11.0_wp,  16.0_wp,  23.0_wp,  36.0_wp,  58.0_wp/
     data   z(  7),  z(  8),  z(  9),  z( 10),  z( 11),  z( 12)&
     &    / 29.0_wp,  20.0_wp,  10.0_wp,   8.0_wp,   3.0_wp,   0.0_wp/
     data   z( 13),  z( 14),  z( 15),  z( 16),  z( 17),  z( 18)&
     &    /  0.0_wp,   2.0_wp,  11.0_wp,  27.0_wp,  47.0_wp,  63.0_wp/
     data   z( 19),  z( 20),  z( 21),  z( 22),  z( 23),  z( 24)&
     &    / 60.0_wp,  39.0_wp,  28.0_wp,  26.0_wp,  22.0_wp,  11.0_wp/
     data   z( 25),  z( 26),  z( 27),  z( 28),  z( 29),  z( 30)&
     &    / 21.0_wp,  40.0_wp,  78.0_wp, 122.0_wp, 103.0_wp,  73.0_wp/
     data   z( 31),  z( 32),  z( 33),  z( 34),  z( 35),  z( 36)&
     &    / 47.0_wp,  35.0_wp,  11.0_wp,   5.0_wp,  16.0_wp,  34.0_wp/
     data   z( 37),  z( 38),  z( 39),  z( 40),  z( 41),  z( 42)&
     &    / 70.0_wp,  81.0_wp, 111.0_wp, 101.0_wp,  73.0_wp,  40.0_wp/
     data   z( 43),  z( 44),  z( 45),  z( 46),  z( 47),  z( 48)&
     &    / 20.0_wp,  16.0_wp,   5.0_wp,  11.0_wp,  22.0_wp,  40.0_wp/
     data   z( 49),  z( 50),  z( 51),  z( 52),  z( 53),  z( 54)&
     &    / 60.0_wp,  80.9_wp,  83.4_wp,  47.7_wp,  47.8_wp,  30.7_wp/
     data   z( 55),  z( 56),  z( 57),  z( 58),  z( 59),  z( 60)&
     &    / 12.2_wp,   9.6_wp,  10.2_wp,  32.4_wp,  47.6_wp,  54.0_wp/
     data   z( 61),  z( 62),  z( 63),  z( 64),  z( 65),  z( 66)&
     &    / 62.9_wp,  85.9_wp,  61.2_wp,  45.1_wp,  36.4_wp,  20.9_wp/
     data   z( 67),  z( 68),  z( 69),  z( 70),  z( 71),  z( 72)&
     &    / 11.4_wp,  37.8_wp,  69.8_wp, 106.1_wp, 100.8_wp,  81.6_wp/
     data   z( 73),  z( 74),  z( 75),  z( 76),  z( 77),  z( 78)&
     &    / 66.5_wp,  34.8_wp,  30.6_wp,   7.0_wp,  19.8_wp,  92.5_wp/
     data   z( 79),  z( 80),  z( 81),  z( 82),  z( 83),  z( 84)&
     &    /154.4_wp, 125.9_wp,  84.8_wp,  68.1_wp,  38.5_wp,  22.8_wp/
     data   z( 85),  z( 86),  z( 87),  z( 88),  z( 89),  z( 90)&
     &    / 10.2_wp,  24.1_wp,  82.9_wp, 132.0_wp, 130.9_wp, 118.1_wp/
     data   z( 91),  z( 92),  z( 93),  z( 94),  z( 95),  z( 96)&
     &    / 89.9_wp,  66.6_wp,  60.0_wp,  46.9_wp,  41.0_wp,  21.3_wp/
     data   z( 97),  z( 98),  z( 99),  z(100),  z(101),  z(102)&
     &    / 16.0_wp,   6.4_wp,   4.1_wp,   6.8_wp,  14.5_wp,  34.0_wp/
     data   z(103),  z(104),  z(105),  z(106),  z(107),  z(108)&
     &    / 45.0_wp,  43.1_wp,  47.5_wp,  42.2_wp,  28.1_wp,  10.1_wp/
     data   z(109),  z(110),  z(111),  z(112),  z(113),  z(114)&
     &    /  8.1_wp,   2.5_wp,   0.0_wp,   1.4_wp,   5.0_wp,  12.2_wp/
     data   z(115),  z(116),  z(117),  z(118),  z(119),  z(120)&
     &    / 13.9_wp,  35.4_wp,  45.8_wp,  41.1_wp,  30.1_wp,  23.9_wp/
     data   z(121),  z(122),  z(123),  z(124),  z(125),  z(126)&
     &    / 15.6_wp,   6.6_wp,   4.0_wp,   1.8_wp,   8.5_wp,  16.6_wp/
     data   z(127),  z(128),  z(129),  z(130),  z(131),  z(132)&
     &    / 36.3_wp,  49.6_wp,  64.2_wp,  67.0_wp,  70.9_wp,  47.8_wp/
     data   z(133),  z(134),  z(135),  z(136),  z(137),  z(138)&
     &    / 27.5_wp,   8.5_wp,  13.2_wp,  56.9_wp, 121.5_wp, 138.3_wp/
     data   z(139),  z(140),  z(141),  z(142),  z(143),  z(144)&
     &    /103.2_wp,  85.7_wp,  64.6_wp,  36.7_wp,  24.2_wp,  10.7_wp/
     data   z(145),  z(146),  z(147),  z(148),  z(149),  z(150)&
     &    / 15.0_wp,  40.1_wp,  61.5_wp,  98.5_wp, 124.7_wp,  96.3_wp/
     data   z(151),  z(152),  z(153),  z(154),  z(155),  z(156)&
     &    / 66.6_wp,  64.5_wp,  54.1_wp,  39.0_wp,  20.6_wp,   6.7_wp/
     data   z(157),  z(158),  z(159),  z(160),  z(161),  z(162)&
     &    /  4.3_wp,  22.7_wp,  54.8_wp,  93.8_wp,  95.8_wp,  77.2_wp/
     data   z(163),  z(164),  z(165),  z(166),  z(167),  z(168)&
     &    / 59.1_wp,  44.0_wp,  47.0_wp,  30.5_wp,  16.3_wp,   7.3_wp/
     data   z(169),  z(170),  z(171),  z(172),  z(173),  z(174)&
     &    / 37.6_wp,  74.0_wp, 139.0_wp, 111.2_wp, 101.6_wp,  66.2_wp/
     data   z(175),  z(176),  z(177),  z(178),  z(179),  z(180)&
     &    / 44.7_wp,  17.0_wp,  11.3_wp,  12.4_wp,   3.4_wp,   6.0_wp/
     data   z(181),  z(182),  z(183),  z(184),  z(185),  z(186)&
     &    / 32.3_wp,  54.3_wp,  59.7_wp,  63.7_wp,  63.5_wp,  52.2_wp/
     data   z(187),  z(188),  z(189),  z(190),  z(191),  z(192)&
     &    / 25.4_wp,  13.1_wp,   6.8_wp,   6.3_wp,   7.1_wp,  35.6_wp/
     data   z(193),  z(194),  z(195),  z(196),  z(197),  z(198)&
     &    / 73.0_wp,  85.1_wp,  78.0_wp,  64.0_wp,  41.8_wp,  26.2_wp/
     data   z(199),  z(200),  z(201),  z(202),  z(203),  z(204)&
     &    / 26.7_wp,  12.1_wp,   9.5_wp,   2.7_wp,   5.0_wp,  24.4_wp/
     data   z(205),  z(206),  z(207),  z(208),  z(209),  z(210)&
     &    / 42.0_wp,  63.5_wp,  53.8_wp,  62.0_wp,  48.5_wp,  43.9_wp/
     data   z(211),  z(212),  z(213),  z(214),  z(215),  z(216)&
     &    / 18.6_wp,   5.7_wp,   3.6_wp,   1.4_wp,   9.6_wp,  47.4_wp/
     data   z(217),  z(218),  z(219),  z(220),  z(221),  z(222)&
     &    / 57.1_wp, 103.9_wp,  80.6_wp,  63.6_wp,  37.6_wp,  26.1_wp/
     data   z(223),  z(224),  z(225),  z(226),  z(227),  z(228)&
     &    / 14.2_wp,   5.8_wp,  16.7_wp,  44.3_wp,  63.9_wp,  69.0_wp/
     data   z(229),  z(230),  z(231),  z(232),  z(233),  z(234)&
     &    / 77.8_wp,  64.9_wp,  35.7_wp,  21.2_wp,  11.1_wp,   5.7_wp/
     data   z(235),  z(236),  z(237),  z(238),  z(239),  z(240)&
     &    /  8.7_wp,  36.1_wp,  79.7_wp, 114.4_wp, 109.6_wp,  88.8_wp/
     data   z(241),  z(242),  z(243),  z(244),  z(245),  z(246)&
     &    / 67.8_wp,  47.5_wp,  30.6_wp,  16.3_wp,   9.6_wp,  33.2_wp/
     data   z(247),  z(248),  z(249),  z(250),  z(251),  z(252)&
     &    / 92.6_wp, 151.6_wp, 136.3_wp, 134.7_wp,  83.9_wp,  69.4_wp/
     data   z(253),  z(254),  z(255),  z(256),  z(257),  z(258)&
     &    / 31.5_wp,  13.9_wp,   4.4_wp,  38.0_wp, 141.7_wp, 190.2_wp/
     data   z(259),  z(260),  z(261)&
     &    /184.8_wp, 159.0_wp, 112.3_wp/
!
      itest = 1
!
!     MAKE CALLS WITH VALID DATA
!
      ny = 50
      nz = 261
      nfft = 514
      nprt = 2
      lzfft = 600
      lper = 514
      lperi = 514
      taperp = 0.10_wp
      lfreq = 300
      iextnd = 0
      lab = 600
      nk = 3
      k(1) = 8
      k(2) = 8
      k(3) = 8
!
      call iprint(iprt)
!
!     TEST OF CENTER
!
    5 write (iprt, 1018)
      call center (z, nz, zt)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VARIABLES FROM CENTER
!
      if (ierr.eq.0) write (iprt, 1004) (zt(i), i = 1, nz)
!
!     TEST OF TAPER
!
      write (iprt, 1015)
      call taper (z, nz, taperp, zt)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VARIABLES FROM TAPER
!
      if (ierr.eq.0) write (iprt, 1004) (zt(i), i = 1, nz)
!
!     TEST OF PGM
!
      write (iprt, 1013)
      call scopy (nz, zt, 1, zfft, 1)
      call pgm (zfft, nz, lzfft, ldstak)
      write (iprt, 1002) ierr
!
!     TEST OF FFTLEN
!
      write (iprt, 1026)
      call fftlen(nfft-2, 2, ntemp)
      write(iprt, 1002) ierr
!
!     PRINT RETURNED VARIABLES FROM FFTLEN
!
      if (ierr.eq.0) write (iprt, 1027) ntemp
!
!     TEST OF PGMS
!
      ntemp = nfft-1
      write (iprt, 1025)
      call scopy (nz, zt, 1, zfft, 1)
     call pgms (zfft, nz, ntemp, lzfft, iextnd, nf, per, lper, freq,&
     &   lfreq, -2)
      write (iprt, 1027) ntemp
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VARIABLES FROM PGMS
!
      if (ierr.eq.0) then
        write (iprt, 1004) (freq(i), i = 1, nf)
        write (iprt, 1004) (per(i), i = 1, nf)
      end if
!
!     TEST OF MDFLT
!
      write (iprt, 1016)
      call mdflt (per, nf, nk, k, perf, ldstak)
      write (iprt, 1002) ierr
      if (ierr.eq.0) then
!
!       PRINT RETURNED VARIABLES FROM MDFLT
!
        write (iprt, 1004) (perf(i), i = 1, nf)
!
!       DISPLAY SMOOTHED PERIODOGRAM ON A LOG PLOT
!
        write (iprt, 1028)
        call ppl (perf, freq, nf, 1)
      end if
!
!     TEST OF IPGMP
!
      write (iprt, 1029)
      call ipgmp (per, freq, nf, nz, ldstak)
      write (iprt, 1002) ierr
!
!     TEST OF IPGMPS
!
      write (iprt, 1030)
      call ipgmps (per, freq, nf, nz, ldstak, peri, nprt)
      write (iprt, 1002) ierr
      if (ierr.eq.0) then
!
!     PRINT RETURNED VARIABLES FROM IPGMPS
!
         write (iprt, 1004) (freq(i), i = 1, nf)
         write (iprt, 1004) (peri(i), i = 1, nf)
      end if
!
!     TEST OF IPGM
!
      write (iprt, 1017)
      call scopy (nz, zt, 1, zfft, 1)
      call ipgm (zfft, nz, lzfft, ldstak)
      write (iprt, 1002) ierr
!
!     TEST OF IPGMS
!
      write (iprt, 1014)
      call scopy (nz, zt, 1, zfft, 1)
     call ipgms (zfft, nz, lzfft, ldstak, nf, peri, lperi, freq, lfreq,&
     &   nprt)
      write (iprt, 1002) ierr
      if (ierr.eq.0) then
!
!     PRINT RETURNED VARIABLES FROM IPGMS
!
         write (iprt, 1004) (freq(i), i = 1, nf)
         write (iprt, 1004) (peri(i), i = 1, nf)
      end if
!
!     TEST OF FFTR (CENTERED DATA - O PERCENT TAPER)
!
      taperp = -1.0_wp
      write (iprt, 1031)
      if (ny.ge.1) call taper (y, ny, taperp, yfft)
      call fftr (yfft, ny, nfft, iextnd, nf, ab, lab)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VARIABLES FROM FFTR
!
      if (ierr.eq.0) write (iprt, 1004) (ab(i), i = 1, nf)
!
      go to (10, 20, 30, 40) itest
!
!     CHECK MINIMUM PROBLEM SIZE
!
   10 itest = itest + 1
      nz = 17
      ny = 17
      go to 5
!
!     CHECK VARIOUS OPTIONS
!
   20 itest = itest + 1
!
!     TEST OF MDFLT (ELEMENTS OF K NOT EVEN)
!
      k(1) = 7
      write (iprt, 1016)
      call mdflt (per, nf, nk, k, perf, ldstak)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VARIABLES FROM MDFLT
!
      write (iprt, 1004) (perf(i), i = 1, nf)
!
!     TEST OF PGMS (UNCENTERED DATA)
!
      iextnd = 1
      nprt = 1
      write (iprt, 1025)
      call scopy (nz, z, 1, zfft, 1)
     call pgms (zfft, nz, nfft, lzfft, iextnd, nf, per, lper, freq,&
     &   lfreq, nprt)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VARIABLES FROM PGMS
!
      write (iprt, 1004) (freq(i), i = 1, nf)
      write (iprt, 1004) (per(i), i = 1, nf)
!
      nprt = 2
      write (iprt, 1025)
      call scopy (nz, z, 1, zfft, 1)
     call pgms (zfft, nz, nfft, lzfft, iextnd, nf, per, lper, freq,&
     &   lfreq, nprt)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VARIABLES FROM PGMS
!
      write (iprt, 1004) (freq(i), i = 1, nf)
      write (iprt, 1004) (per(i), i = 1, nf)
!
!     TEST OF FFTR (CENTERED DATA - 100 PERCENT TAPER)
!
      taperp = 1.1_wp
      write (iprt, 1031)
      call taper (y, ny, taperp, yfft)
      call fftr (yfft, ny, nfft, iextnd, nf, ab, lab)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VARIABLES FROM FFTR
!
      write (iprt, 1004) (ab(i), i = 1, nf)
!
!     TEST OF FFTR (CENTERED DATA - O PERCENT TAPER)
!
      taperp = -1.0_wp
      write (iprt, 1031)
      call taper (y, ny, taperp, yfft)
      call fftr (yfft, ny, nfft-1, iextnd, nf, ab, nfft-2)
      write (iprt, 1002) ierr
!
!     PRINT RETURNED VARIABLES FROM FFTR
!
      write (iprt, 1004) (ab(i), i = 1, nf)
!
!     PERFORM ERROR CHECKING
!
      ny = -1
      nz = -1
      nfft = 0
      nprt = 2
      lzfft = 0
      lper = 0
      lperi = 0
      taperp = 0.10_wp
      lfreq = 0
      iextnd = 0
      lab = 0
      nk = 0
      k(1) = 0
      k(2) = 0
      k(3) = 0
      go to 5
!
!     PERFORM MORE ERROR CHECKING
!
   30 itest = itest + 1
      ny = 50
      nz = 261
      nprt = 2
      lzfft = 0
      lper = 0
      lperi = 0
      taperp = 0.10_wp
      lfreq = 0
      iextnd = 0
      lab = 0
      nk = 3
      k(1) = 0
      k(2) = 0
      k(3) = 0
      go to 5
!
   40 return
!
!     FORMAT STATEMENTS
!
 1002 format (8h ierr is, i5)
 1004 format (3(1x, e16.8))
 1013 format ('1', 11htest of pgm)
 1014 format ('1', 13htest of ipgms)
 1015 format ('1', 13htest of taper)
 1016 format ('1', 13htest of mdflt)
 1017 format ('1', 12htest of ipgm)
 1018 format ('1', 14htest of center)
 1025 format ('1', 12htest of pgms)
 1026 format ('1', 14htest of fftlen)
 1027 format (/8h nfft is, i6)
1028 format ('1', 45hdisplay of periodogram smoothed with modified,&
     &   14h daniel filter)
 1029 format ('1', 13htest of ipgmp)
 1030 format ('1', 14htest of ipgmps)
 1031 format ('1', 12htest of fftr)
      end
!DIFMC
     subroutine difmc (y, ymiss, n, nfac, nd, iod, iar, phi, lphi, yf,&
     &   yfmiss, nyf, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE EXPANDS THE DIFFERENCE FILTER SPECIFIED BY NFAC,
!     IOD AND ND INTO PHI AND PERFORMS THE DIFFERENCE FILTERING
!     OPERATION DEFINED BY PHI ON A SERIES CONTAINING MISSING DATA,
!     RETURNING THE FILTERED SERIES IN YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: yfmiss,ymiss
     integer&
     &   iar,ldstak,lphi,n,nfac,nyf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   phi(*),y(*),yf(*)
     integer&
     &   iod(*),nd(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   i,iprt,ldsmin,nall0,work
     logical&
     &   err01,err02,err03,err04,head
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     character&
     &   llds(8)*1,llphi(8)*1,ln(8)*1,nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DCOEF,EISGE,ERDF,FLTARM,IPRINT,LDSCMP,STKCLR,STKSET
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03, ERR04
!        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IOD(NFAC)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LLDS(8), LLPHI(8), LN(8)
!        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES LDSTAK, N
!        AND LPHI, RESPECTIVELY.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
!     INTEGER ND(NFAC)
!        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE
!        FACTORS ARE TO BE APPLIED.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     REAL PHI(LPHI)
!        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER WORK
!        THE STARTING LOCATION FOR THE WORK VECTOR NECESSARY TO
!        EXPAND THE DIFFERENCE FILTER.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!     REAL YFMISS
!        THE MISSING VALUE CODE USED IN THE FILTERED SERIES TO
!        INDICATE THE VALUE COULD NOT BE COMPUTED DUE TO MISSING DATA.
!     REAL YMISS
!        THE MISSING VALUE CODE USED IN THE INPUT SERIES TO INDICATE
!        AN OBSERVATION IS MISSING.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'D',       'I',       'F',       'M',       'C',       ' '/
     data&
    &  llds(1), llds(2), llds(3), llds(4), llds(5), llds(6),&
    &  llds(7), llds(8)&
     & /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
     data&
    &  llphi(1), llphi(2), llphi(3), llphi(4), llphi(5), llphi(6),&
    &  llphi(7), llphi(8)&
     & /  'L',   'P',   'H',   'I',   ' ',   ' ',   ' ',   ' '/
     data&
    &  ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
      err01 = .false.
      err02 = .false.
      err03 = .false.
      err04 = .false.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub,ln,n,3,1,head,err01,ln)
!
      iar = 0
!
      if (nfac.ge.1) then
!
         do 10 i = 1, nfac
            iar = iar + nd(i)*iod(i)
   10    continue
!
         call erdf(nmsub,nfac,nd,iod,n,head,err02)
!
         if (.not.err02) then
            call eisge(nmsub,llphi,lphi,iar,9,head,err03,llphi)
            call ldscmp(1,0,0,0,0,0,'S',2*iar,ldsmin)
            call eisge(nmsub,llds,ldstak,ldsmin,9,head,err04,llds)
         end if
      end if
!
      if (err01 .or. err02 .or. err03 .or. err04) go to 20
      go to 30
!
   20 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   30 continue
!
      nyf = n
      do 50 i = 1, nyf
         yf(i) = y(i)
   50 continue
!
      yfmiss = ymiss
!
      if (nfac .le. 0) return
!
      call stkset (ldstak, 4)
      nall0 = stkst(1)
!
      do 60 i = 1, lphi
         phi(i) = 0.0e0
   60 continue
!
      work = stkget(2*iar,3)
!
      if (ierr .eq. 1) go to 20
!
      call dcoef (nfac,nd,iod,iar,phi,lphi,rstak(work))
!
      call stkclr(nall0)
!
      if (ierr .eq. 1) go to 20
!
      call fltarm (yf,ymiss,nyf,iar,phi,yf,yfmiss,nyf)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL DIFMC (Y, YMISS, N,'/&
    &   '      +            NFAC, ND, IOD, IAR, PHI, LPHI,'/&
     &   '      +            YF, YFMISS, NYF, LDSTAK)')
      end
!GMEAN
      subroutine gmean(y, n, ymean)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE GEOMETRIC MEAN OF A SERIES, ASSUMING
!     ALL VALUES IN Y ARE NON-ZERO.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ymean
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(n)
!
!  LOCAL SCALARS
     integer&
     &   i
!
!  INTRINSIC FUNCTIONS
      intrinsic exp,log
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     REAL YMEAN
!        THE GEOMETRIC MEAN OF THE OBSERVED SERIES
!
      ymean = 0.0e0
      do 10 i = 1, n
         ymean = ymean + log(y(i))
   10 continue
      ymean = exp(ymean/n)
      return
      end
!MATPRT
      subroutine matprt (x, y, nc, iprt, mode, code, irdim)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE TAKES A SQUARE MATRIX AND PRINTS EITHER ITS
!     LOWER TRIANGULAR PART OR THE FULL MATRIX WITH OR WITHOUT DOUBLE
!     PRINTING.
!
!     WRITTEN BY - LINDA L. MITCHELL
!                  STATISTICAL ENGINEERING LAB/BOULDER
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   code,iprt,irdim,mode,nc
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(irdim,nc),y(irdim,nc)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   temp
     integer&
     &   i,iwidth,j,k,km,kn,l,nf
!
!  INTRINSIC FUNCTIONS
      intrinsic min,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CODE
!                  IF 1 -SINGLE PRINTED LINE, X ONLY (Y IS DUMMY ARG)
!                     2 -DOUBLE PRINTED LINE, BOTH X AND Y
!     INTEGER I
!                  ROW NUMBER
!     INTEGER IPRT
!                  THE OUTPUT UNIT NUMBER
!     INTEGER IRDIM
!                  ROW INDEX OF X
!     INTEGER IWIDTH
!                  THE WIDTH OF THE OUTPUT DEVICE.
!     INTEGER J
!                  FIRST COLUMN IN THE SET TO BE PRINTED
!     INTEGER K
!                  COLUMN NUMBER IN THE POSSIBLE SET OF NF
!     INTEGER KM
!                  LAST COLUMN IN THE SET
!                   LIMITED TO VALUES OF J-1 PLUS A NUMBER BETWEEN 1 AND
!                   NF (INCLUSIVE)
!     INTEGER KN
!                  LAST COLUMN TO PRINT WHEN PRINTING LOWER TRIANGLE
!     INTEGER L
!                  FIRST ROW TO PRINT FOR THIS SET
!     INTEGER MODE
!                  IF 0, LOWER TRIANGULAR PART PRINTED
!                     1, FULL MATRIX PRINTED
!                     2, LOWER TRIANGULAR PART IS PRINTED WITH
!                        SQUARE ROOTS OF THE DIAGONAL
!     INTEGER NC
!                  ROW AND COLUMN DIMENSION OF X
!     INTEGER NF
!                  THE NUMBER OF COLUMNS THAT CAN BE PRINTED, GIVEN
!                  THE WIDTH IWIDTH OF THE OUTPUT DEVICE.
!     REAL TEMP
!                  A TEMPORARY LOCATION
!     REAL X(IRDIM,NC)
!                  NC BY NC INPUT MATRIX
!     REAL Y(IRDIM,NC)
!                  MATRIX TO BE PRINTED ON THE SECOND LEVEL IF CODE=2
!
      iwidth = 132
      nf = min(7, (iwidth - 7)/17)
      l = 1
      do 20 j=1,nc, nf
         kn = min(nc, j+nf-1)
         write(iprt,1000) (k,k=j,kn)
         write(iprt,1030)
         if ((mode.eq.00) .or. (mode.eq.2)) l = j
         do 10 i=l,nc
            temp = x(i,i)
            km = kn
           if ((mode.eq.0) .or. (mode.eq.2))&
     &         km = j + min(i-l, nf-1)
           if ((mode.eq.2) .and. ((i.ge.j) .and. (i.le.km)))&
     &         x(i,i) = sqrt(x(i,i))
            write(iprt,1010) i, (x(i,k),k=j,km)
            if (code.eq.2) write(iprt,1020) (y(i,k),k=j,km)
            if (code.eq.2) write(iprt,1030)
            x(i,i) = temp
   10    continue
   20 continue
      return
!
!     FORMAT STATEMENTS
!
 1000 format (/4x, 7hcolumn , 7(i9, 8x))
 1010 format (4x, i6, 1x, 7(3x, g14.8))
 1020 format (9x, 7(3x, g14.8))
 1030 format (4x)
      end
!ACCDIG
      subroutine accdig(ax, x, ad, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     RETURNS NUMBER OF ACCURATE DIGITS, AD, IN AX AN APPROXIMATION TO X
!
!     WRITTEN BY DAVID HOGBEN, SEL, NBS.   10/29/69.
!
!     THIS ROUTINE WAS ADAPTED FROM THE OMNITAB ROUTINE ACCDIG
!     BY - -
!
!     JANET R. DONALDSON
!     STATISTICAL ENGINEERING DIVISION
!     NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ad(*),ax(*),x(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   admax,diff,fplrs
     integer&
     &   i
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
!       EXTERNAL R1MACH
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,log10,max,min
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL(KIND=WP) :: AD(N)
!        THE NUMBER OF ACCURATE DIGITS.
!     REAL(KIND=WP) :: ADMAX
!        THE NUMBER OF DIGITS CARRIED IN A FLOATING POINT COMPUTATION.
!     REAL(KIND=WP) :: AX(N)
!        THE APPROXIMATION TO THE SOLUTION.
!     REAL(KIND=WP) :: DIFF
!        *
!     REAL(KIND=WP) :: FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     INTEGER I
!        AN INDEX.
!     INTEGER N
!        THE NUMBER OF ELEMENTS BEING COMPARED.
!     REAL(KIND=WP) :: X(N)
!        THE SOLUTION.
!
!
      fplrs = r1mach(4)
!
      admax = -log10(fplrs)
!
      do 20 i=1,n
         diff = ax(i) - x(i)
         if (diff.ne.0.0e0) go to 10
         ad(i) = admax
         go to 20
   10    ad(i) = 0.0e0
         if (abs(x(i)).gt.0.0e0) ad(i) = log10(abs(x(i)))
         if (abs(diff).gt.0.0e0) ad(i) = -log10(abs(diff)) + ad(i)
         ad(i) = min(admax,ad(i))
         ad(i) = max(-admax,ad(i))
   20 continue
      return
      end
!SVPM
      subroutine svpm(ym, ymiss, n, ns, isym)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA AND USER CONTROL OF THE PLOT SYMBOL USED
!     (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: ymiss
     integer&
     &   n,ns
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: ym(*)
     integer&
     &   isym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ibar,ilog,iprt,irlin,ischck,isize,iym,lisym,m
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
      real(kind=wp) :: ymmiss(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(N,*)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'S',       'V',       'P',       'M',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      ymmiss=ymiss
      m = 1
      iym = n
      multi = .false.
      ilog = -1
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 1.0e0
      xinc = 1.0e0
      ischck = 1
      isize = -1
      miss = .true.
      lisym = n
      irlin = -1
      ibar = 0
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ymmiss, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &  '       CALL SVPM (Y, YMISS, N, NS, ISYM)')
      end
!CCFSD
      subroutine ccfsd (ccov11, ccov22, sdrhoc, lagmax, ncc, n, iccov)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING THE STANDARD ERROR
!     OF THE CROSS CORRELATIONS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iccov,lagmax,n,ncc
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ccov11(iccov),ccov22(iccov),sdrhoc(ncc)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   div,sum
     integer&
     &   i,ilast,k,k0,km,kp
!
!  INTRINSIC FUNCTIONS
      intrinsic min,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCOV11(ICCOV), CCOV22(ICCOV)
!        THE ARRAYS IN WHICH THE AUTOCOVARIANCES ARE STORED
!     REAL DIV
!        THE SQUARE ROOT OF THE PRODUCT OF THE AUTOCOVARIANCE
!        FUNCTION VALUES AT LAG ZERO.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER ICCOV
!        THE DIMENSION OF THE ACVF ARRAYS.
!     INTEGER ILAST
!        THE LAST LAG AT WHICH THE STANDARD ERROR IS TO BE COMPUTED.
!     INTEGER K
!        AN INDEX VARIALBE.
!     INTEGER KM, KP, K0
!        THE LOCATIONS IN THE ARRAYS -RHOC- AND -SDRHOC-
!        OF THE LAG -K, K AND 0, RESPECTIVELY.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE USED.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NCC
!        THE NUMBER OF CCF COMPUTED.
!     REAL SDRHOC(NCC)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE CROSS CORRELATION
!        ARE STORED
!     REAL SUM
!         A SUMMING VARIABLE.
!
      k0 = lagmax + 1
!
      div = ccov11(1) * ccov22(1)
!
      sum = 0.0e0
      do 10 i = 1, lagmax
         sum = sum + ccov11(i+1) * ccov22(i+1)
   10 continue
      sum = sum / div
      sdrhoc(k0) = sqrt(n + 2.0e0 * sum) / n
!
      do 30 k = 1, lagmax
         sum = 0.0e0
         ilast = min(lagmax, n-lagmax)
         do 20 i = 1, ilast
            sum = sum + (n-k-i)*ccov11(i+1)*ccov22(i+1)
   20    continue
         sum = sum / div
         km = k0 - k
         sdrhoc(km) = sqrt((n - k) + 2.0e0 * sum) / n
!
         kp = k0 + k
         sdrhoc(kp) = sdrhoc(km)
!
   30 continue
!
      return
      end
!AIMEC
     subroutine aimec(y, n, mspec, nfac, par, npar, res, ldstak,&
     &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR ARIMA ESTIMATION
!     (CONTROL CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,stopp,stopss
     integer&
     &   ivaprx,ldstak,mit,n,nfac,npar,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),res(*),scale(*),stp(*),y(*)
     integer&
     &   ifixed(1),mspec(4,*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   iprt,ivcv,lifixd,lpv,lscale,lsdpv,lsdres,lstp,npare
     logical&
     &   save
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   pv(1),sdpv(1),sdres(1),vcv(1,1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AMEDRV,IPRINT
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!        IF IFIXED(1).LT.0, THEN IFIXED(I)=DEFAULT,I=1,...,NPAR, AND THE
!                           DIMENSION OF IFIXED WILL BE ASSUMED TO BE 1.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE FOR
!        IVAPRX LE 0, VCV = THE DEFAULT OPTION
!        IVAPRX EQ 1, VCV = INVERSE(TRANSPOSE(J)*J)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2, VCV = INVERSE(H)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4, VCV = INVERSE(TRANSPOSE(J)*J)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5, VCV = INVERSE(H)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7, VCV = THE DEFAULT OPTION
!        WITH J REPRESENTING THE JACOBIAN AND H THE HESSIAN.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE DIMENSION OF VECTOR IFIXED.
!     INTEGER LPV
!        THE DIMENSION OF VECTOR PV.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER LSDPV
!        THE DIMENSION OF VECTOR SDPV.
!     INTEGER LSDRES
!        THE DIMENSION OF VECTOR SDRES.
!     INTEGER LSTP
!        THE DIMENSION OF VECTOR STP.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER MSPEC(4,NFAC)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PV(1)
!        THE PREDICTED VALUE OF THE FIT, UNUSED WHEN SAVE = FALSE.
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(NPAR)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!        IF SCALE(1).LE.0, THEN SCALE(I)=DEFAULT,I=1,...,NPAR, AND THE
!                          DIMENSION OF SCALE WILL BE ASSUMED TO BE 1.
!     REAL SDPV(1)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES, UNUSED
!        WHEN SAVE = FALSE.
!     REAL SDRES(1)
!        THE STANDARDIZED RESIDUALS, UNUSED WHEN SAVE = FALSE.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(1)
!        THE STEP SIZE ARRAY.
!        IF STP(1).LE.0, THEN STP(I)=DEFAULT,I=1,...,NPAR, AND THE
!                        DIMENSION OF STP WILL BE ASSUMED TO BE 1.
!     REAL VCV(1,1)
!        THE VARIANCE-COVARIANCE MATRIX, UNUSED WHEN SAVE = FALSE.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'A','I','M','E','C',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      save = .false.
!
      lifixd = npar
      if (ifixed(1).le.-1) lifixd = 1
      lpv = 1
      lscale = npar
      if (scale(1).le.0.0e0) lscale = 1
      lstp = npar
      if (stp(1).le.0.0e0) lstp = 1
      lsdpv = 1
      lsdres = 1
      ivcv = 1
!
     call amedrv(y, n, mspec, nfac, par, npar, res,&
    &   ldstak, ifixed, lifixd, stp, lstp, mit, stopss, stopp, scale,&
    &   lscale, delta, ivaprx, nprt, rsd, pv, lpv, sdpv, lsdpv, sdres,&
     &   lsdres, vcv, ivcv, nmsub, save, npare)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/' THE CORRECT FORM OF THE CALL STATEMENT IS'//&
    &  '       CALL AIMEC (Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK,'/&
    &  '      +            IFIXED, STP, MIT, STOPSS, STOPP, SCALE,'/&
     &  '      +            DELTA, IVAPRX, NPRT)')
      end
!LLSW
      subroutine llsw(y, wt, xm, n, ixm, npar, res, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CALL FOR GENERAL LINEAR MODEL LEAST SQUARES FIT
!     USER SUPPLIED WEIGHTS SPECIFIED
!     NO STORAGE OTHER THAN RESIDUALS
!     FOUR PAGES AUTOMATIC PRINTOUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,ldstak,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   res(*),wt(*),xm(*),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   iprt,ivcv,lpar,lpv,lsdpv,lsdres,lwt,nprt
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   par(1),pv(1),sdpv(1),sdres(1),vcv(1,1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LLCNTG
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     REAL PAR(1)
!        A DUMMY ARRAY FOR
!        THE PARAMETERS  TO BE ESTIMATED.
!     REAL PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUES.
!     REAL RES(N)
!        THE RESIDUALS.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     REAL SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARDIZED RESIDUALS.
!     REAL VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(N)
!        A DUMMY ARRAY FOR
!        THE WEIGHTS.
!     REAL XM(IXM,NPAR)
!        THE INDEPENDENT VARIABLE.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'L','L','S','W',' ',' '/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      weight = .true.
      save = .false.
      nprt = 1111
      lpar = 1
      lpv = 1
      lsdpv = 1
      lsdres = 1
      ivcv = 1
      lwt = n
!
     call llcntg(y, wt, lwt, xm, n, ixm, npar, res, ldstak, nprt,&
    &   par, lpar, rsd, pv, lpv, sdpv, lsdpv, sdres, lsdres, vcv, ivcv,&
     &   nmsub, weight, save)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (//42h the correct form of the call statement is//&
     &   '       CALL LLSW (Y, WT, XM, N, IXM, NPAR, RES, LSDTAK)')
      end
!STPLS2
      subroutine stpls2(npar, stp)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     SET UP PROBLEM SPECIFICATION FOR TESTING THE USER CALLABLE
!     ROUTINES IN THE (LEAST SQUARES) STEP SIZE SELECTION FAMILY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   stp(npar)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   i
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     REAL STP(NPAR)
!        THE STEP SIZE ARRAY.
!
      do 10 i=1,npar
         stp(i) = -1.0e0
   10 continue
!
      ierr = -1
!
      return
!
      end
!NLSS
     subroutine nlss(y, xm, n, m, ixm, mdl, par, npar, res, ldstak,&
    &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt,&
     &   npare, rsd, pv, sdpv, sdres, vcv, ivcv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
!     (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
     &   ivaprx,ivcv,ixm,ldstak,m,mit,n,npar,npare,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   par(*),pv(*),res(*),scale(*),sdpv(*),sdres(*),stp(*),vcv(*),&
     &   xm(*),y(*)
     integer&
     &   ifixed(*)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,lifixd,lpv,lscale,lsdpv,lsdres,lstp,lwt,nnzw
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   wt(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,NLCNTN
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(NPAR)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(NPAR)
!        THE STEP SIZE ARRAY.
!     REAL VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(1)
!        THE DUMMY ARRAY FOR THE WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'N','L','S','S',' ',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      weight = .false.
      save = .true.
!
      wt(1) = 1.0e0
      lifixd = npar
      lpv = n
      lscale = npar
      lstp = npar
      lsdpv = n
      lsdres = n
      lwt = 1
!
     call nlcntn(y, wt, lwt, xm, n, m, ixm, mdl, par, npar, res,&
    &   ldstak, ifixed, lifixd, stp, lstp, mit, stopss, stopp, scale,&
    &   lscale, delta, ivaprx, nprt, rsd, pv, lpv, sdpv, lsdpv, sdres,&
     &   lsdres, vcv, ivcv, nmsub, weight, save, nnzw, npare)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL NLSS (Y, XM, N, M, IXM, NLSMDL,'/&
    &   '      +           PAR, NPAR, RES, LDSTAK,'/&
    &   '      +           IFIXED, STP, MIT, STOPSS, STOPP,'/&
    &   '      +           SCALE, DELTA, IVAPRX, NPRT,'/&
     &   '      +           NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)')
      end
!CORRS
      subroutine corrs(ym, n, m, iym, ldstak, nprt, vcv, ivcv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR THE CORRELATION FAMILY.
!     IT IS THE LONG CALL FORM.
!     THIS ROUTINE CALLS CORRER TO CHECK FOR ERRORS IN THE PARAMETERS.
!     IF THERE ARE NO PROBLEMS IT THEN ALLOCATES SPACE IN CSTAK
!     FOR THE VECTORS NEEDED AND CALLS THE MAIN ROUTINE, CORRMN, TO DO
!     THE CORRELATION ANALYSIS.
!
!     WRITTEN BY -
!        LINDA L. MITCHELL
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ivcv,iym,ldstak,m,n,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   vcv(*),ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
    &   avg,cilo,ciup,icor,ifp,iprt,iwrk,liwrk,lwrk,nall0,pc,qf,&
     &   quad,rank,sc,scinv,sd,slpc,slsc,srcc,t,wrk
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL CORRER,CORRMN,IPRINT,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER AVG
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  AVERAGES OF YM
!     INTEGER CILO
!                  OCCUPIES THE SAME SPACE AS SLPC AND IS THE LOWER
!                  CONFIDENCE INTERVAL
!     INTEGER CIUP
!                  OCCUPIES THE SAME SPACE AS SLSC AND IS THE UPPER
!                  CONFIDENCE INTERVAL
!     DOUBLE PRECISION DSTAK(12)
!                  THE DOUBLE PRECISION VERSION OF
!                  THE /CSTAK/ WORK AREA.
!     INTEGER ICOR
!                  DETERMINES WHICH SUBROUTINE CALLED CORRMN
!                  IF =1, THEN CALLED BY CORR
!                     =2, THEN CALLED BY CORRS
!     INTEGER IERR
!                  A FLAG RETURNED TO THE USER INDICATING
!                  WHETHER  ERRORS WERE DETECTED IN THE PARAMETER LIST
!                  IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!                  IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!                  AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3
!                  INDICATES SINGLE PRECISION AND IFP=4 INDICATES
!                  DOUBLE PRECISION.
!     INTEGER IPRT
!                  LOGICAL OUTPUT UNIT
!     INTEGER ISTAK(12)
!                  THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IVCV
!                  THE DIMENSION OF VCV ASSIGNED IN THE USERS PROGRAM.
!     INTEGER IWRK
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  INTEGER WORK VECTOR.
!     INTEGER IYM
!                  ROW DIMENSION OF YM SPECIFIED IN THE USERS PROGRAM.
!     INTEGER LDSTAK
!                  SIZE OF WORK AREA ALLOCATED IN THE USERS PROGRAM
!     INTEGER LIWRK
!                  THE LENGTH OF THE INTEGER WORK VECTOR.
!     INTEGER LWRK
!                  THE LENGTH OF THE REAL WORK VECTOR.
!     INTEGER M
!                  THE NUMBER OF VARIABLES
!     INTEGER N
!                  THE NUMBER OF OBSERVATIONS
!     INTEGER NALL0
!                  THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE
!                  TIME THAT THIS ROUTINE WAS CALLED.
!     CHARACTER*1 NMSUB(6)
!                  THE SUBROUTINE NAME
!     INTEGER NPRT
!                  THE VARIABLE CONTROLLING THE AUTOMATIC PRINTOUT
!                  NPRT = 0 PRINTOUT IS SUPRESSED
!                  OTHERWISE THE PRINTOUT IS PROVIDED.
!     INTEGER PC
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  THE PARTIAL CORRELATION COEFFICIENTS MATRIX
!     INTEGER QF
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  QUADRATIC FIT MATRIX
!     INTEGER QUAD
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  REAL  QUAD FIT
!     INTEGER RANK
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  MATRIX CONTAINING THE RANKS OF YM
!     REAL RSTAK(12)
!                  THE REAL VERSION OF
!                  THE /CSTAK/ WORK AREA.
!     INTEGER SC
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  THE SIMPLE CORRELATION COEFFICIENTS MATRIX
!     INTEGER SCINV
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  INVERSE MATRIX OF VCV
!     INTEGER SD
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  STANDARD DEVIATIONS VECTOR
!     INTEGER SLPC
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  SIGNIFICANCE LEVELS FOR PC
!     INTEGER SLSC
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  SIGNIFICANCE LEVELS FOR SC
!     INTEGER SRCC
!                  STARTING LOCATION IN THE WORK AREA FOR THE SPEAR-
!                  MAN RANK COEFFICIENTS
!     INTEGER T
!                  STARTING LOCATION IN THE WORK AREA
!                  FOR THE WORK VECTOR T
!     REAL VCV(IVCV,M)
!                  THE VARIANCE COVARIANCE MATRIX
!     INTEGER WRK
!                  THE STARTING LOCATION IN THE WORK AREA FOR
!                  WORK SPACE
!     REAL YM(IYM,M)
!                  THE OBSERVATION MATRIX
!
!
!     SET UP NAME ARRAY
!
     data  nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6)&
     &   /       'C',      'O',      'R',      'R',      'S',      ' '/
!
!     SET UP FRAMEWORK VARIABLES FOR NUMBER TYPES
!
      ifp = 3
!
!     SET THE CALLER FLAG, THIS IS CORRS
!
      icor = 2
!
!     CHECK FOR ERRORS IN PARAMETERS
!
      call correr(nmsub, m, n, iym, ivcv, ldstak, icor, nprt)
!
!     IF THERE IS AN ERROR RETURN TO THE CALLERS ROUTINE
!
      if (ierr.eq.0) go to 10
!
!     PRINT CORRECT FORM OF CALL STATEMENT AND RETURN TO CALLER
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     INITIALIZE THE STACK
!
   10 call stkset (ldstak, 4)
      nall0 = stkst(1)
!
!     ALLOCATE SPACE IN DSTAK FOR MATRICES
!
      liwrk = max(n,m)
      lwrk = liwrk
!
      wrk = stkget(lwrk,ifp)
!
      if (nprt.eq.0) then
         iwrk = wrk
         t = wrk
         rank = wrk
         sc = wrk
         scinv = wrk
         slsc = wrk
         pc = wrk
         slpc = wrk
         quad = wrk
         qf = wrk
      else
         iwrk = stkget(liwrk,2)
         t = stkget(m,ifp)
         rank = stkget(n*m,ifp)
         sc = stkget(m*m,ifp)
         scinv = stkget(m*m,ifp)
         slsc = stkget(m*m,ifp)
         pc = stkget(m*m,ifp)
         slpc = stkget(m*m,ifp)
         quad = stkget(3*n,ifp)
         qf = stkget(m*m,ifp)
      end if
!
!     THE FOLLOWING VARIABLES HAVE BEEN INDIRECTLY EQUIVALENCED-
!
      ciup = slsc
      cilo = slpc
      avg = wrk
      sd = wrk
      srcc = scinv
!
     call corrmn(ym, n, m, iym, rstak(avg), rstak(sd), rstak(t),&
    &   rstak(rank), rstak(sc), rstak(pc), rstak(scinv), istak(iwrk),&
    &   rstak(wrk), rstak(slsc), rstak(slpc), rstak(srcc),&
    &   rstak(quad), rstak(ciup), rstak(cilo), rstak(qf),&
     &   nprt, vcv, ivcv, liwrk, lwrk)
!
!     RETURN AREA TO WORK
!
      call stkclr(nall0)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL CORRS (YM, N, M, IYM, LDSTAK, NPRT, VCV, IVCV)')
      end
!RANDN
      function randn(jd,typ) result(randn_)
      real(kind=wp) :: randn_
      real(kind=wp),intent(in) :: typ
!***BEGIN PROLOGUE  RANDN (ORIGINALLY RNOR)
!***DATE WRITTEN   810915
!***REVISION DATE  900315
!***CATEGORY NO.  L6A14
!***KEYWORDS  RANDOM NUMBERS, UNIFORM RANDOM NUMBERS
!***AUTHOR    KAHANER, DAVID
!             APPLIED AND COMPUTATIONAL MATHEMATICS DIVISTION, NIST
!
!             MARSAGLIA, GEORGE
!             COMPUTER SCIENCE DEPT., WASH STATE UNIV
!
!             MODIFIED BY -
!             DONALDSON, JANET
!             APPLIED AND COMPUTATIONAL MATHEMATICS DIVISTION, NIST
!
!***PURPOSE  GENERATES QUASI NORMAL RANDOM NUMBERS, WITH MEAN ZERO AND
!             UNIT STANDARD DEVIATION, AND CAN BE USED WITH ANY COMPUTER
!             WITH INTEGERS AT LEAST AS LARGE AS 32767.
!***DESCRIPTION
!
!       RANDN GENERATES QUASI NORMAL RANDOM NUMBERS WITH ZERO MEAN AND
!       UNIT STANDARD DEVIATION.
!       IT CAN BE USED WITH ANY COMPUTER WITH INTEGERS AT LEAST AS
!       LARGE AS 32767.
!
!
!   USE
!       FIRST TIME....
!                   Z = RANDN(JD)
!                     HERE JD IS ANY  N O N - Z E R O  INTEGER.
!                     THIS CAUSES INITIALIZATION OF THE PROGRAM
!                     AND THE FIRST RANDOM NUMBER TO BE RETURNED AS Z.
!       SUBSEQUENT TIMES...
!                   Z = RANDN(0)
!                     CAUSES THE NEXT RANDOM NUMBER TO BE RETURNED AS Z.
!
!=======================================================================
!
!    NOTE: USERS WHO WISH TO TRANSPORT THIS PROGRAM TO OTHER
!           COMPUTERS SHOULD READ THE FOLLOWING ....
!
!   MACHINE DEPENDENCIES...
!      MDIG = A LOWER BOUND ON THE NUMBER OF BINARY DIGITS AVAILABLE
!              FOR REPRESENTING INTEGERS, INCLUDING THE SIGN BIT.
!              THIS MUST BE AT LEAST 16, BUT CAN BE INCREASED IN
!              LINE WITH REMARK A BELOW.
!
!   REMARKS...
!     A. THIS PROGRAM CAN BE USED IN TWO WAYS:
!        (1) TO OBTAIN REPEATABLE RESULTS ON DIFFERENT COMPUTERS,
!            SET 'MDIG' TO THE SMALLEST OF ITS VALUES ON EACH, OR,
!        (2) TO ALLOW THE LONGEST SEQUENCE OF RANDOM NUMBERS TO BE
!            GENERATED WITHOUT CYCLING (REPEATING) SET 'MDIG' TO THE
!            LARGEST POSSIBLE VALUE.
!     B. THE SEQUENCE OF NUMBERS GENERATED DEPENDS ON THE INITIAL
!          INPUT 'JD' AS WELL AS THE VALUE OF 'MDIG'.
!          IF MDIG=16 ONE SHOULD FIND THAT
!            THE FIRST EVALUATION
!              Z=RANDN(87) GIVES  Z=-.40079207...
!            THE SECOND EVALUATION
!              Z=RANDN(0) GIVES   Z=-1.8728870...
!            THE THIRD EVALUATION
!              Z=RANDN(0) GIVES   Z=1.8216004...
!            THE FOURTH EVALUATION
!              Z=RANDN(0) GIVES   Z=.69410355...
!            THE THOUSANDTH EVALUATION
!              Z=RANDN(0) GIVES   Z=.96782424...
!
!***REFERENCES  MARSAGLIA & TSANG, "A FAST, EASILY IMPLEMENTED
!                 METHOD FOR SAMPLING FROM DECREASING OR
!                 SYMMETRIC UNIMODAL DENSITY FUNCTIONS", TO BE
!                 PUBLISHED IN SIAM J SISC 1983.
!***ROUTINES CALLED  I1MACH,XERROR
!***END PROLOGUE  RANDN
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   jd
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   aa,b,c,c1,c2,one,p5,pc,rmax,s,x,xn,y
     integer&
     &   i,i1,j,j0,j1,jseed,k0,k1,m1,m2,mdig
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   v(65),w(65)
     integer&
     &   m(17)
!
!  EXTERNAL FUNCTIONS
!      real(kind=wp) ::
!     &   randu
!      integer
!     &   i1mach
!      external randu,i1mach
!
!  EXTERNAL SUBROUTINES
!      external xerror
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,exp,log,min,mod,real,sign
!
!  SAVE STATEMENT
      save i1,j1,m,m1,m2,rmax
!
     data aa,b,c,rmax/12.37586_wp,0.4878992_wp,12.67706_wp,&
     & 3.0518509e-5_wp/
     data c1,c2,pc,xn/0.9689279_wp,1.301198_wp,0.1958303e-1_wp,&
     & 2.776994_wp/
     data (v(i),i=1,15)/0.3409450_wp,0.4573146_wp,0.5397793_wp,&
    &     0.6062427_wp,0.6631691_wp,0.7136975_wp,0.7596125_wp,&
    & 0.8020356_wp,&
    &     0.8417227_wp,0.8792102_wp,0.9148948_wp,0.9490791_wp,&
    & 0.9820005_wp,&
     &     1.0138492_wp,1.0447810_wp/
     data (v(i),i=16,30)/1.0749254_wp,1.1043917_wp,1.1332738_wp,&
    &     1.1616530_wp,1.1896010_wp,1.2171815_wp,1.2444516_wp,&
    & 1.2714635_wp,&
    &     1.2982650_wp,1.3249008_wp,1.3514125_wp,1.3778399_wp,&
    & 1.4042211_wp,&
     &     1.4305929_wp,1.4569915_wp/
     data (v(i),i=31,45)/1.4834526_wp,1.5100121_wp,1.5367061_wp,&
    &     1.5635712_wp,1.5906454_wp,1.6179680_wp,1.6455802_wp,&
    & 1.6735255_wp,&
    &     1.7018503_wp,1.7306045_wp,1.7598422_wp,1.7896223_wp,&
    & 1.8200099_wp,&
     &     1.8510770_wp,1.8829044_wp/
     data (v(i),i=46,60)/1.9155830_wp,1.9492166_wp,1.9839239_wp,&
    &     2.0198430_wp,2.0571356_wp,2.0959930_wp,2.1366450_wp,&
    & 2.1793713_wp,&
    &     2.2245175_wp,2.2725185_wp,2.3239338_wp,2.3795007_wp,&
    & 2.4402218_wp,&
     &     2.5075117_wp,2.5834658_wp/
     data (v(i),i=61,65)/2.6713916_wp,2.7769943_wp,2.7769943_wp,&
     &     2.7769943_wp,2.7769943/
     data (w(i),i=1,20)/0.10405134e-04_wp,0.13956560e-04_wp,&
    & 0.16473259e-04_wp,&
    &     0.18501623e-04_wp,0.20238931e-04_wp,0.21780983e-04_wp,&
    & 0.23182241e-04_wp,&
    &     0.24476931e-04_wp,0.25688121e-04_wp,0.26832186e-04_wp,&
    & 0.27921226e-04_wp,&
    &     0.28964480e-04_wp,0.29969191e-04_wp,0.30941168e-04_wp,&
    & 0.31885160e-04_wp,&
    &     0.32805121e-04_wp,0.33704388e-04_wp,0.34585827e-04_wp,&
    & 0.35451919e-04_wp,&
     &     0.36304851e-04_wp/
     data (w(i),i=21,40)/0.37146564e-04_wp,0.37978808e-04_wp,&
    & 0.38803170e-04_wp,&
    &     0.39621114e-04_wp,0.40433997e-04_wp,0.41243096e-04_wp,&
    & 0.42049621e-04_wp,&
    &     0.42854734e-04_wp,0.43659562e-04_wp,0.44465208e-04_wp,&
    & 0.45272764e-04_wp,&
    &     0.46083321e-04_wp,0.46897980e-04_wp,0.47717864e-04_wp,&
    & 0.48544128e-04_wp,&
    &     0.49377973e-04_wp,0.50220656e-04_wp,0.51073504e-04_wp,&
    & 0.51937936e-04_wp,&
     &     0.52815471e-04_wp/
     data (w(i),i=41,60)/0.53707761e-04_wp,0.54616606e-04_wp,&
    & 0.55543990e-04_wp,&
    &     0.56492112e-04_wp,0.57463436e-04_wp,0.58460740e-04_wp,&
    & 0.59487185e-04_wp,&
    &     0.60546402e-04_wp,0.61642600e-04_wp,0.62780711e-04_wp,&
    & 0.63966581e-04_wp,&
    &     0.65207221e-04_wp,0.66511165e-04_wp,0.67888959e-04_wp,&
    & 0.69353880e-04_wp,&
    &     0.70922996e-04_wp,0.72618816e-04_wp,0.74471933e-04_wp,&
    & 0.76525519e-04_wp,&
     &     0.78843526e-04_wp/
     data (w(i),i=61,65)/0.81526890e-04_wp,0.84749727e-04_wp,&
    & 0.84749727e-04_wp,&
     &     0.84749727e-04_wp,0.84749727e-04_wp/
     data m(1),m(2),m(3),m(4),m(5),m(6),m(7),m(8),m(9),m(10),m(11),&
    &     m(12),m(13),m(14),m(15),m(16),m(17)/30788,23052,2053,19346,&
    &     10646,19427,23975,19049,10949,19693,29746,26748,2796,23890,&
     &     29168,31924,16499/
      data m1,m2,i1,j1/32767,256,5,17/
      data p5,one/0.5_wp,1.0_wp/
!
! FAST PART...
!
!
!***FIRST EXECUTABLE STATEMENT  RANDN
      if (jd.ne.0) then
!  FILL
          mdig = i1mach(8) + 1
!
!  MODIFICATION SO SAME NUMBERS WILL BE GENERATED ON ALL MACHINES
!  WITH I1MACH(8) AT LEAST 31
!
          mdig = min(mdig,32)
!
!  BE SURE THAT MDIG AT LEAST 16...
          if (mdig.lt.16) call xerror('RANDN--MDIG LESS THAN 16',23,1,2)
!
          m1 = 2** (mdig-2) + (2** (mdig-2)-1)
          m2 = 2** (mdig/2)
          jseed = min(abs(jd),m1)
          if (mod(jseed,2).eq.0) jseed = jseed - 1
          k0 = mod(9069,m2)
          k1 = 9069/m2
          j0 = mod(jseed,m2)
          j1 = jseed/m2
          do 10 i = 1,17
              jseed = j0*k0
              j1 = mod(jseed/m2+j0*k1+j1*k0,m2/2)
              j0 = mod(jseed,m2)
              m(i) = j0 + m2*j1
   10     continue
          j1 = 17
          i1 = 5
          rmax = one/real(m1,kind=wp)
!  SEED UNIFORM (0,1] GENERATOR.  (JUST A DUMMY CALL)
          randn_ = randu(jd)
          do 20 i = 1,65
              w(i) = rmax*v(i)
   20     continue
      end if

      i = m(i1) - m(j1)
      if (i.lt.0) i = i + m1
      m(j1) = i
      i1 = i1 - 1
      if (i1.eq.0) i1 = 17
      j1 = j1 - 1
      if (j1.eq.0) j1 = 17
      j = mod(i,64) + 1
      randn_ = i*w(j+1)
      if (((i/m2)/2)*2.eq. (i/m2)) randn_ = -randn_
      if (abs(randn_).gt.v(j)) then
!  SLOW PART; AA IS A*F(0)
          x = (abs(randn_)-v(j))/ (v(j+1)-v(j))
          y = randu(0)
          s = x + y
          if (s.le.c2) then
              if (s.le.c1) then
                  return
              else if (y.le.c-aa*exp(-p5 * (b-b*x)**2)) then
                 if (exp(-p5*v(j+1)**2)+y*pc/v(j+1).gt.&
     &                exp(-p5*randn_**2)) then
   30                 continue
! TAIL PART; 3.855849 IS .5*XN**2
                      s = xn - log(randu(0))/xn
                     if (3.855849_wp+log(randu(0))-xn*s.gt.&
     &                    -p5*s**2) go to 30
                      randn_ = sign(s,randn_)
                  end if
                  return
              else
              end if
          end if
          randn_ = sign(b-b*x,randn_)
      end if
      end
!HIST
      subroutine hist(y, n, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR PRODUCING A HISTOGRAM
!     (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   ylb,yub
     integer&
     &   idp,ifp,iint,iprt,lsort,nall0,ncells,ydist
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL HSTER,HSTMN,IPRINT,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic anint,log10,min,nint,real
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDP
!        THE CODE VALUE FOR DOUBLE PRECISION FOR FRAMEWORK.
!     INTEGER IERR
!        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
!        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
!        SOME ERROR EXISTS.
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IINT
!        THE CODE VALUE FOR INTEGER FOR FRAMEWORK
!     INTEGER IPRT
!        THE NUMBER OF THE STANDARD OUTPUT UNIT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
!        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
!     INTEGER LSORT
!        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION
!        VECTOR.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
!        WAS CALLED.
!     INTEGER NCELLS
!        THE NUMBER OF CELLS IN THE HISTOGRAM.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL Y(N)
!        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
!        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
!        TO ITS ORIGINAL ORDER AFTERWARDS.
!     INTEGER YDIST
!        THE STARTING LOCATION IN RSTAK OF THE DISTRIBUTION VECTOR.
!     REAL YLB
!        THE LOWER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!     REAL YUB
!        THE UPPER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!
!     INITIALIZE NAME VECTORS
!
     data  nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6)&
     &   /       'H',      'I',      'S',      'T',      ' ',      ' '/
!
      data idp /4/
      data iint /2/
      data ylb/0.0e0/, yub/0.0e0/
!
!     COMPUTE NCELLS
!
      if (n.ge.1) then
         ncells = min(nint(5.5e0+1.5e0*anint(log10(real(n)))),25)
      else
         ncells = 1
      end if
!
!     CHECK FOR ERRORS IN THE INPUT PARAMETERS
!
      call hster(nmsub, y, n, ncells, ldstak, ylb, yub, ierr)
      if (ierr.eq.0) go to 10
!
!     PRINT ERROR MESSAGE.
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     SET UP FRAMEWORK AREA.
!
   10 call stkset (ldstak, idp)
      nall0 = stkst(1)
!
!     SET UP WORK VECTORS
!
      ifp = 3
!
      lsort = stkget(n,iint)
      ydist = stkget(ncells,ifp)
!
!     COMPUTE THE HISTOGRAM.
!
      call hstmn(y, n, ncells, ylb, yub, istak(lsort), rstak(ydist))
!
!     RETURN THE WORK VECTORS.
!
      call stkclr(nall0)
      return
!
!     FORMAT STATEMENTS.
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL HIST (Y, N, LDSTAK)')
      end
!PGMEST
      subroutine pgmest (yfft, nfft, nf, cnst, per, lper)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE PERIODOGRAM ESTIMATES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   cnst
     integer&
     &   lper,nf,nfft
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   per(lper),yfft(nfft)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fac
     integer&
     &   i,isn,nfft2
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL FFT,REALTR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CNST
!        THE VARIANCE OF THE OBSERVED TIME SERIES TIMES THE NUMBER OF
!        OBSERVATIONS IN THE SERIES IF CALLED BY IPGM,
!        OR 1.0E0 IF CALLED BY PGM.
!     REAL FAC
!        A FACTOR USED FOR COMPUTATIONS OF THE INTEGRATED PERIODOGRAM.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER ISN
!        A CODE USED FOR THE FFT.
!     INTEGER LPER
!        THE LENGTH OF THE PERIODOGRAM ARRAY.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        COMPUTED.
!     INTEGER NFFT
!        THE EFFECTIVE NUMBER OF OBSERVATIONS FOR THE FFT TRANSFORM.
!     INTEGER NFFT2
!        THE EFFECTIVE NUMBER OF COMPLEX OBSERVATIONS FOR THE FFT
!        TRANSFORM.
!     REAL PER(LPER)
!        THE PERIODOGRAM.
!     REAL YFFT(NFFT)
!        THE CENTERED SERIES.
!
!     COMPUTE THE FOURIER COEFFICIENTS
!
      nfft2 = (nfft-2) / 2
      isn = 2
!
      call fft (yfft(1), yfft(2), nfft2, nfft2, nfft2, isn)
      call realtr (yfft(1), yfft(2), nfft2, isn)
!
      fac = 0.5e0 / (cnst * (nfft-2))
!
      nf = nfft2 + 1
!
      do 10 i = 1, nf
         per(i) = (yfft(2*i-1)*yfft(2*i-1) + yfft(2*i)*yfft(2*i)) * fac
   10 continue
!
      return
      end
!CCFLST
     subroutine ccflst (rhoc, sdrhoc, nlpp12, nlpp21, lagmax, lccov,&
     &   ncc, ifmiss)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE ACTUALLY LISTS THE CROSS CORRELATIONS AND THEIR
!     STANDARD ERRORS, AND MISCELLANEOUS SUMMARY INFORMATION.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lagmax,lccov,ncc
     logical&
     &   ifmiss
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   rhoc(*),sdrhoc(*)
     integer&
     &   nlpp12(*),nlpp21(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm
     integer&
     &   i,i1,imax,imin,iprt,k,k0,k1,lagn,nperl
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rlst(12),sdrlst(12)
     integer&
     &   lag(12),nlplst(12)
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic min,mod
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     LOGICAL IFMISS
!        THE INDICATOR VARIABLE USED TO DETERMINE
!        WHETHER THE INPUT SERIES HAS MISSING DATA OR NOT.
!     INTEGER IMAX, IMIN
!        THE INDEX VALUES OF THE FIRST AND LAST OBSERVATION
!        TO BE PRINTED PER LINE
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT
!     INTEGER I1
!        AN INDEX VARIABLE.
!     INTEGER K, K0, K1
!        INDEX VARIABLES.
!     INTEGER LAG(12)
!        THE LAG VALUE OF THE CORRELATION BEING PRINTED.
!     INTEGER LAGMAX
!        THE LARGEST LAG VALUE TO BE USED.
!     INTEGER LAGN
!        THE NUMBER OF LAG VALUES TO BE PRINTED PER LINE.
!     INTEGER LCCOV
!        THE NUMBER OF LOCATIONS ALLOWED FOR STORING THE NLPPC.
!     INTEGER NCC
!        THE NUMBER OF CROSS CORRELATIONS COMPUTED (FROM -LAGMAX
!        TO +LAGMAX).
!     INTEGER NLPLST(12)
!        THE ARRAY WHICH CONTAINS THE VALUES OF NLPPC TO BE PRINTED
!        ON EACH LINE, ORDERED PROPERLY.
!     INTEGER NLPP12(LCCOV), NLPP21(LCCOV)
!        THE NUMBER OF LAGGED PRODUCT PAIRS USED TO COMPUTE EACH
!        CCVF AT EACH LAG.
!     INTEGER NPERL
!        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
!     REAL RHOC(NCC)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS OR PARTIAL
!        AUTOCORRELATIONS WILL BE PASSED TO THIS ROUTINE.
!     REAL RLST(12)
!        THE ARRAY WHICH CONTAINS THE VALUES OF RHO TO BE PRINTED
!        ON EACH LINE, ORDERED PROPERLY.
!     REAL SDRHOC(NCC)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!        ARE STORED
!     REAL SDRLST(12)
!        THE ARRAY WHICH CONTAINS THE VALUES OF SDRHO TO BE PRINTED
!        ON EACH LINE, ORDERED PROPERLY.
!
!
      call iprint(iprt)
      nperl = 12
!
      k0 = lagmax + 1
!
      lagn = mod(lagmax, nperl)
      if (lagn .eq. 0) lagn = nperl
      i1 = lagn + 1
!
      do 20 i = i1, k0, nperl
         do 10 k = 1, lagn
            lag(k) = i - k0 - k
            k1 = i - k
            rlst(k) = rhoc(k1)
            sdrlst(k) = sdrhoc(k1)
            if (.not. ifmiss) go to 10
            k1 = k0 - k1
            nlplst(k) = nlpp21(k1+1)
   10    continue
         write(iprt, 1000) (lag(k), k = 1, lagn)
         write(iprt, 1001) (rlst(k), k = 1, lagn)
         write(iprt, 1002) (sdrlst(k), k = 1, lagn)
         if (ifmiss) write(iprt, 1003) (nlplst(k), k = 1, lagn)
         lagn = nperl
   20 continue
!
      lag(1) = 0
      write(iprt, 1000) lag(1)
      write(iprt, 1001) rhoc(k0)
      write(iprt, 1002) sdrhoc(k0)
      if (ifmiss) write(iprt, 1003) nlpp12(1)
!
      do 40 i = 1, lagmax, nperl
         imin = i + k0
         imax = min(imin + nperl - 1, 2*lagmax+1)
         lagn = imax - imin + 1
         do 30 k = 1, lagn
            lag(k) = i - 1 + k
   30    continue
         write(iprt, 1000) (lag(k), k = 1, lagn)
         write(iprt, 1001) (rhoc(k), k = imin, imax)
         write(iprt, 1002) (sdrhoc(k), k = imin, imax)
         if (.not. ifmiss) go to 40
         imin = i
         imax = min(i + nperl - 1, lagmax)
         write (iprt,1003) (nlpp12(k+1), k=imin,imax)
   40 continue
!
      fplm = r1mach(2)
!
     if (sdrhoc(1).eq.fplm .or. sdrhoc(2*lagmax+1).eq.fplm)&
     &   write(iprt, 1004) fplm
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format(/19h lag               , 12(1x, i6))
 1001 format( 19h ccf               , 12(2x, f5.2))
 1002 format( 19h standard error    , 12(2x, f5.2))
 1003 format( 19h no. of obs. used  , 12(1x, i6))
1004 format(///5x, f5.2, 38h indicates value could not be computed,&
     &   21h due to missing data.)
      end
!MDLTS2
     subroutine mdlts2 (par, rests, y, npar, n, nfac, mspect, pmu,&
     &  pardf, npardf, t, temp, parar, parma, mbo, n1, n2, iflag)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MODEL ROUTINE FOR PACKS SPECIFICATION OF
!     BOX-JENKINS MODELS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 4, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   pmu
     integer&
     &   iflag,mbo,n,n1,n2,nfac,npar,npardf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   par(npar),parar(*),pardf(*),parma(*),rests(n1:n2),t(*),&
     &   temp(*),y(n)
     integer&
     &   mspect(nfac,4)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplpm,resmax,wtest
     integer&
    &   i,imod,imod1,ipar,ipq,istart,j,k,l,maxord,mbo1,np,nparar,&
     &   nparma
     logical&
     &   parle1
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
!       EXTERNAL R1MACH
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,log,mod,sign,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL FPLPM
!        THE FLOATING POINT LARGEST POSITIVE MAGNITUDE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IFLAG
!        AN INDICATOR VARIABLE DESIGNATING WHETHER THE BACK FORECASTS
!        WERE ESSENTIALLY ZERO (IFLAG=0) OR NOT (IFLAG=1).
!     INTEGER IMOD
!        AN INDEX VARIABLE.
!     INTEGER IPAR
!        AN INDEX VARIABLE.
!     INTEGER IPQ
!        AN INDEX VARIABLE.
!     INTEGER ISTART
!        ***
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER L
!        AN INDEX VARIABLE.
!     INTEGER MAXORD
!        THE LARGEST BACK ORDER.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBO1
!        THE VALUE MBO+1
!     INTEGER MSPECT(NFAC,4)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NP
!        THE NUMBER OF PARAMETERS IN THE EXPANDED TERM.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER N1
!        THE LOWER BOUND FOR RESTS.
!     INTEGER N2
!        THE UPPER BOUND FOR RESTS.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PARAR(MBO)
!        THE AUTOREGRESSIVE PARAMETERS
!     REAL PARDF(NPARDF)
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS.
!     LOGICAL PARLE1
!        A FLAG INDICATING WHETHER ALL OF THE MOVING AVERAGE PARAMETERS
!        ARE LESS THAN OR EQUAL TO 1 (PARLE1 = .TRUE.) OR NOT
!        (PARLE1 = .FALSE.)
!     REAL PARMA(MBO)
!        THE MOVING AVERAGE PARAMETERS
!     REAL PMU
!        THE VALUE OF MU, I.E., THE TREND OR MEAN.
!     REAL RESMAX
!        THE LARGEST POSSIBLE RESIDUAL WHICH WILL STILL AVOID OVERFLOW.
!     REAL RESTS(N1:N2)
!        THE PREDICTED VALUE OF THE FIT.
!     REAL T(2*MBO)
!        A TEMPORARY WORK VECTOR.
!     REAL TEMP(MBO)
!        A TEMPORARY WORK VECTOR
!     REAL WTEST
!        THE TEST VALUE USED TO DETERMINE IF THE DIFFERENCED SERIES
!        BACK FORECAST IS EFFECTIVELY ZERO OR NOT.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
      fplpm = r1mach(2)
!
!     ZERO THE PARAMETER ARRAYS PARAR AND PARMA
!
      do 10 i=1,mbo
         t(i) = 0.0e0
         temp(i) = 0.0e0
   10 continue
!
      np = 0
      ipar = 0
      nparar = 0
      istart = 0
!
!     EXPAND THE MODEL AND STORE AUTOREGRESSIVE PARAMETERS IN PARAR
!     AND MOVING AVERAGE PARAMETERS IN PARMA
!
      do 110 ipq = 1, 3, 2
         do 100 l=1,nfac
            if (mspect(l,ipq).eq.0) go to 100
            maxord = mspect(l,ipq)*mspect(l,4)
            do 90 k = mspect(l,4), maxord, mspect(l,4)
               ipar = ipar + 1
               temp(k) = temp(k) + par(ipar)
               do 80 i = 1, np
                  temp(k+i) = temp(k+i) - t(i)*par(ipar)
   80          continue
   90       continue
            np = np + maxord
            do 95 k = 1, np
               t(k) = temp(k)
   95       continue
  100    continue
          if (ipq.ne.3) then
            ipar = ipar + 1
            pmu = par(ipar)
            nparar = np
            do 105 k =1, nparar
               parar(k) = t(k)
               t(k) = 0.0e0
               temp(k) = 0.0e0
  105       continue
            np = 0
         end if
  110 continue
      nparma = np
      parle1 = .true.
      do 115 k =1, nparma
         parma(k) = t(k)
         if (abs(parma(k)).gt.1.0e0) parle1 = .false.
  115 continue
!
!     COMPUTE FITTED VALUES AND RESIDUALS FOR MODEL.
!
!     COMPUTE W, THE DIFFERENCED SERIES MINUS ITS MEAN, AND STORE IN
!     RESTS(NPARDF+1) TO RESTS(N2)
!
      do 140 i = npardf+1, n2, 1
         rests(i) = y(i) - pmu
         do 130 j = 1,npardf
            rests(i) = rests(i) - pardf(j)*y(i-j)
  130    continue
  140 continue
      wtest = abs(rests(npardf+1))*0.01
!
!     BACK FORECAST THE ERROR, E, FOR I = N-NPARAR TO NPARDF+1, AND
!     THE DIFFERENCED SERIES FOR I = NPARDF TO N1
!
      mbo1 = mbo+1
      iflag = 0
      do 170 i = n2-nparar,npardf+1,-1
         imod = mod(i+1-n1,mbo1) + 1
         t(imod) = rests(i)
         do 150 j = 1,nparar
            t(imod) = t(imod) - parar(j)*rests(i+j)
  150    continue
         do 160 j = 1,nparma
           if ((i+j.gt.npardf) .and. (i+j.le.n))&
     &         t(imod) = t(imod) + parma(j)*t(mod(i+j+1-n1,mbo1)+1)
  160    continue
  170 continue
      do 175 i = npardf,n1,-1
         imod = mod(i+1-n1,mbo1) + 1
         rests(i) = 0.0e0
         do 163 j = 1,nparar
            rests(i) = rests(i) + parar(j)*rests(i+j)
  163    continue
         do 166 j = 1,nparma
           if ((i+j.gt.npardf) .and. (i+j.le.n))&
    &         rests(i) = rests(i) -&
     &                    parma(j)*t(mod(i+j+1-n1,mbo1)+1)
  166    continue
         istart = i
         if ((istart.le.1) .and. (abs(rests(i)).le.wtest)) go to 180
  175 continue
      iflag = 1
!
!     COMPUTE RESIDUALS AND STORE VALUES IN RESTS
!
  180 continue
      do 210 i = istart,n2,1
         imod = mod(i+1-n1,mbo1) + 1
         t(imod) = rests(i)
         do 190 j = 1,nparar
            if (i-j.ge.istart) t(imod) = t(imod) - parar(j)*rests(i-j)
  190    continue
!
         if (parle1) then
!
!     COMPUTE RESIDUALS WHERE THERE IS NO CHANCE OF OVERFLOW
!
            do 200 j = 1,nparma
              if (i-j.ge.istart)&
     &            t(imod) = t(imod) + parma(j)*t(mod(i-j+1-n1,mbo1)+1)
  200       continue
         else
!
!     COMPUTE RESIDUALS WHERE THERE IS A CHANCE OF OVERFLOW
!
            do 205 j = 1,nparma
               if (i-j.ge.istart) then
                  imod1 = mod(i-j+1-n1,mbo1)+1
                  if (parma(j).ne.0.0e0 .and. t(imod1).ne.0.0e0) then
                    if (log(abs(parma(j)))+log(abs(t(imod1))).lt.&
    &                         log(fplpm)&
    &                     .and.&
    &                     (sign(1.0e0,t(imod)).ne.&
    &                         sign(1.0e0,parma(j)*t(imod1))&
    &                     .or.&
    &                     log(abs(parma(j)))+log(abs(t(imod1))).lt.&
     &                         log(fplpm-abs(t(imod))))) then
                        t(imod) = t(imod) + parma(j)*t(imod1)
                     else
                        go to 300
                     end if
                  end if
               end if
  205       continue
         end if
         if (i-mbo.ge.istart) then
            rests(i-mbo) = t(mod(i-mbo+1-n1,mbo1)+1)
         end if
  210 continue
      do 220 i = n-mbo+1,n
        rests(i) = t(mod(i-mbo+2-n1,mbo1)+1)
  220 continue
!
      do 230 i = n1, istart-1
         rests(i) = 0.0e0
  230 continue
!
      return
!
!     SET RESIDUALS TO LARGEST POSSIBLE VALUE
!
  300 resmax = sqrt(fplpm/(n2-n1+1))
      do 310 i=n1,n2
         rests(i) = resmax
  310 continue
!
      return
!
      end
!CORRXP
      subroutine corrxp(m, vcv, ivcv, iprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     PRINT STORED OUTPUT RETURNED FROM CORRS
!
!     WRITTEN BY -
!        LINDA MITCHELL
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iprt,ivcv,m
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   vcv(*)
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL MATPRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IPRT
!        THE LOGICAL OUTPUT NUMBER
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV
!     INTEGER M
!        THE NUMBER OF VARIABLES IN THE ANALYSIS
!     REAL VCV(IVCV,M)
!        ARRAYS TO BE PRINTED
!
      if (ivcv.ge.m) then
         write (iprt,1000)
         write (iprt,1010)
         call matprt(vcv, vcv, m, iprt, 1, 1, ivcv)
      end if
!
!     FORMAT STATEMENTS
!
      return
 1000 format (/ 20h storage from corrs.)
 1010 format (40h storage from variance-covariance matrix)
      end
!MPPC
     subroutine mppc(ym, x, n, m, iym, ilog, isize, nout, ylb, yub,&
     &  xlb, xub)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH MULTIPLE Y-AXIS VALUES (LONG CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   xlb,xub,ylb,yub
     integer&
     &   ilog,isize,iym,m,n,nout
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xmiss
     integer&
     &   iprt,ischck,lisym
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(IYM,M)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'M',       'P',       'P',       'C',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      xmiss = 1.0e0
      multi = .true.
      ischck = 2
      miss = .false.
      lisym = 1
!
     call ppcnt (ym, ym, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &  '       CALL MPPC (YM, X, N, M, IYM, ILOG,'/&
     &  '      +           ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      end
!ACFMNM
     subroutine acfmnm(y, ymiss, n, lagmax, rho, sdrho, nlppa, ymean,&
    &   prho, aic, ftest, phi, iar, ospvar, acov, lacov, laic, chia,&
     &   chiap, laglst, work, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING AUTOCORRELATIONS AND
!     PARTIAL AUTOCORRELATIONS OF A TIME SERIES WITH MISSING DATA.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: chia,chiap,ospvar,ymean,ymiss
     integer&
     &   iar,lacov,laglst,lagmax,laic,n,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   acov(*),aic(*),ftest(2,*),phi(*),prho(*),rho(*),sdrho(*),&
     &   work(*),y(*)
     integer&
     &   nlppa(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm
     integer&
     &   i,nused
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
!       EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL ACFSDM,ACVFM,AOS,CHIRHO
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV)
!        THE AUTOCOVARIANCE FUNCTION ESTIMATE VECTOR.
!     REAL AIC(LAIC)
!        THE ARRAY CONTAINING AKAIAES CRITERION FOR EACH ORDER.
!     REAL CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     REAL FTEST(2, LAGMAX)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGLST
!        THE LAST LAG BEFORE MISSING DATA CAUSED THE ACVF OF THE
!        SERIES NOT TO BE COMPUTED.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER NLPPA(LACOV)
!        THE ARRAY CONTAINING THE NUMBERS OF LAGGED PRODUCT PAIRS
!        USED TO COMPUTE THE ACVF AT EACH LAG.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     INTEGER NUSED
!        THE NUMBER OF ACTIVE (NOT MISSING) OBSERVATIONS IN THE SERIES.
!     REAL OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED ORDER (IAR).
!     REAL PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER (IAR).
!     REAL PRHO(LAGMAX)
!        THE ARRAY IN WHICH THE PARTIAL AUTOCORRELATIONS ARE STORED
!     REAL RHO(LAGMAX)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
!     REAL SDRHO(LAGMAX)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!        ARE STORED
!     REAL WORK(LAGMAX)
!        AN ARRAY USED IN THE COMPUTATIONS OF THE PARTIAL
!        AUTOCORRELATIONS COEFFICIENTS.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED SERIES
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     REAL YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER
!        OR NOT AN OBSERVATION IN THE SERIES IS MISSING.
!        IF Y(I) .EQ. YMISS, THE VALUE IS ASSUMED MISSING.
!        IF Y(I) .NE. YMISS, THE VALUE IS ASSUMED NOT MISSING.
!
!
      fplm = r1mach(2)
!
!     COMPUTE AUTOCOVARIANCES OF THE SERIES WITH MISSING DATA.
!
      call acvfm(y, ymiss, n, ymean, acov, lagmax, laglst, nlppa, lacov)
!
      if (nlppa(1) .eq. 0 .or. acov(1) .eq. 0.0e0) return
!
      if (nprt .eq. 0) return
!
!     COMPUTE PARTIAL AUTOCORRELATIONS AND THE AUTOREGRESSIVE MODEL
!     ORDER SELECTION STATISTICS IF THERE WERE NO MISSING DATA.
!
     if (nlppa(1) .eq. n) call aos (n, lagmax, acov, prho, iar,&
     &   ospvar, phi, work, aic, ftest, lacov, laic)
!
!     COMPUTE AUTOCORRELATIONS.
!
      do 10 i = 1, lagmax
         if (nlppa(i+1) .ge. 1) rho(i) = acov(i+1) / acov(1)
   10 continue
!
!     PRESET SDRHO VALUES FOR PRINTING ROUTINE
!
      do 20 i = laglst, lagmax
         sdrho(i) = fplm
   20 continue
!
!     COMPUTE STANDARD ERROR OF AUTOCORRELATIONS.
!
      call acfsdm (rho, sdrho, laglst, n, nlppa(2))
!
      if (laglst .eq. 0) return
!
!     COMPUTE CHI STATISTIC BASED ON AUTOCORRELATION VALUES
!
      nused = nlppa(1)
!
      call chirho (rho, nused, laglst, chia, chiap)
!
      return
      end
!XXCH11
      subroutine xxch11(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE COMPLEX DEMODULATION FAMILY OF ROUTINES.
!
!     DATA IS THE WOLF SUMSPOT NUMBERS FOR THE YEARS 1700 TO 1960 AS
!     TABULATED BY WALDMEIER [1961].
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fc,fd
     integer&
     &   iprt,k,n
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   y(300)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DEMOD,IPRINT
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FC
!        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
!     REAL FD
!        THE DEMODULATION FREQUENCY.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER K
!        THE NUMBER OF TERMS IN THE SYMETRIC LINEAR FILTER.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     REAL Y(300)
!        THE LOG OF THE AIRLINE DATA.
!
!
     data   y(  1),  y(  2),  y(  3),  y(  4),  y(  5),  y(  6)&
     &    /     5.0e0, 11.0e0, 16.0e0, 23.0e0, 36.0e0, 58.0e0/
     data   y(  7),  y(  8),  y(  9),  y( 10),  y( 11),  y( 12)&
     &    /    29.0e0, 20.0e0, 10.0e0,  8.0e0,  3.0e0,  0.0e0/
     data   y( 13),  y( 14),  y( 15),  y( 16),  y( 17),  y( 18)&
     &    /     0.0e0, 2.0e0, 11.0e0, 27.0e0, 47.0e0, 63.0e0/
     data   y( 19),  y( 20),  y( 21),  y( 22),  y( 23),  y( 24)&
     &    /    60.0e0, 39.0e0, 28.0e0, 26.0e0, 22.0e0, 11.0e0/
     data   y( 25),  y( 26),  y( 27),  y( 28),  y( 29),  y( 30)&
     &    /    21.0e0, 40.0e0, 78.0e0,122.0e0,103.0e0, 73.0e0/
     data   y( 31),  y( 32),  y( 33),  y( 34),  y( 35),  y( 36)&
     &    /    47.0e0, 35.0e0, 11.0e0,  5.0e0, 16.0e0, 34.0e0/
     data   y( 37),  y( 38),  y( 39),  y( 40),  y( 41),  y( 42)&
     &    /    70.0e0, 81.0e0,111.0e0,101.0e0, 73.0e0, 40.0e0/
     data   y( 43),  y( 44),  y( 45),  y( 46),  y( 47),  y( 48)&
     &    /    20.0e0, 16.0e0,  5.0e0, 11.0e0, 22.0e0, 40.0e0/
     data   y( 49),  y( 50),  y( 51),  y( 52),  y( 53),  y( 54)&
     &    /    60.0e0, 80.9e0, 83.4e0, 47.7e0, 47.8e0, 30.7e0/
     data   y( 55),  y( 56),  y( 57),  y( 58),  y( 59),  y( 60)&
     &    /    12.2e0,  9.6e0, 10.2e0, 32.4e0, 47.6e0, 54.0e0/
     data   y( 61),  y( 62),  y( 63),  y( 64),  y( 65),  y( 66)&
     &    /    62.9e0, 85.9e0, 61.2e0, 45.1e0, 36.4e0, 20.9e0/
     data   y( 67),  y( 68),  y( 69),  y( 70),  y( 71),  y( 72)&
     &    /    11.4e0, 37.8e0, 69.8e0,106.1e0,100.8e0, 81.6e0/
     data   y( 73),  y( 74),  y( 75),  y( 76),  y( 77),  y( 78)&
     &    /    66.5e0, 34.8e0, 30.6e0,  7.0e0, 19.8e0, 92.5e0/
     data   y( 79),  y( 80),  y( 81),  y( 82),  y( 83),  y( 84)&
     &    /   154.4e0,125.9e0, 84.8e0, 68.1e0, 38.5e0, 22.8e0/
     data   y( 85),  y( 86),  y( 87),  y( 88),  y( 89),  y( 90)&
     &    /    10.2e0, 24.1e0, 82.9e0,132.0e0,130.9e0,118.1e0/
     data   y( 91),  y( 92),  y( 93),  y( 94),  y( 95),  y( 96)&
     &    /    89.9e0, 66.6e0, 60.0e0, 46.9e0, 41.0e0, 21.3e0/
     data   y( 97),  y( 98),  y( 99),  y(100),  y(101),  y(102)&
     &    /    16.0e0,  6.4e0,  4.1e0,  6.8e0, 14.5e0, 34.0e0/
     data   y(103),  y(104),  y(105),  y(106),  y(107),  y(108)&
     &    /    45.0e0, 43.1e0, 47.5e0, 42.2e0, 28.1e0, 10.1e0/
     data   y(109),  y(110),  y(111),  y(112),  y(113),  y(114)&
     &    /     8.1e0,  2.5e0,  0.0e0,  1.4e0,  5.0e0, 12.2e0/
     data   y(115),  y(116),  y(117),  y(118),  y(119),  y(120)&
     &    /    13.9e0, 35.4e0, 45.8e0, 41.1e0, 30.1e0, 23.9e0/
     data   y(121),  y(122),  y(123),  y(124),  y(125),  y(126)&
     &    /    15.6e0,  6.6e0,  4.0e0,  1.8e0,  8.5e0, 16.6e0/
     data   y(127),  y(128),  y(129),  y(130),  y(131),  y(132)&
     &    /    36.3e0, 49.6e0, 64.2e0, 67.0e0, 70.9e0, 47.8e0/
     data   y(133),  y(134),  y(135),  y(136),  y(137),  y(138)&
     &    /    27.5e0,  8.5e0, 13.2e0, 56.9e0,121.5e0,138.3e0/
     data   y(139),  y(140),  y(141),  y(142),  y(143),  y(144)&
     &    /   103.2e0, 85.7e0, 64.6e0, 36.7e0, 24.2e0, 10.7e0/
     data   y(145),  y(146),  y(147),  y(148),  y(149),  y(150)&
     &    /    15.0e0, 40.1e0, 61.5e0, 98.5e0,124.7e0, 96.3e0/
     data   y(151),  y(152),  y(153),  y(154),  y(155),  y(156)&
     &    /    66.6e0, 64.5e0, 54.1e0, 39.0e0, 20.6e0,  6.7e0/
     data   y(157),  y(158),  y(159),  y(160),  y(161),  y(162)&
     &    /     4.3e0, 22.7e0, 54.8e0, 93.8e0, 95.8e0, 77.2e0/
     data   y(163),  y(164),  y(165),  y(166),  y(167),  y(168)&
     &    /    59.1e0, 44.0e0, 47.0e0, 30.5e0, 16.3e0,  7.3e0/
     data   y(169),  y(170),  y(171),  y(172),  y(173),  y(174)&
     &    /    37.6e0, 74.0e0,139.0e0,111.2e0,101.6e0, 66.2e0/
     data   y(175),  y(176),  y(177),  y(178),  y(179),  y(180)&
     &    /    44.7e0, 17.0e0, 11.3e0, 12.4e0,  3.4e0,  6.0e0/
     data   y(181),  y(182),  y(183),  y(184),  y(185),  y(186)&
     &    /    32.3e0, 54.3e0, 59.7e0, 63.7e0, 63.5e0, 52.2e0/
     data   y(187),  y(188),  y(189),  y(190),  y(191),  y(192)&
     &    /    25.4e0, 13.1e0,  6.8e0,  6.3e0,  7.1e0, 35.6e0/
     data   y(193),  y(194),  y(195),  y(196),  y(197),  y(198)&
     &    /    73.0e0, 85.1e0, 78.0e0, 64.0e0, 41.8e0, 26.2e0/
     data   y(199),  y(200),  y(201),  y(202),  y(203),  y(204)&
     &    /    26.7e0, 12.1e0,  9.5e0,  2.7e0,  5.0e0, 24.4e0/
     data   y(205),  y(206),  y(207),  y(208),  y(209),  y(210)&
     &    /    42.0e0, 63.5e0, 53.8e0, 62.0e0, 48.5e0, 43.9e0/
     data   y(211),  y(212),  y(213),  y(214),  y(215),  y(216)&
     &    /    18.6e0,  5.7e0,  3.6e0,  1.4e0,  9.6e0, 47.4e0/
     data   y(217),  y(218),  y(219),  y(220),  y(221),  y(222)&
     &    /    57.1e0,103.9e0, 80.6e0, 63.6e0, 37.6e0, 26.1e0/
     data   y(223),  y(224),  y(225),  y(226),  y(227),  y(228)&
     &    /    14.2e0,  5.8e0, 16.7e0, 44.3e0, 63.9e0, 69.0e0/
     data   y(229),  y(230),  y(231),  y(232),  y(233),  y(234)&
     &    /    77.8e0, 64.9e0, 35.7e0, 21.2e0, 11.1e0,  5.7e0/
     data   y(235),  y(236),  y(237),  y(238),  y(239),  y(240)&
     &    /     8.7e0, 36.1e0, 79.7e0,114.4e0,109.6e0, 88.8e0/
     data   y(241),  y(242),  y(243),  y(244),  y(245),  y(246)&
     &    /    67.8e0, 47.5e0, 30.6e0, 16.3e0,  9.6e0, 33.2e0/
     data   y(247),  y(248),  y(249),  y(250),  y(251),  y(252)&
     &    /    92.6e0,151.6e0,136.3e0,134.7e0, 83.9e0, 69.4e0/
     data   y(253),  y(254),  y(255),  y(256),  y(257),  y(258)&
     &    /    31.5e0, 13.9e0,  4.4e0, 38.0e0,141.7e0,190.2e0/
     data   y(259),  y(260),  y(261)&
     &    /   184.8e0,159.0e0,112.3e0/
!
!     DEFINE CONSTANTS
!
      call iprint(iprt)
      n = 261
      fd = 1.0/11.0
      fc = 1.0/22.0
      k = 41
!
!     WRITE HEADER
!
      write(iprt, 1000)
!
!     RUN SIMPLE TEST OF DIF
!
      write(iprt, 1100)
      call demod (y, n, fd, fc, k, ldstak)
      write (iprt,2000) ierr
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format ('1*CH11')
 1100 format (' SIMPLE TEST OF DEMOD')
 2000 format (/' THE VALUE OF IERR IS ', i4)
      end
!DEMDRV
     subroutine demdrv (y, n, fd, fc, k, hlp, ampl, phase, iphase,&
     &   ndem, nprt, nmsub)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE DRIVER ROUTINE TO DEMODULATE SERIES
!     Y AT FREQUENCY FD, TO APPLY A LOW PASS FILTER WITH CUTOFF
!     FREQUENCY FC, AND TO EXTRACT THE AMPLITUDE AND PHASE COMPONENTS
!     OF THE RESULTING FILTERED SERIES .
!
!     WRITTEN BY  -  PETER BLOOMFIELD
!                    FOURIER ANALYSIS OF TIME SERIES- AN
!                       INTRODUCTION
!                    JOHN WILEY AND SONS, NEW YORK, 1976
!                    PAGE 147
!     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
!                                STATISTICAL ENGINEERING DIVISION
!                                NATIONAL BUREAU OF STANDARDS
!                                BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fc,fd
     integer&
     &   iphase,k,n,ndem,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ampl(n),hlp(k),phase(iphase,2),y(n)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL DEMODU,DEMORD,DEMOUT,FLTSL,LPFLT,POLAR
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AMPL(N)
!        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
!     REAL FC
!        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
!     REAL FD
!        THE DEMODULATION FREQUENCY.
!     REAL HLP(K)
!        THE ARRAY IN WHICH THE LOW PASS FILTER COEFFICIENTS ARE
!        STORED.
!     INTEGER K
!        THE USER SUPPLIED NUMBER OF TERMS TO BE USED FOR THE LOW
!        PASS FILTER.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDEM
!        THE NUMBER OF VALUES IN THE DEMODULATED SERIES, I.E., IN
!        THE AMPLITUDE AND PHASE ARRAYS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF NPRT
!        IS ZERO, NO OUTPUT IS GIVEN, OTHERWISE OUTPUT IS PROVIDED.
!     REAL PHASE(IPHASE,2)
!        THE ARRAY CONTAINING THE PRIMARY AND SECONDARY PHASE ESTIMATES.
!     REAL Y(N)
!        THE INPUT ARRAY CONTAINING THE OBSERVED SERIES.
!
!
      call demodu (y, n, fd, ampl, phase)
      call lpflt (fc, k, hlp)
      call fltsl (ampl, n, k, hlp, ampl, ndem)
      call fltsl (phase, n, k, hlp, phase, ndem)
!
      call polar (ampl, phase, ndem)
!
      if (nprt .eq. 0) return
!
      call demord (phase, phase(1,2), ndem, n)
      call demout (fd, fc, k, ampl, phase, iphase, ndem, nmsub)
!
      return
!
      end
!DIFC
     subroutine difc (y, n, nfac, nd, iod, iar, phi, lphi, yf, nyf,&
     &   ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE EXPANDS THE DIFFERENCE FILTER SPECIFIED BY NFAC,
!     IOD AND ND INTO PHI AND PERFORMS THE DIFFERENCE FILTERING
!     OPERATION DEFINED BY PHI, RETURNING THE FILTERED SERIES
!     IN YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iar,ldstak,lphi,n,nfac,nyf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   phi(*),y(*),yf(*)
     integer&
     &   iod(*),nd(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   i,iprt,ldsmin,nall0,work
     logical&
     &   err01,err02,err03,err04,head
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     character&
     &   llds(8)*1,llphi(8)*1,ln(8)*1,nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DCOEF,EISGE,ERDF,FLTAR,IPRINT,LDSCMP,STKCLR,STKSET
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03, ERR04
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE NUMBER OF FILTER COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IOD(NFAC)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LLDS(8), LLPHI(8), LN(8)
!        THE ARRAYS CONTAINING THE NAMES OF VARIOUS VARIABLES
!     INTEGER LPHI
!        THE LENGTH OF THE ARRAY PHI.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING WORK AREA ALLOCATIONS.
!     INTEGER ND(NFAC)
!        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE
!        FACTORS ARE TO BE APPLIED.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     REAL PHI(LPHI)
!        THE VECTOR CONTAINING THE FILTER COEFFICIENTS.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER WORK
!        THE STARTING LOCATION FOR THE WORK VECTOR NECESSARY TO
!        EXPAND THE DIFFERENCE FILTER.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'D',       'I',       'F',       'C',       ' ',       ' '/
     data&
    &  llds(1), llds(2), llds(3), llds(4), llds(5), llds(6),&
    &  llds(7), llds(8)&
     & /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
     data&
    &  llphi(1), llphi(2), llphi(3), llphi(4), llphi(5), llphi(6),&
    &  llphi(7), llphi(8)&
     & /  'L',   'P',   'H',   'I',   ' ',   ' ',   ' ',   ' '/
     data&
    &  ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
      err01 = .false.
      err02 = .false.
      err03 = .false.
      err04 = .false.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub,ln,n,3,1,head,err01,ln)
!
      iar = 0
!
      if (nfac.ge.1) then
!
         do 10 i = 1, nfac
            iar = iar + nd(i)*iod(i)
   10    continue
!
         call erdf(nmsub,nfac,nd,iod,n,head,err02)
!
         if (.not.err02) then
            call eisge(nmsub,llphi,lphi,iar,9,head,err03,llphi)
            call ldscmp(1,0,0,0,0,0,'S',2*iar,ldsmin)
            call eisge(nmsub,llds,ldstak,ldsmin,9,head,err04,llds)
         end if
      end if
!
!
      if (err01 .or. err02 .or. err03 .or. err04) go to 20
      go to 30
!
   20 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   30 continue
!
      nyf = n
      do 50 i = 1, nyf
         yf(i) = y(i)
   50 continue
!
      if (nfac .le. 0) return
!
      call stkset (ldstak, 4)
      nall0 = stkst(1)
!
      do 60 i = 1, lphi
         phi(i) = 0.0e0
   60 continue
!
      work = stkget(2*iar, 3)
!
      if (ierr .eq. 1) go to 20
!
      call dcoef (nfac,nd,iod,iar,phi,lphi,rstak(work))
!
      call stkclr(nall0)
!
      if (ierr .eq. 1) go to 20
!
      call fltar (yf,nyf,iar,phi,yf,nyf)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL DIFC (Y, N,'/&
    &   '      +           NFAC, ND, IOD, IAR, PHI, LPHI,'/&
     &   '      +           YF, NYF, LDSTAK)')
      end
!NLSPK
      subroutine nlspk(par, mask, npar, ppar, nppar)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PACKS A VECTOR PAR INTO A VECTOR PPAR, BY
!     OMITTING FROM THE PACKED VERSION THOSE ELEMENTS OF THE
!     UNPACKED VERSION CORRESPONDING TO ELEMENTS OF MASK WHICH
!     HAVE THE VALUE 1.  OTHER ELEMENTS OF MASK SHOULD BE ZERO.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   npar,nppar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),ppar(nppar)
     integer&
     &   mask(npar)
!
!  LOCAL SCALARS
     integer&
     &   i,ippar
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL PAR(NPAR)
!        INPUT PARAMETER.  THE UNPACKED VECTOR.
!     INTEGER I
!        LOOP PARAMETER.
!     INTEGER IPPAR
!        CURRENT ELEMENT OF PPAR.  RANGES FROM 0 (ON INITIALIZATION)
!        TO NPPAR.
!     INTEGER MASK(NPAR)
!        INPUT PARAMETER.  THE MASK GOVERNING THE PACKING OF PAR.
!        ELEMENTS OF MASK ARE 1 IF THE CORRESPONDING ELEMENT OF PAR
!        IS TO BE ELIMINATED IN PPAR, 0 IF IT IS TO BE INCLUDED.
!     INTEGER NPAR
!        INPUT PARAMETER.  THE LENGTH OF PAR.
!     INTEGER NPPAR
!        INPUT PARAMETER.  THE LENGTH OF PPAR.
!     REAL PPAR(NPPAR)
!        OUTPUT PARAMETER.  THE PACKED VERSION OF PAR.  SEE INITIAL
!        DESCRIPTION.
!
!     COMMENCE BODY OF ROUTINE
!
      ippar = 0
      do 10 i=1,npar
         if (mask(i).ne.0) go to 10
         ippar = ippar + 1
         ppar(ippar) = par(i)
   10 continue
      return
      end
!ACFF
      subroutine acff (yfft, n, lyfft, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
!     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
!     USING AN FFT (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,lyfft,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   yfft(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   chia,chiap,ospvar,ymean,ysd
     integer&
    &   iar,ifp,iprt,lacov,lagmax,laic,ldsmin,nall0,nfac,nfft,&
     &   sdrho,work
     logical&
     &   differ,isfft
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   acov(101),aic(101),ftest(2,100),phi(100),prho(100),rho(100),&
     &   rstak(12)
     integer&
     &   iod(1),nd(1),ndum(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACFER,ACFMNF,ACFOUT,FFTLEN,IPRINT,LDSCMP,SETLAG,STKCLR,
!     +   STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (acov(2),rho(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(101)
!        THE AUTOCOVARIANCE VECTOR.
!     REAL AIC(101)
!       THE ARRAY CONTAINING AKAIKES CRITERIA FOR EACH ORDER.
!     REAL CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     LOGICAL DIFFER
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FTEST(2, 100)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0 ERRORS WERE DETECTED.
!     INTEGER IFP
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE FLOATING
!        POINT VARIABLES ARE SINGLE (IFP=3) OR DOUBLE (IFP=4) PRECISION.
!     INTEGER IOD(1)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     INTEGER ND(1)
!        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
!     INTEGER NDUM(1)
!        A DUMMY ARRAY.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     REAL OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE SELECTED ORDER (IAR).
!     REAL PHI(100)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     REAL PRHO(100)
!        THE ARRAY CONTAINING THE PARITAL ACF ESTIMATES.
!     REAL RHO(100)
!        THE ARRAY CONTAINING THE ACF ESTIMATES.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SDRHO
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE STANDARD ERRORS OF THE ACF ESTIMATES.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR WORK.
!     REAL YFFT(LYFFT)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     REAL YSD
!        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'A',       'C',       'F',       'F',       ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      lacov = 101
      laic = 101
      differ = .false.
      nfac = 1
      nd(1) = 0
      iod(1) = 0
      isfft = .true.
!
      if (n.ge.3) then
!
!     SET NUMBER OF ACF TO BE COMPUTED
!     AND LENGTH OF EXTENDED SERIES
!
         call setlag(n, lagmax)
         call fftlen(n+lagmax, 4, nfft)
      end if
!
      call ldscmp(1, 0, 0, 0, 0, 0, 'S', nfft, ldsmin)
!
!     CALL ERROR CHECKING ROUTINES
!
     call acfer(nmsub, n, lagmax, lacov, ldstak, ldsmin,&
     &  differ, nfac, nd, iod, isfft, lyfft, nfft)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      if (ierr.eq.0) then
!
!       SET UP THE WORK AREA.
!
        call stkset (ldstak, 4)
        nall0 = stkst(1)
!
        ifp = 3
!
        work = stkget(nfft, ifp)
        sdrho = work
!
        if (ierr.eq.0) then
!
!         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
         call acfmnf (yfft, n, nfft, lagmax, rho, rstak(sdrho), ymean,&
    &       prho, aic, ftest, phi, iar, ospvar, acov, lacov, laic,&
     &       chia, chiap, lyfft, rstak(work), nfft, 1)
!
          ysd = sqrt (acov(1) * n / (n - 1))
!
!         CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
         call acfout(ymean, ysd, n, n, lagmax, rho, rstak(sdrho), prho,&
    &       ndum, aic, laic, ftest, iar, phi, ospvar, chia, chiap,&
    &       lagmax, .false., 0.0e0, .false., .false., 0, ndum, ndum,&
     &       0)
        end if
!
        call stkclr(nall0)
      end if
!
      if (ierr.ne.0) then
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        ierr = 1
        call iprint (iprt)
        write (iprt, 1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format(/42h the correct form of the call statement is//&
     &  '       CALL ACFF (YFFT, N, LYFFT, LDSTAK)')
      end
!ERSII
     subroutine ersii(nmsub, nmvar, val, valmn, valmx, msgtyp, head,&
     &   error, nmmin, nmmax)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THE ROUTINE CHECKS WHETHER THE VALUE   VAL   IS WITHIN THE
!     THE RANGE VALMN (INCLUSIVE) TO VALMX (INCLUSIVE), AND PRINTS A
!     DIAGNOSTIC IF IT IS NOT.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   val,valmn,valmx
     integer&
     &   msgtyp
     logical&
     &   error,head
!
!  ARRAY ARGUMENTS
     character&
     &   nmmax(8)*1,nmmin(8)*1,nmsub(6)*1,nmvar(8)*1
!
!  LOCAL SCALARS
     integer&
     &   i,iprt
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
!        PRINTED, WHERE IF ERROR IS .TRUE. AND
!        MSGTYP = 1 THE INPUT VALUE WAS OUTSIDE THE RANGE DETERMINED
!                   FROM OTHER INPUT ARGUMENTS
!        MSGTYP = 2 THE INPUT VALUE WAS OUTSIDE THE RANGE IMPOSED BY
!                   STARPAC
!     CHARACTER*1 NMMAX(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MAXIMUM.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE ARGUMENTS NAME.
!     REAL VAL
!        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
!     REAL VALMN, VALMX
!        THE MINIMUM AND MAXIMUM OF THE RANGE WITHIN WHICH THE
!        ARGUMENT MUST LIE.
!
      error = .false.
!
     if (((valmn.le.val) .and. (val.le.valmx)) .or.&
     &   (valmx.lt.valmn)) return
!
      error = .true.
      call iprint(iprt)
      call ehdr(nmsub, head)
!
      write (iprt, 1000) (nmvar(i),i=1,6), val
!
!     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE DETERMINED FROM
!     OTHER INPUT ARGUMENTS.
!
     if (msgtyp .eq. 1)&
    &   write (iprt, 1010) (nmvar(i),i=1,6), (nmmin(i),i=1,8),&
     &      (nmmax(i),i=1,8)
!
!     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE IMPOSED BY STARPAC
!
     if (msgtyp .eq. 2)&
     &   write (iprt, 1020) (nmvar(i),i=1,6), valmn, valmx
      return
!
!     FORMAT STATEMENTS
!
 1000 format (/20h the input value of , 6a1, 4h is , g15.8, '.')
1010 format(&
    &   27h the value of the argument , 6a1,&
    &   16h must be between, 1x, 8a1,&
     &   5h and , 8a1, 12h, inclusive.)
1020 format(&
    &   27h the value of the argument , 6a1,&
    &   16h must be between, 1x, g15.8,&
     &   5h and , g15.8, 12h, inclusive.)
!
      end
!STAT1
     subroutine stat1(y, n, ymed, ymin, ymax, ymidrg, yrange, ncells,&
     &   ylb, yub, ydistr)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS COMPUTES STATISTICS FOR A VECTOR Y THAT REQUIRE OR CAN
!     MAKE USE OF SORTEDNESS IN THE Y VECTOR.
!
!     THIS SUBROUTINE IS BASED ON A MODIFICATION OF THE STATIS
!     CODE USED IN OMNITAB, VERSION 5 (6/16/72), WRITTED BY
!     SALLY PEAVY.  THE ORIGINAL ADAPTATION TO STARPAC WAS MADE
!     BY JANET DONALDSON.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ylb,ymax,ymed,ymidrg,ymin,yrange,yub
     integer&
     &   n,ncells
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(n),ydistr(ncells)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   dely,yt
     integer&
     &   i,ic,ic1,l,m,m1
!
!  INTRINSIC FUNCTIONS
      intrinsic mod
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELY
!        THE WIDTH OF AN INTERVAL ONE TENTH THE RANGE OF THE
!        DATA IN Y.
!     INTEGER I
!        A LOOP INDEX.
!     INTEGER IC
!        PREVIOUS SIGN IN RUNS CALCULATION.
!     INTEGER IC1
!        COUNT IN FREQUENCY DISTRIBUTION CALCULATIONS.
!     INTEGER L
!        A LOOP INDEX.
!     INTEGER M
!        A LOOP INDEX.
!     INTEGER M1
!        WHEN N IS EVEN, M1 IS M + 1, OTHERWISE IT IS M.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y AND WT.
!     INTEGER NCELLS
!        THE NUMBER OF CELLS IN THE FREQUENCY DISTRIBUTION.
!     REAL Y(N)
!        INPUT PARAMETER.  A SET OF N DATA POINTS, SORTED
!        INTO ASCENDING ORDER.
!     REAL YDISTR(NCELLS)
!        OUTPUT PARAMETER.  THE NUMBERS OF Y VALUES WITH
!        POSITIVE WEIGHTS IN EACH OF NCELLS EQUAL LENGTH INTERVALS
!        THAT DIVIDE THE RANGE OF Y VALUES.
!     REAL YLB
!        THE LOWER BOUND FOR THE FREQUENCY DISTRIBUTION.
!        IF YLB = YUB, THE MINIMUM OBSERVATION WILL BE USED.
!     REAL YMAX
!        OUTPUT PARAMETER.  THE MAXIMUM OF THE OBSERVATIONS Y HAVING
!        POSITIVE WEIGHT.
!     REAL YMED
!        OUTPUT PARAMETER.  THE MEDIAN OF THE OBSERVATIONS Y.
!     REAL YMIDRG
!        OUTPUT PARAMETER.  THE MIDRANGE OF THE OBSERVATIONS Y.
!     REAL YMIN
!        OUTPUT PARAMETER.  THE MINIMUM OF THE OBSERVATIONS Y HAVING
!        POSITIVE WEIGHT.
!     REAL YRANGE
!        THE RANGE OF THE OBSERVATIONS Y.
!     REAL YT
!        THE MAXIMUM VALUE IN EACH INTERVAL IN THE FREQUENCY
!        DISTRIBUTIONS CALCULATIONS.
!     REAL YUB
!        THE UPPER BOUND FOR THE FREQUENCY DISTRIBUTION.
!        IF YLB = YUB, THE MAXIMUM OBSERVATION WILL BE USED.
!
!     CALCULATE THE MEDIAN, MIDRANGE, RANGE, AND EXTREMA.
!
      m = (n+1)/2
      m1 = m
      if (mod(n,2).eq.0) m1 = m1 + 1
      ymed = (y(m)+y(m1))/2.0e0
      ymidrg = (y(1)+y(n))/2.0e0
      yrange = y(n) - y(1)
      ymin = y(1)
      ymax = y(n)
!
!     COMPUTE FREQUENCY DISTRIBUTION.
!
      if (ncells.le.0) return
      ic1 = 0
      if (ncells.eq.1) go to 40
!
      dely = yrange
      yt = ymin
      if (ylb.ge.yub) go to 5
         dely = yub - ylb
         yt = ylb
    5 continue
      dely = dely / ncells
      yt = yt + dely
      l = 0
      do 30 i=2,ncells
         ic = 0
   10    l = l + 1
         if (l.gt.n) go to 20
         if (y(l).gt.yt) go to 20
         ic = ic + 1
         ic1 = ic1 + 1
         go to 10
   20    ydistr(i-1) = ic
         l = l - 1
         yt = yt + dely
   30 continue
   40 ydistr(ncells) = n - ic1
      return
      end
!MDLTS1
      subroutine mdlts1 (par, npar, xm, n, m, ixm, rests)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR ESTIMATING BOX-JENKINS
!     ARIMA MODELS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 4, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),rests(nrests),xm(ixm,m)
!
!  SCALARS IN COMMON
     integer&
    &   iflag,mbo,mbol,mspect,nfact,nparar,npardf,nparma,nrests,&
     &   parar,pardf,parma,t,temp
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   pmu
     integer&
     &   i,i1
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL MDLTS2
!
!  COMMON BLOCKS
      common /cstak/dstak
     common /mdltsc/mspect,nfact,pardf,npardf,parar,nparar,parma,&
     &   nparma,mbo,mbol,t,temp,nrests,iflag
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IFLAG
!        AN INDICATOR VARIABLE DESIGNATING WHETHER THE BACK FORECASTS
!        WERE ESSENTIALLY ZERO (IFLAG=0) OR NOT (IFLAG=1).
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IXM
!        THE FIRST DIMENSION OF MATRIX XM.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBOL
!        THE MAXIMUM BACK ORDER ON THE LEFT
!     INTEGER MSPECT
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFACT
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARAR
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE AUTOREGRESSIVE PARAMETERS
!     INTEGER PARDF
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
!     INTEGER PARMA
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE MOVING AVERAGE PARAMETERS
!     REAL PMU
!        THE VALUE OF MU, I.E., THE TREND OR MEAN.
!     REAL RESTS(NRESTS)
!        THE RESIDUALS FROM THE ARIMA MODEL.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER T
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR.
!     INTEGER TEMP
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR
!     REAL XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!
!
!     COMPUTE RESIDUALS
!
     call mdlts2 (par, rests, xm(1,1), npar, n, nfact, istak(mspect),&
    &  pmu, rstak(pardf), npardf, rstak(t), rstak(temp), rstak(parar),&
     &  rstak(parma), mbo, n-nrests+1, n, iflag)
!
!     COMPUTE PREDICTED VALUES
!
      i1=nrests-n
      do 20 i = 1,n
        i1=i1+1
        rests(i) = xm(i1,1)-rests(i1)
   20 continue
!
      return
      end
!ACFD
      subroutine acfd (y, n, lagmax, nfac, nd, iod, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
!     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
!     WITH DIFFERENCING.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lagmax,ldstak,n,nfac
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*)
     integer&
     &   iod(*),nd(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   chia,chiap,ospvar,ymean,ysd
     integer&
    &   acov,aic,ftest,i,iar,ifp,iprt,lacov,ldsmin,lyfft,nall0,&
     &   nfft,ntimes,nyd,nyf,phi,prho,sdrho,work,yf
     logical&
     &   differ,isfft,newpg
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   ndum(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACFER,ACFMN,ACFOUT,DIFSER,IPRINT,LDSCMP,STKCLR,
!     +   STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic min,sqrt
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER ACOV
!        THE STARTING LOCATION IN DSTAK FOR
!        THE AUTOCOVARIANCE VECTOR.
!     INTEGER AIC
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE AKAIKES CRITERION FOR EACH ORDER.
!     REAL(KIND=WP) :: CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     LOGICAL DIFFER
!        THE VARIABLE USED TO DESIGNATE WHETHER OR NOT THE SERIES
!        BEING ANALYZED WAS DIFFERENCED OR NOT.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER FTEST
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE PARTIAL F RATIO AND PROBABILITIES
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!     INTEGER IFP
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE FLOATING
!        POINT VARIABLES ARE SINGLE (IFP=3) OR DOUBLE (IFP=4) PRECISION.
!     INTEGER IOD(NFAC)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        A DUMMY VARIABLE
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     INTEGER ND(NFAC)
!        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCE
!        FACTORS ARE TO BE APPLIED.
!     INTEGER NDUM(1)
!        A DUMMY DIMENSIONED VARIABLE.
!     LOGICAL NEWPG
!        THE VARIABLE USED TO DESIGNATE WHETHER OR NOT THE OUTPUT
!        IS TO BEGIN ON A NEW PAGE.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NTIMES
!        THE NUMBER OF TIMES THE FIRST DIFFERENCE FACTOR HAS BEEN
!        APPLIED.
!     INTEGER NYD, NYF
!        THE NUMBER OF OBSERVATIONS AFTER THE DIFFERENCE FILTER IS
!        APPLIED.
!     REAL(KIND=WP) :: OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
!     INTEGER PHI
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     INTEGER PRHO
!        THE STARTING LOCATION IN THE WORK AREA FOR PRHO.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SDRHO
!        THE STARTING LOCATION IN THE WORK AREA FOR SDRHO.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR WORK.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     INTEGER YF
!        THE STARTING LOCATION IN DSTAK FOR
!        THE VECTOR CONTAINING THE DIFFERENCE FILTERED SERIES.
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     REAL YSD
!        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'A',       'C',       'F',       'D',       ' ',       ' '/
!
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      lacov = lagmax+1
      differ = .true.
      isfft = .false.
      lyfft = 0
      nfft = 0
!
      call ldscmp(7, 0, 0, 0, 0, 0, 'S', 7*lagmax+2+n, ldsmin)
!
!     CALL ERROR CHECKING ROUTINES
!
     call acfer(nmsub, n, lagmax, lacov, ldstak, ldsmin,&
     &  differ, nfac, nd, iod, isfft, lyfft, nfft)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      if (ierr.eq.0) then
!
!       SET UP THE WORK AREA.
!
        call stkset(ldstak, 4)
        nall0 = stkst(1)
!
        ifp = 3
!
        acov = stkget(lagmax+1, ifp)
        prho = stkget(lagmax, ifp)
        aic = stkget(lagmax+1, ifp)
        ftest = stkget(2*lagmax, ifp)
        phi = stkget(lagmax, ifp)
        work = stkget(lagmax, ifp)
        yf = stkget(n, ifp)
        sdrho = work
!
        if (ierr.eq.0) then
!
          newpg = .false.
          ntimes = 0
!
!         CHECK WHETHER THERE IS MORE THAN ONE DIFFERENCE FACTOR.
!
          if (nfac.le.1) then
            call scopy(n, y, 1, rstak(yf), 1)
          else
!
!           CREATE NEW DATA BY APPLYING DIFFERENCE FACTORS BEYOND THE
!           FIRST.
!
            call difser(y, n, nfac-1, nd(2), iod(2), rstak(yf), nyf)
          end if
          nyd = n
!
!         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
         call acfmn (rstak(yf), nyd, min(lagmax, nyd-1),&
    &       rstak(acov+1), rstak(sdrho), ymean, rstak(prho),&
    &       rstak(aic), rstak(ftest), rstak(phi), iar, ospvar,&
    &       rstak(acov), lagmax+1, lagmax+1, chia, chiap, rstak(work),&
     &       1)
!
          ysd = sqrt(rstak(acov) * n / (n-1))
!
!         CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
         call acfout (ymean, ysd, nyf, nyf, min(lagmax, nyd-1),&
    &       rstak(acov+1), rstak(sdrho), rstak(prho), ndum, rstak(aic),&
    &       lagmax+1, rstak(ftest), iar, rstak(phi), ospvar, chia,&
    &       chiap, lagmax, .false., 0.0e0, differ, newpg, nfac, nd,&
     &       iod, ntimes)
!
          newpg = .true.
!
!         COMPUTE CORRELATION ANALYSIS FOR FIRST DIFFERENCE FACTOR
!         APPLIED 1 TO ND(1) TIMES
!
          if ((nfac.ge.1) .and. (nd(1).ge.1)) then
            do 50 i = 1, nd(1)
!
              call difser(rstak(yf), nyd, nfac-1, nd(2), iod(2),&
     &           rstak(yf), nyf)
!
!              CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
            call acfmn (rstak(yf), nyd, min(lagmax, nyd-1),&
    &          rstak(acov+1), rstak(sdrho), ymean, rstak(prho),&
    &          rstak(aic), rstak(ftest), rstak(phi), iar, ospvar,&
    &          rstak(acov), lagmax+1, lagmax+1, chia, chiap,&
     &          rstak(work), 1)
!
               ysd = sqrt(rstak(acov) * n / (n-1))
!
!           CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
            call acfout (ymean, ysd, nyf, nyf, min(lagmax, nyd-1),&
    &          rstak(acov+1), rstak(sdrho), rstak(prho), ndum,&
    &          rstak(aic), lagmax+1, rstak(ftest), iar, rstak(phi),&
    &          ospvar, chia, chiap, lagmax, .false., 0.0e0, differ,&
     &          newpg, nfac, nd, iod, i)
!
   50       continue
          end if
        end if
!
        call stkclr(nall0)
      end if
!
      if (ierr.ne.0) then
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        ierr = 1
        call iprint (iprt)
        write (iprt, 1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format(/42h the correct form of the call statement is//&
     &  '       CALL ACFD (Y, N, LAGMAX, NFAC, ND, IOD, LDSTAK)')
      end
!DCKCNT
     subroutine dckcnt(xm, n, m, ixm, mdl, drv, par, npar, neta, ntau,&
    &   scale, lscale, nrow, nprt, hdr, page, wide, isubhd, hlfrpt,&
     &   prtfxd, ifixed, lifixd)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CONTROLS THE DERIVATIVE CHECKING PROCESS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   isubhd,ixm,lifixd,lscale,m,n,neta,npar,nprt,nrow,ntau
     logical&
     &   hlfrpt,page,prtfxd,wide
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),scale(lscale),xm(ixm,m)
     integer&
     &   ifixed(lifixd)
!
!  SUBROUTINE ARGUMENTS
       external drv,hdr,mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   d,eta,fplrs,pv,scl,tau
     integer&
    &   dtemp,ifixd,ifp,indxd,indxpv,j,lmsg,msg,nall0,ndd,ndgt1,&
     &   ndgt2,nrowu,partmp,pvtemp
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
     integer&
     &   stkst
!       EXTERNAL R1MACH,STKST
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL CPYVII,DCKMN,DCKOUT,ETAMDL,SETIV,SETROW,STKCLR
!
!  INTRINSIC FUNCTIONS
      intrinsic log10
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL D
!        THE SCALAR IN WHICH ROW   NROWU   OF THE DERIVATIVE
!        MATRIX WITH RESPECT TO THE JTH UNKNOWN PARAMETER
!        IS STORED.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER DTEMP
!        THE STARTING LOCATION IN THE WORK AREA IN WHICH
!        THE ARRAY IN WHICH THE ANALYTIC DERIVATIVES WITH
!        RESPECT TO EACH UNKNOWN PARAMETER ARE STORED.
!     REAL ETA
!        THE RELATIVE NOISE IN THE MODEL.
!     REAL FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     EXTERNAL HDR
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFIXD
!        THE STARTING LOCATION IN ISTAK OF
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INDXD, INDXPV
!        THE INDEX IN THE WORK AREA OF
!        THE LOCATION OF THE VALUE OF THE
!        DERIVATIVE WITH RESPECT TO THE JTH PARAMETER AT ROW   NROWU
!        AND OF THE LOCATION OF THE PREDICTED VALUE FROM THE MODEL FOR R
!        ROW   NROWU   .
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED BY
!        ROUTINE HDR.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER LIFIXD
!        THE LENGTH OF THE VECTOR IFIXED.
!     INTEGER LMSG
!        THE LENGTH OF THE VECTOR MSG.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER MSG
!        THE STARTING LOCATION IN THE WORK AREA OF
!        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NALL0
!        THE NUMBER OF STACK ALLOCATIONS ON ENTRY.
!     INTEGER NDD
!        THE NUMBER OF DECIMAL DIGITS CARRIED FOR A SINGLE
!        PRECISION REAL NUMBER.
!     INTEGER NDGT1
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL USED, EITHER
!        SET TO THE USER SUPPLIED VALUE OF NETA, OR COMPUTED
!        BY ETAMDL.
!     INTEGER NDGT2
!        THE ACTUAL NUMBER OF DIGITS OF AGREEMENT USED, EITHER
!        SET TO THE USER SUPPLIED VALUE OF NTAU, OR COMPUTED
!        FROM NDGT1.
!     INTEGER NETA
!        THE USER SUPPLIED NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NROW, NROWU
!        THE USER-SUPPLIED NUMBER OF THE ROW OF THE INDEPENDENT
!        VARIABLE ARRAY AT WHICH THE DERIVATIVE IS TO BE CHECKED,
!        AND THE NUMBER OF THE ROW ACTUALLY USED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     INTEGER PARTMP
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE MODIFIED MODEL PARAMETERS
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     REAL PV
!        THE SCALAR IN WHICH THE PREDICTED VALUE FROM THE MODEL FOR
!        ROW   NROW   IS STORED.
!     INTEGER PVTEMP
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     REAL SCL
!        THE ACTUAL TYPICAL SIZE USED.
!     REAL TAU
!        THE AGREEMENT TOLERANCE.
!     LOGICAL WIDE
!       THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      nall0 = stkst(1)
!
      fplrs = r1mach(4)
!
!     SELECT FIRST ROW OF INDEPENDENT VARIABLES WHICH CONTAINS NO ZEROS
!
      call setrow(nrow, xm, n, m, ixm, nrowu)
!
!     SUBDIVIDE WORK AREA
!
      ifp = 3
!
      lmsg = npar + 1
!
      ifixd = stkget(npar,2)
      msg = stkget(lmsg,2)
      dtemp = stkget(n*npar,ifp)
      partmp = stkget(npar,ifp)
      pvtemp = stkget(n,ifp)
!
      if (ierr.eq.1) return
!
!     SET UP IFIXD
!
      if (ifixed(1).lt.0) call setiv(istak(ifixd), npar, 0)
      if (ifixed(1).ge.0) call cpyvii(npar, ifixed, 1, istak(ifixd), 1)
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      ndd = -log10(fplrs)
!
      if ((neta.lt.2) .or. (neta.gt.ndd)) then
        call etamdl(mdl, par, npar, xm, n, m, ixm, eta, ndgt1,&
     &      rstak(partmp), rstak(pvtemp), nrowu)
      else
         eta = 10.0e0**(-neta)
         ndgt1 = neta
      end if
!
      if ((ntau.lt.1) .or. (ntau.gt.(ndgt1-1)/2)) then
         ndgt2 = (ndgt1+3)/4
      else
         ndgt2 = ntau
      end if
!
      tau = 10.0e0**(-ndgt2)
!
      indxpv = pvtemp + nrowu - 1
!
!     COMPUTE PREDICTED VALUE OF MODEL USING CURRENT PARAMETER
!     ESTIMATES, AND COMPUTE USER-SUPPLIED DERIVATIVE VALUES
!
      call mdl(par, npar, xm, n, m, ixm, rstak(pvtemp))
      pv = rstak(indxpv)
      call drv(par, npar, xm, n, m, ixm, rstak(dtemp))
!
      istak(msg) = 0
!
      do 30 j=1,npar
!
         if (scale(1).gt.0.0e0) then
            scl = scale(j)
         else
            scl = par(j)
         end if
         if (scl.eq.0.0e0) scl = 1.0e0
!
!     CALL ROUTINE TO CHECK USER SUPPLIED NUMERICAL DERIVATIVES
!     WITH RESPECT TO THE JTH PARAMETER.
!
         indxd = dtemp - 1 + n*(j-1) + nrowu
!
         d = rstak(indxd)
        call dckmn(j, d, par, scl, npar, eta, tau, mdl, xm, n, nrowu,&
     &      m, ixm, pv, rstak(pvtemp), istak(msg), lmsg)
!
   30 continue
!
      if (istak(msg).ge.1) ierr = istak(msg) + 1
!
!     PRINT RESULTS IF THEY ARE DESIRED
!
      hlfrpt = .false.
!
      if ((nprt.ne.0) .or. (ierr.ne.0)) then
         hlfrpt = .true.
        call dckout(xm,ixm,n,m,nrowu,ndgt1,ndgt2,npar,istak(msg),&
    &      lmsg,par,scale,lscale,hdr,page,wide,isubhd,prtfxd,&
     &      istak(ifixd))
      end if
!
      call stkclr(nall0)
!
      return
!
      end
!AOV1S
      subroutine aov1s(y, tag, n, ldstak, nprt, gstat, igstat, ng)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE -
!     1. CALLS OTHER ROUTINES TO CHECK THE INPUT PARAMETERS
!     2. SETS UP NEEDED STORAGE LOCATIONS AND
!     3. CALLS AOV1MN TO COMPUTE A COMPREHENSIVE SET OF RESULTS FOR A
!         ONEWAY ANALYSIS OF VARIANCE WITH OPTIONAL OUTPUT.
!
!     WRITTEN BY -
!       LINDA MITCHELL
!       STATISTICAL ENGINEERING DIVISION
!       NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!                       BASED ON EARLIER VERSION BY J. R. DONALDSON
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   igstat,ldstak,n,ng,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   gstat(*),tag(*),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
    &   b10,gpmax,gpmin,ifp,index,int,iprt,itemp,nall0,nztags,&
     &   ranks,srank
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AOV1ER,AOV1HD,AOV1MN,IPRINT,STKCLR
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER B10
!        STARTING LOCATION IN THE STACK AREA FOR B10
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER GPMAX
!        THE STARTING LOCATION IN THE STACK AREA OF MAXIMUM
!        OBSERVATION
!     INTEGER GPMIN
!        THE STARTING LOCATION IN THE STACK AREA OF THE MINUMUM
!        OBSERVATION
!     REAL GSTAT(IGSTAT,4)
!        THE GROUP STATISTICS.  COLUMNS CORRESPOND TO THE TAG
!        VALUE, SAMPLE SIZE, GROUP MEAN, AND GROUP STANDARD DEVIATION.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG INDICATING WHETHER THERE
!        ARE ANY ERRORS, IF = 0 THEN NO ERRORS
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IGSTAT
!        THE FIRST DIMENSION OF GSTAT.
!     INTEGER INDEX
!        THE STARTING LOCATION IN THE STACK ARRAY OF THE INDEX FOR
!        THE SORTED TAGS
!     INTEGER INT
!        FRAMEWORK CODE VALUE FOR INTEGER NUMBERS
!     INTEGER IPRT
!        THE OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ITEMP
!        STARTING LOCATION IN THE STACK FOR THE
!        TEMPORARY STORAGE ARRAY
!     INTEGER LDSTAK
!         SIZE OF THE STACK AREA ALLOCATED IN THE USERS MAIN PROGRAM
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS TO BE ANALYZED
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT THIS
!        ROUTINE WAS CALLED.
!     INTEGER NG
!        THE COMPUTED NUMBER OF GROUPS WITH
!        DIFFERENT POSITIVE TAG VALUES
!     CHARACTER*1 NMSUB(6)
!        SUBROUTINE NAME
!     INTEGER NPRT
!        THE VARIABLE CONTROLLING AUTOMATIC PRINTOUT
!        IF =0, PRINTOUT IS SUPRESSED
!        OTHERWISE PRINTOUT IS PROVIDED
!     INTEGER NZTAGS
!        THE NUMBER OF OBSERVATIONS WITH POSITIVE NON-ZERO WIEGHTS
!     INTEGER RANKS
!        THE STARTING LOCATION IN STACK AREA FOR THE RANKS OF Y
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SRANK
!        THE STARTING LOCATION IN STACK FOR THE SUM OF RANKS
!     REAL TAG(N)
!        THE VECTOR OF TAG VALUES
!     REAL Y(N)
!        THE VECTOR OF OBSERVATIONS
!
     data   nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6)&
     &     /      'A',      'O',      'V',      '1',      'S',      ' '/
!
!     SET UP FRAMEWORK VARIABLES FOR NUMBER TYPES
!
      int = 2
      ifp = 3
!
      call iprint(iprt)
!
!     CHECK FOR ERRORS IN PARAMETERS, INITIALIZE STACK, AND SET
!     NALL0.
!
     call aov1er(y, tag, n, igstat, nztags, ng, ldstak, nmsub, index,&
     &   0, nall0)
!
      if (ierr.eq.0) go to 20
!
!     PRINT CORRECT FORM OF CALL STATEMENT AND RETURN TO CALLER
!
      ierr = 1
      write (iprt,1000)
      return
!
!     PRINT HEADING IF DESIRED
!
   20 if (nprt.eq.0) go to 30
      call aov1hd(iprt)
!
!     SET UP ADDITIONAL WORK VECTORS FOR AOV1MN AS CALLED FROM AOV1S
!
   30 srank = stkget(ng,ifp)
      gpmin = stkget(ng,ifp)
      gpmax = stkget(ng,ifp)
      b10 = stkget(ng,ifp)
      ranks = stkget(nztags,ifp)
      itemp = stkget(nztags,int)
!
     call aov1mn(y, tag, n,&
    &            gstat(1), gstat(igstat+1),&
    &            gstat(2*igstat+1), gstat(3*igstat+1),&
    &            nprt, istak(index), rstak(srank), rstak(gpmin),&
    &            rstak(gpmax), rstak(b10), rstak(ranks),&
     &            istak(itemp), ng, nztags)
!
!     RELEASE THE STACK AREA
!
      call stkclr(nall0)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format(/42h the correct form of the call statement is//&
     & '       CALL AOV1S (Y, TAG, N, LDSTAK, NPRT, GSTAT, IGSTAT, NG)')
      end
!CCFF
      subroutine ccff (yfft1, yfft2, n, lyfft, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
!     CORRELATIONS OF TWO TIME SERIES USING THE SINGLETON FFT
!     (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,lyfft,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   yfft1(*),yfft2(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   y1mean,y1sd,y2mean,y2sd
     integer&
    &   iccov,ifp,inlppc,iprt,iym,iymfft,jccov,jnlppc,lagmax,&
     &   ldsmin,m,nall0,nfft,work
     logical&
     &   isfft,islong
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ccov(101,2,2),rhoc(201),rstak(12),sdrhoc(201),stak(12)
     integer&
     &   ndum(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACVFF,CCFER,CCFMNF,CCFOUT,FFTLEN,IPRINT,LDSCMP,SETLAG,
!     +   STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),stak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCOV(101, 2, 2)
!        THE CCVF MATRIX.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ICCOV
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INLPPC
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
!        IN THE USERS PROGRAM.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     LOGICAL ISLONG
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
!     INTEGER IYMFFT
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JCCOV
!        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
!        IN THE USERS PROGRAM.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE NUMBER OF LOCATIONS IN THE ARRAY YFFT1 AND YFFT2.
!     INTEGER M
!        THE NUMBER OF SERIES BEING COMPARED, IE THE
!        NUMBER OF COLUMNS OF DATA IN YM.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     INTEGER NDUM(1)
!        A DUMMY ARRAY.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     REAL RHOC(201)
!        THE ARRAY CONTAINING THE CCF.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL SDRHOC(201)
!        THE ARRAY CONTAINING THE SD OF THE CCF.
!     REAL STAK(12)
!        THE USED VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER WORK
!        THE STARTING LOCATION IN DSTAK FOR
!        THE WORK ARRAY NEEDED BY THE FFT.
!     REAL YFFT1(N), Y1MEAN, Y1SD
!        THE FIRST SERIES, AND ITS MEAN AND STANDARD DEVIATION.
!     REAL YFFT2(N), Y2MEAN, Y2SD
!        THE SECOND SERIES, AND ITS MEAN AND STANDARD DEVIATION.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'C',       'C',       'F',       'F',       ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      iccov = 101
      inlppc = 1
      iym = n
      jccov = 2
      jnlppc = 1
      lagmax = 1
      iymfft = lyfft
      m = 2
      nfft = n
      isfft = .true.
      islong = .false.
!
      if (n.ge.3) then
!
!     SET LARGEST LAG VALUE TO BE USED
!
        call setlag(n, lagmax)
!
!     SET LENGTH OF THE EXTENDED SERIES
!
        call fftlen(n+lagmax, 4, nfft)
      end if
!
      call ldscmp(1, 0, 0, 0, 0, 0, 'S', nfft, ldsmin)
!
     call ccfer(nmsub, n, lagmax, ldstak, ldsmin, iccov, jccov,&
     &  inlppc, jnlppc, m, lyfft, nfft, iym, iymfft, isfft, islong)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      if (ierr.eq.0) then
!
!       SET UP THE WORK AREA.
!
        call stkset (ldstak, 4)
        nall0 = stkst(1)
!
        ifp = 3
!
        work = stkget(nfft, ifp)
!
        if (ierr.eq.0) then
!
!         COMPUTE THE SERIES ACVF AND SD
!
         call acvff (yfft1, n, nfft, y1mean, ccov(1,1,1), lagmax, 101,&
     &       lyfft, stak(work), nfft)
          y1sd = sqrt(ccov(1,1,1) * n / (n-1))
!
         call acvff (yfft2, n, nfft, y2mean, ccov(1,2,2), lagmax, 101,&
     &       lyfft, stak(work), nfft)
          y2sd = sqrt(ccov(1,2,2) * n / (n-1))
!
!         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
         if (ccov(1,1,1)*ccov(1,2,2) .ne. 0.0e0)&
    &       call ccfmnf (yfft1, yfft2, n, nfft, lagmax, 2*lagmax+1,&
    &       ccov(1,1,1), ccov(1,2,2), ccov(1,1,2), ccov(1,2,1), 101,&
     &       rhoc, sdrhoc, 1, lyfft, stak(work), nfft)
!
!         CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
         call ccfout (1, y1mean, y1sd, n, n, 2, y2mean, y2sd, n,&
    &       n, lagmax, 2*lagmax+1, rhoc, sdrhoc, .false., ndum, ndum,&
     &       1, 0.0e0, 0.0e0, .false.)
        end if
!
        call stkclr(nall0)
      end if
!
      if (ierr.ne.0) then
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        ierr = 1
        call iprint (iprt)
        write (iprt, 1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format(/42h the correct form of the call statement is//&
     &  '       CALL CCFF (YFFT1, YFFT2, N, LYFFT, LDSTAK)')
      end
!PGORD
      subroutine pgord (per, npts, yaxis, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES CO-ORDINATES FOR THE PERIODOGRAM PLOT.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   nprt,npts
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   per(npts),yaxis(npts)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm
     integer&
     &   i
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
!       EXTERNAL R1MACH
!
!  INTRINSIC FUNCTIONS
      intrinsic iabs,log10
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .EQ.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
!        IF NPRT .GE.  2, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!     INTEGER NPTS
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
!        ARE ESTIMATED.
!     REAL PER(NPTS)
!        THE ARRAY CONTAINING THE PERIODOGRAM VALUES.
!     REAL YAXIS(NPTS)
!        THE Y CO-ORDINATES FOR THE PERIODOGRAM PLOTS.
!
      fplm = r1mach(2)
!
!     THE FIRST VALUE SHOULD BE ZERO, SO NO ATTEMPT IS MADE TO PLOT IT.
!
      yaxis(1) = fplm
!
      do 10 i = 2, npts
         yaxis(i) = fplm
         if (per(i) .le. 0.0e0) go to 10
            yaxis(i) = per(i)
            if (iabs(nprt) .eq. 1) yaxis(i) = 10.0e0*log10(yaxis(i))
   10 continue
!
      return
!
      end
!PGOUT
      subroutine pgout (yaxis, xaxis, npts, nprt, nmsub)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES THE PERIODOGRAM PLOTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   nprt,npts
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   xaxis(npts),yaxis(npts)
     character&
     &   nmsub(6)*1
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm,xmiss,xmn,xmx,ymn,ymx
     integer&
     &   ilog,iprt
     logical&
     &   error
      real(kind=wp) :: ymiss
!
!  LOCAL ARRAYS
     integer&
     &   isym(1)
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPLMT,PPMN,VERSP,VPLMT,VPMN
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,iabs
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!       AN ERROR FLAG
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER ILOG
!        ...
!     INTEGER IPRT
!        THE LOGICAL UNIT NUMBER FOR THE OUTPUT.
!     INTEGER ISYM(1)
!        A DUMMY ARRAY FOR THE PAGE PLOTS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE.
!     INTEGER NPRT
!        THE VARIABLE CONTROLING PRINTED OUTPUT, WHERE
!        IF NPRT .LE. -2, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM ON A LOG-LINEAR SCALE,
!        IF NPRT .EQ. -1, THE OUTPUT CONSISTS OF A PAGE PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE,
!        IF NPRT .EQ.  0, THE OUTPUT IS SUPPRESSED,
!        IF NPRT .GE.  1, THE OUTPUT CONSISTS OF A VERTICAL PLOT OF THE
!                         PERIODOGRAM IN DECIBELS ON A LINEAR SCALE.
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     REAL XAXIS(NPTS)
!        THE X CO-ORDINATES FOR THE PAGE PLOTS.
!     REAL XMISS
!        THE VALUE USED TO SPECIFY IF THE PERIODOGRAM VALUE WAS
!        LESS THAN OR EQUAL TO ZERO.
!     REAL XMN, XMX
!        ...
!     REAL YAXIS(NPTS)
!        THE Y CO-ORDINATES FOR THE SPECTRAL PLOTS.
!     REAL YMISS
!        THE VALUE USED TO SPECIFY IF AN PERIODOGRAM VALUE WAS
!        LESS THAN OR EQUAL TO ZERO.
!     REAL YMN, YMX
!
!
      fplm = r1mach(2)
!
      xmiss = fplm
      ymiss = fplm
!
!     SET LOGICAL UNIT NUMBER FOR OUTPUT AND SET OUTPUT WIDTH.
!
      call iprint (iprt)
!
      call versp(.true.)
      if (iabs(nprt).eq.1) then
         write (iprt, 1010)
      else
         write (iprt, 1000)
      end if
!
      if (abs(nprt).eq.1) then
        ilog = 0
      else
        ilog = 1
      end if
      if (nprt.ge.1) then
!
!       PLOT VERTICAL PLOTS
!
       call vplmt(yaxis,[ymiss],npts,1,npts,0.0e0,0.0e0,ymn,ymx,&
     &    error, nmsub, .true., 1)
       if (.not.error)&
    &    call vpmn(yaxis(2),[ymiss],npts-1,1,npts,1,0,isym,1,0,&
    &    ymn, ymx, 0.5e0/(npts-1), 0.5e0/(npts-1),&
     &   .true., ilog, -1, 0)
      else
!
!       PLOT PAGE PLOTS
!
       call pplmt(yaxis,[ymiss],xaxis,xmiss,npts,1,npts,&
    &    0.0e0, 0.0e0, ymn, ymx, 0.0e0, 0.5e0, xmn, xmx,&
     &    error, nmsub, .true.)
        if (.not.error) then
         call ppmn (yaxis,[ymiss],xaxis,xmiss,npts,1,npts,0,&
     &      isym, 1, 0, -1, ymn, ymx, xmn, xmx, .true., ilog)
          write(iprt, 1030)
        end if
      end if
      return
!
!     FORMAT STATEMENTS
!
 1000 format (' SAMPLE PERIODOGRAM')
 1010 format (' SAMPLE PERIODOGRAM (IN DECIBELS)')
!1020 FORMAT (5H+FREQ/
!    1   7H PERIOD, 9X, 3HINF, 7X, 3H10., 4X, 2H5., 8X, 6H3.3333, 4X,
!    2   3H2.5, 4X, 2H2.)
1030 format (5h+freq/&
    &   7h period, 9x, 3hinf, 7x, 3h20., 7x, 3h10., 8x, 6h6.6667, 4x,&
    &   2h5., 8x, 2h4., 8x, 6h3.3333, 4x, 6h2.8571, 4x, 3h2.5, 7x,&
     &   6h2.2222, 4x, 2h2.)
!
      end
!XDCKLE
      subroutine xdckle(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer ldstak
!
!  SCALARS IN COMMON
      integer ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
      real(kind=wp) :: delta
      integer i,iprt,ixm,ldsmin,m,n,neta,npar,nprt,nrow,ntau,ntest
!
!  LOCAL ARRAYS
      real(kind=wp) :: par(10),scale(10),xm(200,2)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DCKLS,DCKLS1,DCKLSC,DRV4A,DRV4B,IPRINT,LDSCMP,MDL4
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        *
!     EXTERNAL DRV4A, DRV4B
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL4
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     REAL PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL SCALE(10)
!        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL XM(200,2)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      call iprint(iprt)
!
!     SET PARAMETER VALUES
!
      call dckls1(n, m, ixm, par, npar, neta, ntau, nrow, scale, nprt)
     call ldscmp(5, 0, 2*npar+1, 0, 0, 0, 'S',&
     &            n*npar+npar+n, ldsmin)
!
      if (ldsmin.le.ldstak) go to 5
!
      write (iprt, 1040) ldsmin
      return
!
    5 continue
!
!     CREATE INDEPENDENT VARIABLE
!
      delta = 0.0625e0
      xm(1,1) = 0.0e0
      do 10 i=2,n
         xm(i,1) = xm(i-1,1) + delta
   10 continue
!
      ntest = 0
!
!     CHECK ERROR HANDLING
!
!        TEST 1  -  MISCELANEOUS ERROR CHECKING
!
      n = -5
      m = -5
      ixm = -10
      npar = -10
!
      ntest = ntest + 1
      write (iprt,1130) ntest
      write (iprt,1020)
      write (iprt,1000)
      ierr = -1
      call dckls(xm, n, m, ixm, mdl4, drv4a, par, npar, ldstak)
      write (iprt,1050) ierr
      write (iprt,1010)
      ierr = -1
     call dcklsc(xm, n, m, ixm, mdl4, drv4a, par, npar, ldstak, neta,&
     &   ntau, scale, nrow, nprt)
      write (iprt,1050) ierr
!
!        TEST 2  -  MISCELANEOUS ERROR CHECKING (CONTINUED)
!
      call dckls1(n, m, ixm, par, npar, neta, ntau, nrow, scale, nprt)
      scale(2) = 0.0e0
!
      ntest = ntest + 1
      write (iprt,1130) ntest
      write (iprt,1030)
      write (iprt,1000)
      ierr = -1
      call dckls(xm, n, m, ixm, mdl4, drv4a, par, npar, ldsmin-1)
      write (iprt,1050) ierr
      write (iprt,1010)
      ierr = -1
     call dcklsc(xm, n, m, ixm, mdl4, drv4a, par, npar, ldsmin-1,&
     &   neta, ntau, scale, nrow, nprt)
      write (iprt,1050) ierr
!
      return
!
!     FORMAT STATEMENTS
!
!
 1000 format (15h test of dckls )
 1010 format (15h test of dcklsc)
 1020 format (32h check error handling  -  test 1)
 1030 format (32h check error handling  -  test 2)
 1040 format (45h1 *** ldstak must be greater than or equal to , i6)
1050 format (29h ***** returned results *****, 5x, 15h (-1 indicates ,&
     &   39hvalue not changed by called subroutine)//9h ierr is , i3)
 1130 format (43h1derivative checking subroutine test number, i5)
      end
!DRV
      subroutine drv(par, npar, xm, n, m, ixm, d)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DUMMY DERIVATIVE FUNCTION FOR NLS FAMILY
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   d(n,npar),par(npar),xm(ixm,m)
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL D(N,NPAR)
!        THE FIRST DERIVATIVE WITH RESPECT TO THE ITH PARAMETER
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLESC
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS
!     REAL PAR(NPAR)
!        MODEL PARAMETERS
!     REAL XM(IXM,M)
!        MODEL INDEPENDENT VARIABLE
!
!
      return
!
      end
!AOS
     subroutine aos (n, lagmax, acov, prho, iar, ospvar, phi, work,&
     &   aic, ftest, lacov, laic)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES AUTOREGRESSIVE MODEL ORDER SELECTION
!     STATISTICS. IT PERFORMS STEPWISE FITTING OF AUTOREGRESSIVE
!     COEFFICIENTS BY DURBINS METHOD USING AKAIKES AIC CRITERION
!     FOR SELECTING ORDER.   THE ROUTINE IS MODELED AFTER
!     SUBROUTINE UFPE WRITTEN BY DICK JONES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ospvar
     integer&
     &   iar,lacov,lagmax,laic,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   acov(lacov),aic(laic),ftest(2,lagmax),phi(lagmax),&
     &   prho(lagmax),work(lagmax)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   acov0,aicmin,fplm,rss,rssmin,sqpacf
     integer&
     &   i,j
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   cdff,r1mach
!       EXTERNAL CDFF,R1MACH
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL ARCOEF
!
!  INTRINSIC FUNCTIONS
      intrinsic log,real
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV), ACOV0
!        THE AUTOCOVARIANCES FOR LAGS ZERO TO LAGMAX, AND THE
!        AUTOCOVARIANCE AT LAG ZERO.
!     REAL AIC(LAIC), AICMIN
!        THE ARRAY CONTAINING AKIAKES CRITERIA FOR EACH ORDER, WHERE
!        AIC(I+1) IS THE CRITERIA FOR ORDER I-1, AND THE MINIMUM
!        CRITERIA COMPUTED.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     REAL FTEST(2, LAGMAX)
!        THE ARRAY IN WHICH THE F PERCENTAGE POINT AND PROBABILITY ARE
!        STORED.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     REAL OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
!     REAL PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     REAL PRHO(LAGMAX)
!        THE ARRAY CONTAINING THE PARTIAL AUTOCORRELATION
!        COEFFICIENTS.
!     REAL RSS, RSSMIN
!        THE ONE STEP PREDICTION RESIDUAL SUM OF SQUARES AND THE
!        MINIMUM ONE STEP PREDICTION RESIDUAL SUM OF SQUARES.
!     REAL SQPACF
!        THE SQUARED VALUE OF THE PARTIAL AUTOCORRELATION FUNCTION AT
!        LAG I.
!     REAL WORK(LAGMAX)
!        A REAL WORK AREA.
!
      fplm = r1mach(2)
!
      rss = acov(1) * n
      rssmin = rss
      aic(1) = n * log(rss * (n+1) / (n-1))
      aicmin = aic(1)
      iar = 0
!
!  START STEPWISE PROCEDURE
!
      work(1) = acov(2) / acov(1)
      prho(1) = work(1)
      rss = rss * (1.0e0 - work(1)*work(1))
      aic(2) = n * log(rss * (n+2) / (n-2))
!
      sqpacf = work(1) * work(1)
      ftest(1, 1) = fplm
      ftest(2, 1) = 0.0e0
      if (sqpacf .ge. 1.0e0) go to 5
!
      ftest(1,1) = (n-2) * sqpacf / (1.0e0 - sqpacf)
!
      ftest(2,1) = 1.0e0 - cdff(ftest(1,1), 1.0e0, real(n-2))
!
    5 continue
!
      if (aic(2).ge.aicmin) go to 10
      aicmin = aic(2)
      rssmin = rss
      iar = 1
      phi(1) = work(1)
!
   10 if (lagmax.le.1) go to 40
!
      acov0 = acov(1)
!
      do 30 i=2,lagmax
         call arcoef (acov(2), work, rss, i, lagmax, acov0)
         prho(i) = work(i)
         aic(i+1) = fplm
         ftest(1,i) = fplm
         ftest(2,i) = fplm
         if (i.eq.n-1) go to 15
!
         aic(i+1) = n * log(rss * (n+i+1) / (n-i-1))
!
         sqpacf = work(i) * work(i)
         if (sqpacf .ge. 1.0e0) go to 15
!
         ftest(1,i) = (n-i-1) * sqpacf / (1.0e0 - sqpacf)
!
         ftest(2,i) = 1.0e0 - cdff(ftest(1,i), 1.0e0, real(n-i-1))
!
   15    continue
!
!     IF THIS AIC IS A MINIMUM AND ITS LAG DOES NOT EXCEED N/2,
!     SAVE THE COEFFICIENTS.
!
         if ((aic(i+1).ge.aicmin) .or. (i.gt.n/2)) go to 30
         aicmin = aic(i+1)
         rssmin = rss
         iar = i
         do 20 j=1,i
            phi(j) = work(j)
   20    continue
   30 continue
!
!   NORMALIZE AIC
!
   40 continue
      aic(1) = aic(1) - aicmin
      do 50 i=1,lagmax
         aic(i+1) = aic(i+1) - aicmin
   50 continue
!
      ospvar = rssmin / (n-iar-1)
!
      return
      end
!PPC
      subroutine ppc(ym, x, n, ilog, isize, nout, ylb, yub, xlb, xub)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT (LONG CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   xlb,xub,ylb,yub
     integer&
     &   ilog,isize,n,nout
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xmiss
     integer&
     &   iprt,ischck,iym,lisym,m
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ymmiss(1)
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'P',       'P',       'C',       ' ',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      ymmiss(1) = 1.0e0
      xmiss = 1.0e0
      m = 1
      iym = n
      multi = .false.
      ischck = 0
      miss = .false.
      lisym = 1
!
     call ppcnt (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL PPC (Y, X, N, ILOG,'/&
     &   '      +          ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      end
!SVP
      subroutine svp(ym, n, ns, isym)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH USER CONTROL OF THE PLOT SYMBOLS USED (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n,ns
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(*)
     integer&
     &   isym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ibar,ilog,iprt,irlin,ischck,isize,iym,lisym,m
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'S',       'V',       'P',       ' ',       ' ',       ' '/
!
!     DEFINE CONSTANTS
!
!     SET DEFAULT VALUES
!
      m = 1
      iym = n
      multi = .false.
      ilog = -1
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 1.0e0
      xinc = 1.0e0
      ischck = 1
      isize = -1
      miss = .false.
      lisym = n
      irlin = -1
      ibar = 0
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ym, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL SVP (Y, N, NS, ISYM)')
      end
!DCKLS
      subroutine dckls(xm, n, m, ixm, mdl, drv, par, npar, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR CHECKING USER SUPPLIED
!     ANALYTIC DERIVATIVES AGAINST NUMERICAL DERIVATIVES
!     FOR THE NONLINEAR LEAST SQUARES ROUTINES (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer ixm,ldstak,m,n,npar
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: par(*),xm(:,:)
!
!  SUBROUTINE ARGUMENTS
       external drv,mdl
!
!  SCALARS IN COMMON
      integer ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
      integer iprt,lscale,neta,nprt,nrow,ntau
!
!  LOCAL ARRAYS
      real(kind=wp) :: scale(1)
      character nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DCKDRV,IPRINT
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
!        PARAMETERS ARE STORED.
!     REAL SCALE(1)
!        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL XM(IXM,M)
!        THE INDEPENDENT VARIABLE MATRIX.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'D','C','K','L','S',' '/
!
!     SET DEFAULT VALUES
!
      neta = 0
      ntau = 0
      scale(1) = 0.0e0
      lscale = 1
      nprt = 1
      nrow = 0
!
!     PASS CONTROL OF DERIVATIVE CHECKING TO DCKDRV
!
     call dckdrv(nmsub, ldstak, xm, n, m, ixm, mdl, drv, par, npar,&
     &   neta, ntau, scale, lscale, nrow, nprt)
!
      if (ierr.ne.1) return
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL DCKLS (XM, N, M, IXM, NLSMDL, NLSDRV,'/&
     &   '      +            PAR, NPAR, LDSTAK)')
      end
!ACFS
      subroutine acfs(y, n, lagmax, lacov, acov, iar, phi, nprt, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE AUTO-
!     CORRELATIONS AND PARTIAL AUTOCORRELATIONS OF A TIME SERIES
!     WITH THE COMPUTED ACVF ESTIMATES RETURNED TO THE USERS
!     ROUTINE (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iar,lacov,lagmax,ldstak,n,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(*),phi(*),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   chia,chiap,ospvar,ymean,ysd
     integer&
    &   aic,ftest,i,ifp,iprt,ldsmin,lyfft,nall0,nfac,nfft,prho,&
     &   sdrho,work
     logical&
     &   differ,isfft
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   iod(1),nd(1),ndum(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACFER,ACFMN,ACFOUT,IPRINT,LDSCMP,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV)
!        THE AUTOCOVARIANCE VECTOR.
!     INTEGER AIC
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE AKAIKES CRITERION FOR EACH ORDER.
!     REAL CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     LOGICAL DIFFER
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE IS ACFD (DIFFER = TRUE) OR NOT (DIFFER = FALSE)
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER FTEST
!        THE STARTING LOCATION IN DSTAK FOR
!        THE ARRAY CONTAINING THE PARTIAL F RATIO AND PROBABILITIES
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!     INTEGER IFP
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE FLOATING
!        POINT VARIABLES ARE SINGLE (IFP=3) OR DOUBLE (IFP=4) PRECISION.
!     INTEGER IOD(1)
!        THE ORDER OF EACH OF THE DIFFERENCE FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
!     INTEGER ND(1)
!        THE NUMBER OF TIMES EACH DIFFERENCE FACTOR IS TO BE APPLIED
!     INTEGER NDUM(1)
!        A DUMMY DIMENSIONED VARIABLE.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS MADE.
!     REAL OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
!     REAL PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     INTEGER PRHO
!        THE STARTING LOCATION IN THE WORK AREA FOR PRHO.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SDRHO
!        THE STARTING LOCATION IN THE WORK AREA FOR SDRHO.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR WORK.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED TIME SERIES
!     REAL YSD
!        THE STANDARD DEVIATION OF THE OBSERVED TIME SERIES
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'A',       'C',       'F',       'S',       ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      differ = .false.
      nfac = 1
      nd(1) = 0
      iod(1) = 0
      isfft = .false.
      lyfft = n
      nfft = n
!
!
      call ldscmp(4, 0, 0, 0, 0, 0, 'S', 5*lagmax+1, ldsmin)
!
     call acfer(nmsub, n, lagmax, lacov, ldstak, ldsmin,&
     &  differ, nfac, nd, iod, isfft, lyfft, nfft)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      if (ierr.eq.0) then
!
!       SET UP THE WORK AREA.
!
        call stkset(ldstak, 4)
        nall0 = stkst(1)
!
        ifp = 3
!
        prho = stkget(lagmax, ifp)
        aic = stkget(lagmax+1, ifp)
        ftest = stkget(2*lagmax, ifp)
        work = stkget(lagmax, ifp)
        sdrho = work
!
        if (ierr.eq.0) then
!
!         CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
         call acfmn (y, n, lagmax, acov(2), rstak(sdrho),&
    &       ymean, rstak(prho), rstak(aic), rstak(ftest), phi,&
    &       iar, ospvar, acov, lacov, lagmax+1, chia, chiap,&
     &       rstak(work), nprt)
!
          ysd = sqrt (acov(1) * n / (n - 1))
!
!         CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
         if ((nprt.ne.0) .or.  (acov(1).eq.0.0e0)) call acfout&
    &       (ymean, ysd, n, n, lagmax, acov(2), rstak(sdrho),&
    &       rstak(prho), ndum, rstak(aic), lagmax+1, rstak(ftest),&
    &       iar, phi, ospvar, chia, chiap, lagmax, .false., 0.0e0,&
     &       .false., .false., 0, ndum, ndum, 0)
!
          if (nprt.ne.0) then
            do 50 i = 1, lagmax
               acov(i+1) = acov(i+1) * acov(1)
   50       continue
          end if
!
        end if
!
        call stkclr(nall0)
!
      end if
!
      if (ierr.ne.0) then
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        ierr = 1
        call iprint (iprt)
        write (iprt, 1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format(/42h the correct form of the call statement is//&
    & '       CALL ACFS (Y, N,'/&
     & '      +           LAGMAX, LACOV, ACOV, IAR, PHI, NPRT, LDSTAK)')
      end
!NLSDS
     subroutine nlsds(y, xm, n, m, ixm, mdl, drv, par, npar, res,&
    &   ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING ANALYTIC DERIVATIVES WITH USER
!     SUPPLIED CONTROL PARAMETERS, AND WITH COMPUTED VALUES RETURNED
!     TO THE USER.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
     &   idrvck,ivaprx,ivcv,ixm,ldstak,m,mit,n,npar,npare,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   par(*),pv(*),res(*),scale(*),sdpv(*),sdres(*),vcv(*),xm(*),&
     &   y(*)
     integer&
     &   ifixed(*)
!
!  SUBROUTINE ARGUMENTS
       external drv,mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,lifixd,lpv,lscale,lsdpv,lsdres,lwt,nnzw
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   wt(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,NLCNTA
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER OR NOT THE DERIVATIVES WE
!        CHECKED OR NOT.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(NPAR)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL VCV(IVCV,NPAR)
!        THE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(1)
!        THE DUMMY ARRAY FOR THE WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'N','L','S','D','S',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      weight = .false.
      save = .true.
!
      wt(1) = 1.0e0
      lifixd = npar
      lpv = n
      lscale = npar
      lsdpv = n
      lsdres = n
      lwt = 1
!
     call nlcnta(y, wt, lwt, xm, n, m, ixm, mdl, drv, par, npar, res,&
    &   ldstak, ifixed, lifixd, idrvck, mit, stopss, stopp, scale,&
    &   lscale, delta, ivaprx, nprt, rsd, pv, lpv, sdpv, lsdpv, sdres,&
     &   lsdres, vcv, ivcv, nmsub, weight, save, nnzw, npare)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL NLSDS (Y, XM, N, M, IXM, NLSMDL, NLSDRV,'/&
    &   '      +            PAR, NPAR, RES, LDSTAK,'/&
    &   '      +            IFIXED, IDRVCK, MIT, STOPSS, STOPP,'/&
    &   '      +            SCALE, DELTA, IVAPRX, NPRT,'/&
     &   '      +            NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)')
      end
!DIFSER
      subroutine difser (y, n, ndf, nd, iod, ydiff, ndiff)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PERFORMS THE DIFFERENCING OPPERATION
!     DEFINED BY ND, IOD AND NDF ON THE SERIES Y, RESULTING IN
!     THE SERIES YDIFF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVIAION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n,ndf,ndiff
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*),ydiff(*)
     integer&
     &   iod(*),nd(*)
!
!  LOCAL SCALARS
     integer&
     &   i,j,k,l,ntimes
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IOD(NDF)
!        THE VECTOR CONTAINING THE ORDERS OF EACH DIFFERENCE FACTOR.
!     INTEGER J, K, L
!        INDEX VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER ND(NDF)
!        THE VECTOR CONTAINING THE NUMBER OF TIMES EACH DIFFERENCING
!        FACTOR IS APPLIED.
!     INTEGER NDF
!        THE NUMBER OF DIFFERENCE FACTORS.
!     INTEGER NDIFF
!        THE NUMBER OF OBSERVATIONS REMAINING IN THE DIFFERENCED SERIES.
!     INTEGER NTIMES
!        THE NUMBER OF TIMES A GIVEN DIFFERENCE FACTOR IS TO BE APPLIED.
!     REAL Y(N), YDIFF(N)
!        THE VECTOR CONTAINING THE SERIES OBSERVATIONS AND THE VECTOR
!        IN WHICH THE DIFFERENCED SERIES IS RETURNED.
!
      do 10 i = 1, n
         ydiff(i) = y(i)
   10 continue
!
      ndiff = n
!
      if (ndf .eq. 0) return
!
      do 40 i = 1, ndf
         ntimes = nd(i)
         do 30 l = 1, ntimes
            ndiff = ndiff - iod(i)
            do 20 j = 1, ndiff
               k = j + iod(i)
               ydiff(j) = ydiff(k) - ydiff(j)
   20       continue
   30    continue
   40 continue
      return
      end
!DCKCRV
     subroutine dckcrv(j, d, par, npar, eta, tau, mdl, xm, n,&
     &   nrow, m, ixm, pv, pvtemp, msg, lmsg, fd, parmx, pvpstp, stp)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS WHETHER HIGH CURVATURE COULD BE THE CAUSE
!     OF THE DISAGREEMENT BETWEEN THE NUMERICAL AND ANALYTIC DERIVATIVES
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   d,eta,fd,parmx,pv,pvpstp,stp,tau
     integer&
     &   ixm,j,lmsg,m,n,npar,nrow
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),pvtemp(n),xm(ixm,m)
     integer&
     &   msg(lmsg)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   curve,fplrs,pvmcrv,pvpcrv,stpcrv,temp,third
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
!       EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL DCKFPA
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,sign
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CURVE
!        A MEASURE OF THE CURVATURE IN THE MODEL.
!     REAL D
!        THE SCALAR IN WHICH ROW   NROW   OF THE DERIVATIVE
!        MATRIX WITH RESPECT TO THE JTH UNKNOWN PARAMETER
!        IS STORED.
!     REAL ETA
!        THE RELATIVE NOISE IN THE MODEL.
!     REAL FD
!        THE FORWARD DIFFERENCE QUOTIENT DERIVATIVE WITH RESPECT TO THE
!        JTH PARAMETER.
!     REAL FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARTIAL DERIVATIVE BEING EXAMINED.
!     INTEGER LMSG
!        THE LENGTH OF THE VECTOR MSG.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER MSG(LMSG)
!        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL PARMX
!        THE MAXIMUM OF THE CURRENT PARAMETER ESTIMATE.
!     REAL PV
!        THE SCALAR IN WHICH THE PREDICTED VALUE FROM THE MODEL FOR
!        ROW   NROW   IS STORED.
!     REAL PVMCRV
!        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
!        BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)-STPCRV.
!     REAL PVPCRV
!        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
!        BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCRV.
!     REAL PVPSTP
!        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
!        BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J) + STP.
!     REAL PVTEMP(N)
!        THE VECTOR OF PREDICTED VALUES FROM THE MODEL.
!     REAL STP
!        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FINITE DIFFERENC
!        DERIVATIVE
!     REAL STPCRV
!        THE STEP SIZE SELECTED TO CHECK FOR CURVATURE IN THE MODEL.
!     REAL TAU
!        THE AGREEMENT TOLERANCE.
!     REAL TEMP
!        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
!        PARAMETER IS STORED.
!     REAL THIRD
!        THE VALUE ONE THIRD.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      fplrs = r1mach(4)
!
      third = 1.0e0/3.0e0
!
      stpcrv = (eta**third*parmx*sign(1.0e0,par(j))+par(j)) - par(j)
!
      temp = par(j)
      par(j) = temp + stpcrv
      call mdl(par, npar, xm, n, m, ixm, pvtemp)
!
      pvpcrv = pvtemp(nrow)
!
      par(j) = temp - stpcrv
      call mdl(par, npar, xm, n, m, ixm, pvtemp)
      par(j) = temp
!
      pvmcrv = pvtemp(nrow)
!
!     ESTIMATE CURVATURE BY SECOND DERIVATIVE OF MODEL WITH RESPECT TO
!     PAR(J)
!
      curve = ((pvpcrv+pvmcrv)-2*pv) / (stpcrv*stpcrv)
     curve = curve + (eta ** third) * (abs(pvpcrv) +&
     &   abs(pvmcrv) + 2.0e0 * abs(pv)) / (parmx * parmx)
!
!     COMPARE NUMERICAL AND ANALYTICAL DERIVATIVES USING A FUDGE
!     FACTOR OF 10.0E0.
!
      if (abs(curve*stp)*5.0e0.lt.abs(fd-d)) then
!
!     CURVATURE CANNOT ACCOUNT FOR DISCREPANCY.
!     CHECK IF FINITE PRECISION ARITHMETIC COULD BE THE CULPRIT.
!
        call dckfpa(j,d,par,npar,eta,tau,mdl,xm,n,nrow,&
     &      m,ixm,pv,pvtemp,msg,lmsg,fd,parmx,stp,pvpstp,curve)
!
      else
!
!     HIGH CURVATURE COULD BE THE PROBLEM.  TRY A SMALLER STEP SIZE.
!     COMPUTE SMALLER STEPSIZE
!
        stp = (2.0e0*tau*abs(d)*sign(1.0e0,par(j))/abs(curve)+par(j))&
     &          - par(j)
!
         if (abs(stp).le.fplrs*abs(par(j))) then
!
!     NEW STEP SIZE IS TOO SMALL TO USE.
!
            if (msg(1).eq.0) msg(1) = 1
            msg(j+1) = 1
         else
!
!     TRY NEW STEP SIZE
!
            temp = par(j)
            par(j) = temp + stp
            call mdl(par, npar, xm, n, m, ixm, pvtemp)
            par(j) = temp
            pvpstp = pvtemp(nrow)
!
!     COMPUTE THE NEW NUMERICAL DERIVATIVE
!
            fd = (pvpstp-pv)/stp
!
!     CHECK WHETHER THE NEW NUMERICAL DERIVATIVE IS NOT OK
!
            if (abs(fd-d).gt.2.0e0*tau*abs(d)) then
!
!     NUMERICAL DERIVATIVE COMPUTED USING NEW STEP SIZE DOES
!     NOT AGREE WITH ANALYTIC DERIVATIVE.
!
!     CHECK IF THE PROBLEM COULD BE THE FORWARD DIFFERENCE QUOTIENT
!     DERIVATIVE.
!     (FUDGE FACTOR IS 2)
!
               if (abs(stp*(fd-d)).ge.2.0e0*eta*abs(pv+pvpstp)) then
!
!     FINITE PRECISION COULD NOT BE THE CULPRIT
!
                  msg(1) = 2
                  msg(j+1) = 2
               else
!
!     FINITE PRECISION MAY BE THE CULPRIT
!
                  if (msg(1).eq.0) msg(1) = 1
                  msg(j+1) = 1
               end if
            end if
         end if
      end if
      return
!
      end
!HIPASS
      subroutine hipass (y, n, fc, k, hhp, yf, nyf)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE CARRIES OUT HI-PASS FILTERING OF THE
!     SERIES.  THE FILTER IS THE K-TERM
!     LEAST SQUARES APPROXIMATION TO THE CUTOFF FILTER
!     WITH CUTOF FREQUENCY FC.  ITS TRANSFER FUNCTION
!     HAS A TRANSITION BAND OF WIDTH DELTA SURROUNDING FC,
!     WHERE DELTA = 4*PI/K.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fc
     integer&
     &   k,n,nyf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   hhp(*),y(*),yf(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iprt
     logical&
     &   err01,err02,err03,err04,err05,head
!
!  LOCAL ARRAYS
     character&
     &   lfc(8)*1,lk(8)*1,ln(8)*1,nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,EISII,ERIODD,ERSII,ERSLFS,FLTSL,HPFLT,IPRINT,LPFLT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     REAL FC
!        THE USER SUPPLIED CUTOFF FREQUENCY.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     REAL HHP(K)
!        THE ARRAY IN WHICH THE -IDEAL- HIGH PASS FILTER COEFFICIENTS
!        WILL BE RETURNED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS TO BE COMPUTED.
!     CHARACTER*1 LFC(8), LK(8), LN(8)
!        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES FC, K AND N.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'H',       'I',       'P',       'A',       'S',       'S'/
     data&
    &  lfc(1), lfc(2), lfc(3), lfc(4), lfc(5), lfc(6), lfc(7), lfc(8)&
     & /  'F',   'C',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lk(1), lk(2), lk(3), lk(4), lk(5), lk(6), lk(7), lk(8)&
     & /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 3, 1, head, err01, ln)
!
     call ersii(nmsub, lfc, fc, 0.0e0,&
     &           0.5e0, 2, head, err02, lfc, lfc)
!
      call eisii(nmsub, lk, k, 1, n, 2, head, err03, lk, lk)
!
      call eriodd(nmsub, lk, k, 1, head, err04)
      if (err01 .or. err02 .or. err03 .or. err04) go to 10
!
      call erslfs(nmsub, fc, k, head, err05)
!
      if (err05) go to 10
      go to 20
!
   10 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   20 continue
!
      call lpflt (fc, k, hhp)
!
      call hpflt (hhp, k, hhp)
!
      call fltsl (y, n, k, hhp, yf, nyf)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   46h       call hipass (y, n, fc, k, hhp, yf, nyf))
      end
!IPGORD
     subroutine ipgord (peri, nf, n, freq, xaxis, yaxis, isym, npts,&
     &   lpcv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES CO-ORDINATES FOR THE SPECTRAL PLOTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lpcv,n,nf,npts
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(nf),peri(nf),xaxis(lpcv),yaxis(lpcv)
     integer&
     &   isym(lpcv)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   ci,cimid
     integer&
     &   i,ii,nlim
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   s(40)
!
!  INTRINSIC FUNCTIONS
      intrinsic mod,real,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CI, CIMID
!        THE WIDTH AND MIDPOINT OF THE TEST INTERVAL FOR WHITE NOISE.
!     REAL FREQ(NF)
!        THE ARRAY IN WHICH THE FREQUENCIES AT WHICH THE PERIODOGRAM
!        WAS ESTIMATED ARE STORED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER II
!        AN INDEX VARIABLE
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER N
!        THE ACTUAL NUMBER OF OBSERVATIONS IN THE SERIES FROM WHICH
!        THE PERIODOGRAM WAS COMPUTED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
!        ARE ESTIMATED.
!     INTEGER NLIM
!        THE NUMBER OF POINTS AT WHICH THE WHITE NOISE LIMITS ARE TO
!        PLOTTED.
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     REAL PERI(NF)
!        THE ARRAY CONTAINING THE INTEGRATED PERIODOGRAM VALUES.
!     REAL S(40)
!        VALUES USED TO COMPUTE THE CONFIDENCE LIMITS.
!     REAL XAXIS(LPCV), YAXIS(LPCV)
!        THE X, Y CO-ORDINATES FOR THE SPECTRAL PLOTS.
!
      data s(1)/0.975e0/, s(2)/0.842e0/, s(3)/0.708e0/
      data s(4)/0.624e0/, s(5)/0.563e0/
      data s(6)/0.519e0/, s(7)/0.483e0/, s(8)/0.454e0/
      data s(9)/0.430e0/, s(10)/0.409e0/
      data s(11)/0.391e0/, s(12)/0.375e0/, s(13)/0.361e0/
      data s(14)/0.349e0/, s(15)/0.338e0/
      data s(16)/0.327e0/, s(17)/0.318e0/, s(18)/0.309e0/
      data s(19)/0.301e0/, s(20)/0.294e0/
      data s(21)/0.287e0/, s(22)/0.281e0/, s(23)/0.275e0/
      data s(24)/0.269e0/, s(25)/0.264e0/
      data s(26)/0.259e0/, s(27)/0.254e0/, s(28)/0.250e0/
      data s(29)/0.246e0/, s(30)/0.242e0/
      data s(31)/0.238e0/, s(32)/0.234e0/, s(33)/0.231e0/
      data s(34)/0.227e0/, s(35)/0.224e0/
      data s(36)/0.221e0/, s(37)/0.218e0/, s(38)/0.215e0/
      data s(39)/0.213e0/, s(40)/0.210e0/
!
      i = n + mod(n,2) - 1
!
      if (i .le. 40) then
         ci = s(i)
      else
         ci = 1.36e0 / sqrt(real(i))
      end if
!
      do 10 i = 1, nf
         xaxis(i) = freq(i)
         yaxis(i) = peri(i)
         isym(i) = 1
   10 continue
!
      nlim = 101
!
      ii = nf
!
      do 30 i = 1, nlim, 2
         cimid = real(i-1) / real(nlim-1)
         if (cimid - ci .lt. 0.0e0) go to 20
         ii = ii + 1
         xaxis(ii) = cimid / 2.0e0
         yaxis(ii) = cimid - ci
         isym(ii) = 2
   20    if (cimid + ci .gt. 1.0e0) go to 30
         ii = ii + 1
         xaxis(ii) = cimid / 2.0e0
         yaxis(ii) = cimid + ci
         isym(ii) = 2
   30 continue
!
      npts = ii
!
      return
      end
!MVPMC
     subroutine mvpmc(ym, ymmiss, n, m, iym, ns, ilog, isize,&
     &   ylb, yub, xlb, xinc)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA AND MULTIPLE Y-AXIS VALUES (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ilog,isize,iym,m,n,ns
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(*),ymmiss(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   ibar,iprt,irlin,ischck,lisym
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(IYM,M)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(M)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'M',       'V',       'P',       'M',       'C',       ' '/
!
!     SET DEFAULT VALUES
!
      multi = .true.
      irlin = -1
      ibar = -1
      ischck = 2
      miss = .true.
      lisym = 1
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ymmiss, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &  '       CALL MVPMC (YM, YMMISS, N, M, IYM, NS, ILOG,'/&
     &  '      +            ISIZE, YLB, YUB, XLB, XINC)')
      end
!SPPLTL
     subroutine sppltl (spcmn, spcmx, alow, aup, ypltmn, ypltmx,&
     &   cilow, cimid, ciup)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SETS VARIOUS Y AXIS LIMITS FOR DECIBLE
!     SPECTRUM PLOTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   alow,aup,cilow,cimid,ciup,spcmn,spcmx,ypltmn,ypltmx
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   rngmn,ymax,ymin
!
!  INTRINSIC FUNCTIONS
      intrinsic log10
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALOW, AUP
!        FACTORS USED TO COMPUTE THE CONFIDENCE INTERVALS.
!     REAL CILOW, CIMID, CIUP
!        THE Y CORDNATES FOR THE LOWER  MID AND UPPER CONFIDENCE
!        INTERVAL POINTS.
!     REAL RNGMN
!        THE MINIMUM Y AXIS RANGE FOR THE PLOT.
!     REAL SPCMN, SPCMX
!        THE MINIMUM AND MAXIMUM SPECTRAL VALUE TO BE PLOTTED.
!     REAL YMAX, YMIN
!        THE MAXIMUM AND MINIMUM ACTUAL SPECTRUM VALUE TO BE PLOTTED.
!     REAL YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VAUES TO BE PLOTTED FOR THE Y AXIS.
!
!     SET CO-ORDINATES FOR DECIBLE PLOTS
!
      ymax = log10(spcmx)
      ymin = log10(spcmn)
!
      ypltmx = spcmx
      ypltmn = spcmn
      rngmn = 2.0e0 * (log10(aup) - log10(alow))
      if (ymax - ymin .ge. rngmn) go to 10
!
      ypltmx = 10.0e0 ** (ymax + (rngmn - ymax + ymin) * 0.5e0)
      ypltmn = 10.0e0 ** (ymin - (rngmn - ymax + ymin) * 0.5e0)
!
   10 ciup = ypltmx
      cimid = ciup / aup
      cilow = cimid * alow
!
      return
      end
!VCVOUT
      subroutine vcvout(np, vcv, ivcv, est)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS THE VARIANCE COVARIANCE MATRIX.
!     IF EST IS TRUE, THE COVARIANCES ARE LISTED ABOVE THE
!     DIAGONAL, THE VARIANCES ON THE DIAGONAL, AND THE CORRELATION
!     COEFFICIENTS BELOW THE DIAGONAL.
!     IF EST IS FALSE, THE STANDARD DEVIATIONS ARE LISTED ON THE
!     DIAGONAL, AND THE CORRELATION COEFFICIENTS ARE BELOW THE
!     DIAGONAL.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ivcv,np
     logical&
     &   est
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   vcv(ivcv,np)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   den,svcvii,svcvjj
     integer&
     &   i,iprt,j,k,mode
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,MATPRT
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DEN
!        DENOMINATOR OF (I, J) CORRELATION COEFFICIENT
!     LOGICAL EST
!        AN INDICATOR USED TO DESIGNATE WHETHER THE VCV TO BE PRINTED
!        IS OF THE ESTIMATED PARAMETERS (TRUE) OR NOT (FALSE).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE EXACT FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER MODE
!        IF MODE IS 1, PRINT FULL MATRIX.
!        IF MODE IS 2, PRINT LOWER TRIANGLE WITH SQUARE ROOTS OF
!                      OF THE DIAGONAL.
!     INTEGER NP
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     REAL SVCVII, SVCVJJ
!        SQUARE ROOTS OF VCV(I, I) AND VCV(J, J)
!     REAL VCV(IVCV,NP)
!        THE VARIANCE COVARIANCE MATRIX.
!
!     COMMENCE BODY OF ROUTINE
!
      call iprint(iprt)
!
!     DETERMINE WHETHER TO ISSUE NEGATIVE VARIANCE WARNING
!
      mode = 2
      do 10 i=1,np
         if (vcv(i,i).gt.0.0e0) go to 10
         write (iprt,1000)
         if (est) write (iprt,1050)
         write (iprt,1010)
         mode = 0
         go to 70
   10 continue
!
      if (est) go to 20
!
!     PRINT HEADING FOR CORRELATION ROUTINES
!
      write (iprt,1040)
      write (iprt,1030)
      mode = 2
      go to 30
!
   20 continue
!
!     PRINT HEADING FOR ESTIMATION ROUTINES
!
      write (iprt,1050)
      write (iprt,1020)
      mode = 1
!
   30 continue
!
!     COMPUTE THE CORRELATION COEFFICIENTS AND STORE IN THE BOTTOM HALF
!     OF THE VARIANCE COVARIANCE MATRIX
!
      if (np.eq.1) go to 60
      do 50 j=2,np
         k = j - 1
         svcvjj = 0.0e0
         if (vcv(j,j).gt.0.0e0) svcvjj = sqrt(vcv(j,j))
         do 40 i=1,k
            svcvii = 0.0e0
            if (vcv(i,i).gt.0.0e0) svcvii = sqrt(vcv(i,i))
            den = svcvii*svcvjj
            if (den.le.0.0e0) vcv(j,i) = 0.0e0
            if (den.gt.0.0e0) vcv(j,i) = vcv(j,i)/den
   40    continue
   50 continue
!
   60 continue
!
   70 call matprt(vcv, vcv, np, iprt, mode, 1, ivcv)
!
!     RESTORE THE VCV MATRIX
!
      if (np.eq.1) return
      do 90 j=2,np
         k = j - 1
         do 80 i=1,k
            vcv(j,i) = vcv(i,j)
   80    continue
   90 continue
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (/18h covariance matrix)
1010 format (/39h     nonpositive variances encountered./10h     corre,&
     &   39hlation coefficients cannot be computed.)
1020 format (4x, 36h- covariances are above the diagonal/4x, 7h- varia,&
    &   24hnces are on the diagonal/4x, 27h- correlation coefficients ,&
     &   22hare below the diagonal)
1030 format (4x, 41h- standard deviations are on the diagonal/4x,&
     &   49h- correlation coefficients are below the diagonal)
 1040 format (/19h correlation matrix)
1050 format (/45h variance-covariance and correlation matrices,&
     &   28h of the estimated parameters/ 1x, 72('-')/)
      end
!XNLSE
      subroutine xnlse(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DEMONSTRATE THE USER CALLABLE ROUTINES IN THE NONLINEAR
!     LEAST SQUARES FAMILY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
    &   i,idrvck,iprt,ivaprx,ivcv,ixm1,ixm3,ldsa1,ldsmin,ldsn3a,&
     &   m1,m3,mit,n1,n3,nnzw,npar1,npar3,npare,nprt,ntest
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   par1(10),par3(10),pv(100),res(100),scale(10),sdpv(100),&
    &   sdres(100),stp(10),vcv(6,6),wt(100),xm1(10,2),xm3(101,5),&
     &   y1(10),y3(100)
     integer&
     &   ifixed(10)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DRV1A,DRV1B,IPRINT,LDSCMP,MDL1,MDL3,NLS,NLSC,NLSD,NLSDC,
!     +   NLSDS,NLSS,NLSW,NLSWC,NLSWD,NLSWDC,NLSWDS,NLSWS,NLSX1,
!     +   NLSX2,SETRV
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV1A, DRV1B
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
!        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(10)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM1, IXM3
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSA1, LDSN3A
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK
!        FOR THE ROUTINES WITH ANALYTIC DERIVATIVES AND
!        NUMERICAL DERIVATIVES, RESPECTIVELY.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M1, M3
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL1, MDL3
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N1, N3
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
!     INTEGER NPAR1, NPAR3
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     REAL PAR1(10), PAR3(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL PV(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(100)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     REAL SCALE(10)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     REAL SDPV(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(100)
!        THE STARTING LOCATION IN RSTAK/DSTAK OF THE
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(10)
!        THE RCSTEP SIZE ARRAY.
!     REAL VCV(6,6)
!        THE COVARIANCE MATRIX.
!     REAL WT(100)
!        THE USER SUPPLIED WEIGHTS.
!     REAL XM1(10,2), XM3(101,5)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y1(10), Y3(100)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     DEFINE CONSTANTS
!
     data y1(1), y1(2), y1(3), y1(4), y1(5), y1(6)&
     &   /2.138e0, 3.421e0, 3.597e0, 4.340e0, 4.882e0, 5.660e0/
!
     data xm1(1,1), xm1(2,1), xm1(3,1), xm1(4,1), xm1(5,1), xm1(6,1)&
     &   /1.309e0, 1.471e0, 1.490e0, 1.565e0, 1.611e0, 1.680e0/
!
      data n3 /50/, m3 /5/, ixm3 /101/, npar3 /5/
!
      call iprint(iprt)
!
     call nlsx2(n1, m1, ixm1, npar1, ifixed, stp, idrvck, mit, stopss,&
     &   stopp, scale, delta, ivaprx, nprt, ivcv)
!
      call setrv(wt, n3, 1.0e0)
!
     call ldscmp(6, 0, 60+2*npar1, 0, 0, 0,&
     &   'S', 94+n1*(3+npar1)+npar1*(3*npar1+35)/2, ldsa1)
     call ldscmp(14, 0, max(2*(n3+npar3),60+2*npar3), 0, 0, 0,&
     &   'S', max(10*n3,94+n3*(3+npar3)+npar3*(3*npar3+37)/2), ldsn3a)
!
      ldsmin = max(ldsa1, ldsn3a)
!
      if (ldsmin.le.ldstak) go to 5
!
      write (iprt, 1190) ldsmin
      return
!
    5 continue
!
      do 20 i=1,n3
         xm3(i,1) = 1.0e0
         xm3(i,2) = i
         xm3(i,3) = xm3(i,2)*xm3(i,2)
         xm3(i,4) = xm3(i,3)*xm3(i,2)
         xm3(i,5) = xm3(i,4)*xm3(i,2)
         y3(i) = xm3(i,1) + xm3(i,2) + xm3(i,3) + xm3(i,4) + xm3(i,5)
   20 continue
!
      ntest = 0
!
!
!
!     CHECK ERROR HANDLING
!
!        TEST 1  -  PROBLEM SPECIFICATION
!
      n1 = -5
      m1 = -1
      ixm1 = -10
      npar1 = 0
      ivcv = -10
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1140)
!
      write (iprt,1000)
      call nls(y1, xm1, n1, m1, ixm1, mdl1, par1, npar1, res, ldstak)
      write (iprt,1120) ierr
!
      write (iprt,1010)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsc(y1, xm1, n1, m1, ixm1, mdl1, par1, npar1, res, ldstak,&
     &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
!
      npar1 = 8
      n1 = 2
      write (iprt,1020)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlss(y1, xm1, n1, m1, ixm1, mdl1, par1, npar1, res, ldstak,&
    &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt,&
     &   npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
!
      write (iprt,1030)
     call nlsw(y1, wt, xm1, n1, m1, ixm1, mdl1, par1, npar1, res,&
     &   ldstak)
      write (iprt,1120) ierr
!
      write (iprt,1040)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlswc(y1, wt, xm1, n1, m1, ixm1, mdl1, par1, npar1, res,&
    &   ldstak, ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx,&
     &   nprt)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
!
      write (iprt,1050)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsws(y1, wt, xm1, n1, m1, ixm1, mdl1, par1, npar1, res,&
    &   ldstak, ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx,&
     &   nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
!
      write (iprt,1060)
     call nlsd(y1, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1, res,&
     &   ldstak)
      write (iprt,1120) ierr
!
      write (iprt,1070)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsdc(y1, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1, res,&
    &   ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
!
      n1 = 15
      write (iprt,1080)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsds(y1, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1, res,&
    &   ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
!
      write (iprt,1090)
     call nlswd(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
     &   res, ldstak)
      write (iprt,1120) ierr
!
      write (iprt,1100)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlswdc(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
    &   res, ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
!
      write (iprt,1110)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlswds(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
    &   res, ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
!
!        TEST 2  -  WEIGHTS AND CONTROL VALUES
!
     call nlsx2(n1, m1, ixm1, npar1, ifixed, stp, idrvck, mit, stopss,&
     &   stopp, scale, delta, ivaprx, nprt, ivcv)
!
      wt(n1) = -1.0e0
      stp(1) = 1.0e0
      stp(2) = 0.0e0
      scale(1) = 1.0e0
      scale(2) = 0.0e0
      do 30 i=1,npar1
         ifixed(i) = 1
   30 continue
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1150)
!
      write (iprt,1050)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsws(y1, wt, xm1, n1, m1, ixm1, mdl1, par1, npar1, res,&
    &   ldstak, ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx,&
     &   nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
!
      write (iprt,1090)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlswd(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
     &   res, ldstak)
     call nlswds(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
    &   res, ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
!
!
!        TEST 3  -  TOO FEW POSITIVE WEIGHTS
!
     call nlsx2(n1, m1, ixm1, npar1, ifixed, stp, idrvck, mit, stopss,&
     &   stopp, scale, delta, ivaprx, nprt, ivcv)
!
      call setrv(wt(2), n1-1, 0.0e0)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1160)
!
      write (iprt,1030)
     call nlsw(y1, wt, xm1, n1, m1, ixm1, mdl1, par1, npar1, res,&
     &   ldstak)
      write (iprt,1120) ierr
!
      write (iprt,1110)
     call nlswds(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
    &   res, ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
      write (iprt,1120) ierr
!
!
!        TEST 4  -  DEFINITE ERROR IN DERIVATIVE
!
     call nlsx2(n1, m1, ixm1, npar1, ifixed, stp, idrvck, mit, stopss,&
     &   stopp, scale, delta, ivaprx, nprt, ivcv)
!
      call setrv(wt, n1, 1.0e0)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1170)
!
      write (iprt,1060)
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
     call nlsd(y1, xm1, n1, m1, ixm1, mdl1, drv1b, par1, npar1, res,&
     &   ldstak)
      write (iprt,1120) ierr
!
!
!        TEST 5  -  POSSIBLE ERROR IN DERIVATIVE
!
     call nlsx2(n1, m1, ixm1, npar1, ifixed, stp, idrvck, mit, stopss,&
     &   stopp, scale, delta, ivaprx, nprt, ivcv)
      idrvck = 1
      nprt = 10000
!
      call setrv(wt, n1, 1.0e0)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1180)
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n1, ivcv,&
     &   nnzw, npare, rsd)
      par1(1) = 0.0e0
      write (iprt,1070)
     write (iprt,1360) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call nlsdc(y1, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1, res,&
    &   ldstak, ifixed, idrvck, mit, stopss, stopp, scale, delta,&
     &   ivaprx, nprt)
     write (iprt,1370) ifixed(1), idrvck, mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
!
!
!        TEST 6 -  INSUFFICIENT WORK AREA LENGTH
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1230)
     call nlsx2(n1, m1, ixm1, npar1, ifixed, stp, idrvck, mit, stopss,&
     &   stopp, scale, delta, ivaprx, nprt, ivcv)
!
      write (iprt,1000)
     call nlsx1(3, par3, npar3, pv, sdpv, res, sdres, vcv, n3, ivcv,&
     &   nnzw, npare, rsd)
      call nls(y3, xm3, n3, m3, ixm3, mdl3, par3, npar3, res, ldsn3a-1)
      write (iprt,1120) ierr
!
      write (iprt,1090)
     call nlsx1(1, par1, npar1, pv, sdpv, res, sdres, vcv, n3, ivcv,&
     &   nnzw, npare, rsd)
     call nlswd(y1, wt, xm1, n1, m1, ixm1, mdl1, drv1a, par1, npar1,&
     &   res, ldsa1-1)
      write (iprt,1120) ierr
!
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (14h test of nls  )
 1010 format (15h test of nlsc  )
 1020 format (15h test of nlss  )
 1030 format (14h test of nlsw )
 1040 format (15h test of nlswc )
 1050 format (15h test of nlsws )
 1060 format (14h test of nlsd )
 1070 format (15h test of nlsdc )
 1080 format (15h test of nlsds )
 1090 format (14h test of nlswd)
 1100 format (15h test of nlswdc)
 1110 format (15h test of nlswds)
1120 format (/29h ***** returned results *****, 5x, 15h (-1 indicates ,&
     &   39hvalue not changed by called subroutine)//9h ierr is , i3)
 1140 format (46h error handling test 1 - problem specification)
 1150 format (51h error handling test 2 - weights and control values)
 1160 format (49h error handling test 3 - too few positive weights)
 1170 format (53h error handling test 4 - definite error in derivative)
 1180 format (53h error handling test 5 - possible error in derivative)
 1190 format (45h1 *** ldstak must be greater than or equal to , i6)
 1230 format (' ERROR HANDLING TEST 6 - INSUFFICIENT WORK AREA LENGTH')
1330 format (54h1nonlinear least squares estimation subroutine test nu,&
     &   4hmber, i5/)
1340 format (24h input   -  ifixed(1) = , i6, 9x, 11h, stp(1) = ,&
    &   g15.8, 11h,    mit = ,i5, 11h, stopss = , g15.8, 10h, stopp = ,&
    &   g15.8/13x, 11hscale(1) = , g15.8, 11h,  delta = , g15.8,&
     &   11h, ivaprx = , i5, 11h,   nprt = , i5)
1350 format (//24h output  -  ifixed(1) = , i6, 9x, 11h, stp(1) = ,&
    &   g15.8, 11h,    mit = ,i5, 11h, stopss = , g15.8, 10h, stopp = ,&
    &   g15.8/13x, 11hscale(1) = , g15.8, 11h,  delta = , g15.8,&
     &   11h, ivaprx = , i5, 11h,   nprt = , i5//)
1360 format (24h input   -  ifixed(1) = , i6, 9x, 11h, idrvck = ,&
    &   i5, 10x, 11h,    mit = ,i5, 11h, stopss = , g15.8,&
    &   10h, stopp = , g15.8/&
    &   13x, 11hscale(1) = , g15.8, 11h,  delta = , g15.8,&
     &   11h, ivaprx = , i5, 11h,   nprt = , i6)
1370 format (//24h output  -  ifixed(1) = , i6, 9x, 11h, idrvck = ,&
    &   i5, 10x, 11h,    mit = ,i5, 11h, stopss = , g15.8,&
    &   10h, stopp = , g15.8/&
    &   13x, 11hscale(1) = , g15.8, 11h,  delta = , g15.8,&
     &   11h, ivaprx = , i5, 11h,   nprt = , i5//)
      end
!LSTVEC
      subroutine lstvec(n, vec)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS THE INDICES AND ELEMENT VALUES
!     OF THE VECTOR VEC.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   vec(n)
!
!  LOCAL SCALARS
     integer&
     &   i,imax,imin,index,iprt,nperl
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   INPERL
!      EXTERNAL INPERL
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic min
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IMAX, IMIN
!        THE LARGEST AND SMALLEST INDEX VALUE TO BE PRINTED ON EACH
!        LINE.
!     INTEGER INDEX
!        THE INDEX VALUE TO BE PRINTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER N
!        THE NUMBER OF VALUES TO BE PRINTED IN THE INPUT VECTOR.
!     INTEGER NPERL
!        THE NUMBER OF VALUES TO BE PRINTED PER LINE.
!     REAL VEC(N)
!        THE VECTOR OF VALUES TO BE PRINTED.
!
      call iprint(iprt)
!
      nperl = inperl(0)
!
      do 10 i = 1, n, nperl
         imin = i
         imax = min(i+nperl-1, n)
         write(iprt, 1010) (index, index = imin, imax)
         write(iprt, 1020) (vec(index), index = imin, imax)
   10 continue
!
      return
!
!     FORMAT STATEMENTS
!
 1010 format(10x, 5hindex, i5, 6i15)
 1020 format(10x, 5hvalue, 7(1x, g14.7)/)
!
      end
!ACFOUT
     subroutine acfout (ymean, ysd, n, nused, lagmax, rho, sdrho,&
    &   prho, nlppa, aic, laic, ftest, iar, phi, ospvar, chia, chiap,&
     &   ndfchi, ifmiss, ymiss, differ, newpg, nfac, nd, iod, ntimes)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRINTS THE AUTOCORRELATIONS AND THEIR
!     STANDARD ERRORS, AS WELL AND THE PARTIAL AUTOCORRELATIONS
!     AND MISCELLANEOUS SUMMARY INFORMATION.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: chia,chiap,ospvar,ymean,ymiss,ysd
     integer&
     &   iar,lagmax,laic,n,ndfchi,nfac,ntimes,nused
     logical&
     &   differ,ifmiss,newpg
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   aic(laic),ftest(2,lagmax),phi(lagmax),prho(lagmax),&
     &   rho(lagmax),sdrho(lagmax)
     integer&
     &   iod(*),nd(*),nlppa(lagmax)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm,pmiss
     integer&
     &   iprt,nmiss
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ymmiss(1)
     integer&
     &   isym(1)
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACFDTL,ACFLST,AOSLST,IPRINT,VERSP,VPMN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AIC(LAIC)
!        THE ARRAY CONTAINING THE AKAIKES INFORMATION CRITERION.
!     REAL CHIA, CHIAP
!        THE VARIABLES IN WHICH THE CHI SQUARE STATISTIC AND
!        CHI SQUARED STATISTIC PROBABILITY FOR THE AUTOCORRELATIONS
!        ARE STORED.
!     LOGICAL DIFFER
!        THE VARIABLE USED TO DESIGNATE WHETHER OR NOT THE SERIES
!        ANALYZED WAS DIFFERENCED OR NOT.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     REAL FTEST(2, LAGMAX)
!        THE ARRAY IN WHICH THE F RATIO AND PROBABILITY ARE STORED.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     LOGICAL IFMISS
!        THE INDICATOR VARIABLE USED TO DETERMINE
!        WHETHER THE INPUT SERIES HAS MISSING DATA OR NOT.
!     INTEGER IOD(NFAC)
!        THE ORDER OF EACH OF THE DIFFERENCING FACTORS.
!     INTEGER IPRT
!        THE UNIT NUMBER OF THE DEVICE USED FOR PRINTED
!        OUTPUT.
!     INTEGER ISYM(1)
!        A DUMMY ARRAY.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE VECTOR AIC.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER ND(NFAC)
!        THE ARRAY CONTAINING THE NUMBER OF TIMES THE DIFFERENCING
!        FACTORS ARE TO BE APPLIED.
!     INTEGER NDFCHI
!        THE DEGREES OF FREEDOM FOR THE CHI SQUARED STATISTIC.
!     LOGICAL NEWPG
!        THE VARIABLE DESIGNATING WHETHER OR NOT THE OUTPUT IS TO
!        START ON A NEW PAGE.
!     INTEGER NFAC
!        THE NUMBER OF DIFFERENCE FACTORS.
!     INTEGER NLPPA(LAGMAX)
!        THE ARRAY OF NUMBERS OF LAGGED PRODUCT PAIRS USED TO
!        COMPUTE EACH ACF ESTIMATE.
!     INTEGER NMISS
!        THE NUMBER OF MISSING OBSERVATIONS.
!     INTEGER NTIMES
!        THE NUMBER OF TIMES THE FIRST DIFFERENCE FACTOR HAS BEEN
!        APPLIED.
!     INTEGER NUSED
!        THE ACTIVE NUMBER OF OBSERVATIONS.
!     REAL OSPVAR
!        THE ONE STEP PREDICTION VARIANCE FOR THE ORDER SELECTED (IAR).
!     REAL PHI(LAGMAX)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE SELECTED
!        ORDER.
!     REAL PMISS
!        THE PERCENT OF MISSING OBSERVATIONS.
!     REAL PRHO(LAGMAX)
!        THE ARRAY IN WHICH THE PARTIAL AUTOCORRELATIONS ARE STORED
!     REAL RHO(LAGMAX)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
!     REAL SDRHO(LAGMAX)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!        ARE STORED
!     REAL YMEAN
!        THE MEAN OF THE OBSERVED SERIES.
!     REAL YMISS, YMMISS(1)
!        THE MISSING VALUE CODE.
!     REAL YSD
!        THE STANDARD DEVIATION OF THE OBSERVED SERIES.
!
!
      fplm = r1mach(2)
!
      ymmiss(1) = fplm
!
!     PRINT SUMMARY INFORMATION
!
      call iprint(iprt)
!
      if (newpg) write(iprt, 1004)
!
      call versp (.true.)
      write(iprt, 1005)
      if (differ) call acfdtl(nfac, nd, iod, ntimes)
      write(iprt, 1000) ymean, ysd, n
      if (.not. ifmiss) go to 10
      nmiss = n - nused
      pmiss = 100.0e0 * nmiss / n
      write(iprt, 1003) nmiss, pmiss
   10 write(iprt, 1006) lagmax
      if (ifmiss) write(iprt, 1007) ymiss
!
      if (ysd .gt. 0.0e0) go to 20
!
      write (iprt, 1010)
      return
!
   20 continue
!
!     PRINT ACF INFORMATION
!
      write(iprt, 1008)
      write(iprt, 1001)
     call acflst (rho, sdrho, nlppa, lagmax, ifmiss, chia, ndfchi,&
     &   chiap)
!
!     PLOT ACF INFORMATION
!
      write(iprt, 1004)
      call versp (.true.)
      write(iprt, 1001)
      if (differ) call acfdtl(nfac, nd, iod, ntimes)
     call vpmn(rho, ymmiss, lagmax, 1, lagmax, 1, 0, isym, 1, 0,&
     &   -1.0e0, 1.0e0, 1.0e0, 1.0e0, ifmiss, 0, 0, 1)
!
!     CHECK WHETHER PACF HAVE BEEN COMPUTED
!
      if (nused .le. n-1) return
!
!     PRINT PACF INFORMATION AND AUTOREGRESSIVE MODEL ORDER SELECTION
!     STATISTICS
!
      write(iprt, 1004)
      call versp (.true.)
      write(iprt, 1002)
      write (iprt, 1009)
      if (differ) call acfdtl(nfac, nd, iod, ntimes)
     call aoslst (prho, aic, ftest, lagmax, laic, iar, phi, ospvar,&
     &   .true., n)
!
!     PLOT PACF INFORMATION
!
      write(iprt, 1004)
      call versp (.true.)
      write(iprt, 1002)
      if (differ) call acfdtl(nfac, nd, iod, ntimes)
     call vpmn(prho, ymmiss, ndfchi, 1, ndfchi, 1, 0, isym, 1, 0,&
     &   -1.0e0, 1.0e0, 1.0e0, 1.0e0, ifmiss, 0, 0, 1)
      return
!
!     FORMAT STATEMENTS
!
1000 format(/&
    &   ' AVERAGE OF THE SERIES                 = ', g14.7/&
    &   ' STANDARD DEVIATION OF THE SERIES      = ', g14.7/&
     &   ' NUMBER OF TIME POINTS                 = ', i10)
 1001 format (40h autocorrelation function estimate (acf)/)
 1002 format (49h partial autocorrelation function estimate (pacf)/)
1003 format (&
    &   ' NUMBER OF MISSING OBSERVATIONS        = ', i10/&
     &   ' PERCENTAGE OF OBSERVATIONS MISSING    = ', f10.4)
 1004 format ('1')
 1005 format ( 25h autocorrelation analysis)
1006 format(&
     &   ' LARGEST LAG VALUE USED                = ', i10)
1007 format(&
     &   ' MISSING VALUE CODE                    = ', g14.7)
 1008 format(//)
 1009 format (46h and autoregressive order selection statistics///)
1010 format (///36h the autocorrelations of this series,&
    &   22h could not be computed/&
    &   50h because the lag zero autocovariance of the series,&
     &    9h is zero.)
      end
!SPPMC
     subroutine sppmc(ym, ymiss, x, xmiss, n, isym, ilog, isize, nout,&
     &   ylb, yub, xlb, xub)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH USER CONTROL OF PLOT SYMBOLS AND WITH MISSING
!     OBSERVATIONS (LONG CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: xlb,ymiss,xmiss,xub,ylb,yub
     integer&
     &   ilog,isize,n,nout
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: x(*),ym(*)
     integer&
     &   isym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iprt,ischck,iym,lisym,m
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
      real(kind=wp) :: ymmiss(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YMISS
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'S',       'P',       'P',       'M',       'C',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      ymmiss=ymiss
      m = 1
      iym = n
      multi = .false.
      ischck = 1
      miss = .true.
      lisym = n
!
     call ppcnt (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL SPPMC (Y, YMISS, X, XMISS, N, ISYM, ILOG,'/&
     &   '      +            ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      end
!XAIMD
      subroutine xaimd(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DEMONSTRATE THE USER CALLABLE ROUTINES IN THE ARIMA FAMILY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  SEPTEMBER 1, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
    &   i,ifcst,iprt,ivaprx,ivcv,mit,mxfac,mxfc,mxfco,mxn,mxpar,n,&
     &   nfac,nfcst,nfcsto,npar,npare,nprt,ntest
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   fcst(200,10),fcstsd(200,10),par(10),pv(200),res(200),&
     &   scale(10),sdpv(200),sdres(200),stp(10),vcv(10,10),y(200)
     integer&
     &   ifcsto(10),ifixed(10),mspec(4,10)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AIME,AIMEC,AIMES,AIMF,AIMFS,AIMX1,FITXSP,IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic log
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FCST(200, 10)
!        THE FORECASTS.
!     REAL FCSTSD(200, 10)
!        THE STANDARD DEVIATIONS OF THE FORECASTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFCST
!        THE FIRST DIMENSION OF THE ARRAY FCST.
!     INTEGER IFCSTO(10)
!        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
!     INTEGER IFIXED(10)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER MSPEC(4,10)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH
!        FACTOR.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFCST
!        THE NUMBER OF FORECASTS.
!     INTEGER NFCSTO
!        THE NUMBER OF THE ORIGINS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     REAL PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL PV(200)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(200)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     REAL SCALE(10)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     REAL SDPV(200)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(200)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(10)
!        THE RCSTEP SIZE ARRAY.
!     REAL VCV(10,10)
!        THE COVARIANCE MATRIX.
!     REAL Y(200)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     DEFINE CONSTANTS
!
     data    y(  1),   y(  2),   y(  3),   y(  4),   y(  5),   y(  6)&
     &    / 112.0e0, 118.0e0, 132.0e0, 129.0e0, 121.0e0, 135.0e0/
     data    y(  7),   y(  8),   y(  9),   y( 10),   y( 11),   y( 12)&
     &    / 148.0e0, 148.0e0, 136.0e0, 119.0e0, 104.0e0, 118.0e0/
     data    y( 13),   y( 14),   y( 15),   y( 16),   y( 17),   y( 18)&
     &    / 115.0e0, 126.0e0, 141.0e0, 135.0e0, 125.0e0, 149.0e0/
     data    y( 19),   y( 20),   y( 21),   y( 22),   y( 23),   y( 24)&
     &    / 170.0e0, 170.0e0, 158.0e0, 133.0e0, 114.0e0, 140.0e0/
     data    y( 25),   y( 26),   y( 27),   y( 28),   y( 29),   y( 30)&
     &    / 145.0e0, 150.0e0, 178.0e0, 163.0e0, 172.0e0, 178.0e0/
     data    y( 31),   y( 32),   y( 33),   y( 34),   y( 35),   y( 36)&
     &    / 199.0e0, 199.0e0, 184.0e0, 162.0e0, 146.0e0, 166.0e0/
     data    y( 37),   y( 38),   y( 39),   y( 40),   y( 41),   y( 42)&
     &    / 171.0e0, 180.0e0, 193.0e0, 181.0e0, 183.0e0, 218.0e0/
     data    y( 43),   y( 44),   y( 45),   y( 46),   y( 47),   y( 48)&
     &    / 230.0e0, 242.0e0, 209.0e0, 191.0e0, 172.0e0, 194.0e0/
     data    y( 49),   y( 50),   y( 51),   y( 52),   y( 53),   y( 54)&
     &    / 196.0e0, 196.0e0, 236.0e0, 235.0e0, 229.0e0, 243.0e0/
     data    y( 55),   y( 56),   y( 57),   y( 58),   y( 59),   y( 60)&
     &    / 264.0e0, 272.0e0, 237.0e0, 211.0e0, 180.0e0, 201.0e0/
     data    y( 61),   y( 62),   y( 63),   y( 64),   y( 65),   y( 66)&
     &    / 204.0e0, 188.0e0, 235.0e0, 227.0e0, 234.0e0, 264.0e0/
     data    y( 67),   y( 68),   y( 69),   y( 70),   y( 71),   y( 72)&
     &    / 302.0e0, 293.0e0, 259.0e0, 229.0e0, 203.0e0, 229.0e0/
     data    y( 73),   y( 74),   y( 75),   y( 76),   y( 77),   y( 78)&
     &    / 242.0e0, 233.0e0, 267.0e0, 269.0e0, 270.0e0, 315.0e0/
     data    y( 79),   y( 80),   y( 81),   y( 82),   y( 83),   y( 84)&
     &    / 364.0e0, 347.0e0, 312.0e0, 274.0e0, 237.0e0, 278.0e0/
     data    y( 85),   y( 86),   y( 87),   y( 88),   y( 89),   y( 90)&
     &    / 284.0e0, 277.0e0, 317.0e0, 313.0e0, 318.0e0, 374.0e0/
     data    y( 91),   y( 92),   y( 93),   y( 94),   y( 95),   y( 96)&
     &    / 413.0e0, 405.0e0, 355.0e0, 306.0e0, 271.0e0, 306.0e0/
     data    y( 97),   y( 98),   y( 99),   y(100),   y(101),   y(102)&
     &    / 315.0e0, 301.0e0, 356.0e0, 348.0e0, 355.0e0, 422.0e0/
     data    y(103),   y(104),   y(105),   y(106),   y(107),   y(108)&
     &    / 465.0e0, 467.0e0, 404.0e0, 347.0e0, 305.0e0, 336.0e0/
     data    y(109),   y(110),   y(111),   y(112),   y(113),   y(114)&
     &    / 340.0e0, 318.0e0, 362.0e0, 348.0e0, 363.0e0, 435.0e0/
     data    y(115),   y(116),   y(117),   y(118),   y(119),   y(120)&
     &    / 491.0e0, 505.0e0, 404.0e0, 359.0e0, 310.0e0, 337.0e0/
     data    y(121),   y(122),   y(123),   y(124),   y(125),   y(126)&
     &    / 360.0e0, 342.0e0, 406.0e0, 396.0e0, 420.0e0, 472.0e0/
     data    y(127),   y(128),   y(129),   y(130),   y(131),   y(132)&
     &    / 548.0e0, 559.0e0, 463.0e0, 407.0e0, 362.0e0, 405.0e0/
     data    y(133),   y(134),   y(135),   y(136),   y(137),   y(138)&
     &    / 417.0e0, 391.0e0, 419.0e0, 461.0e0, 472.0e0, 535.0e0/
     data    y(139),   y(140),   y(141),   y(142),   y(143),   y(144)&
     &    / 622.0e0, 606.0e0, 508.0e0, 461.0e0, 390.0e0, 432.0e0/
!
      call iprint(iprt)
!
      do 10 i = 1, 144
        y(i) = log(y(i))
   10 continue
!
!     SET DIMENSIONS
!
      mxn = 200
      mxpar = 10
      mxfc = 200
      mxfco = 10
      mxfac = 10
!
!
      ntest = 0
!
!
!     **TEST ON NORMAL STATEMENT**
!
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1000)
     call aimx1(mxn, mxpar, mxfc, mxfco, mxfac,&
    &   1, n, mspec, nfac, par, npar, res,&
    &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt,&
    &   npare, rsd, pv, sdpv, sdres, vcv, ivcv,&
     &   nfcst, nfcsto, ifcsto, fcst, ifcst, fcstsd)
      call aime (y, n, mspec, nfac, par, npar, res, ldstak)
      write (iprt,1120) ierr
     call fitxsp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv,&
     &   n, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1010)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call aimx1(mxn, mxpar, mxfc, mxfco, mxfac,&
    &   1, n, mspec, nfac, par, npar, res,&
    &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt,&
    &   npare, rsd, pv, sdpv, sdres, vcv, ivcv,&
     &   nfcst, nfcsto, ifcsto, fcst, ifcst, fcstsd)
     call aimec(y, n, mspec, nfac, par, npar, res, ldstak,&
     &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv,&
     &   n, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1020)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call aimx1(mxn, mxpar, mxfc, mxfco, mxfac,&
    &   1, n, mspec, nfac, par, npar, res,&
    &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt,&
    &   npare, rsd, pv, sdpv, sdres, vcv, ivcv,&
     &   nfcst, nfcsto, ifcsto, fcst, ifcst, fcstsd)
     call aimes(y, n, mspec, nfac, par, npar, res, ldstak,&
    &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt,&
     &   npare, rsd, pv, sdpv, sdres, vcv, ivcv)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv,&
     &   n, npare, rsd)
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1030)
     call aimx1(mxn, mxpar, mxfc, mxfco, mxfac,&
    &   1, n, mspec, nfac, par, npar, res,&
    &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt,&
    &   npare, rsd, pv, sdpv, sdres, vcv, ivcv,&
     &   nfcst, nfcsto, ifcsto, fcst, ifcst, fcstsd)
      call aimf (y, n, mspec, nfac, par, npar, ldstak)
      write (iprt,1120) ierr
!
      ntest = ntest + 1
      write (iprt,1330) ntest
      write (iprt,1130)
      write (iprt,1040)
     write (iprt,1340) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
     call aimx1(mxn, mxpar, mxfc, mxfco, mxfac,&
    &   1, n, mspec, nfac, par, npar, res,&
    &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt,&
    &   npare, rsd, pv, sdpv, sdres, vcv, ivcv,&
     &   nfcst, nfcsto, ifcsto, fcst, ifcst, fcstsd)
     call aimfs(y, n, mspec, nfac, par, npar, ldstak,&
     &   nfcst, nfcsto, ifcsto, nprt, fcst, ifcst, fcstsd)
     write (iprt,1350) ifixed(1), stp(1), mit, stopss, stopp,&
     &   scale(1), delta, ivaprx, nprt
      write (iprt,1120) ierr
     call fitxsp(par, fcst(1,1), fcst(1,2), fcst(1,3), fcstsd, vcv,&
     &  n, npar, ivcv, n, npare, rsd)
!
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (14h test of aim  )
 1010 format (15h test of aimc  )
 1020 format (15h test of aims  )
 1030 format (14h test of aimf )
 1040 format (15h test of aimfs )
1120 format (/29h ***** returned results *****, 5x, 15h (-1 indicates ,&
     &   39hvalue not changed by called subroutine)//9h ierr is , i3)
 1130 format (15h normal problem)
 1330 format ('1ARIMA TEST NUMBER', i5)
1340 format (//24h input   -  ifixed(1) = , i6, 9x, ', STP(1) = ',&
    &   g15.8, ',    MIT = ',i5, ', STOPSS = ', g15.8, 10h, stopp = ,&
    &   g15.8/13x, 'SCALE(1) = ', g15.8, ',  DELTA = ', g15.8,&
     &   ', IVAPRX = ', i5, ',   NPRT = ', i5//)
1350 format (//24h output  -  ifixed(1) = , i6, 9x, ', STP(1) = ',&
    &   g15.8, ',    MIT = ',i5, ', STOPSS = ', g15.8, 10h, stopp = ,&
    &   g15.8/13x, 'SCALE(1) = ', g15.8, ',  DELTA = ', g15.8,&
     &   ', IVAPRX = ', i5, ',   NPRT = ', i5//)
      end
!UFSV
      subroutine ufsv(acov, lagmax, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS AND USER SUPPLIED ACVF VALUES (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lagmax,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
      real(kind=wp) :: alpha,delta,fmax,fmin,ymiss
     integer&
    &   iprt,ispcf,lacov,ldsmin,ldstak,lnlppa,lpcv,lwork,ly,nf,&
     &   nprt,nw
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   freq(101),spcf(101,4),work(101),xaxis(106),y(1),yaxis(106)
     integer&
     &   isort(101),isym(106),lags(4),nlppa(1)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PARZEN,UFSDRV
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LAGMAX+1)
!        THE AUTOCOVARIANCE AT LAG ZERO (BIASED VARIANCE).
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISYM(106)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(1)
!        A DUMMY ARRAY FOR SERIES WITHOUT MISSING VALUES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL SPCF(101,4)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     REAL WORK(101)
!        THE VECTOR OF LAG WINDOWS.
!     REAL XAXIS(106)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL Y(1)
!        A DUMMY ARRAY.
!     REAL YAXIS(106)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL YMISS
!        A DUMMY VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'U','F','S','V',' ',' '/
!
!     SET UP FOR ERROR CHECKING
!
      option(4) = .false.
      option(3) = .true.
      option(2) = .false.
      option(1) = .false.
!
      ldstak = 0
      ldsmin = 0
!
      ymiss = 1.0e0
      lacov = lagmax+1
!
      ispcf = 101
      ly = 1
      lnlppa = 1
      lpcv = 106
      lwork = 101
      nf = 101
!
!     SET NUMBER OF LAG WINDOW TRUNCATION POINTS
!
      nw = 4
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!
     call ufsdrv(y, ly, ymiss, acov, nlppa, spcf, ispcf, nf, fmin,&
    &   fmax, freq, n, nw, lagmax, lags, work, lacov, lwork, delta,&
    &   isort, isym, xaxis, yaxis, lpcv, alpha, nprt, parzen, nmsub,&
     &   ldsmin, ldstak, option, lnlppa, ly)
!
!     CHECK FOR ERRORS
!
      if (ierr.eq.0) return
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &  '       CALL UFSV (ACOV, LAGMAX, N)')
      end
!NLSWDS
     subroutine nlswds (y, wt, xm, n, m, ixm, mdl, drv, par,&
    &   npar, res, ldstak, ifixed, idrvck, mit, stopss, stopp, scale,&
    &   delta, ivaprx, nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv,&
     &   ivcv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING ANALYTIC DERIVATIVES, WEIGHTS, AND
!     USER SUPPLIED CONTROL PARAMETERS, AND WITH COMPUTED VALUES
!     RETURNED TO THE USER.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
     &   idrvck,ivaprx,ivcv,ixm,ldstak,m,mit,n,nnzw,npar,npare,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   par(*),pv(*),res(*),scale(*),sdpv(*),sdres(*),vcv(*),wt(*),&
     &   xm(*),y(*)
     integer&
     &   ifixed(*)
!
!  SUBROUTINE ARGUMENTS
       external drv,mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,lifixd,lpv,lscale,lsdpv,lsdres,lwt
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,NLCNTA
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
!        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF IFIXED(I).EQ
!        THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(NPAR)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL STANDARD DEVIATION (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL VCV(IVCV,NPAR)
!        THE VARIANCE-COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(N)
!        THE WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'N',       'L',       'S',       'W',       'D',       'S'/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      weight = .true.
      save = .true.
!
      lifixd = npar
      lpv = n
      lscale = npar
      lsdpv = n
      lsdres = n
      lwt = n
!
     call nlcnta(y, wt, lwt, xm, n, m, ixm, mdl, drv, par, npar, res,&
    &   ldstak, ifixed, lifixd, idrvck, mit, stopss, stopp, scale,&
    &   lscale, delta, ivaprx, nprt, rsd, pv, lpv, sdpv, lsdpv, sdres,&
     &   lsdres, vcv, ivcv, nmsub, weight, save, nnzw, npare)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt, 1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL NLSWDS (Y, WT, XM, N, M, IXM, NLSMDL, NLSDRV,'/&
    &   '      +             PAR, NPAR, RES, LDSTAK,'/&
    &   '      +             IFIXED, IDRVCK, MIT, STOPSS, STOPP,'/&
    &   '      +             SCALE, DELTA, IVAPRX, NPRT,'/&
    &   '      +             NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV,',&
     &   ' IVCV)')
!
      end
!CCFMNM
     subroutine ccfmnm (y1, y1miss, y2, y2miss, n, lagmax, ncc,&
    &   ccov11, ccov22, ccov12, ccov21, iccov, nlpp11, nlpp22,&
    &   nlpp12, nlpp21, inlppc, y1mean, y2mean, rhoc, sdrhoc, nprt,&
     &   laglst)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING CROSS CORRELATIONS AND
!     THEIR STANDARD ERRORS WHEN MISSING DATA ARE INVOLVED.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   y1mean,y1miss,y2mean,y2miss
     integer&
     &   iccov,inlppc,laglst,lagmax,n,ncc,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   ccov11(iccov),ccov12(iccov),ccov21(iccov),ccov22(iccov),&
     &   rhoc(ncc),sdrhoc(ncc),y1(n),y2(n)
     integer&
    &   nlpp11(inlppc),nlpp12(inlppc),nlpp21(inlppc),&
     &   nlpp22(inlppc)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fac,fplm
     integer&
     &   i,i0,im,ip
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
!       EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL CCFSDM,CCVFM
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCOV11(ICCOV), CCOV12(ICCOV)
!     REAL CCOV21(ICCOV), CCOV22(ICCOV)
!        THE ARRAY CONTAINING THE AUTOCOVARIANCE AND CROSS COVARIANCE
!        ESTIMATES FOR SERIES 1 AND 2.
!     REAL FAC
!        THE INVERSE OF THE SQUARE ROOT OF THE PRODUCT OF THE
!        AUTOCOVARIANCES AT LAG ZERO.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER I
!        THE INDEXING VARIABLE FOR THE LAG.
!     INTEGER ICCOV
!        THE DIMENSION OF THE COVARIANCE VECTORS.
!     INTEGER IM
!        THE LOCATIONS IN THE VARIOUS CCF RELATED ARRAYS OF LAG -I.
!     INTEGER INLPPC
!        THE DIMENSION OF THE LAGGED PRODUCT PAIR COUNT VECTORS.
!     INTEGER IP
!        THE LOCATION IF THE VARIOUS CCF RELATED ARRAYS OF LAG I.
!     INTEGER I0
!        THE LOCATION IF THE VARIOUS CCF RELATED ARRAYS OF LAG 0.
!     INTEGER LAGLST
!        THE LAST LAG BEFORE MISSING DATA CAUSED THE ACVF OF EITHER
!        SERIES 1 OR 2 NOT TO BE COMPUTED.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES
!     INTEGER NCC
!        THE NUMBER OF CROSS CORRELATIONS TO BE COMPUTED.
!     INTEGER NLPP11(INLPPC), NLPP12(INLPPC), NLPP21(INLPPC),
!    +        NLPP22(INLPPC)
!        THE NUMBERS OF LAGGED PRODUCT PAIRS USED TO COMPUTE
!        THE AUTOCOVARIANCE AND CROSS COVARIANCE ESTIMATES.
!     INTEGER NPRT
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT.
!     REAL RHOC(NCC)
!        THE ARRAY IN WHICH THE AUTO AND CROSS CORRELATIONS ARE STORED
!     REAL SDRHOC(NCC)
!        THE ARRAY CONTAINING THE STD. ERRORS OF THE CROSS CORRELATIONS.
!        ARE STORED
!     REAL Y1(N), Y1MEAN, Y1MISS
!        THE FIRST SERIES, AND ITS MEAN, AND MISSING VALUE CODE.
!     REAL Y2(N), Y2MEAN, Y2MISS
!        THE SECOND SERIES, AND ITS MEAN, AND MISSING VALUE CODE.
!
      fplm = r1mach(2)
!
!     COMPUTE AUTOCORRELATIONS AND STANDARD DEVIATION OF THE SERIES.
!
     call ccvfm(y1, y1miss, y2, y2miss, n, lagmax, y1mean, y2mean,&
     &   ccov12, ccov21, iccov, nlpp12, nlpp21)
!
      if (nprt .eq. 0 .or. nlpp11(1) .eq. 0) return
      if (ccov11(1) *ccov22(1) .eq. 0.0e0) return
!
      fac = 1.0e0 / sqrt(ccov11(1) * ccov22(1))
!
      i0 = lagmax + 1
      rhoc(i0) = fplm
      if (nlpp12(1).ge.1) rhoc(i0) = ccov12(1) * fac
!
      do 10 i = 1, lagmax
         ip = i0 + i
         rhoc(ip) = fplm
         if (nlpp12(i+1).ge.1) rhoc(ip) = ccov12(i+1) * fac
!
         im = i0 - i
         rhoc(im) = fplm
         if (nlpp21(i+1).ge.1) rhoc(im) = ccov21(i+1) * fac
   10 continue
!
!     COMPUTE STANDARD ERROR OF AUTOCORRELATIONS.
!
     call ccfsdm (ccov11, ccov22, sdrhoc, lagmax, ncc, laglst, n,&
     &   nlpp12, nlpp21, iccov, inlppc)
!
      return
      end
!SVPMC
     subroutine svpmc(ym, ymiss, n, ns, isym, ilog, isize,&
     &   irlin, ibar, ylb, yub, xlb, xinc)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA AND USER CONTROL OF THE PLOT SYMBOL USED
!     (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: ymiss,xinc,xlb,ylb,yub
     integer&
     &   ibar,ilog,irlin,isize,n,ns
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: ym(*)
     integer&
     &   isym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iprt,ischck,iym,lisym,m
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
      real(kind=wp) :: ymmiss(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMISS
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'S',       'V',       'P',       'M',       'C',       ' '/
!
!     SET DEFAULT VALUES
!
      m = 1
      iym = n
      multi = .false.
      ischck = 1
      miss = .true.
      lisym = n
!
!     COMMENCE BODY OF ROUTINE
!
      ymmiss=ymiss
     call vpcnt (ym, ymmiss, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &  '       CALL SVPMC (Y, YMISS, N, NS, ISYM, ILOG,'/&
     &  '      +            ISIZE, IRLIN, IBAR, YLB, YUB, XLB, XINC)')
      end
!NLDRVN
     subroutine nldrvn (mdl, drv, done, ifixd, par, npar, xm, n, m,&
     &   ixm, pvt, d, weight, wt, lwt, stpt, lstpt, scl, lscl)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE NUMERICAL APPROXIMATIONS TO THE
!     DERIVATIVE MATRIX (JACOBIAN).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,lscl,lstpt,lwt,m,n,npar
     logical&
     &   done,weight
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   d(n,npar),par(npar),pvt(n),scl(lscl),stpt(lstpt),wt(lwt),&
     &   xm(ixm,m)
     integer&
     &   ifixd(npar)
!
!  SUBROUTINE ARGUMENTS
       external drv,mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   pj,stpj,wtsqrt
     integer&
     &   i,j,jpk
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max,sign,sqrt
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL D(N,NPAR)
!        THE FIRST DERIVATIVE OF THE MODEL (JACOBIAN).
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     LOGICAL DONE
!        THE VARIABLE USED TO INDICATE WHETHER THIS IS THE FINAL
!        COMPUTATION OF THE JACOBIAN OR NOT.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IXM
!        THE FIRST DIMENSION OF MATRIX XM.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER JPK
!        AN INDEX VARIABLE.
!     INTEGER LSCL
!        THE DIMENSION OF VECTOR SCL.
!     INTEGER LSTPT
!        THE DIMENSION OF VECTOR STPT.
!     INTEGER LWT
!        THE DIMENSION OF VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PJ
!        A TEMPORARY LOCATION FOR STORAGE OF THE JTH PARAMETER.
!     REAL PVT(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
!     REAL SCL(LSCL)
!        THE SCALE VALUES.
!     REAL STPT(LSTPT)
!        THE STEP SIZE ARRAY.
!     REAL STPJ
!        THE JTH STEP SIZE.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     REAL WTSQRT
!        THE SQUARE ROOT OF THE USER SUPPLIED WEIGHTS.
!     REAL XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!
!     COMPUTE FINITE-DIFFERENCE JACOBIAN OF THE OPTIMIZED PARAMETERS
!
      jpk = 0
!
      do 20 j=1,npar
         if (ifixd(j).eq.0) then
            jpk = jpk + 1
            pj = par(j)
            if (scl(jpk).eq.0.0e0) then
               if (par(j).ne.0.0e0) then
                  stpj = stpt(j)*sign(1.0e0,par(j))*abs(par(j))
               else
                  stpj = stpt(j)
               end if
            else
              stpj = stpt(j)*&
    &                sign(1.0e0,par(j))*max(abs(par(j)),1.0e0/&
     &                abs(scl(jpk)))
            end if
!
            stpj = stpj + par(j)
            stpj = stpj - par(j)
!
            par(j) = pj + stpj
            call mdl(par, npar, xm, n, m, ixm, d(1,j))
!
            do 10 i=1,n
               wtsqrt = 1.0e0
               if (weight .and. (.not.done)) wtsqrt = sqrt(wt(i))
               d(i,jpk) = wtsqrt*(pvt(i)-d(i,j))/stpj
   10       continue
!
            par(j) = pj
         end if
   20 continue
!
      return
!
      end
!VPMN
     subroutine vpmn (ym, ymmiss, n, m, iym, nsampl, ischck, isym,&
     &  lisym, isize, ymn, ymx, xlb, xinc, miss, ilog, irlin, ibar)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES VERTICAL PLOTS
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   xinc,xlb,ymn,ymx
     integer&
     &   ibar,ilog,irlin,ischck,isize,iym,lisym,m,n,nsampl
     logical&
     &   miss
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(iym,m),ymmiss(m)
     integer&
     &   isym(lisym)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   refpt,xlabel,ydmn,ydmx,ywidth,yy
     integer&
    &   i,iend,ilogy,imax,imin,ipoint,iprt,iptsym,irefpt,j,numcol,&
     &   nused
     logical&
     &   ifmiss
     character&
     &   i0*1,iblank*1,im*1,ipltch*1,irefch*1,fmt*72
!
!  LOCAL ARRAYS
     integer&
     &   icount(103)
     character&
     &   line(103)*1
!
!  EXTERNAL FUNCTIONS
!      LOGICAL
!     +   MVCHK
!      EXTERNAL MVCHK
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AMEAN,AMEANM,IPRINT,PLINE,PLTPLX,PLTSYM,SETIV,VPHEAD
!
!  INTRINSIC FUNCTIONS
      intrinsic log10,max,min
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     CHARACTER FMT*72
!        THE FORMAT FOR THE X-AXIS LABELS
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     CHARACTER*1 IBLANK
!        THE PLOT SYMBOL BLANK.
!     INTEGER ICOUNT(103)
!        THE NUMBER OF PLOT SYMBOLS AT EACH LOCATION.
!     INTEGER IEND
!        THE NUMBER OF LOCATIONS IN THE PLOT STRING.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     LOGICAL IFMISS
!        THE INDICATOR VARIABLE USED TO DETERMINE WHETHER THE
!        INPUT SERIES HAS MISSING DATA (TRUE) OR NOT (FALSE).
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER ILOGY
!        THE VALUE OF Q (SEE ILOG).
!     CHARACTER*1 IM
!        THE PLOT SYMBOL M.
!     INTEGER IMAX
!        THE LARGEST LOCATION IN THE PLOT STRING BEING DEFINED.
!     INTEGER IMIN
!        THE SMALLEST LOCATION IN THE PLOT STRING BEING DEFINED.
!     CHARACTER*1 IPLTCH
!        THE PLOT CHARACTER USED FOR A GIVEN LINE OF THE PLOT.
!     INTEGER IPOINT
!        THE LOCATION IN THE PLOT STRING OF THE VALUE BEING PLOTTED.
!     INTEGER IPRT
!        *
!     INTEGER IPTSYM
!        AN INDICATOR VARIABLE USED TO DESIGNATE THE TYPE
!        OF PLOT.  IF ISCHCK = 1, THE PLOT IS A SYMPLE PAGE
!        OR VERTICAL PLOT.  IF ISCHCK = 2, THE PLOT IS A SYMBOL
!        PLOT.  IF ISCHCK = 3, THE PLOT IS A MULTIVARIATE PLOT.
!     CHARACTER*1 IREFCH
!        THE PLOT SYMBOL USED TO IDENTIFY THE PLOT REFERENCE LINE.
!     INTEGER IREFPT
!        THE LOCATION IN THE PLOT STRING FOR THE VALUE ZERO, OR
!        SERIES MEAN, WHICH EVER WAS REQUESTED.
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(LISYM)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE EXACT VALUE OF THE FIRST DIMENSION OF THE MATRIX YM.
!     CHARACTER*1 I0
!        THE PLOT SYMBOL -0-.
!     INTEGER J
!        AN INDEX VARIABLE.
!     CHARACTER*1 LINE(103)
!        THE VECTOR USED FOR THE PLOT STRING.
!     INTEGER LISYM
!        *
!     INTEGER M
!        THE NUMBER OF COLUMNS OF DATA IN YM.
!     LOGICAL MISS
!        *
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS .
!     INTEGER NSAMPL
!        THE SAMPLING FREQUENCY ACTUALLY USED.
!     INTEGER NUMCOL
!        *
!     INTEGER NUSED
!        THE NUMBER OF ACTIVE OBSERVATIONS.
!     REAL REFPT
!        THE VALUE ZERO, OR THE MEAN OF THE SERIES, WHICH EVER IS
!        REQUESTED, USED AS A PLOT REFERENCE LINE.
!     REAL XINC
!        THE VARIABLE USED TO SPECIFY THE INCREMENT FOR XLABEL.
!     REAL XLABEL
!        THE VALUE USED FOR THE LABELS ON THE RIGHT SIDE OF THE PLOT.
!     REAL XLB
!        THE STARTING VALUE FOR LABELS ON THE RIGHT SIDE OF THE GRAPH.
!     REAL YDMN, YDMX
!        THE Y-AXIS DATA LIMITS ACTUALLY USED.
!     REAL YM(IYM,M)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES
!     REAL YMMISS(M)
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF YM(I) = YMMISS
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!     REAL YMN, YMX
!        THE GRAPH AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
!     REAL YWIDTH
!        THE SCALE INTERVAL OF THE PLOT.
!     REAL YY
!        THE VALUE OF YM ACTUALLY BEING PLOTTED
!
!
      data iblank/' '/, im/'M'/, i0/'0'/
!
!     PRINT PLOT HEADINGS
!
      call iprint(iprt)
     call vphead(nsampl, irlin, ibar,&
    &            refpt, ywidth, ymn, ymx, isize, ilog,&
     &            line, numcol, ilogy, ydmn, ydmx)
      iend = numcol + 2
!
!     COMPUTE REFERENCE POINT OF GRAPH, IF REQUIRED.
!
      if (irlin.ge.0) then
        if (irlin.eq.0) then
!
!         REFERENCE POINT IS ZERO
!
          refpt = 0.0e0
          irefch = i0
        else
!
!         REFERENCE POINT IS MEAN
!
          if (miss) then
            call ameanm(ym, ymmiss(1), n, nused, refpt)
          else
            call amean(ym, n, refpt)
          end if
          if (ilogy.ne.0) refpt = log10(refpt)
          irefch = im
        end if
!
!       COMPUTE LOCATION OF REFPT IN PLOT STRING
!
        call pltplx(refpt, ymn, ywidth, irefpt, iend)
      else
        irefpt = 1
      end if
!
!     BEGIN PLOTTING
!
      iptsym = ischck + 1
      xlabel = xlb
      do 50 i=1,n,nsampl
         call pline(1, iend, iblank, line)
         call setiv(icount, iend, 0)
         ifmiss = .false.
         ipoint = 1
         do 30 j=1,m
           if (miss) then
             ifmiss = (ifmiss .or. (mvchk(ym(i,j),ymmiss(j))))
             if (.not.(mvchk(ym(i,j),ymmiss(j)))) then
               if (ilogy.eq.0) then
                 yy = ym(i,j)
               else
                 yy = log10(ym(i,j))
               end if
               if ((yy.ge.ydmn) .and. (yy.le.ydmx)) then
                call pltplx(yy, ymn, ywidth, ipoint, iend)
                call pltsym(iptsym, i, j, isym, n, ipoint, line, icount)
                ipltch = line(ipoint)
               else
                ipoint = irefpt
                ipltch = iblank
               end if
             end if
           else
             if (ilogy.eq.0) then
               yy = ym(i,j)
             else
               yy = log10(ym(i,j))
             end if
             if ((yy.ge.ydmn) .and. (yy.le. ydmx)) then
                call pltplx(yy, ymn, ywidth, ipoint, iend)
                call pltsym(iptsym, i, j, isym, n, ipoint, line, icount)
                ipltch = line(ipoint)
             else
                ipoint = irefpt
                ipltch = iblank
             end if
           end if
   30    continue
         if ((ibar.ge.1) .and. (.not.ifmiss)) then
            imin = min(ipoint,irefpt)
            imax = max(ipoint,irefpt)
            call pline(imin, imax, ipltch, line)
         else if (irlin.ge.0) then
            line(irefpt) = irefch
         end if
!
         if (ifmiss) then
           write(fmt,1000) numcol, '8H MISSING'
           write(iprt,fmt) xlabel, (line(j), j=1,iend)
         else
           write(fmt,1000) numcol, '1X, G11.5 '
           if (m.eq.1) then
             write(iprt,fmt) xlabel, (line(j),j=1,iend), ym(i,1)
           else
             write(iprt,fmt) xlabel, (line(j),j=1,iend)
           end if
         end if
         xlabel = xlabel + xinc*nsampl
   50 continue
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format('(1X,G11.5,1X,A1,''I'',', i3, 'A1,''I'',A1,',a10,')')
      end
!MDL2
      subroutine mdl2(par, npar, xm, n, m, ixm, pv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     MODEL FUNCTION FOR NLS EXERCISER
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),pv(n),xm(ixm,m)
!
!  LOCAL SCALARS
     integer&
     &   i
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        ROW INDEX
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     INTEGER M
!        NUMBER OF VARIABLES
!     INTEGER N
!        NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        NUMBER OF PARAMETERS
!     REAL PAR(NPAR)
!        MODEL PARAMETERS
!     REAL PV(N)
!        PREDICTED VALUES
!     REAL XM(IXM,M)
!        INDEPENDENT VARIABLES
!
      do 10 i=1,n
         pv(i) = par(1)*xm(i,1) + par(2)*xm(i,2) + par(3)*xm(i,3)**3
   10 continue
      return
      end
!XXCH12
      subroutine xxch12(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE TIME SERIES CORRELATION AND SPECTRUM ANALYSIS
!     FAMILY OF ROUTINES.
!
!     DATA FOR ACF IS TAKEN FROM P. 362 OF JENKINS AND WATTS [1968]
!     DATA FOR CCF IS TAKEN FROM P. 361 OF JENKINS AND WATTS [1968]
!     DATA FOR UFS IS TAKEN FROM P. 318 OF JENKINS AND WATTS [1968]
!     DATA FOR UAS IS TAKEN FROM P. 318 OF JENKINS AND WATTS [1968]
!     DATA FOR TAPER, PGMS, MDFLT AND PPL IS
!           THE WOLF SUNSPOT NUMBERS FOR THE YEARS 1700 TO 1960 AS
!           TABULATED BY WALDMEIER [1961].
!     DATA FOR BFS IS TAKEN FROM PP. 387-388 OF JENKINS AND WATTS [1968]
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   taperp
     integer&
    &   iextnd,ilog,iprt,lfreq,lper,lyfft,nf,nfft,nk,nprt,ny1,ny2,&
     &   ny3,ny4,ny5,ny6
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   freq(300),per(300),perf(300),y1(100),y2a(100),y2b(100),&
     &   y3(50),y4(50),y5(300),y6a(100),y6b(100),yfft(600)
     integer&
     &   kmd(10)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACF,BFS,CCF,IPRINT,MDFLT,PGMS,PPL,TAPER,UAS,UFS
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (y3(1),y4(1))
      equivalence (y2a(1),y6a(1))
      equivalence (y2b(1),y6b(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FREQ(300)
!        THE FREQUENCIES AT WHICH THE PERIODOGRAM IS COMPUTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER IEXTND
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE USED TO EXTEND THE SERIES.
!     INTEGER ILOG
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE PLOT IS
!        TO HAVE LOGARITHMIC AXIS OR NOT.
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER KMD(10)
!        THE VECTOR OF MODIFIED DANIEL FILTER LENGTHS.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER LFREQ
!        THE LENGTH OF VECTOR FREQ.
!     INTEGER LPER
!        THE LENGTH OF VECTOR PER.
!     INTEGER LYFFT
!        THE LENGTH OF VECTOR YFFT.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES.
!     INTEGER NFFT
!        THE EXTENDED SERIES LENGTH FOR THE FFT.
!     INTEGER NK
!        THE NUMBER OF DANIEL FILTERS TO APPLY.
!     INTEGER NPRT
!        THE PRINT CONTROL VARIABLE.
!     INTEGER NY1, NY2, NY3, NY4, NY5, NY6
!        THE NUMBER OF OBSERVATIONS.
!     REAL PER(300)
!        THE PERIODOGRAM.
!     REAL PERF(300)
!        THE FILTERED PERIODOGRAM.
!     REAL TAPERP
!        THE PERCENTAGE OF THE SERIES TO BE TAPERED.
!     REAL YFFT(600)
!        AN ARRAY FOR THE FFT COMPUTATIONS.
!     REAL Y1(100)
!        THE DATA FROM PAGE 362 OF JENKINS AND WATTS.
!     REAL Y2A(100), Y2B(100)
!        THE DATA FROM PAGE 361 OF JENKINS AND WATTS.
!     REAL Y3(50), Y4(50)
!        THE DATA FROM PAGE 318 OF JENKINS AND WATTS.
!     REAL Y5(300)
!        THE WOLF SUNSPOT DATA.
!     REAL Y6A(100), Y6B(100)
!        THE DATA FROM PAGE 387 AND 388 OF JENKINS AND WATTS.
!
!
     data   y1(  1),  y1(  2),  y1(  3),  y1(  4),  y1(  5),  y1(  6)&
     &    / -2.07_wp, -1.15_wp,  0.69_wp, -0.46_wp, -1.49_wp, -0.70_wp/
     data   y1(  7),  y1(  8),  y1(  9),  y1( 10),  y1( 11),  y1( 12)&
     &    / -1.07_wp, -0.69_wp, -0.68_wp,  1.27_wp, -1.05_wp, -0.05_wp/
     data   y1( 13),  y1( 14),  y1( 15),  y1( 16),  y1( 17),  y1( 18)&
     &    / -0.84_wp, -0.62_wp, -0.49_wp, -1.29_wp, -0.49_wp, -1.06_wp/
     data   y1( 19),  y1( 20),  y1( 21),  y1( 22),  y1( 23),  y1( 24)&
     &    / -0.38_wp, -0.52_wp, -0.13_wp,  1.30_wp, -1.51_wp, -0.43_wp/
     data   y1( 25),  y1( 26),  y1( 27),  y1( 28),  y1( 29),  y1( 30)&
     &    / -1.33_wp, -0.78_wp,  0.31_wp, -0.95_wp, -0.90_wp, -0.30_wp/
     data   y1( 31),  y1( 32),  y1( 33),  y1( 34),  y1( 35),  y1( 36)&
     &    / -1.02_wp, -0.53_wp,  0.15_wp,  1.40_wp,  1.22_wp,  0.59_wp/
     data   y1( 37),  y1( 38),  y1( 39),  y1( 40),  y1( 41),  y1( 42)&
     &    /  0.70_wp,  1.70_wp,  2.78_wp,  1.98_wp,  1.39_wp,  1.85_wp/
     data   y1( 43),  y1( 44),  y1( 45),  y1( 46),  y1( 47),  y1( 48)&
     &    /  2.60_wp,  0.51_wp,  2.77_wp,  1.16_wp,  1.07_wp, -0.48_wp/
     data   y1( 49),  y1( 50),  y1( 51),  y1( 52),  y1( 53),  y1( 54)&
     &    / -0.52_wp,  0.37_wp,  0.00_wp, -1.99_wp, -1.75_wp,  0.70_wp/
     data   y1( 55),  y1( 56),  y1( 57),  y1( 58),  y1( 59),  y1( 60)&
     &    /  0.73_wp,  1.16_wp,  0.06_wp, -0.02_wp,  1.10_wp, -0.35_wp/
     data   y1( 61),  y1( 62),  y1( 63),  y1( 64),  y1( 65),  y1( 66)&
     &    / -1.67_wp, -1.57_wp,  1.16_wp,  1.84_wp,  3.35_wp,  0.40_wp/
     data   y1( 67),  y1( 68),  y1( 69),  y1( 70),  y1( 71),  y1( 72)&
     &    /  0.45_wp,  1.30_wp,  0.93_wp,  1.17_wp, -1.74_wp, -1.28_wp/
     data   y1( 73),  y1( 74),  y1( 75),  y1( 76),  y1( 77),  y1( 78)&
     &    / -0.07_wp,  1.50_wp,  0.53_wp,  0.20_wp, -0.42_wp,  1.18_wp/
     data   y1( 79),  y1( 80),  y1( 81),  y1( 82),  y1( 83),  y1( 84)&
     &    /  0.82_wp,  1.50_wp,  2.92_wp,  1.18_wp,  1.23_wp,  3.16_wp/
     data   y1( 85),  y1( 86),  y1( 87),  y1( 88),  y1( 89),  y1( 90)&
     &    /  0.79_wp,  0.68_wp,  1.14_wp,  1.02_wp,  1.02_wp, -0.71_wp/
     data   y1( 91),  y1( 92),  y1( 93),  y1( 94),  y1( 95),  y1( 96)&
     &    / -0.17_wp, -1.50_wp, -0.26_wp, -0.38_wp,  0.93_wp, -0.33_wp/
     data   y1( 97),  y1( 98),  y1( 99),  y1(100)&
     &    / -1.12_wp, -2.95_wp, -2.09_wp, -1.11_wp                    /
!
     data  y2a(  1), y2a(  2), y2a(  3), y2a(  4), y2a(  5), y2a(  6)&
     &    /-0.88_wp, -0.16_wp, -1.87_wp, -1.12_wp,  1.38_wp,  2.13_wp/
     data  y2a(  7), y2a(  8), y2a(  9), y2a( 10), y2a( 11), y2a( 12)&
     &    / 2.76_wp,  0.56_wp, -0.69_wp, -1.79_wp, -3.82_wp, -2.38_wp/
     data  y2a( 13), y2a( 14), y2a( 15), y2a( 16), y2a( 17), y2a( 18)&
     &    / 1.00_wp,  0.70_wp, -0.15_wp,  0.98_wp,  0.11_wp, -0.35_wp/
     data  y2a( 19), y2a( 20), y2a( 21), y2a( 22), y2a( 23), y2a( 24)&
     &    /-0.73_wp,  0.89_wp, -1.63_wp, -0.44_wp, -1.37_wp, -1.71_wp/
     data  y2a( 25), y2a( 26), y2a( 27), y2a( 28), y2a( 29), y2a( 30)&
     &    /-1.22_wp, -2.00_wp, -0.22_wp,  0.38_wp,  1.31_wp,  0.71_wp/
     data  y2a( 31), y2a( 32), y2a( 33), y2a( 34), y2a( 35), y2a( 36)&
     &    / 0.32_wp,  0.48_wp, -1.88_wp, -0.94_wp, -1.54_wp, -0.13_wp/
     data  y2a( 37), y2a( 38), y2a( 39), y2a( 40), y2a( 41), y2a( 42)&
     &    / 1.02_wp,  0.02_wp, -0.77_wp,  0.11_wp, -0.60_wp, -0.52_wp/
     data  y2a( 43), y2a( 44), y2a( 45), y2a( 46), y2a( 47), y2a( 48)&
     &    /-0.09_wp,  1.23_wp,  1.46_wp,  0.61_wp,  0.42_wp,  2.16_wp/
     data  y2a( 49), y2a( 50), y2a( 51), y2a( 52), y2a( 53), y2a( 54)&
     &    / 3.18_wp,  2.10_wp,  0.37_wp, -0.24_wp,  0.57_wp, -0.53_wp/
     data  y2a( 55), y2a( 56), y2a( 57), y2a( 58), y2a( 59), y2a( 60)&
     &    / 2.44_wp,  1.02_wp, -0.53_wp, -2.49_wp, -2.12_wp, -1.04_wp/
     data  y2a( 61), y2a( 62), y2a( 63), y2a( 64), y2a( 65), y2a( 66)&
     &    /-0.12_wp, -1.88_wp, -1.50_wp,  1.54_wp,  3.33_wp,  3.08_wp/
     data  y2a( 67), y2a( 68), y2a( 69), y2a( 70), y2a( 71), y2a( 72)&
     &    / 1.71_wp,  0.79_wp,  1.55_wp,  0.89_wp, -0.89_wp, -1.18_wp/
     data  y2a( 73), y2a( 74), y2a( 75), y2a( 76), y2a( 77), y2a( 78)&
     &    / 0.89_wp,  1.71_wp,  3.05_wp,  0.15_wp, -1.04_wp,  0.12_wp/
     data  y2a( 79), y2a( 80), y2a( 81), y2a( 82), y2a( 83), y2a( 84)&
     &    / 0.08_wp,  0.11_wp, -2.62_wp, -1.28_wp,  1.07_wp,  3.20_wp/
     data  y2a( 85), y2a( 86), y2a( 87), y2a( 88), y2a( 89), y2a( 90)&
     &    / 1.92_wp,  0.53_wp, -1.08_wp,  0.49_wp, -0.58_wp,  0.17_wp/
     data  y2a( 91), y2a( 92), y2a( 93), y2a( 94), y2a( 95), y2a( 96)&
     &    / 1.15_wp, -0.97_wp, -1.63_wp,  1.14_wp, -0.67_wp, -0.88_wp/
     data  y2a( 97), y2a( 98), y2a( 99), y2a(100)&
     &    /-0.07_wp,  0.24_wp,  0.55_wp, -2.16_wp/
!
     data  y2b(  1), y2b(  2), y2b(  3), y2b(  4), y2b(  5), y2b(  6)&
     &    / 0.79_wp,  1.12_wp, -1.10_wp, -2.39_wp, -1.75_wp, -0.82_wp/
     data  y2b(  7), y2b(  8), y2b(  9), y2b( 10), y2b( 11), y2b( 12)&
     &    /-0.36_wp,  1.27_wp,  1.75_wp,  2.44_wp,  0.36_wp, -2.10_wp/
     data  y2b( 13), y2b( 14), y2b( 15), y2b( 16), y2b( 17), y2b( 18)&
     &    /-1.93_wp, -1.30_wp, -1.75_wp, -0.34_wp,  0.74_wp,  0.49_wp/
     data  y2b( 19), y2b( 20), y2b( 21), y2b( 22), y2b( 23), y2b( 24)&
     &    / 0.70_wp,  0.71_wp,  0.09_wp,  0.59_wp,  1.54_wp,  0.14_wp/
     data  y2b( 25), y2b( 26), y2b( 27), y2b( 28), y2b( 29), y2b( 30)&
     &    / 0.55_wp, -1.40_wp, -2.55_wp, -1.66_wp, -0.43_wp,  0.58_wp/
     data  y2b( 31), y2b( 32), y2b( 33), y2b( 34), y2b( 35), y2b( 36)&
     &    / 2.18_wp, -0.24_wp,  0.58_wp, -0.18_wp, -1.55_wp, -0.64_wp/
     data  y2b( 37), y2b( 38), y2b( 39), y2b( 40), y2b( 41), y2b( 42)&
     &    /-1.09_wp,  0.90_wp, -0.66_wp, -0.35_wp,  0.48_wp,  0.50_wp/
     data  y2b( 43), y2b( 44), y2b( 45), y2b( 46), y2b( 47), y2b( 48)&
     &    / 0.05_wp, -0.68_wp,  0.24_wp,  0.58_wp, -1.26_wp, -0.25_wp/
     data  y2b( 49), y2b( 50), y2b( 51), y2b( 52), y2b( 53), y2b( 54)&
     &    / 0.25_wp,  2.18_wp,  2.96_wp,  1.56_wp, -0.36_wp, -0.59_wp/
     data  y2b( 55), y2b( 56), y2b( 57), y2b( 58), y2b( 59), y2b( 60)&
     &    /-0.12_wp,  3.03_wp,  2.11_wp,  0.78_wp,  0.89_wp, -1.45_wp/
     data  y2b( 61), y2b( 62), y2b( 63), y2b( 64), y2b( 65), y2b( 66)&
     &    /-0.36_wp, -0.37_wp, -1.39_wp, -4.19_wp, -0.73_wp, -0.98_wp/
     data  y2b( 67), y2b( 68), y2b( 69), y2b( 70), y2b( 71), y2b( 72)&
     &    / 0.36_wp,  0.06_wp, -1.94_wp, -0.08_wp,  0.17_wp,  1.00_wp/
     data  y2b( 73), y2b( 74), y2b( 75), y2b( 76), y2b( 77), y2b( 78)&
     &    /-0.05_wp,  0.43_wp,  0.15_wp,  2.69_wp,  0.57_wp,  0.29_wp/
     data  y2b( 79), y2b( 80), y2b( 81), y2b( 82), y2b( 83), y2b( 84)&
     &    / 1.10_wp,  0.48_wp, -1.06_wp, -2.28_wp, -2.03_wp, -0.75_wp/
     data  y2b( 85), y2b( 86), y2b( 87), y2b( 88), y2b( 89), y2b( 90)&
     &    / 1.00_wp,  1.71_wp,  0.58_wp,  1.97_wp,  0.99_wp,  1.94_wp/
     data  y2b( 91), y2b( 92), y2b( 93), y2b( 94), y2b( 95), y2b( 96)&
     &    / 2.18_wp,  3.14_wp,  0.60_wp,  0.51_wp,  1.35_wp,  0.56_wp/
     data  y2b( 97), y2b( 98), y2b( 99), y2b(100)&
     &    / 0.11_wp,  0.00_wp,  2.34_wp,  1.88_wp/
!
     data  y3(  1),y3(  2),y3(  3),y3(  4),y3(  5),y3(  6)&
     &    /-0.88_wp, -0.12_wp, -0.89_wp, -1.38_wp, -0.07_wp,  1.03_wp/
     data  y3(  7),y3(  8),y3(  9),y3( 10),y3( 11),y3( 12)&
     &    / 2.14_wp,  0.35_wp, -1.10_wp, -1.78_wp, -2.76_wp, -1.77_wp/
     data  y3( 13),y3( 14),y3( 15),y3( 16),y3( 17),y3( 18)&
     &    / 0.98_wp,  1.00_wp, -0.70_wp, -1.01_wp, -1.30_wp, -0.85_wp/
     data  y3( 19),y3( 20),y3( 21),y3( 22),y3( 23),y3( 24)&
     &    /-0.46_wp,  1.63_wp,  0.06_wp, -0.17_wp, -1.01_wp, -1.04_wp/
     data  y3( 25),y3( 26),y3( 27),y3( 28),y3( 29),y3( 30)&
     &    /-0.66_wp, -1.12_wp, -0.51_wp, -0.71_wp, -0.20_wp, -0.13_wp/
     data  y3( 31),y3( 32),y3( 33),y3( 34),y3( 35),y3( 36)&
     &    / 0.14_wp,  1.59_wp, -0.76_wp, -1.08_wp, -1.77_wp, -1.20_wp/
     data  y3( 37),y3( 38),y3( 39),y3( 40),y3( 41),y3( 42)&
     &    / 0.45_wp, -0.07_wp, -0.63_wp, -0.35_wp, -0.87_wp, -0.62_wp/
     data  y3( 43),y3( 44),y3( 45),y3( 46),y3( 47),y3( 48)&
     &    / 0.28_wp,  1.90_wp,  2.14_wp,  1.05_wp,  0.31_wp,  1.07_wp/
     data  y3( 49),y3( 50)&
     &    / 2.67_wp,  2.44_wp/
!
     data  y5(  1), y5(  2), y5(  3), y5(  4), y5(  5), y5(  6)&
     &    /     5.0_wp, 11.0_wp, 16.0_wp, 23.0_wp, 36.0_wp, 58.0_wp/
     data  y5(  7), y5(  8), y5(  9), y5( 10), y5( 11), y5( 12)&
     &    /    29.0_wp, 20.0_wp, 10.0_wp,  8.0_wp,  3.0_wp,  0.0_wp/
     data  y5( 13), y5( 14), y5( 15), y5( 16), y5( 17), y5( 18)&
     &    /     0.0_wp, 2.0_wp, 11.0_wp, 27.0_wp, 47.0_wp, 63.0_wp/
     data  y5( 19), y5( 20), y5( 21), y5( 22), y5( 23), y5( 24)&
     &    /    60.0_wp, 39.0_wp, 28.0_wp, 26.0_wp, 22.0_wp, 11.0_wp/
     data  y5( 25), y5( 26), y5( 27), y5( 28), y5( 29), y5( 30)&
     &    /    21.0_wp, 40.0_wp, 78.0_wp,122.0_wp,103.0_wp, 73.0_wp/
     data  y5( 31), y5( 32), y5( 33), y5( 34), y5( 35), y5( 36)&
     &    /    47.0_wp, 35.0_wp, 11.0_wp,  5.0_wp, 16.0_wp, 34.0_wp/
     data  y5( 37), y5( 38), y5( 39), y5( 40), y5( 41), y5( 42)&
     &    /    70.0_wp, 81.0_wp,111.0_wp,101.0_wp, 73.0_wp, 40.0_wp/
     data  y5( 43), y5( 44), y5( 45), y5( 46), y5( 47), y5( 48)&
     &    /    20.0_wp, 16.0_wp,  5.0_wp, 11.0_wp, 22.0_wp, 40.0_wp/
     data  y5( 49), y5( 50), y5( 51), y5( 52), y5( 53), y5( 54)&
     &    /    60.0_wp, 80.9_wp, 83.4_wp, 47.7_wp, 47.8_wp, 30.7_wp/
     data  y5( 55), y5( 56), y5( 57), y5( 58), y5( 59), y5( 60)&
     &    /    12.2_wp,  9.6_wp, 10.2_wp, 32.4_wp, 47.6_wp, 54.0_wp/
     data  y5( 61), y5( 62), y5( 63), y5( 64), y5( 65), y5( 66)&
     &    /    62.9_wp, 85.9_wp, 61.2_wp, 45.1_wp, 36.4_wp, 20.9_wp/
     data  y5( 67), y5( 68), y5( 69), y5( 70), y5( 71), y5( 72)&
     &    /    11.4_wp, 37.8_wp, 69.8_wp,106.1_wp,100.8_wp, 81.6_wp/
     data  y5( 73), y5( 74), y5( 75), y5( 76), y5( 77), y5( 78)&
     &    /    66.5_wp, 34.8_wp, 30.6_wp,  7.0_wp, 19.8_wp, 92.5_wp/
     data  y5( 79), y5( 80), y5( 81), y5( 82), y5( 83), y5( 84)&
     &    /   154.4_wp,125.9_wp, 84.8_wp, 68.1_wp, 38.5_wp, 22.8_wp/
     data  y5( 85), y5( 86), y5( 87), y5( 88), y5( 89), y5( 90)&
     &    /    10.2_wp, 24.1_wp, 82.9_wp,132.0_wp,130.9_wp,118.1_wp/
     data  y5( 91), y5( 92), y5( 93), y5( 94), y5( 95), y5( 96)&
     &    /    89.9_wp, 66.6_wp, 60.0_wp, 46.9_wp, 41.0_wp, 21.3_wp/
     data  y5( 97), y5( 98), y5( 99), y5(100), y5(101), y5(102)&
     &    /    16.0_wp,  6.4_wp,  4.1_wp,  6.8_wp, 14.5_wp, 34.0_wp/
     data  y5(103), y5(104), y5(105), y5(106), y5(107), y5(108)&
     &    /    45.0_wp, 43.1_wp, 47.5_wp, 42.2_wp, 28.1_wp, 10.1_wp/
     data  y5(109), y5(110), y5(111), y5(112), y5(113), y5(114)&
     &    /     8.1_wp,  2.5_wp,  0.0_wp,  1.4_wp,  5.0_wp, 12.2_wp/
     data  y5(115), y5(116), y5(117), y5(118), y5(119), y5(120)&
     &    /    13.9_wp, 35.4_wp, 45.8_wp, 41.1_wp, 30.1_wp, 23.9_wp/
     data  y5(121), y5(122), y5(123), y5(124), y5(125), y5(126)&
     &    /    15.6_wp,  6.6_wp,  4.0_wp,  1.8_wp,  8.5_wp, 16.6_wp/
     data  y5(127), y5(128), y5(129), y5(130), y5(131), y5(132)&
     &    /    36.3_wp, 49.6_wp, 64.2_wp, 67.0_wp, 70.9_wp, 47.8_wp/
     data  y5(133), y5(134), y5(135), y5(136), y5(137), y5(138)&
     &    /    27.5_wp,  8.5_wp, 13.2_wp, 56.9_wp,121.5_wp,138.3_wp/
     data  y5(139), y5(140), y5(141), y5(142), y5(143), y5(144)&
     &    /   103.2_wp, 85.7_wp, 64.6_wp, 36.7_wp, 24.2_wp, 10.7_wp/
     data  y5(145), y5(146), y5(147), y5(148), y5(149), y5(150)&
     &    /    15.0_wp, 40.1_wp, 61.5_wp, 98.5_wp,124.7_wp, 96.3_wp/
     data  y5(151), y5(152), y5(153), y5(154), y5(155), y5(156)&
     &    /    66.6_wp, 64.5_wp, 54.1_wp, 39.0_wp, 20.6_wp,  6.7_wp/
     data  y5(157), y5(158), y5(159), y5(160), y5(161), y5(162)&
     &    /     4.3_wp, 22.7_wp, 54.8_wp, 93.8_wp, 95.8_wp, 77.2_wp/
     data  y5(163), y5(164), y5(165), y5(166), y5(167), y5(168)&
     &    /    59.1_wp, 44.0_wp, 47.0_wp, 30.5_wp, 16.3_wp,  7.3_wp/
     data  y5(169), y5(170), y5(171), y5(172), y5(173), y5(174)&
     &    /    37.6_wp, 74.0_wp,139.0_wp,111.2_wp,101.6_wp, 66.2_wp/
     data  y5(175), y5(176), y5(177), y5(178), y5(179), y5(180)&
     &    /    44.7_wp, 17.0_wp, 11.3_wp, 12.4_wp,  3.4_wp,  6.0_wp/
     data  y5(181), y5(182), y5(183), y5(184), y5(185), y5(186)&
     &    /    32.3_wp, 54.3_wp, 59.7_wp, 63.7_wp, 63.5_wp, 52.2_wp/
     data  y5(187), y5(188), y5(189), y5(190), y5(191), y5(192)&
     &    /    25.4_wp, 13.1_wp,  6.8_wp,  6.3_wp,  7.1_wp, 35.6_wp/
     data  y5(193), y5(194), y5(195), y5(196), y5(197), y5(198)&
     &    /    73.0_wp, 85.1_wp, 78.0_wp, 64.0_wp, 41.8_wp, 26.2_wp/
     data  y5(199), y5(200), y5(201), y5(202), y5(203), y5(204)&
     &    /    26.7_wp, 12.1_wp,  9.5_wp,  2.7_wp,  5.0_wp, 24.4_wp/
     data  y5(205), y5(206), y5(207), y5(208), y5(209), y5(210)&
     &    /    42.0_wp, 63.5_wp, 53.8_wp, 62.0_wp, 48.5_wp, 43.9_wp/
     data  y5(211), y5(212), y5(213), y5(214), y5(215), y5(216)&
     &    /    18.6_wp,  5.7_wp,  3.6_wp,  1.4_wp,  9.6_wp, 47.4_wp/
     data  y5(217), y5(218), y5(219), y5(220), y5(221), y5(222)&
     &    /    57.1_wp,103.9_wp, 80.6_wp, 63.6_wp, 37.6_wp, 26.1_wp/
     data  y5(223), y5(224), y5(225), y5(226), y5(227), y5(228)&
     &    /    14.2_wp,  5.8_wp, 16.7_wp, 44.3_wp, 63.9_wp, 69.0_wp/
     data  y5(229), y5(230), y5(231), y5(232), y5(233), y5(234)&
     &    /    77.8_wp, 64.9_wp, 35.7_wp, 21.2_wp, 11.1_wp,  5.7_wp/
     data  y5(235), y5(236), y5(237), y5(238), y5(239), y5(240)&
     &    /     8.7_wp, 36.1_wp, 79.7_wp,114.4_wp,109.6_wp, 88.8_wp/
     data  y5(241), y5(242), y5(243), y5(244), y5(245), y5(246)&
     &    /    67.8_wp, 47.5_wp, 30.6_wp, 16.3_wp,  9.6_wp, 33.2_wp/
     data  y5(247), y5(248), y5(249), y5(250), y5(251), y5(252)&
     &    /    92.6_wp,151.6_wp,136.3_wp,134.7_wp, 83.9_wp, 69.4_wp/
     data  y5(253), y5(254), y5(255), y5(256), y5(257), y5(258)&
     &    /    31.5_wp, 13.9_wp,  4.4_wp, 38.0_wp,141.7_wp,190.2_wp/
     data  y5(259), y5(260), y5(261)&
     &    /   184.8_wp,159.0_wp,112.3_wp/
!
!     DEFINE CONSTANTS
!
      call iprint(iprt)
      lper = 300
      lfreq = 300
      lyfft = 600
!
      ny1 = 100
      ny2 = 50
      ny3 = 50
      ny4 = 50
      ny5 = 261
      ny6 = 100
!
      nk = 3
      kmd(1) = 8
      kmd(2) = 8
      kmd(3) = 8
!
      taperp = 0.10
!
      nfft = 514
      iextnd = 0
      nprt = -1
!
      ilog = 1
!
!     WRITE HEADER
!
      write(iprt, 1000)
!
!     RUN SIMPLE TEST OF ACF
!
      write(iprt, 1100)
      call acf (y1, ny1)
      write (iprt,2000) ierr
!
!     RUN SIMPLE TEST OF CCF
!
      write(iprt, 1200)
      call ccf (y2a, y2b, ny2)
      write (iprt,2000) ierr
!
!     RUN SIMPLE TEST OF UFS
!
      write(iprt, 1300)
      call ufs (y3, ny3)
      write (iprt,2000) ierr
!
!     RUN SIMPLE TEST OF UAS
!
      write(iprt, 1400)
      call uas (y4, ny4)
      write (iprt,2000) ierr
!
!     RUN SIMPLE TEST OF TAPER
!
      write(iprt, 1510)
      call taper (y5, ny5, taperp, yfft)
      write (iprt,2000) ierr
!
!     RUN SIMPLE TEST OF PGMS
!
      write(iprt, 1520)
     call pgms(yfft, ny5, nfft, lyfft,&
     &          iextnd, nf, per, lper, freq, lfreq, nprt)
      write (iprt,2000) ierr
!
!     RUN SIMPLE TEST OF MDFLT
!
      write(iprt, 1530)
      call mdflt (per, nf, nk, kmd, perf, ldstak)
      write (iprt,2000) ierr
!
!     DISPLAY RESULTS OF MDFLT
!
      write(iprt, 1540)
      call ppl (perf, freq, nf, ilog)
      write (iprt,2000) ierr
!
!     RUN SIMPLE TEST OF BFS
!
      write(iprt, 1600)
      call bfs (y6a, y6b, ny6)
      write (iprt,2000) ierr
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format ('1*CH12')
 1100 format (' SIMPLE TEST OF ACF')
 1200 format ('1SIMPLE TEST OF CCF')
 1300 format ('1SIMPLE TEST OF UFS')
 1400 format ('1SIMPLE TEST OF UAS')
 1510 format ('1SIMPLE TEST OF TAPER (NO OUTPUT UNLESS ERROR FOUND)')
 1520 format ('1SIMPLE TEST OF PGMS')
 1530 format ('1SIMPLE TEST OF MDFLT (NO OUTPUT UNLESS ERROR FOUND)')
 1540 format ('1DISPLAY RESULTS OF MDFLT')
 1600 format ('1SIMPLE TEST OF BFS')
 2000 format (/' THE VALUE OF IERR IS ', i4)
      end
!AIMES
     subroutine aimes(y, n, mspec, nfac, par, npar, res, ldstak,&
    &   ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx, nprt,&
     &   npare, rsd, pv, sdpv, sdres, vcv, ivcv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR ARIMA ESTIMATION
!     (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
     &   ivaprx,ivcv,ldstak,mit,n,nfac,npar,npare,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   par(*),pv(*),res(*),scale(*),sdpv(*),sdres(*),stp(*),vcv(*),&
     &   y(*)
     integer&
     &   ifixed(1),mspec(4,*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,lifixd,lpv,lscale,lsdpv,lsdres,lstp
     logical&
     &   save
!
!  LOCAL ARRAYS
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AMEDRV,IPRINT
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(1)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!        IF IFIXED(1).LT.0, THEN IFIXED(I)=DEFAULT,I=1,...,NPAR, AND THE
!                           DIMENSION OF IFIXED WILL BE ASSUMED TO BE 1.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE FOR
!        IVAPRX LE 0, VCV = THE DEFAULT OPTION
!        IVAPRX EQ 1, VCV = INVERSE(TRANSPOSE(J)*J)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2, VCV = INVERSE(H)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
!                     USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                     DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4, VCV = INVERSE(TRANSPOSE(J)*J)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5, VCV = INVERSE(H)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6, VCV = INVERSE(H)*TRANSPOSE(J)*JACOBIAN*INVERSE(H)
!                     USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7, VCV = THE DEFAULT OPTION
!        WITH J REPRESENTING THE JACOBIAN AND H THE HESSIAN.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE DIMENSION OF VECTOR IFIXED.
!     INTEGER LPV
!        THE DIMENSION OF VECTOR PV.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER LSDPV
!        THE DIMENSION OF VECTOR SDPV.
!     INTEGER LSDRES
!        THE DIMENSION OF VECTOR SDRES.
!     INTEGER LSTP
!        THE DIMENSION OF VECTOR STP.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER MSPEC(4,NFAC)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PV(N)
!        THE PREDICTED VALUE OF THE FIT.
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(NPAR)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!        IF SCALE(1).LE.0, THEN SCALE(I)=DEFAULT,I=1,...,NPAR, AND THE
!                          DIMENSION OF SCALE WILL BE ASSUMED TO BE 1.
!     REAL SDPV(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(N)
!        THE STANDARDIZED RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(NPAR)
!        THE STEP SIZE ARRAY.
!        IF STP(1).LE.0, THEN STP(I)=DEFAULT,I=1,...,NPAR, AND THE
!                        DIMENSION OF STP WILL BE ASSUMED TO BE 1.
!     REAL VCV(IVCV,NPAR)
!        THE VARIANCE-COVARIANCE MATRIX.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'A','I','M','E','S',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      save = .true.
!
      lifixd = npar
      if (ifixed(1).le.-1) lifixd = 1
      lscale = npar
      if (scale(1).le.0.0e0) lscale = 1
      lstp = npar
      if (stp(1).le.0.0e0) lstp = 1
!
     call amedrv(y, n, mspec, nfac, par, npar, res,&
    &   ldstak, ifixed, lifixd, stp, lstp, mit, stopss, stopp, scale,&
    &   lscale, delta, ivaprx, nprt, rsd, pv, lpv, sdpv, lsdpv, sdres,&
     &   lsdres, vcv, ivcv, nmsub, save, npare)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/' THE CORRECT FORM OF THE CALL STATEMENT IS'//&
    &  '       CALL AIMES (Y, N, MSPEC, NFAC, PAR, NPAR, RES, LDSTAK,'/&
    &  '      +            IFIXED, STP, MIT, STOPSS, STOPP, SCALE,'/&
    &  '      +            DELTA, IVAPRX, NPRT,'/&
     &  '      +            NPARE, RSD, PV, SDPV, SDRES, VCV, IVCV)')
      end
!STAT1W
     subroutine stat1w(y, wt, n, ymed, ymin, ymax, ymidrg, yrange,&
     &   ncells, ylb, yub, ydistr, nnzw)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS COMPUTES STATISTICS FOR A VECTOR Y THAT REQUIRE OR CAN
!     MAKE USE OF SORTEDNESS IN THE VECTOR.  WEIGHTS ARE USED.
!
!     THIS SUBROUTINE IS BASED ON A MODIFICATION OF THE STATIS
!     CODE USED IN OMNITAB, VERSION 5 (6/16/72), WRITTED BY
!     SALLY PEAVY.  THE ORIGINAL ADAPTATION TO STARPAC WAS MADE
!     BY JANET DONALDSON.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ylb,ymax,ymed,ymidrg,ymin,yrange,yub
     integer&
     &   n,ncells,nnzw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   wt(n),y(n),ydistr(ncells)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   dely,yt
     integer&
     &   i,ic,ic1,kk,l,m,m1,max,maxy,miny,n2
!
!  INTRINSIC FUNCTIONS
      intrinsic mod
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELY
!        THE WIDTH OF AN INTERVAL ONE TENTH THE RANGE OF THE
!        DATA IN Y.
!     INTEGER I
!        A LOOP INDEX.
!     INTEGER IC
!        PREVIOUS SIGN IN RUNS CALCULATION.
!     INTEGER IC1
!        COUNT IN FREQUENCY DISTRIBUTION CALCULATIONS.
!     INTEGER KK
!        A BACKWARDS, BOULDER, COLORADO LOOP INDEX.
!     INTEGER L
!        A LOOP INDEX.
!     INTEGER M
!        A LOOP INDEX.
!     INTEGER MAX
!        INDEX OF A MAXIMUM ELEMENT.
!     INTEGER MAXY
!        LAST ELEMENT OF Y, THE LARGEST ONE.
!     INTEGER MINY
!        FIRST ELEMENT OF Y, THE LEAST ONE.
!     INTEGER M1
!        ...
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y AND WT.
!     INTEGER NCELLS
!        THE NUMBER OF CELLS IN THE FREQUENCY DISTRIBUTION.
!     INTEGER NNZW
!        INPUT PARAMETER.  THE NUMBER OF POSITIVE ELEMENTS IN WT.
!     INTEGER N2
!        (NNZW + 1)/2
!     REAL WT(N)
!        INPUT PARAMETER.  THE VECTOR OF WEIGHTS FOR THE
!        Y OBSERVATIONS.
!     REAL Y(N)
!        INPUT PARAMETER.  A SET OF N DATA POINTS, SORTED
!        INTO ASCENDING ORDER.
!     REAL YDISTR(NCELLS)
!        OUTPUT PARAMETER.  THE NUMBERS OF Y VALUES WITH
!        POSITIVE WEIGHTS IN EACH OF TEN EQUAL LENGTH INTERVALS.
!        THAT DIVIDE THE RANGE OF Y VALUES.
!     REAL YLB
!        THE LOWER BOUND FOR THE FREQUENCY DISTRIBUTION.
!        IF YLB = YUB, THE MINIMUM OBSERVATION WILL BE USED.
!     REAL YMAX
!        OUTPUT PARAMETER.  THE MAXIMUM OF THE OBSERVATIONS Y HAVING
!        POSITIVE WEIGHT.
!     REAL YMED
!        OUTPUT PARAMETER.  THE MEDIAN OF THE OBSERVATIONS Y.
!     REAL YMIDRG
!        OUTPUT PARAMETER.  THE MIDRANGE OF THE OBSERVATIONS Y.
!     REAL YMIN
!        OUTPUT PARAMETER.  THE MINIMUM OF THE OBSERVATIONS Y HAVING
!        POSITIVE WEIGHT.
!     REAL YRANGE
!        OUTPUT PARAMETER.  THE RANGE OF THE OBSERVATIONS Y.
!     REAL YT
!        THE MAXIMUM VALUE IN EACH INTERVAL IN THE FREQUENCY
!        DISTRIBUTIONS CALCULATIONS.
!     REAL YUB
!        THE UPPER BOUND FOR THE FREQUENCY DISTRIBUTION.
!        IF YLB = YUB, THE MAXIMUM OBSERVATION WILL BE USED.
!
!     CALCULATE THE MEDIAN.
!
      n2 = (nnzw+1)/2
      m = 1
      do 10 i=1,n
         if (i.gt.n2) go to 20
         m = i
         if (wt(m).le.0.0e0) n2 = n2 + 1
   10 continue
   20 m1 = m
      if (mod(nnzw,2).ne.0) go to 40
      do 30 m1=m,n
         if (wt(m1).gt.0.0e0) go to 40
   30 continue
   40 ymed = (y(i)+y(m1))/2.0e0
!
!     CALCULATE THE MIDRANGE, RANGE, MINIMUM, AND MAXIMUM.
!
      max = n - nnzw + 1
      do 50 i=1,max
         miny = i
         if (wt(miny).gt.0.0e0) go to 60
   50 continue
   60 do 70 i=1,max
         kk = n + 1 - i
         maxy = kk
         if (wt(maxy).gt.0.0e0) go to 80
   70 continue
   80 ymidrg = (y(miny)+y(maxy))/2.0e0
      yrange = y(maxy) - y(miny)
      ymin = y(miny)
      ymax = y(maxy)
!
!     COMPUTE FREQUENCY DISTRIBUTION
!
      dely = yrange
      yt = ymin
      if (ylb.ge.yub) go to 5
         dely = yub - ylb
         yt = ylb
    5 continue
      dely = dely / ncells
      yt = yt + dely
      l = 0
      ic1 = 0
      do 110 i=2,ncells
         ic = 0
   90    l = l + 1
         if (l.gt.n) go to 100
         if (wt(l).le.0.0e0) go to 90
         if (y(l).gt.yt) go to 100
         ic = ic + 1
         ic1 = ic1 + 1
         go to 90
  100    ydistr(i-1) = ic
         l = l - 1
         yt = yt + dely
  110 continue
      ydistr(ncells) = nnzw - ic1
      return
      end
!STATW
      subroutine statw(y, wt, n, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES 53 DIFFERENT STATISTICS FOR A
!     VECTOR Y, WITH WEIGHTS SPECIFIED.  ONE PAGE OF AUTOMATIC
!     PRINTOUT IS PRODUCED.
!
!     WRITTEN BY - JANET R. DONALDSON, JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!        (EXTENSIVE REVISION OF OLDER VERSION)
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   wt(*),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   alpha,sum1,sumd2,sumd3,sumd4,sumda,sumdi,sumt1,sumw,sumwd2,&
     &   sumwt1
     integer&
     &   idp,iint,iprt,lsort,mid,nall0,nnzw
     logical&
     &   stack,wts
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   sts(53)
     integer&
     &   istak(12)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL GENI,IPRINT,SRTIRR,SRTRRI,STAT1W,STAT2W,STATER,STKCLR,
!     +   STKSET,SUMBS,SUMIDW,SUMOT,SUMWDS,SUMWSS,SUMWTS
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        THE PERCENTAGE OF POINTS TO BE TRIMMED FROM EITHER END OF
!        Y IN CALCULATING THE TRIMMED MEANS.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IDP
!        FRAMEWORK CODE VALUE FOR DOUBLE PRECISION NUMBERS.
!     INTEGER IERR
!        THE CODE INDICATING WHETHER OR NOT AN ERROR HAS
!        BEEN DISCOVERED.  0 MEANS NO ERROR, NOT 0 MEANS
!        SOME ERROR EXISTS.
!     INTEGER IINT
!        THE CODE VALUE FOR INTEGER FOR FRAMEWORK.
!     INTEGER IPRT
!        THE NUMBER OF THE STANDARD OUTPUT UNIT.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER LDSTAK
!        INPUT PARAMETER.  THE NUMBER OF DOUBLE PRECISION
!        ELEMENTS DIMENSIONED FOR DSTAK IN THE USER PROGRAM.
!     INTEGER LSORT
!        THE STARTING LOCATION IN ISTAK OF THE PERMUTATION
!        VECTOR.
!     INTEGER MID
!        THE INDEX OF A ZERO ELEMENT IN THE SORTED Y, OR OF THE
!        ELEMENT CLOSEST TO ZERO.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF Y.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
!        WAS CALLED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NNZW
!        NUMBER OF NONZERO WEIGHTS.
!     LOGICAL STACK
!        A FLAG INDICATING WHETHER THIS ROUTINE USES THE STACK (TRUE)
!        OR NOT (FALSE).
!     REAL STS(53)
!        THE VECTOR OF THE 53 STATISTICS COMPUTED.
!     REAL SUMDA
!        THE SUM OF THE ABSOLUTE DIFFERENCES FROM THE MEAN.
!     REAL SUMDI
!        THE SUM OF THE PRODUCTS OF THE INDICES AND THE
!        DIFFERENCES.
!     REAL SUMD2
!        THE SUM OF THE SQUARES OF THE DIFFERENCES.
!     REAL SUMD3
!        THE SUM OF THE CUBES OF THE DIFFERENCES.
!     REAL SUMD4
!        THE SUM OF THE 4TH POWERS OF THE DIFFERENCES.
!     REAL SUMT1
!        THE SUM OF THE ALPHA TRIMMED ARRAY Y.
!     REAL SUMW
!        THE SUM OF THE WEIGHTS VECTOR WT.
!     REAL SUMWD2
!        THE WEIGHTED SUM OF THE SQUARES OF THE DIFFERENCES.
!     REAL SUMWT1
!        THE WEIGHTED SUM OF THE ALPHA TRIMMED ARRAY.
!     REAL SUM1
!        THE UNWEIGHTED SUM OF THE ELEMENTS OF Y.
!     REAL WT(N)
!        INPUT PARAMETER.  THE WEIGHTS VECTOR.
!     LOGICAL WTS
!        A FLAG INDICATING WHETHER THERE ARE WEIGHTS (TRUE)
!        OR NOT (FALSE).
!     REAL Y(N)
!        INPUT PARAMETER.  THE VECTOR OF DATA POINTS ON WHICH
!        THE STATISTICS ARE COMPUTED.  Y IS SORTED, BUT RESTORED
!        TO ITS ORIGINAL ORDER AFTERWARDS.
!
!
!     INITIALIZE NAME VECTORS
!
     data  nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6)&
     &   /       'S',      'T',      'A',      'T',      'W',      ' '/
!
      data alpha /0.25e0/
      data idp /4/
      data iint /2/
      data wts /.true./
      data stack /.true./
!
!     CHECK FOR ERRORS IN THE INPUT PARAMETERS.
!
      call stater(nmsub, wt, n, ldstak, wts, nnzw, stack, ierr)
      if (ierr.ne.0) then
!
!     PRINT ERROR MESSAGE.
!
         call iprint(iprt)
         write (iprt,1000)
         return
      end if
!
!     SET UP FRAMEWORK AREA.
!
      call stkset (ldstak, idp)
      nall0 = stkst(1)
!
!     SET UP LSORT, THE PERMUTATION VECTOR.
!
      lsort = stkget(n,iint)
      call geni(istak(lsort), n, 1, 1)
!
!     SORT THE VECTOR Y.
!
      call srtirr(istak(lsort), wt, n, y)
!
!     COMPUTE THE STATISTICS WHICH USE A SORTED ARRAY.
!
     call stat1w(y, wt, n, sts(5), sts(34), sts(35), sts(6),&
     &   sts(11), 10, 0.0e0, 0.0e0, sts(44), nnzw)
!
!     COMPUTED VARIOUS SUMS IN THE SORTED ARRAY Y.
!
      call sumbs(y, n, 1, mid, n)
     call sumwss(y, wt, n, 1, mid, n, nnzw, sum1, sts(38), sts(39),&
     &   sts(42), sumw, sts(3), sts(4))
     call sumwts(y, wt, n, nnzw, alpha, sumt1, sumwt1, sts(7),&
     &   sts(8))
     call sumwds(y, wt, n, 1, mid, n, sts(4), sumda, sumwd2, sumd2,&
     &   sumd3, sumd4)
!
!     RESTORE THE VECTOR Y TO ITS ORIGINAL ORDER.
!
      call srtrri(y, wt, n, istak(lsort))
!
!     COMPUTE REST OF STATISTICS.
!
      call sumidw(y, wt, n, sts(4), sumdi)
     call stat2w(y, wt, n, nnzw, sts, sumda, sumdi, sumwd2, sumd2,&
     &   sumd3, sumd4, sumw)
      call sumot(sts, n, nnzw, wts)
!
!     RETURN THE VECTOR LSORT.
!
      call stkclr(nall0)
      return
!
!     FORMAT STATEMENTS.
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL STATW (Y, WT, N, LDSTAK)')
      end
!DCKZRO
     subroutine dckzro(j, par, npar, mdl, xm, n, nrow, m, ixm, pv,&
     &   pvtemp, msg, lmsg, fd, parmx, pvpstp, stp)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE RECHECKS THE DERIVATIES IN THE CASE WHERE THE FINITE
!     DIFFERENCE DERIVATIVE DISAGREES WITH THE ANALYTIC DERIVATIVE AND T
!     ANALYTIC DERIVATIVE IS ZERO.
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fd,parmx,pv,pvpstp,stp
     integer&
     &   ixm,j,lmsg,m,n,npar,nrow
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),pvtemp(n),xm(ixm,m)
     integer&
     &   msg(lmsg)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   cd,fplrs,pvmstp,temp,third
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
!       EXTERNAL R1MACH
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,min
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CD
!        THE CENTRAL DIFFERENCE QUOTIENT DERIVATIVE WITH
!        RESPECT TO THE JTH PARAMETER.
!     REAL FD
!        THE FORWARD DIFFERENCE QUOTIENT DERIVATIVE WITH RESPECT TO THE
!        JTH PARAMETER.
!     REAL FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARTIAL DERIVATIVE BEING EXAMINED.
!     INTEGER LMSG
!        THE LENGTH OF THE VECTOR MSG.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER MSG(LMSG)
!        AN ARRAY USED TO STORE MESSAGE PARAMETERS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL PARMX
!        THE MAXIMUM OF THE CURRENT PARAMETER ESTIMATE AND THE TYPICAL
!        VALUE OF THAT PARAMETER.
!     REAL PV
!        THE SCALAR IN WHICH THE PREDICTED VALUE FROM THE MODEL FOR
!        ROW   NROW   IS STORED.
!     REAL PVMSTP
!        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
!        BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J) - STP.
!     REAL PVPSTP
!        THE PREDICTED VALUE FOR ROW    NROW   OF THE MODEL
!        BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J) + STP.
!     REAL PVTEMP(N)
!        THE VECTOR OF PREDICTED VALUES FROM THE MODEL.
!     REAL STP
!        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FINITE DIFFERENC
!        DERIVATIVE
!     REAL TEMP
!        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
!        PARAMETER IS STORED.
!     REAL THIRD
!        THE VALUE 1/3.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      fplrs = r1mach(4)
!
!     RECALCULATE NUMERICAL DERIVATIVE USING CENTRAL DIFFERENCE AND STEP
!     SIZE OF 2*STP
!
      temp = par(j)
      par(j) = par(j) - stp
      call mdl(par, npar, xm, n, m, ixm, pvtemp)
      par(j) = temp
!
      pvmstp = pvtemp(nrow)
!
      cd = (pvpstp-pvmstp)/(2.0e0*stp)
!
!     CHECK FOR DISAGREEMENT
!
      if (cd.ne.0.0e0) go to 10
!
!     NUMERICAL AND ANALYTIC DERIVATIVES NOW AGREE, BUT BOTH EQUAL ZERO,
!     INDICATING THAT DERIVATIVES SHOULD BE RECHECKED AT ANOTHER POINT.
!
      if (msg(1).eq.0) msg(1) = 1
      msg(j+1) = 3
      return
!
   10 continue
!
!     NUMERICAL AND ANALYTIC DERIVATIVE STILL DO NOT AGREE.
!
!     CHECK IF NUMERICAL DERIVATIVE IS CLOSE TO ZERO.
!
      third = 1.0e0/3.0e0
     if (min(abs(cd), abs(fd))*parmx .gt. abs(pv*fplrs**third))&
     &   go to 20
!
!     NUMERICAL DERIVATIVE IS CLOSE TO ZERO
!
      if (msg(1).eq.0) msg(1) = 1
      msg(j+1) = 4
      return
!
   20 continue
!
!     NUMERICAL DERIVATIVE NOT CLOSE TO ZERO
!
      msg(1) = 2
      msg(j+1) = 5
      return
!
      end
!AXPBY
      subroutine axpby(n,sa,sx,incx,sb,sy,incy,sz,incz)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE IS ADAPTED FROM BLAS SUBROUTINE SAXPY.
!
!     OVERWRITE REAL SZ WITH REAL SA*SX + SB*SY.
!     FOR I = 0 TO N-1, REPLACE  SZ(LZ+I*INCZ) WITH SA*SX(LX+I*INCX) +
!     SY(LY+I*INCY), WHERE LX = 1 IF INCX .GE. 0, ELSE LX = (-INCX)*N,
!     AND LY AND LZ ARE DEFINED IN A SIMILAR WAY USING INCY AND INCZ,
!     RESPECTIVELY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   sa,sb
     integer&
     &   incx,incy,incz,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   sx(*),sy(*),sz(*)
!
!  LOCAL SCALARS
     integer&
     &   i,ix,iy,iz,m,mp1,ns
!
!  INTRINSIC FUNCTIONS
      intrinsic mod
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL SX(N), SY(N), SZ(N)
!
      if(n.le.0) return
     if ((incx .eq. 1) .and. (incy .eq. 1) .and. (incz .eq. 1))&
     &   go to 20
     if ((incx .ge. 2) .and. (incx .eq. incy) .and. (incx .eq. incz))&
     &   go to 60
!
!        CODE FOR NONEQUAL OR NONPOSITIVE INCREMENTS.
!
      ix = 1
      iy = 1
      iz = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      if(incz.lt.0)iz = (-n+1)*incz + 1
      do 10 i = 1,n
        sz(iz) = sa*sx(ix) + sb*sy(iy)
        ix = ix + incx
        iy = iy + incy
        iz = iz + incz
   10 continue
      return
!
!        CODE FOR BOTH INCREMENTS EQUAL TO 1
!
!
!        CLEAN-UP LOOP SO REMAINING VECTOR LENGTH IS A MULTIPLE OF 4.
!
   20 m = mod(n,4)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        sz(i) = sa*sx(i) + sb*sy(i)
   30 continue
      if( n .lt. 4 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,4
        sz(i) = sa*sx(i) + sb*sy(i)
        sz(i+1) = sa*sx(i+1) + sb*sy(i+1)
        sz(i+2) = sa*sx(i+2) + sb*sy(i+2)
        sz(i+3) = sa*sx(i+3) + sb*sy(i+3)
   50 continue
      return
!
!        CODE FOR EQUAL, POSITIVE, NONUNIT INCREMENTS.
!
   60 continue
      ns = n*incx
      do 70 i=1,ns,incx
        sz(i) = sa*sx(i) + sb*sy(i)
   70 continue
      return
      end
!UASV
      subroutine uasv (acov, lagmax, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR AUTOREGRESSIVE
!     SPECTRUM ESTIMATION WHEN THE ACVF HAVE PREVIOUSLY BEEN
!     COMPUTED AND STORED (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lagmax,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta,fmax,fmin,var
     integer&
    &   iar,iprt,lacov,lag,laic,ldsmin,ldstak,lpcv,lphi,lspc,&
     &   lwork,nf,nprt
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   aic(101),freq(101),ftest(2,100),phi(100),spca(101),spcf(101),&
     &   work(101),xaxis(207),yaxis(207)
     integer&
     &   isort(101),isym(207)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PARZEN,UASDV,UASER
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LAGMAX+1)
!        THE AUTOCOVARIANCE COMPUTED FROM THE LAG PRODUCT PAIRS.
!     REAL AIC(101)
!        THE ARRAY CONTAINING AKIAKES CRITERIA FOR EACH ORDER.
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY FOR WHICH THE
!        SPECTRUM ESTIMATES ARE TO BE COMPUTED.
!     REAL FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     REAL FTEST(2, 100)
!        THE ARRAY CONTAINING THE F RATIO AND F TEST.
!     INTEGER IAR
!        THE ORDER OF THE AUTOREGRESSIVE PROCESS CHOSEN.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISYM(207)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE COVARIANCE ARRAYS.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAIC
!        THE LENGTH OF THE ARRAY AIC.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LPHI
!        THE LENGTH OF THE VECTOR PHI.
!     INTEGER LSPC
!         THE LENGTH OF THE SPECTRUM ARRAYS.
!     INTEGER LWORK
!        THE LENGTH OF THE WORK ARRAY.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
!        ARE TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE TYPE OF WINDOW TO BE USED.
!     REAL PHI(100)
!        THE ARRAY OF AUTOREGRESSIVE COEFFICIENTS FOR THE
!        SELECTED ORDER.
!     REAL SPCA(101)
!        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!     REAL SPCF(101)
!        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
!     REAL VAR
!        THE ONE STEP PREDICTION VARIANCE.
!     REAL WORK(101)
!        A WORK AREA USED FOR THE LAG WINDOWS AND FOR
!        COMPUTING THE AUTOREGRESSIVE COEFFICIENTS.
!     REAL XAXIS(207)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL YAXIS(207)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'U',       'A',       'S',       'V',       ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      option(1) = .false.
      option(2) = .false.
      option(3) = .true.
      option(4) = .false.
!
      lag = 0
      iar = 0
      nf = 101
      fmin = 0.0e0
      fmax = 0.5e0
      nprt = -1
      lacov = lagmax+1
      ldstak = 0
      ldsmin = 0
!
!     CALL ERROR CHECKING ROUTINE
!
     call uaser(nmsub, n, acov, iar, phi, lagmax, lag, lacov,&
     &   nf, ldstak, ldsmin, n, n, option)
!
      if (ierr.ne.0) then
         ierr = 1
         call iprint (iprt)
         write (iprt, 1000)
         return
      end if
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      lpcv = 207
      laic = 101
      lspc = 101
      lphi = 100
      lwork = 101
!
      alpha = 0.95e0
      delta = 1.0e0
!
!     CALL THE MAIN DRIVER FOR AUTOREGRESSIVE SPECTRUM ROUTINES.
!
     call uasdv(acov, spca, spcf, lspc, iar, phi, nf, fmin, fmax, freq,&
    &   n, lagmax, ftest, aic, work, lacov, lwork, delta, isort,&
    &   isym, xaxis, yaxis, lpcv, alpha, lag, laic, lphi, nprt, var,&
     &   parzen, nmsub)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &  '       CALL UASV (ACOV, LAGMAX, N)')
      end
!VPHEAD
     subroutine vphead(nsampl, irlin, ibar,&
    &                  refpt, ywidth, ymn, ymx,&
     &                  isize, ilog, line, numcol, ilogy, ydmn, ydmx)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRINTS THE HEADING FOR THE VERTICAL PLOT OUTPUT.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   refpt,ydmn,ydmx,ymn,ymx,ywidth
     integer&
     &   ibar,ilog,ilogy,irlin,isize,nsampl,numcol
!
!  ARRAY ARGUMENTS
     character&
     &   line(103)*1
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   dely
     integer&
     &   i,icol,ik,iprt,jcol,nlably,nlu
     character&
     &   fmt*4,ylfmt*205,ylfmt2*205
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ylabel(20)
     integer&
     &   ispace(20)
     integer&
     & ilogy_(1)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LOGLMT,PRTCNT
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,log10,max,mod
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELY
!        THE SCALE INTERVAL OF THE PLOT.
!     CHARACTER FMT*4
!        *
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER ICOL, IK
!        *
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER ILOGY
!        THE VALUE OF Q (SEE ILOG)
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISIZE
!     INTEGER ISPACE(20)
!     INTEGER JCOL
!     CHARACTER*1 LINE(103)
!     INTEGER NLABLY
!     INTEGER NLU
!     INTEGER NSAMPL
!        THE SAMPLING FREQUENCY,
!        WHERE IF NSAMPL .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     INTEGER NUMCOL
!        *
!     REAL REFPT
!        THE VALUE ZERO, OR THE MEAN OF THE SERIES, WHICH EVER IS
!        REQUESTED, USED AS A PLOT REFERENCE LINE.
!     REAL YDMN, YDMX
!        THE Y-AXIS DATA LIMITS ACTUALLY USED.
!     REAL YLABEL(20)
!        THE Y-AXIS LABLES.
!     CHARACTER YLFMT*205, YLFMT2*205
!        THE FORMATS USED TO PRINT THE X-AXIS
!     REAL YMN, YMX
!        THE GRAPH AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
!     REAL YWIDTH
!        *
!
      call iprint(iprt)
!
!     CHECK PLOT SEQUENCE.
!
      if (nsampl.eq.2) then
         write(iprt, 1003)
      else if (nsampl.eq.3) then
         write(iprt, 1004)
      else if (nsampl.ge.4) then
         write(iprt, 1005) nsampl
      end if
!
!     PRINT HEADINGS FOR Y
!
      if (ibar.eq.0) then
         if (irlin.ge.1) then
            write(iprt, 1006)
         else if (irlin.eq.0) then
            write(iprt, 1007)
         end if
      end if
!
!     FIND SIZE OF PLOT TO BE CREATED
!
      if (mod(max(0,isize),10).eq.0) then
        numcol=101
      else
        numcol = 51
      end if
!
!     ADJUST FOR LOG PLOTS IF NECESSARY AND FIND AXIS LABELS
!
      call prtcnt (mod(max(0,ilog),10),1,ilogy_)
      ilogy=ilogy_(1)
     call loglmt (ilogy, ymn, ymx, ylabel, numcol, 10, dely, ywidth,&
     &  nlably, ydmn, ydmx)
!
!     WRITE OUT THE HORIZONTAL AXIS AND THE AXIS LABELS.
!
      do 330 icol=1,numcol
         line(icol)='-'
  330 continue
      line(1)='I'
      if (ilogy.eq.0) then
        nlu = nlably+1
        do 340 icol=numcol,1,-10
           line(icol)='I'
           nlu = nlu - 1
           ispace(nlu) = 1
  340   continue
      else
        jcol = 1
        line(jcol) = 'I'
        nlu = nlably
        do 345 ik = nlably,1,-1
          icol = ((log10(ylabel(ik))-ymn)/ywidth)+1.5e0
          line(icol) = 'I'
          if (icol-jcol.ge.10) then
            ispace(nlu) = icol-jcol-9
            nlu = nlu - 1
            ylabel(nlu) = ylabel(ik)
            jcol = icol
          end if
  345   continue
      end if
      line(numcol+1)='-'
      line(numcol+2)=' '
!
!     CHECK X-AXIS LABELS FOR FORMAT
!
      fmt = 'F9.4'
      do 350 i=1,nlably
        if (((abs(ylabel(i)).gt.0.0e0).and.&
    &        (abs(ylabel(i)).lt.0.01e0)) .or.&
     &       ((ylabel(i).ge.1.0e4).or.(ylabel(i).le.(-1.0e3)))) then
           fmt = 'E9.3'
           go to 355
         end if
  350 continue
  355 continue
      write(ylfmt2,1000) nlably-nlu
      write(ylfmt,ylfmt2) (fmt, ispace(i), i=nlably,nlu+1,-1), fmt
      write(iprt, ylfmt) (ylabel(i),i=nlably,nlu,-1)
!
      write(iprt, 1001) '-', (line(icol), icol=1,numcol+2)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format ('(''(11X'',', i2, '('', '', A4, '','', I2, ''X''),',&
     &  ''', '', A4, '')'')')
 1001 format (' ',13x, a1, 105a1)
 1003 format(45h0note that every other point has been plotted)
 1004 format(45h0note that every third point has been plotted)
 1005 format(17h0note that every , i2, 25hth point has been plotted)
 1006 format(/' LOCATION OF MEAN IS GIVEN BY PLOT CHARACTER M')
 1007 format(/' LOCATION OF ZERO IS GIVEN BY PLOT CHARACTER 0')
      end
!STPLSC
     subroutine stplsc(xm, n, m, ixm, mdl, par, npar, ldstak, stp,&
     &   neta, exmpt, scale, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR SELECTING STEP SIZES
!     TO BE USED IN COMPUTING FORWARD DIFFERENCE QUOTIENT ESTIMATES
!     OF THE NUMERICAL DERIVATIVES FOR THE NONLINEAR LEAST SQUARES
!     ROUTINES (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: exmpt
      integer ixm,ldstak,m,n,neta,npar,nprt
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: par(*),scale(*),stp(*),xm(*)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  SCALARS IN COMMON
      integer ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
      integer iprt,lscale
!
!  LOCAL ARRAYS
      character nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,STPDRV
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
!        PARAMETERS ARE STORED.
!     REAL SCALE(NPAR)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL STP(NPAR)
!        THE SELECTED STEP SIZES.
!     REAL XM(IXM,M)
!        THE INDEPENDENT VARIABLE ARRAY
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'S','T','P','L','S','C'/
!
!     SET LENGTH OF VECTOR SCALE.
!
      lscale = npar
!
!     PASS CONTROL TO STEP SIZE SELECTION DRIVER
!
     call stpdrv(nmsub, xm, n, m, ixm, mdl, par, npar, ldstak, stp,&
     &   neta, exmpt, scale, lscale, nprt)
!
      if (ierr.ne.1) return
!
      call iprint(iprt)
      write (iprt,1000)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    & '       CALL STPLSC (XM, N, M, IXM, NLSMDL, PAR, NPAR, LDSTAK,',&
    & ' STP,'/&
     & '      +             NETA, EXMPT, SCALE, NPRT)')
      end
!SPPC
     subroutine sppc(ym, x, n, isym, ilog, isize, nout, ylb, yub,&
     &  xlb, xub)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH USER CONTROL OF PLOT SYMBOLS (LONG CALL).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   xlb,xub,ylb,yub
     integer&
     &   ilog,isize,n,nout
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),ym(*)
     integer&
     &   isym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xmiss
     integer&
     &   iprt,ischck,iym,lisym,m
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ymmiss(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'S',       'P',       'P',       'C',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      ymmiss(1) = 1.0e0
      xmiss = 1.0e0
      m = 1
      iym = n
      multi = .false.
      ischck = 1
      miss = .false.
      lisym = n
!
     call ppcnt (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &  '       CALL SPPC (Y, X, N, ISYM, ILOG,'/&
     &  '      +           ISIZE, NOUT, YLB, YUB, XLB, XUB)')
      end
!SUMIDW
      subroutine sumidw(x, w, n, xmeanw, sumdi)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO CALCULATE THE SUM OF THE PRODUCTS OF I AND THE I TH
!     DIFFERENCE AMONG THE ELEMENTS OF THE VECTOR X - XMEANW WHICH
!     ARE NOT WEIGHTED ZERO.  (ELEMENTS WEIGHTED ZERO DO NOT
!     PRODUCE AN INCREMENT IN I.)
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   sumdi,xmeanw
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   w(n),x(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   diff,i
     integer&
     &   k
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DIFF
!        THE DIFFERENCE OF A VALUE OF X AND THE WEIGHTED MEAN OF X.
!     REAL I
!        I COUNTS FROM 1 TO THE NUMBER OF NON-ZERO WEIGHTED ELEMENTS
!        FOUND IN X.
!     INTEGER K
!        A LOOP INDEX.
!     INTEGER N
!        INPUT PARAMETER.  THE NUMBER OF ELEMENTS IN X.
!     REAL SUMDI
!        OUTPUT PARAMETER.  THE SUM OF THE PRODUCTS OF I AND THE
!        NON-ZERO WEIGHTED ELEMENTS OF THE VECTOR X - XMEANW.
!     REAL W(N)
!        INPUT PARAMETER.  THE WEIGHTS VECTOR FOR X.
!     REAL X(N)
!        INPUT PARAMETER.  THE VECTOR OF N DATA VALUES.
!     REAL XMEANW
!        INPUT PARAMETER.  THE WEIGHTED MEAN OF X.
!
      i = 0.0e0
      sumdi = 0.0e0
      do 10 k=1,n
         if (w(k).eq.0.0e0) go to 10
         diff = x(k) - xmeanw
         i = i + 1.0e0
         sumdi = sumdi + i*diff
   10 continue
      return
      end
!UFSMN
     subroutine ufsmn(acov, nlppa, lag, df, nf, freq, alpha, bw, spcf,&
     &   alow, aup, lacov, ispcf, window, w, lw, n, delta, miss, lnlppa)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR COMPUTING AUTOCORRELATIONS AND
!     PARTIAL AUTOCORRELATIONS OF A TIME SERIES
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   alow,alpha,aup,bw,delta,df
     integer&
     &   ispcf,lacov,lag,lnlppa,lw,n,nf
     logical&
     &   miss
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(lacov),freq(nf),spcf(ispcf),w(lw)
     integer&
     &   nlppa(lnlppa)
!
!  SUBROUTINE ARGUMENTS
       external window
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   ppfchs
!       EXTERNAL PPFCHS
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL DFBW,DFBWM,UFSEST
!
!  INTRINSIC FUNCTIONS
      intrinsic nint
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV)
!        THE AUTOCOVARIANCES OF THE SERIES.
!     REAL ALOW
!        A FACTOR USED TO COMPUTE THE LOWER CONFIDENCE LIMITS.
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL AUP
!        A FACTOR USED TO COMPUTE THE UPPER CONFIDENCE LIMITS.
!     REAL BW
!        THE BANDWIDTH.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL DF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER LACOV
!        THE LENGTH OF VECTOR ACOV.
!     INTEGER LAG
!        THE VARIABLE INDICATING THE LAG VALUE BEING EXAMINED.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     LOGICAL MISS
!        AN INDICATOR VARIABLE WHICH DESIGNATES WHETHER THERE ARE
!        MISSING VALUES (TRUE) OR NOT (FALSE)
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE TIME SERIES.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(LNLPPA)
!        THE NUMBERS OF LAGGED PRODUCT PAIRS IN EACH ACVF VALUE.
!     REAL SPCF(ISPCF)
!        THE ARRAY IN WHICH THE SPECTRUM IS STORED.
!     REAL W(LW)
!        THE VECTOR OF LAG WINDOWS.
!     EXTERNAL WINDOW
!        THE NAME OF THE WINDOW COMPUTING SUBROUTINE.
!
!     COMPUTE THE WINDOW, EFFECTIVE DEGREES OF FREEDOM AND
!     BANDWIDTH BASED ON THE WINDOW.
!
      call window(lag, w, lw)
      if (.not.miss) call dfbw(n, lag, w, lw, df, bw)
      if (miss) call dfbwm(n, lag, w, lw, nlppa, nlppa, lnlppa, df, bw)
!
!     COMPUTE THE SPECTRUM
!
      call ufsest(acov, w, lag, spcf, ispcf, lacov, lw, nf, freq, delta)
!
!     COMPUTE -ALPHA- PERCENT POINT FUNCTION VALUE FOR
!     SPECTRUM WINDOW BEING USED.
!
      alow = df/ppfchs(0.5e0+alpha/2.0e0,nint(df))
      aup = df/ppfchs(0.5e0-alpha/2.0e0,nint(df))
!
      return
      end
!DRV1A
      subroutine drv1a(coef, ncoef, xm, n, m, ixm, d)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DERIVATIVE FUNCTION FOR NLS FAMILY EXERCISER SUBROUTINE MDL1
!     CODED CORRECTLY.
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,m,n,ncoef
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   coef(ncoef),d(n,ncoef),xm(ixm,m)
!
!  LOCAL SCALARS
     integer&
     &   i
!
!  INTRINSIC FUNCTIONS
      intrinsic log
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL COEF(NCOEF)
!        MODEL COEFFICIENTS
!     REAL D(N,NCOEF)
!        THE FIRST DERIVATIVE WITH RESPECT TO THE ITH COEFFICIENT
!     INTEGER I
!        ROW MARKER
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLESC
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NCOEF
!        THE NUMBER OF COEFFICIENTS
!     REAL XM(IXM,M)
!        INDEPENDENT VARIABLES
!
!
      do 10 i=1,n
         d(i,1) = xm(i,1)**coef(2)
         d(i,2) = coef(1)*(xm(i,1)**coef(2))*log(xm(i,1))
   10 continue
!
      return
!
      end
!SUMSS
      subroutine sumss(x, n, lo, mid, hi, sum1, sum2, suma, xmean)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO CALCULATE SUMS OF POWERS AND THE MEAN
!     FOR A SORTED VECTOR IN WHICH THE MIDTH ELEMENT IS
!     THE ELEMENT CLOSEST TO ZERO.  USED BY THE STAT
!     FAMILY.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   sum1,sum2,suma,xmean
     integer&
     &   hi,lo,mid,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(n)
!
!  LOCAL SCALARS
     integer&
     &   curhi,curlo,i,irev
!
!  INTRINSIC FUNCTIONS
      intrinsic abs
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CURHI
!        THE UPPER BOUND OF THE CURRENT INTERVAL.
!     INTEGER CURLO
!        THE LOWER BOUND OF THE CURRENT INTERVAL.
!     INTEGER HI
!        INPUT PARAMETER.  THE UPPER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER I
!        LOOP PARAMETER.
!     INTEGER IREV
!        A VARIABLE WHICH RUNS IN THE SAME INTERVAL AS I, BUT
!        IN THE REVERSE ORDER.
!     INTEGER LO
!        INPUT PARAMETER.  THE LOWER BOUND OF THE INITIAL INTERVAL.
!     INTEGER MID
!        INPUT PARAMETER.  THE INDEX OF THE ELEMENT IN X CLOSEST TO
!        ZERO IN VALUE.  THE POINT OUT FROM WHICH THE SUMMING IS
!        DONE.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
!     REAL SUMA
!        OUTPUT PARAMETER.  THE SUM OF THE ABSOLUTE VALUES OF THE
!        ELEMENTS OF X.
!     REAL SUM1
!        OUTPUT PARAMETER.  THE SUM OF THE ELEMENTS OF X.
!     REAL SUM2
!        OUTPUT PARAMETER.  THE SUM OF THE SQUARES OF THE
!        ELEMENTS OF X.
!     REAL X(N)
!        INPUT PARAMETER.  THE DATA ARRAY X OVER WHICH THE SUMS ARE
!        TAKEN.
!     REAL XMEAN
!        OUTPUT PARAMETER.  THE UNWEIGHTED MEAN OF X.
!
!     INITIALIZE SUMMATION VARIABLES.
!
      sum1 = x(mid)
      sum2 = x(mid)*x(mid)
      suma = abs(x(mid))
      curlo = mid - 1
      curhi = mid + 1
!
!     SUM OUTWARDS FROM THE VALUE NEAREST ZERO.  THAT IS, SUM FROM
!     THE LEAST IN MAGNITUDE TO THE GREATEST.
!
   10 if (curhi.gt.hi .or. curlo.lt.lo) go to 30
      if (abs(x(curhi)).lt.abs(x(curlo))) go to 20
      sum1 = sum1 + x(curlo)
      sum2 = sum2 + x(curlo)*x(curlo)
      suma = suma + abs(x(curlo))
      curlo = curlo - 1
      go to 10
   20 sum1 = sum1 + x(curhi)
      sum2 = sum2 + x(curhi)*x(curhi)
      suma = suma + abs(x(curhi))
      curhi = curhi + 1
      go to 10
!
!     SUM UP ANY VALUES WHICH MAY REMAIN BECAUSE OF AN OFF
!     CENTER ZERO POINT.
!
   30 if (curhi.gt.hi) go to 50
      do 40 i=curhi,hi
         sum1 = sum1 + x(i)
         sum2 = sum2 + x(i)*x(i)
         suma = suma + abs(x(i))
   40 continue
   50 if (curlo.lt.lo) go to 70
      do 60 irev=lo,curlo
         i = lo - irev + curlo
         sum1 = sum1 + x(i)
         sum2 = sum2 + x(i)*x(i)
         suma = suma + abs(x(i))
   60 continue
   70 xmean = sum1/(hi-lo+1)
      return
      end
!NLSWC
     subroutine nlswc(y, wt, xm, n, m, ixm, mdl, par, npar, res,&
    &   ldstak, ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx,&
     &   nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
!     AND WEIGHTS (CONTROL CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,stopp,stopss
     integer&
     &   ivaprx,ixm,ldstak,m,mit,n,npar,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),res(*),scale(*),stp(*),wt(*),xm(*),y(*)
     integer&
     &   ifixed(*)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   rsd
     integer&
    &   iprt,ivcv,lifixd,lpv,lscale,lsdpv,lsdres,lstp,lwt,nnzw,&
     &   npare
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   pv(1),sdpv(1),sdres(1),vcv(1,1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,NLCNTN
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(NPAR)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(NPAR)
!        THE STEP SIZE ARRAY.
!     REAL VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(N)
!        THE WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'N','L','S','W','C',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      weight = .true.
      save = .false.
!
      lifixd = npar
      lpv = 1
      lscale = npar
      lstp = npar
      lsdpv = 1
      lsdres = 1
      lwt = n
      ivcv = 1
!
     call nlcntn(y, wt, lwt, xm, n, m, ixm, mdl, par, npar, res,&
    &   ldstak, ifixed, lifixd, stp, lstp, mit, stopss, stopp, scale,&
    &   lscale, delta, ivaprx, nprt, rsd, pv, lpv, sdpv, lsdpv, sdres,&
     &   lsdres, vcv, ivcv, nmsub, weight, save, nnzw, npare)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL NLSWC (Y, WT, XM, N, M, IXM, NLSMDL,'/&
    &   '      +            PAR, NPAR, RES, LDSTAK,'/&
    &   '      +            IFIXED, STP, MIT, STOPSS, STOPP, SCALE,'/&
     &   '      +            DELTA, IVAPRX, NPRT)')
      end
!LLCNT
     subroutine llcnt(y, wt, lwt, xm, n, m, ixm, npar, res, ldstak,&
    &   nprt, par, lpar, rsd, pv, lpv, sdpv, lsdpv, sdres, lsdres, vcv,&
     &   ivcv, llhdr, ifit, nmsub, weight, save)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR LINEAR LEAST
!     SQUARES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rsd
     integer&
    &   ifit,ivcv,ixm,ldstak,lpar,lpv,lsdpv,lsdres,lwt,m,n,npar,&
     &   nprt
     logical&
     &   save,weight
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),pv(*),res(*),sdpv(*),sdres(*),vcv(*),wt(*),xm(*),y(*)
     character&
     &   nmsub(6)*1
!
!  SUBROUTINE ARGUMENTS
       external llhdr
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
    &   acc,c,fc,ifp,nall0,ndigit,nnzw,par1,pari,pvi,red,resi,&
     &   rsdi,sdpvi,sdresi,t,vcvi,wti,wy,xmw
     logical&
     &   page,wide
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   iptout(4),istak(12)
!
!  EXTERNAL FUNCTIONS
     integer&
     &   stkst
!       EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL CPYMSS,LLER,LLSMN,PRTCNT,SETRV,STKCLR,STKSET
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER ACC
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE NUMBER OF ACCURATE DIGITS.
!     INTEGER C
!        *
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER FC
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE ORTHONORMALIZATION MATRIX.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IFIT
!        THE INDICATOR VALUE DESIGNATING WHETHER THE FIT IS OF A
!        GENERAL MODEL (IFIT=3) OR A POLYNOMIAL MODEL (IFIT=1).
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IPTOUT(4)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     EXTERNAL LLHDR
!        THE NAME OF THE ROUTINE THAT PRODUCED THE HEADING.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        NUMBER OF ALLOCATIONS ON ENTRY.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(LPAR)
!        THE PARAMETERS TO BE ESTIMATED.
!     INTEGER PARI
!        THE STARTING LOCATION IN THE WORK AREA OF
!        THE PARAMETERS TO BE ESTIMATED.
!     INTEGER PAR1
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE PARAMETERS TO BE ESTIMATED OMMITTING THE LAST
!        INDEPENDENT VARIABLE.
!     REAL PV(LPV)
!        THE PREDICTED VALUES.
!     INTEGER PVI
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE PREDICTED VALUES.
!     INTEGER RED
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE REDUCTION TO THE SUM OF SQUARES DUE TO EACH PARAMETER.
!     REAL RES(N)
!        THE RESIDUALS.
!     INTEGER RESI
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE RESIDUALS.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     INTEGER RSDI
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE RESIDUAL STANDARD DEVIATION.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     REAL SDPV(LSDPV)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     INTEGER SDPVI
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(LSDRES)
!        THE STANDARDIZED RESIDUALS.
!     INTEGER SDRESI
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE STANDARDIZED RESIDUALS.
!     INTEGER T
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE TRIANGULAR MATRIX FROM THE DECOMPOSITION.
!     REAL VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     INTEGER VCVI
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL WT(LWT)
!        THE WEIGHTS.
!     INTEGER WTI
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE WEIGHTS.
!     INTEGER WY
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE VECTOR CONTAINING SQRT(WT)*Y.
!     REAL XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!     INTEGER XMW
!        THE STARTING LOCATION IN THE WORK AREA FOR
!        THE MATRIX CONTAINING XM * SQRT(WT).
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!
      wide = .true.
      page = .false.
      ndigit = 4
!
      ifp = 3
!
!     SET PRINT CONTROL VALUES
!
      call prtcnt(nprt, ndigit, iptout)
!
!     CHECK FOR ERRORS
!
     call ller(nmsub, ixm, ivcv, n, npar, lpar, ldstak, wt, lwt,&
     &   weight, nnzw, ifit, save)
      if (ierr.ne.0) return
!
      call stkset(ldstak, 4)
      nall0 = stkst(1)
!
!     SET UP SUBDIVISION OF WORK AREAS
!
      wti = stkget(n,ifp)
      resi = stkget(n,ifp)
      rsdi = stkget(1,ifp)
      pari = stkget(npar,ifp)
      pvi = stkget(n,ifp)
      sdpvi = stkget(n,ifp)
      sdresi = stkget(n,ifp)
      vcvi = stkget(npar*npar,ifp)
!
      wy = stkget(n,ifp)
      xmw = stkget(n*npar,ifp)
      red = stkget(npar,ifp)
      t = stkget(npar*npar,ifp)
      par1 = stkget(npar,ifp)
      acc = stkget(npar,ifp)
      c = stkget(npar,ifp)
!
!     EQUIVALENCED LOCATIONS WITHIN SCRAT
!
      fc = xmw
!
!     SET UP WEIGHTS VECTOR
!
      if (weight) then
         call scopy(n, wt, 1, rstak(wti), 1)
      else
         call setrv(rstak(wti), n, 1.0e0)
      end if
!
     call llsmn(y, xm, rstak(wti), n, m, npar, ixm, rstak(resi),&
    &   rstak(pari), nnzw, rstak(rsdi), rstak(pvi), rstak(sdpvi),&
    &   rstak(sdresi), iptout, rstak(wy), rstak(xmw), rstak(vcvi),&
    &   rstak(fc), rstak(red), rstak(t), rstak(par1), rstak(acc), ifit,&
     &   weight, rstak(c), llhdr, page, wide)
!
      call scopy(n, rstak(resi), 1, res, 1)
!
      if (save) then
         rsd = rstak(rsdi)
         call scopy(npar, rstak(pari), 1, par, 1)
         call scopy(n, rstak(pvi), 1, pv, 1)
         call scopy(n, rstak(sdpvi), 1, sdpv, 1)
         call scopy(n, rstak(sdresi), 1, sdres, 1)
         call cpymss(npar, npar, rstak(vcvi), npar, vcv, ivcv)
      end if
      call stkclr(nall0)
!
      if (ierr.eq.3) ierr = 2
      if (ierr.eq.4) ierr = 3
!
      return
!
      end
!DOTC
      subroutine dotc (y, ymean, ny, x, xmean, nx, dotxy, ndotxy)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE DOT PRODUCT OF TWO
!     SERIES, CENTERED ABOUT THEIR RESPECTIVE MEANS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   dotxy,xmean,ymean
     integer&
     &   ndotxy,nx,ny
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(nx),y(ny)
!
!  LOCAL SCALARS
     integer&
     &   i,m
!
!  INTRINSIC FUNCTIONS
      intrinsic min
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DOTXY
!        THE DOT PRODUCT OF THE SERIES (Y(I) - YMEAN) AND
!        (X(I) - XMEAN).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER M
!        THE SMALLER OF THE NUMBER OF OBSERVATIONS IN X AND Y
!     INTEGER NDOTXY
!        THE NUMBER OF OBSERVATIONS USED TO COMPUTE DOTXY
!     INTEGER NX, NY
!        THE NUMBER OF OBSERVATIONS IN SERIES X AND Y, RESPECTIVELY.
!     REAL X(NX)
!        THE VECTOR CONTAINING THE SECOND SERIES
!     REAL XMEAN
!        THE MEAN OF THE SECOND SERIES.
!     REAL Y(NY)
!        THE VECTOR CONTAINING THE FIRST SERIES
!     REAL YMEAN
!        THE MEAN OF THE FIRST SERIES.
!
      ndotxy = 0
      dotxy = 0.0e0
      m = min(ny, nx)
      do 10 i = 1, m
         dotxy = dotxy + (y(i) - ymean) * (x(i) - xmean)
         ndotxy = ndotxy + 1
   10 continue
      return
      end
!XXCH5
      subroutine xxch5(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE STATISTICAL ANALYSIS FAMILY OF ROUTINES.
!
!     DATA SET IS FROM PAGE 39 OF MANDEL [1964]
!
!     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,n
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   y(40)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,STAT
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        ERROR FLAG
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER N
!        THE LENGTH OF THE VECTOR Y.
!     REAL Y(40)
!        DATA VECTOR FOR TESTS.
!
!     DATA INITIALIZATIONS.
!
      data n /39/
!
     data y( 1), y( 2), y( 3), y( 4)&
     &    / 0.4, 0.6, 1.0, 1.0/
     data y( 5), y( 6), y( 7), y( 8)&
     &    / 1.0, 0.5, 0.6, 0.7/
     data y( 9), y(10), y(11), y(12)&
     &    / 1.0, 0.6, 0.2, 1.9/
     data y(13), y(14), y(15), y(16)&
     &    / 0.2, 0.4, 0.0, -0.4/
     data y(17), y(18), y(19), y(20)&
     &    / -0.3, 0.0, -0.4, -0.3/
     data y(21), y(22), y(23), y(24)&
     &    / 0.1, -0.1, 0.2, -0.5/
     data y(25), y(26), y(27), y(28)&
     &    / 0.3, -0.1, 0.2, -0.2/
     data y(29), y(30), y(31), y(32)&
     &    / 0.8, 0.5, 0.6, 0.8/
     data y(33), y(34), y(35), y(36)&
     &    / 0.7, 0.7, 0.2, 0.5/
     data y(37), y(38), y(39)&
     &    / 0.7, 0.8, 1.1/
!
!     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
!
      call iprint(iprt)
!
!     PRINT HEADING
!
      write (iprt,1000)
!
!     PERFORM SIMPLE TEST OF STAT
!
      write (iprt,1100)
      call stat(y, n, ldstak)
      write (iprt,2000) ierr
!
      return
!
!     FORMATS
!
 1000 format ('1*CH5')
 1100 format (' SIMPLE TEST OF STAT')
 2000 format (/' THE VALUE OF IERR IS ', i4)
      end
!AMEOUT
     subroutine ameout(y, n, ifixd,&
    &   par, npar, npare, res, iptout, ndigit, page, idf, cond, rss,&
    &   rsd, yss, exact, pvt, sdpvt, sdrest, vcvl, lvcvl, ivcvpt,&
     &   iskull, amehdr, wide)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PRINTS THE FINAL SUMMARY OUTPUT FROM THE
!     ARIMA ESTIMATION SUBROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   cond,rsd,rss,yss
     integer&
     &   idf,ivcvpt,lvcvl,n,ndigit,npar,npare
     logical&
     &   exact,page,wide
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),pvt(*),res(*),sdpvt(*),sdrest(*),vcvl(*),y(*)
     integer&
     &   ifixd(*),iptout(*),iskull(10)
!
!  SUBROUTINE ARGUMENTS
       external amehdr
!
!  SCALARS IN COMMON
     integer&
    &   ierr,iflag,mbo,mbol,mspect,nfact,nparar,npardf,nparma,&
     &   nrests,parar,pardf,parma,t,temp
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm
     integer&
     &   i,iamhd,iprt,isubhd
!
!  LOCAL ARRAYS
     integer&
     &   istak(12)
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AMEPT1,AMEPT2,AMLST,IPRINT,MODSUM,NLSKL,VCVOTF
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
     common /mdltsc/mspect,nfact,pardf,npardf,parar,nparar,parma,&
     &   nparma,mbo,mbol,t,temp,nrests,iflag
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL COND
!        THE CONDITION NUMBER OF D.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL EXACT
!        AN INDICATOR VALUE USED TO DESIGNATE WHETHER THE FIT
!        WAS EXACT TO MACHINE PRECISION (TRUE) OR NOT (FALSE).
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     EXTERNAL AMEHDR
!        THE ROUTINE USED TO PRINT THE HEADING
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IAMHD
!        THE INDICATOR VALUE USED TO DESIGNATE THE TYPE OF LIST
!        TO BE GENERATED
!        IF IAMHD=1, THE LIST IS FOR THE INITIAL SUMMARY OF THE
!                    ESTIMATION ROUTINES.
!        IF IAMHD=2, THE LIST IS FOR THE INITIAL REPORT OF THE
!                    FORECASTING ROUTINES.
!        IF IAMHD=3, THE LIST IS FOR THE FINAL REPORT OF THE
!                    ESTIMATION ROUTINES.
!     INTEGER IDF
!        THE DEGREES OF FREEDOM IN THE FIT.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IPTOUT(NDIGIT)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER ISKULL(10)
!        AN ERROR MESSAGE INDICATOR VARIABLE.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IVCVPT
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH FORM OF THE
!        VARIANCE COVARIANCE MATRIX (VCV) IS BEING PRINTED, WHERE
!        IVCVPT = 1 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!        IVCVPT = 2 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)
!        IVCVPT = 3 INDICATES THE VCV WAS COMPUTED AS
!                   INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                       *INVERSE(HESSIAN)
!     INTEGER LVCVL
!        THE DIMENSION OF VECTOR VCVL.
!     INTEGER MBO
!        THE MAXIMUM BACK ORDER OPERATOR.
!     INTEGER MBOL
!        THE MAXIMUM BACK ORDER ON THE LEFT
!     INTEGER MSPECT
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     INTEGER NFACT
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARAR
!        THE NUMBER OF AUTOREGRESSIVE PARAMETERS
!     INTEGER NPARDF
!        THE ORDER OF THE EXPANDED DIFFERENCE FILTER.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NPARMA
!        THE LENGTH OF THE VECTOR PARMA
!     INTEGER NRESTS
!        THE MAXIMUM NUMBER OF RESIDUALS TO BE COMPUTED.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     INTEGER PARAR
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE AUTOREGRESSIVE PARAMETERS
!     INTEGER PARDF
!        THE STARTING LOCATION IN THE WORK SPACE FOR
!        THE VECTOR CONTAINING THE DIFFERENCE FILTER PARAMETERS
!     INTEGER PARMA
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        THE MOVING AVERAGE PARAMETERS
!     REAL PVT(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES.
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     REAL RSS
!        THE RESIDUAL SUM OF SQUARES.
!     REAL SDPVT(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDREST(N)
!        THE STANDARDIZED RESIDUALS.
!     INTEGER T
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR.
!     INTEGER TEMP
!        THE STARTING LOCATION IN THE WORK ARRAY FOR
!        A TEMPORARY WORK VECTOR
!     REAL VCVL(LVCVL)
!        THE LOWER HALF OF THE VARIANCE-COVARIANCE MATRIX, STORED
!        ROW WISE.
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!     REAL YSS
!        THE SUM OF THE SQUARES ABOUT THE MEAN Y VALUE.
!
!
      fplm = r1mach(2)
!
      call iprint(iprt)
!
      if ((ierr.ge.1) .and. (ierr.ne.4)) go to 60
!
!     TEST FOR EXACT FIT
!
      if ((idf.le.0) .or. exact) go to 70
!
!     PRINT ERROR HEADING IF NECESSARY
!
      if (ierr.eq.4) call nlskl(iskull, page, wide, amehdr)
!
!     PRINT PRIMARY REPORT
!
      if ((ierr.eq.0) .and. (iptout(3).eq.0)) go to 10
      isubhd = 0
      call amehdr(page, wide, isubhd)
      call amept1(n, y, pvt, sdpvt, res, sdrest, iptout, ndigit)
!
!     PRINT STANDARDIZED RESIDUAL PLOTS
!
   10 if (iptout(4).eq.0) go to 20
      isubhd = 0
      call amehdr(page, wide, isubhd)
!
      call amept2 (res, sdrest, n, rss)
!
!     PRINT THE COVARIANCE AND CORRELATION MATRIX
!
   20 if ((ierr.eq.0) .and. (iptout(5).eq.0)) return
      isubhd = 0
      call amehdr(page, wide, isubhd)
      call modsum(nfact, istak(mspect))
!
      if ((ierr.eq.0) .and. (iptout(5).le.1)) go to 30
!
      call vcvotf(npare, vcvl, lvcvl, .true., npar, ifixd, ivcvpt)
!
!     PRINT ANALYSIS SUMMARY
!
   30 write (iprt,1000)
      iamhd = 3
     call amlst(iamhd, par, npar, nfact, istak(mspect), n, vcvl, lvcvl,&
     &   par, npar, par, npar, ifixd, rss, rsd, npardf, npare, idf)
      write (iprt,1050) cond
!
      if (rss.gt.yss) write (iprt,1060)
!
      return
!
!     PRINT OUT ERROR HEADING
!
   60 call nlskl(iskull, page, wide, amehdr)
!
      if (ierr.le.2) return
!
!     PRINT SECONDARY REPORT
!
   70 continue
      isubhd = 0
      call amehdr(page, wide, isubhd)
      call modsum(nfact, istak(mspect))
      if (ierr.ne.0) write (iprt,1080)
      write (iprt,1000)
      iamhd = 2
     call amlst(iamhd, par, npar, nfact, istak(mspect), n, vcvl, lvcvl,&
     &   par, npar, par, npar, ifixd, rss, rsd, npardf, npare, idf)
      if (ierr.ne.3) write (iprt,1050) cond
!
     if ((ierr.eq.0) .and. (.not.exact) .and. (idf.le.0)) write&
     &   (iprt,1070)
      if ((ierr.eq.0) .and. exact) write (iprt,1090)
!
      if (ierr.ne.0) go to 100
!
      do 90 i=1,n
         sdrest(i) = 0.0e0
         sdpvt(i) = 0.0e0
   90 continue
!
      return
!
  100 continue
!
      do 110 i=1,n
         sdrest(i) = fplm
         sdpvt(i) = fplm
  110 continue
!
!     PRINT OUT ERROR EXIT STATISTICS
!
      call amept1(n, y, pvt, sdpvt, res, sdrest, iptout, ndigit)
!
!     WIPE OUT SDREST VECTOR
!
      do 120 i=1,n
         sdrest(i) = fplm
  120 continue
!
!     WIPE OUT VCV MATRIX
!
      do 140 i=1,lvcvl
         vcvl(i) = fplm
  140 continue
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format (///33h estimates from least squares fit/1x, 33('-'))
 1050 format (/29h approximate condition number, 10x, g15.7)
1060 format (//52h the residual sum of squares after the least squares,&
    &   20h fit is greater than/35h the sum of squares about the mean ,&
    &   19hy observation.  the, 14h model is less/17h representative o,&
    &   39hf the data than a simple average.  data, 15h and model shou,&
     &   2hld/48h be checked to be sure that they are compatable.)
1070 format (/49h the degrees of freedom for this problem is zero.,&
     &   54h  statistical analysis of the results is not possible.)
1080 format (//40h the following summary should be used to, 8h analyze,&
     &   30h the above mentioned problems.)
1090 format (/50h the least squares fit of the data to the model is,&
    &   35h exact to within machine precision./20h statistical analysi,&
     &   33hs of the results is not possible.)
      end
!MDL3
      subroutine mdl3(par, npar, xm, n, m, ixm, pv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     MODEL FUNCTION FOR NLS EXERCISER
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),pv(n),xm(ixm,m)
!
!  LOCAL SCALARS
     integer&
     &   i
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        ROW INDEX
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     INTEGER M
!        NUMBER OF VARIABLES
!     INTEGER N
!        NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        NUMBER OF PARAMETERS
!     REAL PAR(NPAR)
!        MODEL PARAMETERS
!     REAL PV(N)
!        PREDICTED VALUES
!     REAL XM(IXM,M)
!        INDEPENDENT VARIABLES
!
      do 10 i=1,n
        pv(i) = par(1)*xm(i,1) + par(2)*xm(i,2) + par(3)*xm(i,3) +&
     &      par(4)*xm(i,4) + par(5)*xm(i,5)
   10 continue
      return
      end
!HSTER
      subroutine hster(nmsub, y, n, ncells, ldstak, ylb, yub, ierr)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE CHECKS INPUT PARAMETERS TO THE USER
!     CALLABLE MEMBERS OF THE HIST FAMILY OF ROUTINES
!     FOR ERRORS AND REPORTS ANY THAT IT FINDS, BESIDES
!     RETURNING A FLAG INDICATING THAT ERRORS HAVE BEEN
!     FOUND.
!
!     WRITTEN BY - JOHN E. KOONTZ, JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ylb,yub
     integer&
     &   ierr,ldstak,n,ncells
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*)
     character&
     &   nmsub(6)*1
!
!  LOCAL SCALARS
     integer&
     &   ldsmin,nv
     logical&
     &   head,ier1,ier2,ier3,ier4
!
!  LOCAL ARRAYS
     character&
     &   llds(8)*1,ln(8)*1,lone(8)*1,ly(8)*1
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL EISGE,ERVII,LDSCMP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        OUTPUT PARAMETER.  A FLAG INDICATING WHETHER OR
!        NOT AN ERROR HAS BEEN FOUND.  0 = OK, 1 = ERROR.
!     LOGICAL IER1
!        TRUE IF N .LT. 3
!     LOGICAL IER2
!        TRUE IF LDSTAK .LT. (N + 13)/2.
!     LOGICAL IER3
!        TRUE IF ALL Y VALUES ARE EQUAL.
!     LOGICAL IER4
!        TRUE IF NO DATA WITHIN USER LIMITS
!     INTEGER LDSMIN
!        MINIMUM LENGTH OF FRAMEWORK AREA IN DOUBLE
!        PRECISION ELEMENTS.
!     INTEGER LDSTAK
!        INPUT PARAMETER.  THE NUMBER OF LOCATIONS PROVIDED IN
!        THE FRAMEWORK AREA.
!     CHARACTER*1 LLDS(8), LN(8), LONE(8), LY(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) FO THE VARIALBE(S) CHECKED
!        FOR ERRORS
!     INTEGER N
!        INPUT PARAMETER.  THE NUMBER OF ELEMENTS IN Y.
!     INTEGER NCELLS
!        THE NUMBER OF CELLS IN THE HISTOGRAM.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE CALLING SUBROUTINE
!     INTEGER NV
!        THE NUMBER OF VALUES OUTSIDE USER SUPPLIED LIMITS.
!     REAL Y(N)
!        INPUT PARAMETER.  THE VECTOR OF N OBSERVATIONS.
!     REAL YLB
!        THE LOWER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!     REAL YUB
!        THE UPPER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!
!     INITIALIZE NAME VECTORS
!
     data   llds(1),  llds(2),  llds(3),  llds(4),  llds(5),  llds(6),&
     &  llds(7), llds(8) /'L', 'D', 'S', 'T', 'A', 'K', ' ', ' '/
     data     ln(1),    ln(2),    ln(3),    ln(4),    ln(5),    ln(6),&
     &    ln(7),   ln(8) /'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
     data   lone(1),  lone(2),  lone(3),  lone(4),  lone(5),  lone(6),&
     &  lone(7), lone(8) /'O', 'N', 'E', ' ', ' ', ' ', ' ', ' '/
     data     ly(1),    ly(2),    ly(3),    ly(4),    ly(5),    ly(6),&
     &    ly(7),   ly(8) /'Y', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
!
!     INITIALIZE ERROR FLAGS
!
      ier1 = .false.
      ier2 = .false.
      ier3 = .false.
      ier4 = .false.
!
      ierr = 0
!
      head = .true.
!
!     CHECK TO SEE THAT THERE IS AT LEAST ONE DATA POINTS.
!
      call eisge(nmsub, ln, n, 1, 2, head, ier1, lone)
!
!     CHECK FOR SUFFICIENT WORK AREA
!
      call ldscmp(2, 0, n, 0, 0, 0, 'S', ncells, ldsmin)
!
      call eisge(nmsub, llds, ldstak, ldsmin, 9, head, ier2, llds)
!
!     CHECK WHETHER THERE IS ANY DATA BETWEEN USER SUPPLIED LIMITS
!
     if ((ylb.lt.yub) .and. (n.ge.1))&
     &  call ervii (nmsub, ly, y, n, ylb, yub, n-1, head, 1, nv, ier4)
!
!     SEE IF ANY ERRORS WERE FOUND.
!
      if (ier1 .or. ier2 .or. ier3 .or. ier4) ierr = 1
      return
      end
!FLTMD
      subroutine fltmd (x, y, n, kmd, sym)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE APPLIES ONE MODIFIED DANIEL FILTERS TO A SYMMETRIC
!     SERIES.  THIS ROUTINE IS ADAPTED FROM BLOOMFIELDS ROUTINE MODDAN.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   sym
     integer&
     &   kmd,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(n),y(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   con
     integer&
     &   i,j,kused,lim
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   extend
!       EXTERNAL EXTEND
!
!  INTRINSIC FUNCTIONS
      intrinsic mod
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CON
!        A FACTOR USED IN THE COMPUTATIONS.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER J
!        AN INDEXING VARIABLE.
!     INTEGER KMD
!        THE INPUT FILTER LENGTH.
!     INTEGER KUSED
!        THE FILTER LENGTH ACTUALLY USED.
!     INTEGER LIM
!        A LOOP LIMIT.
!     INTEGER N
!        THE NUMBER OF POINTS IN THE SERIES TO BE FILTERED.
!     REAL SYM
!        AN INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE SERIES
!        IS SYMMETRIC (SYM = 1.0E0) OR NOT (SYM = -1.0E0).
!     REAL X(N)
!        ON INPUT, THE SERIES TO BE FILTERED.  ON OUTPUT, THE
!        SMOOTHED SERIES.
!     REAL Y(N)
!        ON INPUT, A WORK VECTOR.  ON OUTPUT, THE INPUT SERIES X.
!
!
      do 10 i = 1, n
         y(i) = x(i)
   10 continue
!
      if (kmd .le. 0) return
!
      kused = kmd + mod(kmd,2)
      if (kused .gt. n) kused = kused - 2
!
      lim = kused-1
      con = 1.0e0 / (2*kused)
      do 40 i = 1, n
         x(i) = y(i)
         if (lim .eq. 0) go to 30
         do 20 j = 1, lim
           x(i) = x(i) + extend(y, i-j, n, sym)&
     &         + extend(y, i+j, n, sym)
   20    continue
  30    x(i) = (x(i) + (extend(y, i-kused, n, sym)&
     &      + extend(y, i+kused, n, sym)) * 0.5e0) * con
   40 continue
!
      return
!
      end
!GENR
      subroutine genr(rvect, n, rinit, rstp)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     PUT VALUES RINIT STEP RSTP THROUGH RINIT + (N - 1)*RSTP INTO
!     A VECTOR RVECT OF LENGTH N.  NO ERROR CHECKING IS DONE.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING LAB/BOULDER
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rinit,rstp
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   rvect(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   r
     integer&
     &   j
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER J
!        LOOP PARAMETER.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF RVECT.
!     REAL R
!        INITIALIZATION VALUE.
!     REAL RINIT, RSTP
!        INPUT PARAMETERS.  THE INITIAL VALUE AND THE INCREMENT USED
!        IN CREATING THE INITIALIZATION VALUES.
!     REAL RVECT(N)
!        OUTPUT PARAMETER.  THE VECTOR INTO WHICH TO PUT THE VALUES
!        RINIT, RINIT + RSTP, ..., RINIT + (N - 1)*RSTP.
!
      r = rinit
      do 10 j=1,n
         rvect(j) = r
         r = r + rstp
   10 continue
      return
      end
!SRTIR
      subroutine srtir(ir, la, a)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!   FUNCTION     SRTIR  - SORT INTEGER ARRAY IR ON KEY ARRAY A.
!                           IF THE INTEGER ARRAY CONSISTS OF THE
!                           ORDERED SEQUENCE 1, 2, ... LA, THEN
!                           ON COMPLETION IR IS  A PERMUTATION
!                           VECTOR FOR THE SORT OF A.
!   USAGE               - CALL SRTIR (A,LA,IR)
!   PARAMETERS   A(LA)  - ON INPUT, CONTAINS THE ARRAY TO BE SORTED ON
!                         ON OUTPUT, A CONTAINS THE SORTED ARRAY
!                LA     - INPUT VARIABLE CONTAINING THE NUMBER OF
!                           ELEMENTS IN THE ARRAY TO BE SORTED
!                IR(LA) - IF ON INPUT, IR CONTAINS THE INTEGER VALUES
!                           1,2,...,LA.
!                       - THEN ON OUTPUT, IR CONTAINS A RECORD OF THE
!                           PERMUTATIONS MADE ON THE VECTOR A.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   la
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   a(la)
     integer&
     &   ir(la)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   r,t,tt
     integer&
     &   i,ij,it,itt,j,k,l,m
!
!  LOCAL ARRAYS
     integer&
     &   il(21),iu(21)
!
!  INTRINSIC FUNCTIONS
      intrinsic int
!
!
      m = 1
      i = 1
      j = la
      r = .375e0
   10 if (i.eq.j) go to 90
      if (r.gt.0.5898437e0) go to 20
      r = r + 3.90625e-2
      go to 30
   20 r = r - .21875e0
   30 k = i
!                                  SELECT A CENTRAL ELEMENT OF THE
!                                  ARRAY AND SAVE IT IN LOCATION T
      ij = i + int((j-i)*r)
      t = a(ij)
      it = ir(ij)
!                                  IF FIRST ELEMENT OF ARRAY IS GREATER
!                                  THAN T, INTERCHANGE WITH T
      if (a(i).le.t) go to 40
      a(ij) = a(i)
      a(i) = t
      t = a(ij)
      ir(ij) = ir(i)
      ir(i) = it
      it = ir(ij)
   40 l = j
!                                  IF LAST ELEMENT OF ARRAY IS LESS THAN
!                                  T, INTERCHANGE WITH T
      if (a(j).ge.t) go to 60
      a(ij) = a(j)
      a(j) = t
      t = a(ij)
      ir(ij) = ir(j)
      ir(j) = it
      it = ir(ij)
!                                  IF FIRST ELEMENT OF ARRAY IS GREATER
!                                  THAN T, INTERCHANGE WITH T
      if (a(i).le.t) go to 60
      a(ij) = a(i)
      a(i) = t
      t = a(ij)
      ir(ij) = ir(i)
      ir(i) = it
      it = ir(ij)
      go to 60
   50 tt = a(l)
      a(l) = a(k)
      a(k) = tt
      itt = ir(l)
      ir(l) = ir(k)
      ir(k) = itt
!                                  FIND AN ELEMENT IN THE SECOND HALF OF
!                                  THE ARRAY WHICH IS SMALLER THAN T
   60 l = l - 1
      if (a(l).gt.t) go to 60
!                                  FIND AN ELEMENT IN THE FIRST HALF OF
!                                  THE ARRAY WHICH IS GREATER THAN T
   70 k = k + 1
      if (a(k).lt.t) go to 70
!                                  INTERCHANGE THESE ELEMENTS
      if (k.le.l) go to 50
!                                  SAVE UPPER AND LOWER SUBSCRIPTS OF
!                                  THE ARRAY YET TO BE SORTED
      if (l-i.le.j-k) go to 80
      il(m) = i
      iu(m) = l
      i = k
      m = m + 1
      go to 100
   80 il(m) = k
      iu(m) = j
      j = l
      m = m + 1
      go to 100
!                                  BEGIN AGAIN ON ANOTHER PORTION OF
!                                  THE UNSORTED ARRAY
   90 m = m - 1
      if (m.eq.0) return
      i = il(m)
      j = iu(m)
  100 if (j-i.ge.1) go to 30
      if (i.eq.1) go to 10
      i = i - 1
  110 i = i + 1
      if (i.eq.j) go to 90
      t = a(i+1)
      it = ir(i+1)
      if (a(i).le.t) go to 110
      k = i
  120 a(k+1) = a(k)
      ir(k+1) = ir(k)
      k = k - 1
      if (t.lt.a(k)) go to 120
      a(k+1) = t
      ir(k+1) = it
      go to 110
      end
!NLSWS
     subroutine nlsws(y, wt, xm, n, m, ixm, mdl, par, npar, res,&
    &   ldstak, ifixed, stp, mit, stopss, stopp, scale, delta, ivaprx,&
     &   nprt, nnzw, npare, rsd, pv, sdpv, sdres, vcv, ivcv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING NUMERICALLY APPROXIMATED DERIVATIVES
!     AND WEIGHTS (LONG CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
     &   ivaprx,ivcv,ixm,ldstak,m,mit,n,nnzw,npar,npare,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   par(*),pv(*),res(*),scale(*),sdpv(*),sdres(*),stp(*),vcv(*),&
     &   wt(*),xm(*),y(*)
     integer&
     &   ifixed(*)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,lifixd,lpv,lscale,lsdpv,lsdres,lstp,lwt
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,NLCNTN
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF IFIXED(I).EQ
!        THEN PAR(I) WILL BE HELD FIXED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.   N
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(NPAR)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUE.
!     REAL SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(NPAR)
!        THE STEP SIZE ARRAY.
!     REAL VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(N)
!        THE WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'N','L','S','W','S',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      weight = .true.
      save = .true.
!
      lifixd = npar
      lpv = n
      lscale = npar
      lstp = npar
      lsdpv = n
      lsdres = n
      lwt = n
!
     call nlcntn(y, wt, lwt, xm, n, m, ixm, mdl, par, npar, res,&
    &   ldstak, ifixed, lifixd, stp, lstp, mit, stopss, stopp, scale,&
    &   lscale, delta, ivaprx, nprt, rsd, pv, lpv, sdpv, lsdpv, sdres,&
     &   lsdres, vcv, ivcv, nmsub, weight, save, nnzw, npare)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL NLSWS (Y, WT, XM, N, M, IXM, NLSMDL,'/&
    &   '      +            PAR, NPAR, RES, LDSTAK,'/&
    &   '      +            IFIXED, STP, MIT, STOPSS, STOPP,'/&
    &   '      +            SCALE, DELTA, IVAPRX, NPRT,'/&
    &   '      +            NNZW, NPARE, RSD, PV, SDPV, SDRES, VCV,',&
     &   ' IVCV)')
      end
!UFSPCV
     subroutine ufspcv (spcf, spcmn, spcmx, freq, nf, xaxis, yaxis,&
    &   isym, npts, ispcf, lpcv, nspc, bw, alow, aup, xpltmn, xpltmx,&
     &   ypltmn, ypltmx, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES CO-ORDINATES FOR THE SPECTRUM PLOTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   alow,aup,bw,spcmn,spcmx,xpltmn,xpltmx,ypltmn,ypltmx
     integer&
     &   ispcf,lpcv,nf,nprt,npts,nspc
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(nf),spcf(ispcf),xaxis(lpcv),yaxis(lpcv)
     integer&
     &   isym(lpcv)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   cilow,cimid,ciup,ymax
     integer&
     &   i,ispcfw
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL SPPLTC,SPPLTD,SPPLTL
!
!  INTRINSIC FUNCTIONS
      intrinsic log10
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALOW, AUP
!        FACTORS USED TO COMPUTE THE CONFIDENCE INTERVALS.
!     REAL BW
!       THE BANDWIDTH.
!     REAL CILOW, CIMID, CIUP
!        THE Y AXIS VALUES FOR THE LOWER  MID AND UPPER CONFIDENCE
!        INTERVAL POINTS.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISPCFW
!        AN INDEX VARIABLE.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NPTS
!        THE NUMBER OF CO-ORDINATES TO BE PLOTTED.
!     INTEGER NSPC
!        THE NUMBER OF VALID SPECTRUM VALUES.
!     REAL SPCF(ISPCF)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     REAL SPCMN, SPCMX
!        THE MINIMUM AND MAXIMUM SPECTRUM VALUE TO BE PLOTTED.
!     REAL XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     REAL YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YMAX
!        THE MAXIMUM ACTUAL SPECTRUM VALUE (IN DECIBELS) TO BE PLOTTED.
!     REAL YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VAUES TO BE PLOTTED FOR THE Y AXIS.
!
!
      ispcfw = 0
!
      if (nprt .ge. 1) go to 30
!
!     SET VARIOUS Y AXIS VALUES FOR DECIBLE PLOTS
!
     call sppltd (spcmn, spcmx, alow, aup, ypltmn, ypltmx,&
     &   cilow, cimid, ciup, ymax)
!
!     SET CO-ORDINATES FOR DECIBLE PLOTS
!
      do 10 i = 1, nf
         if (spcf(i) .lt. spcmn) go to 10
         ispcfw = ispcfw + 1
         xaxis(ispcfw) = freq(i)
         yaxis(ispcfw) = 10.0e0 * log10(spcf(i)) - ymax
         isym(ispcfw) = 1
   10 continue
!
      go to 70
!
   30 continue
!
!     SET VARIOUS Y AXIS VALUES FOR LOG PLOTS
!
     call sppltl (spcmn, spcmx, alow, aup, ypltmn, ypltmx,&
     &   cilow, cimid, ciup)
!
!     SET CO-ORDINATES FOR LOG PLOTS
!
      do 50 i = 1, nf
         if (spcf(i) .lt. spcmn) go to 50
         ispcfw = ispcfw + 1
         xaxis(ispcfw) = freq(i)
         yaxis(ispcfw) = spcf(i)
         isym(ispcfw) = 1
   50 continue
!
   70 continue
!
      npts = nspc
!
!     SET CO-ORDINATES FOR BANDWIDTH AND CONFIDENCE INTERVAL.
!
     call sppltc (xaxis, yaxis, isym, npts, xpltmn, xpltmx, bw, cilow,&
     &   cimid, ciup, lpcv)
!
      return
      end
!PPFT
      real(kind=wp) function ppft(p, idf)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS FUNCTION IS A VERSION OF DATAPAC SUBROUTINE
!     TPPF, WITH MODIFICATIONS TO FACILITATE CONVERSION TO
!     DOUBLE PRECISION AUTOMATICALLY USING THE NAG, INC. CODE APT,
!     AND TO CORRESPOND TO STARPAC CONVENTIONS.
!
!     PURPOSE--THIS SUBROUTINE COMPUTES THE PERCENT POINT
!              FUNCTION VALUE FOR THE STUDENT"S T DISTRIBUTION
!              WITH INTEGER DEGREES OF FREEDOM PARAMETER = IDF.
!              THE STUDENT"S T DISTRIBUTION USED
!              HEREIN IS DEFINED FOR ALL X,
!              AND ITS PROBABILITY DENSITY FUNCTION IS GIVEN
!              IN THE REFERENCES BELOW.
!              NOTE THAT THE PERCENT POINT FUNCTION OF A DISTRIBUTION
!              IS IDENTICALLY THE SAME AS THE INVERSE CUMULATIVE
!              DISTRIBUTION FUNCTION OF THE DISTRIBUTION.
!     ERROR CHECKING--NONE
!     RESTRICTIONS--IDF SHOULD BE A POSITIVE INTEGER VARIABLE.
!                 --P SHOULD BE BETWEEN 0.0E0 (EXCLUSIVELY)
!                   AND 1.0E0 (EXCLUSIVELY).
!     COMMENT--FOR IDF = 1 AND IDF = 2, THE PERCENT POINT FUNCTION
!              FOR THE T DISTRIBUTION EXISTS IN SIMPLE CLOSED FORM
!              AND SO THE COMPUTED PERCENT POINTS ARE EXACT.
!            --FOR OTHER SMALL VALUES OF IDF (IDF BETWEEN 3 AND 6,
!              INCLUSIVELY), THE APPROXIMATION
!              OF THE T PERCENT POINT BY THE FORMULA
!              GIVEN IN THE REFERENCE BELOW IS AUGMENTED
!              BY 3 ITERATIONS OF NEWTON"S METHOD FOR
!              ROOT DETERMINATION.
!              THIS IMPROVES THE ACCURACY--ESPECIALLY FOR
!              VALUES OF P NEAR 0 OR 1.
!     REFERENCES--NATIONAL BUREAU OF STANDARDS APPLIED MATHMATICS
!                 SERIES 55, 1964, PAGE 949, FORMULA 26.7.5.
!               --JOHNSON AND KOTZ, CONTINUOUS UNIVARIATE
!                 DISTRIBUTIONS--2, 1970, PAGE 102,
!                 FORMULA 11.
!               --FEDERIGHI, "EXTENDED TABLES OF THE
!                 PERCENTAGE POINTS OF STUDENT"S T
!                 DISTRIBUTION, JOURNAL OF THE
!                 AMERICAN STATISTICAL ASSOCIATION,
!                 1969, PAGES 683-688.
!               --HASTINGS AND PEACOCK, STATISTICAL
!                 DISTRIBUTIONS--A HANDBOOK FOR
!                 STUDENTS AND PRACTITIONERS, 1975,
!                 PAGES 120-123.
!     WRITTEN BY--JAMES J. FILLIBEN
!                 STATISTICAL ENGINEERING DIVISION
!                 NATIONAL BUREAU OF STANDARDS
!                 WASHINGTON, D. C. 20234
!     ORIGINAL VERSION--OCTOBER   1975.
!     UPDATED         --NOVEMBER  1975.
!
!     MODIFIED BY     --JANET R. DONALDSON, DECEMBER 7, 1981
!                       STATISTICAL ENGINEERING DIVISION
!                       NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   p
     integer&
     &   idf
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   arg,b21,b31,b32,b33,b34,b41,b42,b43,b44,b45,&
    &   b51,b52,b53,b54,b55,b56,c,con,d1,d3,d5,d7,d9,df,pi,ppfn,&
     &   s,sqrt2,term1,term2,term3,term4,term5,z
     integer&
     &   ipass,maxit
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   ppfnml
!       EXTERNAL PPFNML
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL GETPI
!
!  INTRINSIC FUNCTIONS
      intrinsic atan,cos,sin,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ARG
!        *
!     REAL B21
!        *
!     REAL B31, B32, B33, B34
!        *
!     REAL B41, B42, B43, B44, B45
!        *
!     REAL B51, B52, B53, B54, B55, B56
!        *
!     REAL C, CON
!        *
!     REAL DF
!        THE DEGREES OF FREEDOM.
!     REAL D1, D3, D5, D7, D9
!        *
!     INTEGER IDF
!        THE (INTEGER) DEGREES OF FREEDOM.
!     INTEGER IPASS
!        *
!     INTEGER MAXIT
!        *
!     REAL P
!        THE PROBABILITY AT WHICH THE PERCENT POINT IS TO BE EVALUATED.
!     REAL PI
!        THE VALUE OF PI.
!     REAL PPFN
!        THE NORMAL PERCENT POINT VALUE.
!     REAL S
!        *
!     REAL SQRT2
!        THE SQUARE ROOT OF TWO.
!        *
!     REAL TERM1, TERM2, TERM3, TERM4, TERM5
!        *
!     REAL Z
!        *
!
!     DEFINE CONSTANTS USED IN THE APPROXIMATIONS
!
      data b21 /4.0e0/
      data b31, b32, b33, b34 /96.0e0, 5.0e0, 16.0e0, 3.0e0/
     data b41, b42, b43, b44, b45&
     &  /384.0e0, 3.0e0, 19.0e0, 17.0e0, -15.0e0/
     data b51, b52, b53, b54, b55, b56&
    &   /9216.0e0, 79.0e0, 776.0e0, 1482.0e0,&
     &   -1920.0e0, -945.0e0/
!
      call getpi(pi)
!
      sqrt2 = sqrt(2.0e0)
!
      df = idf
      maxit = 5
!
      if (idf.ge.3) go to 50
      if (idf.eq.1) go to 30
      if (idf.eq.2) go to 40
      ppft = 0.0e0
      return
!
!     TREAT THE IDF = 1 (CAUCHY) CASE
!
   30 arg = pi*p
      ppft = -cos(arg)/sin(arg)
      return
!
!     TREAT THE IDF = 2 CASE
!
   40 term1 = sqrt2/2.0e0
      term2 = 2.0e0*p - 1.0e0
      term3 = sqrt(p*(1.0e0-p))
      ppft = term1*term2/term3
      return
!
!     TREAT THE IDF GREATER THAN OR EQUAL TO 3 CASE
!
   50 ppfn = ppfnml(p)
      d1 = ppfn
      d3 = ppfn**3
      d5 = ppfn**5
      d7 = ppfn**7
      d9 = ppfn**9
      term1 = d1
      term2 = (1.0e0/b21)*(d3+d1)/df
      term3 = (1.0e0/b31)*(b32*d5+b33*d3+b34*d1)/(df**2)
      term4 = (1.0e0/b41)*(b42*d7+b43*d5+b44*d3+b45*d1)/(df**3)
      term5 = (1.0e0/b51)*(b52*d9+b53*d7+b54*d5+b55*d3+b56*d1)/(df**4)
      ppft = term1 + term2 + term3 + term4 + term5
      if (idf.ge.7) return
      if (idf.eq.3) go to 60
      if (idf.eq.4) go to 80
      if (idf.eq.5) go to 100
      if (idf.eq.6) go to 120
      return
!
!     AUGMENT THE RESULTS FOR THE IDF = 3 CASE
!
   60 con = pi*(p-0.5e0)
      arg = ppft/sqrt(df)
      z = atan(arg)
      do 70 ipass=1,maxit
         s = sin(z)
         c = cos(z)
         z = z - (z+s*c-con)/(2.0e0*c*c)
   70 continue
      ppft = sqrt(df)*s/c
      return
!
!     AUGMENT THE RESULTS FOR THE IDF = 4 CASE
!
   80 con = 2.0e0*(p-0.5e0)
      arg = ppft/sqrt(df)
      z = atan(arg)
      do 90 ipass=1,maxit
         s = sin(z)
         c = cos(z)
         z = z - ((1.0e0+0.5e0*c*c)*s-con)/(1.5e0*c*c*c)
   90 continue
      ppft = sqrt(df)*s/c
      return
!
!     AUGMENT THE RESULTS FOR THE IDF = 5 CASE
!
  100 con = pi*(p-0.5e0)
      arg = ppft/sqrt(df)
      z = atan(arg)
      do 110 ipass=1,maxit
         s = sin(z)
         c = cos(z)
         z = z - (z+(c+(2.0e0/3.0e0)*c*c*c)*s-con)/((8.0e0/3.0e0)*c**4)
  110 continue
      ppft = sqrt(df)*s/c
      return
!
!     AUGMENT THE RESULTS FOR THE IDF = 6 CASE
!
  120 con = 2.0e0*(p-0.5e0)
      arg = ppft/sqrt(df)
      z = atan(arg)
      do 130 ipass=1,maxit
         s = sin(z)
         c = cos(z)
        z = z - ((1.0e0+0.5e0*c*c+0.375e0*c**4)*s-con)/&
     &           ((15.0e0/8.0e0)*c**5)
  130 continue
      ppft = sqrt(df)*s/c
      return
!
      end
!CCFMS
     subroutine ccfms (ym, ymmiss, n, m, iym, lagmax, ccov,&
     &   cmiss, iccov, jccov, nlppc, inlppc, jnlppc, nprt, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
!     CORRELATIONS AND COVARIANCES OF A MULTIVARIATE SERIES (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   cmiss
     integer&
     &   iccov,inlppc,iym,jccov,jnlppc,lagmax,ldstak,m,n,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ccov(*),ym(*),ymmiss(*)
     integer&
     &   nlppc(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplm
     integer&
    &   i,ifp,io,iprt,iymfft,j,k,ldsmin,lglst,lglstj,lglstk,lyfft,&
     &   nall0,nfft,rhoc,sdrhoc,ymean,ymeanj,ymeank,ysd,ysdj,ysdk
     logical&
     &   isfft,islong,newpg
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      INTEGER
!     +   STKST
!      EXTERNAL R1MACH,STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACVFM,CCFER,CCFMNM,CCFOUT,IPRINT,LDSCMP,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic min,sqrt
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  STATEMENT FUNCTIONS
     integer&
     &   i2,i3c,i3n
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCOV(ICCOV, JCCOV, M)
!        THE CROSS COVARIANCE MATRIX.
!     REAL CMISS
!        THE MISSING VALUE CODE FOR THE CCVF ESTIMATES.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     INTEGER ICCOV
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INLPPC
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
!        IN THE USERS PROGRAM.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON WHETHER PRINTED OUTPUT IS DESIRED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     LOGICAL ISLONG
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IYM
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YM AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IYMFFT
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER I2
!        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN YM
!     INTEGER I3C
!        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN CCOV
!     INTEGER I3N
!        STATEMENT FUNCTION SPECIFYING THE DESIRED LOCATION WITHIN NLPPC
!     INTEGER J
!        THE INDEX OF -SERIES 1- IN THE ARRAY YM.
!     INTEGER JCCOV
!        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
!        IN THE USERS PROGRAM.
!     INTEGER K
!        THE INDEX OF -SERIES 2- IN THE ARRAY YM.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE REQUESTED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LGLST, LGLSTJ, LGLSTK
!        THE STARTING LOCATION IN ISTAK FOR THE ARRAY LGLST,
!        AND THE LOCATIONS IN LGLST IN EHICH THE NUMBER OF THE
!        LAG OF THE LAST ACVF WHICH COULD BE COMPUTED FOR SERIES
!        J AND K, RESPECTIVELY, BEFORE A MISSNG ACVF (DUE TO MISSING
!        DATA).
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER M
!        THE NUMBER OF SERIES BEING COMPARED, IE THE
!        NUMBER OF COLUMNS OF DATA IN YM.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS
!     LOGICAL NEWPG
!        AN INDICATOR VARIABLE USED TO DETERMINE WHEN A NEW PAGE
!        IS APPROPRIATE FOR THE OUTPUT.
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NLPPC(INLPPC, JNLPPC, M)
!        THE ARRAY CONTAINING THE NUMBER OF LAGGED PRODUCT PAIRS
!        USED TO COMPUTE EACH ACVF ESTIMATE.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPEDIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE GIVEN, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO OUTPUT IS GIVEN.
!     INTEGER RHOC
!        THE STARTING LOCATION IN DSTAK OF THE ARRAY RHOC.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SDRHOC
!        THE STARTING LOCATION IN THE WORK AREA FOR SDRHOC.
!     REAL YM(IYM, M)
!        THE MATRIX CONTAINING THE OBSERVED TIME SERIES
!     INTEGER YMEAN, YMEANJ, YMEANK
!        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
!        MEANS OF EACH OF THE SERIES, AND THE LOCATION IN
!        THE ARRAY FOR THE MEAN OF THE JTH AND KTH SERIES,
!        RESPECTIVELY.
!     REAL YMMISS(M)
!        THE MISSING VALUE CODES FOR EACH OF THE SERIES IN YM.
!     INTEGER YSD, YSDJ, YSDK
!        THE STARTING LOCATION FOR THE ARRAY CONTAINING THE
!        STANDARD DEVIATIONS OF EACH OF THE SERIES, AND THE
!        LOCATION IN THE ARRAY FOR THE STANDARD DEVIATION OF
!        THE JTH AND KTH SERIES, RESPECTIVELY.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'C',       'C',       'F',       'M',       'S',       ' '/
!
      i2(i,j) = i + (j-1)*iym
      i3c(i,j,k) = i + (j-1)*iccov + (k-1)*jccov*iccov
      i3n(i,j,k) = i + (j-1)*inlppc + (k-1)*jnlppc*inlppc
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      lyfft = n + lagmax
      iymfft = lyfft
      nfft = n
      isfft = .false.
      islong = .true.
!
      io = 1
      if (nprt .eq. 0) io = 0
!
     call ldscmp(3+2*io, 0, m, 0, 0, 0, 'S',&
     &            2*m+io*(4*lagmax+2), ldsmin)
!
     call ccfer(nmsub, n, lagmax, ldstak, ldsmin, iccov, jccov,&
     &  inlppc, jnlppc, m, lyfft, nfft, iym, iymfft, isfft, islong)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      if (ierr.eq.0) then
!
        fplm = r1mach(2)
!
!       SET UP THE WORK AREA.
!
        call stkset (ldstak, 4)
        nall0 = stkst(1)

        ifp = 3
!
        ymean = stkget(m, ifp)
        ysd = stkget(m, ifp)
        lglst = stkget(m, 2)
        if (nprt.eq.0) then
          rhoc = ysd
          sdrhoc = ysd
        else
          rhoc = stkget(2*lagmax+1, ifp)
          sdrhoc = stkget(2*lagmax+1, ifp)
        end if
!
        if (ierr.eq.0) then
!
!         BEGIN LOOP FOR COMPUTATIONS
!
          newpg = .false.
!
          do 40 k = 1, m
!
             ymeank = ymean + k - 1
             ysdk = ysd + k - 1
             lglstk = lglst + k - 1
!
            call acvfm (ym(i2(1,k)), ymmiss(k), n, rstak(ymeank),&
    &                   ccov(i3c(1,k,k)), lagmax, istak(lglstk),&
     &                   nlppc(i3n(1,k,k)), lagmax+1)
             rstak(ysdk) = sqrt(ccov(i3c(1,k,k)) * n / (n - 1))
!
             if ((k-1).le.0) go to 40
!
             do 30 j = 1, (k-1)
!
                ymeanj = ymean + j - 1
                ysdj = ysd + j - 1
                lglstj = lglst + j - 1
!
               call ccfmnm (ym(i2(1,j)), ymmiss(j),&
    &                       ym(i2(1,k)), ymmiss(k),&
    &                       n,  lagmax, 2*lagmax+1,&
    &                       ccov(i3c(1,j,j)), ccov(i3c(1,k,k)),&
    &                       ccov(i3c(1,j,k)), ccov(i3c(1,k,j)), iccov,&
    &                       nlppc(i3n(1,j,j)), nlppc(i3n(1,k,k)),&
    &                       nlppc(i3n(1,j,k)), nlppc(i3n(1,k,j)),&
    &                       inlppc,&
    &                       rstak(ymeanj), rstak(ymeank), rstak(rhoc),&
    &                       rstak(sdrhoc),&
     &                       nprt, min(istak(lglstj), istak(lglstk)))
!
                if (nprt .eq. 0) go to 30
!
!         CALL ROUTINE TO PRINT OUT CORRELATIONS
!
               call ccfout (j, rstak(ymeanj), rstak(ysdj), n,&
    &                       nlppc(i3n(1,j,j)), k, rstak(ymeank),&
    &                       rstak(ysdk), n, nlppc(i3n(1,k,k)), lagmax,&
    &                       2*lagmax+1, rstak(rhoc), rstak(sdrhoc),&
    &                       .true., nlppc(i3n(1,j,k)),&
    &                       nlppc(i3n(1,k,j)),&
     &                       inlppc, ymmiss(j), ymmiss(k), newpg)
!
                newpg = .true.
!
   30        continue
   40     continue
!
          cmiss = fplm
        end if
!
        call stkclr(nall0)
      end if
!
      if (ierr.ne.0) then
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        ierr = 1
        call iprint (iprt)
        write (iprt, 1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format(/42h the correct form of the call statement is//&
    &  '       CALL CCFMS (YM, YMMISS, N, M, IYM,'/&
    &  '      +            LAGMAX, CCOV, CMISS, ICCOV, JCCOV,'/&
     &  '      +            NLPPC, INLPPC, JNLPPC, NPRT, LDSTAK)')
      end
!HPFLT
      subroutine hpflt (hlp, k, hhp)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE HIPASS FILTER COEFFICIENTS
!     CORRESPONDING TO THE INPUT LOW PASS FILTER.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   k
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   hhp(k),hlp(k)
!
!  LOCAL SCALARS
     integer&
     &   i,kmid
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL HHP(K)
!        THE ARRAY IN WHICH THE HIGH PASS FILTER COEFFICIENTS
!        WILL BE RETURNED.
!     REAL HLP(K)
!        THE ARRAY IN WHICH THE INPUT LOW PASS FILTER COEFFICIENTS
!        ARE STORED.
!     INTEGER I
!       AN INDEX VARIABLE.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS TO BE COMPUTED.
!     INTEGER KMID
!        THE MIDPOINT OF THE FILTER.
!
      do 20 i = 1, k
         hhp(i) = -hlp(i)
   20 continue
!
      kmid = (k + 1) / 2
!
      hhp(kmid) = hhp(kmid) + 1.0e0
!
      return
      end
!CDFCHI
      real(kind=wp) function cdfchi(chisqr, df)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE CHI SQUARE CUMULATIVE DISTRIBUTION
!     FUNCTION FROM THE INCOMPLETE GAMMA FUNCTION RATIO AS DISCUSSED IN
!     CHAPTER 17 OF DISTRIBUTIONS IN STATISTICS - CONTINUOUS UNIVARIATE
!     DISTRIBUTIONS - 1, BY JOHNSON AND KOTZ.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE - DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   chisqr,df
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   fplpm
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &    gami, gamma,r1mach
     logical&
     &   mvchk
!       EXTERNAL  GAMI, GAMMA,R1MACH,MVCHK
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CHISQR
!        THE PERCENT POINT FROM THE CHI SQUARED DISTRIBUTION.
!     REAL DF
!        THE DEGREES OF FREEDOM.
!     REAL FPLPM
!        THE REAL FLOATING POINT LARGEST POSITIVE MAGNITUDE.
!
!     COMMENCE BODY OF ROUTINE
!
      fplpm = r1mach(2)
!
      cdfchi =  gami(0.5e0*df, 0.5e0*chisqr)
      if (mvchk(cdfchi,fplpm)) then
         cdfchi = 1.0e0
      else
         cdfchi = cdfchi /  gamma(0.5e0*df)
         if (cdfchi.lt.0.0e0) cdfchi = 0.0e0
         if (cdfchi.gt.1.0e0) cdfchi = 1.0e0
      end if
!
      return
      end
!UFSM
      subroutine ufsm(y, ymiss, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS WITH MISSING DATA (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: ymiss
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta,fmax,fmin
     integer&
    &   iprt,ispcf,lacov,lagmax,ldsmin,ldstak,lnlppa,lpcv,lwork,&
     &   ly,nf,nprt,nw
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   acov(101),freq(101),spcf(101,4),work(101),xaxis(106),&
     &   yaxis(106)
     integer&
     &   isort(101),isym(106),lags(4),nlppa(101)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ECVF,IPRINT,PARZEN,SETLAG,UFSDRV
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(101)
!        THE AUTOCOVARIANCE AT LAG ZERO (BIASED VARIANCE).
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCES AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT(101)
!        AN ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISYM(106)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LACOV
!        THE LENGTH OF THE VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(101)
!        THE ARRAY CONTAINING THE NUMBER OF LAG PRODUCT PAIRS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL SPCF(101,4)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     REAL WORK(101)
!        THE VECTOR OF LAG WINDOWS.
!     REAL XAXIS(106)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL Y(N)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     REAL YAXIS(106)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL YMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IN THE SERIES IS MISSING.  IF Y(I) = YMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'U','F','S','M',' ',' '/
!
!     SET UP
!
      option(4) = .false.
      option(3) = .false.
      option(2) = .true.
      option(1) = .false.
!
      ldstak = 0
      ldsmin = 0
!
      ispcf = 101
      lacov = 101
      lnlppa = 101
      ly = n
      lpcv = 106
      lwork = 101
      nf = 101
!
!     SET MAXIMUM LAG VALUE TO BE USED.
!     AND NUMBER OF LAG WINDOW TRUNCATION POINTS TO USE.
!
      call setlag(n, lagmax)
      nw = 4
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!     FOR SERIES WITH MISSING DATA.
!
     call ufsdrv(y, ly, ymiss, acov, nlppa, spcf, ispcf, nf, fmin,&
    &   fmax, freq, n, nw, lagmax, lags, work, lacov, lwork, delta,&
    &   isort, isym, xaxis, yaxis, lpcv, alpha, nprt, parzen, nmsub,&
     &   ldsmin, ldstak, option, lnlppa, ly)
!
!     CHECK FOR ERRORS
!
      if (ierr.eq.0) return
!
      if (ierr.eq.2) call ecvf(nmsub)
      ierr = 1
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL UFSM (Y, YMISS, N)')
      end
!IPGMN
      subroutine ipgmn (per, nf, peri, ispcer)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE INTEGRATED PERIODOGRAM.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ispcer,nf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   per(nf),peri(nf)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   sm
     integer&
     &   i
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER ISPCER
!        AN ERROR INDICATOR FOR THE INTEGRATED PERIODOGRAM COMPUTATIONS.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE PERIODOGRAM IS
!        COMPUTED.
!     REAL PER(NF)
!        THE RAW PERIODOGRAM.
!     REAL PERI(NF)
!        THE ARRAY WHICH CONTAINS THE INTEGRATED PERIODOGRAM.
!     REAL SM
!        A VALUE USED TO COMPUTE THE INTEGRATED PERIODOGRAM ESTIMATES.
!
!
      sm = 0.0e0
!
      do 30 i = 1, nf
         sm = sm + per(i)
         peri(i) = sm
   30 continue
!
      ispcer = 1
      if (sm .eq. 0.0e0) return
!
      ispcer = 0
!
      do 40 i = 1, nf
         peri(i) = peri(i)/sm
   40 continue
!
      return
      end
!DRV1B
      subroutine drv1b(par, npar, xm, n, m, ixm, d)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     DERIVATIVE FUNCTION FOR NLS FAMILY EXERCISER SUBROUTINE MDL1
!     CODED INCORRECTLY.
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   d(n,npar),par(npar),xm(ixm,m)
!
!  LOCAL SCALARS
     integer&
     &   i
!
!  INTRINSIC FUNCTIONS
      intrinsic log
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL D(N,NPAR)
!        THE FIRST DERIVATIVE WITH RESPECT TO THE ITH COEFFICIENT
!     INTEGER I
!        ROW MARKER
!     INTEGER IXM
!        ACTUAL FIRST DIMENSION OF XM
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLESC
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        THE NUMBER OF COEFFICIENTS
!     REAL PAR(NPAR)
!        MODEL COEFFICIENTS
!     REAL XM(IXM,M)
!        INDEPENDENT VARIABLES
!
!
      do 10 i=1,n
         d(i,1) = xm(i,1)*par(2)
         d(i,2) = par(1)*(xm(i,1)**par(2))*log(xm(i,1))
   10 continue
!
      return
!
      end
!AOV1ER
     subroutine aov1er(y, tag, n, igstat, nztags, ng, ldstak, nmsub,&
     &   index, isaov1, nall0)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE DOES PRELIMINARY CHECKING FOR ERRORS IN THE INPUT
!     PARAMETERS OF THE ONEWAY FAMILY.
!
!     WRITTEN BY -
!        LINDA L. MITCHELL AND JANET R. DONALDSON
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   igstat,index,isaov1,ldstak,n,nall0,ng,nztags
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   tag(*),y(*)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   i,iprt,j,ldsmin,nv
     logical&
     &   error,head
!
!  LOCAL ARRAYS
     integer&
     &   istak(12)
     character&
    &   ligsta(8)*1,llds(8)*1,ln(8)*1,lng(8)*1,ltag(8)*1,&
     &   ltwo(8)*1,lzero(8)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,EISII,ERVGT,GENI,IPRINT,LDSCMP,SRTIRR,SRTRRI,
!     +   STKCLR,STKSET
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERROR
!        SET TRUE IF THE ERROR CHECKING ROUTINE FOUND ANY ERRORS
!     LOGICAL HEAD
!        INDICATES WHETHER HEADING NEEDS TO BE PRINTED
!        TRUE - YES, NEEDS TO BE PRINTED
!        FALSE - NO, HAS BEEN PRINTED
!     INTEGER I
!        *
!     INTEGER IERR
!        IF IERR .NE. 0, THEN ERRORS WHERE FOUND IN THE PARAMETERS
!     INTEGER IGSTAT
!        *
!     INTEGER INDEX
!        THE STARTING LOCATION IN THE STACH AREA OF THE INDEX FOR
!        THE SORTED TAGS.
!     INTEGER IPRT
!        THE OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISAOV1
!        AN INDICATOR VARIABLE USED FOR THE COMPUTATION OF WORK
!        SPACE.  IF ISAOV1 = 0, THE CALLING ROUTINE IS AOV1S.  IF
!        ISAOV1 = 1, THE CALLING ROUTINE IS AOV1.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER J
!        *
!     INTEGER LDSMIN
!        THE MINIMUM SIZE ALLOWED FOR THE STACK
!     INTEGER LDSTAK
!        SIZE OF STACK ALLOCATED IN THE USERS MAIN PROGRAM
!     CHARACTER*1 LIGSTA(8), LLDS(8), LN(8), LNG(8), LTAG(8),
!    *   LTWO(8), LZERO(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF THE VARIABLE(S) CHECKED
!        ERRORS
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     INTEGER NALL0
!        OUTPUT PARAMETER.  NUMBER OF STACK ALLOCATIONS AFTER
!        STACK IS INITIALIZED.
!     INTEGER NG
!        *
!     CHARACTER*1 NMSUB(6)
!        NAME OF THE CALLING SUBROUTINE
!     INTEGER NV
!        THE NUMBER OF VALUES LESS THAN OR EQUAL TO ZERO.
!     INTEGER NZTAGS
!        THE NUMBER OF POSITIVE NON-ZERO TAGS, TO BE DETERMINED BY
!        THIS ROUTINE
!     REAL TAG(N)
!        THE VECTOR OF TAGS.
!     REAL Y(N)
!        THE VECTOR OF OBSERVATIONS.
!
     data  ligsta(1),ligsta(2),ligsta(3),ligsta(4),ligsta(5),ligsta(6),&
    &      ligsta(7),ligsta(8)&
     &     / 'I', 'G', 'S', 'T', 'A', 'T', ' ', ' '/
     data   llds(1),  llds(2),  llds(3),  llds(4),  llds(5),  llds(6),&
    &       llds(7),  llds(8)&
     &     / 'L', 'D', 'S', 'T', 'A', 'K', ' ', ' '/
     data     ln(1),    ln(2),    ln(3),    ln(4),    ln(5),    ln(6),&
    &         ln(7),    ln(8)&
     &     / 'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
     data    lng(1),   lng(2),   lng(3),   lng(4),   lng(5),   lng(6),&
    &        lng(7),   lng(8)&
     &     / 'N', 'G', ' ', ' ', ' ', ' ', ' ', ' '/
     data   ltag(1),  ltag(2),  ltag(3),  ltag(4),  ltag(5),  ltag(6),&
    &       ltag(7),  ltag(8)&
     &     / 'T', 'A', 'G', ' ', ' ', ' ', ' ', ' '/
     data   ltwo(1),  ltwo(2),  ltwo(3),  ltwo(4),  ltwo(5),  ltwo(6),&
    &       ltwo(7),  ltwo(8)&
     &     / 'T', 'W', 'O', ' ', ' ', ' ', ' ', ' '/
     data  lzero(1), lzero(2), lzero(3), lzero(4), lzero(5), lzero(6),&
    &      lzero(7), lzero(8)&
     &     / 'Z', 'E', 'R', 'O', ' ', ' ', ' ', ' '/
!
!     COMMENCE BODY OF ROUTINE
!
      ierr = 0
      head = .true.
!
!     SET UP OUTPUT UNIT
      call iprint(iprt)
!
!     BEGIN ERROR CHECKING.
!
!     NUMBER OF OBSERVATIONS LESS THAN 2
!
      call eisge(nmsub, ln, n, 2, 2, head, error, ltwo)
      if (error) go to 50
!
!     NUMBER OF NON-ZERO TAGS LESS THAN 2
!
     call ervgt(nmsub, ltag, tag, n, 0.0e0, (n-2), head, 7, nv, error,&
     &   lzero)
      if (error) go to 50
!
      nztags = n - nv
!
!     STACK MUST BE LARGE ENOUGH FOR A VECTOR OF LENGTH N TO CONTINUE
!
      call ldscmp(1, 0, n, 0, 0, 0, 'S', 0, ldsmin)
      call eisge(nmsub, llds, ldstak, ldsmin, 9, head, error, llds)
      if (error) write(iprt, 1000)
      if (error) go to 50
!
!     INITIALIZE STACK AND NALL0
!
      call stkset(ldstak, 4)
      nall0 = stkst(1)
!
      index = stkget(n,2)
!
!     SORT TAG VECTOR CARRYING ALONG INDEX TO ORIGINAL ORDER AND THE
!     VECTOR OF OBSERVATIONS
!
      call geni(istak(index), n, 1, 1)
      call srtirr(istak(index), y, n, tag)
!
!     COUNT THE NUMBER OF DIFFERENT TAG VALUES
!
      j = n - nztags + 2
      ng = 1
      do 10 i=j,n
         if (tag(i).gt.tag(i-1)) ng = ng + 1
   10 continue
!
!     LESS THAN 2 DIFFERENT TAG GROUPS
!
     call eisii(nmsub, lng, ng, 2, nztags-1, 3, head, error,&
     &  ltwo, ln)
      if (error) go to 40
!
!     CHECK THAT DIMENSION OF STATISTICS MATRIX IS SUFFICIENT
!
      call eisge(nmsub, ligsta, igstat, ng, 3, head, error, lng)
      if (error) go to 40
!
!     COMPUTE AND CHECK FOR SUFFICIENT STACK
!
     call ldscmp(11, 0, n+nztags, 0, 0, 0,&
     &            'S', isaov1*4*ng+4*ng+nztags, ldsmin)
!
      call eisge(nmsub, llds, ldstak, ldsmin, 9, head, error, llds)
      if (.not.error) return
!
   40 continue
!
!     REORDER DATA
!
      call srtrri(tag, y, n, istak(index))
!
!     CLEAR STACK, IN CASE WHERE ERROR FOLLOWS ALLOCATION OF STACK.
!
      call stkclr (nall0)
!
   50 continue
      ierr = 1
      return
!
!     FORMAT STATEMENTS
!
1000 format(/' NOTE.  THE VALUE OF LDSTAK MENTIONED ABOVE IS THE',&
    &  ' MINIMUM NECESSARY'/&
    &  ' TO CONTINUE CHECKING FOR ERRORS AND',&
    &  ' TO CALCULATE THE CORRECT VALUE'/&
    &  ' OF LDSTAK.  THE CORRECT',&
    &  ' VALUE WILL BE LARGER.  CONSULT THE DOCUMENTATION'/&
     &  ' FOR THE FORMULAS USED TO CALCULATE LDSTAK.')
      end
!SUMOT
      subroutine sumot(sts, n, nnzw, wts)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE REPORTS THE RESULTS OF A STAT FAMILY
!     COMPUTATION OF 53 SELECTED STATISTICS.  THERE MAY OR
!     MAY NOT BE WEIGHTS.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n,nnzw
     logical&
     &   wts
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   sts(53)
!
!  LOCAL SCALARS
     integer&
     &   i,iprt
!
!  LOCAL ARRAYS
     integer&
     &   itemp(10)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VERSP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        LOOP INDEX.
!     INTEGER IPRT
!        THE OUTPUT UNIT.
!     INTEGER ITEMP(10)
!        A TEMPORARY VECTOR OF INTEGER STORAGE.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF THE ORIGINAL DATA VECTOR.
!     INTEGER NNZW
!        INPUT PARAMETER.  THE NUMBER OF VALUES IN THE ORIGINAL DATA
!        VECTOR WITH WEIGHTS GREATER THAN 0.0E0.
!     REAL STS(53)
!        INPUT PARAMETER.  THE VECTOR OF 53 STATISTICS COMPUTED.
!        ROW STATISTIC                    ROW STATISTIC
!         1  LENGTH OF VECTOR             TESTS FOR NONRANDOMNESS
!         2  NUMBER OF NONZERO WEIGHTS    23  NUMBER OF RUNS UP AND DOWN
!        MEASURES OF LOCATION             24  EXPECTED NUMBER OF RUNS
!         3  UNWEIGHTED MEAN              25  S.D. OF NUMBER OF RUNS
!         4  WEIGHTED MEAN                26  MEAN SQR. SUCCESSIVE DIFF.
!         5  MEDIAN                       27  MEAN SQR. SUCC. DIFF./VAR.
!         6  MID-RANGE                    DEVIATIONS FROM WTD MEAN
!         7  25 P.C. UNWTD. TRIMMED MEAN  28  NUMBER OF + SIGNS
!         8  25 P.C. WTD. TRIMMED MEAN    29  NUMBER OF - SIGNS
!        MEASURES OF DISPERSION           30  NUMBER OF RUNS
!         9  STANDARD DEVIATION (S.D.)    31  EXPECTED NUMBER OF RUNS
!        10  S.D. OF MEAN                 32  S.D. OF RUNS
!        11  RANGE                        33  DIFF./S.D. OF RUNS
!        12  MEAN VARIATION               OTHER STATISTICS
!        13  VARIANCE (VAR.)              34  MINIMUM
!        14  COEFFICIENT OF VARIATION     35  MAXIMUM
!        CONFIDENCE INTERVALS             36  BETA 1
!        15  LOWER CONFIDENCE LIMIT, MEAN 37  BETA 2
!        16  UPPER CONFIDENCE LIMIT, MEAN 38  WTD. SUM OF VALUES
!        17  LOWER CONFIDENCE LIMIT, S.D. 39  WTD. SUM OF SQUARES
!        18  UPPER CONFIDENCE LIMIT, S.D. 40  WTD. SUM OF SQRD. DEVS.
!        LINEAR TREND STATISTICS          41  STUDENTS T
!        19  SLOPE                        42  WTD. SUM OF ABS. VALUES
!        20  S.D. OF SLOPE                43  WTD. AVG. ABS. VALUES
!        21  SLOPE/S.D. OF SLOPE = T      44-53 FREQ. DISTRIBUTION
!        22  PROB ( X .GT. ABS(OBS. T))
!     LOGICAL WTS
!        INPUT PARAMETER.  A FLAG TO INDICATE WHETHER OR NOT THERE ARE
!        WEIGHTS.
!
!     BEGIN PRINTOUT
!
      call iprint(iprt)
!
!     PRINT HEADING
!
      call versp(.true.)
!
!     PRINT NUMBERS OF OBSERVATIONS, RAW AND NONZERO WEIGHTED.
!
      if (.not.wts) write (iprt,1000)
      if (wts) write (iprt,1010)
      if (nnzw.ne.n) go to 10
      write (iprt,1020) nnzw
      go to 20
   10 write (iprt,1030) nnzw, n
      write (iprt,1040)
!
!     PRINT FREQUENCY DISTRIBUTIONS
!
   20 do 30 i=1,10
         itemp(i) = sts(i+43)
   30 continue
      write (iprt,1050) (itemp(i),i=1,10)
!
!     PRINT MEASURES OF LOCATION AND DISPERSION
!
      write (iprt,1060)
     if (sts(4).ne.0.0e0)&
     &   write (iprt,1070) (sts(i+2),sts(i+8),i=1,6)
     if (sts(4).eq.0.0e0)&
     &   write (iprt,1080) (sts(i+2),sts(i+8),i=1,5), sts(8)
!
!     PRINT CONFIDENCE INTERVALS
!
      write (iprt,1090) (sts(i),i=15,18)
!
!     PRINT LINEAR TREND AND OTHER STATISTICS, AND PRINT HEADING FOR
!     TESTS FOR NONRANDOMNESS
!
     write (iprt,1100)&
     &   (sts(i),sts(i+15),i=19,22), (sts(i),i=38,41)
      itemp(1) = sts(23)
      itemp(2) = sts(28)
      itemp(3) = sts(29)
      itemp(4) = sts(30)
!
!     PRINT TESTS FOR NONRANDOMNESS
!
     write (iprt,1110) itemp(1), sts(42), sts(24), sts(43),&
     &   (sts(i),i=25,27), (itemp(i),i=2,4), (sts(i),i=31,33)
!
!     PRINT FOOTNOTE
!
      write (iprt,1120)
      return
!
 1000 format('+STATISTICAL ANALYSIS')
 1010 format('+WEIGHTED STATISTICAL ANALYSIS')
 1020 format(//5x, 4hn = , i5)
1030 format(//5x, 4hn = , i5, 32h (no. of non-zero wts)    length,&
     &   2h =, i5)
1040 format(/5x, 45hall computations are based on observations wi,&
     &   19hth non-zero weights)
 1050 format(//5x, 28hfrequency distribution (1-6), 7x, 10i6)
1060 format(//5x, 26hmeasures of location (2-2), 34x, 10hmeasures o,&
     &   18hf dispersion (2-6))
1070 format(/10x, 26hunweighted mean          =, 1pe15.7, 20x,&
    &   26hwtd standard deviation   =, e15.7/10x, 17hweighted mean    ,&
    &   9h        =, e15.7, 20x, 26hweighted s.d. of mean    =,&
    &   e15.7/10x, 26hmedian                   =, e15.7, 20x, 6hrange ,&
    &   20h                   =, e15.7/10x, 23hmid-range              ,&
    &   3h  =, e15.7, 20x, 26hmean deviation           =, e15.7/10x,&
    &   26h25 pct unwtd trimmed mean=, e15.7, 20x, 16hvariance        ,&
    &   10h         =, e15.7/10x, 26h25 pct wtd trimmed mean  =,&
     &   e15.7, 20x, 26hcoef. of. var. (percent) =, e15.7)
1080 format(/10x, 26hunweighted mean          =, 1pe15.7, 20x,&
    &   26hwtd standard deviation   =, e15.7/10x, 17hweighted mean    ,&
    &   9h        =, e15.7, 20x, 26hweighted s.d. of mean    =,&
    &   e15.7/10x, 26hmedian                   =, e15.7, 20x, 6hrange ,&
    &   20h                   =, e15.7/10x, 23hmid-range              ,&
    &   3h  =, e15.7, 20x, 26hmean deviation           =, e15.7/10x,&
    &   26h25 pct unwtd trimmed mean=, e15.7, 20x, 16hvariance        ,&
    &   10h         =, e15.7/10x, 26h25 pct wtd trimmed mean  =,&
    &   e15.7, 20x, 26hcoefficient of variation =, 13h    undefined/&
     &   98x, 14h(mean is zero))
1090 format(///20x, 46ha two-sided 95 pct confidence interval for mea,&
    &   4hn is, 1pe14.7, 4h to , e14.7, 6h (2-2)/20x, 13ha two-sided 9,&
    &   37h5 pct confidence interval for s.d. is, e14.7, 4h to ,&
     &   e14.7, 6h (2-7))
1100 format(///5x, 30hlinear trend statistics (5-1) , 30x, 6hother ,&
    &   10hstatistics//10x, 5hslope, 20x, 1h=, 1pe15.7, 20x, 7hminimum,&
    &   18x, 1h=, e15.7/10x, 13hs.d. of slope, 12x, 1h=, e15.7, 20x,&
    &   7hmaximum, 18x, 1h=, e15.7/10x, 26hslope/s.d. of slope = t  =,&
    &   e15.7, 20x, 8hbeta one, 17x, 1h=, e15.7/10x, 14hprob exceeding,&
    &   21h abs value of obs t =, 0pf6.3, 20x, 8hbeta two, 17x, 1h=,&
    & 1pe15.7/71x, 17hwtd sum of values, 8x, 1h=, e15.7/71x, 7hwtd sum,&
    &   11h of squares, 7x, 1h=, e15.7/5x, 24htests for non-randomness,&
    &   42x, 22hwtd sum of dev squared, 4h   =, e15.7/71x, 9hstudents ,&
     &   'T', 15x, 1h=, e15.7)
1110 format(10x, 26hno. of runs up and down  =, i5, 30x, 9hwtd sum a,&
    &   17hbsolute values  =, 1pe15.7/&
    &   10x, 26hexpected no. of runs     =,&
    &   0pf7.1, 28x, 26hwtd ave absolute values  =, 1pe15.7/&
    &   10x, 26hs.d. of no. of runs      =, 0pf8.2/&
    &   10x, 26hmean sq successive diff  =, 1x, 1pe16.7/&
    &   10x, 26hmean sq succ diff/var    =, 0pf9.3///&
    &   10x, 24hdeviations from wtd mean//&
    &   15x, 21hno. of + signs      =, i5/&
    &   15x, 21hno. of - signs      =, i5/&
    &   15x, 21hno. of runs         =, i5/&
    &   15x, 21hexpected no. of runs=, f7.1/&
    &   15x, 12hs.d. of runs, 8x, 1h=, f8.2/&
     &   15x, 21hdiff./s.d. of runs  =, f9.3)
1120 format(///49h note - items in parentheses refer to page number,&
     &   36h in nbs handbook 91 (natrella, 1966))
      end
!DEMOD
      subroutine demod (y, n, fd, fc, k, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE TO DEMODULATE SERIES
!     Y AT FREQUENCY FD, TO APPLY A LOW PASS FILTER WITH CUTOFF
!     FREQUENCY FC, AND TO EXTRACT THE AMPLITUDE AND PHASE COMPONENTS
!     OF THE RESULTING FILTERED SERIES (SHORT CALL).
!
!     WRITTEN BY  -  PETER BLOOMFIELD
!                    FOURIER ANALYSIS OF TIME SERIES- AN
!                       INTRODUCTION
!                    JOHN WILEY AND SONS, NEW YORK, 1976
!                    PAGE 147
!     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
!                                STATISTICAL ENGINEERING DIVISION
!                                NATIONAL BUREAU OF STANDARDS
!                                BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fc,fd
     integer&
     &   k,ldstak,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   temp
     integer&
     &   ampl,hlp,ifp,iprt,ldsmin,nall0,ndem,phase
     logical&
     &   err01,err02,err03,err04,err05,err06,err07,head
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     character&
    &   lfc(8)*1,lfd(8)*1,lk(8)*1,lkin(8)*1,llds(8)*1,ln(8)*1,&
     &   lnm1(8)*1,lone(8)*1,nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DEMDRV,EISGE,EISII,ERIODD,ERSII,ERSLFS,IPRINT,LDSCMP,
!     +   STKCLR,STKSET
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER AMPL
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05, ERR06, ERR07
!        VALUES INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     REAL FC
!        THE CUTOFF FREQUENCY USED FOR THE LOW PASS FILTER.
!     REAL FD
!        THE DEMODULATION FREQUENCY.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER HLP
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE ARRAY IN WHICH THE LOW PASS FILTER COEFFICIENTS ARE
!        STORED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER K
!        THE USER SUPPLIED NUMBER OF TERMS TO BE USED FOR THE LOW
!        PASS FILTER.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LFC(8), LFD(8), LK(8), LKIN(8), LLDS(8), LN(8),
!    *  LNM1(8), LONE(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THIS ROUTINE
!        WAS CALLED.
!     INTEGER NDEM
!        THE NUMBER OF VALUES IN THE DEMODULATED SERIES, I.E., IN
!        THE AMPLITUDE AND PHASE ARRAYS.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER PHASE
!        THE STARTING LOCATIONS IN RSTAK/DSTAK OF
!        THE ARRAY CONTAINING THE PRIMARY AND SECONDARY PHASE ESTIMATES.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL TEMP
!        A TEMPORARY VARIABLE USED FOR TYPE CONVERSION.
!     REAL Y(N)
!        THE INPUT ARRAY CONTAINING THE OBSERVED SERIES.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'D',       'E',       'M',       'O',       'D',       ' '/
     data&
    &  lfc(1), lfc(2), lfc(3), lfc(4), lfc(5), lfc(6), lfc(7), lfc(8)&
     & /  'F',   'C',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lfd(1), lfd(2), lfd(3), lfd(4), lfd(5), lfd(6), lfd(7), lfd(8)&
     & /  'F',   'D',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lk(1), lk(2), lk(3), lk(4), lk(5), lk(6), lk(7), lk(8)&
     & /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lkin(1), lkin(2), lkin(3), lkin(4), lkin(5), lkin(6), lkin(7),&
     &  lkin(8) /  '(',   '1',   '/',   'K',   ')',   ' ',   ' ',   ' '/
     data&
    &  llds(1), llds(2), llds(3), llds(4), llds(5), llds(6), llds(7),&
     &  llds(8) /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
     data&
    &  ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lnm1(1), lnm1(2), lnm1(3), lnm1(4), lnm1(5), lnm1(6), lnm1(7),&
     &  lnm1(8) /  '(',   'N',   '-',   '1',   ')',   ' ',   ' ',   ' '/
     data&
    &  lone(1), lone(2), lone(3), lone(4), lone(5), lone(6), lone(7),&
     &  lone(8) /  'O',   'N',   'E',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     PERFORM ERROR CHECKING ON INPUT DATA.
!
      ierr = 0
      head = .true.
!
      call eisge(nmsub, ln, n, 17, 1, head, err01, ln)
!
     call ersii(nmsub, lfd, fd,&
     &           0.0e0, 0.5e0, 2, head, err02, lfd, lfd)
!
      err03 = .true.
     if (.not. err01)&
     &  call eisii(nmsub, lk, k, 1, n-1, 1, head, err03, lone, lnm1)
!
      call eriodd(nmsub, lk, k, 1, head, err04)
!
      err05 = .true.
      if ((.not. err02) .and. (.not. err03) .and. (.not. err04)) then
         temp = k
        call ersii(nmsub, lfc, fc, 1.0e0/temp, fd, 1, head, err05,&
     &              lkin, lfd)
      end if
!
      err06 = .true.
     if ((.not. err03) .and. (.not. err04) .and. (.not. err05))&
     &   call erslfs(nmsub, fc, k, head, err06)
!
      if (err01 .or. err06) go to 10
!
      call ldscmp(3, 0, 0, 0, 0, 0, 'S', k + 3*n, ldsmin)
!
      call eisge(nmsub, llds, ldstak, ldsmin, 9, head, err07, llds)
!
!
      if (err02 .or. err03 .or. err04 .or. err05 .or. err07) go to 10
      go to 20
!
   10 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   20 continue
      call stkset (ldstak, 4)
      nall0 = stkst(1)
!
      ifp = 3
!
      ampl = stkget(n, ifp)
      phase = stkget(2*n, ifp)
      hlp = stkget(k, ifp)
!
      if (ierr .eq. 1) go to 10
!
     call demdrv(y, n, fd, fc, k, rstak(hlp), rstak(ampl),&
     &   rstak(phase), n, ndem, 1, nmsub)
!
      call stkclr(nall0)
!
      if (ierr .eq. 1) go to 10
!
      return
!
!     FORMAT STATEMENT
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL DEMOD (Y, N, FD, FC, K, LDSTAK)')
!
      end
!AOV1
      subroutine aov1(y, tag, n, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE -
!     1. CALLS OTHER ROUTINES TO CHECK THE INPUT PARAMETERS
!     2. SETS UP THE NEEDED STORAGE LOCATIONS, AND
!     3. CALLS AOV1MN TO COMPUTE A COMPREHENSIVE SET OF RESULTS FOR A
!     ONEWAY ANALYSIS OF VARIANCE WITH AUTOMATIC PRINTOUT.
!
!     WRITTEN BY -
!       LINDA MITCHELL
!       STATISTICAL ENGINEERING DIVISION
!       NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!                       BASED ON EARLIER VERSION BY J. R. DONALDSON
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   tag(*),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
    &   b10,dtmean,dtsd,dtsize,gpmax,gpmin,ifp,index,int,iprt,&
     &   itemp,nall0,ng,nprt,nztags,ranks,srank,tval
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AOV1ER,AOV1HD,AOV1MN,IPRINT,STKCLR
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER B10
!        STARTING LOCATION IN THE STACK AREA FOR B10
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER DTMEAN
!        THE STARTING LOCATION IN THE STACK AREA FOR THE MEANS
!        OF EACH GROUP
!     INTEGER DTSD
!        THE STARTING LOCATION IN THE STACK AREA OF THE
!        STANDARD DEVIATIONS
!     INTEGER DTSIZE
!        THE STARTING LOCATION IN THE STACK AREA OF THE SIZE OF THE
!        DIFFERENT GROUPS
!     INTEGER GPMAX
!        THE STARTING LOCATION IN THE STACK AREA OF MAXIMUM
!        OBSERVATION
!     INTEGER GPMIN
!        THE STARTING LOCATION IN THE STACK AREA OF THE MINUMUM
!        OBSERVATION
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG INDICATING WHETHER THERE
!        ARE ANY ERRORS, IF = 0 THEN NO ERRORS
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        SINGLE PRECISION AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER INDEX
!        THE STARTING LOCATION IN THE STACK ARRAY OF THE INDEX FOR
!        THE SORTED TAGS
!     INTEGER INT
!        FRAMEWORK CODE VALUE FOR INTEGER NUMBERS
!     INTEGER IPRT
!        THE OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ITEMP
!        STARTING LOCATION IN THE STACK FOR THE
!        TEMPORARY STORAGE ARRAY
!     INTEGER LDSTAK
!        SIZE OF THE STACK AREA ALLOCATED IN THE USERS MAIN PROGRAM
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS TO BE ANALYZED
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT THIS
!        ROUTINE WAS CALLED.
!     INTEGER NG
!        THE NUMBER OF GROUPS WITH DIFFERENT POSITIVE TAG VALUES
!     CHARACTER*1 NMSUB(6)
!        SUBROUTINE NAME
!     INTEGER NPRT
!        THE VARIABLE CONTROLLING AUTOMATIC PRINTOUT
!        IF =0, PRINTOUT IS SUPRESSED
!        OTHERWISE PRINTOUT IS PROVIDED
!     INTEGER NZTAGS
!        THE NUMBER OF OBSERVATIONS WITH POSITIVE NON-ZERO WIEGHTS
!     INTEGER RANKS
!        THE STARTING LOCATION IN WORK AREA FOR THE RANKS OF Y
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER SRANK
!        THE STARTING LOCATION IN STACK FOR THE SUM OF RANKS
!     REAL TAG(N)
!        THE VECTOR OF TAG VALUES
!     INTEGER TVAL
!        THE STARTING LOCATION IN THE STACK FOR THE VECTOR OF
!        THE DIFFERENT POSITIVE TAG VALUES, FOR AOV1
!     REAL Y(N)
!        THE VECTOR OF OBSERVATIONS
!
     data   nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6)&
     &     /      'A',      'O',      'V',      '1',      ' ',      ' '/
!
      call iprint(iprt)
!
!     SET UP FRAMEWORK VARIABLES FOR NUMBER TYPES
!
      int = 2
      ifp = 3
!
!     CHECK FOR ERRORS IN PARAMETERS, INITIALIZE STACK, AND SET NALL0.
!
     call aov1er(y, tag, n, n, nztags, ng, ldstak, nmsub, index, 1,&
     &   nall0)
!
      if (ierr.eq.0) go to 20
!
!     PRINT CORRECT FORM OF CALL STATEMENT AND RETURN TO CALLER
!
      ierr = 1
      write (iprt,1000)
      return
!
!     PRINT HEADING
!
   20 call aov1hd(iprt)
!
!     SET UP ADDITIONAL WORK VECTORS FOR AOV1MN AS CALLED FROM AOV1
!
      tval = stkget(ng,ifp)
      dtsize = stkget(ng,ifp)
      dtmean = stkget(ng,ifp)
      dtsd = stkget(ng,ifp)
      srank = stkget(ng,ifp)
      gpmin = stkget(ng,ifp)
      gpmax = stkget(ng,ifp)
      b10 = stkget(ng,ifp)
      ranks = stkget(nztags,ifp)
      itemp = stkget(nztags,int)
!
      nprt = 1
!
     call aov1mn(y, tag, n, rstak(tval), rstak(dtsize), rstak(dtmean),&
    &   rstak(dtsd), nprt, istak(index), rstak(srank), rstak(gpmin),&
    &   rstak(gpmax), rstak(b10), rstak(ranks),&
     &   istak(itemp), ng, nztags)
!
!     RELEASE THE STACK AREA
!
      call stkclr(nall0)
!
      return
!
!     FORMAT STATEMENT
!
1000 format(/42h the correct form of the call statement is//&
     &   '       CALL AOV1 (Y, TAG, N, LDSTAK)')
      end
!NLSX1
     subroutine nlsx1(mod, par, npar, pv, sdpv, res, sdres, vcv, n,&
     &   ivcv, nnzw, npare, rsd)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     SET THE STARTING PARAMETER VALUES FOR NLSX
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   ivcv,mod,n,nnzw,npar,npare
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),pv(n),res(n),sdpv(n),sdres(n),vcv(ivcv,ivcv)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   i,j
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL SETRV
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IVCV
!        THE ACTUAL FIRST DIMENSION OF VCV.
!     INTEGER MOD
!        AN INDICATOR VALUE USED TO DESIGNATE THE MODEL FOR WHICH
!        THE PARAMETERS ARE TO BE SET.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!        TO BE PROVIDED.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS ESTIMATED BY THE ROUTINE.
!     INTEGER NNZW
!        THE NUMBER OF NONZERO WEIGHTS.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL PV(N)
!        THE PREDICTED VALUES.
!     REAL RES(N)
!        THE RESIDUALS.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     REAL SDPV(N)
!        THE STANDARD DEVIATION OF THE PREDICTED VALUES.
!     REAL SDRES(N)
!        THE STANDARDIZED RESIDUALS.
!     REAL VCV(IVCV,IVCV)
!        THE VARIANCE COVARIANCE MATRIX.
!
!
!
      go to (10, 20, 30, 40, 50, 60), mod
!
   10 par(1) = 0.725e0
      par(2) = 4.0e0
!
      go to 70
!
!
   20 par(1) = 1.0e0
      par(2) = 2.0e0
      par(3) = 3.0e0
!
      go to 70
!
!
   30 par(1) = 6.0e0
      par(2) = 5.0e0
      par(3) = 4.0e0
      par(4) = 3.0e0
      par(5) = 2.0e0
!
      go to 70
!
!
   40 call setrv(par, npar, 0.0e0)
!
      go to 70
!
!
   50 call setrv(par, npar, 0.5e0)
!
      go to 70
!
!
   60 par(1) = 100.0e0
      par(2) = 15.0e0
!
   70 continue
!
      do 80 i=1,n
         res(i) = -1.0e0
         pv(i) = -1.0e0
         sdpv(i) = -1.0e0
         sdres(i) = -1.0e0
   80 continue
!
      do 100 i=1,ivcv
         do 90 j=1,ivcv
            vcv(i,j) = -1.0e0
   90    continue
  100 continue
!
      nnzw = -1
      npare = -1
      rsd = -1.0e0
!
      ierr = -1
!
      return
!
      end
!ERVWT
     subroutine ervwt (nmsub, nmvar1, wt, n, nnzwmn, head, nnzw,&
     &   nzw, msgtyp, error, nmvar2)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS USER SUPPLIED WEIGHTS TO ASSURE THERE
!     ARE NO NEGATIVE WEIGHTS, AND THAT THERE ARE SUFFICIENT POSITIVE
!     WEIGHTS FOR THE TASK.  IT RETURNS ERROR SET TO TRUE
!     IF NO ERRORS ARE FOUND, AND SET TO FALSE OTHERWISE, AND IN
!     ADDITION, RETURNS THE NUMBER OF NONZERO WEIGHTS AND THE NUMBER
!     OF ZERO WEIGHTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   msgtyp,n,nnzw,nnzwmn,nzw
     logical&
     &   error,head
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   wt(*)
     character&
     &   nmsub(6)*1,nmvar1(8)*1,nmvar2(8)*1
!
!  LOCAL SCALARS
     integer&
     &   i,iprt
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
!        PRINTED, WHERE IF ERROR IS TRUE AND
!        MSGTYP = 1, THE INPUT VALUE WAS TOO SMALL BASED ON LIMITS
!                    IMPOSED BY STARPAC.
!        MSGTYP = 2, THE INPUT VALUE WAS TOO SMALL BASED ON OTHER
!                    INPUT ARGUMENTS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR1(8)
!        THE CHARACTERS OF THE NAME OF THE ARGUMENT BEING CHECKED.
!     CHARACTER*1 NMVAR2(8)
!        THE CHARACTERS OF THE NAME OF THE ARGUMENT BEING CHECKED
!        AGAINST.
!     INTEGER NNZW
!        THE NUMBER OF NONZERO WEIGHTS.
!     INTEGER NNZWMN
!        THE MINIMUM NUMBER OF NONZERO WEIGHTS WHICH IS ACCEPTABLE.
!     INTEGER NZW
!        THE NUMBER OF ZERO WEIGHTS.
!     REAL WT(N)
!        THE WEIGHT VECTOR.
!
      error = .false.
!
      if (n.le.0) return
!
!     CHECK FOR NEGATIVE WEIGHTS AND COUNT NUMBER OF ZERO WEIGHTS.
!
      nzw = 0
      do 10 i = 1, n
         if (wt(i) .lt. 0.0e0) go to 20
         if (wt(i) .eq. 0.0e0) nzw = nzw + 1
   10 continue
!
      nnzw = n - nzw
      if (nnzw .ge. nnzwmn) return
!
!     INSUFFICIENT NUMBER OF POSITIVE WEIGHTS FOUND
!
      error = .true.
!
      call iprint(iprt)
!
      call ehdr(nmsub, head)
!
      write (iprt, 1010) nnzw
      if (msgtyp.eq.1) write(iprt, 1030) (nmvar1(i), i=1,6), nnzwmn
     if (msgtyp.eq.2) write(iprt,1040) (nmvar1(i),i=1,6),&
     &   (nmvar2(i),i=1,8)
!
      return
!
!     NEGATIVE WEIGHTS FOUND
!
   20 error = .true.
!
      call iprint(iprt)
      call ehdr(nmsub, head)
      write(iprt, 1020) (nmvar1(i), i = 1, 6)
!
      return
!
!     FORMAT STATEMENTS
!
1010 format(/&
     &   40h the number of nonzero weights found is , i6, '.')
1020 format(/&
    &   42h negative values were found in the vector , 6a1, '.'/&
     &   51h all weights must be greater than or equal to zero.)
1030 format(&
    &   34h the number of nonzero weights in , 6a1,&
     &   34h must be greater than or equal to , i6, '.')
1040 format(&
    &   34h the number of nonzero weights in , 6a1,&
     &   34h must be greater than or equal to , 8a1, '.')
!
      end
!DFBW
      subroutine dfbw (n, lag, w, lw, df, bw)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES AND STORES THE ASSOCIATED DEGREES OF
!     FREEDOM AND BANDWIDTH FOR A GIVEN LAG WINDOW.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   bw,df
     integer&
     &   lag,lw,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   w(lw)
!
!  LOCAL SCALARS
     integer&
     &   k
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL BW
!        THE BANDWIDTH.
!     REAL DF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     INTEGER K
!        AN INDEX VARIABLE
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES.
!     REAL W(LW)
!        THE VECTOR OF LAG WINDOWS.
!
      bw = 0.0_wp
      do 10 k = 1, lag
         bw = bw + w(k+1) * w(k+1) * (n-k)
   10 continue
!
      bw = 1.0_wp / (w(1)*w(1) + 2.0_wp*bw/n)
      df = 2.0_wp * bw * n
      return
      end
!CPYASF
      subroutine cpyasf (m, x, lx, y, iy)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COPIES THE ELEMENTS OF SYMMETRIC MATRIX X,
!     STORED ROW WISE, TO MATRIX Y.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iy,lx,m
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),y(iy,*)
!
!  LOCAL SCALARS
     integer&
     &   i,ij,j
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VALUE.
!     INTEGER IY
!        THE FIRST DIMENSION OF THE MATRIX Y.
!     INTEGER J
!        AN INDEX VALUE.
!     INTEGER LX
!        THE LENGTH OF SYMMETRIC MATRIX X, STORED ROW WISE.
!     INTEGER M
!        THE NUMBER OF COLUMNS OF DATA TO BE COPIED FROM MATRIX X.
!     REAL X(LX)
!        THE MATRIX TO BE COPIED FROM.
!     REAL Y(IY,M)
!        THE MATRIX TO BE COPIED TO.
!
      do 20 i = 1, m
         do 10 j = 1, i
            ij = i*(i-1)/2 + j
            y(i,j) = x(ij)
            y(j,i) = y(i,j)
   10    continue
   20 continue
!
      return
!
      end
!SRTRI
      subroutine srtri(a, la, ir)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!   FUNCTION     SRTRI  - SORT ARRAY A ON AN INTEGER ARRAY IR.
!                           IF THE INTEGER ARRAY IS A PERMUTATION
!                           VECTOR FOR THE ARRAY, THEN THE
!                           ARRAY IS RESTORED TO ITS ORIGINAL
!                           (UNPERMUTED) ORDER.
!                           PERMUTATIONS RETURNED
!   USAGE               - CALL SRTRI (A,LA,IR)
!   PARAMETERS   A(LA)  - ON INPUT, CONTAINS THE ARRAY TO BE SORTED
!                         ON OUTPUT, A CONTAINS THE SORTED ARRAY
!                LA     - INPUT VARIABLE CONTAINING THE NUMBER OF
!                           ELEMENTS IN THE ARRAY TO BE SORTED
!                IR(LA) - ON INPUT, CONTAINS THE INTEGER KEY ARRAY
!                         ON OUTPUT, CONTAINS THE SORTED KEY ARRAY
!                           1,2,...,LA.
!                       - THEN ON OUTPUT, IR CONTAINS A RECORD OF THE
!                           PERMUTATIONS MADE ON THE VECTOR A.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   la
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   a(la)
     integer&
     &   ir(la)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   r,t,tt
     integer&
     &   i,ij,it,itt,j,k,l,m
!
!  LOCAL ARRAYS
     integer&
     &   il(21),iu(21)
!
!  INTRINSIC FUNCTIONS
      intrinsic int
!
!
      m = 1
      i = 1
      j = la
      r = .375e0
   10 if (i.eq.j) go to 90
      if (r.gt.0.5898437e0) go to 20
      r = r + 3.90625e-2
      go to 30
   20 r = r - .21875e0
   30 k = i
!                                  SELECT A CENTRAL ELEMENT OF THE
!                                  ARRAY AND SAVE IT IN LOCATION IT
      ij = i + int((j-i)*r)
      t = a(ij)
      it = ir(ij)
!                                  IF FIRST ELEMENT OF ARRAY IS GREATER
!                                  THAN IT, INTERCHANGE WITH IT
      if (ir(i).le.it) go to 40
      a(ij) = a(i)
      a(i) = t
      t = a(ij)
      ir(ij) = ir(i)
      ir(i) = it
      it = ir(ij)
   40 l = j
!                                  IF LAST ELEMENT OF ARRAY IS LESS THAN
!                                  IT, INTERCHANGE WITH IT
      if (ir(j).ge.it) go to 60
      a(ij) = a(j)
      a(j) = t
      t = a(ij)
      ir(ij) = ir(j)
      ir(j) = it
      it = ir(ij)
!                                  IF FIRST ELEMENT OF ARRAY IS GREATER
!                                  THAN IT, INTERCHANGE WITH IT
      if (ir(i).le.it) go to 60
      a(ij) = a(i)
      a(i) = t
      t = a(ij)
      ir(ij) = ir(i)
      ir(i) = it
      it = ir(ij)
      go to 60
   50 tt = a(l)
      a(l) = a(k)
      a(k) = tt
      itt = ir(l)
      ir(l) = ir(k)
      ir(k) = itt
!                                  FIND AN ELEMENT IN THE SECOND HALF OF
!                                  THE ARRAY WHICH IS SMALLER THAN IT
   60 l = l - 1
      if (ir(l).gt.it) go to 60
!                                  FIND AN ELEMENT IN THE FIRST HALF OF
!                                  THE ARRAY WHICH IS GREATER THAN IT
   70 k = k + 1
      if (ir(k).lt.it) go to 70
!                                  INTERCHANGE THESE ELEMENTS
      if (k.le.l) go to 50
!                                  SAVE UPPER AND LOWER SUBSCRIPTS OF
!                                  THE ARRAY YET TO BE SORTED
      if (l-i.le.j-k) go to 80
      il(m) = i
      iu(m) = l
      i = k
      m = m + 1
      go to 100
   80 il(m) = k
      iu(m) = j
      j = l
      m = m + 1
      go to 100
!                                  BEGIN AGAIN ON ANOTHER PORTION OF
!                                  THE UNSORTED ARRAY
   90 m = m - 1
      if (m.eq.0) return
      i = il(m)
      j = iu(m)
  100 if (j-i.ge.1) go to 30
      if (i.eq.1) go to 10
      i = i - 1
  110 i = i + 1
      if (i.eq.j) go to 90
      t = a(i+1)
      it = ir(i+1)
      if (ir(i).le.it) go to 110
      k = i
  120 a(k+1) = a(k)
      ir(k+1) = ir(k)
      k = k - 1
      if (it.lt.ir(k)) go to 120
      a(k+1) = t
      ir(k+1) = it
      go to 110
      end
!DCKLS1
     subroutine dckls1(n, m, ixm, par, npar, neta, ntau, nrow, scale,&
     &   nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     SET UP PROBLEM SPECIFICATION FOR TESTING THE USER CALLABLE
!     ROUTINES IN THE (LEAST SQUARES) STEP SIZE SELECTION FAMILY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,m,n,neta,npar,nprt,nrow,ntau
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(10),scale(10)
!
!  LOCAL SCALARS
     integer&
     &   i
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
!     REAL PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL SCALE(10)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!
!
      par(1) = 1.0e0
      par(2) = 3.125e0
      par(3) = 1.0e0
      par(4) = 2.0e0
!
      n = 101
      m = 1
      ixm = 200
      npar = 4
      do 10 i=1,10
         scale(i) = 1.0e0
   10 continue
      scale(2) = 0.01e0
      neta = 0
      ntau = 0
      nrow = 1
      nprt = 1
!
      return
!
      end
!LLSPW
      subroutine llspw(y, wt, xm, n, ndeg, res, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     CALL FOR POLYNOMIAL MODEL LEAST SQUARES FIT
!     USER SUPPLIED WEIGHTS SPECIFIED
!     NO STORAGE OTHER THAN RESIDUALS
!     FOUR PAGES AUTOMATIC PRINTOUT
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak,n,ndeg
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   res(*),wt(*),xm(*),y(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   iprt,ivcv,lpar,lpv,lsdpv,lsdres,lwt,npar,nprt
     logical&
     &   save,weight
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   par(1),pv(1),sdpv(1),sdres(1),vcv(1,1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LLCNTP
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDEG
!        THE DEGREE OF THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     REAL PAR(1)
!        A DUMMY ARRAY FOR
!        THE PARAMETERS  TO BE ESTIMATED.
!     REAL PV(1)
!        A DUMMY ARRAY FOR
!        THE PREDICTED VALUES.
!     REAL RES(N)
!        THE RESIDUALS.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     REAL SDPV(1)
!        A DUMMY ARRAY FOR
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(1)
!        A DUMMY ARRAY FOR
!        THE STANDARDIZED RESIDUALS.
!     REAL VCV(1,1)
!        A DUMMY ARRAY FOR
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(N)
!        A DUMMY ARRAY FOR
!        THE WEIGHTS.
!     REAL XM(N,1)
!        THE INDEPENDENT VARIABLE.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'L','L','S','P','W',' '/
!
!     SET PARAMETERS NECESSARY FOR THE COMPUTATIONS
!
      weight = .true.
      save = .false.
      nprt = 1111
      lpar = 1
      lpv = 1
      lsdpv = 1
      lsdres = 1
      ivcv = 1
      lwt = n
!
     call llcntp(y, wt, lwt, xm, n, ndeg, npar, res, ldstak, nprt,&
    &   par, lpar, rsd, pv, lpv, sdpv, lsdpv, sdres, lsdres, vcv, ivcv,&
     &   nmsub, weight, save)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (//42h the correct form of the call statement is//&
     &   50h       call llspw (y, wt, x, n, ndeg, res, lsdtak))
      end
!PARZEN
      subroutine parzen (lag, w, lw)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES AND STORES THE PARZEN LAG WINDOW
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lag,lw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   w(lw)
!
!  LOCAL SCALARS
     integer&
     &   k,l
!
!  INTRINSIC FUNCTIONS
      intrinsic real
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER K
!        AN INDEX VARIABLE
!     INTEGER L
!        THE VALUE LAG/2.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     REAL W(LW)
!        THE VECTOR OF LAG WINDOWS.
!
      l = lag/2
      w(1) = 1.0e0
      if (l.le.0) go to 15
      do 10 k = 1, l
         w(k+1) = real(k) / real(lag)
         w(k+1) = 1.0e0 + 6.0e0 * w(k+1) * w(k+1) * (w(k+1) - 1.0e0)
   10 continue
!
   15 continue
      l = l + 1
      do 20 k = l, lag
         w(k+1) = 1.0e0 - real(k) / real(lag)
         w(k+1) = 2.0e0 * w(k+1) * w(k+1) * w(k+1)
   20 continue
!
      return
      end
!FFTCT
      subroutine fftct(x, n2, ix)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     COSINE TRANSFORM OF N=2*N2 SYMMETRIC DATA POINTS
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ix,n2
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(ix)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   a2,aa,ab,cd,cn,ex,pi,save,sd,sn
     integer&
     &   i,isn,j,k,m,m1,n1,nk
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL FFT,GETPI,REALTR
!
!  INTRINSIC FUNCTIONS
      intrinsic sin
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AA, AB, A2
!     REAL CD, CN
!     REAL EX
!     INTEGER I, ISN
!     INTEGER IX
!        THE DIMENSION OF X.
!     INTEGER J
!     INTEGER K
!     INTEGER M, M1
!     INTEGER NK, N1
!     INTEGER N2
!        THE HALF LENGTH OF THE SYMMETRIC DATA ARRAY.  N2 MUST BE EVEN.
!     REAL PI
!        THE VALUE OF PI.
!     REAL SAVE, SD, SN
!     REAL X(IX)
!        THE N2+2 VECTOR WITH FIRST HALF OF SYMMETRIC DATA STORED IN
!        THE FIRST N2+1 LOCATIONS.  LOCATION N2+2 USED ONLY FOR
!        WORKSPACE.  THE COSINE TRANSFORM COEFFICIENTS ARE RETURNED
!        IN THE FIRST N2+1 LOCATIONS OF X.
!
      call getpi(pi)
!
      a2 = 0.0e0
      n1 = n2 + 1
      do 10 j=2,n2,2
         a2 = a2 + x(j)
   10 continue
      a2 = 2.0e0*a2
      m = n2/2
      m1 = m + 1
      ex = x(2)
      x(2) = 0.0e0
      if (n1.lt.4) go to 30
      do 20 i=4,n1,2
         save = ex - x(i)
         ex = x(i)
         x(i) = save
   20 continue
   30 x(n2+2) = 0.0e0
      isn = -2
      call realtr(x, x(2), m, isn)
      call fft(x, x(2), m, m, m, isn)
      sd = pi / (2*n2)
      cd = 2.0e0*sin(sd)**2
      sd = sin(sd+sd)
      sn = 0.0e0
      cn = 1.0e0
      nk = n2 + 2
      do 40 j=2,m1
         k = nk - j
         aa = x(j) + x(k)
         ab = (x(j)-x(k))*0.5e0
         ex = cn - (cd*cn+sd*sn)
         sn = (sd*cn-cd*sn) + sn
         cn = 0.5e0/(ex*ex+sn*sn) + 0.5e0
         sn = cn*sn
         cn = cn*ex
         ex = ab/sn
         x(j) = (aa+ex)*0.5e0
         x(k) = (aa-ex)*0.5e0
   40 continue
      ex = x(1)
      x(1) = ex + a2
      x(n2+1) = ex - a2
      x(n2+2) = 0.0e0
      return
      end
!CORRER
      subroutine correr(nmsub, m, n, iym, ivcv, ldstak, icor, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS FOR ERRORS IN THE INPUT
!     PARAMETERS.  IF ANY ARE FOUND A FLAG IS SET AND
!     COMPUTATION STOPS
!
!     WRITTEN BY -
!        LINDA L. MITCHELL
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   icor,ivcv,iym,ldstak,m,n,nprt
!
!  ARRAY ARGUMENTS
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   ip,iprt,is,ldsmin
     logical&
     &   err01,err02,err03,err04,err05,head
!
!  LOCAL ARRAYS
     character&
    &   livcv(8)*1,liym(8)*1,llds(8)*1,lm(8)*1,ln(8)*1,&
     &   lthree(8)*1,ltwo(8)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,IPRINT,LDSCMP
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
!                  VALUE(S) INDICATING WHETHER OR ERROR WAS DETECTED
!                  (TRUE) OR NOT (FALSE).
!     LOGICAL HEAD
!                  A FLAG INDICATING WHETHER THE HEADING SHOULD BE
!                  PRINTED (TRUE) OR NOT (FALSE).  IF A HEADING IS
!                  PRINTED, THE VALUE OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER ICOR
!                  DETERMINES WHICH SUBROUTINE CALLED CORRER
!                  IF =1, THEN CALLED BY CORR
!                     =2, THEN CALLED BY CORRS
!     INTEGER IERR
!                  A FLAG, THAT WHEN RETURNED BY THIS ROUTINE DESIGNATES
!                  WHETHER  ERRORS WERE DETECTED IN THE PARAMETER LIST
!                  IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!                  IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IP
!                  A TEMPORARY VARIABLE USED FOR COMPUTING LDSMIN.
!     INTEGER IPRT
!                  THE LOGICAL OUTPUT UNIT
!     INTEGER IS
!                  A TEMPORARY VARIABLE USED FOR COMPUTING LDSMIN.
!     INTEGER IVCV
!                  THE DIMENSION OF SC
!     INTEGER IYM
!                  ACTUAL ROW DIMENSION OF YM
!     INTEGER LDSMIN
!                  THE MINIMUM LENGTH ALLOWED FOR DSTAK
!     INTEGER LDSTAK
!                  THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK
!     CHARACTER*1 LIVCV(8), LIYM(8), LLDS(8), LM(8), LN(8), LTHREE(8),
!    *  LTWO(8)
!                  THE ARRAY(S) CONTAINING THE NAME(S) OF THE
!                  VARIABLE(S) CHECKED FOR ERRORS.
!     INTEGER M
!                  NUMBER OF VARIABLES
!     INTEGER N
!                  THE NUMBER OFOBSERVATIONS
!     CHARACTER*1 NMSUB(6)
!                  THE NAME OF THE CALLING SUBROUTINE.
!     INTEGER NPRT
!                  THE VARIABLE CONTROLLING THE PRINTED OUTPUT.
!                  IF NPRT=0, OUTPUT IS SUPPRESSED, OTHERWISE IT IS NOT
!
!
!     SET UP NAME ARRAYS
!
     data  livcv(1), livcv(2), livcv(3), livcv(4), livcv(5), livcv(6),&
     &      livcv(7), livcv(8) / 'I', 'V', 'C', 'V', ' ', ' ', ' ', ' '/
     data   liym(1),  liym(2),  liym(3),  liym(4),  liym(5),  liym(6),&
     &       liym(7),  liym(8) / 'I', 'Y', 'M', ' ', ' ', ' ', ' ', ' '/
     data   llds(1),  llds(2),  llds(3),  llds(4),  llds(5),  llds(6),&
     &       llds(7),  llds(8) / 'L', 'D', 'S', 'T', 'A', 'K', ' ', ' '/
     data     lm(1),    lm(2),    lm(3),    lm(4),    lm(5),    lm(6),&
     &         lm(7),    lm(8) / 'M', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
     data     ln(1),    ln(2),    ln(3),    ln(4),    ln(5),    ln(6),&
     &         ln(7),    ln(8) / 'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
     data lthree(1),lthree(2),lthree(3),lthree(4),lthree(5),lthree(6),&
     &     lthree(7),lthree(8) / 'T', 'H', 'R', 'E', 'E', ' ', ' ', ' '/
     data   ltwo(1),  ltwo(2),  ltwo(3),  ltwo(4),  ltwo(5),  ltwo(6),&
     &       ltwo(7),  ltwo(8) / 'T', 'W', 'O', ' ', ' ', ' ', ' ', ' '/
!
      call iprint(iprt)
!
      head = .true.
!
      ierr = 0
!
!     BEGIN ERROR CHECKING. THE COMMENTS STATE WHAT CONSTITUTES AN
!     ERROR. COMMENTS ENCLOSED BY STARS(**) INDICATE THE ERROR CONDITION
!
!     **NUMBER OF VARIABLES LESS THAN 2**
!
      call eisge(nmsub, lm, m, 2, 2, head, err01, ltwo)
!
!     **NUMBER OF OBSERVATIONS LESS THAN 3**
!
      call eisge(nmsub, ln, n, 3, 2, head, err02, lthree)
!
!     **OBSERVATION MATRIX DIMENSIONED LESS THAN N**
!
      err03 = .false.
     if (.not.err02) call eisge(nmsub, liym, iym, n, 3, head, err03,&
     &   ln)
!
!     **SC MATRIX DIMENSIONED LESS THAN M**
!
      err04 = .false.
     if ((icor.eq.2) .and. (.not.err01)) call eisge(nmsub, livcv,&
     &   ivcv, m, 3, head, err04, lm)
!
      if (err01 .or. err02) go to 40
      is = 0
      if (icor.eq.1) is = 1
!
      ip = 1
      if (nprt.eq.0) ip = 0
!
!
!     CHECK FOR ENOUGH COMMON FOR THIS PROBLEM
!
     call ldscmp(12, 0, ip*max(n,m), 0, 0, 0, 'S',&
     &   is*m*m + ip*(max(n,m)+m+n*(m+3)+6*m*m), ldsmin)
!
      call eisge(nmsub, llds, ldstak, ldsmin, 9, head, err05, llds)
!
      if (err01 .or. err02 .or. err03 .or. err04 .or. err05) go to 40
      return
!
!     SET IERR TO INDICATE AN ERROR
!
   40 continue
      ierr = 1
      return
      end
!XCORR
      subroutine xcorr(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE EXERCISES ALL ASPECTS OF THE CORRELATION
!     FAMILY ROUTINES
!
!     WRITTEN BY -
!        LINDA MITCHELL
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   i,iprt,ivcv,iym,j,ldsmin,m,n
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   vcv(4,4),ym(10,4),z(10,4)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL CORR,CORRS,CORRXP,GENR,IPRINT,LDSCMP,MSGX,SETRA
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!         AN INDEX VARIABLE.
!     INTEGER IERR
!        COMMON FLAG INDICATING IF ANY ERRORS WERE DETECTED
!        IF IERR = 0, THEN NO ERRORS WERE FOUND
!     INTEGER IPRT
!        THE OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IVCV
!        THE ROW DIMENSION OF VCV
!     INTEGER IYM
!        THE ROW DIMENSION OF YM
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER LDSMIN
!        THE SMALLEST ACCEPTABLE SIZE OF COMMON AREA CSTAK
!     INTEGER LDSTAK
!        THE SIZE OF THE COMMON AREA CSTAK
!     INTEGER M
!        THE NUMBER OF VARIABLES
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS
!     REAL VCV(4,4)
!        THE VARIANCE COVARIANCE MATRIX
!     REAL YM(10,4)
!        GENERAL DATA SET, FROM DRAPER AND SMITH
!     REAL Z(10,4)
!        TEST OBSERVATION MATRIX
!
!     THIS DATA SET TAKEN FROM
!        APPLIED REGRESSION ANALYSIS
!        DRAPER AND SMITH
!        PAGE 216
!
     data     ym(1,1),   ym(1,2),   ym(1,3),   ym(1,4)&
     &    /      42.2e0,  11.2e0,  31.9e0, 167.1e0/
     data     ym(2,1),   ym(2,2),   ym(2,3),   ym(2,4)&
     &    /      48.6e0,  10.6e0,  13.2e0, 174.4e0/
     data     ym(3,1),   ym(3,2),   ym(3,3),   ym(3,4)&
     &    /      42.6e0,  10.6e0,  28.7e0, 160.8e0/
     data     ym(4,1),   ym(4,2),   ym(4,3),   ym(4,4)&
     &    /      39.0e0,  10.4e0,  26.1e0, 162.0e0/
     data     ym(5,1),   ym(5,2),   ym(5,3),   ym(5,4)&
     &    /      34.7e0,   9.3e0,  30.1e0, 140.8e0/
     data     ym(6,1),   ym(6,2),   ym(6,3),   ym(6,4)&
     &    /      44.5e0,  10.8e0,   8.5e0, 174.6e0/
     data     ym(7,1),   ym(7,2),   ym(7,3),   ym(7,4)&
     &    /      39.1e0,  10.7e0,  24.3e0, 163.7e0/
     data     ym(8,1),   ym(8,2),   ym(8,3),   ym(8,4)&
     &    /      40.1e0,  10.0e0,  18.6e0, 174.5e0/
     data     ym(9,1),   ym(9,2),   ym(9,3),   ym(9,4)&
     &    /      45.9e0,  12.0e0,  20.4e0, 185.7e0/
!
!     DETERMINE OUTPUT UNIT
!
      call iprint(iprt)
!
      ivcv = 4
      iym = 10
      m = 4
      n = 9
      ierr = 0
!
!**** TEST ROUTINES WITH CORRECT CALL STATEMENT *****
!
      write (iprt,1000)
      write (iprt,1010)
!
!     TEST CORR
!
      write (iprt,1020)
      write (iprt,1060)
      call corr(ym, n, m, iym, ldstak)
      call msgx(0, iprt)
!
!     TEST CORRS
!
!     PRINTOUT SUPPRESSED
!
      write (iprt,1030)
      write (iprt,1040)
      write (iprt,1060)
      call corrs(ym, n, m, iym, ldstak, 0, vcv, ivcv)
      call msgx(0, iprt)
!
!     PRINT STORED OUTPUT AND ZERO ARRAYS
!
      call corrxp(m, vcv, ivcv, iprt)
!
!     WITH PRINTOUT
!
      write (iprt,1050)
      write (iprt,1060)
      call corrs(ym, n, m, iym, ldstak, 1, vcv, ivcv)
      call msgx(0, iprt)
!
!     PRINT STORED OUTPUT
!
      call corrxp(m, vcv, ivcv, iprt)
!
!**** SPECIAL 2 COLUMN MATRIX ****
!
      write (iprt,1070)
      write (iprt,1060)
      call corr(ym, n, 2, iym, ldstak)
      call msgx(0, iprt)
!
!**** TEST WORK AREA REQUIREMENTS ****
!
!     TEST CORR
!
     call ldscmp(12, 0, max(n,m), 0, 0, 0, 'S',&
     &   m*m + (max(n,m)+m+n*(m+3)+6*m*m), ldsmin)
      write (iprt,1090)
      call corr(ym, n, m, iym, ldsmin-1)
      call msgx(1, iprt)
      write (iprt,1100)
      call corr(ym, n, m, iym, ldsmin)
      call msgx(0, iprt)
!
!     TEST CORRS WITH PRINTOUT
!
     call ldscmp(12, 0, max(n,m), 0, 0, 0, 'S',&
     &   max(n,m)+m+n*(m+3)+6*m*m, ldsmin)
      write (iprt,1090)
      call corrs(ym, n, m, iym, ldsmin-1, 1, vcv, ivcv)
      call msgx(1, iprt)
      write (iprt,1100)
      call corrs(ym, n, m, iym, ldsmin, 1, vcv, ivcv)
      call corrxp(m, vcv, ivcv, iprt)
      call msgx(0, iprt)
!
!     TEST CORRS WITHOUT PRINTOUT
!
      call ldscmp(12, 0, 0, 0, 0, 0, 'S', 0, ldsmin)
      write (iprt,1090)
      call corrs(ym, n, m, iym, ldsmin-1, 0, vcv, ivcv)
      call msgx(1, iprt)
      write (iprt,1100)
      call corrs(ym, n, m, iym, ldsmin, 0, vcv, ivcv)
      call corrxp(m, vcv, ivcv, iprt)
      call msgx(0, iprt)
!
!**** NUMBER OF VARIABLES LESS THAN 2 ****
!
      write (iprt,1110)
!
!     TEST CORR
!
      call corr(ym, n, 1, iym, ldstak)
      call msgx(1, iprt)
!
!     TEST CORRS
!
      call corrs(ym, n, 1, iym, ldstak, 1, vcv, ivcv)
      call msgx(1, iprt)
!
!**** NUMBER OF OBSERVATIONS LESS THAN 3 ****
!
      write (iprt,1120)
!
!     TEST CORR
!
      call corr(ym, 2, 4, iym, ldstak)
      call msgx(1, iprt)
!
!     TEST CORRS
!
      call corrs(ym, 2, 4, iym, ldstak, 1, vcv, ivcv)
      call msgx(1, iprt)
!
!**** OBSERVATION MATRIX DIMENSIONED LESS THAN N ****
!
      write (iprt,1150)
!
!     TEST CORR
!
      call corr(ym, n, m, 8, ldstak)
      call msgx(1, iprt)
!
!     TEST CORRS
!
      call corrs(ym, n, m, 8, ldstak, 1, vcv, ivcv)
      call msgx(1, iprt)
!
!**** VCV MATRIX DIMENSIONED LESS THAN M ****
!
      write (iprt,1130)
      call corrs(ym, n, m, iym, ldstak, 1, vcv, 2)
      call msgx(1, iprt)
!
!**** ALL OBSERVATIONS ON A SINGLE VARIABLE EQUAL TO ZERO ****
!
      write (iprt,1140)
      call setra(z, 10, 4, 10, 0.0e0)
      call corr(z, 9, 4, 10, ldstak)
      call msgx(1, iprt)
      call corrs(z, 9, 4, 10, ldstak, 1, vcv, ivcv)
      call corrxp(m, vcv, ivcv, iprt)
      call msgx(1, iprt)
!
      do 10 i=1,10
         z(i,1) = i
         z(i,2) = 0.0e0
   10 continue
      call corr(z, 10, 4, 10, ldstak)
      call msgx(1, iprt)
!
!**** ARRAY FILLED WITH A SINGLE VALUE ****
!
      write (iprt,1160)
      call setra(z, 10, 4, 10, 4.0e0)
      call corr(z, 4, 10, 4, ldstak)
      call msgx(1, iprt)
!
!**** 2 COLUMNS THE SAME ****
!
      do 20 i=1,3
         call genr(z(1,i), 5, 5.0e0*i, 5.0e0*i)
   20 continue
      do 30 i=1,5
         z(i,4) = z(i,3)
   30 continue
      write (iprt,1170)
      call corr(z, 5, 4, 10, ldstak)
      call msgx(1, iprt)
!
!**** 2 COLUMNS INVERSELY RELATED ****
!
      j = 5
      do 40 i=1,5
         j = j - 1
         z(j,4) = z(i,3)
   40 continue
      write (iprt,1170)
      call corr(z, 5, 4, 10, ldstak)
      call msgx(1, iprt)
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format('1')
 1010 format(' ****TEST ROUTINES WITH CORRECT CALL****')
 1020 format(' TEST OF CORR')
 1030 format('1TEST OF CORRS')
 1040 format(' PRINTOUT SUPRESSED.')
 1050 format('1PRINTOUT NOT SUPRESSED.')
 1060 format(' DRAPER AND SMITH DATA SET (PAGE 216).')
 1070 format('1****SPECIAL CASE 2 COLUMN MATRIX****')
 1090 format('1****TEST WITH INSUFFICIENT WORK AREA****')
 1100 format('1****TEST WITH EXACTLY THE RIGHT AMOUNT OF WORK AREA****')
 1110 format('1****NUMBER OF VARIABLES LESS THAN 2****')
 1120 format(' ****NUMBER OF OBSERVATIONS LESS THAN 3****')
 1130 format(' ****INADEQUATE SPACE IN STORAGE ARRAYS****')
 1140 format('1****ALL OBSERVATIONS ON A VARIABLE EQUAL TO ZERO****')
1150 format(' ****OBSERVATION MATRIX DIMENSIONED LESS THAN NUMBER',&
     &       ' OF OBSERVATIONS DESIGNATED****')
 1160 format('1****ARRAY CONTAINING A SINGLE VALUE****')
 1170 format('1****2 COLUMNS RELATED****')
      end
!DEMODU
      subroutine demodu (y, n, fd, ampl, phas)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE DEMODULATES THE SERIES Y AT FREQUENCY
!     FD.  THE REAL AND IMAGINARY PARTS OF THE DEMODULATED
!     SERIES ARE RETURNED IN AMPL AND PHAS, RESPECTIVELY.
!
!     WRITTEN BY  -  PETER BLOOMFIELD
!                    FOURIER ANALYSIS OF TIME SERIES- AN
!                       INTRODUCTION
!                    JOHN WILEY AND SONS, NEW YORK, 1976
!                    PAGE 148
!     ADAPTED FOR STARPAC BY  -  JANET R. DONALDSON
!                                STATISTICAL ENGINEERING DEVISION
!                                NATIONAL BUREAU OF STANDARDS
!                                BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fd
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ampl(n),phas(n),y(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   arg,pi
     integer&
     &   i
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL GETPI
!
!  INTRINSIC FUNCTIONS
      intrinsic cos,sin
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL AMPL(N)
!        THE ARRAY IN WHICH THE AMPLITUDES ARE STORED.
!     REAL ARG
!        A VALUE USED IN COMPUTING THE DEMODULATED SERIES.
!     REAL FD
!        THE DEMODULATION FREQUENCY.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES BEING DEMODULATED.
!     REAL PHAS(N)
!        THE ARRAYS CONTAINING THE PRIMARY PHASE ESTIMATES.
!     REAL PI
!        THE VALUE OF PI.
!     REAL Y(N)
!        THE INPUT ARRAY ARRAY CONTAINING THE OBSERVED SERIES.
!
      call getpi(pi)
!
      do 10 i = 1, n
         if (fd.eq.0.25e0) then
            ampl(i) = 0.0e0
            phas(i) = -2.0e0*y(i)
         else if (fd.eq.0.5e0) then
            ampl(i) = -2.0e0*y(i)
            phas(i) = 0.0e0
         else
            arg = (i-1) * fd * 2.0e0 * pi
            ampl(i) = y(i)*cos(arg)*2.0e0
            phas(i) = -y(i)*sin(arg)*2.0e0
         end if
   10 continue
      return
      end
!AIMFS
     subroutine aimfs(y, n, mspec, nfac, par, npar, ldstak,&
     &   nfcst, nfcsto, ifcsto, nprt, fcst, ifcst, fcstsd)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR ARIMA ESTIMATION
!     (CONTROL CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ifcst,ldstak,n,nfac,nfcst,nfcsto,npar,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   fcst(*),fcstsd(*),par(*),y(*)
     integer&
     &   ifcsto(*),mspec(4,*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,nfcstu
     logical&
     &   save
!
!  LOCAL ARRAYS
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AMFCNT,IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FCST(IFCST,NFCSTO)
!        THE STORAGE ARRAY FOR THE FORECASTS.
!     REAL FCSTSD(NFCST)
!        THE STORAGE ARRAY FOR THE STANDARD DEVIATIONS OF THE FORECASTS.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFCST
!        THE FIRST DIMENSION OF THE ARRAY FCST.
!     INTEGER IFCSTO(NFCSTO)
!        THE INDICES OF THE ORIGINS FOR THE FORECASTS.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER MSPEC(4,NFAC)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL
!     INTEGER NFCST
!        THE NUMBER OF FORECASTS.
!     INTEGER NFCSTO
!        THE NUMBER OF THE ORIGINS.
!     INTEGER NFCSTU
!        THE NUMBER OF FORCASTES ACTUALLY USED.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'A','I','M','F','S',' '/
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      save = .true.
!
      if ((nfcst.ge.1) .and. (nfcst.le.n)) then
         nfcstu = nfcst
      else
         nfcstu = (n/10)+1
      end if
!
     call amfcnt(y, n, mspec, nfac, par, npar, ldstak, nfcstu,&
     &   max(1,nfcsto), ifcsto, nprt, fcst, ifcst, fcstsd, nmsub, save)
!
      if (ierr.ne.1) return
!
!     PRINT PROPER CALL SEQUENCE
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/' THE CORRECT FORM OF THE CALL STATEMENT IS'//&
    &  '       CALL AIMFS (Y, N, MSPEC, NFAC, PAR, NPAR, LDSTAK,'/&
    &  '      +            NFCST, NFCSTO, IFCSTO, NPRT, FCST, IFCST,',&
     &  ' FCSTSD)')
      end
!MAFLT
      subroutine maflt (y, n, k, yf, nyf)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE PERFORMS A SIMPLE MOVING AVERAGE FILTERING
!     OPERATION ON AN INPUT SERIES Y, RETURNING THE FILTERED SERIES
!     IN YF.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   k,n,nyf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*),yf(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   hma
     integer&
     &   iprt
     logical&
     &   err01,err02,err03,head
!
!  LOCAL ARRAYS
     character&
     &   lk(8)*1,ln(8)*1,lone(8)*1,nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,EISII,ERIODD,FLTMA,IPRINT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     REAL HMA
!        THE VALUE OF EACH OF THE SIMPLE MOVING AVERAGE LINEAR FILTER
!        COEFFICIENTS.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS.
!     CHARACTER*1 LK(8), LN(8), LONE(8)
!        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES K AND N.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NYF
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YF.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YF(N)
!        THE VECTOR IN WHICH THE FILTERED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'M',       'A',       'F',       'L',       'T',       ' '/
     data&
    &  lk(1), lk(2), lk(3), lk(4), lk(5), lk(6), lk(7), lk(8)&
     & /  'K', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
     data&
    &  ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /  'N', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
     data&
    &  lone(1), lone(2), lone(3), lone(4), lone(5), lone(6), lone(7),&
     &  lone(8)  /  ' ', ' ', 'O', 'N', 'E', ' ', ' ', ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 3, 1, head, err01, ln)
!
      call eisii(nmsub, lk, k, 1, n, 1, head, err02, lone, ln)
!
      call eriodd(nmsub, lk, k, 1, head, err03)
!
      if (err01 .or. err02 .or. err03) go to 10
      go to 20
!
   10 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   20 continue
!
!     COMPUTE THE SIMPLE MOVING AVERAGE COEFFICIENTS
!
      hma = k
      hma = 1.0e0/hma
!
      call fltma (y, n, k, hma, yf, nyf)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL MAFLT (Y, N, K, YF, NYF)')
      end
!NLER
     subroutine nler (nmsub, weight, wt, lwt, n, m, ixm,&
    &   ifixed, lifixd, npar, npare,&
     &   ldstak, ldsmin, stp, lstp, scale, lscale, ivcv, save, nnzw)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE ERROR CHECKING ROUTINE FOR NONLINEAR LEAST SQUARES
!     ESTIMATION ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
    &   ivcv,ixm,ldsmin,ldstak,lifixd,lscale,lstp,lwt,m,n,nnzw,&
     &   npar,npare
     logical&
     &   save,weight
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   scale(*),stp(*),wt(*)
     integer&
     &   ifixed(*)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   i,nfix,nnfix,nv,nzw
     logical&
     &   head
!
!  LOCAL ARRAYS
     logical&
     &   error(20)
     character&
    &   lifix(8)*1,livcv(8)*1,lixm(8)*1,llds(8)*1,lm(8)*1,&
    &   ln(8)*1,lnpar(8)*1,lnpare(8)*1,lone(8)*1,lscl(8)*1,&
     &   lstep(8)*1,lwgt(8)*1,lzero(8)*1
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL EISGE,EIVEQ,ERVGT,ERVWT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR(20)
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1
!    +   LIFIX(8), LIVCV(8), LIXM(8), LLDS(8), LM(8), LN(8), LNPAR(8),
!    +   LNPARE(8), LONE(8), LSCL(8), LSTEP(8), LWGT(8), LZERO(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NZW
!        THE NUMBER OF ZERO WEIGHTS.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL STP(LSTP)
!        THE STEP SIZE ARRAY.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!
!
!     SET UP NAME ARRAYS
!
     data lifix(1), lifix(2), lifix(3), lifix(4), lifix(5),&
     &   lifix(6), lifix(7), lifix(8) /'I','F','I','X','E','D',' ',' '/
     data livcv(1), livcv(2), livcv(3), livcv(4), livcv(5),&
     &   livcv(6), livcv(7), livcv(8) /'I','V','C','V',' ',' ',' ',' '/
     data lixm(1), lixm(2), lixm(3), lixm(4), lixm(5), lixm(6),&
     &   lixm(7), lixm(8) /'I','X','M',' ',' ',' ',' ',' '/
     data llds(1), llds(2), llds(3), llds(4), llds(5), llds(6),&
     &   llds(7), llds(8) /'L','D','S','T','A','K',' ',' '/
     data lm(1), lm(2), lm(3), lm(4), lm(5), lm(6), lm(7), lm(8) /'M',&
     &   ' ',' ',' ',' ',' ',' ',' '/
     data ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8) /'N',&
     &   ' ',' ',' ',' ',' ',' ',' '/
     data lnpar(1), lnpar(2), lnpar(3), lnpar(4), lnpar(5),&
    &   lnpar(6), lnpar(7), lnpar(8) /'N','P','A','R',' ',' ',' ',&
     &   ' '/
     data lnpare(1), lnpare(2), lnpare(3), lnpare(4), lnpare(5),&
    &   lnpare(6), lnpare(7), lnpare(8) /'N','P','A','R','E',' ',' ',&
     &   ' '/
     data lone(1), lone(2), lone(3), lone(4), lone(5),&
     &   lone(6), lone(7), lone(8) /'O','N','E',' ',' ',' ',' ',' '/
     data lscl(1), lscl(2), lscl(3), lscl(4), lscl(5),&
    &   lscl(6), lscl(7), lscl(8) /'S','C','A','L','E',' ',' ',&
     &   ' '/
     data lstep(1), lstep(2), lstep(3), lstep(4), lstep(5),&
     &   lstep(6), lstep(7), lstep(8) /'S','T','P',' ',' ',' ',' ',' '/
     data lwgt(1), lwgt(2), lwgt(3), lwgt(4), lwgt(5),&
     &   lwgt(6), lwgt(7), lwgt(8) /'W','T',' ',' ',' ',' ',' ',' '/
     data lzero(1), lzero(2), lzero(3), lzero(4), lzero(5),&
     &   lzero(6), lzero(7), lzero(8) /'Z','E','R','O',' ',' ',' ',' '/
!
!     ERROR CHECKING
!
      do 10 i=1,20
         error(i) = .false.
   10 continue
!
      ierr = 0
      head = .true.
      nnzw = n
!
      call eisge(nmsub, lnpar, npar, 1, 2, head, error(1), lone)
      if (error(1)) then
        error(7) = .true.
      else
        if (ifixed(1).lt.0) then
          call eisge(nmsub, ln, n, npar, 2, head, error(7), lnpar)
          if (weight) then
           call ervwt(nmsub, lwgt, wt, lwt, npar, head, nnzw,&
     &                 nzw, 2, error(3), lnpar)
          end if
        else
         call eiveq(nmsub, lifix, ifixed, npar, 0, 1, head, nnfix,&
     &               nfix, 1, error(2), lzero, lone)
          if (.not.error(2)) then
            call eisge(nmsub, ln, n, npare, 2, head, error(7), lnpare)
            if (weight) then
             call ervwt(nmsub, lwgt, wt, lwt, npare, head, nnzw,&
     &                   nzw, 2, error(3), lnpare)
            end if
          end if
        end if
      end if
!
      call eisge(nmsub, lm, m, 1, 2, head, error(4), lone)
!
     if (.not.error(7))&
     &   call eisge(nmsub, lixm, ixm, n, 3, head, error(5), ln)
!
!
      if (.not.error(1)) then
        if ((.not.error(2)) .and. (.not.error(7)))&
    &      call eisge(nmsub, llds, ldstak, ldsmin, 9, head, error(6),&
     &      llds)
!
        call ervgt(nmsub, lstep, stp, lstp, 0.0e0, 0, head, 6, nv,&
     &      error(8), lzero)
!
        call ervgt(nmsub, lscl, scale, lscale, 0.0e0, 0, head, 6, nv,&
     &      error(12), lzero)
!
        if (save)&
    &      call eisge(nmsub, livcv, ivcv, npare, 3, head, error(15),&
     &      lnpare)
      end if
!
!
      do 20 i=1,20
         if (error(i)) go to 30
   20 continue
      return
!
   30 continue
      ierr = 1
      return
!
      end
!GFSLFS
      subroutine gfslfs (h, k, nf, fmin, fmax, gain, freq, nprt, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE
!     GAIN FUNCTION OF A SYMMETRIC LINEAR FILTER (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fmax,fmin
     integer&
     &   k,ldstak,nf,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(*),gain(*),h(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   delta,fmn,fmx,ypltmn,ypltmx
     integer&
     &   igferr,io,iprt,isort,ldsmin,nall0,nord,xord,yord
     logical&
     &   err01,err02,err03,err04,err05,head,sym
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     character&
     &   lh(8)*1,lk(8)*1,llds(8)*1,lnf(8)*1,nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,ERIODD,ERSLF,GFORD,GFOUT,GFSEST,IPRINT,LDSCMP,
!     +   SETFRQ,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic max,min
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL ERR01, ERR02, ERR03, ERR04, ERR05
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     REAL FMAX, FMIN
!        THE MINIMUM AND MAXIMUM FREQUENCY FOR WHICH THE GAIN
!        FUNCTION IS TO BE ESTIMATED.
!     REAL FMN, FMX
!        THE FREQUENCY RANGE ACTUALLY USED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        HAS BEEN ESTIMATED.
!     REAL GAIN(NF)
!        THE VECTOR IN WHICH THE GAIN FUNCTION ESTIMATES ARE
!        STORED.
!     REAL H(K)
!        THE ARRAY OF SYMMETRIC LINEAR FILTER COEFFICIENTS.
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IGFERR
!        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
!        TO HAVE PRODUCED REASONABLE RESULTS.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED,
!        BASED ON PRINTED OUTPUT.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION IN ISTAK FOR
!        THE ARRAY USED FOR SORTING.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LH(8), LK(8), LLDS(8), LNF(8)
!        THE ARRAYS CONTAINING THE NAMES OF THE CHECKED VARIABLES
!     INTEGER NALL0
!        THE NUMBER OF OUTSTANDING STACK ALLOCATIONS.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE GAIN FUNCTION
!        IS TO BE ESTIMATED.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NORD
!        THE NUMBER OF POINTS TO BE PLOTTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL SYM
!        THE VARIABLE USED TO INDICATE WHETHER THE GAIN FUNCTION
!        COMPUTED WAS FOR A SYMMETRIC OR AUTOREGRESSIVE FILTER.
!     INTEGER XORD
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE X COORDINATES FOR THE GAIN FUNCTION PLOT
!     INTEGER YORD
!        THE STARTING LOCATION IN RSTAK/DSTAK OF
!        THE Y COORDINATES FOR THE GAIN FUNCTION PLOT
!     REAL YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE Y AXIS.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'G',       'F',       'S',       'L',       'F',       'S'/
     data&
    &  lh(1), lh(2), lh(3), lh(4), lh(5), lh(6), lh(7), lh(8)&
     & /  'H',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lk(1), lk(2), lk(3), lk(4), lk(5), lk(6),&
     &  lk(7), lk(8) /'K', ' ', ' ', ' ', ' ', ' ', ' ', ' '/
     data&
    &  llds(1), llds(2), llds(3), llds(4), llds(5), llds(6), llds(7),&
     &  llds(8) /  'L',   'D',   'S',   'T',   'A',   'K',   ' ',   ' '/
     data&
    &  lnf(1), lnf(2), lnf(3), lnf(4), lnf(5), lnf(6), lnf(7), lnf(8)&
     & /  'N',   'F',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
      io = 1
      if (nprt .eq. 0) io = 0
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, lk, k, 1, 1, head, err01, lk)
      call eriodd(nmsub, lk, k, 1, head, err02)
      err03 = .true.
     if ((.not. err01) .and. (.not. err02))&
     &   call erslf(nmsub, lh, k, h, head, err03)
      call eisge(nmsub, lnf, nf, 1, 1, head, err04, lnf)
!
      if (err04) go to 10
!
      call ldscmp(3*io, 0, io*nf, 0, 0, 0, 'S', 2*io*nf, ldsmin)
      call eisge(nmsub, llds, ldstak, ldsmin, 9, head, err05, llds)
!
      if (err01 .or. err02 .or. err03 .or. err05) go to 10
      go to 20
!
   10 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   20 continue
!
      if (nprt .ne. 0) then
        call stkset (ldstak, 4)
        nall0 = stkst(1)
      else
        nall0 = 0
      end if
!
!     SET VARIOUS PROGRAM PARAMETERS
!
      sym = .true.
!
      delta = 1.0e0
!
!     SET FREQUENCIES AT WHICH THE GAIN FUNCTION IS TO BE ESTIMATED
!
      fmn = max(fmin, 0.0e0)
      fmx = min(fmax, 0.5e0)
      if (fmn.ge.fmx) then
        fmn = 0.0e0
        fmx = 0.5e0
      end if
      call setfrq (freq, nf, 2, fmn, fmx, delta)
!
!     COMPUTE THE GAIN FUNCTION
!
      call gfsest (h, k, nf, freq, gain, delta)
!
      if (nprt .eq. 0) return
!
!     SET VARIOUS POINTERS FOR THE PLOTTING ARRAYS
!
      xord = stkget(nf, 3)
      yord = stkget(nf, 3)
!
      isort = stkget(nf, 2)
!
      if (ierr .eq. 1) go to 10
!
!     PLOT THE RESULTS
!
     call gford (freq, gain, istak(isort), nf, rstak(xord),&
     &   rstak(yord), nord, ypltmn, ypltmx, nprt, igferr)
     call gfout (rstak(xord), rstak(yord), nord, freq, gain, nf, k,&
     &   sym, fmn, fmx, ypltmn, ypltmx, nprt, igferr, nmsub)
!
      call stkclr(nall0)
!
      if (ierr .eq. 1) go to 10
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL GFSLFS (H, K, NF, FMIN, FMAX, GAIN, FREQ, NPRT,',&
     &   ' LDSTAK)')
      end
!STPADJ
     subroutine stpadj(xm, n, m, ixm, mdl, par, npar,&
    &   nexmpt, stp, nfail, ifail, j, reltol, abstol, stplow, stpmid,&
     &   stpup, itemp, fd, fdlast, pv, pvnew)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE ADJUSTS THE SELECTED STEP SIZES TO OPTIMAL
!     VALUES.
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   abstol,reltol,stp,stplow,stpmid,stpup
     integer&
     &   ixm,j,m,n,nexmpt,nfail,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   fd(n),fdlast(n),par(npar),pv(n),pvnew(n),xm(ixm,m)
     integer&
     &   ifail(n),itemp(n)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  SCALARS IN COMMON
     real(kind=wp) ::&
     &   q
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   factor,stpnew,temp
     integer&
     &   ncount
     logical&
     &   done,first
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL CMPFD,ICOPY,RELCOM
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,sign
!
!  COMMON BLOCKS
      common /notopt/q
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ABSTOL
!        THE ABSOLUTE AGREEMENT TOLERANCE.
!     LOGICAL DONE
!        THE VARIABLE USED TO INDICATE WHETHER THE ADJUSTMENT
!        PROCESS IS COMPLETE OR NOT.
!     REAL FACTOR
!        A FACTOR USED IN COMPUTING THE STEP SIZE.
!     REAL FD(N)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!     REAL FDLAST(N)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!        COMPUTED WITH THE MOST RECENT STEP SIZE SELECTED.
!     LOGICAL FIRST
!        THE VARIABLE USED TO INDICATE WHETHER THIS STEP SIZE
!        IS BEING USED FOR THE FIRST TIME OR WHETHER IT HAS BEEN
!        PREVIOUSLY ADJUSTED.
!     INTEGER IFAIL(N)
!        AN INDICATOR VECTOR USED TO DESIGNATE THOSE OBSERVATIONS
!        FOR WHICH THE STEP SIZE DOES NOT MEET THE CRITERIA.
!     INTEGER ITEMP(N)
!        A TEMPORARY VECTOR USED FOR STORING PAST VALUES OF ITEMP.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NCOUNT
!        THE NUMBER OF OBSERVATIONS AT WHICH THE NEW STEP SIZE DOES
!        SATISFY THE CRITERIA.
!     INTEGER NEXMPT
!        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
!        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
!        SIZE STILL BE CONSIDERED OK.
!     INTEGER NFAIL
!        A VECTOR CONTAINING FOR EACH OBSERVATION THE NUMBER OF
!        OBSERVATIONS FOR WHICH THE STEP SIZE DID NOT MEET THE CRITERIA.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL PVNEW(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCD.
!     REAL Q
!        A DUMMY VARIABLE WHICH IS USED, ALONG WITH COMMON NOTOPT (NO
!        OPTIMIZATION), TO COMPUTE THE STEP SIZE.
!     REAL RELTOL
!        THE RELATIVE AGREEMENT TOLERANCE.
!     REAL STP
!        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FORWARD
!        DIFFERENCE APPROXIMATION TO THE DERIVATIVE.
!     REAL STPLOW
!        THE LOWER LIMIT ON THE STEP SIZE.
!     REAL STPMID
!        THE MIDPOINT OF THE ACCEPTABLE RANGE OF THE STEP SIZE.
!     REAL STPNEW
!        THE VALUE OF THE NEW STEP SIZE BEING TESTED.
!     REAL STPUP
!        THE UPPER LIMIT ON THE STEP SIZE.
!     REAL TEMP
!        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
!        PARAMETER IS STORED.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      call icopy(n, ifail, 1, itemp, 1)
      ncount = nfail
!
      if ((stplow.le.abs(stp)) .and. (abs(stp).le.stpup)) return
!
      if (abs(stp).gt.stpmid) then
!
            stpnew = stpup * sign(1.0e0, par(j))
            factor = 10.0e0
      else
!
            stpnew = stplow * sign(1.0e0, par(j))
            factor = 0.1e0
!
      end if
!
      q = stpnew + par(j)
      stpnew = q - par(j)
!
      done = .false.
      first = .true.
!
!     REPEAT STATEMENTS 60 TO 130 UNTIL (DONE)
!
   60 continue
!
         call scopy(n, fd, 1, fdlast, 1)
!
         temp = par(j)
         par(j) = temp + stpnew
         call mdl(par, npar, xm, n, m, ixm, pvnew)
         par(j) = temp
!
         call cmpfd(n, stpnew, pvnew, pv, fd)
!
         call relcom(n, fd, fdlast, reltol, abstol, ncount, itemp)
!
         if (ncount.le.nexmpt) then
               done = .true.
               call icopy(n, itemp, 1, ifail, 1)
               nfail = ncount
!
               if (first) then
                     stp = stpnew
               else
                     stp = stpnew / factor
               end if
!
         else
!
               first = .false.
               stpnew = stpnew * factor
               q = stpnew + par(j)
               stpnew = q - par(j)
!
              if ((factor.gt.1.0e0 .and. abs(stpnew).gt.abs(stp))&
    &            .or.&
    &            (factor.lt.1.0e0 .and. abs(stpnew).lt.abs(stp)))&
     &            done = .true.
          end if
!
      if (done) then
         return
      else
         go to 60
      end if
!
      end
!XHIST
      subroutine xhist(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS PROGRAM TESTS FEATURES OF THE HIST FAMILY TO ENSURE THAT
!     ALL ASPECTS OF THE HIST FAMILY ROUTINES WORK CORRECTLY.
!
!     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   ylb,yub
     integer&
     &   i,iprt,ldsmin,n,ncell,nconst,nprtof,nprton
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   y(84),yconst(10),ylong(200),ypath(10)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL HIST,HISTC,IPRINT,LDSCMP,NRAND
!
!  INTRINSIC FUNCTIONS
      intrinsic anint,log10,min,nint,real
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        A LOOP INDEX.
!     INTEGER IERR
!        FLAG TO INDICATE PRESENCE OF ERROR DETECTED BY PRECEDING
!        STARPAC CALL.  (0 IS OK, 1 IS ERROR)
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER LDSMIN
!        THE MINIMUM AMOUNT OF WORK AREA NEEDED FOR A GIVEN PROBLEM.
!     INTEGER LDSTAK
!        AMOUNT OF WORK AREA.  SIZE OF DSTAK.
!     INTEGER N
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER NCELL
!        THE USER SUPPLIED VALUE FOR THE NUMBER OF CELLS IN THE
!        HISTOGRAM.  IF NCELL IS LESS THAN OR EQUAL TO ZERO, THE
!        NUMBER OF CELLS TO BE USED (NCELLS) WILL BE CALCULATED FROM
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NCONST
!        LENGTH OF THE VECTOR YCONST.
!     INTEGER NPRTOF
!        FLAG FOR NO OUTPUT (EXCEPT ERROR MESSAGES).
!     INTEGER NPRTON
!        FLAG FOR FULL PRINTOUT.
!     REAL Y(84)
!        DATA VECTOR FOR TESTS.
!     REAL YCONST(10)
!        VECTOR OF CONSTANT DATA.
!     REAL YLB
!        THE LOWER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!     REAL YLONG(200)
!        LONG VECTOR OF DATA
!     REAL YPATH(10)
!        A VECTOR OF Y VALUES DESIGNED TO FORCE DIFFERENT PATHS
!        THROUGH THE SUMMATION ROUTINES.
!     REAL YUB
!        THE UPPER BOUND FOR SELECTING DATA FROM Y FOR THE HISTOGRAM.
!
!     DATA INITIALIZATIONS.
!
      data n /84/
      data nconst /10/
      data nprton /1/
      data nprtof /0/
      data ncell/10/
      data ylb/0.60e0/, yub/0.63e0/
!
!     DAVIS-HARRISON R.H. DATA, PIKES PEAK.
!
!     THIS IS AN ARBITRARILY CHOSEN DATA SET.
!
     data y( 1), y( 2), y( 3), y( 4)&
     &    / 0.6067e0, 0.6087e0, 0.6086e0, 0.6134e0/
     data y( 5), y( 6), y( 7)&
     &    / 0.6108e0, 0.6138e0, 0.6125e0/
     data y( 8), y( 9), y(10), y(11)&
     &    / 0.6122e0, 0.6110e0, 0.6104e0, 0.7213e0/
     data y(12), y(13), y(14)&
     &    / 0.7078e0, 0.7021e0, 0.7004e0/
     data y(15), y(16), y(17), y(18)&
     &    / 0.6981e0, 0.7242e0, 0.7268e0, 0.7418e0/
     data y(19), y(20), y(21)&
     &    / 0.7407e0, 0.7199e0, 0.6225e0/
     data y(22), y(23), y(24), y(25)&
     &    / 0.6254e0, 0.6252e0, 0.6267e0, 0.6218e0/
     data y(26), y(27), y(28)&
     &    / 0.6178e0, 0.6216e0, 0.6192e0/
     data y(29), y(30), y(31), y(32)&
     &    / 0.6191e0, 0.6250e0, 0.6188e0, 0.6233e0/
     data y(33), y(34), y(35)&
     &    / 0.6225e0, 0.6204e0, 0.6207e0/
     data y(36), y(37), y(38), y(39)&
     &    / 0.6168e0, 0.6141e0, 0.6291e0, 0.6231e0/
     data y(40), y(41), y(42)&
     &    / 0.6222e0, 0.6252e0, 0.6308e0/
     data y(43), y(44), y(45), y(46)&
     &    / 0.6376e0, 0.6330e0, 0.6303e0, 0.6301e0/
     data y(47), y(48), y(49)&
     &    / 0.6390e0, 0.6423e0, 0.6300e0/
     data y(50), y(51), y(52), y(53)&
     &    / 0.6260e0, 0.6292e0, 0.6298e0, 0.6290e0/
     data y(54), y(55), y(56)&
     &    / 0.6262e0, 0.5952e0, 0.5951e0/
     data y(57), y(58), y(59), y(60)&
     &    / 0.6314e0, 0.6440e0, 0.6439e0, 0.6326e0/
     data y(61), y(62), y(63)&
     &    / 0.6392e0, 0.6417e0, 0.6412e0/
     data y(64), y(65), y(66), y(67)&
     &    / 0.6530e0, 0.6411e0, 0.6355e0, 0.6344e0/
     data y(68), y(69), y(70)&
     &    / 0.6623e0, 0.6276e0, 0.6307e0/
     data y(71), y(72), y(73), y(74)&
     &    / 0.6354e0, 0.6197e0, 0.6153e0, 0.6340e0/
     data y(75), y(76), y(77)&
     &    / 0.6338e0, 0.6284e0, 0.6162e0/
     data y(78), y(79), y(80), y(81)&
     &    / 0.6252e0, 0.6349e0, 0.6344e0, 0.6361e0/
     data y(82), y(83), y(84)&
     &    / 0.6373e0, 0.6337e0, 0.6383e0/
!
!     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
!
      call iprint(iprt)
!
!     CHECK FOR SUFFICIENT WORK AREA LENGTH.
!
      if (ldstak.lt.300) then
        write (iprt, 1000)
         return
      end if
!
      do 20 i=1,nconst
         yconst(i) = 1.0e0
   20 continue
!
!     HEADING.
!
      write (iprt,1150)
!
!     TEST 1.  CHECK ALL ERROR MESSAGES.
!
      write (iprt,1160)
!
!     ERROR 1, ZERO OR FEWER ELEMENTS.
!
      write (iprt,1180)
      call hist(y, 0, ldstak)
      write (iprt, 1350)
      write (iprt, 1360) (y(i), i = 1, n)
      write (iprt,1170) ierr
      call histc(y, 0, ncell, ylb, yub, ldstak)
      write (iprt, 1350)
      write (iprt, 1360) (y(i), i = 1, n)
      write (iprt,1170) ierr
!
!     ERROR 2, NOT ENOUGH SPACE IN CSTAK.
!
      write (iprt,1190)
     call ldscmp(2, 0, n, 0, 0, 0, 'S',&
     &            min(nint(5.5+1.5*anint(log10(real(n)))),25),ldsmin)
      call hist(y, n, ldsmin-1)
      write (iprt,1170) ierr
      write (iprt,1195)
      call hist(y, n, ldsmin)
      write (iprt,1170) ierr
      write (iprt,1190)
      call ldscmp(2, 0, n, 0, 0, 0, 'S', ncell, ldsmin)
      call histc(y, n, ncell, ylb, yub, ldsmin-1)
      write (iprt,1170) ierr
      write (iprt,1195)
      call histc(y, n, ncell, ylb, yub, ldsmin)
      write (iprt,1170) ierr
!
!     CONSTANT Y. (NOT AN ERROR)
!
      write (iprt,1200)
      call hist(yconst, nconst, ldstak)
      write (iprt,1170) ierr
      write (iprt,1200)
      call histc(yconst, nconst, ncell, ylb, yub, ldstak)
      write (iprt,1170) ierr
!
!     ERROR 4, NO DATA WITHIN USER SUPPLIED LIMITS
!
      write (iprt, 1110)
      call histc(y, n, 0, 4.0e0, 10.0e0, ldstak)
      write (iprt, 1170) ierr
!
!     TEST 2.  MAKE A WORKING RUN OF EACH ROUTINE TO CHECK
!     THE OUTPUT.
!
      write (iprt,1300)
      write (iprt,1310)
      call hist(y, n, ldstak)
      write (iprt, 1350)
      write (iprt, 1360) (y(i), i = 1, n)
      write (iprt,1170) ierr
!
      write (iprt,1340)
      call histc(y, n, ncell, ylb, yub, ldstak)
      write (iprt, 1350)
      write (iprt, 1360) (y(i), i = 1, n)
      write (iprt,1170) ierr
!
!     RUN DATA SET 6.7.
!
      do 90 i=1,10
         ypath(i) = 0.0e0
   90 continue
      ypath(1) = -1.0e0
      ypath(10) = 1.0e0
      write (iprt,1130)
      call hist(ypath, nconst, ldstak)
      write (iprt,1170) ierr
      write (iprt, 1130)
      call histc(ypath, nconst, 0, 0.0e0, 0.0e0, ldstak)
      write (iprt, 1130)
      call histc(ypath, nconst, 1, 0.0e0, 0.0e0, ldstak)
      write (iprt, 1130)
      call histc(ypath, nconst, 0, -0.5e0, 0.5e0, ldstak)
      write (iprt, 1130)
      call histc(ypath, nconst, 0, 1.0e0, 4.0e0, ldstak)
!
!     RUN DATA SET 6.8
!
      write (iprt, 1120)
      call nrand (ylong, 200, 3254767)
      call hist (ylong, 200, ldstak)
      return
!
!     FORMATS
!
1000 format ('1THE DIMENSION OF DSTAK AND THE VALUE OF LDSTAK NEEDED'/&
    &  ' FOR HISTX MUST EQUAL OR EXCEED 300.  CHANGE DRIVER'/&
     &  ' AND RECALL HISTX.')
 1110 format (41h1try no data within user supplied limits.)
 1120 format (38h1run hist on 200 pseudo-randon numbers)
 1130 format(24h1run hist on -1, 8*0, 1.)
 1150 format (48h1test runs for the histogram family of routines.)
1160 format(47h test 1.  generate one of each of the possible ,&
     &   15herror messages.)
 1170 format(22h the value of ierr is , i4)
 1180 format(28h try zero or fewer elements.)
 1190 format('1TEST WITH INSUFFICIENT WORK AREA')
 1195 format(' TEST WITH EXACTLY THE RIGHT AMOUNT OF WORK AREA.')
 1200 format('1TRY CONSTANT Y. (NOT AN ERROR)')
1300 format(52h1test 4.  make working runs of all routines to check,&
     &   12h the output.)
 1310 format(48h1run hist on the davis-harrison pikes peak data.)
 1340 format(49h1run histc on the davis-harrison pikes peak data.)
1350 format(/48h print the data to insure the original order has,&
     &   15h been restored.)
 1360 format (7f10.5)
      end
!CCFM
      subroutine ccfm (y1, y1miss, y2, y2miss, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR COMPUTING THE CROSS
!     CORRELATIONS OF TWO TIME SERIES WITH MISSING OBSERVATIONS
!     (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   y1miss,y2miss
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y1(*),y2(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   y1mean,y1sd,y2mean,y2sd
     integer&
    &   iccov,inlppc,iprt,iym,iymfft,jccov,jnlppc,lagmax,ldsmin,&
     &   ldstak,lglst1,lglst2,lyfft,m,nfft,nused1,nused2
     logical&
     &   isfft,islong
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ccov(101,2,2),rhoc(201),sdrhoc(201)
     integer&
     &   nlppc(101,2,2)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACVFM,CCFER,CCFMNM,CCFOUT,IPRINT,SETLAG
!
!  INTRINSIC FUNCTIONS
      intrinsic min,sqrt
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCOV(101, 2, 2)
!        THE ARRAY USED FOR THE CCVF ESTIMATES.
!     INTEGER ICCOV
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER INLPPC
!        THE ACTUAL FIRST DIMENSION OF THE ARRAY NLPPC AS SPECIFIEC
!        IN THE USERS PROGRAM.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     LOGICAL ISFFT
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX F (ISFFT = TRUE) OR NOT (ISFFT = FALSE)
!     LOGICAL ISLONG
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER THE CALLING
!        ROUTINE HAS SUFFIX S (ISLONG = TRUE) OR NOT (ISLONG = FALSE)
!     INTEGER IYM
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YM AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER IYMFFT
!        THE ACTUAL FIRST DIMENSION OF THE MATRIX YMFFT AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JCCOV
!        THE ACTUAL SECOND DIMENSION OF THE ARRAY CCOV, AS
!        SPECIFIED IN THE USERS PROGRAM.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC AS SPECIFIED
!        IN THE USERS PROGRAM.
!     INTEGER LAGMAX
!        THE NUMBER OF AUTOCORRELATIONS DESIRED.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LGLST1, LGLST2
!        THE LAG VALUE OF THE LAST ACVF WHICH COULD BE COMPUTED
!        FOR SERIES 1 AND 2, RESPECTIVELY, BEFORE MISSING DATA
!        CAUSED A MISSING ACVF.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR YFFT.
!     INTEGER M
!        THE NUMBER OF SERIES BEING COMPARED, IE THE
!        NUMBER OF COLUMNS OF DATA IN YM.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NFFT
!        THE NUMBER OF OBSERVATIONS IN THE EXTENDED SERIES.
!     INTEGER NLPPC(101, 2, 2)
!        THE NUMBER OF LAGGED PRODUCT PAIRS USED TO COMPUTE THE CCVF.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINE.
!     INTEGER NUSED1, NUSED2
!        THE NUMBER OF ACTIVE (NON MISSING) OBSERVATIONS IN SERIES
!        1 AND 2, RESPECTIVELY.
!     REAL RHOC(201)
!        THE CCF ESTIMATES.
!     REAL SDRHOC(201)
!        THE ARRAY CONTAINING THE SD OF THE CCFM.
!     REAL Y1(N), Y1MEAN, Y1MISS, Y1SD
!        THE FIRST SERIES, AND ITS MEAN, MISSING VALUE CODE AND
!        STANDARD DEVIATION.
!     REAL Y2(N), Y2MEAN, Y2MISS, Y2SD
!        THE SECOND SERIES, AND ITS MEAN, MISSING VALUE CODE AND
!        STANDARD DEVIATION.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'C',       'C',       'F',       'M',       ' ',       ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      iccov = 101
      inlppc = 101
      iym = n
      jccov = 2
      jnlppc = 2
      ldsmin = 0
      ldstak = 0
      lagmax = 1
      lyfft = n + lagmax
      iymfft = lyfft
      m = 2
      nfft = n
      isfft = .false.
      islong = .false.
!
!     CALL ERROR CHECKING ROUTINES
!
     call ccfer(nmsub, n, lagmax, ldstak, ldsmin, iccov, jccov,&
     &  inlppc, jnlppc, m, lyfft, nfft, iym, iymfft, isfft, islong)
!
!     CHECK WHETHER AN ERROR HAS BEEN DETECTED
!
      if (ierr.eq.0) then
!
!       SET THE MAXIMUM LAG VALUE TO BE USED.
!
        call setlag (n, lagmax)
!
!       COMPUTE THE SERIES ACVF AND SD
!
       call acvfm (y1, y1miss, n, y1mean, ccov(1,1,1), lagmax, lglst1,&
     &     nlppc(1,1,1), 101)
!
        nused1 = nlppc(1,1,1)
        y1sd = sqrt(ccov(1,1,1) * n / (nused1-1))
!
       call acvfm (y2, y2miss, n, y2mean, ccov(1,2,2), lagmax, lglst2,&
     &     nlppc(1,2,2), 101)
!
        nused2 = nlppc(1,2,2)
        y2sd = sqrt(ccov(1,2,2) * n / (nused2-1))
!
!       CALL ROUTINE FOR MAIN AUTOCORRELATION COMPUTATIONS.
!
       if (ccov(1,1,1)*ccov(1,2,2) .ne. 0.0e0)&
    &    call ccfmnm (y1, y1miss, y2, y2miss, n, lagmax, 201,&
    &    ccov(1,1,1),&
    &    ccov(1,2,2), ccov(1,1,2), ccov(1,2,1), 101, nlppc(1,1,1),&
    &    nlppc(1,2,2), nlppc(1,1,2), nlppc(1,2,1), 101, y1mean, y2mean,&
     &    rhoc, sdrhoc, 1, min(lglst1, lglst2))
!
!       CALL ROUTINE TO PRINT OUT AUTOCORRELATIONS
!
       call ccfout (1, y1mean, y1sd, n, nused1, 2, y2mean, y2sd, n,&
    &     nused2, lagmax, 201, rhoc, sdrhoc, .true., nlppc(1,1,2),&
     &     nlppc(1,2,1), 101, y1miss, y2miss, .false.)
      end if
!
      if (ierr.ne.0) then
!
!     PRINT PROPER CALL SEQUENCE AND RETURN
!
        ierr = 1
        call iprint (iprt)
        write (iprt, 1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format(/42h the correct form of the call statement is//&
     &   44h       call ccfm (y1, ymiss1, y2, ymiss2, n))
      end
!VPLMT
     subroutine vplmt (ym, ymmiss, n, m, iym, ylb, yub, ymn,&
     &  ymx, error, nmsub, miss, nsampl)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SETS THE PLOT LIMITS FOR VERTICAL PLOTS
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ylb,ymn,ymx,yub
     integer&
     &   iym,m,n,nsampl
     logical&
     &   error,miss
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(iym,m),ymmiss(m)
     character&
     &   nmsub(6)*1
!
!  LOCAL SCALARS
     integer&
     &   i,ii,iprt,j
     logical&
     &   head,setlmt
!
!  EXTERNAL FUNCTIONS
!      LOGICAL
!     +   MVCHK
!      EXTERNAL MVCHK
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ADJLMT,EHDR,IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic max,min
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        A VALUE INDICATING WHETHER AN ERROR WAS DETECTED (TRUE)
!        OR NOT (FALSE).
!     LOGICAL HEAD
!        PRINT HEADING (HEAD=TRUE) OR NOT (HEAD=FALSE).
!     INTEGER I, II
!        INDEXING VARIABLES.
!     INTEGER IPRT
!        *
!     INTEGER IYM
!        ACTUAL ROW DIMENSION OF YM DECLARED IN THE USERS MAIN PROGRAM
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER M
!        THE NUMBER OF VECTORS IN YM
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS .
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NSAMPL
!        *
!     LOGICAL SETLMT
!        AN INDICATOR VARIABLE USED TO DETERMINE IF STARTING VALUES
!        FOR XLB, XINC, YMN, YMX HAVE BEEN FOUND.
!     REAL YLB
!        THE USER SUPPLIED Y-AXIS LOWER BOUND.
!     REAL YM(IYM,M)
!        THE ARRAY CONTAINING THE DEPENDENT VARIABLE(S).
!     REAL YMMISS(M)
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IS MISSING.
!        IF YM(I,J) = YMMISS(J), THE VALUE IS ASSUMED MISSING, OTHERWISE
!        IT IS NOT.
!     REAL YMN, YMX
!        THE Y-AXIS LOWER AND UPPER LIMITS ACTUALLY USED.
!     REAL YUB
!        THE USER SUPPLIED Y-AXIS UPPER BOUNDS.
!
      error = .false.
!
      if (ylb.lt.yub) then
!
!       SET LIMITS TO USER SPECIFIED VALUES
!
        ymn = ylb
        ymx = yub
!
      else
!
!       SET LIMITS TO RANGE OF VALUES WITHIN ANY USER SPECIFIED VALUES
!
        setlmt = .false.
        ii = 1
!
!       FIND FIRST VALUE TO BE PLOTTED
!
        do 20 i=1,n,nsampl
           do 10 j=1,m
              if (miss .and. mvchk(ym(i,j),ymmiss(j))) go to 10
             if ((ylb.lt.yub) .and. ((ym(i,j).lt.ylb) .or.&
     &           (yub.lt.ym(i,j)))) go to 10
              if (setlmt) then
                ymn = min(ymn, ym(i,j))
                ymx = max(ymx, ym(i,j))
              else
                ymn = ym(i,j)
                ymx = ym(i,j)
                setlmt = .true.
                ii = i + nsampl
              end if
   10      continue
           if (setlmt) go to 30
   20   continue
!
   30   if (ii.le.1) then
!
!         NO VALUES TO BE PLOTTED.  PRINT ERROR MESSAGE
!
          error = .true.
          call iprint(iprt)
          head = .true.
          call ehdr(nmsub,head)
          if (ylb.ge.yub) then
            write (iprt, 1010)
          else
            write (iprt, 1020)
          end if
          write (iprt, 1030)
!
        else
!
!         FIND LIMITS FROM REMAINING VALUES
!
          if (ii.le.n) then
            do 50 i=ii,n,nsampl
               do 40 j=1,m
                  if (miss .and. mvchk(ym(i,j),ymmiss(j))) go to 40
                 if ((ylb.lt.yub) .and. ((ym(i,j).lt.ylb) .or.&
     &               (yub.lt.ym(i,j)))) go to 40
                  ymn = min(ymn, ym(i,j))
                  ymx = max(ymx, ym(i,j))
   40          continue
   50       continue
          end if
        end if
!
!       ADJUST Y AXIS LIMITS IF EQUAL
!
        if (ymn .ge. ymx) call adjlmt(ymn, ymx)
!
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1010 format (/&
     &   44h no non-missing plot coordinates were found.)
1020 format (/&
    &   40h no non-missing values were found within,&
     &   26h the user supplied limits.)
1030 format (/&
     &   30h the plot has been suppressed.)
      end
!AMEER
     subroutine ameer(nmsub, n, npar, npare, ldstak, ldsmin,&
     &  stp, lstp, scale, lscale, ivcv, save, mspec, nfac)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE ERROR CHECKING ROUTINE FOR NONLINEAR LEAST SQUARES
!     ESTIMATION ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ivcv,ldsmin,ldstak,lscale,lstp,n,nfac,npar,npare
     logical&
     &   save
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   scale(*),stp(*)
     integer&
     &   mspec(4,*)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   i,np,nv
     logical&
     &   head
!
!  LOCAL ARRAYS
     logical&
     &   error(20)
     character&
    &   livcv(8)*1,llds(8)*1,lmspec(8)*1,ln(8)*1,lnfac(8)*1,&
    &   lnpar(8)*1,lnpare(8)*1,lone(8)*1,lscl(8)*1,lstep(8)*1,&
     &   lzero(8)*1
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL EIAGE,EISEQ,EISGE,ERVGT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR(20)
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        THE VARIABLE USED TO INDICATE WHETHER A HEADING IS TO BE
!        PRINTED DURING A GIVEN CALL TO THE ITERATION REPORT (TRUE)
!        OR NOT (FALSE).
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF MATRIX VCV.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     CHARACTER*1 LIVCV(8), LLDS(8), LMSPEC(8), LN(8), LNFAC(8),
!    *   LNPAR(8), LNPARE(8), LONE(8), LSCL(8), LSTEP(8), LZERO(8)
!        THE ARRAY(S) CONTAINING THE NAME(S) OF INPUT PARAMETER(S)
!        CHECKED FOR ERRORS.
!     INTEGER LSCALE
!        THE DIMENSION OF VECTOR SCALE.
!     INTEGER LSTP
!        THE DIMENSION OF VECTOR STP.
!     INTEGER MSPEC(4,*)
!        INTEGER MSPEC(4,NFAC)
!        THE ARRAY CONTAINING THE VALUES OF P, D, Q, AND S FOR EACH FACT
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAC
!        THE NUMBER OF FACTORS IN THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE ROUTINE CALLING THE ERROR CHECKING ROUTINE
!     INTEGER NP
!        THE NUMBER OF PARAMETERS SPECIFIED BY MSPEC.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE OPTIMIZED.
!     INTEGER NV
!        *
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(LSCALE)
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL STP(LSTP)
!        THE STEP SIZE ARRAY.
!
!     SET UP NAME ARRAYS
!
     data livcv(1), livcv(2), livcv(3), livcv(4), livcv(5),&
     &   livcv(6), livcv(7), livcv(8) /'I','V','C','V',' ',' ',' ',' '/
     data llds(1), llds(2), llds(3), llds(4), llds(5), llds(6),&
     &   llds(7), llds(8) /'L','D','S','T','A','K',' ',' '/
     data lmspec(1), lmspec(2), lmspec(3), lmspec(4), lmspec(5),&
    &   lmspec(6), lmspec(7), lmspec(8)&
     &  /'M','S','P','C',' ',' ',' ',' '/
     data ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8) /'N',&
     &   ' ',' ',' ',' ',' ',' ',' '/
     data lnfac(1), lnfac(2), lnfac(3), lnfac(4), lnfac(5),&
     &   lnfac(6), lnfac(7), lnfac(8) /'N','F','A','C',' ',' ',' ',' '/
     data lnpar(1), lnpar(2), lnpar(3), lnpar(4), lnpar(5),&
    &   lnpar(6), lnpar(7), lnpar(8) /'N','P','A','R',' ',' ',' ',&
     &   ' '/
     data lnpare(1), lnpare(2), lnpare(3), lnpare(4), lnpare(5),&
    &   lnpare(6), lnpare(7), lnpare(8) /'N','P','A','R','E',' ',' ',&
     &   ' '/
     data lone(1), lone(2), lone(3), lone(4), lone(5),&
     &   lone(6), lone(7), lone(8) /'1',' ',' ',' ',' ',' ',' ',' '/
     data lscl(1), lscl(2), lscl(3), lscl(4), lscl(5),&
    &   lscl(6), lscl(7), lscl(8) /'S','C','A','L','E',' ',' ',&
     &   ' '/
     data lstep(1), lstep(2), lstep(3), lstep(4), lstep(5),&
     &   lstep(6), lstep(7), lstep(8) /'S','T','P',' ',' ',' ',' ',' '/
     data lzero(1), lzero(2), lzero(3), lzero(4), lzero(5),&
     &   lzero(6), lzero(7), lzero(8) /'Z','E','R','O',' ',' ',' ',' '/
!
!     ERROR CHECKING
!
      do 10 i=1,20
         error(i) = .false.
   10 continue
!
      ierr = 0
      head = .true.
!
      call eisge(nmsub, ln, n, 1, 2, head, error(1), lone)
!
      call eisge(nmsub, lnfac, nfac, 1, 2, head, error(2), lone)
!
     if (.not. error(2))&
    &  call eiage(nmsub, lmspec, mspec, 4, nfac, 4, 0, 0, head, 1, nv,&
     &  error(3), lmspec)
!
      if ((.not. error(2)) .and. (.not. error(3))) then
        np = 1
         do 20 i = 1, nfac
          np = np + mspec(1,i) + mspec(3,i)
   20   continue
        call eiseq(nmsub, lnpar, npar, np, 1, head, error(4), lnpar)
!
        if (.not.error(4)) then
          call eisge(nmsub, lnpare, npare, 1, 2, head, error(5), lone)
         call ervgt(nmsub, lstep, stp, lstp, 0.0e0, 0, head, 6, nv,&
     &      error(8), lzero)
         call ervgt(nmsub, lscl, scale, lscale, 0.0e0, 0, head, 6, nv,&
     &      error(12), lzero)
         if (save .and. (.not.error(5)))&
    &      call eisge(nmsub, livcv, ivcv, npare, 3, head, error(15),&
     &      lnpare)
        end if
      end if
!
     if ((.not.error(1)) .and. (.not.error(2)) .and. (.not.error(3))&
    &   .and. (.not.error(4)) .and. (.not.error(5)))&
    &   call eisge(nmsub, llds, ldstak, ldsmin, 9, head, error(6),&
     &   llds)
!
      do 30 i=1,20
         if (error(i)) go to 40
   30 continue
      return
!
   40 continue
      ierr = 1
      return
!
      end
!NLDRVA
     subroutine nldrva (mdl, drv, done, ifixd, par, npar, xm, n, m,&
     &   ixm, pv, d, weight, wt, lwt, stp, lstp, scl, lscl)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE ANALYTIC DERIVATIVE MATRIX (JACOBIAN)
!     USING USER-SUPPLIED ROUTINE DERIV.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,lscl,lstp,lwt,m,n,npar
     logical&
     &   done,weight
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   d(n,npar),par(npar),pv(n),scl(lscl),stp(lstp),wt(lwt),&
     &   xm(ixm,m)
     integer&
     &   ifixd(npar)
!
!  SUBROUTINE ARGUMENTS
       external drv,mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   wtsqrt
     integer&
     &   i,j,jpk
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL D(N,NPAR)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     LOGICAL DONE
!        THE VARIABLE USED TO INDICATE WHETHER THIS IS THE FINAL
!        COMPUTATION OF THE JACOBIAN OR NOT.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXD(NPAR)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.
!        IF IFIXED(I).NE.0, THEN PAR(I) WILL BE HELD FIXED.
!        IF IFIXED(I).EQ.0, THEN PAR(I) WILL BE OPTIMIZED.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER JPK
!        THE INDEX OF THE PACKED PARAMETERS.
!     INTEGER LSCL
!        THE ACTUAL LENGTH OF THE VECTOR SCL.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     REAL PV(N)
!        THE PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL SCL(LSCL)
!        THE SCALE VALUES.
!     REAL STP(LSTP)
!        THE SELECTED RELATIVE STEP SIZES.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(LWT)
!        THE USER SUPPLIED WEIGHTS.
!     REAL WTSQRT
!        THE SQUARE ROOT OF THE ITH WEIGHT.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
!     COMPUTE JACOBIAN
!
      call drv(par, npar, xm, n, m, ixm, d)
!
      jpk = 0
!
      do 20 j=1,npar
         if (ifixd(j).ne.0) go to 20
         jpk = jpk + 1
         do 10 i=1,n
            wtsqrt = 1.0e0
            if (weight .and. (.not.done)) wtsqrt = sqrt(wt(i))
            d(i,jpk) = -wtsqrt*d(i,j)
   10    continue
   20 continue
!
      return
!
      end
!SMPLY
      subroutine smply (y, n, ns, ys, nys)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE SAMPLES EVERY KTH OBSERVATION FROM THE INPUT
!     SERIES Y, STORING THE SAMPLED SERIES IN YS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DEVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n,ns,nys
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(n),ys(n)
!
!  LOCAL SCALARS
     integer&
     &   i,i1
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I, I1
!        INDEXING VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     INTEGER NS
!        THE SAMPLING RATE.
!     INTEGER NYS
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YS.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YS(N)
!        THE VECTOR IN WHICH THE SAMPLED SERIES IS RETURNED.
!
      nys = 0
      do 30 i = 1, n, ns
         nys = nys + 1
         ys(nys) = y(i)
   30 continue
      i1 = nys + 1
      do 40 i = i1, n
         ys(i) = 0.0e0
   40 continue
!
      return
      end
!LLCNTG
     subroutine llcntg(y, wt, lwt, xm, n, ixm, npar, res, ldstak, nprt,&
    &   par, lpar, rsd, pv, lpv, sdpv, lsdpv, sdres, lsdres, vcv, ivcv,&
     &   nmsub, weight, save)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR GENERAL LINEAR LEAST
!     SQUARES.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   ivcv,ixm,ldstak,lpar,lpv,lsdpv,lsdres,lwt,n,npar,nprt
     logical&
     &   save,weight
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),pv(*),res(*),sdpv(*),sdres(*),vcv(*),wt(*),xm(*),y(*)
     character&
     &   nmsub(6)*1
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   ifit,m
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL LLCNT,LLHDRG
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IFIT
!        THE INDICATOR VALUE DESIGNATING WHETHER THE LLS IS OF A
!        GENERAL MODEL (IFIT=3) OR A POLYNOMIAL MODEL (IFIT=1).
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE MATRIX XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     EXTERNAL LLHDRG
!        THE NAME OF THE ROUTINE THAT PRODUCED THE HEADING.
!     INTEGER LPAR
!        THE ACTUAL LENGTH OF THE VECTOR P.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO DESIGNATE THE AMOUNT OF
!        PRINTED OUTPUT.
!     REAL PAR(LPAR)
!        THE PARAMETERS TO BE ESTIMATED.
!     REAL PV(LPV)
!        THE PREDICTED VALUES.
!     REAL RES(N)
!        THE RESIDUALS.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS ARE TO VE SAVED (TRUE) OR NOT (FALSE).
!     REAL SDPV(LSDPV)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(LSDRES)
!        THE STANDARDIZED RESIDUALS.
!     REAL VCV(IVCV,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(LWT)
!        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
!     REAL XM(IXM,M)
!        THE INDEPENDENT VARIABLE.
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!
!
      ifit = 3
      m = npar
!
     call llcnt(y, wt, lwt, xm, n, m, ixm, npar, res, ldstak, nprt,&
    &   par, lpar, rsd, pv, lpv, sdpv, lsdpv, sdres, lsdres, vcv, ivcv,&
     &   llhdrg, ifit, nmsub, weight, save)
!
      return
!
      end
!SPPLTC
     subroutine sppltc (xaxis, yaxis, isym, npts, xpltmn, xpltmx, bw,&
     &   cilow, cimid, ciup, lpcv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES CONFIDENCE INTERVAL AND BANDWIDTH
!     CO-ORDINATES FOR THE SPECTRUM PLOTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   bw,cilow,cimid,ciup,xpltmn,xpltmx
     integer&
     &   lpcv,npts
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   xaxis(lpcv),yaxis(lpcv)
     integer&
     &   isym(lpcv)
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL BW
!       THE BANDWIDTH.
!     REAL CILOW, CIMID, CIUP
!        THE Y CORDNATES FOR THE LOWER  MID AND UPPER CONFIDENCE
!        INTERVAL POINTS.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR THE PLOTS.
!     INTEGER NPTS
!        THE NUMBER OF CO-ORDINATES TO BE PLOTTED.
!     REAL XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     REAL YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!
      if (xpltmx - xpltmn .ge. bw) go to 10
!
      xpltmx = max(xpltmx + (bw - xpltmx + xpltmn) / 2.0e0, 0.5e0)
      xpltmn = xpltmx - bw
!
   10 continue
!
      npts = npts + 1
!
      xaxis(npts) = xpltmx - 0.5e0 * bw
      yaxis(npts) = ciup
      isym(npts) = 7
!
      npts = npts + 1
!
      xaxis(npts) = xpltmx - 0.5e0 * bw
      yaxis(npts) = cimid
      isym(npts) = 3
!
      npts = npts + 1
!
      xaxis(npts) = xpltmx - 0.5e0 * bw
      yaxis(npts) = cilow
      isym(npts) = 13
!
      npts = npts + 1
!
      xaxis(npts) = xpltmx - bw
      yaxis(npts)  = cimid
      isym(npts) = 6
!
      npts = npts + 1
!
      xaxis(npts) = xpltmx
      yaxis(npts)  = cimid
      isym(npts) = 27
!
      return
      end
!PLTPLX
      subroutine pltplx(point, ymn, scale, ipoint, iend)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE POINT LOCATION IN THE PLOT STRING.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   point,scale,ymn
     integer&
     &   iend,ipoint
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IEND
!        THE NUMBER OF LOCATIONS IN THE PLOT STRING.
!     INTEGER IPOINT
!        THE LOCATION IN THE PLOT STRING OF THE VALUE BEING PLOTTED.
!     REAL POINT
!        THE VALUE TO BE PLOTTED.
!     REAL SCALE
!        THE SCALE INTERVAL OF THE PLOT.
!     REAL YMN
!        THE GRAPH AXIS LOWER LIMITS ACTUALLY USED.
!
      ipoint = (point-ymn)/scale + 2.5
      if (ipoint .lt. 2) ipoint = 1
      if (ipoint .gt. iend) ipoint = iend
      return
      end
!CORR
      subroutine corr(ym, n, m, iym, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR THE CORRELATION FAMILY.
!     IT IS THE SHORT CALL FORM.
!     THIS PROCEDURE CALLS CORER TO CHECK FOR ERRORS IN THE PARAMETER
!     LIST.  IF NO PROBLEMS IT THEN ALLOCATES SPACE IN CSTAK FOR THE
!     VECTORS NEEDED AND CALLS THE MAIN ROUTINE , CORRMN, TO
!     DO THE CORRELATION ANALYSIS.
!
!     WRITTEN BY -
!        LINDA L. MITCHELL
!        STATISTICAL ENGINEERING DIVISION
!        NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iym,ldstak,m,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
    &   avg,cilo,ciup,icor,ifp,iprt,iwrk,liwrk,lwrk,nall0,nprt,pc,&
     &   qf,quad,rank,sc,scinv,sd,slpc,slsc,srcc,t,vcv,wrk
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL CORRER,CORRMN,IPRINT,STKCLR,STKSET
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER AVG
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  AVERAGES OF YM
!     INTEGER CILO
!                  OCCUPIES THE SAME SPACE AS SLPC AND IS THE LOWER
!                  CONFIDENCE INTERVAL
!     INTEGER CIUP
!                  OCCUPIES THE SAME SPACE AS SLSC AND IS THE UPPER
!                  CONFIDENCE INTERVAL
!     DOUBLE PRECISION DSTAK(12)
!                  THE DOUBLE PRECISION VERSION OF
!                  THE /CSTAK/ WORK AREA.
!     INTEGER ICOR
!                  DETERMINES WHICH SUBROUTINE CALLED CORRMN
!                  IF =1, THEN CALLED BY CORR
!                     =2, THEN CALLED BY CORRS
!     INTEGER IERR
!                  A FLAG RETURNED TO THE USER INDICATING
!                  WHETHER  ERRORS WERE DETECTED IN THE PARAMETER LIST
!                  IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!                  IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!                  AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3
!                  INDICATES SINGLE PRECISION AND IFP=4 INDICATES
!                  DOUBLE PRECISION.
!     INTEGER IPRT
!                  LOGICAL OUTPUT UNIT
!     INTEGER ISTAK(12)
!                  THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IWRK
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  INTEGER WORK VECTOR.
!     INTEGER IYM
!                  THE ROW DIMENSION OF YM SPECIFIED IN THE USERS PROGRA
!     INTEGER LDSTAK
!                  SIZE OF WORK AREA ALLOCATED IN THE USERS PROGRAM
!     INTEGER LIWRK
!                  THE LENGTH OF THE INTEGER WORK VECTOR.
!     INTEGER LWRK
!                  THE LENGTH OF THE REAL WORK VECTOR.
!     INTEGER M
!                  THE NUMBER OF VARIABLES
!     INTEGER N
!                  THE NUMBER OF OBSERVATIONS
!     INTEGER NALL0
!                  THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE
!                  TIME THAT THIS ROUTINE WAS CALLED.
!     CHARACTER*1 NMSUB(6)
!                  THE SUBROUTINE NAME
!     INTEGER NPRT
!                  THE VARIABLE CONTROLLING THE AUTOMATIC PRINTOUT
!                       NPRT = 0, PRINTOUT IS SUPPRESSED
!                       OTHERWISE THE PRINTOUT IS PROVIDED.
!     INTEGER PC
!                  THE STARTING LOCATION IN THE WORK AREA
!                  OF THE PARTIAL CORRELATION COEFFICIENTS MATRIX
!     INTEGER QF
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  QUADRATIC FIT
!     INTEGER QUAD
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  REAL VERSION OF THE QUADRATIC FIT
!     INTEGER RANK
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  MATRIX CONTAINING THE RANKS OF YM
!     REAL RSTAK(12)
!                  THE REAL VERSION OF THE
!                  /CSTAK/ WORK AREA.
!     INTEGER SC
!                  THE STARTING LOCATION IN THE WORK AREA
!                  OF THE SIMPLE CORRELATION COEFFICIENTS MATRIX
!     INTEGER SCINV
!                  THE STARTING LOCATION IN THE WORK AREA FOR THE
!                  INVERSE MATRIX OF SC
!     INTEGER SD
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  STANDARD DEVIATIONS OF YM
!     INTEGER SLPC
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  SIGNIFICANCE LEVELS OF PC
!     INTEGER SLSC
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  SIGNIFICANCE LEVELS OF SC
!     INTEGER SRCC
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  SPEARMAN RANK COEFFICIENTS
!     INTEGER T
!                  STARTING LOCATION IN THE WORK AREA
!                  FOR THE ARRAY T.
!     INTEGER VCV
!                  THE STARTING LOCATION IN THE WORK AREA OF THE
!                  VARIANCE COVARIANCE MATRIX.
!     INTEGER WRK
!                  THE STARTING LOCATION IN THE WORK AREA FOR
!                  WORK SPACE
!     REAL YM(IYM,M)
!                  THE MATRIX IN WHICH THE OBSERVATIONS ARE PASSED
!
!
!     SET UP NAME ARRAY
!
     data  nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6)&
     &   /       'C',      'O',      'R',      'R',      ' ',      ' '/
!
!     SET UP FRAMEWORK VARIABLES FOR NUMBER TYPE
!
      ifp = 3
!
!     SET CALLER FLAG, THIS IS CORR
!
      icor = 1
!
!     PRINTOUT IS AUTOMATICALY PROVIDED
!
      nprt = 1
!
!     CHECK FOR ERRORS IN PARAMETERS
!
      call correr(nmsub, m, n, iym, m, ldstak, icor, nprt)
!
!     IF THERE IS AN ERROR RETURN TO THE CALLERS ROUTINE
!
      if (ierr.eq.0) go to 10
!
!     PRINT CORRECT FORM OF CALL STATEMENT AND RETURN TO CALLER
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     INITIALIZE THE STACK
!
   10 call stkset (ldstak, 4)
      nall0 = stkst(1)
!
!     ALLOCATE SPACE IN CSTAK FOR MATRICES.
!
      liwrk = max(n,m)
      lwrk = liwrk
!
      vcv = stkget(m*m,ifp)
      iwrk = stkget(liwrk,2)
      wrk = stkget(lwrk,ifp)
!
      t = stkget(m,ifp)
      rank = stkget(n*m,ifp)
      scinv = stkget(m*m,ifp)
      slsc = stkget(m*m,ifp)
      slpc = stkget(m*m,ifp)
      sc = stkget(m*m,ifp)
      pc = stkget(m*m,ifp)
      quad = stkget(3*n,ifp)
      qf = stkget(m*m,ifp)
!
!     THE FOLLOWING VARIABLES HAVE BEEN INDIRECTLY EQUIVALENCED-
!
      ciup = slsc
      cilo = slpc
      avg = wrk
      sd = wrk
      srcc = scinv
!
!     CALL THE ROUTINE TO DO THE COMPUTATIONS
!
     call corrmn(ym, n, m, iym, rstak(avg), rstak(sd), rstak(t),&
    &   rstak(rank), rstak(sc), rstak(pc), rstak(scinv), istak(iwrk),&
    &   rstak(wrk), rstak(slsc), rstak(slpc), rstak(srcc),&
    &   rstak(quad), rstak(ciup), rstak(cilo), rstak(qf),&
     &   nprt, rstak(vcv), m, liwrk, lwrk)
!
!     RETURN AREA TO THE WORK ARRAY
!
      call stkclr(nall0)
!
      return
!
!     FORMAT STATEMENT
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL CORR (YM, N, M, IYM, LDSTAK)')
      end
!VP
      subroutine vp(ym, n, ns)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT (SHORT CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n,ns
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ibar,ilog,iprt,irlin,ischck,isize,iym,lisym,m
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ymmiss(1)
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  ' ',       'V',       'P',       ' ',       ' ',       ' '/
!
!     DEFINE CONSTANTS
!
!     SET DEFAULT VALUES
!
      ymmiss(1) = 1.0e0
      m = 1
      iym = n
      multi = .false.
      ilog = -1
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 1.0e0
      xinc = 1.0e0
      ischck = 0
      isize = -1
      miss = .false.
      lisym = 1
      irlin = -1
      ibar = 0
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ymmiss, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL VP (Y, N, NS)')
      end
!FITSXP
     subroutine fitsxp(par, pv, sdpv, res, sdres, vcv, n, npar, ivcv,&
     &    rsd)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     GENERATES REPORTS FOR LEAST SQUARES EXERCISER RETURNED STORAGE
!
!     WRITTEN BY  -  LINDA L. MITCHELL
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   ivcv,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(npar),pv(n),res(n),sdpv(n),sdres(n),vcv(ivcv,npar)
!
!  LOCAL SCALARS
     integer&
     &   i,iprt
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LSTVEC,MATPRT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        INDEX VARIABLE
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT
!     INTEGER IVCV
!        ACTUAL FIRST DIMENSION OF VCV
!     INTEGER N
!        NUMBER OF OBSERVATIONS
!     INTEGER NPAR
!        NUMBER OF PARAMETERS
!     REAL PAR(NPAR)
!        THE ESTIMATED PARAMETERS.
!     REAL PV(N)
!        PREDICTED VALUES
!     REAL RES(N)
!        RESIDUALS
!     REAL RSD
!        RESIDUAL STANDARD DEVIATION
!     REAL SDPV(N)
!        STANDARD DEVIATION OF PREDICTED VALUES
!     REAL SDRES(N)
!        STANDARD DEVIATION OF RESIDUALS
!     REAL VCV(IVCV,NPAR)
!        VARIANCE COVARANCE MATRIX
!
      call iprint(iprt)
      write (iprt,1000)
      write (iprt,1002)
      call lstvec(npar, par)
      write (iprt,1001)
      do 10 i=1,n
         write (iprt,1010) pv(i), sdpv(i), res(i), sdres(i)
   10 continue
      write (iprt,1020)
      call matprt(vcv, vcv, npar, iprt, 1, 1, ivcv)
      write (iprt,1030) rsd
!
      return
!
!     FORMAT STATEMENTS
!
 1000 format(//40h returned results from least squares fit/ 1x, 39('-'))
 1001 format (//7x, 2hpv, 13x, 4hsdpv, 12x, 3hres,12x, 5hsdres)
 1002 format (//20h parameters from fit)
 1010 format (1x, g14.7, 2x, g14.7, 2x, g14.7, 2x, g14.7)
 1020 format (//27h variance covariance matrix)
 1030 format (//6h rsd =, g14.7)
      end
!UFSLAG
      subroutine ufslag (acov, lagmax, lags, n, nw, nwused, lacov)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE LAG WINDOW TRUNCATION POINTS FOR
!     SPECTRUM ANALYSIS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   lacov,lagmax,n,nw,nwused
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(lacov)
     integer&
     &   lags(nw)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   acovmx,p95lim
     integer&
     &   i,j,k,lag,nwm1
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,real,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LACOV)
!        THE ARRAY IN WHICH THE AUTOCOVARIANCES ARE STORED
!     REAL ACOVMX
!        THE MAXIMUM AUTOCOVARIANCE VALUE.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER J, K
!        INDEX VARIABLES.
!     INTEGER LACOV
!        THE LENGTH OF VECTOR ACOV.
!     INTEGER LAG, LAGMAX
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        AUTOCOVARIANCE BEING COMPUTED AND THE MAXIMUM LAG TO BE USED,
!        RESPECTIVELY.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NW
!        THE NUMBER OF DIFFERENT BANDWIDTHS REQUESTED.
!     INTEGER NWM1, NWUSED
!        THE NUMBER OF DIFFERENT BANDWIDTHS MINUS 1, AND THE
!        ACTUAL NUMBER OF BANDWIDTHS ACTUALLY USED.
!     REAL P95LIM
!        THE 95 PERCENT CONFIDENT LIMIT FOR WHITE NOISE.
!
      lags(nw) = lagmax
      if (lags(nw) .le. 32) go to 30
!
!     COMPUTE 95 PERCENT CONFIDENCE LIMITS ON AUTOCOVARIANCES,
!     ASSUMING WHITE NOISE.
!
      p95lim = 1.96e0 * acov(1) / sqrt(real(n))
!
!     CHECK FOR FIRST ACVF EXCEEDING 95 PERCENT LIMIT ON WHITE NOISE
!
      do 10 i = 1, lagmax
         lag = lagmax + 1 - i
         if (abs(acov(lag + 1)) .ge. p95lim) go to 30
         lags(nw) = lags(nw) - 1
   10 continue
!
!     IF NO ACVF EXCEEDS WHITE NOISE LIMITS, CHECK FOR LARGEST ACVF.
!
      lags(nw) = 1
      acovmx = abs(acov(2))
      do 20 lag = 1, lagmax
         if (abs(acov(lag + 1)) .le. acovmx) go to 20
         lags(nw) = lag
         acovmx = abs(acov(lag + 1))
   20 continue
!
!     COMPUTE LAG WINDOW TRUNCATION POINTS
!
   30 lags(nw) = lags(nw) * 3.0e0 / 2.0e0
      if (lags(nw) .lt. 32) lags(nw) = 32
      if (lags(nw) .gt. lagmax) lags(nw) = lagmax
      nwused = nw
      if (nw .eq. 1) return
      nwm1 = nw - 1
      do 40 i = 1, nwm1
         k = nw - i
         lags(k) = lags(k + 1) / 2
   40 continue
!
!     CHECK WHETHER ALL NW LAG WINDOW TRUNCATION POINTS CAN BE USED.
!
      nwused = nw
      if (lags(1) .ge. 4) return
!
!     RECONSTURCT -LAGS- VECTOR IF NOT ALL TRUNCATION POINTS ARE
!     TO BE USED
!
      do 50 i = 2, nw
         nwused = nwused - 1
         if (lags(i) .ge. 4) go to 60
   50 continue
!
   60 do 70 i = 1, nwused
         j = nw - nwused + i
         lags(i) = lags(j)
   70 continue
!
      return
      end
!LLSMN
     subroutine llsmn(y, x, wt, n, m, npar, ix, res, par, nnzw,&
    &   rsd, pv, sdpv, sdres, iptout, wy, xw, vcv, fc, red,&
     &   t, par1, acc, ifit, weight, c, llhdr, page, wide)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN PROGRAM FOR THE LINEAR LEAST SQUARES FITTING
!     PROGRAMS
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 29, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rsd
     integer&
     &   ifit,ix,m,n,nnzw,npar
     logical&
     &   page,weight,wide
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   acc(npar),c(npar),fc(n,npar),par(npar),par1(npar),pv(n),&
    &   red(npar),res(n),sdpv(n),sdres(n),t(npar,npar),&
     &   vcv(npar,npar),wt(n),wy(n),x(ix,m),xw(n,npar),y(n)
     integer&
     &   iptout(4)
!
!  SUBROUTINE ARGUMENTS
       external llhdr
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   cond,df,fplm,fplrs,fpspm,probt,probt1,px,r2,ratio,ratio1,&
     &   rsd1,rss,rss1,rvar,rvar1,sdc,sdc1,sm,td,wtsqrt,wtsum,wtym,ysum
     integer&
     &   i,idf,idf1,ier,iprt,irefit,isubhd,j,k,nc
     logical&
     &   const
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   det(2)
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   CDFT,R1MACH
!      EXTERNAL CDFT,R1MACH
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL ACCDIG,FITPT1,FITPT2,IPRINT,MGS,OANOVA,VCVOUT
!      EXTERNAL STRCO,STRDI
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max,sqrt
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACC(NPAR)
!        THE NUMBER OF ACCURATE DIGITS.
!     REAL C(NPAR)
!        A WORK VECTOR.
!     REAL COND
!        THE CONDITION NUMBER OF THE DESIGN MATRIX.
!     LOGICAL CONST
!        AN INDICATOR VALUE DESIGNATING WHETHER THE FIRST COLUMN OF
!        THE DESIGN MATRIX IS ALL ONES FOR A CONSTANT.
!     REAL DET(2)
!        THE DETERMINENT.
!     REAL DF
!        THE DEGREES OF FREEDOM.
!     REAL FC(N,NPAR)
!        THE ORTHONORMALIZATION MATRIX.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     REAL FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     REAL FPSPM
!        THE FLOATING POINT SMALLEST POSITIVE MAGNITUDE.
!     INTEGER I
!        AN INDEX.
!     INTEGER IDF
!        THE DEGREES OF FREEDOM
!     INTEGER IDF1
!        THE DEGREES OF FREEDOM FOR THE FIT WITHOUT THE LAST INDEPENDENT
!        VARIABLE.
!     INTEGER IER
!        THE ERROR FLAG RETURNED BY THE INVERSION ROUTINES.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS WERE
!        DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IFIT
!        THE INDICATOR VALUE DESIGNATING WHETHER THE FIT IS OF A
!        GENERAL MODEL (IFIT=3) OR A POLYNOMIAL MODEL (IFIT=1).
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IPTOUT(4)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER IREFIT
!        AN INDICATOR USED TO DESIGNATE WHETHER THE FIT IS OF THE
!        FULL DESIGN MATRIX (IREFIT=0) OR IS OMITTING THE LAST
!        INDEPENDENT VARIABLE (IREFIT=1).
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IX
!        THE FIRST DIMENSION OF THE MATRIX X.
!     INTEGER J
!        AN INDEX.
!     INTEGER K
!        AN INDEX.
!     EXTERNAL LLHDR
!        THE NAME OF THE ROUTINE THAT PRODUCED THE HEADING.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NC
!        THE NUMBER OF PARAMETERS BEING FIT.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE PARAMETERS  TO BE ESTIMATED.
!     REAL PAR1(NPAR)
!        THE PARAMETERS TO BE ESTIMATED OMMITTING THE LAST
!        INDEPENDENT VARIABLE.
!     REAL PROBT
!        ...
!     REAL PROBT1
!        ...
!     REAL PV(N)
!        THE PREDICTED VALUES.
!     REAL PX
!        A WORK VARIABLE.
!     REAL RATIO
!        THE RATIO OF THE PARAMETERS TO THEIR STANDARD DEVIATIONS.
!     REAL RATIO1
!        THE RATIO OF THE PARAMETERS COMPUTED OMITTING THE LAST
!        INDEPENDENT VARIABLE TO THEIR STANDARD DEVIATIONS.
!     REAL RED(NPAR)
!        THE REDUCTION TO THE SUM OF SQUARES DUE TO EACH PARAMETER.
!     REAL RES(N)
!        THE RESIDUALS.
!     REAL RSD
!        THE RESIDUAL STANDARD DEVIATION.
!     REAL RSD1
!        THE RESIDUAL STANDARD DEVIATION FROM THE FIT OMITTING
!        THE LAST INDEPENDENT VARIABLE.
!     REAL RSS
!        THE RESIDUAL SUM OF SQUARES.
!     REAL RSS1
!        THE RESIDUAL SUM OF SQUARES FROM THE FIT OMITTING
!        THE LAST INDEPENDENT VARIABLE.
!     REAL RVAR
!        THE RESIDUAL VARIANCE.
!     REAL RVAR1
!        THE RESIDUAL VARIANCE FROM THE FIT OMITTING
!        THE LAST INDEPENDENT VARIABLE.
!     REAL R2
!        THE MULTIPLE CORRELATION PARAMETER.
!     REAL SDC
!        THE ESTIMATED STANDARD DEVIATIONS OF THE PARAMETERS.
!     REAL SDC1
!        THE ESTIMATED STANDARD DEVIATIONS OF THE PARAMETERS OMITTING
!        THE LAST INDEPENDENT VARIABLE.
!     REAL SDPV(N)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(N)
!        THE STANDARDIZED RESIDUALS.
!     REAL SM
!        A WORK VARIABLE.
!     REAL T(NPAR,NPAR)
!        THE TRIANGULAR MATRIX FROM THE DECOMPOSITION.
!     REAL TD
!        A WORK VARIABLE.
!     REAL VCV(NPAR,NPAR)
!        THE VARIANCE COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL WT(N)
!        THE WEIGHTS (A DUMMY VECTOR IN THE UNWEIGHTED CASE).
!     REAL WTSQRT
!        THE SQUARE ROOT OF THE WEIGHT.
!     REAL WTSUM
!        THE SUM OF THE WEIGHTS.
!     REAL WTYM
!        THE SUM OF THE WEIGHTED DEPENDENT VARIABLES.
!     REAL WY(N)
!        THE VECTOR CONTAINING SQRT(WT)*Y.
!     REAL X(IX,M)
!        THE INDEPENDENT VARIABLE.
!     REAL XW(N,NPAR)
!        THE MATRIX CONTAINING X * SQRT(WT).
!     REAL Y(N)
!        THE DEPENDENT VARIABLE.
!     REAL YSUM
!        THE SUM OF THE WEIGHTED DEPENDENT VARIABLES SQUARED.
!
      call iprint(iprt)
!
!     INITIALIZE VARIABLES
!
      fplm = r1mach(2)
      fplrs = r1mach(4)
      fpspm = r1mach(1)
      nc = npar
      idf = nnzw - nc
      df = idf
!
      r2 = 0.0
      rvar1 = 0.0
      rsd1 = 0.0
      j = 0
      idf1 = 0
      const = .false.
!
      ysum = 0.0e0
      wtsum = 0.0e0
      do 10 i=1,n
         if (wt(i).le.0.0e0) go to 10
         ysum = ysum + wt(i)*y(i)*y(i)
         wtsum = wtsum + wt(i)
   10 continue
!
!     BEGIN FIT
!
      irefit = -1
!
!     IF IREFIT IS EQUAL TO 1 FIT IS OMITTING THE LAST VARIABLE
!
   50 irefit = irefit + 1
!
!     COMPUTE WORKING VECTORS
!
      wtym = 0.0e0
      i = 0
      do 70 k=1,n
         if (wt(k).le.0.0e0) go to 70
         wtsqrt = sqrt(wt(k))
         i = i + 1
         px = wtsqrt
         do 60 j=1,nc
            if (ifit.eq.1 .and. j.ge.2) px = px*x(k,1)
            if (ifit.eq.3) px = x(k,j)*wtsqrt
            xw(i,j) = px
   60    continue
!
!     COMPUTE WY ( WEIGHTS * Y VECTOR )
!
         wy(i) = y(k)*wtsqrt
         wtym = wtym + wt(k)*y(k)
   70 continue
      wtym = wtym/wtsum
!
!     COMPUTE ESTIMATED VALUES OF PARAMETERS
!
      if (irefit.eq.1) go to 80
      ier = 0
      call mgs(xw, wy, nnzw, nc, par, c, t(1,1), t, npar, n, ier)
      if (ier.eq.0) go to 90
      ierr = 3
      isubhd = 0
      call llhdr(page, wide, isubhd)
      write (iprt,1160)
      write (iprt,1150)
      return
   80 continue
      ier = 0
      call mgs(xw, wy, nnzw, nc, par1, c, t(1,1), t, npar, n, ier)
!
!     COMPUTE PREDICTED VALUES (PV) AND RESIDUALS (RES)
!             RESIDUAL SUM OF SQUARES (RSS) AND
!             RESIDUAL STANDARD DEVIATION (RSD) AND
!             SUM OF WEIGHTS (WTSUM) AND
!             RESIDUAL VARAINCE (RVAR)
!
   90 rss = 0.0e0
      rss1 = 0.0e0
      do 120 i=1,n
         sm = 0.0e0
         px = 1.0e0
         do 100 j=1,nc
            if (ifit.eq.1 .and. j.ge.2) px = px*x(i,1)
            if (ifit.eq.3) px = x(i,j)
            if (irefit.eq.0) sm = sm + par(j)*px
            if (irefit.eq.1) sm = sm + par1(j)*px
  100    continue
         if (irefit.eq.0) then
            pv(i) = sm
            res(i) = y(i) - pv(i)
            rss = rss + res(i)*wt(i)*res(i)
         else
            rss1 = rss1 + (y(i)-sm)*wt(i)*(y(i)-sm)
         end if
  120 continue
!
      if (irefit.eq.0) go to 130
      rvar1 = rss1/(df+1.0e0)
      rsd1 = sqrt(rvar1)
      go to 380
  130 rvar = 0.0e0
      if (df.gt.0.0e0) rvar = rss/df
      rsd = sqrt(rvar)
!
!     COMPUTE MULTIPLE CORRELATION PARAMETER SQUARED (R2)
!
      sm = 0.0e0
      const = .true.
      do 140 i=1,n
         if ((x(i,1).ne.1.0e0) .and. (ifit.eq.3)) const = .false.
         sm = sm + (y(i)-wtym)*wt(i)*(y(i)-wtym)
  140 continue
      r2 = 1.0e0
      if (sm.gt.0.0e0) r2 = 1.0e0-rss/sm
!
!     CHECK FOR -EXACT- FIT
!
      td = 0.0e0
      if (df.gt.0.0e0) td = sqrt(rss)
      if (ysum.gt.0.0e0) td = td/sqrt(ysum)
      if (td.gt.10.0e0*fplrs) go to 180
!
      ierr = 0
     if ((iptout(1).eq.0) .and. (iptout(2).eq.0) .and. (iptout(3).eq.0)&
     &   .and. (iptout(4).eq.0)) go to 145
      isubhd = 0
      call llhdr(page, wide, isubhd)
      write (iprt,1180)
      write (iprt,1020) (i,par(i),i=1,npar)
!
!     ZERO OUT VCV MATRIX AND SDRES AND SDPV VECTORS
!
  145 continue
      do 150 i=1,n
         sdpv(i) = 0.0e0
         sdres(i) = 0.0e0
  150 continue
      do 170 i=1,npar
         do 160 j=1,npar
            vcv(i,j) = 0.0e0
  160    continue
  170 continue
      return
!
  180 continue
!
!     COMPUTE ORTHO NORMALIZATION
!
      do 200 i=1,nc
         t(i,i) = sqrt(t(i,1))
         do 190 j=i,nc
            if (i.eq.j) go to 190
            t(i,j) = t(i,j)*t(i,i)
  190    continue
  200 continue
!
      call strco(t, npar, nc, cond, c, 1)
      if (cond.ne.0.0e0) then
         cond = 1.0e0/cond
      else
         cond = fplm
      end if
      call strdi(t, npar, nc, det, 011, ier)
!
      if (ier.eq.0) go to 210
      ierr = 3
      isubhd = 0
      call llhdr(page, wide, isubhd)
      write (iprt,1160)
      write (iprt,1120)
      return
  210 continue
      do 240 i=1,n
         do 230 j=1,nc
            sm = 0.0e0
            px = 1.0e0
            do 220 k=1,j
               if (ifit.eq.1 .and. k.ge.2) px = px*x(i,1)
               if (ifit.eq.3) px = x(i,k)
               sm = sm + px*t(k,j)
  220       continue
            fc(i,j) = sm
  230    continue
  240 continue
!
!     COMPUTE REDUCTION TO RSS DUE TO FITTING
!
      do 260 j=1,nc
         sm = 0.0e0
         do 250 i=1,n
            sm = sm + (fc(i,j))*wt(i)*y(i)
  250    continue
         red(j) = (sm*sm)
  260 continue
!
!     COMPUTE ESTIMATED VARIANCE COVARIANCE MATRIX
!
      do 290 i=1,nc
         do 280 j=i,nc
            sm = 0.0e0
            do 270 k=j,nc
               sm = sm + t(i,k)*t(j,k)
  270       continue
            if (sqrt(abs(sm))*sqrt(rvar).ge.sqrt(fpspm)) then
               vcv(i,j) = sm*rvar
            else
               vcv(i,j) = 0.0e0
            end if
            vcv(j,i) = vcv(i,j)
  280    continue
  290 continue
!
!     REFIT TO PREDICTED VALUES
!
      i = 0
      do 310 k=1,n
         if (wt(k).le.0.0e0) go to 310
         wtsqrt = sqrt(wt(k))
         i = i + 1
         px = wtsqrt
         do 300 j=1,nc
            if (ifit.eq.1 .and. j.ge.2) px = px*x(k,1)
            if (ifit.eq.3) px = x(k,j)*wtsqrt
            xw(i,j) = px
  300    continue
         wy(i) = pv(k)*wtsqrt
  310 continue
!
      ier = 0
      call mgs(xw, wy, nnzw, nc, par1, c, t(1,1), t, npar, n, ier)
!
      call accdig(par, par1, acc, nc)
!
!     COMPUTE STANDARD DEVIATION OF PREDICTED VALUES (SDPV)
!     AND STANDARDIZED RESIDUALS (SDRES)
!
      do 360 i=1,n
         sm = 0.0e0
         do 330 j=1,nc
            sm = 0.0e0
            px = 1.0e0
            do 320 k=1,nc
               if (ifit.eq.1 .and. k.ge.2) px = px*x(i,1)
               if (ifit.eq.3) px = x(i,k)
               sm = sm + px*vcv(j,k)
  320       continue
            xw(i,j) = sm
  330    continue
         sm = 0.0e0
         px = 1.0e0
         do 340 k=1,nc
            if (ifit.eq.1 .and. k.ge.2) px = px*x(i,1)
            if (ifit.eq.3) px = x(i,k)
            sm = sm + xw(i,k)*px
  340    continue
         sm = max(0.0e0, sm)
         sdpv(i) = sqrt(sm)
         sdres(i) = fplm
         if (wt(i).le.0.0e0) go to 360
         if ((rvar/wt(i)-sm).le.0.0e0) ierr = 4
        if (rvar/wt(i)-sm.gt.0.0e0)&
     &      sdres(i) = (res(i)/sqrt(rvar/wt(i)-sm))
  360 continue
!
!     CHECK FOR PRINTED OUTPUT
!
     if ((iptout(1).eq.0) .and. (iptout(2).eq.0) .and.&
     &   (iptout(3).eq.0) .and. (iptout(4).eq.0)) return
!
!     BEGIN PRINTED OUTPUT
!
      if (iptout(1).eq.0) go to 370
!
!     PRINT FIRST PAGE OF OUTPUT
!
      isubhd = 0
      call llhdr(page, wide, isubhd)
     call fitpt1(n, m, x, y, pv, sdpv, res, sdres, wt, ix, nnzw,&
     &   weight, iptout(1))
!
!     PRINT PLOTS
!
  370 continue
      if (iptout(2).eq.0) go to 375
      isubhd = 0
      call llhdr(page, wide, isubhd)
      call fitpt2 (sdres, pv, wt, n, nnzw, weight, res, rss)
!
  375 continue
      if (iptout(3).eq.0) go to 376
!
!     PRINT ANALYSIS OF VARIANCE
!
      isubhd = 0
      call llhdr(page, wide, isubhd)
      call oanova(ysum, red, npar, rvar, nnzw, par1, iprt)
!
  376 continue
      if (iptout(4).eq.0) return
!
      if (npar.eq.1) go to 450
      nc = nc - 1
      idf1 = nnzw - nc
      go to 50
  380 continue
      do 400 i=1,nc
         t(i,i) = sqrt(t(i,1))
         do 390 j=i,nc
            if (i.eq.j) go to 390
            t(i,j) = t(i,j)*t(i,i)
  390    continue
  400 continue
!
      call strdi(t, npar, nc, det, 011, ier)
!
      if (ier.eq.0) go to 420
      write (iprt,1140)
      do 410 i=1,nc
         par1(i) = 0.0e0
         t(i,i) = 0.0e0
  410 continue
      go to 450
  420 continue
      do 440 i=1,nc
         sm = 0.0e0
         do 430 k=i,nc
            sm = sm + t(i,k)*t(i,k)
  430    continue
         t(i,i) = sm
  440 continue
!
!     PRINT PAGE HEADINGS
!
  450 continue
      isubhd = 0
      call llhdr(page, wide, isubhd)
!
!     PRINT VARIANCE COVARIANCE MATRIX
!
      call vcvout(npar, vcv, npar, .true.)
!
      write (iprt,1030)
      if (npar.gt.1) write (iprt,1040)
      write (iprt,1050)
      if (npar.gt.1) write (iprt,1060)
      write (iprt, 1170)
      if (npar.ge.2) then
         do 460 i=1,nc
            sdc = sqrt(vcv(i,i))
            ratio = fplm
            probt = 0.0e0
            if (sdc.gt.0.0e0) ratio = par(i)/sdc
           if (sdc.gt.0.0e0)&
     &         probt = (1.0e0-cdft(abs(ratio), nnzw-npar)) * 2.0e0
            sdc1 = sqrt(t(i,i))*sqrt(rvar1)
            ratio1 = fplm
            probt1 = 0.0e0
            if (sdc1.gt.0.0e0) ratio1 = par1(i)/sdc1
           if (sdc1.gt.0.0e0)&
     &         probt1 = (1.0e0 - cdft(abs(ratio1), nnzw-npar+1)) * 2.0e0
           write (iprt,1070) i, par(i), sdc, ratio, probt, acc(i),&
     &         par1(i), sdc1, ratio1, probt1
  460    continue
      end if
      sdc = sqrt(vcv(npar,npar))
      ratio = fplm
      probt = 0.0e0
      if (sdc.gt.0.0e0) ratio = par(npar)/sdc
     if (sdc.gt.0.0e0)&
     &   probt = (1.0e0 - cdft(abs(ratio), nnzw-npar)) * 2.0e0
      write (iprt,1070) npar, par(npar), sdc, ratio, probt, acc(npar)
      if (npar.eq.1) write (iprt,1080) rsd
      if (npar.gt.1) write (iprt,1080) rsd, rsd1
      write (iprt,1090) nnzw, npar, idf
      if (npar.gt.1) write (iprt,1100) nnzw, nc, idf1
      if (const) write (iprt,1010) r2
      write (iprt,1000) cond
      write (iprt,1110)
      return
!
!     FORMAT STATEMENTS
!
 1000 format (/29h approximate condition number, 10x, g15.7)
 1010 format (/44h multiple correlation coefficient squared   , f7.4)
1020 format (//46h the values computed for the parameters are - /(5x,&
     &   4hpar(, i3, 4h) = , g15.7))
 1030 format (////1x, 25('-'), 1x, 18hestimates from fit, 1x, 24('-'))
1040 format ('+', 72x, 4('-'), 1x,&
    &   48hestimates from fit omitting last predictor value, 1x,&
     &   4('-'))
1050 format (/2x, 19hestimated parameter, 7x, 9hsd of par, 5x,&
     &   8ht(par=0), 3x, 7hprob(t), 2x, 8hacc dig*)
1060 format ('+', 72x, 19hestimated parameter, 7x, 9hsd of par, 5x,&
     &   8ht(par=0), 3x, 7hprob(t))
1070 format (1x, i3, 2x, g16.9, 3x, g16.9, 2x, g10.4, 1x, f5.3, 2x,&
     &   f7.1, 9x, g16.9, 3x, g16.9, 2x, g10.4, 1x, f5.3)
1080 format (//1x, 30hresidual standard deviation   , 9x, g15.7, 56x,&
     &   g15.7)
1090 format (1x, 27hbased on degrees of freedom, 7x, i4, 3h - , i2,&
     &   3h = , i4)
 1100 format ('+', 105x, i4, 3h - , i2, 3h = , i4)
1110 format (//52h * the number of correctly computed digits in each p,&
    &   56harameter usually differs by less than 1 from the value g,&
     &   10hiven here.)
1120 format (/47h the program was unable to compute the variance,&
    &   19h-covariance matrix./&
    &   52h the design matrix is either nearly singular or very,&
    &   17h ill conditioned./&
     &   29h check your input for errors.)
1140 format (54h0estimates for the standard deviation of the estimated,&
    &   55hparameters omitting the last independent variable could/&
    &   59h not be computed.  the zeros printed for the estimates of t,&
    &   50hhe parameters, their standard deviations and their/&
    &   59h ratios for the fit omitting the last variable are meaningl,&
     &   4hess.)
1150 format (/30h the design matrix is singular,&
    &   29h to within machine precision./&
    &   50h check the design matrix for a linear relationship,&
     &   29h between some of the columns.)
 1160 format (//1x, 11('*')/ 1x, 11h*  error  */ 1x, 11('*'))
 1170 format (' ')
1180 format (/50h the least squares fit of the data to the model is,&
    &   35h exact to within machine precision./&
     &   38h statistical analysis is not possible.)
      end
!HPCOEF
      subroutine hpcoef (hlp, k, hhp)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTE THE HI-PASS FILTER CORRESPONDING
!     TO THE INPUT K TERM LOW PASS FILTER COEFFICIENTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   k
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   hhp(*),hlp(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iprt
     logical&
     &   err01,err02,err03,head
!
!  LOCAL ARRAYS
     character&
     &   lhlp(8)*1,lk(8)*1,nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,ERIODD,ERSLF,HPFLT,IPRINT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02, ERR03
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     REAL HHP(K)
!        THE ARRAY IN WHICH THE HIGH PASS FILTER COEFFICIENTS
!        WILL BE RETURNED.
!     REAL HLP(K)
!        THE ARRAY IN WHICH THE INPUT LOW PASS FILTER COEFFICIENTS
!        ARE STORED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     INTEGER K
!        THE NUMBER OF FILTER TERMS TO BE COMPUTED.
!     CHARACTER*1 LHLP(8), LK(8)
!        THE ARRAYS CONTAINING THE NAMES OF THE VARIABLES HLP AND K.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'H',       'P',       'C',       'O',       'E',       'F'/
     data&
    &  lk(1), lk(2), lk(3), lk(4), lk(5), lk(6), lk(7), lk(8)&
     & /  'K',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lhlp(1), lhlp(2), lhlp(3), lhlp(4), lhlp(5), lhlp(6), lhlp(7),&
    &  lhlp(8)&
     & /  'H',   'L',   'P',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, lk, k, 1, 1, head, err01, lk)
!
      call eriodd(nmsub, lk, k, 1, head, err02)
!
      if (err01 .or. err02) go to 10
!
      call erslf(nmsub, lhlp, k, hlp, head, err03)
!
      if (err03) go to 10
      go to 20
!
   10 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   20 continue
!
      call hpflt (hlp, k, hhp)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   32h       call hpcoef (hlp, k, hhp))
      end
!XXCH4
      subroutine xxch4(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE HISTOGRAM FAMILY OF ROUTINES.
!
!     DATA SET IS FROM PAGE 39 OF MANDEL [1964]
!
!     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,n
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   y(40)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL HIST,IPRINT
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        ERROR FLAG
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER N
!        THE LENGTH OF THE VECTOR Y.
!     REAL Y(40)
!        DATA VECTOR FOR TESTS.
!
!
!     DATA INITIALIZATIONS.
!
      data n /39/
!
     data y( 1), y( 2), y( 3), y( 4)&
     &    / 0.4, 0.6, 1.0, 1.0/
     data y( 5), y( 6), y( 7), y( 8)&
     &    / 1.0, 0.5, 0.6, 0.7/
     data y( 9), y(10), y(11), y(12)&
     &    / 1.0, 0.6, 0.2, 1.9/
     data y(13), y(14), y(15), y(16)&
     &    / 0.2, 0.4, 0.0, -0.4/
     data y(17), y(18), y(19), y(20)&
     &    / -0.3, 0.0, -0.4, -0.3/
     data y(21), y(22), y(23), y(24)&
     &    / 0.1, -0.1, 0.2, -0.5/
     data y(25), y(26), y(27), y(28)&
     &    / 0.3, -0.1, 0.2, -0.2/
     data y(29), y(30), y(31), y(32)&
     &    / 0.8, 0.5, 0.6, 0.8/
     data y(33), y(34), y(35), y(36)&
     &    / 0.7, 0.7, 0.2, 0.5/
     data y(37), y(38), y(39)&
     &    / 0.7, 0.8, 1.1/
!
!     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
!
      call iprint(iprt)
!
!     PRINT HEADING
!
      write (iprt,1000)
!
!     PERFORM SIMPLE TEST OF HIST
!
      write (iprt,1100)
      call hist(y, n, ldstak)
      write (iprt,2000) ierr
!
      return
!
!     FORMATS
!
 1000 format ('1*CH4')
 1100 format (' SIMPLE TEST OF HIST')
 2000 format (/' THE VALUE OF IERR IS ', i4)
      end
!ERAGTM
     subroutine eragtm (nmsub, nmvar, ym, ymmiss, n, m, iym, ymmn,&
     &   nvmx, head, msgtyp, nv, error, nmmin)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS TO ENSURE THAT NO VALUES, OR ONLY A MAXIMUM
!     OF NVMX, ARE NOT GREATER THAN A SPECIFIED LOWER BOUND YMMN,
!     WITH NAME NMMIN.   THE CHECKING OPTION IS SPECIFIED
!     WITH MSGTYP.  IF AN ERROR IS FOUND, THE ERROR IS PRINTED AND
!     AN ERROR FLAG AND THE NUMBER OF VIOLATINS ARE RETURNED.
!     ELEMENTS OF YM(*, I) EQUAL TO YMMISS(I) ARE EXEMPT FROM CHECKING.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ymmn
     integer&
     &   iym,m,msgtyp,n,nv,nvmx
     logical&
     &   error,head
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(*),ymmiss(*)
     character&
     &   nmmin(8)*1,nmsub(6)*1,nmvar(8)*1
!
!  LOCAL SCALARS
     integer&
     &   i,j
!
!  EXTERNAL FUNCTIONS
     logical&
     &   mvchk
!       EXTERNAL MVCHK
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL ERAGTP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IYM
!        THE FIRST DIMENSION OF THE ARRAY YM.
!     INTEGER J
!        AN INDEXING VARIABLE.
!     INTEGER M
!        THE NUMBER OF COLUMNS OF DATA IN YM.
!     INTEGER MSGTYP
!        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
!        IF (MSGTYP.GE.3) THE MESSAGE PRINTED WILL USE NMMIN
!        OTHERWISE IT WILL USE YMMN.
!        IF (MSGTYP = 1 OR 3) NO VIOLATIONS ARE ALLOWED.
!        IF (MSGTYP = 2 OR 4) THE NUMBER OF VIOLATIONS MUST
!                             BE LESS THAN   NVMX   .
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE PARAMETERS NAME.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND.
!     INTEGER NVMX
!        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
!     REAL YM(IYM,M)
!        THE ARRAY BEING TESTED.
!     REAL YMMISS(M)
!        MISSING VALUE CODES FOR EACH COLUMN OF YM
!     REAL YMMN
!        THE MINIMUM ACCEPTABLE VALUE.
!
      error = .false.
!
      if ((n.le.0) .or. (m.le.0)) return
!
!     CHECK FOR VIOLATIONS
!
      nv = 0
      do 5 i = 1, n
         do 1 j = 1, m
            if (mvchk(ym(i+(j-1)*iym), ymmiss(j))) go to 1
            if (ym(i+(j-1)*iym) .le. ymmn) nv = nv + 1
    1    continue
    5 continue
!
      if (nv .le. nvmx) return
!
!     VIOLATIONS FOUND
!
      error = .true.
     call eragtp (nmsub, nmvar, ymmn, nvmx, head, msgtyp, nv,&
     &   nmmin)
!
      return
!
      end
!SPPL
      subroutine sppl(ym, x, n, isym, ilog)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A SIMPLE PAGE
!     PLOT WITH USER CONTROL OF PLOT SYMBOLS (LOG OPTION).
!
!     WRITTEN BY - LINDA L. MITCHELL AND JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ilog,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),ym(*)
     integer&
     &   isym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xlb,xmiss,xub,ylb,yub
     integer&
     &   iprt,ischck,isize,iym,lisym,m,nout
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ymmiss(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IERR
!        THE COMMON VARIABLE USED TO INDICATE ERRORS,
!        IF =0, THEN NO ERRORS
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOLS FOR PLOTTING.
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NOUT
!        USED TO INDICATE HOW MANY OF THE POINTS OUTSIDE THE BOUNDS
!        OF THE PLOT ARE TO BE LISTED.
!     REAL X(N)
!        VECTOR OF OBSERVATIONS FOR X COORDINATES
!     REAL XLB
!        THE LOWER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL XMISS
!        THE MISSING VALUE CODE FOR THE X-AXIS.
!     REAL XUB
!        THE UPPER BOUND FOR THE X-AXIS.  (XLB=XUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YLB
!        THE LOWER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!     REAL YM(N,1)
!        VECTOR OF OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        THE UPPER BOUND FOR THE Y-AXIS.  (YLB=YUB INDICATES LIMITS ARE
!        TO BE DETERMINED FROM THE RANGE OF THE DATA.)
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'S',       'P',       'P',       'L',       ' ',       ' '/
!
!     COMMENCE BODY OF ROUTINE
!
!     SET DEFAULT VALUES
!
      ymmiss(1) = 1.0e0
      xmiss = 1.0e0
      m = 1
      iym = n
      multi = .false.
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 0.0e0
      xub = 0.0e0
      ischck = 1
      isize = -1
      nout = 0
      miss = .false.
      lisym = n
!
     call ppcnt (ym, ymmiss, x, xmiss, n, m, iym, multi, ilog,&
    &  ylb, yub, xlb, xub, nmsub, ischck, isym, isize, nout, miss,&
     &  lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL SPPL (Y, X, N, ISYM, ILOG)')
      end
!ACFSD
      subroutine acfsd (rho, sdrho, nc, n)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE STANDARD ERROR OF THE AUTOCORRELATIONS
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n,nc
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   rho(*),sdrho(*)
!
!  LOCAL SCALARS
     integer&
     &   k,klast,lag
!
!  INTRINSIC FUNCTIONS
      intrinsic min,real,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER K
!        AN INDEX VARIABLE.
!     INTEGER KLAST
!        THE LAST LAG VALUE TO BE USED.
!     INTEGER LAG
!        THE INDEX VARIABLE USED TO INDICATE THE AUTOCORRELATION
!        BEING EXAMINED.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NC
!        THE NUMBER OF AUTOCORRELATIONS COMPUTED
!     REAL RHO(NC)
!        THE ARRAY IN WHICH THE AUTOCORRELATIONS ARE STORED
!     REAL SDRHO(NC)
!        THE ARRAY IN WHICH THE STANDARD ERRORS OF THE AUTOCORRELATIONS
!        ARE STORED
!
      sdrho(1) = sqrt(real(n - 1)) / n
      if (nc .eq. 1) return
      do 20 lag = 2, nc
         sdrho(lag) = 0.0e0
         klast = min(lag-1, n-lag)
         do 10 k = 1, klast
            sdrho(lag) = sdrho(lag) + (n-lag-k) * rho(k) * rho(k)
   10    continue
         sdrho(lag) = sqrt((n-lag) + 2.0e0 * sdrho(lag)) / n
   20 continue
      return
      end
!UFSVS
     subroutine ufsvs(acov, lagmax, n, nw, lags, nf,&
     &   fmin, fmax, nprt, spcf, ispcf, freq, ldstak)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS AND USER SUPPLIED ACVF VALUES (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fmax,fmin
     integer&
     &   ispcf,lagmax,ldstak,n,nf,nprt,nw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   acov(*),freq(*),spcf(*)
     integer&
     &   lags(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
      real(kind=wp) :: alpha,delta,ymiss
     integer&
    &   ifp,io,iprt,isort,isym,lacov,ldsmin,lnlppa,lpcv,lwork,ly,&
     &   nall0,work,xaxis,yaxis
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12),y(1)
     integer&
     &   istak(12),nlppa(1)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
     integer&
     &   stkst
!       EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LDSCMP,PARZEN,STKCLR,STKSET,UFSDRV
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ACOV(LAGMAX+1)
!        THE AUTOCOVARIANCES OF THE SERIES.
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE SPECTRUM
!        IS TO BE COMPUTED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF ERR01, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION FOR THE ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY ISYM.
!     INTEGER LACOV
!        THE LENGTH OF THE ACVF VECTORS.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
!        THIS ROUTINE WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(1)
!        A DUMMY ARRAY FOR SERIES WITHOUT MISSING VALUES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL SPCF(ISPCF,NW)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     INTEGER WORK
!        THE STARTING LOCATION IN RSTAK FOR
!        THE WORK VECTOR.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY XAXIS.
!     REAL Y(1)
!        A DUMMY ARRAY.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY YAXIS.
!     REAL YMISS
!        A DUMMY VARIABLE.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'U','F','S','V','S',' '/
!
!     SET UP
!
      option(4) = .true.
      option(3) = .true.
      option(2) = .false.
      option(1) = .false.
!
      lacov = lagmax+1
!
!     COMPUTE MINIMUM ALLOWABLE STACK LENGTH
!
      io = 1
      if (nprt.eq.0) io = 0
!
     call ldscmp(4, 0, io*(nf+5), 0, 0, 0, 'S',&
     &   lagmax+1+io*(2*nf+10), ldsmin)
!
      ymiss = 1.0e0
!
      ly = 1
      lnlppa = 1
      lpcv = nf + 5
      lwork = lagmax+1
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!     SET THE STACK ALLOCATION TYPE.
!
      call stkset(ldstak, 4)
      nall0 = stkst(1)
!
      ifp = 3
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
!
      if ((ldsmin.gt.ldstak) .or. (ldsmin.le.6)) then
         work = 1
         xaxis = 1
         yaxis = 1
         isym = 1
         isort = 1
      else
         work = stkget(lwork,ifp)
         if (nprt.ne.0) then
            xaxis = stkget(lpcv,ifp)
            yaxis = stkget(lpcv,ifp)
            isym = stkget(lpcv,2)
            isort = isym
         else
            xaxis = work
            yaxis = work
            isym = work
            isort = isym
         end if
      end if
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!
     call ufsdrv(y, ly, ymiss, acov, nlppa, spcf, ispcf, nf, fmin,&
    &   fmax, freq, n, nw, lagmax, lags, rstak(work), lacov, lwork,&
    &   delta, istak(isort), istak(isym), rstak(xaxis), rstak(yaxis),&
    &   lpcv, alpha, nprt, parzen, nmsub, ldsmin, ldstak, option,&
     &   lnlppa, ly)
!
      call stkclr(nall0)
!
!     CHECK FOR ERRORS
!
      if (ierr.eq.0) return
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL UFSVS (ACOV, LAGMAX, N,'/&
    &   '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/&
     &   '      +            SPCF, ISPCF, FREQ, LDSTAK)')
      end
!CNTR
      subroutine cntr (y, n, yc)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CENTERS THE INPUT SERIES Y ABOUT ITS MEAN,
!     RETURNING THE CENTERED SERIES IN YC.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*),yc(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   ymean
     integer&
     &   i
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL AMEAN
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE INPUT SERIES.
!     REAL Y(N)
!        THE INPUT ARRAY OF OBSERVATIONS TO BE CENTERED.
!     REAL YC(N)
!        THE OUTPUT ARRAY OF CENTERED OBSERVATIONS.
!     REAL YMEAN
!        THE MEAN OF THE INPUT SERIES.
!
      call amean (y, n, ymean)
!
      do 10 i = 1, n
         yc(i) = y(i) - ymean
   10 continue
!
      return
!
      end
!GFORD
     subroutine gford (freq, gain, isort, nf, xord, yord,&
     &   nord, ypltmn, ypltmx, nprt, igferr)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES ORDANENTS FOR THE GAIN FUNCTION PLOTS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ypltmn,ypltmx
     integer&
     &   igferr,nf,nord,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(nf),gain(nf),xord(nf),yord(nf)
     integer&
     &   isort(nf)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   gainmn,gainmx,ymax
     integer&
     &   i,j
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL SPCCK
!
!  INTRINSIC FUNCTIONS
      intrinsic log10
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     REAL GAIN(NF)
!        THE VECTOR IN WHICH THE GAIN FUNCTION IS STORED.
!     REAL GAINMN, GAINMX
!        THE MINIMUM AND MAXIMUM GAIN FUNCTION VALUE TO BE PLOTTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IGFERR
!        AN ERROR FLAG INDICATING WHETHER COMPUTATIONS SEEM
!        TO HAVE PRODUCED REASONABLE RESULTS.
!     INTEGER ISORT(NF)
!        THE ARRAY USED FOR SORTING.
!     INTEGER J
!        AN INDEXING VARIABLE.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRAL ESTIMATES
!        ARE TO BE ESTIMATED.
!     INTEGER NORD
!        THE NUMBER OF ORDINATES TO BE PLOTTED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBELS/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     REAL XORD(NF)
!        THE X ORDINATES FOR THE SPECTRUM PLOT.
!     REAL YMAX
!        THE MAXIMUM ACTUAL SPECTRUM VALUE (IN DECIBELS) TO BE PLOTTED.
!     REAL YORD(NF)
!        THE Y ORDINATES FOR THE SPECTRUM PLOTS.
!     REAL YPLTMN, YPLTMX
!        THE MINIMUM AND MAXIMUM VAUES TO BE PLOTTED FOR THE Y AXIS.
!
      igferr = 0
!
      call spcck (gain, isort, nf, gainmn, gainmx, nord, igferr)
!
      if (igferr .ne. 0) return
!
      j = 0
!
      if (nprt.ge.1) go to 30
!
!     SET ORDINATES FOR DECIBLE PLOTS
!
      ymax = 10.0e0 * log10(gainmx)
!
      ypltmx = 0.0e0
      ypltmn = 10.0e0 * log10(gainmn) - ymax
!
      do 10 i = 1, nf
         if (gain(i) .lt. gainmn) go to 10
         j = j + 1
         xord(j) = freq(i)
         yord(j) = 10.0e0 * log10(gain(i)) - ymax
   10 continue
!
      return
!
   30 continue
!
      ypltmx = gainmx
      ypltmn = gainmn
!
!     SET ORDINATES FOR LOG PLOTS
!
      do 50 i = 1, nf
         if (gain(i) .lt. gainmn) go to 50
         j = j + 1
         xord(j) = freq(i)
         yord(j) = gain(i)
   50 continue
!
      return
      end
!FITPT2
      subroutine fitpt2 (sdres, pv, wt, n, nnzw, weight, res, rss)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE, ADAPTED FROM OMNITAB II, PRINTS
!     THE FOUR STANDARDIZED RESIDUAL PLOTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   rss
     integer&
     &   n,nnzw
     logical&
     &   weight
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   pv(n),res(n),sdres(n),wt(n)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   annzw,dot,fac1,fac2,fplm,gamma,pi,pvdiv,pvmax,pvmid,pvmin,&
    &   ratio,rowdiv,rowmax,rowmid,rowmin,w,xdiv,xmax,xmin,ylabel,&
     &   ymax,ymin
     integer&
    &   i,i1,i2,idot,ifirst,imid,iplot,iprb,iprt,ipv,irow,ix,k,l,&
     &   ncol,ncolp1,ncolpl,ncolt2,ndot,nrow
     character&
     &   iblank*1,iminus*1,iplus*1,istar*1
!
!  LOCAL ARRAYS
     character&
     &   line(102)*1
!
!  EXTERNAL FUNCTIONS
!      REAL(KIND=WP) ::
!     +   R1MACH
!      LOGICAL
!     +   MVCHK
!      EXTERNAL R1MACH,MVCHK
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL GETPI,IPRINT
!
!  INTRINSIC FUNCTIONS
      intrinsic int,max,min,mod
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ANNZW
!        THE NUMBER OF NONZERO WEIGHTS, USED IN COMPUTING
!        THE NORMAL PROBABILITY PLOT.
!     REAL DOT
!        ...
!     REAL FAC1, FAC2
!        FACTORS USED IN COMPUTING THE NORMAL PROBABILITY PLOT.
!     REAL FPLM
!        THE FLOATING POINT LARGEST MAGNITUDE.
!     REAL GAMMA
!        A VALUE USED IN COMPUTING THE NORMAL PROBABILITY PLOT.
!     INTEGER I
!        AN INDEX VARIABLE.
!     CHARACTER*1 IBLANK
!        THE VALUE OF THE CHARACTER -BLANK-.
!     INTEGER IERR
!        THE INTEGER VALUE DESIGNATING WHETHER ANY ERRORS HAVE
!        BEEN DETECTED.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .NE. 0, ERRORS HAVE BEEN DETECTED.
!     INTEGER IFIRST
!        THE FIRST ROW OF THE VARIABLES TO BE PLOTTED.
!     INTEGER IMID
!        THE MIDPOINT OF THE FIRST PLOT OF THE SECOND SET
!     CHARACTER*1 IMINUS
!        THE CHARACTER MINUS.
!     INTEGER IPLOT
!        AN INDICATOR VARIABLE DESIGNATING WHETHER THE FIRST OR
!        SECOND SET OF TWO PLOTS ARE BEING PRINTED.
!     CHARACTER*1 IPLUS
!        THE CHARACTER PLUS.
!     INTEGER IPRB
!        THE LOCATION IN THE PLOT STRING OF THE SYMBOL FOR THE
!        PROBABILITY PLOT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IPV
!        THE LOCATION IN THE PLOT STRING OF THE SYMBOL FOR THE PLOT
!        VERSUS PREDICTED VALUE.
!     INTEGER IROW
!        THE ROW OF THE VARIABLES BEING PLOTTED.
!     CHARACTER*1 ISTAR
!        THE CHARACTER STAR.
!     INTEGER IX
!        THE LOCATION IN THE PLOT STRING OF THE SYMBOL FOR THE PLOTS
!        VERSUS THE INDEPENDENT VARIABLE.
!     INTEGER I1, I2
!        ...
!     INTEGER K, L
!        INDEX VARIABLES.
!     CHARACTER*1 LINE(102)
!        THE SYMBOLS (BLANKS AND CHARACTERS) FOR A GIVEN LINE
!        OF THE PLOT.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN EACH COLUMN OF DATA.
!     INTEGER NCOL, NCOLPL, NCOLP1, NCOLT2
!        THE NUMBER OF COLUMNS IN THE PLOT, NCOL+L, NCOL+1,
!        AND NCOL * 2.
!     INTEGER NDOT
!        ...
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NROW
!        THE NUMBER OF COLUMNS IN THE PLOT.
!     REAL PI
!        THE VALUE OF PI.
!     REAL PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT COEFFICIENT ESTIMATES
!     REAL PVDIV
!        THE VALUE OF A DIVISION ALONG THE -PREDICTED VALUE- AXIS.
!     REAL PVMAX
!        THE LARGEST VALUE IN THE VECTOR PV.
!     REAL PVMID
!        THE MIDPOINT OF THE RANGE OF VALUES IN THE VECTOR PV.
!     REAL PVMIN
!        THE SMALLEST VALUE IN THE VECTOR PV.
!     REAL RATIO
!        A VALUE USED TO PRODUCE THE NORMAL PROBABILITY PLOT.
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL ROWDIV
!        THE VALUE OF A DIVISION ALONG THE -ROW- AXIS.
!     REAL ROWMAX
!        THE LARGEST ROW VALUE.
!     REAL ROWMID
!        THE MIDPOINT OF THE RANGE OF THE ROWS PLOTTED.
!     REAL ROWMIN
!        THE SMALLEST ROW VALUE PLOTTED.
!     REAL RSS
!        THE RESIDUAL SUM OF SQUARES.
!     REAL SDRES(N)
!        THE STANDARD DEVIATIONS OF THE RESIDUALS.
!     REAL W
!        THE VALUE OF THE WEIGHT FOR THE CURRENT VALUE BEING PLOTTED.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     REAL WT(N)
!        THE USER SUPPLIED WEIGHTS.
!     REAL XDIV
!        THE VALUE OF A DIVISION ALONG THE X AXIS.
!     REAL XMAX
!        THE LARGEST VALUE ALONG THE X AXIS.
!     REAL XMIN
!        THE SMALLEST VALUE ALONG THE X AXIS.
!     REAL YLABEL
!        THE LABEL TO BE PRINTED ALONG THE Y AXIS.
!     REAL YMAX
!        THE LARGEST VALUE ALONG THE Y AXIS
!     REAL YMIN
!        THE SMALLEST VALUE ALONG THE Y AXIS.
!
      data iplus/'+'/, iminus/'-'/, istar/'*'/, iblank/' '/
!
      call iprint(iprt)
!
      fplm = r1mach(2)
!
!     CHECK FOR INSUFFICIENT POINTS TO PLOT
!
      if (ierr.eq.4) then
         do 1 i = 1, n
            if (sdres(i).ne.fplm) go to 5
    1    continue
         write (iprt, 1090)
         return
      end if
    5 continue
!
!     INITIALIZE VARIABLES FOR PROBABILITY PLOT
!
      call getpi(pi)
      gamma = pi/8.0e0
      annzw = nnzw
      fac1 = 1.0e0 / (annzw - 2.0e0*gamma + 1.0e0)
      fac2 = 10.0e0
!
!     INITIALIZE THE PLOT SIZE (IN PLOT UNITS)
!
      nrow = 26
      ncol = 51
      ncolp1 = ncol + 1
      ncolt2 = 2*ncol
      imid = (ncol-1)/2
!
!     FIND THE FIRST ROW OF OBSERVATIONS WITH NONZERO WEIGHTS
!
      ifirst = 1
      if (.not. weight) go to 20
      do 10 i=1,n
         if (wt(i).le.0.0e0) go to 10
         ifirst = i
         go to 20
   10 continue
!
!     BEGIN COMPUTATIONS FOR FIRST SET OF PLOTS
!
   20 iplot = 1
!
!     SET X AXIS LIMITS FOR STANDARDIZED RESIDUAL VS ROW PLOT,
!     AND STANDARDIZED RESIDUALS VS PREDICTED VALUES PLOT.
!
      rowmin = ifirst
      pvmin = pv(ifirst)
      pvmax = pv(ifirst)
      rowmax = ifirst
      do 30 i=ifirst,n
         w = 1.0e0
         if (weight) w = wt(i)
         if (w.gt.0.0e0) then
            rowmax = i
            if (pv(i).lt.pvmin) pvmin = pv(i)
            if (pv(i).gt.pvmax) pvmax = pv(i)
         end if
   30 continue
!
      if (pvmin.lt.pvmax) go to 35
         if (pvmin.eq.0.0e0) go to 33
            pvmin = pvmin - pvmin/2.0e0
            pvmax = pvmax + pvmax/2.0e0
         go to 35
   33    continue
            pvmin = -0.5e0
            pvmax = 0.5e0
   35 continue
!
      rowmid = (rowmax+rowmin)/2.0e0
      rowdiv = (rowmax-rowmin)/(ncol-1)
      pvmid = (pvmax+pvmin)/2.0e0
      pvdiv = (pvmax-pvmin)/(ncol-1)
!
!     PRINT TITLES FOR FIRST PLOTS
!
      write (iprt,1000)
      go to 90
!
!     BEGIN COMPUTATIONS FOR SECOND SET OF PLOTS
!
   40 iplot = 2
!
!     SET AXIS LIMITS FOR THE STANDARDIZED RESIDUALS VS
!     STANDARDIZED RESIDUALS LAGED BY ONE AND FOR PROBABILITY PLOT
!
      xmin = -3.75e0
      xmax = 3.75e0
      xdiv = (xmax-xmin)/(ncol-1)
!
!     PRINT TITLES FOR SECOND PLOTS
!
      write (iprt,1050)
!
!     WRITE FIRST LINE OF PLOTS
!
   90 continue
!
!     PRINT PLOTS, ONE LINE AT A TIME
!
      ylabel = 3.75e0
      ymax = fplm
      ymin = 4.05e0
      do 160 k=1,nrow
         ymin = ymin - 0.3e0
         if (-3.70e0.ge.ymin) ymin = -fplm
         do 100 l=1,ncol
            ncolpl = l + ncol
            line(l) = iblank
            line(ncolpl) = iblank
            if ((k.ne.1) .and. (k.ne.nrow)) go to 100
               line(l) = iminus
               line(ncolpl) = iminus
               if ((mod(l,10).ne.1) .and. (l.ne.1+ncol/2)) go to 100
                  line(l) = iplus
                  line(ncolpl) = iplus
  100    continue
         do 110 i=1,n
            if (weight) then
               w = wt(i)
            else
               w = 1.0e0
            end if
            if ((w.ne.0.0e0) .and. (.not.mvchk(sdres(i),fplm))) then
               if ((sdres(i).gt.ymin) .and. (sdres(i).le.ymax)) then
                  if (iplot.eq.1) then
!
!     SET PLOT LINE FOR FIRST SET OF PLOTS
!
                     irow = int(((i-rowmin)/rowdiv)+1.5e0)
                     line(irow) = istar
                     ipv = int((pv(i)-pvmin)/pvdiv+1.5e0) + ncol
                     line(ipv) = istar
                  else
!
!     SET PLOT LINE FOR PROBABILITY PLOT
!
                     ratio = (annzw-gamma) * fac1
                    iprb = int(4.91e0*(ratio**0.14e0-&
     &                         (1.0e0-ratio)**0.14e0)*fac2) + 77
                     if (iprb.le.ncol) iprb = ncol+1
                     if (iprb.ge.103) iprb = 102
                     line(iprb) = istar
                     annzw = annzw - 1.0e0
                     if ((annzw.lt.2.0e0) .and. (nnzw.le.10)) then
                        gamma = 1.0e0/3.0e0
                     end if
                  end if
               end if
            end if
  110    continue
!
!     SET PLOT LINE FOR CORRELATION PLOT
!
         if (iplot.eq.2) then
            if (k.le.n-1) then
              dot = 0.0e0
              if (weight) then
                ndot = 0
                do 120 idot = 1, n-k
                 if ((wt(idot).gt.0.0e0) .and.&
     &                (wt(idot+k).gt.0.0e0)) then
                    ndot = ndot + 1
                    dot = dot + res(idot)*res(idot+k)
                  end if
  120           continue
                if (ndot.ge.1) then
                   dot = dot * (n-k) / ndot
                end if
              else
                do 130 idot = 1, n-k
                  dot = dot + res(idot)*res(idot+k)
  130           continue
              end if
              ix = int(imid*dot/rss) + imid + 1
              i1 = min(ix,imid+1)
              i2 = max(ix,imid+1)
              do 140 ix=i1,i2
                line(ix) = istar
  140         continue
            end if
         end if
         if (mod(k,5).eq.1) then
            if (iplot.eq.1) then
              write (iprt,2020) ylabel, (line(l),l=1,ncol), ylabel,&
     &         (line(l),l=ncolp1,ncolt2)
            else
              write (iprt,1020) k, (line(l),l=1,ncol), ylabel,&
     &         (line(l),l=ncolp1,ncolt2)
            end if
            ylabel = ylabel - 1.5
         else
            write (iprt,1030) (line(l),l=1,102)
         end if
         ymax = ymin
  160 continue
!
!     PRINT BOTTOM LINE OF GRAPHS
!
      if (iplot.eq.1) then
!
!     PRINT X AXIS LABELS FOR FIRST SET OF PLOTS
!
         write (iprt,1040) rowmin, rowmid, rowmax, pvmin, pvmid, pvmax
         go to 40
      else
!
!     PRINT X AXIS LABELS FOR SECOND SET OF PLOTS
!
         write (iprt,1070)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/20x, 23h std res vs row number , 35x,&
     &   29h std res vs predicted values )
!1010 FORMAT (7X, 2('+', 9A1), '+', 4A1, 'X', 4A1, 2('+', 9A1), '+',
!    *   10X, 2('+', 9A1), '+', 4A1, 'X', 4A1, 2('+', 9A1), '+')
 1020 format (1x, i5, '+', 51a1, '+', 3x, f5.2, '+', 51a1, '+')
 1030 format (6x, '-', 51a1, '-', 8x, '-', 51a1, '-')
1040 format (1x, f8.1, 17x, f8.1, 17x, f8.1, 4x, g11.4, 14x, g11.4,&
     &   10x, g11.4)
1050 format (/13x, 'AUTOCORRELATION FUNCTION OF RESIDUALS',&
     &   23x, 36h normal probability plot of std res )
!1060 FORMAT ('+', F5.2, '+', 51A1, '+', 3X, F5.2, '+', 51A1, '+')
1070 format (4x, 5h-1.00, 22x, 3h0.0, 21x, 4h1.00, 5x, 4h-2.5, 23x,&
     &   3h0.0, 22x, 3h2.5)
!1080 FORMAT ('+', 6X, 2('+', 9A1), '+', 4A1, 'X', 4A1, 2('+', 9A1),
!    *   '+', 10X, 2('+', 9A1), '+', 4A1, 'X', 4A1, 2('+', 9A1), '+')
1090 format (// 1x, 13('*')/ 1x, 13h*  warning  */ 1x, 13('*')//&
    &   54h the standardized residual plots have been suppressed.,&
    &   45h  none of the standardized residuals could be,&
    &   10h computed,/&
    &   50h because for each observation either the weight or,&
     &   48h the standard deviation of the residual is zero.)
 2020 format (1x, f5.2, '+', 51a1, '+', 3x, f5.2, '+', 51a1, '+')
      end
!SVPML
      subroutine svpml(ym, ymiss, n, ns, isym, ilog)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT WITH MISSING DATA AND USER CONTROL OF THE PLOT SYMBOL USED
!     (LOG PLOT OPTION).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: ymiss
     integer&
     &   ilog,n,ns
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: ym(*)
     integer&
     &   isym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ibar,iprt,irlin,ischck,isize,iym,lisym,m
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
      real(kind=wp) :: ymmiss(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(N)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMISS
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  'S',       'V',       'P',       'M',       'L',       ' '/
!
!     SET DEFAULT VALUES
!
      ymmiss=ymiss
      m = 1
      iym = n
      multi = .false.
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 1.0e0
      xinc = 1.0e0
      ischck = 1
      isize = -1
      miss = .true.
      lisym = n
      irlin = -1
      ibar = 0
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ymmiss, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &  '       CALL SVPML (Y, YMISS, N, NS, ISYM, ILOG)')
      end
!MVCHK
      logical function mvchk (x, xmiss)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE CHECKS WHETHER X = XMISS (MVCHK = TRUE) OR NOT
!     (MVCHK = FALSE) IN A MANNER WHICH WILL PREVENT VERY LARGE OR
!     VERY SMALL MISSING VALUE CODES FROM CAUSING AN OVERFLOW.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   x,xmiss
!
!  INTRINSIC FUNCTIONS
      intrinsic abs
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL X
!        THE VALUE TO BE CHECKED.
!     REAL XMISS
!        THE USER SUPPLIED CODE WHICH IS USED TO DETERMINE WHETHER OR
!        NOT AN OBSERVATION IS MISSING.  IF X = XMISS,
!        THE VALUE IS ASSUMED MISSING, OTHERWISE IT IS NOT.
!
     if ((x .gt. 0.0e0 .and. xmiss .lt. 0.0e0) .or.&
     &    (x .lt. 0.0e0 .and. xmiss .gt. 0.0e0)) go to 10
!
      if (abs(x) .eq. abs(xmiss)) go to 20
!
   10 mvchk = .false.
      return
!
   20 mvchk = .true.
      return
!
      end
!STPLS1
      subroutine stpls1(n, m, ixm, par, npar, neta, exmpt, scale, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     SET UP PROBLEM SPECIFICATION FOR TESTING THE USER CALLABLE
!     ROUTINES IN THE (LEAST SQUARES) STEP SIZE SELECTION FAMILY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   exmpt
     integer&
     &   ixm,m,n,neta,npar,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(10),scale(10)
!
!  LOCAL SCALARS
     integer&
     &   i
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXEMPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL SCALE(10)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!
      par(1) = 0.0e0
      par(2) = 3.125e0
      par(3) = 1.0e0
      par(4) = 2.0e0
!
      n = 101
      m = 1
      ixm = 200
      npar = 4
      do 10 i=1,10
         scale(i) = 1.0e0
   10 continue
      neta = 0
      exmpt = 0.0e0
      nprt = 1
!
      return
!
      end
!STPMN
     subroutine stpmn(j,xm,n,m,ixm,mdl,par,npar,&
    &   nexmpt,eta,reltol,scale,stp,nfail,ifail,cd,&
     &   itemp,fd,fdlast,fdsave,pv,pvmcd,pvnew,pvpcd,pvstp,pvtemp)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN SUBROUTINE FOR SELECTING THE STEP SIZE FOR
!     COMPUTING AGAINST NUMERICAL DERIVATIVES
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   eta,reltol,scale,stp
     integer&
     &   ixm,j,m,n,nexmpt,nfail,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   cd(n),fd(n),fdlast(n),fdsave(n),par(npar),pv(n),pvmcd(n),&
     &   pvnew(n),pvpcd(n),pvstp(n),pvtemp(n),xm(ixm,m)
     integer&
     &   ifail(n),itemp(n)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  SCALARS IN COMMON
     real(kind=wp) ::&
     &   q
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   abstol,curve,eta3,fplrs,parmx,pvmean,pvtyp,stpcd,stplow,&
     &   stpmid,stpup,tauabs,temp,third
     integer&
     &   i
!
!  EXTERNAL FUNCTIONS
     real(kind=wp) ::&
     &   r1mach
!       EXTERNAL R1MACH
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL CMPFD,GMEAN,RELCOM,STPADJ,STPSEL
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max,sign,sqrt
!
!  COMMON BLOCKS
      common /notopt/q
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ABSTOL
!        THE ABSOLUTE AGREEMENT TOLERANCE.
!     REAL CD(N)
!        THE CENTRAL DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER.
!     REAL CURVE
!        A MEASURE OF THE CURVATURE OF THE MODEL.
!     REAL ETA
!        THE RELATIVE NOISE IN THE MODEL
!     REAL ETA3
!        THE CUBE ROOT OF ETA.
!     REAL FD(N)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!     REAL FDLAST(N)
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATION TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!        COMPUTED WITH THE MOST RECENT STEP SIZE SELECTED.
!     REAL FDSAVE(N)
!        A VECTOR USED TO SAVE THE BEST OF THE
!        THE FORWARD DIFFERENCE QUOTIENT APPROXIMATIONS TO THE
!        DERIVATIVE OF THE MODEL WITH RESPECT TO THE JTH PARAMETER
!     REAL FPLRS
!        THE FLOATING POINT LARGEST RELATIVE SPACING.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IFAIL(N)
!        THE VECTOR OF INDICATOR VARIABLES DESIGNATING WHETHER
!        THE STEP SIZE SELECTED WAS SATISFACTORY FOR A GIVEN
!        OBSERVATION AND PARAMETER.
!     INTEGER ITEMP(N)
!        A TEMPORARY STORAGE VECTOR.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER J
!        THE INDEX OF THE PARAMETER BEING EXAMINED.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NEXMPT
!        THE NUMBER OF OBSERVATIONS FOR WHICH A GIVEN STEP SIZE
!        DOES NOT HAVE TO BE SATISFACTORY AND THE SELECTED STEP
!        SIZE STILL BE CONSIDERED OK.
!     INTEGER NFAIL
!        THE VECTOR CONTAINING THE COUNTS FOR EACH PARAMETER
!        OF THE NUMBER OF OBSERVATIONS THE SELECTED STEP SIZE WAS
!        NOT SATISFACTORY.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL PARMX
!        THE MAXIMUM OF THE CURRENT PARAMETER ESTIMATE AND THE
!        TYPICAL VALUE OF THAT PARAMETER
!     REAL PV(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL PVMCD(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)-STPCD.
!     REAL PVMEAN
!        THE MEAN OF A FUNCTION OF THE PREDICTED VALUES.
!     REAL PVNEW(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPNEW.
!     REAL PVPCD(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STPCD.
!     REAL PVSTP(N)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!        FOR ALL BUT THE JTH PARAMETER VALUE, WHICH IS PAR(J)+STP.
!     REAL PVTEMP(N)
!        A TEMPORARY STORAGE VECTOR FOR PREDICTED VALUES.
!     REAL PVTYP
!        THE TYPICAL SIZE OF THE PREDICTED VALUES OF THE MODEL.
!     REAL Q
!        A DUMMY VARIABLE WHICH IS USED, ALONG WITH COMMON NOTOPT (NO
!        OPTIMIZATION), TO COMPUTE THE STEP SIZE.
!     REAL SCALE
!        THE TYPICAL SIZE OF THE JTH PARAMETER.
!     REAL STP
!        THE STEP SIZE CURRENTLY BEING EXAMINED FOR THE FORWARD
!        DIFFERENCE APPROXIMATION TO THE DERIVATIVE.
!     REAL STPCD
!        THE STEP SIZE USED FOR THE CENTRAL DIFFERENCE QUOTIENT.
!     REAL STPLOW
!        THE LOWER LIMIT ON THE STEP SIZE.
!     REAL STPMID
!        THE MIDPOINT OF THE ACCEPTABLE RANGE OF THE STEP SIZE.
!     REAL STPUP
!        THE UPPER LIMIT ON THE STEP SIZE.
!     REAL RELTOL
!        THE RELATIVE AGREEMENT TOLERANCE.
!     REAL TAUABS
!        THE ABSOLUTE AGREEMENT TOLERANCE.
!     REAL TEMP
!        A TEMPORARY LOCATION IN WHICH THE CURRENT ESTIMATE OF THE JTH
!        PARAMETER IS STORED.
!     REAL THIRD
!        THE VALUE ONE THIRD.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      fplrs = r1mach(4)
!
!     SET VARIOUS PARAMETERS NECESSARY FOR COMPUTING THE
!     OPTIMUM STEP SIZE
!
      third = 1.0e0 / 3.0e0
!
      eta3 = eta ** third
!
      parmx = max(abs(par(j)), abs(scale))
      if (parmx .eq. 0.0e0) parmx = 1.0e0
!
      stpcd = ((3.0e0 ** third) * eta3 * parmx * sign(1.0e0, par(j)))
!
      q = stpcd + par(j)
      stpcd = q - par(j)
!
      temp = par(j)
!
      par(j) = temp + stpcd
      call mdl(par, npar, xm, n, m, ixm, pvpcd)
!
      par(j) = temp - stpcd
      call mdl(par, npar, xm, n, m, ixm, pvmcd)
!
      par(j) = temp
!
!     ESTIMATE CURVATURE BY SECOND DERIVATIVE OF MODEL WITH RESPECT TO
!     PAR(J)
!
      do 10 i = 1, n
         pvtemp(i) = abs((pvpcd(i)+pvmcd(i)) - 2*pv(i))
         if (pvtemp(i).eq.0.0e0) then
            if (pv(i).eq.0.0e0) then
               pvtemp(i) = fplrs
            else
               pvtemp(i) = fplrs*abs(pv(i))
            end if
         end if
   10 continue
!
!     COMPUTE THE GEOMETRIC MEAN
!
      call gmean(pvtemp, n, pvmean)
!
      curve = abs(pvmean / stpcd / stpcd)
!
!     COMPUTE A TYPICAL VALUE OF THE MODEL
!
      do 20 i = 1, n
         pvtemp(i) = abs(pvpcd(i) + pv(i) + pvmcd(i))
         if (pvtemp(i).eq.0.0e0) then
            if (pv(i).eq.0.0e0) then
               pvtemp(i) = fplrs
            else
               pvtemp(i) = fplrs*abs(pv(i))
            end if
         end if
   20 continue
!
      call gmean(pvtemp, n, pvmean)
!
      pvtyp = abs(pvmean / 3.0e0)
!
!     SET VALUES REPRESENTATIVE OF THE RANGE THE STEP SIZE
!     CAN BE EXPECTED TO TAKE
!
      stpup = (eta3) * parmx
      stplow = (eta3) * stpup
      stpmid = sqrt(stplow) * sqrt(stpup)
!
!     SELECT AN OPTIMUM STARTING STEP SIZE
!
      if (curve.eq.0.0e0) then
         stp = parmx * sign(1.0e0, par(j))
      else
        stp = (2.0e0 * sqrt(eta) * sqrt(pvtyp) / sqrt(curve)) *&
     &         sign(1.0e0,par(j))
      end if
!
      if (abs(stp).gt.parmx) stp = parmx * sign(1.0e0,par(j))
!
      q = stp + par(j)
      stp = q - par(j)
!
      if (stp.eq.0.0e0) then
         stp = fplrs * par(j)
         if (stp.eq.0.0e0) stp = fplrs
!
   30    continue
         q = stp + par(j)
         stp = q - par(j)
!
         if (stp.eq.0.0e0) then
            stp = 2.0e0 * stp
            go to 30
         end if
      end if
!
!     COMPUTE THE ABSOLUTE TOLERANCES
!
      abstol = 10.0e0 * eta * pvtyp
!
      tauabs = 2.0e0 * sqrt(eta) * sqrt(pvtyp)
      if (curve .ne. 0.0e0) tauabs = tauabs * sqrt(curve)
!
      temp = par(j)
      par(j) = temp + stp
!
      call mdl(par, npar, xm, n, m, ixm, pvstp)
!
      par(j) = temp
!
!     COMPUTE THE FORWARD AND CENTRAL DIFFERENCE QUOTIENT ESTIMATE
!     OF THE DERIVATIVE
!
      call cmpfd(n, stp, pvstp, pv, fd)
!
      call cmpfd(n, 2.0e0*stpcd, pvpcd, pvmcd, cd)
!
!     COMPUTE THE NUMBER OF OBSERVATIONS FOR WHICH THE FD DOES NOT
!     AGREE WITH THE CD WITHIN THE TOLERANCE SPECIFIED.
!
      call relcom(n, fd, cd, reltol, abstol, nfail, ifail)
!
!     IF THE FORWARD DIFFERENCE APPROXIMATION DOES NOT AGREE WITHIN
!     TOLERANCE FOR MORE THAN   NEXMPT   OBSERVATION, SELECT NEW
!     VALUE OF THE STEP SIZE, ELSE ADJUST THE STEP SIZE AND RETURN.
!
      if (nfail.gt.nexmpt) then
!
!        SELECT NEW VALUE OF THE STEP SIZE
!
           call stpsel(xm, n, m, ixm, mdl, par, npar,&
    &         nexmpt, stp, nfail, ifail, j, eta3, reltol, abstol,&
    &         tauabs, stplow,&
     &         stpmid, stpup, itemp, fd, fdlast, fdsave, pv, pvnew)
      else
!
!        ADJUST THE CURRENT STEP SIZE VALUE
!
           call stpadj(xm, n, m, ixm, mdl, par, npar,&
    &         nexmpt, stp, nfail, ifail, j, reltol, abstol, stplow,&
     &         stpmid, stpup, itemp, fd, fdlast, pv, pvnew)
!
      end if
!
!     CONVERT SELECTED ABSOLUTE STEP SIZE TO RELATIVE STEP SIZE
!
      stp = abs(stp) / parmx
!
      return
!
      end
!SAMPLE
      subroutine sample (y, n, ns, ys, nys)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE SAMPLES EVERY KTH OBSERVATION FROM THE INPUT
!     SERIES Y, STORING THE SAMPLED SERIES IN YS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 26, 1980
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n,ns,nys
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   y(*),ys(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     integer&
     &   iprt
     logical&
     &   err01,err02,head
!
!  LOCAL ARRAYS
     character&
     &   ln(8)*1,lns(8)*1,lone(8)*1,nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EISGE,EISII,IPRINT,SMPLY
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERR01, ERR02
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER USED FOR OUTPUT.
!     CHARACTER*1 LN(8), LNS(8), LONE(8)
!        THE ARRAY CONTAINING THE NAME OF THE VARIABLE N AND NS.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES Y.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NS
!        THE SAMPLING RATE.
!     INTEGER NYS
!        THE NUMBER OF OBSERVATIONS IN THE FILTERED SERIES YS.
!     REAL Y(N)
!        THE VECTOR CONTAINING THE OBSERVED TIME SERIES.
!     REAL YS(N)
!        THE VECTOR IN WHICH THE SAMPLED SERIES IS RETURNED.
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     & /     'S',       'A',       'M',       'P',       'L',       'E'/
     data&
    &  ln(1), ln(2), ln(3), ln(4), ln(5), ln(6), ln(7), ln(8)&
     & /  'N',   ' ',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lns(1), lns(2), lns(3), lns(4), lns(5), lns(6), lns(7), lns(8)&
     & /  'N',   'S',   ' ',   ' ',   ' ',   ' ',   ' ',   ' '/
     data&
    &  lone(1), lone(2), lone(3), lone(4), lone(5), lone(6), lone(7),&
    &  lone(8)&
     & /  'O',   'N',   'E',   ' ',   ' ',   ' ',   ' ',   ' '/
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      head = .true.
!
!     CALL ERROR CHECKING ROUTINES
!
      call eisge(nmsub, ln, n, 3, 1, head, err01, ln)
!
      call eisii(nmsub, lns, ns, 1, n, 1, head, err02, lone, ln)
!
      if (err01 .or. err02) go to 10
      go to 20
!
   10 continue
      ierr = 1
      call iprint (iprt)
      write (iprt, 1000)
      return
!
   20 continue
!
      call smply (y, n, ns, ys, nys)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   38h       call sample (y, n, ns, ys, nys))
      end
!ERVGTP
     subroutine ervgtp (nmsub, nmvar, veclb, nvmn, nvmx, head, msgtyp,&
     &  nv, nmmin)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRINTS THE ERROR MESSAGES FOR ERVGT AND ERVGTM.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   veclb
     integer&
     &   msgtyp,nv,nvmn,nvmx
     logical&
     &   head
!
!  ARRAY ARGUMENTS
     character&
     &   nmmin(8)*1,nmsub(6)*1,nmvar(8)*1
!
!  LOCAL SCALARS
     integer&
     &   i,iprt
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED (TRUE)
!        OR NOT (FALSE).
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
!        IF (MSGTYP.GE.4) THE MESSAGE PRINTED WILL USE NMMIN
!        OTHERWISE IT WILL USE VECLB.
!        IF (MSGTYP = 1 OR 4) NO VIOLATIONS ARE ALLOWED.
!        IF (MSGTYP = 2 OR 5) THE NUMBER OF VIOLATIONS MUST
!                             BE LESS THAN   NVMX   .
!        IF (MSGTYP = 3 OR 6) VIOLATIONS ARE COUNTED ONLY IF THE
!                             THE FIRST ELEMENT IS NOT IN VIOLATION.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE ARGUMENTS NAME.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND.
!     INTEGER NVMX
!        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
!     REAL VECLB
!        THE VALUE THAT THE VECTOR IS BEING TESTED AGAINST.
!
      call iprint(iprt)
      call ehdr(nmsub, head)
!
      if (msgtyp.le.3) then
        write (iprt, 1000) (nmvar(i),i=1,6), veclb, nv
      else
        if (msgtyp.ge.7) then
          write (iprt, 1001) (nmvar(i),i=1,6), (nmmin(i),i=1,8), nv
        else
          write (iprt, 1002) (nmvar(i),i=1,6), (nmmin(i),i=1,8), nv
        end if
      end if
!
      go to (10, 20, 30, 40, 50, 60, 70), msgtyp
!
   10 write(iprt, 1010) (nmvar(i),i=1,6), veclb
      return
!
   20 write(iprt, 1020) (nmvar(i),i=1,3), veclb, nvmx
      return
!
   30 write(iprt, 1030) (nmvar(i),i=1,6), veclb, veclb
      return
!
   40 write(iprt, 1040) (nmvar(i),i=1,6), (nmmin(i),i=1,8)
      return
!
   50 write(iprt, 1050) (nmvar(i),i=1,6), (nmmin(i),i=1,8), nvmx
      return
!
  60 write(iprt, 1060) (nmvar(i),i=1,6), (nmmin(i),i=1,8),&
     &   (nmmin(i),i=1,8)
      return
!
   70 write(iprt, 1070) nvmn, (nmvar(i),i=1,6), (nmmin(i),i=1,8)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/&
    &   32h the number of values in vector , 6a1,&
     &   23h less than or equal to , 1pe14.7, 4h is , i6, '.')
1001 format (/&
    &   32h the number of values in vector , 6a1,&
     &  ' GREATER THAN ', 8a1, ' IS ', i2, '.')
1002 format (/&
    &   32h the number of values in vector , 6a1,&
     &   23h less than or equal to , 8a1, 4h is , i6, '.')
1010 format(&
    &   26h the values in the vector , 6a1,&
     &   26h must all be greater than , 1pe14.7, '.')
1020 format(&
    &   36h the number of values in the vector , 6a1,&
    &   23h less than or equal to , 1pe14.7/&
     &   19h must be less than , i5, '.')
1030 format(&
    &   37h since the first value of the vector , 6a1,&
    &   17h is greater than , 1pe14.7/&
     &   40h all of the values must be greater than , 1pe14.7, '.')
1040 format(&
    &   26h the values in the vector , 6a1,&
     &   26h must all be greater than , 8a1, '.')
1050 format(&
    &   36h the number of values in the vector , 6a1,&
    &   23h less than or equal to , 8a1/&
     &   19h must be less than , i5, '.')
1060 format(&
    &   37h since the first value of the vector , 6a1,&
    &   17h is greater than , 8a1/&
     &   40h all of the values must be greater than , 8a1, '.')
1070 format(/' THERE MUST BE AT LEAST ', i2, ' VALUES IN VECTOR ', 6a1/&
     &  ' GREATER THAN OR EQUAL TO ', 8a1, '.')
!
      end
!STPLS
      subroutine stpls(xm, n, m, ixm, mdl, par, npar, ldstak, stp)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE SUBROUTINE FOR SELECTING STEP SIZES
!     TO BE USED IN COMPUTING FORWARD DIFFERENCE QUOTIENT ESTIMATES
!     OF THE NUMERICAL DERIVATIVES FOR THE NONLINEAR LEAST SQUARES
!     ROUTINES (SHORT CALL).
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,ldstak,m,n,npar
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   par(*),stp(*),xm(*)
!
!  SUBROUTINE ARGUMENTS
       external mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   exmpt
     integer&
     &   iprt,lscale,neta,nprt
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   scale(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,STPDRV
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL EXMPT
!        THE PROPORTION OF OBSERVATIONS FOR WHICH THE COMPUTED
!        NUMERICAL DERIVATIVES WRT A GIVEN PARAMETER ARE EXCEPTED
!        FROM MEETING THE DERIVATIVE ACCEPTANCE CRITERIA.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LSCALE
!        THE LENGTH OF VECTOR SCALE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     REAL PAR(NPAR)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE
!        PARAMETERS ARE STORED.
!     REAL SCALE(1)
!        A DUMMY VECTOR USED TO DESIGNATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL STP(NPAR)
!        THE SELECTED STEP SIZES.
!     REAL XM(IXM,M)
!        THE INDEPENDENT VARIABLE ARRAY
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'S','T','P','L','S',' '/
!
!     SET UP DEFAULT VALUES
!
      exmpt = 0.1e0
      neta = 0
      scale(1) = 0.0e0
      lscale = 1
      nprt = 1
!
!     PASS CONTROL TO STEP SIZE SELECTION DRIVER
!
     call stpdrv(nmsub, xm, n, m, ixm, mdl, par, npar, ldstak, stp,&
     &   neta, exmpt, scale, lscale, nprt)
!
      if (ierr.ne.1) return
!
      call iprint(iprt)
      write (iprt,1000)
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL STPLS (XM, N, M, IXM, NLSMDL, PAR, NPAR, LDSTAK,',&
     &   ' STP)')
      end
!IPGOUT
      subroutine ipgout (xaxis, yaxis, isym, npts, lpcv, ispcer)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES THE INTEGRATED PERIODOGRAM PLOTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ispcer,lpcv,npts
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   xaxis(lpcv),yaxis(lpcv)
     integer&
     &   isym(lpcv)
!
!  LOCAL SCALARS
     integer&
     &   iprt
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,PPMN,VERSP
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IPRT
!        THE LOGICAL UNIT NUMBER FOR THE OUTPUT.
!     INTEGER ISPCER
!        AN ERROR INDICATOR FOR THE INTEGRATED PERIODOGRAM COMPUTATIONS.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     REAL XAXIS(LPCV), YAXIS(LPCV)
!        THE X, Y CO-ORDINATES FOR THE SPECTRAL PLOTS.
!
!
!     SET LOGICAL UNIT NUMBER FOR OUTPUT AND SET OUTPUT WIDTH.
!
      call iprint (iprt)
!
      call versp(.true.)
      write (iprt, 1000)
!
      if (ispcer .eq. 0) go to 5
!
      write (iprt, 1003)
      return
!
    5 continue
!
     call ppmn (yaxis,yaxis,xaxis,xaxis(1),npts,1,lpcv,1,isym,&
     &  lpcv, 0, -1, 0.0e0, 1.0e0, 0.0e0, 0.5e0, .false., 0)
      write(iprt, 1002)
      return
!
!     FORMAT STATEMENTS
!
1000 format(34h integrated sample periodogram (+)/&
     &   5x, 49h with 95 per cent test limits for white noise (.))
!1001 FORMAT(5H+FREQ/
!    1   7H PERIOD, 9X, 3HINF, 7X, 3H10., 4X, 2H5., 8X, 6H3.3333, 4X,
!    2   3H2.5, 4X, 2H2.)
1002 format(5h+freq/&
    &   7h period, 9x, 3hinf, 7x, 3h20., 7x, 3h10., 8x, 6h6.6667, 4x,&
    &   2h5., 8x, 2h4., 8x, 6h3.3333, 4x, 6h2.8571, 4x, 3h2.5, 7x,&
     &   6h2.2222, 4x, 2h2.)
1003 format (///42h the integrated periodogram of this series,&
    &   22h could not be computed/&
     &   44h because the variance of the series is zero.)
      end
!ERSEI
     subroutine ersei(nmsub, nmvar, val, valmn, valmx, msgtyp, head,&
     &   error, nmmin, nmmax)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THE ROUTINE CHECKS WHETHER THE VALUE   VAL   IS WITHIN THE
!     THE RANGE VALMN (EXCLUSIVE) TO VALMX (INCLUSIVE), AND PRINTS A
!     DIAGNOSTIC IF IT IS NOT.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   val,valmn,valmx
     integer&
     &   msgtyp
     logical&
     &   error,head
!
!  ARRAY ARGUMENTS
     character&
     &   nmmax(8)*1,nmmin(8)*1,nmsub(6)*1,nmvar(8)*1
!
!  LOCAL SCALARS
     integer&
     &   i,iprt
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
!        PRINTED, WHERE IF ERROR IS .TRUE. AND
!        MSGTYP = 1 THE INPUT VALUE WAS OUTSIDE THE RANGE DETERMINED
!                   FROM OTHER INPUT ARGUMENTS
!        MSGTYP = 2 THE INPUT VALUE WAS OUTSIDE THE RANGE IMPOSED BY
!                   STARPAC
!     CHARACTER*1 NMMAX(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MAXIMUM.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE ARGUMENTS NAME.
!     REAL VAL
!        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
!     REAL VALMN, VALMX
!        THE MINIMUM AND MAXIMUM OF THE RANGE WITHIN WHICH THE
!        ARGUMENT MUST LIE.
!
      error = .false.
!
     if (((valmn.lt.val) .and. (val.le.valmx)) .or.&
     &   (valmx.lt.valmn)) return
!
      error = .true.
      call iprint(iprt)
      call ehdr(nmsub, head)
!
      write (iprt, 1000) (nmvar(i),i=1,6), val
!
!     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE DETERMINED FROM
!     OTHER INPUT ARGUMENTS.
!
     if (msgtyp .eq. 1)&
    &   write (iprt, 1010) (nmvar(i),i=1,6), (nmmin(i),i=1,8),&
     &      (nmmax(i),i=1,8)
!
!     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE IMPOSED BY STARPAC
!
     if (msgtyp .eq. 2)&
     &   write (iprt, 1020) (nmvar(i),i=1,6), valmn, valmx
      return
!
!     FORMAT STATEMENTS
!
 1000 format (/20h the input value of , 6a1, 4h is , g15.8, '.')
1010 format(&
    &   27h the value of the argument , 6a1,&
    &   17h must lie between, 1x, 8a1, 12h (exclusive)/&
     &   5h and , 8a1, 13h (inclusive).)
1020 format(&
    &   27h the value of the argument , 6a1,&
    &   17h must lie between, 1x, g15.8, 12h (exclusive)/&
     &   5h and , g15.8, 13h (inclusive).)
!
      end
!XDCKLD
      subroutine xdckld(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     ROUTINE TO TEST DERIVATIVE CHECKING ROUTINES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  NOVEMBER 21, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer ldstak
!
!  SCALARS IN COMMON
      integer ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
      real(kind=wp) :: delta
      integer i,iprt,ixm,ldsmin,m,n,neta,npar,nprt,nrow,ntau,ntest
!
!  LOCAL ARRAYS
      real(kind=wp) :: par(10),scale(10),xm(200,2)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL DCKLS,DCKLS1,DCKLSC,DRV4A,IPRINT,LDSCMP,MDL4
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        *
!     EXTERNAL DRV4A
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        ANALYTIC DERIVATIVES (JACOBIAN MATRIX) OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .EQ. 1, ERRORS WERE DETECTED.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH OF THE ARRAY DSTAK ALLOWED.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     EXTERNAL MDL4
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NETA
!        THE NUMBER OF RELIABLE DIGITS IN THE MODEL.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE INDICATOR VARIABLE USED TO SPECIFY WHETHER OR NOT
!        PRINTED OUTPUT IS TO BE PROVIDED, WHERE IF THE VALUE OF
!        NPRT IS ZERO, NO PRINTED OUTPUT IS GIVEN.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICAL DERIVATIVES AND THE USER SUPPLIED DERIVATIVES.
!     INTEGER NTEST
!        THE NUMBER OF THE CURRENT TEST.
!     REAL PAR(10)
!        THE ARRAY IN WHICH THE CURRENT ESTIMATES OF THE UNKNOWN
!        PARAMETERS ARE STORED.
!     REAL SCALE(10)
!        A DUMMY ARRAY, INDICATING USE OF DEFAULT VALUES FOR
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL XM(200,2)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!
      call iprint(iprt)
!
!     SET PARAMETER VALUES
!
      call dckls1(n, m, ixm, par, npar, neta, ntau, nrow, scale, nprt)
     call ldscmp(5, 0, 2*npar+1, 0, 0, 0, 'S',&
     &            n*npar+npar+n, ldsmin)
!
      if (ldsmin.gt.ldstak) then
         write (iprt, 1020) ldsmin
         return
      end if
!
!     CREATE INDEPENDENT VARIABLE
!
      delta = 0.0625e0
      xm(1,1) = 0.0e0
      do 10 i=2,n
         xm(i,1) = xm(i-1,1) + delta
   10 continue
!
      ntest = 0
!
!
!
!     CHECK RESULTS FROM VALID CALLS
!
!     SIMPLE EXAMPLE
!
!     CHECK RESULT FOR CORRECTLY COMPUTED DERIVATIVE
!
      call dckls1(n, m, ixm, par, npar, neta, ntau, nrow, scale, nprt)
!
      ntest = ntest + 1
      write (iprt,1130) ntest
      write (iprt,1100)
      write (iprt,1040)
      write (iprt,1000)
      ierr = -1
      call dckls(xm, n, m, ixm, mdl4, drv4a, par, npar, ldsmin)
      write (iprt,1050) ierr
!
      ntest = ntest + 1
      write (iprt,1130) ntest
      write (iprt,1100)
      write (iprt,1040)
      write (iprt,1060) neta, ntau, scale(1), nrow, nprt
      write (iprt,1010)
      ierr = -1
     call dcklsc(xm, n, m, ixm, mdl4, drv4a, par, npar, ldsmin, neta,&
     &   ntau, scale, nrow, nprt)
      write (iprt,1050) ierr
      write (iprt,1140) neta, ntau, scale(1), nrow, nprt
!
!
      return
!
!     FORMAT STATEMENTS
!
!
 1000 format (15h test of dckls )
 1010 format (15h test of dcklsc)
 1020 format (45h1 *** ldstak must be greater than or equal to , i6)
 1040 format (15h simple example)
1050 format (29h ***** returned results *****, 5x, 15h (-1 indicates ,&
     &   39hvalue not changed by called subroutine)//9h ierr is , i3)
1060 format (19h input   -  neta = , i5, 9h, ntau = , i5,&
     &   13h, scale(1) = , g15.8, 9h, nrow = , i5, 9h, nprt = , i5)
 1100 format (27h correctly coded derivative)
 1130 format (43h1derivative checking subroutine test number, i5/)
1140 format (19h output  -  neta = , i5, 9h, ntau = , i5,&
     &   13h, scale(1) = , g15.8, 9h, nrow = , i5, 9h, nprt = , i5//)
      end
!SETROW
      subroutine setrow (nrow, xm, n, m, ixm, nrowu)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE SELECTS THE ROW USED BY THE DERIVATIVE CHECKING
!     PROCEDURE.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ixm,m,n,nrow,nrowu
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   xm(ixm,m)
!
!  LOCAL SCALARS
     integer&
     &   i,j
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER I
!        AN INDEX VARIABLE.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY XM.
!     INTEGER J
!        AN INDEX VARIABLE.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS OF DATA.
!     INTEGER NROW, NROWU
!        THE USER-SUPPLIED NUMBER OF THE ROW OF THE INDEPENDENT
!        VARIABLE ARRAY AT WHICH THE DERIVATIVE IS TO BE CHECKED,
!        AND THE NUMBER OF THE ROW ACTUALLY USED.
!     REAL XM(IXM,M)
!        THE INDEPENDENT VARIABLE MATRIX.
!
      nrowu = nrow
!
      if ((nrowu.ge.1) .and. (nrowu.le.n)) return
!
!     SELECT FIRST ROW OF INDEPENDENT VARIABLES WHICH CONTAINS NO ZEROS
!     IF THERE IS ONE, OTHERWISE FIRST ROW IS USED.
!
      do 20 i = 1, n
         do 10 j = 1, m
            if (xm(i,j) .eq. 0.0e0) go to 20
   10    continue
         nrowu = i
         return
   20 continue
!
      nrowu = 1
!
      return
      end
!BFSMV
     subroutine bfsmv(ccov, nlppc, index1, index2, n, lagmax, iccov,&
     &  jccov, inlppc, jnlppc)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES BIVARIATE
!     FOURIER SPECTRUM ANALYSIS OF SERIES WITH MISSING OBSERVATIONS
!     AND COVARIANCES INPUT RATHER THAN ORIGINAL SERIES
!     (SHORT CALL)
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iccov,index1,index2,inlppc,jccov,jnlppc,lagmax,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ccov(*)
     integer&
     &   nlppc(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   alpha,delta,fmax,fmin,ymiss1,ymiss2
     integer&
    &   icspc2,iphas,iprt,lagmx1,lagmxu,ldsmin,ldstak,lpcv,lw,ly,&
     &   m,nf,nprt,nw
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
    &   ceven(101),codd(101),cspc2(101,4),freq(101),phas(101,4),&
    &   spcf1(101),spcf2(101),w(101),xaxis(404),y1(1),y2(1),&
     &   yaxis(404)
     integer&
     &   isym(404),lags(4)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL BFSDRV,ECVF,IPRINT,PARZEN,SETLAG
!
!  INTRINSIC FUNCTIONS
      intrinsic min
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL CCOV(ICCOV,JCCOV,*)
!        THE COVARIANCES.
!     REAL CEVEN(101)
!        THE SUMS OF THE AUTOCOVARIANCES FOR EACH LAG.
!     REAL CODD(101)
!        THE DIFFERENCES OF THE AUTOCOVARIANCES FOR EACH LAG.
!     REAL CSPC2(101,4)
!        THE SQUARED COHERENCY COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE
!        SPECTRUM IS TO BE COMPUTED.
!     REAL FREQ(101)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER ICSPC2
!        THE FIRST DIMENSION OF THE ARRAY CSPC2.
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER INLPPC
!        THE FIRST DIMENSION OF THE ARRAY NLPPC.
!     INTEGER IPHAS
!        THE FIRST DIMENSION OF THE ARRAY PHAS.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISYM(404)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER JNLPPC
!        THE SECOND DIMENSION OF THE ARRAY NLPPC.
!     INTEGER LAGMAX, LAGMXU
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGMX1
!        LAGMAX+1.
!     INTEGER LAGS(4)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LY
!        THE LENGTH OF THE VECTORS Y1 AND Y2.
!     INTEGER M
!        THE NUMBER OF SERIES FOR WHICH THE COVARIANCES WERE
!        COMPUTED
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPC(INLPPC,JNLPPC,*)
!        THE NUMBER OF OBSERVATIONS IN EACH COVARIANCE ESTIMATE
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT.
!        IF NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        IF NPRT = 0 THE PLOT IS SUPPRESSED.
!        IF NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE ARGUMENT USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL PHAS(101,4)
!        THE PHASE COMPONENT OF THE BIVARIATE SPECTRA.
!     REAL SPCF1(101), SPCF2(101)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED.
!     REAL W(101)
!        THE WINDOWS.
!     REAL XAXIS(404)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YAXIS(404)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOTS.
!     REAL YMISS1, YMISS2
!        THE MISSING VALUE CODES
!     REAL Y1(1)
!        THE FIRST TIME SERIES.
!     REAL Y2(1)
!        THE SECOND TIME SERIES.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'B','F','S','M','V',' '/
!
!     SET UP FOR ERROR CHECKING
!
      option(1) = .false.
      option(2) = .true.
      option(3) = .true.
      option(4) = .false.
!
      m = 2
!
      icspc2 = 101
      iphas = 101
!
      ldstak = 0
      ldsmin = 0
!
      nf = 101
      lw = 101
      ly = n
      lpcv = 404
!
!     SET MAXIMUM LAG VALUE USED (LAGMXU)
!     SET NUMBER OF LAG WINDOW TRUCCATION POINTS (NW)
!
      call setlag(n, lagmxu)
      lagmxu = min(lagmxu,lagmax)
      nw = 4
!
!     CALL THE CONTROLING ROUTINE FOR THE BIVARIATE SPECTRUM ROUTINES
!
     call bfsdrv(y1, y2, ymiss1, ymiss2, ccov, nlppc, spcf1, spcf2,&
    &   nf, fmin, fmax, freq, n, nw, lagmxu, lags, lagmx1, w, lw,&
    &   delta, isym, xaxis, yaxis, lpcv, alpha, nprt, parzen, iccov,&
    &   jccov, m, index1, index2, cspc2, phas, icspc2, iphas, codd,&
    &   ceven, w, lw, nmsub, ldsmin, ldstak, option, n, inlppc,&
     &   jnlppc, ly)
!
      if (ierr.ne.0) then
        if (ierr.eq.2) call ecvf(nmsub)
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
!
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL BFSMV (CCOV, NLPPC, INDEX1, INDEX2, N, LAGMAX,'/&
     &   '      +            ICCOV, JCCOV, INLPPC, JNLPPC)')
      end
!NLSX2
     subroutine nlsx2(n, m, ixm, npar, ifixed, stp, idrvck, mit,&
     &   stopss, stopp, scale, delta, ivaprx, nprt, ivcv)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     SET UP PROBLEM SPECIFICATION FOR TESTING THE USER CALLABLE
!     ROUTINES IN THE NONLINEAR  LEAST SQUARES FAMILY.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,stopp,stopss
     integer&
     &   idrvck,ivaprx,ivcv,ixm,m,mit,n,npar,nprt
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   scale(10),stp(10)
     integer&
     &   ifixed(10)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   sqmeps
     integer&
     &   i
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
!        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
!     INTEGER IFIXED(10)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(I).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IVAPRX
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVAPRX LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVAPRX EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVAPRX EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVAPRX GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NPAR
!        THE NUMBER OF UNKNOWN PARAMETERS IN THE MODEL.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     REAL SCALE(10)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE UNKNOWN PARAMETERS.
!     REAL SQMEPS
!        THE SQUARE ROOT OF MACHINE PRECISION
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL STANDARD DEVIATION (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(10)
!        THE STEP SIZE ARRAY.
!
!
!     **SET UP FOR NORMAL STATEMENT**
!
      sqmeps = sqrt(rmdcon(3,typ=0.0_wp))
!
      n = 6
      m = 1
      ixm = 10
      npar = 2
      mit = 500
      do 10 i=1,10
         stp(i) = sqmeps
         scale(i) = 1.0e0
   10 continue
      ifixed(1) = -1
      idrvck = 0
      stopss = 10.0e-5
      stopp = 10.0e-5
      delta = 0.5e0
      nprt = 11111
      ivaprx = 3
      ivcv = 6
!
      return
!
      end
!NLCNTA
     subroutine nlcnta(y, wt, lwt, xm, n, m, ixm, mdl, drv, par, npar,&
    &   res, ldstak, ifixed, lifixd, idrvck, mit, stopss, stopp,&
    &   scale, lscale, delta, ivcvop, nprt, rsd, pv, lpv, sdpv, lsdpv,&
     &   sdres, lsdres, vcv, ivcv, nmsub, weight, save, nnzw, npare)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE CONTROLLING SUBROUTINE FOR NONLINEAR LEAST
!     SQUARES REGRESSION USING ANALYTIC (USER-SUPPLIED) DERIVATIVES.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  OCTOBER 3, 1983
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   delta,rsd,stopp,stopss
     integer&
    &   idrvck,ivcv,ivcvop,ixm,ldstak,lifixd,lpv,lscale,lsdpv,&
     &   lsdres,lwt,m,mit,n,nnzw,npar,npare,nprt
     logical&
     &   save,weight
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
    &   par(*),pv(*),res(*),scale(*),sdpv(*),sdres(*),vcv(*),wt(*),&
     &   xm(*),y(*)
     integer&
     &   ifixed(*)
     character&
     &   nmsub(6)*1
!
!  SUBROUTINE ARGUMENTS
       external drv,mdl
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   isubhd,ldsmin,lstp,ndigit,neta,nrow,ntau
     logical&
     &   aprxdv,hlfrpt,page,prtfxd,wide
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   stp(1)
     integer&
     &   iptout(5)
!
!  EXTERNAL FUNCTIONS
     integer&
     &   icnti
!       EXTERNAL ICNTI
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL DCKCNT,LDSCMP,NLCNT,NLDRVA,NLER,NLHDRA,PRTCNT,STKSET
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL APRXDV
!        THE VARIABLE USED TO INDICATE WHETHER NUMERICAL
!        APPROXIMATIONS TO THE DERIVATIVE WERE USED (TRUE) OR NOT
!        (FALSE).
!     REAL DELTA
!        THE MAXIMUM CHANGE ALLOWED IN THE MODEL PARAMETERS AT THE
!        FIRST ITERATION.
!     EXTERNAL DRV
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        DERIVATIVE (JACOBIAN) MATRIX OF THE MODEL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     LOGICAL HLFRPT
!        THE VARIABLE WHICH INDICATES WHETHER THE DERIVATIVE
!        CHECKING ROUTINE HAS ALREADY PRINTED PART OF THE
!        INITIAL SUMMARY (TRUE) OR NOT (FALSE).
!     INTEGER IDRVCK
!        THE VARIABLE USED TO INDICATE WHETHER THE DERIVATIVES ARE
!        TO BE CHECKED (IDRVCK = 1) OR NOT (IDRVCK = 0).
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST.
!        IF IERR .EQ. 0, NO ERRORS WERE DETECTED.
!        IF IERR .GE. 1, ERRORS WERE DETECTED.
!     INTEGER IFIXED(LIFIXD)
!        THE INDICATOR VALUES USED TO DESIGNATE WHETHER THE
!        PARAMETERS ARE TO BE OPTIMIZED OR ARE TO BE HELD FIXED.  IF
!        IFIXED(I).NE.0, THEN PAR(I) WILL BE OPTIMIZED.  IF
!        IFIXED(I).EQ.0, THEN PAR(I) WILL BE HELD FIXED.
!        IFIXED(1).LT.0, THEN ALL PAR(I),I=1,NPAR, WILL BE OPTIMIZED..
!     INTEGER IPTOUT(5)
!        THE VARIABLE USED TO CONTROL PRINTED OUTPUT FOR EACH SECTION.
!     INTEGER ISUBHD
!        AN INDICATOR VALUE SPECIFYING SUBHEADINGS TO BE PRINTED.
!     INTEGER IVCV
!        THE FIRST DIMENSION OF THE VARIANCE COVARIANCE MATRIX VCV.
!     INTEGER IVCVOP
!        AN INDICATOR VALUE USED TO DESIGNATE WHICH OPTION IS TO BE USED
!        TO COMPUTE THE VARIANCE COVARIANCE MATRIX (VCV), WHERE
!        IVCVOP LE 0 INDICATES THE THE DEFAULT OPTION WILL BE USED
!        IVCVOP EQ 1 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVCVOP EQ 2 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVCVOP EQ 3 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING BOTH THE MODEL SUBROUTINE THE USER SUPPLIED
!                    DERIVATIVE SUBROUTINE WHEN IT IS AVAILABLE
!        IVCVOP EQ 4 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)*TRANSPOSE(JACOBIAN)*JACOBIAN
!                          *INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVCVOP EQ 5 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(HESSIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVCVOP EQ 6 INDICATES THE VCV IS TO BE COMPUTED BY
!                       INVERSE(TRANSPOSE(JACOBIAN)*JACOBIAN)
!                    USING ONLY THE MODEL SUBROUTINE
!        IVCVOP GE 7 INDICATES THE DEFAULT OPTION WILL BE USED
!     INTEGER IXM
!        THE FIRST DIMENSION OF THE INDEPENDENT VARIABLE ARRAY.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR THE ARRAY DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE ARRAY DSTAK.
!     INTEGER LIFIXD
!        THE ACTUAL LENGTH OF THE VECTOR IFIXED.
!     INTEGER LPV
!        THE ACTUAL LENGTH OF THE VECTOR PV.
!     INTEGER LSCALE
!        THE ACTUAL LENGTH OF THE VECTOR SCALE.
!     INTEGER LSDPV
!        THE ACTUAL LENGTH OF THE VECTOR SDPV.
!     INTEGER LSDRES
!        THE ACTUAL LENGTH OF THE VECTOR SDRES.
!     INTEGER LSTP
!        THE ACTUAL LENGTH OF THE VECTOR STP.
!     INTEGER LWT
!        THE ACTUAL LENGTH OF THE VECTOR WT.
!     INTEGER M
!        THE NUMBER OF INDEPENDENT VARIABLES.
!     INTEGER MIT
!        THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!     EXTERNAL MDL
!        THE NAME OF THE USER SUPPLIED SUBROUTINE WHICH COMPUTES THE
!        PREDICTED VALUES BASED ON THE CURRENT PARAMETER ESTIMATE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NDIGIT
!        THE NUMBER OF DIGITS IN THE PRINT CONTROL VALUE.
!     INTEGER NETA
!        THE NUMBER OF ACCURATE DIGITS IN THE MODEL RESULTS.
!     EXTERNAL NLDRVA
!        THE NAME OF THE ROUTINE WHICH CALCULATES THE DERIVATIVES.
!     EXTERNAL NLHDRA
!        THE NAME OF THE ROUTINE WHICH PRODUCES THE HEADING.
!     CHARACTER*1 NMSUB(6)
!        THE NAME OF THE SUBROUTINE CALLING THE ERROR CHECKING
!        SUBROUTINES.
!     INTEGER NNZW
!        THE NUMBER OF NON ZERO WEIGHTS.
!     INTEGER NPAR
!        THE NUMBER OF PARAMETERS IN THE MODEL.
!     INTEGER NPARE
!        THE NUMBER OF PARAMETERS TO BE ESTIMATED.
!     INTEGER NPRT
!        THE PARAMETER USED TO INDICATE HOW MUCH PRINTED OUTPUT IS
!        TO BE PROVIDED.
!     INTEGER NROW
!        THE NUMBER OF THE ROW OF THE INDEPENDENT VARIABLE ARRAY AT
!        WHICH THE DERIVATIVE IS TO BE CHECKED.
!     INTEGER NTAU
!        THE NUMBER OF DIGITS OF AGREEMENT REQUIRED BETWEEN THE
!        NUMERICALLY APPROXIMATED DERIVATIVES AND THE USER SUPPLIED
!        DRVITIVES.
!     LOGICAL PAGE
!        THE VARIABLE USED TO INDICATE WHETHER A GIVEN SECTION OF
!        THE OUTPUT IS TO BEGIN ON A NEW PAGE (TRUE) OR NOT (FALSE).
!     REAL PAR(NPAR)
!        THE CURRENT ESTIMATES OF THE PARAMETERS.
!     LOGICAL PRTFXD
!        THE INDICATOR VALUE USED TO DESIGNATE WHETHER THE
!        OUTPUT IS TO INCLUDE INFORMATION ON WHETHER THE
!        PARAMETER IS FIXED (TRUE) OR NOT (FALSE).
!     REAL PV(LPV)
!        THE PREDICTED VALUE BASED ON THE CURRENT PARAMETER ESTIMATES
!     REAL RES(N)
!        THE RESIDUALS FROM THE FIT.
!     REAL RSD
!        THE VALUE OF THE RESIDUAL STANDARD DEVIATION AT THE SOLUTION.
!     LOGICAL SAVE
!        THE VARIABLE USED TO INDICATE WHETHER ANY RESULTS OTHER THAN
!        THE RESIDUALS AND PARAMETERS ARE TO BE SAVED (TRUE) OR NOT
!        (FALSE).
!     REAL SCALE(LSCALE)
!        A VALUE TO INDICATE USE OF THE DEFAULT VALUES OF
!        THE TYPICAL SIZE OF THE PARAMETERS.
!     REAL SDPV(LSDPV)
!        THE STANDARD DEVIATIONS OF THE PREDICTED VALUES.
!     REAL SDRES(LSDRES)
!        THE STANDARDIZED RESIDUALS.
!     REAL STOPP
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE MAXIMUM SCALED
!        RELATIVE CHANGE IN THE ELEMENTS OF THE MODEL PARAMETER VECTOR
!     REAL STOPSS
!        THE STOPPING CRITERION FOR THE TEST BASED ON THE RATIO OF THE
!        PREDICTED DECREASE IN THE RESIDUAL SUM OF SQUARES (COMPUTED
!        BY STARPAC) TO THE CURRENT RESIDUAL SUM OF SQUARES ESTIMATE.
!     REAL STP(1)
!        THE DUMMY STEP SIZE ARRAY.
!     REAL VCV(IVCV,NPAR)
!        THE VARIANCE-COVARIANCE MATRIX.
!     LOGICAL WEIGHT
!        THE VARIABLE USED TO INDICATE WHETHER WEIGHTED ANALYSIS IS TO
!        BE PERFORMED (TRUE) OR NOT (FALSE).
!     LOGICAL WIDE
!        THE VARIABLE USED TO INDICATE WHETHER THE HEADING SHOULD
!        BE FULL WIDTH (TRUE) OR NOT (FALSE).
!     REAL WT(LWT)
!        THE WEIGHTS.
!     REAL XM(IXM,M)
!        THE ARRAY IN WHICH ONE ROW OF THE INDEPENDENT VARIABLE ARRAY
!        IS STORED.
!     REAL Y(N)
!        THE ARRAY OF THE DEPENDENT VARIABLE.
!
!     SET VARIOUS PROGRAM VALUES
!
      hlfrpt = .false.
      aprxdv = .false.
      prtfxd = .true.
      stp(1) = 0.0e0
      lstp = 1
      neta = 0
      ntau = 0
      nrow = 0
!
      wide = .true.
      page = .false.
!
      ndigit = 5
!
!     SET UP FOR ERROR CHECKING
!
      ierr = 0
      if ((ifixed(1).ge.0) .and. (npar.ge.1)) then
         npare = icnti(ifixed,npar,0)
      else
         npare = npar
      end if
!
     call ldscmp(6, 0, 60+2*npar, 0, 0, 0, 'S',&
     &            94+n*(3+npar)+npare*(3*npare+35)/2, ldsmin)
!
     call nler (nmsub, weight, wt, lwt, n, m, ixm,&
    &   ifixed, lifixd, npar, npare,&
     &   ldstak, ldsmin, stp, lstp, scale, lscale, ivcv, save, nnzw)
!
      if (ierr.ne.0) return
!
      call stkset(ldstak, 4)
!
!     SET PRINT CONTROL VALUES
!
      call prtcnt(nprt, ndigit, iptout)
!
      if (idrvck.eq.0) go to 10
!
!     CHECK DERIVATIVES, IF DESIRED
!
      isubhd = 1
     call dckcnt(xm, n, m, ixm, mdl, drv, par, npar, neta, ntau,&
    &   scale, lscale, nrow, iptout(1), nlhdra, page, wide, isubhd,&
     &   hlfrpt, prtfxd, ifixed, lifixd)
!
!     CHECK FOR DEFINITE ERROR IN DERIVATIVES
!
      if (ierr.le.2) go to 10
      ierr = 1
      return
!
   10 continue
!
      ierr = 0
!
     call nlcnt(y, wt, lwt, xm, n, m, ixm, mdl, nldrva, aprxdv, drv,&
    &   par, npar, res, ifixed, lifixd, stp, lstp, mit, stopss, stopp,&
    &   scale, lscale, delta, ivcvop, rsd, pv, lpv, sdpv, lsdpv,&
    &   sdres, lsdres, vcv, ivcv, weight, save, nnzw, npare, nlhdra,&
     &   page, wide, iptout, ndigit, hlfrpt)
!
      return
!
      end
!XXCH6
      subroutine xxch6(ldstak,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBPROGRAM PROVIDES A SIMPLE TEST OF
!     THE ONEWAY ANALYSIS OF VARIANCE FAMILY OF ROUTINES.
!
!     DATA SET IS FROM PAGES 314-316 OF BRWONLEE [1965].
!
!     WRITTEN BY  -  JOHN E. KOONTZ, JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  AUGUST 3, 1987
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ldstak
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
     integer&
     &   iprt,n
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   tag(20),y(20)
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL AOV1,IPRINT
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER IERR
!        ERROR FLAG
!     INTEGER IPRT
!        LOGICAL OUTPUT UNIT.
!     INTEGER LDSTAK
!        THE LENGTH OF DSTAK IN COMMON /CSTAK/.
!     INTEGER N
!        THE LENGTH OF THE VECTOR Y.
!     REAL TAG(20)
!        THE TAG VALUES FOR EACH OBSERVATION
!     REAL Y(20)
!        DATA VECTOR FOR TESTS.
!
!
!     DATA INITIALIZATIONS.
!
      data n /16/
!
     data y( 1), y( 2), y( 3), y( 4)&
     &    / 83.0, 81.0, 76.0, 78.0/
     data y( 5), y( 6), y( 7), y( 8)&
     &    / 79.0, 72.0, 61.0, 61.0/
     data y( 9), y(10), y(11), y(12)&
     &    / 67.0, 67.0, 64.0, 78.0/
     data y(13), y(14), y(15), y(16)&
     &    / 71.0, 75.0, 72.0, 74.0/
!
     data tag( 1), tag( 2), tag( 3), tag( 4)&
     &    / 1.0, 1.0, 1.0, 1.0/
     data tag( 5), tag( 6), tag( 7), tag( 8)&
     &    / 1.0, 1.0, 2.0, 2.0/
     data tag( 9), tag(10), tag(11), tag(12)&
     &    / 2.0, 2.0, 2.0, 3.0/
     data tag(13), tag(14), tag(15), tag(16)&
     &    / 3.0, 3.0, 3.0, 3.0/
!
!     DEFINE IPRT, THE CURRENT OUTPUT UNIT.
!
      call iprint(iprt)
!
!     PRINT HEADING
!
      write (iprt,1000)
!
!     PERFORM SIMPLE TEST OF AOV1
!
      write (iprt,1100)
      call aov1(y, tag, n, ldstak)
      write (iprt,2000) ierr
!
      return
!
!     FORMATS
!
 1000 format ('1*CH6')
 1100 format (' SIMPLE TEST OF AOV1')
 2000 format (/' THE VALUE OF IERR IS ', i4)
      end
!UFSFS
     subroutine ufsfs(yfft, n, lyfft, ldstak, nw, lags, nf, fmin, fmax,&
     &   nprt, spcf, ispcf, freq)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE FOR TIME SERIES FOURIER
!     SPECTRUM ANALYSIS USING THE FFT (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   fmax,fmin
     integer&
     &   ispcf,ldstak,lyfft,n,nf,nprt,nw
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(*),spcf(*),yfft(*)
     integer&
     &   lags(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  ARRAYS IN COMMON
      double precision dstak(12)
!
!  LOCAL SCALARS
      real(kind=wp) :: alpha,delta,ymiss
     integer&
    &   acov,i,ifp,io,iprt,isort,isym,lacov,lagmax,ldsmin,lnlppa,&
     &   lpcv,lwork,nall0,nfft,work,xaxis,yaxis
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   rstak(12)
     integer&
     &   istak(12),nlppa(1)
     logical&
     &   option(4)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL FUNCTIONS
!      INTEGER
!     +   STKST
!      EXTERNAL STKST
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LDSCMP,PARZEN,SETESL,STKCLR,STKSET,UFSDRV
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  COMMON BLOCKS
      common /cstak/dstak
      common /errchk/ierr
!
!  EQUIVALENCES
      equivalence (dstak(1),rstak(1))
      equivalence (dstak(1),istak(1))
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER ACOV
!        THE STARTING LOCATION IN RSTAK FOR THE ACVF VECTOR.
!     REAL ALPHA
!        THE DESIRED CONFIDENCE LEVEL.
!     REAL DELTA
!        THE SAMPLING INTERVAL.
!     DOUBLE PRECISION DSTAK(12)
!        THE DOUBLE PRECISION VERSION OF THE /CSTAK/ WORK AREA.
!     REAL FMAX, FMIN
!        THE MAXIMUM AND MINIMUM FREQUENCY AT WHICH THE SPECTRUM
!        IS TO BE COMPUTED.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        COMPUTED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER IERR
!        THE INTEGER VALUE RETURNED BY THIS ROUTINE DESIGNATING
!        WHETHER ANY ERRORS WERE DETECTED IN THE PARAMETER LIST
!        IF ERR01, NO ERRORS WERE DETECTED
!        IF IERR .EQ. 1, ERRORS HAVE BEEN DETECTED
!     INTEGER IFP
!        AN INDICATOR FOR STACK ALLOCATION TYPE, WHERE IFP=3 INDICATES
!        REAL AND IFP=4 INDICATES DOUBLE PRECISION.
!     INTEGER IO
!        A VARIABLE USED TO DETERMINE THE AMOUNT OF STORAGE REQUIRED
!        BASED ON PRINTED OUTPUT REQUESTED.
!     INTEGER IPRT
!        THE LOGICAL UNIT USED FOR PRINTED OUTPUT.
!     INTEGER ISORT
!        THE STARTING LOCATION FOR THE ARRAY USED FOR SORTING.
!     INTEGER ISPCF
!         THE ACTUAL FIRST DIMENSION OF THE SPECTRUM ARRAYS.
!     INTEGER ISTAK(12)
!        THE INTEGER VERSION OF THE /CSTAK/ WORK AREA.
!     INTEGER ISYM
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY ISYM.
!     INTEGER LACOV
!        THE LENGTH OF VECTOR ACOV.
!     INTEGER LAGMAX
!        THE MAXIMUM LAG VALUE TO BE USED.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO SPECIFY THE LAG WINDOW TRUNCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER LDSMIN
!        THE MINIMUM LENGTH ALLOWED FOR DSTAK.
!     INTEGER LDSTAK
!        THE LENGTH OF THE VECTOR DSTAK IN COMMON CSTAK.
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LPCV
!        THE LENGTH OF THE VECTORS USED FOR PLOTTING.
!     INTEGER LWORK
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LYFFT
!        THE LENGTH OF THE VECTOR Y.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NALL0
!        THE NUMBER OF ALLOCATIONS OUTSTANDING AT THE TIME THAT
!        THIS ROUTINE WAS CALLED.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES AT WHICH THE SPECTRUM IS
!        TO BE COMPUTED.
!     INTEGER NLPPA(1)
!        A DUMMY ARRAY FOR SERIES WITHOUT MISSING VALUES.
!     CHARACTER*1 NMSUB(6)
!        THE ARRAY CONTAINING THE NAME OF THIS SUBROUTINE.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NW
!        THE VARIABLE USED TO DETERMINE THE NUMBER OF DIFFERENT
!        BANDWIDTHS TO BE USED.
!     LOGICAL OPTION(4)
!        AN INDICATOR ARRAY USED TO DESIGNATE WHETHER ANY OF THE
!        FOUR POSSIBLE OPTIONS (F, M, V, OR S) HAVE BEEN USED (TRUE)
!        OR NOT (FALSE).
!     EXTERNAL PARZEN
!        THE SUBROUTINE USED TO COMPUTE THE WINDOW.
!     REAL RSTAK(12)
!        THE REAL VERSION OF THE /CSTAK/ WORK AREA.
!     REAL SPCF(ISPCF,NW)
!        THE ARRAYS IN WHICH THE SPECTRUM IS STORED
!        FOR EACH LAG WINDOW.
!     INTEGER WORK
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY WORK.
!     INTEGER XAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY XAXIS.
!     REAL YFFT(LYFFT)
!        THE ARRAY CONTAINING THE OBSERVED TIME SERIES.
!     INTEGER YAXIS
!        THE STARTING LOCATION IN THE WORK AREA FOR ARRAY YAXIS.
!     REAL YMISS
!        THE MISSING VALUE CODE FOR THE SERIES.
!
!     SET UP NAME ARRAYS
!
     data nmsub(1), nmsub(2), nmsub(3), nmsub(4), nmsub(5), nmsub(6) /&
     &   'U','F','S','F','S',' '/
!
!     SET UP
!
      option(4) = .true.
      option(3) = .false.
      option(2) = .false.
      option(1) = .true.
!
!     SET MAXIMUM LAG VALUE TO BE USED.
!
      lagmax = n - 1
      if (nw.le.0) go to 20
      lagmax = lags(1)
      do 10 i=1,nw
         lagmax = max(lagmax,lags(i))
   10 continue
   20 continue
      lacov = lagmax + 1
      lnlppa = 1
!
!     SET EXTENDED SERIES LENGTH
!
      call setesl(n+lagmax, 4, nfft)
!
!     COMPUTE MINIMUM ALLOWABLE STACK LENGTH
!
      io = 1
      if (nprt.eq.0) io = 0
!
     call ldscmp(5, 0, io*(nf+5), 0, 0, 0, 'S',&
     &   lagmax+1+nfft+io*(2*nf+10), ldsmin)
!
      lpcv = nf + 5
      lwork = nfft
!
!     SET SIZE OF WORK AREA.
!     SET THE NUMBER OF OUTSTANDING ALLOCATIONS.
!     SET THE STACK ALLOCATION TYPE.
!
      call stkset(ldstak, 4)
      nall0 = stkst(1)
!
      ifp = 3
!
!     SET STARTING LOCATIONS IN THE WORK AREA FOR VARIOUS ARRAYS.
!
      if ((ldsmin.gt.ldstak) .or. (ldsmin.le.6)) then
         acov = 1
         work = 1
         xaxis = 1
         yaxis = 1
         isym = 1
         isort = 1
      else
         acov = stkget(lacov,ifp)
         work = stkget(lwork,ifp)
         if (nprt.ne.0) then
            xaxis = stkget(lpcv,ifp)
            yaxis = stkget(lpcv,ifp)
            isym = stkget(lpcv,2)
            isort = isym
         else
            xaxis = work
            yaxis = work
            isym = work
            isort = isym
         end if
      end if
!
!     CALL THE CONTROLLING ROUTINE FOR FOURIER SPECTRUM ROUTINES
!
     call ufsdrv(yfft, lyfft, ymiss, rstak(acov), nlppa, spcf, ispcf,&
    &   nf, fmin, fmax, freq, n, nw, lagmax, lags, rstak(work), lacov,&
    &   lwork, delta, istak(isort), istak(isym), rstak(xaxis),&
    &   rstak(yaxis), lpcv, alpha, nprt, parzen, nmsub, ldsmin, ldstak,&
     &   option, lnlppa, nfft)
!
      call stkclr(nall0)
!
!     CHECK FOR ERRORS
!
      if (ierr.eq.0) return
!
      call iprint(iprt)
      write (iprt,1000)
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &   '       CALL UFSFS (YFFT, N, LYFFT, LDSTAK,'/&
    &   '      +            NW, LAGS, NF, FMIN, FMAX, NPRT,'/&
     &   '      +            SPCF, ISPCF, FREQ)')
      end
!UASORD
     subroutine uasord (spcf, spca, spcfmn, spcfmx, spcamn, spcamx,&
    &   freq, nf, xaxis, yaxis, isym, npts, ispc, lpcv, nspcf, nspca,&
     &   bw, alow, aup, xpltmn, xpltmx, ypltmn, ypltmx, nprt)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRODUCES CO-ORDINATES FOR THE SPECTRUM PLOTS.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
    &   alow,aup,bw,spcamn,spcamx,spcfmn,spcfmx,xpltmn,xpltmx,ypltmn,&
     &   ypltmx
     integer&
     &   ispc,lpcv,nf,nprt,npts,nspca,nspcf
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   freq(nf),spca(ispc),spcf(ispc),xaxis(lpcv),yaxis(lpcv)
     integer&
     &   isym(lpcv)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   cilow,cimid,ciup,ymax
     integer&
     &   i,ispca,ispcf
!
!  EXTERNAL SUBROUTINES
!       EXTERNAL SPPLTC,SPPLTD,SPPLTL
!
!  INTRINSIC FUNCTIONS
      intrinsic log10,max,min
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL ALOW
!        THE FACTOR USED TO COMPUTE THE LOWER CONFIDENCE LIMITS.
!     REAL AUP
!        THE FACTOR USED TO COMPUTE THE UPPER CONFIDENCE LIMITS.
!     REAL BW
!        THE BANDWIDTH.
!     REAL CILOW, CIMID, CIUP
!        THE Y AXIS VALUES FOR THE LOWER, MID AND UPPER CONFIDENCE
!        INTERVAL POINTS.
!     REAL FREQ(NF)
!        THE VECTOR OF FREQUENCIES AT WHICH THE SPECTRUM IS TO BE
!        ESTIMATED.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER ISPC
!         THE LENGTH OF THE SPECTRUM ARRAYS.
!     INTEGER ISPCA, ISPCF
!        THE INDEX FOR THE FOURIER AND AUTOREGRESSIVE  ESTIMATES,
!        RESPECTIVELY.
!     INTEGER ISYM(LPCV)
!        THE ARRAY CONTAINING THE CODE FOR THE PLOT SYMBOLS.
!     INTEGER LPCV
!        THE LENGTH OF THE PLOT CO-ORDINATE VECTORS.
!     INTEGER NF
!        THE NUMBER OF FREQUENCIES FOR WHICH THE SPECTRUM ESTIMATES
!        ARE TO BE ESTIMATED.
!     INTEGER NPRT
!        A CODE USED TO SPECIFY THE TYPE OF PLOT, WHERE IF
!        NPRT < 0 THE PLOT IS DECIBLES/LINEAR
!        NPRT = 0 THE PLOT IS SUPPRESSED
!        NPRT > 0 THE PLOT IS LOG/LINEAR
!     INTEGER NPTS
!        THE NUMBER OF X, Y CO-ORDINATES TO BE PLOTTED.
!     INTEGER NSPCA, NSPCF
!        THE NUMBER OF VALID SPECTRUM ESTIMATES FOR THE AUTOREGRESSIVE
!        AND FOURIER SPECTRUMS, RESPECTIVELY.
!     REAL SPCA(ISPC)
!        THE ARAY CONTAINING THE AUTOREGRESSIVE SPECTRUM ESTIMATES.
!     REAL SPCAMN, SPCAMX
!        THE MINIMUM AND MAXIMUM AUTOREGRESSIVE SPECTRUM VALUE TO BE
!        PLOTTED.
!     REAL SPCF(ISPC)
!        THE ARRAY CONTAINING THE FOURIER SPECTRUM ESTIMATES.
!     REAL SPCFMN, SPCFMX
!        THE MINIMUM AND MAXIMUM FOURIER SPECTRUM VALUE TO BE PLOTTED.
!     REAL XAXIS(LPCV)
!        THE X AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL XPLTMN, XPLTMX
!        THE MINIMUM AND MAXIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!     REAL YAXIS(LPCV)
!        THE Y AXIS VALUES FOR THE SPECTRUM PLOT.
!     REAL YMAX
!        THE MAXIMUM  ACTUAL SPECTRUM VALUE (IN DECIBLES) TO BE PLOTTED.
!     REAL YPLTMN, YPLTMX
!        THE MINIMUM AND MAYIMUM VALUES TO BE PLOTTED FOR THE X AXIS.
!
      ispcf = 0
      ispca = nspcf
!
      if (nprt.ge.1) go to 30
!
!     SET VARIOUS Y AXIS VALUES FOR DECIBLE PLOTS
!
     call sppltd (min(spcfmn, spcamn), max(spcfmx, spcamx),&
     &   alow, aup, ypltmn, ypltmx, cilow, cimid, ciup, ymax)
!
!     SET CO-ORDINATES FOR DECIBLE PLOTS
!
      do 20 i = 1, nf
         if (spcf(i) .lt. spcfmn) go to 10
         ispcf = ispcf + 1
         xaxis(ispcf) = freq(i)
         yaxis(ispcf) = 10.0e0 * log10(spcf(i)) - ymax
         isym(ispcf) = 1
!
   10    if (spca(i) .lt. spcamn) go to 20
         ispca = ispca + 1
         xaxis(ispca) = freq(i)
         yaxis(ispca) = 10.0e0 * log10(spca(i)) - ymax
         isym(ispca) = 2
   20 continue
!
      go to 70
   30 continue
!
!     SET VARIOUS Y AXIS VALUES FOR LOG PLOTS
!
     call sppltl (min(spcfmn, spcamn), max(spcfmx, spcamx),&
     &   alow, aup, ypltmn, ypltmx, cilow, cimid, ciup)
!
!     SET CO-ORDINATES FOR LOG PLOTS
!
      do 60 i = 1, nf
         if (spcf(i) .lt. spcfmn) go to 50
         ispcf = ispcf + 1
         xaxis(ispcf) = freq(i)
         yaxis(ispcf) = spcf(i)
         isym(ispcf) = 1
!
   50    if (spca(i) .lt. spcamn) go to 60
         ispca = ispca + 1
         xaxis(ispca) = freq(i)
         yaxis(ispca) = spca(i)
         isym(ispca) = 2
   60 continue
!
   70 continue
!
      npts = nspca + nspcf
!
!     SET CO-ORDINATES FOR BANDWIDTH AND CONFIDENCE INTERVAL.
!
     call sppltc (xaxis, yaxis, isym, npts, xpltmn, xpltmx, bw, cilow,&
     &   cimid, ciup, lpcv)
!
      return
      end
!ERSIE
     subroutine ersie(nmsub, nmvar, val, valmn, valmx, msgtyp, head,&
     &   error, nmmin, nmmax)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THE ROUTINE CHECKS WHETHER THE VALUE   VAL   IS WITHIN THE
!     THE RANGE VALMN (INCLUSIVE) TO VALMX (EXCLUSIVE), AND PRINTS A
!     DIAGNOSTIC IF IT IS NOT.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   val,valmn,valmx
     integer&
     &   msgtyp
     logical&
     &   error,head
!
!  ARRAY ARGUMENTS
     character&
     &   nmmax(8)*1,nmmin(8)*1,nmsub(6)*1,nmvar(8)*1
!
!  LOCAL SCALARS
     integer&
     &   i,iprt
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL ERROR
!        VALUE(S) INDICATING WHETHER AN ERROR WAS DETECTED (TRUE) OR NOT
!        (FALSE).
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        AN ARGUMENT USED TO INDICATE THE TYPE OF MESSAGE TO BE
!        PRINTED, WHERE IF ERROR IS .TRUE. AND
!        MSGTYP = 1 THE INPUT VALUE WAS OUTSIDE THE RANGE DETERMINED
!                   FROM OTHER INPUT ARGUMENTS
!        MSGTYP = 2 THE INPUT VALUE WAS OUTSIDE THE RANGE IMPOSED BY
!                   STARPAC
!     CHARACTER*1 NMMAX(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MAXIMUM.
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING SUBROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE ARGUMENTS NAME.
!     REAL VAL
!        THE INPUT VALUE OF THE ARGUMENT BEING CHECKED.
!     REAL VALMN, VALMX
!        THE MINIMUM AND MAXIMUM OF THE RANGE WITHIN WHICH THE
!        ARGUMENT MUST LIE.
!
      error = .false.
!
     if (((valmn.le.val) .and. (val.lt.valmx)) .or.&
     &   (valmx.lt.valmn)) return
!
      error = .true.
      call iprint(iprt)
      call ehdr(nmsub, head)
!
      write (iprt, 1000) (nmvar(i),i=1,6), val
!
!     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE DETERMINED FROM
!     OTHER INPUT ARGUMENTS.
!
     if (msgtyp .eq. 1)&
    &   write (iprt, 1010) (nmvar(i),i=1,6), (nmmin(i),i=1,8),&
     &      (nmmax(i),i=1,8)
!
!     PRINT MESSAGE FOR VALUE OUTSIDE OF RANGE IMPOSED BY STARPAC
!
     if (msgtyp .eq. 2)&
     &   write (iprt, 1020) (nmvar(i),i=1,6), valmn, valmx
      return
!
!     FORMAT STATEMENTS
!
 1000 format (/20h the input value of , 6a1, 4h is , g15.8, '.')
1010 format(&
    &   27h the value of the argument , 6a1,&
    &   17h must lie between, 1x, 8a1, 12h (inclusive)/&
     &   5h and , 8a1, 13h (exclusive).)
1020 format(&
    &   27h the value of the argument , 6a1,&
    &   17h must lie between, 1x, g15.8, 12h (inclusive)/&
     &   5h and , g15.8, 13h (exclusive).)
!
      end
!DFBWM
      subroutine dfbwm (n, lag, w, lw, nlppa1, nlppa2, lnlppa, df, bw)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES AND STORES THE ASSOCIATED DEGREES OF
!     FREEDOM AND BANDWIDTH FOR A GIVEN LAG WINDOW WHEN MISSING DATA ARE
!     INVOLVED.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 7, 1981
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   bw,df
     integer&
     &   lag,lnlppa,lw,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   w(lw)
     integer&
     &   nlppa1(lnlppa),nlppa2(lnlppa)
!
!  LOCAL SCALARS
     integer&
     &   k
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL BW
!        THE BANDWIDTH.
!     REAL DF
!        THE EFFECTIVE DEGREES OF FREEDOM.
!     INTEGER K
!        AN INDEX VARIABLE
!     INTEGER LNLPPA
!        THE LENGTH OF THE VECTOR NLPPA.
!     INTEGER LW
!        THE LENGTH OF THE VECTOR W.
!     INTEGER LAG
!        THE LAG WINDOW TRUNCATION POINT USED FOR A SPECIFIC WINDOW.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS IN THE SERIES.
!     INTEGER NLPPA1(LNLPPA), NLPPA2(LNLPPA)
!        THE NUMBER OF LAGGED PRODUCT PAIRS USED FOR EACH ACVF
!        ESTIMATE.
!     REAL W(LW)
!        THE VECTOR OF LAG WINDOWS.
!
      bw = (w(1)*n)**2/nlppa1(1)
      do 10 k = 1, lag
        bw = bw + (w(k+1)*(n-k))**2 *&
     &      (1.0_wp/nlppa1(k+1) + 1.0_wp/nlppa2(k+1))
   10 continue
!
!
      bw = n / bw
      df = 2.0_wp * bw * n
      return
      end
!VPL
      subroutine vpl(ym, n, ns, ilog)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT (LOG PLOT OPTION).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ilog,n,ns
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ym(*)
!
!  SCALARS IN COMMON
     integer&
     &   ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xinc,xlb,ylb,yub
     integer&
     &   ibar,iprt,irlin,ischck,isize,iym,lisym,m
     logical&
     &   miss,multi
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   ymmiss(1)
     integer&
     &   isym(1)
     character&
     &   nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  ' ',       'V',       'P',       'L',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      ymmiss(1) = 1.0e0
      m = 1
      iym = n
      multi = .false.
      ylb = 0.0e0
      yub = 0.0e0
      xlb = 1.0e0
      xinc = 1.0e0
      ischck = 0
      isize = -1
      miss = .false.
      lisym = 1
      irlin = -1
      ibar = 0
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ymmiss, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
     &   '       CALL VPL (Y, N, NS, ILOG)')
      end
!BFSLAG
     subroutine bfslag(ccov, lagmax, lags, n, nw, nwused, iccov,&
     &   jccov, index1, index2)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE COMPUTES THE LAG WINDOW TRUNCATION POINTS FOR
!     FOURIER BIVARIATE SPECTRUM ANALYSIS.
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  DECEMBER 2, 1985
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   iccov,index1,index2,jccov,lagmax,n,nw,nwused
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   ccov(iccov,jccov,*)
     integer&
     &   lags(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   covmx,covmxi,fac11,fac12,fac21,fac22,p95lim
     integer&
     &   i,j,k,lag,nwm1
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max,real,sqrt
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL CCOV(ICCOV,JCCOV,*)
!        THE COVARIANCES.
!     REAL COVMX
!        THE MAXIMUM COVARIANCE VALUE.
!     REAL COVMXI
!        THE MAXIMUM COVARIANCE VALUE FOR THE ITH LAG.
!     REAL FAC11, FAC12, FAC21, FAC22
!        FACTORS USED TO COMPUTE THE CORRELATION COEFFICIENTS.
!     INTEGER I
!        AN INDEX VARIABLE
!     INTEGER ICCOV
!        THE FIRST DIMENSION OF THE ARRAY CCOV.
!     INTEGER INDEX1, INDEX2
!        THE INDICES OF THE COVARIANCES OF THE TWO SERIES.
!     INTEGER J
!        AN INDEX VALUE.
!     INTEGER JCCOV
!        THE SECOND DIMENSION OF THE ARRAY CCOV.
!     INTEGER K
!        AN INDEX VALUE.
!     INTEGER LAG, LAGMAX
!        THE INDEXING VARIABLE INDICATING THE LAG VALUE OF THE
!        BIVARIATE COVARIANCE BEING COMPUTED AND THE MAXIMUM LAG
!        TO BE USED, RESPECTIVELY.
!     INTEGER LAGS(NW)
!        THE ARRAY USED TO STORE THE LAG WINDOW TRUCCATION
!        POINTS USED FOR EACH SET OF SPECTRUM VALUES.
!     INTEGER N
!        THE INTEGER NUMBER OF OBSERVATIONS IN EACH SERIES
!     INTEGER NW
!        THE NUMBER OF DIFFERENT BANDWIDTHS REQUESTED.
!     INTEGER NWM1, NWUSED
!        THE NUMBER OF DIFFERENT BANDWIDTHS MINUS 1, AND THE
!        ACTUAL NUMBER OF BANDWIDTHS ACTUALLY USED.
!     REAL P95LIM
!        THE 95 PERCENT CONFIDENT LIMIT FOR WHITE NOISE.
!
      lags(nw) = lagmax
      if (lags(nw).le.32) go to 30
!
!     COMPUTE 95 PERCENT CONFIDENCE LIMITS ON BIVARIATECOVARIANCES,
!     ASSUMING WHITE NOISE.
!
      p95lim = 1.96e0/sqrt(real(n))
!
      fac11 = ccov(1,index1,index1)
      fac12 = sqrt(ccov(1,index1,index1)*ccov(1,index2,index2))
      fac21 = fac12
      fac22 = ccov(1,index2,index2)
!
!     CHECK FOR FIRST CVF EXCEEDING 95 PERCENT LIMIT ON WHITE NOISE
!
      do 10 i=1,lagmax
         lag = lagmax + 1 - i
        covmxi = max(abs(ccov(lag,index1,index1)*fac11),abs(ccov(lag,&
    &      index1,index2)*fac12),abs(ccov(lag,index2,index1)*fac21),&
     &      abs(ccov(lag,index2,index2)*fac22))
         if (covmxi.ge.p95lim) go to 30
         lags(nw) = lags(nw) - 1
   10 continue
!
!     IF NO ACVF EXCEEDS WHITE NOISE LIMITS, CHECK FOR LARGEST ACVF.
!
      lags(nw) = 1
      covmx = abs(ccov(2,1,1)*fac11)
      do 20 lag=1,lagmax
        covmxi = max(abs(ccov(lag,index1,index1)*fac11),abs(ccov(lag,&
    &      index1,index2)*fac12),abs(ccov(lag,index2,index1)*fac21),&
     &      abs(ccov(lag,index2,index2)*fac22))
         if (covmxi.le.covmx) go to 20
         lags(nw) = lag
         covmx = covmxi
   20 continue
!
!     COMPUTE LAG WINDOW TRUNCATION POINTS
!
   30 lags(nw) = lags(nw)*3.0e0/2.0e0
      if (lags(nw).lt.32) lags(nw) = 32
      if (lags(nw).gt.lagmax) lags(nw) = lagmax
      nwused = nw
      if (nw.eq.1) return
      nwm1 = nw - 1
      do 40 i=1,nwm1
         k = nw - i
         lags(k) = lags(k+1)/2
   40 continue
!
!     CHECK WHETHER ALL NW LAG WINDOW TRUNCATION POINTS CAN BE USED.
!
      nwused = nw
      if (lags(1).ge.4) return
!
!     RECONSTURCT -LAGS- VECTOR IF NOT ALL TRUNCATION POINTS ARE
!     TO BE USED
!
      do 50 i=2,nw
         nwused = nwused - 1
         if (lags(i).ge.4) go to 60
   50 continue
!
   60 do 70 i=1,nwused
         j = nw - nwused + i
         lags(i) = lags(j)
   70 continue
!
      return
      end
!ERAGTP
     subroutine eragtp (nmsub, nmvar, ymmn, nvmx, head, msgtyp, nv,&
     &   nmmin)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS ROUTINE PRINTS THE ERROR MESSAGES FOR ERAGT AND ERAGTM.
!
!     WRITTEN BY  -  JANET R. DONALDSON
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JUNE 10, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   ymmn
     integer&
     &   msgtyp,nv,nvmx
     logical&
     &   head
!
!  ARRAY ARGUMENTS
     character&
     &   nmmin(8)*1,nmsub(6)*1,nmvar(8)*1
!
!  LOCAL SCALARS
     integer&
     &   i,iprt
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL EHDR,IPRINT
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     LOGICAL HEAD
!        A FLAG INDICATING WHETHER THE HEADING SHOULD BE PRINTED
!        (TRUE) OR NOT (FALSE).  IF A HEADING IS PRINTED, THE VALUE
!        OF HEAD WILL BE CHANGED TO FALSE.
!     INTEGER I
!        AN INDEX ARGUMENT.
!     INTEGER IPRT
!        THE UNIT NUMBER FOR PRINTED OUTPUT.
!     INTEGER MSGTYP
!        THE INDICATOR ARGUMENT FOR THE TYPE OF MESSAGE.
!        IF (MSGTYP.GE.3) THE MESSAGE PRINTED WILL USE NMMIN
!        OTHERWISE IT WILL USE YMMN.
!        IF (MSGTYP = 1 OR 3) NO VIOLATIONS ARE ALLOWED.
!        IF (MSGTYP = 2 OR 4) THE NUMBER OF VIOLATIONS MUST
!                             BE LESS THAN   NVMX   .
!     CHARACTER*1 NMMIN(8)
!        THE NAME OF THE ARGUMENT SPECIFYING THE MINIMUM.
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     CHARACTER*1 NMVAR(8)
!        THE CHARACTERS OF THE PARAMETERS NAME.
!     INTEGER NV
!        THE NUMBER OF VIOLATIONS FOUND.
!     INTEGER NVMX
!        THE LARGEST NUMBER OF VIOLATIONS ALLOWED.
!     REAL YMMN
!        THE MINIMUM ACCEPTABLE VALUE.
!
      call iprint(iprt)
      call ehdr(nmsub, head)
!
     if (msgtyp.le.2)&
     &   write (iprt, 1000) (nmvar(i),i=1,6), ymmn, nv
     if (msgtyp.ge.3)&
     &   write (iprt, 1005) (nmvar(i),i=1,6), (nmmin(i),i=1,8), nv
!
      go to (10, 20, 30, 40), msgtyp
!
   10 write(iprt, 1010) (nmvar(i),i=1,6), ymmn
      return
!
   20 write(iprt, 1020) (nmvar(i),i=1,6), ymmn, nvmx
      return
!
   30 write(iprt, 1030) (nmvar(i),i=1,6), (nmmin(i),i=1,8)
      return
!
   40 write(iprt, 1040) (nmvar(i),i=1,6), (nmmin(i),i=1,8), nvmx
      return
!
!     FORMAT STATEMENTS
!
1000 format (/&
    &   31h the number of values in array , 6a1,&
     &   23h less than or equal to , 1pe14.7, 4h is , i6, '.')
1005 format (/&
    &   31h the number of values in array , 6a1,&
     &   23h less than or equal to , 8a1, 4h is , i6, '.')
1010 format(&
    &   25h the values in the array , 6a1,&
     &   26h must all be greater than , 1pe14.7, '.')
1020 format(&
    &   35h the number of values in the array , 6a1,&
    &   23h less than or equal to , 8a1/&
     &   19h must be less than , i5, '.')
1030 format(&
    &   25h the values in the array , 6a1,&
     &   26h must all be greater than , 1pe14.7, '.')
1040 format(&
    &   35h the number of values in the array , 6a1,&
    &   23h less than or equal to , 8a1/&
     &   19h must be less than , i5, '.')
!
      end
!PPMN
     subroutine ppmn (ym, ymmiss, x, xmiss, n, m, iym, ischck, isym,&
     &  lisym, isize, nout, ymn, ymx, xmn, xmx, miss, ilog)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE MAIN ROUTINE FOR PAGE PLOTS
!
!     WRITTEN BY  --
!                 JANET R. DONALDSON
!                 STATISTICAL ENGINEERING DIVISION/BOULDER
!                 NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  NOVEMBER 21, 1980
!
!     INPUT ARGUMENTS - (IN ORDER OF USAGE)
!
!        X  THE N VECTOR OF OBSERVATIONS FOR THE X
!           COORDINATES
!       YM  THE N BY M MATRIX OF OBSERVATIONS FOR THE Y (VERTICAL)
!           COORDINATES
!           THE ITH COLUMN IS PLOTTED USING THE FOLLOWING SYMBOL
!               1 = A    2 = B    3 = C    4 = D
!               5 = E    6 = F    7 = G    8 = H
!               9 = I   10 = J   11 = K   12 = L
!              13 = M   14 = N   15 = O   16 = P
!              17 = Q   18 = R   19 = S   20 = T
!              21 = U   22 = V   23 = W   24 = Y
!              25 (AND ABOVE) = Z
!           THE NUMBERS 1 TO 9 INDICATE MULTIPLE POINTS ON A GIVEN
!           PLOT LOCATION, WHERE THE NUMBER INDICATES HOW MANY POINTS
!           ARE REPRESENTED
!           NOTE THAT  X  IS NOT USED AS A PLOTTING SYMBOL EXCEPT TO
!           INDICATE THAT MORE THAN 9 POINTS FELL ON THE SAME PLOT
!           LOCATION
!        N  THE INTEGER NUMBER OF OBSERVATIONS TO BE PLOTTED (IN EACH
!           COLUMN)
!        M  THE NUMBER OF COLUMNS IN THE YM ARRAY TO BE PLOTTED VERSUS X
!           FOR THE CASE OF A VECTOR YM, M MUST BE EQUAL TO 1
!    IYM  THE ACTUAL INTEGER VALUE OF THE ROW DIMENSION OF THE Y ARRAY
!           WHEN YM IS A VECTOR (M.EQ.1) IYM SHOULD BE SET EQUAL TO N
!   ISCHCK  THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     ISYM  THE N VECTOR OF INTEGERS DETERMINING THE PLOTTING SYMBOLS TO
!           USED FOR THE S SERIES OF PLOTS, WHERE
!               1 = +    2 = .    3 = *    4 = -
!               5 = A    6 = B    7 = C    8 = D
!               9 = E   10 = F   11 = G   12 = H
!              13 = I   14 = J   15 = K   16 = L
!              17 = M   18 = N   19 = O   20 = P
!              21 = Q   22 = R   23 = S   24 = T
!              25 = U   26 = V   27 = W   28 = Y
!              29 (AND ABOVE) = Z
!           THE NUMBERS 1 TO 9 INDICATE MULTIPLE POINTS ON A GIVEN
!           PLOT LOCATION, WHERE THE NUMBER INDICATES HOW MANY POINTS
!           ARE REPRESENTED
!           NOTE THAT  X  IS NOT USED AS A PLOTTING SYMBOL EXCEPT TO
!           INDICATE THAT MORE THAN 9 POINTS FELL ON THE SAME PLOT
!           LOCATION
!    ISIZE  THE INTEGER CODE FOR THE PLOT SIZE, WHERE
!           0 INDICATES A PLOT 100 COL BY 50 ROWS
!           1 INDICATES A PLOT 50 COL BY  50 ROWS
!     NOUT  THE INTEGER VALUE INDICATING HOW MANY OF THE POINTS WHICH
!           FELL OUTSIDE OF THE GRAPH LIMITS ARE TO BE LISTED
!           IF XLB.EQ.XUB AND YLB.EQ.YUB, NOUT SHOULD BE SET TO ZERO
!     XLB  THE MINIMUM VALUE OF X TO BE PLOTTED(IE, THE LOWER BOUND FOR
!           THE X AXIS), WHERE IF XLB=XUB THE ROUTINE WILL DETERMINE
!           THIS VALUE FROM THE MINIMUM VALUE OF THE X VECTOR
!     XUB  THE MAXIMUM VALUE OF X TO BE PLOTTED(IE, THE UPPER BOUND FOR
!           THE X AXIS), WHERE IF XLB=XUB THE ROUTINE WILL DETERMINE
!           THIS VALUE FROM THE MAXIMUM VALUE OF THE X VECTOR
!     YLB  THE MINIMUM VALUE OF Y TO BE PLOTTED(IE, THE LOWER BOUND FOR
!           THE Y AXIS), WHERE IF YLB=YUB THE ROUTINE WILL DETERMINE
!           THIS VALUE FROM THE MINIMUM VALUE OF THE Y VECTOR
!     YUB  THE MAXIMUM VALUE OF Y TO BE PLOTTED(IE, THE UPPER BOUND FOR
!           THE Y AXIS), WHERE IF YLB=YUB THE ROUTINE WILL DETERMINE
!           THIS VALUE FROM THE MAXIMUM VALUE OF THE Y VECTOR
!     ILOG  THE INTEGER INDICATOR VARIABLE USED TO DETERMINE WHETHER
!           THE Y AXIS SCALE IS TO BE LOG OR NOT
!           IF ILOG.EQ.0, THE SCALE IS NOT LOG
!           IF ILOG.NE.0, THE SCALE IS LOG
!
!
!     ADDITIONAL VARIABLES USED - (IN ALPHABETICAL ORDER)
!
!    ALINE  THE VECTOR OF THE CURRENT PLOT LINE
!   ALPHAI  THE PLOT AXIS SYMBOL I
!   AXISCH  THE Y A AXIS SYMBOL TO BE USED FOR THE CURRENT LINE,
!           EITHER I OR -
!   ALPHAX  THE PLOTTING SYMBOL X DESIGNATING MORE THAN 9 POINTS FELL ON
!           A SINGLE PLOTTING LOCATION
!    BLANK  THE PLOTTING SYMBOL BLANK
!     DELX  THE RANGE OF THE X AXIS
!     DELY  THE RANGE OF THE Y AXIS
!   HYPHEN  THE PLOT AXIS SYMBOL -
!       IC  THE COUNT OF THE NUMBER OF VALUES FALLING OUTSIDE OF THE
!           GRAPH BOUNDS
!     ICOL  THE COLUMN LOCATION FOR THE PLOT LINE
!     IOUT  THE MINIMUM OF NOUT OR 50, INDICATING HOW MANY OF THE
!           POINTS WHICH FELL OUTSIDE OF THE GRAPH LIMITS WILL ACTUALLY
!           BE LISTED
!   IPCODE  THE INTEGER CODE, USED IN ERROR CHECKING, WHICH DETERMINES
!           WHICH PLOT ROUTINE HAS BEEN CALLED
!      IPR  THE UNIT NUMBER OF THE PRINTER
!    ITEST  THE INDICATOR VARIABLE FOR WHETHER THE X AXIS LABELS ARE
!           PRINTED IN E OR F FORMAT
!      KSS  AN INTEGER VECTOR USED IN DETERMINING THE PLOT SYMBOL
!           NEEDED
!       NN  THE NUMBER OF Y LABELS TO BE LISTED ON THE LEFT AXIS,
!           (DEPENDENT ON THE GRAPH SIZE)
!   NUMCOL  THE INTEGER VALUE OF THE NUMBER OF COLUMNS IN THE GRAPH
!   NUMLAB  THE INTEGER NUMBER OF X LABELS TO BE LISTED AT THE BOTTOM
!           OF THE GRAPH (DEPENDENT ON GRAPH SIZE)
!   NUMROW  THE INTEGER NUMBER OF ROWS IN THE GRAPH
!      SYM  THE VECTOR OF PLOT SYMBOL ASSIGNMENTS (SEE IS ABOVE)
!     SYM1  THE VECTOR OF INTEGER VALUES USED TO INDICATE MULTIPLE
!           POINTS ON THE SAME PLOT LOCATION
!     TEMP  THE ARRAY OF VALUES TO BE PRINTED WHICH FALL OUTSIDE THE
!           GRAPH LIMITS
!   XLABEL  THE VECTOR OF X AXIS LABELS
!       XMN  THE MINIMUM X VALUE TO BE PLOTTED, COMPUTED FROM DATA OR
!           ASSIGNED BY XLB
!   XWIDTH  THE VALUE OF AN INDIVIDUAL X AXIS GRAPH INTERVAL
!       XMX  THE MAXIMUM X VALUE TO BE PLOTTED, COMPUTED FROM DATA OR
!           ASSIGNED BY XUB
!   YLABEL  THE VALUE OF THE Y AXIS LABEL TO BE PRINTED
!   YLOWER  THE LOWER BOUND FOR Y VALUES TO BE PLOTTED ON THE CURRENT
!           LINE
!       YMN  THE MINIMUM Y VALUE TO BE PLOTTED, COMPUTED FROM DATA OR
!           ASSIGNED BY YLB
!   YUPPER  THE UPPER BOUND FOR Y VALUES TO BE PLOTTED ON THE CURRENT
!           LINE
!   YWIDTH  THE VALUE OF AN INDIVIDUAL Y AXIS GRAPH INTERVAL
!       YMX  THE MAXIMUM Y VALUE TO BE PLOTTED, COMPUTED FROM DATA OR
!           ASSIGNED BY YUB
!
!!SUBROUTINE PPMN (YM(IYM,M),YMMISS(M),X(N),xmiss,n,m,iym,ischck,ISYM(LISYM),lisym,isize,nout,ymn,ymx,xmn,xmx,_miss,ilog)
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: xmiss,xmn,xmx,ymn,ymx
      integer :: ilog,ischck,isize,iym,lisym,m,n,nout
      logical :: miss
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: x(n),ym(iym,m),ymmiss(m)
      integer isym(lisym)
!
!  SCALARS IN COMMON
      integer ierr
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   delx,dely,tn,tx,xdmn,xdmx,xwidth,xx,ydmn,ydmx,yl,ylower,&
     &   yupper,ywidth,yy
     integer&
    &   i,ic,icol,ik,ilogx,ilogy,iout,iprt,irow,it,itest,j,jcol,k,&
     &   l,nlablx,nlably,nlu,nn,numcol,numcp2,numrow
     character&
    &   alphai*1,alphax*1,axisch*1,blank*1,hyphen*1,fmt*4,&
     &   xlfmt*205,xlfmt2*205
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   temp(50,2),xlabel(20),ylabel(20)
     integer&
     &   aline(105),ilogxy(2),isizxy(2),ispace(20),kss(101)
     character&
     &   cline(105)*1,itemp(50)*1,sym(30)*1,sym1(9)*1
!
!  EXTERNAL FUNCTIONS
!      LOGICAL
!     +   MVCHK
!      EXTERNAL MVCHK
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,LOGLMT,PRTCNT
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,log10,max,min
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER ALINE(105)
!     CHARACTER*1 ALPHAI, ALPHAX
!     CHARACTER*1 AXISCH
!     CHARACTER*1 BLANK
!     CHARACTER*1 CLINE(105)
!     REAL(KIND=WP) :: DELX, DELY
!     CHARACTER FMT*4
!        THE FORMAT FOR THE X-AXIS LABELS
!     CHARACTER*1 HYPHEN
!     INTEGER I, IC, ICOL, IERR, IK
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER ILOGX
!        THE VALUES OF P AS SPECIFIED BY ILOG.
!     INTEGER ILOGXY(2)
!        THE VALUES OF P AND Q AS SPECIFIED BY ILOG.
!     INTEGER ILOGY
!        THE VALUES OF Q AS SPECIFIED BY ILOG.
!     INTEGER IOUT
!     INTEGER IPRT, IROW
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISIZXY(2)
!     INTEGER ISPACE(20)
!        THE SPACING FOR THE X-AXIS LABELS
!     INTEGER ISYM(LISYM)
!     INTEGER IT
!     CHARACTER*1 ITEMP(50)
!     INTEGER ITEST
!     INTEGER IYM
!     INTEGER J, JCOL
!     INTEGER K
!     INTEGER KSS(101)
!     INTEGER L
!     INTEGER LISYM
!     INTEGER M
!     LOGICAL MISS
!     INTEGER N
!     INTEGER NLABLX, NLABLY, NLU
!     INTEGER NN, NOUT, NUMCOL, NUMCP2, NUMROW
!     CHARACTER*1 SYM(30), SYM1(9)
!     REAL(KIND=WP) :: TEMP(50, 2)
!     REAL(KIND=WP) :: TN, TX
!     REAL(KIND=WP) :: X(N)
!     REAL(KIND=WP) :: XDMN, XDMX
!        THE X-AXIS DATA LIMITS ACTUALLY USED.
!     REAL(KIND=WP) :: XLABEL(20)
!        THE X-AXIS LABLES.
!     CHARACTER XLFMT*205, XLFMT2*205
!        THE FORMATS USED TO PRINT THE X-AXIS
!     REAL(KIND=WP) :: XMISS, XMN, XMX, XWIDTH, XX
!     REAL(KIND=WP) :: YDMN, YDMX
!        THE Y-AXIS DATA LIMITS ACTUALLY USED.
!     REAL(KIND=WP) :: YL
!     REAL(KIND=WP) :: YLABEL(20)
!        THE Y-AXIS LABLES.
!     REAL(KIND=WP) :: YLOWER
!     REAL(KIND=WP) :: YM(IYM, M)
!     REAL(KIND=WP) :: YMMISS(M)
!     REAL(KIND=WP) :: YMN, YMX, YUPPER, YWIDTH, YY
!
      data blank/' '/,hyphen/'-'/,alphai/'I'/,alphax/'X'/
     data sym( 1)/'+'/,sym( 2)/'.'/,sym( 3)/'*'/,sym( 4)/'-'/,&
    &     sym( 5)/'A'/,sym( 6)/'B'/,sym( 7)/'C'/,sym( 8)/'D'/,&
    &     sym( 9)/'E'/,sym(10)/'F'/,sym(11)/'G'/,sym(12)/'H'/,&
    &     sym(13)/'I'/,sym(14)/'J'/,sym(15)/'K'/,sym(16)/'L'/,&
    &     sym(17)/'M'/,sym(18)/'N'/,sym(19)/'O'/,sym(20)/'P'/,&
    &     sym(21)/'Q'/,sym(22)/'R'/,sym(23)/'S'/,sym(24)/'T'/,&
    &     sym(25)/'U'/,sym(26)/'V'/,sym(27)/'W'/,sym(28)/'Y'/,&
     &     sym(29)/'Z'/,sym(30)/'Z'/
     data sym1(1)/'1'/,sym1(2)/'2'/,sym1(3)/'3'/,sym1(4)/'4'/,&
    &     sym1(5)/'5'/,sym1(6)/'6'/,sym1(7)/'7'/,sym1(8)/'8'/,&
     &     sym1(9)/'9'/
!
      call iprint(iprt)
!
!     DEFINE THE NUMBER OF ROWS AND COLUMNS WITHIN THE PLOT
!
      call prtcnt(max(0,isize),2,isizxy)
      if (isizxy(1).eq.0) then
        numcol=101
      else
        numcol = 51
      end if
      if (isizxy(2).eq.0) then
        numrow = 51
      else
        numrow = 26
      end if
!
      numcp2 = numcol + 2
      nn=(numrow-1)/5
!
!     ADJUST FOR LOG PLOTS IF NECESSARY AND FIND AXIS LABELS
!
      call prtcnt (max(0,ilog),2,ilogxy)
      ilogx = ilogxy(1)
      ilogy = ilogxy(2)
     call loglmt (ilogy, ymn, ymx, ylabel, numrow, 5, dely, ywidth,&
     &  nlably, ydmn, ydmx)
     call loglmt (ilogx, xmn, xmx, xlabel, numcol, 10, delx, xwidth,&
     &  nlablx, xdmn, xdmx)
!
!     TEST FOR FORMAT FOR Y AXIS LABELS
!
      itest=0
      tx=ymx
      tn=ymn
      if (ilogy.eq.0) go to 190
      tx=10.0_wp**tx
      tn=10.0_wp**tn
 190 if ((tn .ge. 1.0e6_wp .or. tn .le. (-1.0e5_wp)) .or.&
     &   (abs(tn).gt.0.0_wp.and.abs(tn).lt.0.001_wp)) itest=1
     if ((tx .ge. 1.0e6_wp .or. tx .le. (-1.0e5_wp)) .or.&
     &   (abs(tx).gt.0.0_wp.and.abs(tx).lt.0.001_wp)) itest=1
!
!     BLANK OUT THE PLOT PRINT LINE CLINE
!
      do 200 icol=1,105
         cline(icol)=blank
  200 continue
!
!     WRITE OUT THE TOP HORIZONTAL AXIS OF THE PLOT
!
      do 210 icol=1,numcol
         cline(icol)=hyphen
  210 continue
      cline(1)=alphai
      if (ilogx.eq.0) then
        do 215 icol=11,numcol,10
           cline(icol)=alphai
  215   continue
      else
        do 216 ik = nlablx, 1, -1
          icol = ((log10(xlabel(ik))-xmn)/xwidth)+1.5_wp
          cline(icol) = alphai
  216   continue
      end if
      cline(numcol+1)=hyphen
      cline(numcol+2)=blank
      write (iprt, 1004) hyphen,(cline(i),i=1,numcol),hyphen
      do 217 icol=1,105
         cline(icol)=blank
  217 continue
!
!     DETERMINE AND WRITE OUT THE PLOT POSITIONS ONE LINE AT A TIME.
!
      l=-1
      ik=1
      do 320 irow=1,numrow
         l=l+1
         if (l.gt.nn) l=1
         do 235 icol=1,numcol
            aline(icol)=0
            kss(icol)=0
  235    continue
         yupper=ymx+(1.5_wp-irow)*ywidth
         ylower=ymx+(0.5_wp-irow)*ywidth
      do 255 i = 1, n
!
         if (miss .and. mvchk(x(i), xmiss)) go to 255
!
         if (ilogx.eq.0) then
           xx=x(i)
         else
           xx=log10(x(i))
         end if
         do 250 j=1,m
!
            if (miss .and. mvchk(ym(i,j), ymmiss(j))) go to 250
               if (ilogy.eq.0) then
                 yy=ym(i,j)
               else
                 yy=log10(ym(i,j))
               end if
              if (((ylower.le.yy).and.(yy.lt.yupper)) .and.&
     &             ((yy.ge.ydmn).and.(yy.le.ydmx))) then
                  if ((xx.ge.xdmn) .and. (xx.le.xdmx)) then
                     icol=((xx-xmn)/xwidth)+1.5_wp
                     aline(icol) = aline(icol) + 1
!     SIMPLE PLOTTING (PLT)
                     kss(icol)=1
!     SYMBOL PLOTS (SPLT)
                     if (ischck .eq. 1) kss(icol) = isym(i)
!     MULTIPLE PLOTS (MPLT)
                     if (ischck .eq. 2) kss(icol) = j + 4
                     if (kss(icol).gt.30) kss(icol)=30
                     if (kss(icol).lt.1) kss(icol)=1
                  end if
               end if
  250       continue
  255    continue
         do 290 icol=1,numcol
            if (aline(icol).eq.0) then
              cline(icol)=blank
            else
              if (aline(icol).eq.1) then
                k=kss(icol)
                cline(icol)=sym(k)
              else
                if (aline(icol).le.9) then
                  cline(icol)=sym1(aline(icol))
                else
                  cline(icol)=alphax
                end if
              end if
            end if
  290    continue
         cline(numcol+2)=hyphen
         axisch=hyphen
         if (ilogy.eq.0) then
           yl = ylabel(ik)
         else
           yl = log10(ylabel(ik))
         end if
         if ((ylower.gt.yl) .or. (yl.ge.yupper)) then
!
!          PRINT LINE WITHOUT LABEL
!
           cline(numcp2)=alphai
           write(iprt, 1008) alphai, (cline(icol), icol=1,numcp2)
         else
!
!          PRINT LINE WITH LABEL
!
           if (itest.eq.0) then
            write(iprt,1006) ylabel(ik),axisch,&
     &         (cline(icol),icol=1,numcp2)
           else
            write(iprt,1007) ylabel(ik),axisch,&
     &         (cline(icol),icol=1,numcp2)
           end if
           ik=ik+1
         end if
  320 continue
!
!     WRITE OUT THE BOTTOM HORIZONTAL AXIS AND THE X AXIS LABELS.
!
      do 330 icol=1,numcol
         cline(icol)=hyphen
  330 continue
      cline(1)=alphai
      if (ilogx.eq.0) then
        nlu = nlablx+1
        do 340 icol=numcol,1,-10
           cline(icol)=alphai
           nlu = nlu - 1
           ispace(nlu) = 1
  340   continue
      else
        jcol = 1
        cline(jcol) = alphai
        nlu = nlablx
        do 345 ik = nlablx, 1, -1
          icol = ((log10(xlabel(ik))-xmn)/xwidth)+1.5
          cline(icol) = alphai
          if (icol-jcol.ge.10) then
            ispace(nlu) = icol-jcol-9
            nlu = nlu - 1
            xlabel(nlu) = xlabel(ik)
            jcol = icol
          end if
  345   continue
      end if
      cline(numcol+1)=hyphen
      cline(numcol+2)=blank
!
      write(iprt, 1004) hyphen, (cline(icol), icol = 1, numcp2)
!
!     CHECK X-AXIS LABELS FOR FORMAT
!
      fmt = 'F9.4'
      do 350 i=1,nlablx
       if (((abs(xlabel(i)).gt.0.0_wp) .and.&
    &     (abs(xlabel(i)).lt.0.01_wp))&
    &     .or.&
    &     ((xlabel(i).ge.1.0e4_wp) .or. (xlabel(i).le.(-1.0e3_wp))))&
     &     then
          fmt = 'E9.4'
           go to 355
         end if
  350 continue
  355 continue
      write(xlfmt2,1000) nlablx-nlu
      write(xlfmt,xlfmt2) (fmt, ispace(i), i=nlablx,nlu+1,-1), fmt
      write(iprt, xlfmt) (xlabel(i),i=nlablx,nlu,-1)
!
!     DETERMINE VALUES TO BE LISTED IF OUTSIDE OF AXIS LIMITS.
!
      ic = 0
      iout = min(nout,50)
      if (iout.ge.0) then
        do 180 i = 1, n
!
          if (miss .and. mvchk(x(i), xmiss)) go to 180
!
          if (ilogx.eq.0) then
            xx = x(i)
          else
            xx = log10(x(i))
          end if
           do 175 j=1,m
!
              if (miss .and. mvchk(ym(i,j), ymmiss(j))) go to 175
!
              if (ilogy.eq.0) then
                yy = ym(i,j)
              else
                yy = log10(ym(i,j))
              end if
!
             if (((ydmn .le. yy) .and. (yy .le. ydmx)) .and.&
     &            ((xdmn .le. xx) .and. (xx .le. xdmx))) go to 175
!
              ic=ic+1
              if (ic.gt.iout) go to 175
              temp(ic,1)=x(i)
              temp(ic,2)=ym(i,j)
              it=1
              if (ischck.eq.1) it=isym(i)
              if (ischck.eq.2) it=j+4
              if (it.lt.1) it=1
              if (it.gt.30) it=30
              itemp(ic) = sym(it)
  175      continue
  180   continue
      end if
!
!     CHECK FOR POINTS OUTSIDE OF GRAPH LIMITS AND LIST IF REQUESTED
!     THE TOTAL NUMBER OF POINTS TO BE PLOTTED IS N*M
!
      if (ic.eq.0) return
      if (iout .lt. 0) return
      write (iprt, 1010) ic
      if (iout.le.0) return
      write (iprt, 1016)
      if (ic.le.iout) go to 360
      ic=iout
      write(iprt, 1011) iout
      go to 370
  360 write(iprt, 1012)
  370 write(iprt, 1013) (temp(i,1), temp(i,2), itemp(i), i = 1, ic)
      return
!
!     FORMAT STATEMENTS
!
1000 format ('(''(14X'',', i2, '('', '', A4, '','', I2, ''X''),',&
     &  ''', '', A4, '')'')')
 1004 format (' ',16x, a1, 105a1)
 1006 format(4x,f11.4,1x,a1,1x,105a1)
 1007 format (' ', e14.7, 1x, a1, 1x, 105a1)
 1008 format (' ', 15x, a1, 1x, 105a1)
1010 format(16x,6h**note,i4,43h values fell outside the specified limit&
     &s**)
1011 format ('1', 15x, 10hthe first , i3,&
    &   35h values outside the plot limits are/ 22x,&
     & 33h x               y            sym)
1012 format ('1', 15x, 38hthe values outside the plot limits are/ 22x,&
     & 33h x               y            sym)
 1013 format (15x,2e15.8,9x,a1)
 1016 format (16x, 22hsee next page for list)
!
      end
!SUMBS
      subroutine sumbs(x, n, lo, mid, hi)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     A ROUTINE TO FIND A ZERO OR VALUE CLOSEST TO ZERO IN
!     A SORTED VECTOR.
!
!     WRITTEN BY - JOHN E. KOONTZ
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS
!
!     CREATION DATE  -  MAY 17, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   hi,lo,mid,n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(n)
!
!  LOCAL SCALARS
     integer&
     &   curhi,curlo
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER CURHI
!        THE UPPER BOUND OF THE CURRENT INTERVAL.
!     INTEGER CURLO
!        THE LOWER BOUND OF THE CURRENT INTERVAL.
!     INTEGER HI
!        INPUT PARAMETER.  THE UPPER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER LO
!        INPUT PARAMETER.  THE LOWER BOUND OF THE INITIAL
!        INTERVAL.
!     INTEGER MID
!        OUTPUT PARAMETER.  THE MIDPOINT OF THE CURRENT
!        INTERVAL, AND ON EXIT THE POINT IN THE INITIAL
!        INTERVAL CLOSEST TO ZERO.
!     INTEGER N
!        INPUT PARAMETER.  THE LENGTH OF THE ARRAY X.
!     REAL(KIND=WP) :: X(N)
!        INPUT PARAMETER.  THE ARRAY X IN WHICH THE SEARCH FOR
!        A (NEAR) ZERO VALUE IS MADE.
!
!     BINARY SEARCH OF X FOR 0.0_WP OR CLOSEST TO IT.
!
      curlo = lo
      curhi = hi
!
!     SEE IF ZERO IS OUT OF THE RANGE X(LO) TO X(HI).
!
      if (x(curlo).lt.0.0_wp) go to 10
      mid = curlo
      go to 50
   10 if (x(curhi).gt.0.0_wp) go to 20
      mid = curhi
      go to 50
!
!     LOCATE EITHER A ZERO OR A PAIR OF ADJACENT VALUES BETWEEN
!     WHICH THERE LIES A ZERO.
!
   20 if (curlo+1.eq.curhi) go to 30
      mid = (curlo+curhi)/2
      if (0.0_wp.lt.x(mid)) curhi = mid
      if (0.0_wp.gt.x(mid)) curlo = mid
      if (0.0_wp.eq.x(mid)) go to 50
      go to 20
!
!     PICK AS MIDPOINT THE CURRENT ENDPOINT CLOSEST TO ZERO.
!
   30 if (x(curhi)+x(curlo).gt.0.0_wp) go to 40
      mid = curhi
      go to 50
   40 mid = curlo
   50 return
      end
!ABSCOM
subroutine abscom(n, v, w, abstol, nfail)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS SUBROUTINE COMPUTES THE NUMBER OF TIMES THE
!     ABSOLUTE DIFFERENCE BETWEEN V(I) AND W(I), I = 1, 2, ..., N,
!     IS GREATER THAN   ABSTOL  .
!
!     WRITTEN BY  -  ROBERT B. SCHNABEL (CODED BY JANET R. DONALDSON)
!                    STATISTICAL ENGINEERING DIVISION
!                    NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  APRIL 2, 1981
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) :: abstol
     integer n,nfail
!
!  ARRAY ARGUMENTS
     real(kind=wp) :: v(*),w(*)
!
!  LOCAL SCALARS
     integer i
!
!  INTRINSIC FUNCTIONS
      intrinsic abs
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     REAL(KIND=WP) :: ABSTOL
!        THE ABSOLUTE TOLERANCE USED IN THE COMPARISON.
!     INTEGER I
!        AN INDEXING VARIABLE.
!     INTEGER N
!        THE NUMBER OF OBSERVATIONS.
!     INTEGER NFAIL
!        THE TOTAL NUMBER OF FAILURES.
!     REAL(KIND=WP) :: V(N), W(N)
!        THE VALUES BEING COMPARED.
!
      nfail = 0
!
      do i = 1, n
         if (abs(v(i) - w(i)) .gt. abstol) nfail = nfail + 1
      enddo
!
end subroutine abscom
!VPC
subroutine vpc(ym, n, ns, ilog, isize, irlin, ibar, ylb, yub, xlb, xinc)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!     THIS IS THE USER CALLABLE ROUTINE WHICH PRODUCES A VERTICAL
!     PLOT (LONG CALL).
!
!     WRITTEN BY - JANET R. DONALDSON
!                  STATISTICAL ENGINEERING DIVISION
!                  NATIONAL BUREAU OF STANDARDS, BOULDER, COLORADO
!
!     CREATION DATE  -  JANUARY 21, 1982
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) :: xinc,xlb,ylb,yub
     integer ibar,ilog,irlin,isize,n,ns
!
!  ARRAY ARGUMENTS
     real(kind=wp) :: ym(*)
!
!  SCALARS IN COMMON
     integer ierr
!
!  LOCAL SCALARS
     integer iprt,ischck,iym,lisym,m
     logical miss,multi
!
!  LOCAL ARRAYS
     real(kind=wp) :: ymmiss(1)
     integer isym(1)
     character nmsub(6)*1
!
!  EXTERNAL SUBROUTINES
!      EXTERNAL IPRINT,VPCNT
!
!  COMMON BLOCKS
      common /errchk/ierr
!
!     VARIABLE DEFINITIONS (ALPHABETICALLY)
!
!     INTEGER IBAR
!        THE VARIABLE USED TO DETERMINE IF SINGLE POINTS (IBAR .EQ. 0)
!        OR BARS (IBAR .NE. 0) ARE TO BE PLOTTED.
!     INTEGER IERR
!        A COMMON VARIABLE USED AS A FLAG TO INDICATE WHETHER
!        OR NOT THERE ARE ANY ERRORS, IF =0 THEN NO ERRORS.
!     INTEGER ILOG
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SCALE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS LINEAR.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS LOG.
!     INTEGER IPRT
!        OUTPUT LOGICAL UNIT NUMBER
!     INTEGER IRLIN
!        THE INDICATOR VARIABLE USED TO DESIGNATE WHETHER ZERO OR THE
!        SERIES MEAN IS TO BE PLOTTED AS A REFERENCE LINE, OR WHETHER
!        NO REFERENCE LINE IS TO BE PLOTTED.
!        IF IRLIN .LE. -1, NO REFERENCE LINE IS PLOTTED.
!        IF IRLIN .EQ.  0, ZERO IS PLOTTED AS THE REFERENCE LINE.
!        IF IRLIN .GE.  1, THE SERIES MEAN IS PLOTTED.
!     INTEGER ISCHCK
!        THE INTEGER VALUE INDICATING HOW THE PLOTTING SYMBOLS
!           WILL BE DESIGNATED, WHERE
!           0 INDICATES THE PLOTTING SYMBOLS HAVE NOT BEEN DESIGNATED IN
!             THE N VECTOR ISYM AND ONLY THE SYMBOL + IS TO BE USED
!           1 INDICATES THE PLOTTING SYMBOLS HAVE BEEN DESIGNATED IN THE
!             N VECTOR ISYM
!           2 INDICATES THAT M SERIES ARE BEING PLOTTED.
!             SYMBOL I+4 WILL BE USED FOR COLUMN I OF YM.
!     INTEGER ISIZE
!        THE TWO DIGIT INTEGER, PQ, USED TO SELECT AXIS SIZE, WHERE
!        P DESIGNATES THE X-AXIS AND Q DESIGNATES THE Y-AXIS.
!        IF P.EQ.0 (Q.EQ.0), THEN THE X-AXIS (Y-AXIS) IS THE MAXIMUM.
!        IF P.NE.0 (Q.NE.0), THEN THE X-AXIS (Y-AXIS) IS HALF THE MAXIMU
!     INTEGER ISYM(1)
!        VECTOR CONTAINING SYMBOL DESIGNATIONS FOR PLOTTING
!     INTEGER IYM
!        THE FIRST DIMENSION OF ARRAY YM.
!     INTEGER LISYM
!        THE LENGTH OF ARRAY ISYM.
!     INTEGER M
!        NUMBER OF Y VECTORS
!     LOGICAL MISS
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MISSING VALUES
!        MAY BE PRESENT (MISS = .TRUE.) OR NOT (MISS = .FALSE.)
!     LOGICAL MULTI
!        INDICATOR VARIABLE USED TO DESIGNATE WHETHER MULTIPLE Y VALUES
!        ARE TO BE PLOTTED (MULTI = .TRUE.) OR NOT (MULTI = .FALSE.)
!     INTEGER N
!        LENGTH OF VECTORS
!     CHARACTER*1 NMSUB(6)
!        THE CHARACTERS OF THE CALLING ROUTINES NAME.
!     INTEGER NS
!        THE SAMPLING FREQUENCY,
!        WHERE IF NS .LE. 1, EVERY POINT IS PLOTTED,
!                       = 2, EVERY OTHER POINT IS PLOTTED,
!                       = 3, EVERY THIRD POINT IS PLOTTED, ETC.
!     REAL(KIND=WP) :: XINC, XLB
!        INCREMENT AND LOWER BOUNDS FOR X-AXIS.
!     REAL(KIND=WP) :: YLB
!        LOWER BOUND FOR Y-AXIS.
!     REAL(KIND=WP) :: YM(N,1)
!        MULTIVARIATE OBSERVATIONS FOR THE Y COORDINATES
!     REAL(KIND=WP) :: YMMISS(1)
!        THE MISSING VALUE CODE FOR THE Y-AXIS.
!     REAL(KIND=WP) :: YUB
!        UPPER BOUND FOR Y-AXIS.
!
!
!     SET UP NAME ARRAYS
!
     data&
    &  nmsub(1),  nmsub(2),  nmsub(3),  nmsub(4),  nmsub(5),  nmsub(6)&
     &    /  ' ',       'V',       'P',       'C',       ' ',       ' '/
!
!     SET DEFAULT VALUES
!
      ymmiss(1) = 1.0_wp
      m = 1
      iym = n
      multi = .false.
      ischck = 0
      miss = .false.
      lisym = 1
!
!     COMMENCE BODY OF ROUTINE
!
     call vpcnt (ym, ymmiss, n, m, iym, multi, ilog, ylb, yub,&
    &  xlb, xinc, ns, irlin, ibar, nmsub, ischck, isym, isize,&
     &  miss, lisym)
!
      if (ierr.ne.0) then
        ierr = 1
        call iprint(iprt)
        write (iprt,1000)
      end if
      return
!
!     FORMAT STATEMENTS
!
1000 format (/42h the correct form of the call statement is//&
    &  '       CALL VPC (Y, N, NS, ILOG,'/&
     &  '      +          ISIZE, IRLIN, IBAR, YLB, YUB, XLB, XINC)')
end subroutine vpc

!QAPPLY
      subroutine qapply(nn, n, p, j, r, ierr)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  VARIABLE DECLARATIONS
!
!
!  SCALAR ARGUMENTS
     integer&
     &   ierr,n,nn,p
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   j(nn,p),r(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   t
     integer&
     &   i,k,l,nl1
!
!  EXTERNAL FUNCTIONS
!      real(kind=wp) ::
!     &   dotprd
!      external dotprd
!
!  INTRINSIC FUNCTIONS
      intrinsic abs
!
!     *****PARAMETERS.
!     INTEGER NN, N, P, IERR
!     REAL(KIND=WP) :: J(NN,P), R(N)
!
!     =================================================================
!
!     *****PURPOSE.
!     THIS SUBROUTINE APPLIES TO R THE ORTHOGONAL TRANSFORMATIONS
!     STORED IN J BY QRFACT
!
!     *****PARAMETER DESCRIPTION.
!     ON INPUT.
!
!        NN IS THE ROW DIMENSION OF THE MATRIX J AS DECLARED IN
!             THE CALLING PROGRAM DIMENSION STATEMENT
!
!        N IS THE NUMBER OF ROWS OF J AND THE SIZE OF THE VECTOR R
!
!        P IS THE NUMBER OF COLUMNS OF J AND THE SIZE OF SIGMA
!
!        J CONTAINS ON AND BELOW ITS DIAGONAL THE COLUMN VECTORS
!             U WHICH DETERMINE THE HOUSEHOLDER TRANSFORMATIONS
!             IDENT - U*U.TRANSPOSE
!
!        R IS THE RIGHT HAND SIDE VECTOR TO WHICH THE ORTHOGONAL
!             TRANSFORMATIONS WILL BE APPLIED
!
!        IERR IF NON-ZERO INDICATES THAT NOT ALL THE TRANSFORMATIONS
!             WERE SUCCESSFULLY DETERMINED AND ONLY THE FIRST
!             ABS(IERR) - 1 TRANSFORMATIONS WILL BE USED
!
!     ON OUTPUT.
!
!        R HAS BEEN OVERWRITTEN BY ITS TRANSFORMED IMAGE
!
!     *****APPLICATION AND USAGE RESTRICTIONS.
!     NONE
!
!     *****ALGORITHM NOTES.
!     THE VECTORS U WHICH DETERMINE THE HOUSEHOLDER TRANSFORMATIONS
!     ARE NORMALIZED SO THAT THEIR 2-NORM SQUARED IS 2.  THE USE OF
!     THESE TRANSFORMATIONS HERE IS IN THE SPIRIT OF (1).
!
!     *****SUBROUTINES AND FUNCTIONS CALLED.
!
!     DOTPRD - FUNCTION, RETURNS THE INNER PRODUCT OF VECTORS
!
!     *****REFERENCES.
!     (1) BUSINGER, P. A., AND GOLUB, G. H. (1965), LINEAR LEAST SQUARES
!        SOLUTIONS BY HOUSEHOLDER TRANSFORMATIONS, NUMER. MATH. 7,
!        PP. 269-276.
!
!     *****HISTORY.
!     DESIGNED BY DAVID M. GAY, CODED BY STEPHEN C. PETERS (WINTER 1977)
!
!     *****GENERAL.
!
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!     MCS-7600324, DCR75-10143, 76-14311DSS, AND MCS76-11989.
!
!     =================================================================
!
!     *****LOCAL VARIABLES.
!     INTEGER I, K, L, NL1
!     REAL(KIND=WP) :: T
!/
!     *****FUNCTIONS.
!     EXTERNAL DOTPRD
!     REAL(KIND=WP) :: DOTPRD
!
      k = p
      if (ierr .ne. 0) k = abs(ierr) - 1
      if ( k .eq. 0) go to 999
!
      do 20 l = 1, k
         nl1 = n - l + 1
         t = -dotprd(nl1, j(l,l), r(l))
!
         do 10 i = l, n
            r(i) = r(i) + t*j(i,l)
 10      continue
 20   continue
 999  return

      end subroutine qapply
!LIVMUL
      subroutine livmul(n, x, l, y)
!
!  ***  SOLVE  L*X = Y, WHERE  L  IS AN  N X N  LOWER TRIANGULAR
!  ***  MATRIX STORED COMPACTLY BY ROWS.  X AND Y MAY OCCUPY THE SAME
!  ***  STORAGE.  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   l(1),x(n),y(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   t,zero
     integer&
     &   i,j,k
!
!  EXTERNAL FUNCTIONS
!      real(kind=wp) ::
!     &   dotprd
!      external dotprd
!
      data zero/0.0_wp/
!
      do 10 k = 1, n
         if (y(k) .ne. zero) go to 20
         x(k) = zero
 10      continue
      go to 999
 20   j = k*(k+1)/2
      x(k) = y(k) / l(j)
      if (k .ge. n) go to 999
      k = k + 1
      do 30 i = k, n
         t = dotprd(i-1, l(j+1), x)
         j = j + i
         x(i) = (y(i) - t)/l(j)
 30      continue
 999  return
      end subroutine livmul
!LSQRT
      subroutine lsqrt(n1, n, l, a, irc)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  COMPUTE ROWS N1 THROUGH N OF THE CHOLESKY FACTOR  L  OF
!  ***  A = L*(L**T),  WHERE  L  AND THE LOWER TRIANGLE OF  A  ARE BOTH
!  ***  STORED COMPACTLY BY ROWS (AND MAY OCCUPY THE SAME STORAGE).
!  ***  IRC = 0 MEANS ALL WENT WELL.  IRC = J MEANS THE LEADING
!  ***  PRINCIPAL  J X J  SUBMATRIX OF  A  IS NOT POSITIVE DEFINITE --
!  ***  AND  L(J*(J+1)/2)  CONTAINS THE (NONPOS.) REDUCED J-TH DIAGONAL.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   irc,n,n1
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   a(1),l(1)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   t,td,zero
     integer&
     &   i,i0,ij,ik,im1,j,j0,jk,jm1,k
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!  ***  PARAMETERS  ***
!
!     INTEGER N1, N, IRC
!     REAL(KIND=WP) :: L(1), A(1)
!     DIMENSION L(N*(N+1)/2), A(N*(N+1)/2)
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER I, IJ, IK, IM1, I0, J, JK, JM1, J0, K
!     REAL(KIND=WP) :: T, TD, ZERO
!
!/
      data zero/0.0_wp/
!
!  ***  BODY  ***
!
      i0 = n1 * (n1 - 1) / 2
      do 50 i = n1, n
         td = zero
         if (i .eq. 1) go to 40
         j0 = 0
         im1 = i - 1
         do 30 j = 1, im1
              t = zero
              if (j .eq. 1) go to 20
              jm1 = j - 1
              do 10 k = 1, jm1
                   ik = i0 + k
                   jk = j0 + k
                   t = t + l(ik)*l(jk)
 10                continue
 20           ij = i0 + j
              j0 = j0 + j
              t = (a(ij) - t) / l(j0)
              l(ij) = t
              td = td + t*t
 30           continue
 40      i0 = i0 + i
         t = a(i0) - td
         if (t .le. zero) go to 60
         l(i0) = sqrt(t)
 50      continue
!
      irc = 0
      go to 999
!
 60   l(i0) = t
      irc = i
!
 999  return
!
      end subroutine lsqrt
!LINVRT
      subroutine linvrt(n, lin, l)
!
!  ***  COMPUTE  LIN = L**-1,  BOTH  N X N  LOWER TRIANG. STORED   ***
!  ***  COMPACTLY BY ROWS.  LIN AND L MAY SHARE THE SAME STORAGE.  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   l(*),lin(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   one,t,zero
     integer&
     &   i,ii,im1,j0,j1,jj,k,k0,np1
!
!  ***  PARAMETERS  ***
!
!     INTEGER N
!     REAL(KIND=WP) :: L(*), LIN(*)
!     DIMENSION L(N*(N+1)/2), LIN(N*(N+1)/2)
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER I, II, IM1, JJ, J0, J1, K, K0, NP1
!     REAL(KIND=WP) :: ONE, T, ZERO
      data one/1.0_wp/, zero/0.0_wp/
!
!  ***  BODY  ***
!
      np1 = n + 1
      j0 = n*(np1)/2
      do 30 ii = 1, n
         i = np1 - ii
         lin(j0) = one/l(j0)
         if (i .le. 1) go to 999
         j1 = j0
         im1 = i - 1
         do 20 jj = 1, im1
              t = zero
              j0 = j1
              k0 = j1 - jj
              do 10 k = 1, jj
                   t = t - l(k0)*lin(j0)
                   j0 = j0 - 1
                   k0 = k0 + k - i
 10                continue
              lin(j0) = t/l(k0)
 20           continue
         j0 = j0 - 1
 30      continue
 999  return
      end subroutine linvrt
!VSCOPY
      subroutine vscopy(p, y, s)
!
!  ***  SET P-VECTOR Y TO SCALAR S  ***
!
!  SCALAR ARGUMENTS
      integer p
      real(kind=wp) :: y(*)
      real(kind=wp) :: s
!
!  LOCAL SCALARS
      integer i
!
      do i = 1, p
         y(i) = s
      enddo

      end subroutine vscopy
!LMSTEP
      subroutine lmstep(d, g, ierr, ipivot, ka, p, qtr, r, step, v, w)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!  ***  COMPUTE LEVENBERG-MARQUARDT STEP USING MORE-HEBDEN TECHNIQUE  **
!  ***  NL2SOL VERSION 2.2.  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ierr,ka,p
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   d(p),g(p),qtr(p),r(1),step(p),v(21),w(1)
     integer&
     &   ipivot(p)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   a,adi,alphak,b,d1,d2,dfac,dfacsq,dst,dtol,eight,half,lk,&
    &   negone,oldphi,one,p001,phi,phimax,phimin,psifac,rad,si,sj,&
     &   sqrtak,t,three,ttol,twopsi,uk,wl,zero
     integer&
    &   dgnorm,dst0,dstnrm,dstsav,epslon,gtstep,i,i1,ip1,j1,k,&
    &   kalim,l,lk0,nreduc,phipin,phmnfc,phmxfc,pp1o2,preduc,rad0,&
     &   radius,res,res0,rmat,rmat0,stppar,uk0
!
!  EXTERNAL FUNCTIONS
!      real(kind=wp) ::
!     &   dotprd,v2norm
!      external dotprd,v2norm
!
!  EXTERNAL SUBROUTINES
!      external litvmu,livmul,vcopy
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max,min,sqrt
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER IERR, KA, P
!     INTEGER IPIVOT(P)
!     REAL(KIND=WP) :: D(P), G(P), QTR(P), R(1), STEP(P), V(21), W(1)
!     DIMENSION W(P*(P+5)/2 + 4)
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  ***  PURPOSE  ***
!
!        GIVEN THE R MATRIX FROM THE QR DECOMPOSITION OF A JACOBIAN
!     MATRIX, J, AS WELL AS Q-TRANSPOSE TIMES THE CORRESPONDING
!     RESIDUAL VECTOR, RESID, THIS SUBROUTINE COMPUTES A LEVENBERG-
!     MARQUARDT STEP OF APPROXIMATE LENGTH V(RADIUS) BY THE MORE-
!     TECHNIQUE.
!
!  ***  PARAMETER DESCRIPTION  ***
!
!      D (IN)  = THE SCALE VECTOR.
!      G (IN)  = THE GRADIENT VECTOR (J**T)*R.
!   IERR (I/O) = RETURN CODE FROM QRFACT OR QRFGS -- 0 MEANS R HAS
!             FULL RANK.
! IPIVOT (I/O) = PERMUTATION ARRAY FROM QRFACT OR QRFGS, WHICH COMPUTE
!             QR DECOMPOSITIONS WITH COLUMN PIVOTING.
!     KA (I/O).  KA .LT. 0 ON INPUT MEANS THIS IS THE FIRST CALL ON
!             LMSTEP FOR THE CURRENT R AND QTR.  ON OUTPUT KA CON-
!             TAINS THE NUMBER OF HEBDEN ITERATIONS NEEDED TO DETERMINE
!             STEP.  KA = 0 MEANS A GAUSS-NEWTON STEP.
!      P (IN)  = NUMBER OF PARAMETERS.
!    QTR (IN)  = (Q**T)*RESID = Q-TRANSPOSE TIMES THE RESIDUAL VECTOR.
!      R (IN)  = THE R MATRIX, STORED COMPACTLY BY COLUMNS.
!   STEP (OUT) = THE LEVENBERG-MARQUARDT STEP COMPUTED.
!      V (I/O) CONTAINS VARIOUS CONSTANTS AND VARIABLES DESCRIBED BELOW.
!      W (I/O) = WORKSPACE OF LENGTH P*(P+5)/2 + 4.
!
!  ***  ENTRIES IN V  ***
!
! V(DGNORM) (I/O) = 2-NORM OF (D**-1)*G.
! V(DSTNRM) (I/O) = 2-NORM OF D*STEP.
! V(DST0)   (I/O) = 2-NORM OF GAUSS-NEWTON STEP (FOR NONSING. J).
! V(EPSLON) (IN) = MAX. REL. ERROR ALLOWED IN TWONORM(R)**2 MINUS
!             TWONORM(R - J*STEP)**2.  (SEE ALGORITHM NOTES BELOW.)
! V(GTSTEP) (OUT) = INNER PRODUCT BETWEEN G AND STEP.
! V(NREDUC) (OUT) = HALF THE REDUCTION IN THE SUM OF SQUARES PREDICTED
!             FOR A GAUSS-NEWTON STEP.
! V(PHMNFC) (IN)  = TOL. (TOGETHER WITH V(PHMXFC)) FOR ACCEPTING STEP
!             (MORE*S SIGMA).  THE ERROR V(DSTNRM) - V(RADIUS) MUST LIE
!             BETWEEN V(PHMNFC)*V(RADIUS) AND V(PHMXFC)*V(RADIUS).
! V(PHMXFC) (IN)  (SEE V(PHMNFC).)
! V(PREDUC) (OUT) = HALF THE REDUCTION IN THE SUM OF SQUARES PREDICTED
!             BY THE STEP RETURNED.
! V(RADIUS) (IN)  = RADIUS OF CURRENT (SCALED) TRUST REGION.
! V(RAD0)   (I/O) = VALUE OF V(RADIUS) FROM PREVIOUS CALL.
! V(STPPAR) (I/O) = MARQUARDT PARAMETER (OR ITS NEGATIVE IF THE SPECIAL
!             CASE MENTIONED BELOW IN THE ALGORITHM NOTES OCCURS).
!
! NOTE -- SEE DATA STATEMENT BELOW FOR VALUES OF ABOVE SUBSCRIPTS.
!
!  ***  USAGE NOTES  ***
!
!     IF IT IS DESIRED TO RECOMPUTE STEP USING A DIFFERENT VALUE OF
!     V(RADIUS), THEN THIS ROUTINE MAY BE RESTARTED BY CALLING IT
!     WITH ALL PARAMETERS UNCHANGED EXCEPT V(RADIUS).  (THIS EXPLAINS
!     WHY MANY PARAMETERS ARE LISTED AS I/O).  ON AN INTIIAL CALL (ONE
!     WITH KA = -1), THE CALLER NEED ONLY HAVE INITIALIZED D, G, KA, P,
!     QTR, R, V(EPSLON), V(PHMNFC), V(PHMXFC), V(RADIUS), AND V(RAD0).
!
!  ***  APPLICATION AND USAGE RESTRICTIONS  ***
!
!     THIS ROUTINE IS CALLED AS PART OF THE NL2SOL (NONLINEAR LEAST-
!     SQUARES) PACKAGE (REF. 1).
!
!  ***  ALGORITHM NOTES  ***
!
!     THIS CODE IMPLEMENTS THE STEP COMPUTATION SCHEME DESCRIBED IN
!     REFS. 2 AND 4.  FAST GIVENS TRANSFORMATIONS (SEE REF. 3, PP. 60-
!     62) ARE USED TO COMPUTE STEP WITH A NONZERO MARQUARDT PARAMETER.
!        A SPECIAL CASE OCCURS IF J IS (NEARLY) SINGULAR AND V(RADIUS)
!     IS SUFFICIENTLY LARGE.  IN THIS CASE THE STEP RETURNED IS SUCH
!     THAT  TWONORM(R)**2 - TWONORM(R - J*STEP)**2  DIFFERS FROM ITS
!     OPTIMAL VALUE BY LESS THAN V(EPSLON) TIMES THIS OPTIMAL VALUE,
!     WHERE J AND R DENOTE THE ORIGINAL JACOBIAN AND RESIDUAL.  (SEE
!     REF. 2 FOR MORE DETAILS.)
!
!  ***  FUNCTIONS AND SUBROUTINES CALLED  ***
!
! DOTPRD - RETURNS INNER PRODUCT OF TWO VECTORS.
! LITVMU - APPLY INVERSE-TRANSPOSE OF COMPACT LOWER TRIANG. MATRIX.
! LIVMUL - APPLY INVERSE OF COMPACT LOWER TRIANG. MATRIX.
! VCOPY  - COPIES ONE VECTOR TO ANOTHER.
! V2NORM - RETURNS 2-NORM OF A VECTOR.
!
!  ***  REFERENCES  ***
!
! 1.  DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1980), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, (SUBMITTED TO ACM
!             TRANS. MATH. SOFTWARE).
! 2.  GAY, D.M. (1979), COMPUTING OPTIMAL ELLIPTICALLY CONSTRAINED
!             STEPS, MRC TECH. SUMMARY REPORT NO. 2013, MATH RESEARCH
!             CENTER, UNIV. OF WISCONSIN-MADISON.
! 3.  LAWSON, C.L., AND HANSON, R.J. (1974), SOLVING LEAST SQUARES
!             PROBLEMS, PRENTICE-HALL, ENGLEWOOD CLIFFS, N.J.
! 4.  MORE, J.J. (1978), THE LEVENBERG-MARQUARDT ALGORITHM, IMPLEMEN-
!             TATION AND THEORY, PP.105-116 OF SPRINGER LECTURE NOTES
!             IN MATHEMATICS NO. 630, EDITED BY G.A. WATSON, SPRINGER-
!             VERLAG, BERLIN AND NEW YORK.
!
!  ***  GENERAL  ***
!
!     CODED BY DAVID M. GAY.
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!     MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989, AND
!     MCS-7906671.
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER DSTSAV, I, IP1, I1, J1, K, KALIM, L, LK0, PHIPIN,
!    1        PP1O2, RES, RES0, RMAT, RMAT0, UK0
!     REAL(KIND=WP) :: A, ADI, ALPHAK, B, DFACSQ, DST, DTOL, D1, D2,
!    1                 LK, OLDPHI, PHI, PHIMAX, PHIMIN, PSIFAC, RAD,
!    2                 SI, SJ, SQRTAK, T, TWOPSI, UK, WL
!
!     ***  CONSTANTS  ***
!     REAL(KIND=WP) :: DFAC, EIGHT, HALF, NEGONE, ONE, P001, THREE,
!    1                 TTOL, ZERO
!
!/
!  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***
!
!     EXTERNAL DOTPRD, LITVMU, LIVMUL, VCOPY, V2NORM
!     REAL(KIND=WP) :: DOTPRD, V2NORM
!
!  ***  SUBSCRIPTS FOR V  ***
!
!     INTEGER DGNORM, DSTNRM, DST0, EPSLON, GTSTEP, NREDUC, PHMNFC,
!    1        PHMXFC, PREDUC, RADIUS, RAD0, STPPAR
     data dgnorm/1/, dstnrm/2/, dst0/3/, epslon/19/,&
    &     gtstep/4/, nreduc/6/, phmnfc/20/,&
    &     phmxfc/21/, preduc/7/, radius/8/,&
     &     rad0/9/, stppar/5/
!
     data dfac/256.0_wp/, eight/8.0_wp/, half/0.5_wp/, negone/-1.0_wp/,&
    &     one/1.0_wp/, p001/1.0e-3_wp/, three/3.0_wp/, ttol/2.5_wp/,&
     &     zero/0.0_wp/
!
!  ***  BODY  ***
!
!     ***  FOR USE IN RECOMPUTING STEP, THE FINAL VALUES OF LK AND UK,
!     ***  THE INVERSE DERIVATIVE OF MORE*S PHI AT 0 (FOR NONSING. J)
!     ***  AND THE VALUE RETURNED AS V(DSTNRM) ARE STORED AT W(LK0),
!     ***  W(UK0), W(PHIPIN), AND W(DSTSAV) RESPECTIVELY.
      alphak = 0.0_wp
      psifac = 0.0_wp
      lk0 = p + 1
      phipin = lk0 + 1
      uk0 = phipin + 1
      dstsav = uk0 + 1
      rmat0 = dstsav
!     ***  A COPY OF THE R-MATRIX FROM THE QR DECOMPOSITION OF J IS
!     ***  STORED IN W STARTING AT W(RMAT), AND A COPY OF THE RESIDUAL
!     ***  VECTOR IS STORED IN W STARTING AT W(RES).  THE LOOPS BELOW
!     ***  THAT UPDATE THE QR DECOMP. FOR A NONZERO MARQUARDT PARAMETER
!     ***  WORK ON THESE COPIES.
      rmat = rmat0 + 1
      pp1o2 = p * (p + 1) / 2
      res0 = pp1o2 + rmat0
      res = res0 + 1
      rad = v(radius)
     if (rad .gt. zero)&
     &   psifac = v(epslon)/((eight*(v(phmnfc) + one) + three) * rad**2)
      phimax = v(phmxfc) * rad
      phimin = v(phmnfc) * rad
!     ***  DTOL, DFAC, AND DFACSQ ARE USED IN RESCALING THE FAST GIVENS
!     ***  REPRESENTATION OF THE UPDATED QR DECOMPOSITION.
      dtol = one/dfac
      dfacsq = dfac*dfac
!     ***  OLDPHI IS USED TO DETECT LIMITS OF NUMERICAL ACCURACY.  IF
!     ***  WE RECOMPUTE STEP AND IT DOES NOT CHANGE, THEN WE ACCEPT IT.
      oldphi = zero
      lk = zero
      uk = zero
      kalim = ka + 12
!
!  ***  START OR RESTART, DEPENDING ON KA  ***
!
      if (ka) 10, 20, 370
!
!  ***  FRESH START -- COMPUTE V(NREDUC)  ***
!
 10   ka = 0
      kalim = 12
      k = p
      if (ierr .ne. 0) k = abs(ierr) - 1
      v(nreduc) = half*dotprd(k, qtr, qtr)
!
!  ***  SET UP TO TRY INITIAL GAUSS-NEWTON STEP  ***
!
 20   v(dst0) = negone
      if (ierr .ne. 0) go to 90
!
!  ***  COMPUTE GAUSS-NEWTON STEP  ***
!
!     ***  NOTE -- THE R-MATRIX IS STORED COMPACTLY BY COLUMNS IN
!     ***  R(1), R(2), R(3), ...  IT IS THE TRANSPOSE OF A
!     ***  LOWER TRIANGULAR MATRIX STORED COMPACTLY BY ROWS, AND WE
!     ***  TREAT IT AS SUCH WHEN USING LITVMU AND LIVMUL.
      call litvmu(p, w, r, qtr)
!     ***  TEMPORARILY STORE PERMUTED -D*STEP IN STEP.
      do 60 i = 1, p
         j1 = ipivot(i)
         step(i) = d(j1)*w(i)
 60      continue
      dst = v2norm(p, step)
      v(dst0) = dst
      phi = dst - rad
      if (phi .le. phimax) go to 410
!     ***  IF THIS IS A RESTART, GO TO 110  ***
      if (ka .gt. 0) go to 110
!
!  ***  GAUSS-NEWTON STEP WAS UNACCEPTABLE.  COMPUTE L0  ***
!
      do 70 i = 1, p
         j1 = ipivot(i)
         step(i) = d(j1)*(step(i)/dst)
 70      continue
      call livmul(p, step, r, step)
      t = one / v2norm(p, step)
      w(phipin) = (t/dst)*t
      lk = phi*w(phipin)
!
!  ***  COMPUTE U0  ***
!
 90   do 100 i = 1, p
 100     w(i) = g(i)/d(i)
      v(dgnorm) = v2norm(p, w)
      uk = v(dgnorm)/rad
      if (uk .le. zero) go to 390
!
!     ***  ALPHAK WILL BE USED AS THE CURRENT MARQUARDT PARAMETER.  WE
!     ***  USE MORE*S SCHEME FOR INITIALIZING IT.
      alphak = abs(v(stppar)) * v(rad0)/rad
!
!
!  ***  TOP OF LOOP -- INCREMENT KA, COPY R TO RMAT, QTR TO RES  ***
!
 110  ka = ka + 1
      call vcopy(pp1o2, w(rmat), r)
      call vcopy(p, w(res), qtr)
!
!  ***  SAFEGUARD ALPHAK AND INITIALIZE FAST GIVENS SCALE VECTOR.  ***
!
     if (alphak .le. zero .or. alphak .lt. lk .or. alphak .ge. uk)&
     &             alphak = uk * max(p001, sqrt(lk/uk))
      sqrtak = sqrt(alphak)
      do 120 i = 1, p
 120     w(i) = one
!
!  ***  ADD ALPHAK*D AND UPDATE QR DECOMP. USING FAST GIVENS TRANS.  ***
!
      do 270 i = 1, p
!        ***  GENERATE, APPLY 1ST GIVENS TRANS. FOR ROW I OF ALPHAK*D.
!        ***  (USE STEP TO STORE TEMPORARY ROW)  ***
         l = i*(i+1)/2 + rmat0
         wl = w(l)
         d2 = one
         d1 = w(i)
         j1 = ipivot(i)
         adi = sqrtak*d(j1)
         if (adi .ge. abs(wl)) go to 150
 130     a = adi/wl
         b = d2*a/d1
         t = a*b + one
         if (t .gt. ttol) go to 150
         w(i) = d1/t
         d2 = d2/t
         w(l) = t*wl
         a = -a
         do 140 j1 = i, p
              l = l + j1
              step(j1) = a*w(l)
 140          continue
         go to 170
!
 150     b = wl/adi
         a = d1*b/d2
         t = a*b + one
         if (t .gt. ttol) go to 130
         w(i) = d2/t
         d2 = d1/t
         w(l) = t*adi
         do 160 j1 = i, p
              l = l + j1
              wl = w(l)
              step(j1) = -wl
              w(l) = a*wl
 160          continue
!
 170     if (i .eq. p) go to 280
!
!        ***  NOW USE GIVENS TRANS. TO ZERO ELEMENTS OF TEMP. ROW  ***
!
         ip1 = i + 1
         do 260 i1 = ip1, p
              l = i1*(i1+1)/2 + rmat0
              wl = w(l)
              si = step(i1-1)
              d1 = w(i1)
!
!             ***  RESCALE ROW I1 IF NECESSARY  ***
!
              if (d1 .ge. dtol) go to 190
                   d1 = d1*dfacsq
                   wl = wl/dfac
                   k = l
                   do 180 j1 = i1, p
                        k = k + j1
                        w(k) = w(k)/dfac
 180                    continue
!
!             ***  USE GIVENS TRANS. TO ZERO NEXT ELEMENT OF TEMP. ROW
!
 190          if (abs(si) .gt. abs(wl)) go to 220
              if (si .eq. zero) go to 260
 200          a = si/wl
              b = d2*a/d1
              t = a*b + one
              if (t .gt. ttol) go to 220
              w(l) = t*wl
              w(i1) = d1/t
              d2 = d2/t
              do 210 j1 = i1, p
                   l = l + j1
                   wl = w(l)
                   sj = step(j1)
                   w(l) = wl + b*sj
                   step(j1) = sj - a*wl
 210               continue
              go to 240
!
 220          b = wl/si
              a = d1*b/d2
              t = a*b + one
              if (t .gt. ttol) go to 200
              w(i1) = d2/t
              d2 = d1/t
              w(l) = t*si
              do 230 j1 = i1, p
                   l = l + j1
                   wl = w(l)
                   sj = step(j1)
                   w(l) = a*wl + sj
                   step(j1) = b*sj - wl
 230               continue
!
!             ***  RESCALE TEMP. ROW IF NECESSARY  ***
!
 240          if (d2 .ge. dtol) go to 260
                   d2 = d2*dfacsq
                   do 250 k = i1, p
 250                    step(k) = step(k)/dfac
 260          continue
 270     continue
!
!  ***  COMPUTE STEP  ***
!
 280  call litvmu(p, w(res), w(rmat), w(res))
!     ***  RECOVER STEP AND STORE PERMUTED -D*STEP AT W(RES)  ***
      do 290 i = 1, p
         j1 = ipivot(i)
         k = res0 + i
         t = w(k)
         step(j1) = -t
         w(k) = t*d(j1)
 290     continue
      dst = v2norm(p, w(res))
      phi = dst - rad
      if (phi .le. phimax .and. phi .ge. phimin) go to 430
      if (oldphi .eq. phi) go to 430
      oldphi = phi
!
!  ***  CHECK FOR (AND HANDLE) SPECIAL CASE  ***
!
      if (phi .gt. zero) go to 310
         if (ka .ge. kalim) go to 430
              twopsi = alphak*dst*dst - dotprd(p, step, g)
              if (alphak .ge. twopsi*psifac) go to 310
                   v(stppar) = -alphak
                   go to 440
!
!  ***  UNACCEPTABLE STEP -- UPDATE LK, UK, ALPHAK, AND TRY AGAIN  ***
!
 300  if (phi .lt. zero) uk = min(uk, alphak)
      go to 320
 310  if (phi .lt. zero) uk = alphak
 320  do 330 i = 1, p
         j1 = ipivot(i)
         k = res0 + i
         step(i) = d(j1) * (w(k)/dst)
 330     continue
      call livmul(p, step, w(rmat), step)
      do 340 i = 1, p
 340     step(i) = step(i) / sqrt(w(i))
      t = one / v2norm(p, step)
      alphak = alphak + t*phi*t/rad
      lk = max(lk, alphak)
      go to 110
!
!  ***  RESTART  ***
!
 370  lk = w(lk0)
      uk = w(uk0)
      if (v(dst0) .gt. zero .and. v(dst0) - rad .le. phimax) go to 20
      alphak = abs(v(stppar))
      dst = w(dstsav)
      phi = dst - rad
      t = v(dgnorm)/rad
      if (rad .gt. v(rad0)) go to 380
!
!        ***  SMALLER RADIUS  ***
         uk = t
         if (alphak .le. zero) lk = zero
         if (v(dst0) .gt. zero) lk = max(lk, (v(dst0)-rad)*w(phipin))
         go to 300
!
!     ***  BIGGER RADIUS  ***
 380  if (alphak .le. zero .or. uk .gt. t) uk = t
      lk = zero
      if (v(dst0) .gt. zero) lk = max(lk, (v(dst0)-rad)*w(phipin))
      go to 300
!
!  ***  SPECIAL CASE -- RAD .LE. 0 OR (G = 0 AND J IS SINGULAR)  ***
!
 390  v(stppar) = zero
      dst = zero
      lk = zero
      uk = zero
      v(gtstep) = zero
      v(preduc) = zero
      do 400 i = 1, p
 400     step(i) = zero
      go to 450
!
!  ***  ACCEPTABLE GAUSS-NEWTON STEP -- RECOVER STEP FROM W  ***
!
 410  alphak = zero
      do 420 i = 1, p
         j1 = ipivot(i)
         step(j1) = -w(i)
 420     continue
!
!  ***  SAVE VALUES FOR USE IN A POSSIBLE RESTART  ***
!
 430  v(stppar) = alphak
 440  v(gtstep) = dotprd(p, step, g)
      v(preduc) = half * (alphak*dst*dst - v(gtstep))
 450  v(dstnrm) = dst
      w(dstsav) = dst
      w(lk0) = lk
      w(uk0) = uk
      v(rad0) = rad
!
      end subroutine lmstep
!QRFACT
      subroutine qrfact(nm,m,n,qr,alpha,ipivot,ierr,nopivk,sum)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  COMPUTE THE QR DECOMPOSITION OF THE MATRIX STORED IN QR  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ierr,m,n,nm,nopivk
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   alpha(n),qr(nm,n),sum(n)
     integer&
     &   ipivot(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   alphak,beta,one,p01,p99,qrkk,qrkmax,rktol,rktol1,sigma,sumj,&
     &   temp,ufeta,zero
     integer&
     &   i,j,jbar,k,k1,minum,mk1
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!      real(kind=wp) ::
!     &   dotprd,v2norm
!      external dotprd,v2norm
!
!  EXTERNAL SUBROUTINES
!      external vaxpy,vscopy
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,min,sqrt
!
!     *****PARAMETERS.
!     INTEGER NM,M,N,IPIVOT(N),IERR,NOPIVK
!     REAL(KIND=WP) :: QR(NM,N),ALPHA(N),SUM(N)
!     *****LOCAL VARIABLES.
!     INTEGER I,J,JBAR,K,K1,MINUM,MK1
!     REAL(KIND=WP) :: ALPHAK,BETA,QRKK,QRKMAX,SIGMA,TEMP,UFETA,RKTOL,
!    1        RKTOL1,SUMJ
!     *****FUNCTIONS.
!/+
!     INTEGER MIN
!     REAL(KIND=WP) ::             ABS,SQRT
!/
!     EXTERNAL DOTPRD, VAXPY, VSCOPY, V2NORM
!     REAL(KIND=WP) :: DOTPRD, V2NORM
! DOTPRD... RETURNS INNER PRODUCT OF TWO VECTORS.
! RMDCON... RETURNS MACHINE-DEPENDENT CONSTANTS.
! VAXPY... COMPUTES SCALAR TIMES ONE VECTOR PLUS ANOTHER.
! VSCOPY... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.
! V2NORM... RETURNS THE 2-NORM OF A VECTOR.
!
!     *****CONSTANTS.
!     REAL(KIND=WP) :: ONE, P01, P99, ZERO
      data one/1.0_wp/, p01/0.01_wp/, p99/0.99_wp/, zero/0.0_wp/
!
!
!     ==================================================================
!
!
!     *****PURPOSE.
!
!     THIS SUBROUTINE DOES A QR-DECOMPOSITION ON THE M X N MATRIX QR,
!        WITH AN OPTIONALLY MODIFIED COLUMN PIVOTING, AND RETURNS THE
!        UPPER TRIANGULAR R-MATRIX, AS WELL AS THE ORTHOGONAL VECTORS
!        USED IN THE TRANSFORMATIONS.
!
!     *****PARAMETER DESCRIPTION.
!     ON INPUT.
!
!        NM MUST BE SET TO THE ROW DIMENSION OF THE TWO DIMENSIONAL
!             ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
!             DIMENSION STATEMENT.
!
!        M MUST BE SET TO THE NUMBER OF ROWS IN THE MATRIX.
!
!        N MUST BE SET TO THE NUMBER OF COLUMNS IN THE MATRIX.
!
!        QR CONTAINS THE REAL RECTANGULAR MATRIX TO BE DECOMPOSED.
!
!     NOPIVK IS USED TO CONTROL PIVOTTING.  COLUMNS 1 THROUGH
!        NOPIVK WILL REMAIN FIXED IN POSITION.
!
!        SUM IS USED FOR TEMPORARY STORAGE FOR THE SUBROUTINE.
!
!     ON OUTPUT.
!
!        QR CONTAINS THE NON-DIAGONAL ELEMENTS OF THE R-MATRIX
!             IN THE STRICT UPPER TRIANGLE. THE VECTORS U, WHICH
!             DEFINE THE HOUSEHOLDER TRANSFORMATIONS   I - U*U-TRANSP,
!             ARE IN THE COLUMNS OF THE LOWER TRIANGLE. THESE VECTORS U
!             ARE SCALED SO THAT THE SQUARE OF THEIR 2-NORM IS 2.0.
!
!        ALPHA CONTAINS THE DIAGONAL ELEMENTS OF THE R-MATRIX.
!
!        IPIVOT REFLECTS THE COLUMN PIVOTING PERFORMED ON THE INPUT
!             MATRIX TO ACCOMPLISH THE DECOMPOSITION. THE J-TH
!             ELEMENT OF IPIVOT GIVES THE COLUMN OF THE ORIGINAL
!             MATRIX WHICH WAS PIVOTED INTO COLUMN J DURING THE
!             DECOMPOSITION.
!
!        IERR IS SET TO.
!             0 FOR NORMAL RETURN,
!             K IF NO NON-ZERO PIVOT COULD BE FOUND FOR THE K-TH
!                  TRANSFORMATION, OR
!             -K FOR AN ERROR EXIT ON THE K-TH THANSFORMATION.
!             IF AN ERROR EXIT WAS TAKEN, THE FIRST (K - 1)
!             TRANSFORMATIONS ARE CORRECT.
!
!
!     *****APPLICATIONS AND USAGE RESTRICTIONS.
!     THIS MAY BE USED WHEN SOLVING LINEAR LEAST-SQUARES PROBLEMS --
!     SEE SUBROUTINE QR1 OF ROSEPACK.  IT IS CALLED FOR THIS PURPOSE
!     BY LLSQST IN THE NL2SOL (NONLINEAR LEAST-SQUARES) PACKAGE.
!
!     *****ALGORITHM NOTES.
!     THIS VERSION OF QRFACT TRIES TO ELIMINATE THE OCCURRENCE OF
!     UNDERFLOWS DURING THE ACCUMULATION OF INNER PRODUCTS.  RKTOL1
!     IS CHOSEN BELOW SO AS TO INSURE THAT DISCARDED TERMS HAVE NO
!     EFFECT ON THE COMPUTED TWO-NORMS.
!
!     ADAPTED FROM THE ALGOL ROUTINE SOLVE (1).
!
!     *****REFERENCES.
!     (1)     BUSINGER,P. AND GOLUB,G.H., LINEAR LEAST SQUARES
!     SOLUTIONS BY HOUSHOLDER TRANSFORMATIONS, IN WILKINSON,J.H.
!     AND REINSCH,C.(EDS.), HANDBOOK FOR AUTOMATIC COMPUTATION,
!     VOLUME II. LINEAR ALGEBRA, SPRINGER-VERLAG, 111-118 (1971).
!     PREPUBLISHED IN NUMER.MATH. 7, 269-276 (1965).
!
!     *****HISTORY.
!     THIS AMOUNTS TO THE SUBROUTINE QR1 OF ROSEPACK WITH RKTOL1 USED
!     IN PLACE OF RKTOL BELOW, WITH V2NORM USED TO INITIALIZE (AND
!     SOMETIMES UPDATE) THE SUM ARRAY, AND WITH CALLS ON DOTPRD AND
!     VAXPY IN PLACE OF SOME LOOPS.
!
!     *****GENERAL.
!
!     DEVELOPMENT OF THIS PROGRAM SUPPORTED IN PART BY
!     NATIONAL SCIENCE FOUNDATION GRANT GJ-1154X3 AND
!     NATIONAL SCIENCE FOUNDATION GRANT DCR75-08802
!     TO NATIONAL BUREAU OF ECONOMIC RESEARCH, INC.
!
!
!
!     =================================================================
!     =================================================================
!
!
!     ==========  UFETA IS THE SMALLEST POSITIVE FLOATING POINT NUMBER
!        S.T. UFETA AND -UFETA CAN BOTH BE REPRESENTED.
!
!     ==========  RKTOL IS THE SQUARE ROOT OF THE RELATIVE PRECISION
!        OF FLOATING POINT ARITHMETIC (MACHEP).
      data rktol/0.0_wp/, ufeta/0.0_wp/
!     *****BODY OF PROGRAM.
      if (ufeta .gt. zero) go to 10
         ufeta = rmdcon(1,typ=0.0_wp)
         rktol = rmdcon(4,typ=0.0_wp)
   10 ierr = 0
      rktol1 = p01 * rktol
!
      do 20 j=1,n
         sum(j) = v2norm(m, qr(1,j))
         ipivot(j) = j
   20 continue
!
      minum = min(m,n)
!
      do 120 k=1,minum
         mk1 = m - k + 1
!        ==========K-TH HOUSEHOLDER TRANSFORMATION==========
         sigma = zero
         jbar = 0
!        ==========FIND LARGEST COLUMN SUM==========
      if (k .le. nopivk) go to 50
         do 30 j=k,n
              if (sigma .ge. sum(j))  go to 30
              sigma = sum(j)
              jbar = j
   30    continue
!
         if (jbar .eq. 0)  go to 220
         if (jbar .eq. k)  go to 50
!        ==========COLUMN INTERCHANGE==========
         i = ipivot(k)
         ipivot(k) = ipivot(jbar)
         ipivot(jbar) = i
         sum(jbar) = sum(k)
         sum(k) = sigma
!
         do 40 i=1,m
              sigma = qr(i,k)
              qr(i,k) = qr(i,jbar)
              qr(i,jbar) = sigma
   40    continue
!        ==========END OF COLUMN INTERCHANGE==========
   50    continue
!        ==========  SECOND INNER PRODUCT  ==========
         qrkmax = zero
!
         do 60 i=k,m
              if (abs( qr(i,k) ) .gt. qrkmax)  qrkmax = abs( qr(i,k) )
   60    continue
!
         if (qrkmax .lt. ufeta)  go to 210
         alphak = v2norm(mk1, qr(k,k)) / qrkmax
         sigma = alphak**2
!
!        ==========  END SECOND INNER PRODUCT  ==========
         qrkk = qr(k,k)
         if (qrkk .ge. zero)  alphak = -alphak
         alpha(k) = alphak * qrkmax
         beta = qrkmax * sqrt(sigma - (qrkk*alphak/qrkmax) )
         qr(k,k) = qrkk - alpha(k)
         do 65 i=k,m
   65         qr(i,k) =  qr(i,k) / beta
         k1 = k + 1
         if (k1 .gt. n) go to 120
!
         do 110 j = k1, n
              temp = -dotprd(mk1, qr(k,k), qr(k,j))
!
!             ***  SET QR(I,J) = QR(I,J) + TEMP*QR(I,K), I = K,...,M.
!
              call vaxpy(mk1, qr(k,j), temp, qr(k,k), qr(k,j))
!
              if (k1 .gt. m) go to 110
              sumj = sum(j)
              if (sumj .lt. ufeta) go to 110
              temp = abs(qr(k,j)/sumj)
              if (temp .lt. rktol1) go to 110
              if (temp .ge. p99) go to 90
                   sum(j) = sumj * sqrt(one - temp**2)
                   go to 110
   90         sum(j) = v2norm(m-k, qr(k1,j))
  110    continue
!        ==========END OF K-TH HOUSEHOLDER TRANSFORMATION==========
  120 continue
!
      go to 999
!     ==========ERROR EXIT ON K-TH TRANSFORMATION==========
  210 ierr = -k
      go to 230
!     ==========NO NON-ZERO ACCEPTABLE PIVOT FOUND==========
  220 ierr = k
  230 do 240 i = k, n
         alpha(i) = zero
         if (i .gt. k) call vscopy(i-k, qr(k,i), zero)
 240     continue
!     ==========RETURN TO CALLER==========
  999 return

      end subroutine qrfact
!NL2SNO
      subroutine nl2sno(n, p, x, calcr, iv, v, uiparm, urparm, ufparm)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  LIKE NL2SOL, BUT WITHOUT CALCJ -- MINIMIZE NONLINEAR SUM OF  ***
!  ***  SQUARES USING FINITE-DIFFERENCE JACOBIAN APPROXIMATIONS      ***
!  ***  (NL2SOL VERSION 2.2)  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer  n,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: urparm(:),v(:),x(p)
      integer iv(:),uiparm(:)
!
!  SUBROUTINE ARGUMENTS
      external calcr,ufparm
!
!  LOCAL SCALARS
      real(kind=wp) :: h,hfac,hlim,negpt5,one,xk,zero
     integer covprt,covreq,d,d1,dk,dltfdj,dtype,i,j,j1,j1k,k,nf,nfcall,nfgcal,r,r1,rn,toobig
     logical strted
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!
!  EXTERNAL SUBROUTINES
!      external dfault,itsmry,nl2itr,vscopy
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max
!
!     INTEGER N, P, IV(:), UIPARM(:)
!     REAL(KIND=WP) :: X(P), V(*), URPARM(*)
!     DIMENSION IV(60+P),  V(93 + N*P + 3*N + P*(3*P+33)/2)
!
!-----------------------------  DISCUSSION  ----------------------------
!
!        THE PARAMETERS FOR NL2SNO ARE THE SAME AS THOSE FOR NL2SOL
!     (WHICH SEE), EXCEPT THAT CALCJ IS OMITTED.  INSTEAD OF CALLING
!     CALCJ TO OBTAIN THE JACOBIAN MATRIX OF R AT X, NL2SNO COMPUTES
!     AN APPROXIMATION TO IT BY FINITE (FORWARD) DIFFERENCES -- SEE
!     V(DLTFDJ) BELOW.  NL2SNO USES FUNCTION VALUES ONLY WHEN COMPUT-
!     THE COVARIANCE MATRIX (RATHER THAN THE FUNCTIONS AND GRADIENTS
!     THAT NL2SOL MAY USE).  TO DO SO, NL2SNO SETS IV(COVREQ) TO -1 IF
!     IV(COVPRT) = 1 WITH IV(COVREQ) = 0 AND TO MINUS ITS ABSOLUTE
!     VALUE OTHERWISE.  THUS V(DELTA0) IS NEVER REFERENCED AND ONLY
!     V(DLTFDC) MATTERS -- SEE NL2SOL FOR A DESCRIPTION OF V(DLTFDC).
!        THE NUMBER OF EXTRA CALLS ON CALCR USED IN COMPUTING THE JACO-
!     BIAN APPROXIMATION ARE NOT INCLUDED IN THE FUNCTION EVALUATION
!     COUNT IV(NFCALL) AND ARE NOT OTHERWISE REPORTED.
!
! V(DLTFDJ)... V(36) HELPS CHOOSE THE STEP SIZE USED WHEN COMPUTING THE
!             FINITE-DIFFERENCE JACOBIAN MATRIX.  FOR DIFFERENCES IN-
!             VOLVING X(I), THE STEP SIZE FIRST TRIED IS
!                       V(DLTFDJ) * MAX(ABS(X(I)), 1/D(I)),
!             WHERE D IS THE CURRENT SCALE VECTOR (SEE REF. 1).  (IF
!             THIS STEP IS TOO BIG, I.E., IF CALCR SETS NF TO 0, THEN
!             SMALLER STEPS ARE TRIED UNTIL THE STEP SIZE IS SHRUNK BE-
!             LOW 1000 * MACHEP, WHERE MACHEP IS THE UNIT ROUNDOFF.
!             DEFAULT = MACHEP**0.5.
!
!  ***  REFERENCES  ***
!
! 1.  DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1980), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, SUBMITTED TO ACM TRANS.
!             MATH. SOFTWARE.
!
!  ***  GENERAL  ***
!
!     CODED BY DAVID M. GAY.
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!     MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989, AND
!     MCS-7906671.
!
!+++++++++++++++++++++++++++  DECLARATIONS  ++++++++++++++++++++++++++++
!
!/
!  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***
!
!     EXTERNAL DFAULT, ITSMRY, NL2ITR, VSCOPY
!
! DFAULT... SUPPLIES DEFAULT PARAMETER VALUES.
! ITSMRY... PRINTS ITERATION SUMMARY AND INFO ABOUT INITIAL AND FINAL X.
! NL2ITR... REVERSE-COMMUNICATION ROUTINE THAT CARRIES OUT NL2SOL ALGORITHM.
! RMDCON... RETURNS MACHINE-DEPENDENT CONSTANTS.
! VSCOPY... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.
!
!     LOGICAL STRTED
!     INTEGER DK, D1, I, J1, J1K, K, NF, RN, R1
!     REAL(KIND=WP) :: H, HFAC, HLIM, NEGPT5, ONE, XK, ZERO
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER COVPRT, COVREQ, D, DLTFDJ, DTYPE, J, NFCALL, NFGCAL, R, TOOBIG
!
     data hfac/1.0e3_wp/, hlim/0.0_wp/, negpt5/-0.5_wp/, one/1.0_wp/, zero/0.0_wp/
!
!  ***  IV SUBSCRIPT VALUES  ***
!
     data covprt/14/, covreq/15/, d/27/, dtype/16/, j/33/,nfcall/6/, nfgcal/7/, r/50/, toobig/2/
!
!  ***  V SUBSCRIPT VALUES  ***
!
      data dltfdj/36/
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
      d1 = 94 + 2*n + p*(3*p + 31)/2
      iv(d) = d1
      r1 = d1 + p
      iv(r) = r1
      j1 = r1 + n
      iv(j) = j1
      rn = j1 - 1
      if (iv(1) .eq. 0) call dfault(iv, v)
      iv(covreq) = -abs(iv(covreq))
      if (iv(covprt) .ne. 0 .and. iv(covreq) .eq. 0) iv(covreq) = -1
      strted = .true.
      if (iv(1) .ne. 12) go to 80
         strted = .false.
         iv(nfcall) = 1
         iv(nfgcal) = 1
!        ***  INITIALIZE SCALE VECTOR D TO ONES FOR COMPUTING
!        ***  INITIAL JACOBIAN.
         if (iv(dtype) .gt. 0) call vscopy(p, v(d1), one)
!
 10   continue
      nf = iv(nfcall)
      call calcr(n, p, x, nf, v(r1), uiparm, urparm, ufparm)
      if (strted) go to 20
         if (nf .gt. 0) go to 30
              iv(1) = 13
              go to 90
!
 20   continue
      if (nf .le. 0) iv(toobig) = 1
      go to 80
!
!  ***  COMPUTE FINITE-DIFFERENCE JACOBIAN  ***
!
 30   continue
      j1k = j1
      dk = d1
      do 70 k = 1, p
         xk = x(k)
         h = v(dltfdj) * max(abs(xk), one/v(dk))
         dk = dk + 1
 40      continue
         x(k) = xk + h
         nf = iv(nfgcal)
         call calcr (n, p, x, nf, v(j1k), uiparm, urparm, ufparm)
         if (nf .gt. 0) go to 50
              if (hlim .eq. zero) hlim = hfac * rmdcon(3,typ=0.0_wp)
!             ***  HLIM = HFAC TIMES THE UNIT ROUNDOFF  ***
              h = negpt5 * h
              if (abs(h) .ge. hlim) go to 40
                   iv(1) = 15
                   go to 90
 50      continue
         x(k) = xk
         do i = r1, rn
              v(j1k) = (v(j1k) - v(i)) / h
              j1k = j1k + 1
         enddo
 70      continue
!
      strted = .true.
!
 80   continue
!          nl2itr(d(p),  iv(*), j(nn,p), n, nn, p, r(n),  v(*), x(p))
      call nl2itr(v(d1), iv,    v(j1),   n, n,  p, v(r1), v,    x)
      if (iv(1) - 2) 10, 30, 999
!
 90   continue
      call itsmry(v(d1), iv, p, v, x)
!
end subroutine nl2sno
!MADR
      subroutine madr(n, p, x, nf, r, uiparm, urparm, ufparm)
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer n,nf,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: r(n),urparm(:),x(p)
      integer uiparm(:)
!
!  SUBROUTINE ARGUMENTS
      external ufparm
!
!  INTRINSIC FUNCTIONS
      intrinsic cos,sin
!
      r(1) = x(1)**2 + x(2)**2 + x(1)*x(2)
      r(2) = sin(x(1))
      r(3) = cos(x(2))

      end subroutine madr
!V2NORM
      real(kind=wp) function v2norm(p, x)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  RETURN THE 2-NORM OF THE P-VECTOR X, TAKING  ***
!  ***  CARE TO AVOID THE MOST LIKELY UNDERFLOWS.    ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   p
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   one,r,scale,sqteta,t,xi,zero
     integer&
     &   i,j
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,sqrt
!
!
      data one/1.0_wp/, sqteta/0.0_wp/, zero/0.0_wp/
!
      if (p .gt. 0) go to 10
         v2norm = zero
         go to 999
 10   do 20 i = 1, p
         if (x(i) .ne. zero) go to 30
 20      continue
      v2norm = zero
      go to 999
!
 30   scale = abs(x(i))
      if (i .lt. p) go to 40
         v2norm = scale
         go to 999
 40   t = one
      if (sqteta .eq. zero) sqteta = rmdcon(2,typ=0.0_wp)
!
!     ***  SQTETA IS (SLIGHTLY LARGER THAN) THE SQUARE ROOT OF THE
!     ***  SMALLEST POSITIVE FLOATING POINT NUMBER ON THE MACHINE.
!     ***  THE TESTS INVOLVING SQTETA ARE DONE TO PREVENT UNDERFLOWS.
!
      j = i + 1
      do 60 i = j, p
         xi = abs(x(i))
         if (xi .gt. scale) go to 50
              r = xi / scale
              if (r .gt. sqteta) t = t + r*r
              go to 60
 50           r = scale / xi
              if (r .le. sqteta) r = zero
              t = one  +  t * r*r
         scale = xi
 60      continue
!
      v2norm = scale * sqrt(t)
 999  return

      end function v2norm
!ITSMRY
      subroutine itsmry(d, iv, p, v, x)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  PRINT NL2SOL (VERSION 2.2) ITERATION SUMMARY  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   p
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   d(p),v(*),x(p)
     integer&
     &   iv(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   nreldf,oldf,preldf,reldf,zero
     integer&
    &   cov1,covmat,covprt,covreq,dstnrm,f,f0,fdif,g,g1,i,i1,ich,&
    &   ii,iv1,j,m,needhd,nf,nfcall,nfcov,ng,ngcall,ngcov,niter,&
    &   nreduc,ol,outlev,preduc,prntit,prunit,pu,reldx,size,&
     &   solprt,statpr,stppar,sused,x0prt
!
!  LOCAL ARRAYS
     character&
     &   model1(3,6)*1,model2(4,6)*1
!
!  INTRINSIC FUNCTIONS
      intrinsic abs
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER IV(1), P
!     REAL(KIND=WP) :: D(P), V(1), X(P)
!     DIMENSION IV(*), V(*)
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER COV1, G1, I, II, IV1, I1, J, M, NF, NG, OL, PU
!     CHARACTER*1 MODEL1(3, 6), MODEL2(4, 6)
!     REAL(KIND=WP) :: NRELDF, OLDF, PRELDF, RELDF, ZERO
!
!/
!  ***  NO EXTERNAL FUNCTIONS OR SUBROUTINES  ***
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER COVMAT, COVPRT, COVREQ, DSTNRM, F, FDIF, F0, G,
!    1        NEEDHD, NFCALL, NFCOV, NGCOV, NGCALL, NITER, NREDUC,
!    2        OUTLEV, PREDUC, PRNTIT, PRUNIT, RELDX, SIZE, SOLPRT,
!    3        STATPR, STPPAR, SUSED, X0PRT
!
!  ***  IV SUBSCRIPT VALUES  ***
!
     data covmat/26/, covprt/14/, g/28/, covreq/15/,&
    &     needhd/39/, nfcall/6/, nfcov/40/, ngcov/41/,&
    &     ngcall/30/, niter/31/, outlev/19/, prntit/48/,&
    &     prunit/21/, solprt/22/, statpr/23/, sused/57/,&
     &     x0prt/24/
!
!  ***  V SUBSCRIPT VALUES  ***
!
     data dstnrm/2/, f/10/, f0/13/, fdif/11/, nreduc/6/,&
     &     preduc/7/, reldx/17/, size/47/, stppar/5/
!
     data model1(1, 1), model1(2, 1), model1(3, 1)&
     &   /        ' ',          ' ',          ' '  /
     data model1(1, 2), model1(2, 2), model1(3, 2)&
     &   /        ' ',          ' ',          ' '  /
     data model1(1, 3), model1(2, 3), model1(3, 3)&
     &   /        ' ',          ' ',          ' '  /
     data model1(1, 4), model1(2, 4), model1(3, 4)&
     &   /        ' ',          ' ',          ' '  /
     data model1(1, 5), model1(2, 5), model1(3, 5)&
     &   /        ' ',          'G',          ' '  /
     data model1(1, 6), model1(2, 6), model1(3, 6)&
     &   /        ' ',          'S',          ' '  /
     data model2(1, 1), model2(2, 1), model2(3, 1), model2(4, 1)&
     &    /       ' ',          'G',          ' ',          ' '  /
     data model2(1, 2), model2(2, 2), model2(3, 2), model2(4, 2)&
     &   /        ' ',          'S',          ' ',          ' '  /
     data model2(1, 3), model2(2, 3), model2(3, 3), model2(4, 3)&
     &   /        'G',          '-',          'S',          ' '  /
     data model2(1, 4), model2(2, 4), model2(3, 4), model2(4, 4)&
     &   /        'S',          '-',          'G',          ' '  /
     data model2(1, 5), model2(2, 5), model2(3, 5), model2(4, 5)&
     &   /        '-',          'S',          '-',          'G'  /
     data model2(1, 6), model2(2, 6), model2(3, 6), model2(4, 6)&
     &   /        '-',          'G',          '-',          'S'  /
      data zero/0.0_wp/
!
!-----------------------------------------------------------------------
!
      pu = iv(prunit)
      if (pu .eq. 0) go to 999
      iv1 = iv(1)
      ol = iv(outlev)
      if (iv1 .lt. 2 .or. iv1 .gt. 15) go to 140
      if (ol .eq. 0) go to 20
      if (iv1 .ge. 12) go to 20
      if (iv1 .ge. 10 .and. iv(prntit) .eq. 0) go to 20
      if (iv1 .gt. 2) go to 10
         iv(prntit) = iv(prntit) + 1
         if (iv(prntit) .lt. abs(ol)) go to 999
 10   nf = iv(nfcall) - abs(iv(nfcov))
      iv(prntit) = 0
      reldf = zero
      preldf = zero
      oldf = v(f0)
      if (oldf .le. zero) go to 12
         reldf = v(fdif) / oldf
         preldf = v(preduc) / oldf
 12   if (ol .gt. 0) go to 15
!
!        ***  PRINT SHORT SUMMARY LINE  ***
!
         if (iv(needhd) .eq. 1) write(pu, 1010)
 1010 format(12h0   it    nf,6x,'F',8x,5hreldf,6x,6hpreldf,5x,5hreldx)
         iv(needhd) = 0
         write(pu,1017) iv(niter), nf, v(f), reldf, preldf, v(reldx)
         go to 20
!
!     ***  PRINT LONG SUMMARY LINE  ***
!
 15   if (iv(needhd) .eq. 1) write(pu,1015)
1015 format(12h0   it    nf,6x,'F',8x,5hreldf,6x,6hpreldf,5x,5hreldx,&
     &       4x,15hmodel    stppar,6x,4hsize,6x,6hd*step,5x,7hnpreldf)
      iv(needhd) = 0
      m = iv(sused)
      nreldf = zero
      if (oldf .gt. zero) nreldf = v(nreduc) / oldf
     write(pu,1017) iv(niter), nf, v(f), reldf, preldf, v(reldx),&
    &               (model1(ich, m), ich = 1, 3),&
    &               (model2(ich, m), ich = 1, 4),&
     &               v(stppar), v(size), v(dstnrm), nreldf
 1017 format(1x,i5,i6,4e11.3,7a1,4e11.3)
!
 20   go to (999,999,30,35,40,45,50,60,70,80,90,150,110,120,130), iv1
!
 30   write(pu,1030)
 1030 format(26h0***** x-convergence *****)
      go to 180
!
 35   write(pu,1035)
 1035 format(42h0***** relative function convergence *****)
      go to 180
!
 40   write(pu,1040)
 1040 format(49h0***** x- and relative function convergence *****)
      go to 180
!
 45   write(pu,1045)
 1045 format(42h0***** absolute function convergence *****)
      go to 180
!
 50   write(pu,1050)
 1050 format(33h0***** singular convergence *****)
      go to 180
!
 60   write(pu,1060)
 1060 format(30h0***** false convergence *****)
      go to 180
!
 70   write(pu,1070)
 1070 format(38h0***** function evaluation limit *****)
      go to 180
!
 80   write(pu,1080)
 1080 format(28h0***** iteration limit *****)
      go to 180
!
 90   write(pu,1090)
 1090 format(18h0***** stopx *****)
      go to 180
!
 110  write(pu,1100)
 1100 format(45h0***** initial sum of squares overflows *****)
!
      go to 150
!
 120  write(pu,1120)
 1120 format(37h0***** bad parameters to assess *****)
      go to 999
!
 130  write(pu,1130)
 1130 format(36h0***** j could not be computed *****)
      if (iv(niter) .gt. 0) go to 190
      go to 150
!
 140  write(pu,1140) iv1
 1140 format(14h0***** iv(1) =,i5,6h *****)
      go to 999
!
!  ***  INITIAL CALL ON ITSMRY  ***
!
 150  if (iv(x0prt) .ne. 0) write(pu,1150) (i, x(i), d(i), i = 1, p)
 1150 format(23h0    i     initial x(i),7x,4hd(i)//(1x,i5,e17.6,e14.3))
      if (iv1 .ge. 13) go to 999
      iv(needhd) = 0
      iv(prntit) = 0
      if (ol .eq. 0) go to 999
      if (ol .lt. 0) write(pu,1010)
      if (ol .gt. 0) write(pu,1015)
      write(pu,1160) v(f)
 1160 format(12h0    0     1,e11.3,11x,e11.3)
      go to 999
!
!  ***  PRINT VARIOUS INFORMATION REQUESTED ON SOLUTION  ***
!
 180  iv(needhd) = 1
      if (iv(statpr) .eq. 0) go to 190
         oldf = v(f0)
         preldf = zero
         nreldf = zero
         if (oldf .le. zero) go to 185
              preldf = v(preduc) / oldf
              nreldf = v(nreduc) / oldf
 185     nf = iv(nfcall) - iv(nfcov)
         ng = iv(ngcall) - iv(ngcov)
         write(pu,1180) v(f), v(reldx), nf, ng, preldf, nreldf
1180 format(9h0function,e17.6,8h   reldx,e20.6/12h func. evals,&
     &   i8,9x,'GRAD. EVALS',i8/' PRELDF',e19.6,3x,'NPRELDF',e18.6)
!
         if (iv(nfcov) .gt. 0) write(pu,1185) iv(nfcov)
 1185    format('0',i4,' EXTRA FUNC. EVALS FOR COVARIANCE.')
         if (iv(ngcov) .gt. 0) write(pu,1186) iv(ngcov)
 1186    format(1x,i4,' EXTRA GRAD. EVALS FOR COVARIANCE.')
!
 190  if (iv(solprt) .eq. 0) go to 210
         iv(needhd) = 1
         g1 = iv(g)
         write(pu,1190)
 1190 format('0    I      FINAL X(I)',8x,'D(I)',10x,'G(I)'/)
         do 200 i = 1, p
              write(pu,1200) i, x(i), d(i), v(g1)
              g1 = g1 + 1
 200          continue
 1200    format(1x,i5,e17.6,2e14.3)
!
 210  if (iv(covprt) .eq. 0) go to 999
      cov1 = iv(covmat)
      iv(needhd) = 1
      if (cov1) 220, 230, 240
 220  if (-1 .eq. cov1) write(pu,1220)
 1220 format(43h0++++++ indefinite covariance matrix ++++++)
      if (-2 .eq. cov1) write(pu,1225)
 1225 format(52h0++++++ oversize steps in computing covariance +++++)
      go to 999
!
 230  write(pu,1230)
 1230 format(45h0++++++ covariance matrix not computed ++++++)
      go to 999
!
 240  i = abs(iv(covreq))
      if (i .le. 1) write(pu,1241)
 1241 format(48h0covariance = scale * h**-1 * (j**t * j) * h**-1/)
      if (i .eq. 2) write(pu,1242)
 1242 format(27h0covariance = scale * h**-1/)
      if (i .ge. 3) write(pu,1243)
 1243 format(36h0covariance = scale * (j**t * j)**-1/)
      ii = cov1 - 1
      if (ol .le. 0) go to 260
      do 250 i = 1, p
         i1 = ii + 1
         ii = ii + i
         write(pu,1250) i, (v(j), j = i1, ii)
 250     continue
 1250 format(' ROW',i3,2x,9e12.4/(9x,9e12.4))
      go to 999
!
 260  do 270 i = 1, p
         i1 = ii + 1
         ii = ii + i
         write(pu,1270) i, (v(j), j = i1, ii)
 270     continue
 1270 format(' ROW',i3,2x,5e12.4/(9x,5e12.4))
!
 999  return
      end subroutine itsmry
!VCOPY
      subroutine vcopy(p, y, x)
!
!  ***  SET Y = X, WHERE X AND Y ARE P-VECTORS  ***
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer p
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: x(*),y(*)
!
!  LOCAL SCALARS
      integer i
!
!
      do i = 1, p
        y(i) = x(i)
      enddo

      end subroutine vcopy
!PARCHK
      subroutine parchk(iv, n, nn, p, v)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!  ***  CHECK NL2SOL (VERSION 2.2) PARAMETERS, PRINT CHANGED VALUES  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n,nn,p
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   v(33)
     integer&
     &   iv(21)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   big,machep,tiny,vk,zero
     integer&
    &   d0init,dtype,dtype0,epslon,i,ich,inits,iv1,jtinit,jtol0,&
    &   jtol1,jtolp,k,l,m,nvdflt,oldn,oldnn,oldp,parprt,parsv1,&
     &   prunit,pu
!
!  LOCAL ARRAYS
     real(kind=wp) ::&
     &   vm(27),vx(27)
     character&
     &   cngd(12)*1,dflt(12)*1,vn(8,27)*1,which(12)*1
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!
!  EXTERNAL SUBROUTINES
!      external dfault,vcopy
!
!     INTEGER IV(21), N, NN, P
!     REAL(KIND=WP) :: V(33)
!     DIMENSION IV(*), V(*)
!
!     EXTERNAL DFAULT, VCOPY
! DFAULT -- SUPPLIES DFAULT PARAMETER VALUES.
! RMDCON -- RETURNS MACHINE-DEPENDENT CONSTANTS.
! VCOPY  -- COPIES ONE VECTOR TO ANOTHER.
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER I, IV1, JTOLP, K, L, M, NVDFLT, PU
!     CHARACTER*1 CNGD(12), WHICH(12)
!     CHARACTER*1 DFLT(12), VN(8,27)
!     REAL(KIND=WP) :: BIG, MACHEP, TINY, VK, VM(27), VX(27), ZERO
!
!  ***  IV AND V SUBSCRIPTS  ***
!
!     INTEGER DTYPE, DTYPE0, D0INIT, EPSLON, INITS, JTINIT, JTOL0,
!    1        JTOL1, OLDN, OLDNN, OLDP, PARPRT, PARSV1, PRUNIT
!
      data big/0.0_wp/, nvdflt/27/, tiny/1.0_wp/, zero/0.0_wp/
!
     data dtype/16/, dtype0/29/, d0init/37/, epslon/19/,&
    &     inits/25/, jtinit/39/, jtol0/86/, jtol1/87/,&
    &     oldn/45/, oldnn/46/, oldp/47/, parprt/20/,&
     &     parsv1/51/, prunit/21/
!
     data&
    & vn(1,1),vn(2,1),vn(3,1),vn(4,1),vn(5,1),vn(6,1),vn(7,1),vn(8,1)&
     &   /'E',    'P',    'S',    'L',    'O',    'N',    '.',    '.'/
     data&
    & vn(1,2),vn(2,2),vn(3,2),vn(4,2),vn(5,2),vn(6,2),vn(7,2),vn(8,2)&
     &   /'P',    'H',    'M',    'N',    'F',    'C',    '.',    '.'/
     data&
    & vn(1,3),vn(2,3),vn(3,3),vn(4,3),vn(5,3),vn(6,3),vn(7,3),vn(8,3)&
     &   /'P',    'H',    'M',    'X',    'F',    'C',    '.',    '.'/
     data&
    & vn(1,4),vn(2,4),vn(3,4),vn(4,4),vn(5,4),vn(6,4),vn(7,4),vn(8,4)&
     &   /'D',    'E',    'C',    'F',    'A',    'C',    '.',    '.'/
     data&
    & vn(1,5),vn(2,5),vn(3,5),vn(4,5),vn(5,5),vn(6,5),vn(7,5),vn(8,5)&
     &   /'I',    'N',    'C',    'F',    'A',    'C',    '.',    '.'/
     data&
    & vn(1,6),vn(2,6),vn(3,6),vn(4,6),vn(5,6),vn(6,6),vn(7,6),vn(8,6)&
     &   /'R',    'D',    'F',    'C',    'M',    'N',    '.',    '.'/
     data&
    & vn(1,7),vn(2,7),vn(3,7),vn(4,7),vn(5,7),vn(6,7),vn(7,7),vn(8,7)&
     &   /'R',    'D',    'F',    'C',    'M',    'X',    '.',    '.'/
     data&
    & vn(1,8),vn(2,8),vn(3,8),vn(4,8),vn(5,8),vn(6,8),vn(7,8),vn(8,8)&
     &   /'T',    'U',    'N',    'E',    'R',    '1',    '.',    '.'/
     data&
    & vn(1,9),vn(2,9),vn(3,9),vn(4,9),vn(5,9),vn(6,9),vn(7,9),vn(8,9)&
     &   /'T',    'U',    'N',    'E',    'R',    '2',    '.',    '.'/
     data&
    & vn(1,10),vn(2,10),vn(3,10),vn(4,10),vn(5,10),vn(6,10),vn(7,10),&
    & vn(8,10)&
     &   /'T',    'U',    'N',    'E',    'R',    '3',    '.',    '.'/
     data&
    & vn(1,11),vn(2,11),vn(3,11),vn(4,11),vn(5,11),vn(6,11),vn(7,11),&
    & vn(8,11)&
     &   /'T',    'U',    'N',    'E',    'R',    '4',    '.',    '.'/
     data&
    & vn(1,12),vn(2,12),vn(3,12),vn(4,12),vn(5,12),vn(6,12),vn(7,12),&
    & vn(8,12)&
     &   /'T',    'U',    'N',    'E',    'R',    '5',    '.',    '.'/
     data&
    & vn(1,13),vn(2,13),vn(3,13),vn(4,13),vn(5,13),vn(6,13),vn(7,13),&
    & vn(8,13)&
     &   /'A',    'F',    'C',    'T',    'O',    'L',    '.',    '.'/
     data&
    & vn(1,14),vn(2,14),vn(3,14),vn(4,14),vn(5,14),vn(6,14),vn(7,14),&
    & vn(8,14)&
     &   /'R',    'F',    'C',    'T',    'O',    'L',    '.',    '.'/
     data&
    & vn(1,15),vn(2,15),vn(3,15),vn(4,15),vn(5,15),vn(6,15),vn(7,15),&
    & vn(8,15)&
     &   /'X',    'C',    'T',    'O',    'L',    '.',    '.',    '.'/
     data&
    & vn(1,16),vn(2,16),vn(3,16),vn(4,16),vn(5,16),vn(6,16),vn(7,16),&
    & vn(8,16)&
     &   /'X',    'F',    'T',    'O',    'L',    '.',    '.',    '.'/
     data&
    & vn(1,17),vn(2,17),vn(3,17),vn(4,17),vn(5,17),vn(6,17),vn(7,17),&
    & vn(8,17)&
     &   /'L',    'M',    'A',    'X',    '0',    '.',    '.',    '.'/
     data&
    & vn(1,18),vn(2,18),vn(3,18),vn(4,18),vn(5,18),vn(6,18),vn(7,18),&
    & vn(8,18)&
     &   /'D',    'L',    'T',    'F',    'D',    'J',    '.',    '.'/
     data&
    & vn(1,19),vn(2,19),vn(3,19),vn(4,19),vn(5,19),vn(6,19),vn(7,19),&
    & vn(8,19)&
     &   /'D',    '0',    'I',    'N',    'I',    'T',    '.',    '.'/
     data&
    & vn(1,20),vn(2,20),vn(3,20),vn(4,20),vn(5,20),vn(6,20),vn(7,20),&
    & vn(8,20)&
     &   /'D',    'I',    'N',    'I',    'T',    '.',    '.',    '.'/
     data&
    & vn(1,21),vn(2,21),vn(3,21),vn(4,21),vn(5,21),vn(6,21),vn(7,21),&
    & vn(8,21)&
     &   /'J',    'T',    'I',    'N',    'I',    'T',    '.',    '.'/
     data&
    & vn(1,22),vn(2,22),vn(3,22),vn(4,22),vn(5,22),vn(6,22),vn(7,22),&
    & vn(8,22)&
     &   /'D',    'L',    'T',    'F',    'D',    'C',    '.',    '.'/
     data&
    & vn(1,23),vn(2,23),vn(3,23),vn(4,23),vn(5,23),vn(6,23),vn(7,23),&
    & vn(8,23)&
     &   /'D',    'F',    'A',    'C',    '.',    '.',    '.',    '.'/
     data&
    & vn(1,24),vn(2,24),vn(3,24),vn(4,24),vn(5,24),vn(6,24),vn(7,24),&
    & vn(8,24)&
     &   /'R',    'L',    'I',    'M',    'I',    'T',    '.',    '.'/
     data&
    & vn(1,25),vn(2,25),vn(3,25),vn(4,25),vn(5,25),vn(6,25),vn(7,25),&
    & vn(8,25)&
     &   /'C',    'O',    'S',    'M',    'I',    'N',    '.',    '.'/
     data&
    & vn(1,26),vn(2,26),vn(3,26),vn(4,26),vn(5,26),vn(6,26),vn(7,26),&
    & vn(8,26)&
     &   /'D',    'E',    'L',    'T',    'A',    '0',    '.',    '.'/
     data&
    & vn(1,27),vn(2,27),vn(3,27),vn(4,27),vn(5,27),vn(6,27),vn(7,27),&
    & vn(8,27)&
     &   /'F',    'U',    'Z',    'Z',    '.',    '.',    '.',    '.'/
!
     data vm(1)/1.0e-3_wp/, vm(2)/-0.99_wp/, vm(3)/1.0e-3_wp/,&
    &     vm(4)/1.0e-2_wp/,&
    &     vm(5)/1.2_wp/, vm(6)/1.0e-2_wp/, vm(7)/1.2_wp/,&
    &     vm(8)/0.0_wp/,&
    &     vm(9)/0.0_wp/, vm(10)/1.0e-3_wp/, vm(11)/-1.0_wp/,&
    &     vm(15)/0.0_wp/,&
    &     vm(16)/0.0_wp/, vm(19)/0.0_wp/, vm(20)/-10.0_wp/,&
    &     vm(21)/0.0_wp/,&
     &     vm(23)/0.0_wp/, vm(24)/1.0e10_wp/, vm(27)/1.01_wp/
     data vx(1)/0.9_wp/, vx(2)/-1.0e-3_wp/, vx(3)/1.0e1_wp/,&
    &     vx(4)/0.8_wp/,&
    &     vx(5)/1.0e2_wp/, vx(6)/0.8_wp/, vx(7)/1.0e2_wp/,&
    &     vx(8)/0.5_wp/,&
    &     vx(9)/0.5_wp/, vx(10)/1.0_wp/, vx(11)/1.0_wp/,&
    &     vx(14)/0.1_wp/,&
    &     vx(15)/1.0_wp/, vx(16)/1.0_wp/, vx(18)/1.0_wp/,&
    &     vx(22)/1.0_wp/,&
    &     vx(23)/1.0_wp/, vx(25)/1.0_wp/, vx(26)/1.0_wp/,&
     &     vx(27)/1.0e2_wp/
!
     data cngd(1), cngd(2), cngd(3), cngd(4), cngd(5), cngd(6)&
     &   /     '-',     '-',     '-',     'C',     'H',     'A'/
     data cngd(7), cngd(8), cngd(9), cngd(10), cngd(11), cngd(12)&
     &   /     'N',     'G',     'E',     'D',     ' ',     'V'/
     data dflt(1), dflt(2), dflt(3), dflt(4), dflt(5), dflt(6)&
     &   /     'N',     'O',     'N',     'D',     'E',     'F'/
     data dflt(7), dflt(8), dflt(9), dflt(10), dflt(11), dflt(12)&
     &   /     'A',     'U',     'L',     'T',     ' ',     'V'/
!
!.......................................................................
!
      if (iv(1) .eq. 0) call dfault(iv, v)
      pu = iv(prunit)
      iv1 = iv(1)
      if (iv1 .ne. 12) go to 30
         if (nn .ge. n .and. n .ge. p .and. p .ge. 1) go to 20
              iv(1) = 16
              if (pu .ne. 0) write(pu,10) nn, n, p
10           format(30h0///// bad nn, n, or p... nn =,i5,5h, n =,i5,&
     &               5h, p =,i5)
              go to 999
 20      k = iv(21)
         call dfault(iv(21), v(33))
         iv(21) = k
         iv(dtype0) = iv(dtype+20)
         iv(oldn) = n
         iv(oldnn) = nn
         iv(oldp) = p
         do 25 ich = 1, 12
            which(ich) = dflt(ich)
 25      continue
         go to 80
30   if (n .eq. iv(oldn) .and. nn .eq. iv(oldnn) .and. p .eq. iv(oldp))&
     &                       go to 50
         iv(1) = 17
        if (pu .ne. 0) write(pu,40) iv(oldnn), iv(oldn), iv(oldp), nn,&
     &                               n, p
40      format('0///// (NN,N,P) CHANGED FROM (',i5,',',i5,',',i3,&
     &          ') TO (',i5,',',i5,',',i3,').')
         go to 999
!
 50   if (iv1 .le. 11 .and. iv1 .ge. 1) go to 70
         iv(1) = 50
         if (pu .ne. 0) write(pu,60) iv1
 60      format('0/////  IV(1) =',i5,' SHOULD BE BETWEEN 0 AND 12.')
         go to 999
!
 70   do 75 ich = 1, 12
         which(ich) = cngd(ich)
 75   continue
!
 80   if (big .gt. tiny) go to 90
         tiny = rmdcon(1,typ=0.0_wp)
         machep = rmdcon(3,typ=0.0_wp)
         big = rmdcon(6,typ=0.0_wp)
         vm(12) = machep
         vx(12) = big
         vm(13) = tiny
         vx(13) = big
         vm(14) = machep
         vm(17) = tiny
         vx(17) = big
         vm(18) = machep
         vx(19) = big
         vx(20) = big
         vx(21) = big
         vm(22) = machep
         vx(24) = rmdcon(5,typ=0.0_wp)
         vm(25) = machep
         vm(26) = machep
 90   m = 0
      if (iv(inits) .ge. 0 .and. iv(inits) .le. 2) go to 110
         m = 18
         if (pu .ne. 0) write(pu,100) iv(inits)
100     format(25h0/////  inits... iv(25) =,i4,20h should be between 0,&
     &          7h and 2.)
 110  k = epslon
      do 140 i = 1, nvdflt
         vk = v(k)
         if (vk .ge. vm(i) .and. vk .le. vx(i)) go to 130
              m = k
          if (pu .ne. 0) write(pu,120) (vn(ich, i), ich=1, 8),&
    &                                  (vn(ich, i), ich=1, 8),&
     &                                  k, vk, vm(i), vx(i)
120          format(8h0/////  ,8a1,5h.. v(,i2,3h) =,e11.3,7h should,&
     &               ' BE BETWEEN',e11.3,4h and,e11.3)
 130     k = k + 1
 140     continue
!
      if (iv1 .eq. 12 .and. v(jtinit) .gt. zero) go to 170
!
!  ***  CHECK JTOL VALUES  ***
!
      jtolp = jtol0 + p
      do 160 i = jtol1, jtolp
         if (v(i) .gt. zero) go to 160
         k = i - jtol0
         if (pu .ne. 0) write(pu,150) k, i, v(i)
150     format(12h0///// jtol(,i3,6h) = v(,i3,3h) =,e11.3,&
     &          20h should be positive.)
         m = i
 160     continue
!
 170  if (m .eq. 0) go to 180
         iv(1) = m
         go to 999
!
 180  if (pu .eq. 0 .or. iv(parprt) .eq. 0) go to 999
      if (iv1 .ne. 12 .or. iv(inits) .eq. 0) go to 200
         m = 1
         write(pu,190) iv(inits)
 190     format(22h0nondefault values..../20h inits..... iv(25) =,i3)
 200  if (iv(dtype) .eq. iv(dtype0)) go to  210
         if (m .eq. 0) write(pu,215) (which(ich), ich=1, 12)
         m = 1
         write(pu,205) iv(dtype)
 205     format(20h dtype..... iv(16) =,i3)
 210  k = epslon
      l = parsv1
      do 240 i = 1, nvdflt
         if (v(k) .eq. v(l)) go to 230
              if (m .eq. 0) write(pu,215) (which(ich), ich = 1, 12)
 215          format ('0',12a1,'ALUES....'/)
              m = 1
              write (pu,220) (vn(ich, i), ich = 1, 8), k, v(k)
 220          format (1x, 8a1, 5h.. v(, i2, 3h) =, e15.7)
 230     k = k + 1
         l = l + 1
 240     continue
      iv(dtype0) = iv(dtype)
      call vcopy(nvdflt, v(parsv1), v(epslon))
      if (iv1 .ne. 12) go to 999
         if (v(jtinit) .gt. zero) go to 260
              jtolp = jtol0 + p
              write(pu,250) (v(i), i = jtol1, jtolp)
 250          format(24h0(initial) jtol array.../(1x,6e12.3))
 260     if (v(d0init) .gt. zero) go to 999
              k = jtol1 + p
              l = k + p - 1
              write(pu,270) (v(i), i = k, l)
 270          format(22h0(initial) d0 array.../1x,6e12.3)
!
 999  return

      end subroutine parchk
!NL2X
      subroutine nl2x(typ)
      real(kind=wp),intent(in) :: typ
!     ***  TEST NL2SOL AND NL2SNO ON MADSEN EXAMPLE  ***
!
!  VARIABLE DECLARATIONS
!
!  LOCAL ARRAYS
      real(kind=wp) :: urparm(1), v(147), x(2)
      integer       :: iv(62), uiparm(1)
!
!  EXTERNAL SUBROUTINES
      external madj, madr, nl2sno, nl2sol, ufparm
!
      x(1) = 3.0_wp
      x(2) = 1.0_wp
      iv(1) = 0
      call nl2sol(3, 2, x, madr, madj, iv, v, uiparm, urparm, ufparm)
      iv(1) = 12
      x(1) = 3.0_wp
      x(2) = 1.0_wp
      call nl2sno(3, 2, x, madr, iv, v, uiparm, urparm, ufparm)

      end subroutine nl2x
!COVCLC
      subroutine covclc(covirc, d, iv, j, n, nn, p, r, v, x)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  COMPUTE COVARIANCE MATRIX FOR NL2ITR (NL2SOL VERSION 2.2)  ***
!
!  ***  LET K = ABS(IV(COVREQ).  FOR K .LE. 2, A FINITE-DIFFERENCE
!  ***  HESSIAN H IS COMPUTED (USING FUNC. AND GRAD. VALUES IF
!  ***  IV(COVREQ) IS NONNEGATIVE, AND USING ONLY FUNC. VALUES IF
!  ***  IV(COVREQ) IS NEGATIVE).  FOR SCALE = 2*F(X) / MAX(1, N-P),
!  ***  WHERE 2*F(X) IS THE RESIDUAL SUM OF SQUARES, COVCLC COMPUTES...
!  ***             K = 0 OR 1...  SCALE * H**-1 * (J**T * J) * H**-1.
!  ***             K = 2...  SCALE * H**-1.
!  ***             K .GE. 3...  SCALE * (J**T * J)**-1.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer covirc,n,nn,p
!
!  ARRAY ARGUMENTS
     real(kind=wp) :: d(p),j(nn,p),r(n),v(1),x(p)
     integer iv(1)
!
!  LOCAL SCALARS
     real(kind=wp) :: del,half,negpt5,one,t,two,wk,zero
     integer&
    &   cov,covmat,covreq,delta,delta0,dltfdc,f,fx,g,g1,gp,gsave1,&
    &   h,hc,hmi,hpi,hpm,i,ierr,ip1,ipiv0,ipivi,ipivk,ipivot,irc,&
    &   k,kagqt,kalm,kind,kl,l,lmat,m,mm1,mm1o2,mode,nfgcal,pp1o2,&
    &   qtr,qtr1,rd,rd1,rsave,savei,stp0,stpi,stpm,switch,toobig,&
     &   w,w0,w1,wl,xmsave
     logical&
     &   havej
!
!  EXTERNAL SUBROUTINES
!      external linvrt,litvmu,livmul,lsqrt,ltsqar,qrfact,vcopy,vscopy
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER COVIRC, IV(1), N, NN, P
!     REAL(KIND=WP) :: D(P), J(NN,P), R(N), V(1), X(P)
!     DIMENSION IV(*), V(*)
!
!  ***  LOCAL VARIABLES  ***
!
!     LOGICAL HAVEJ
!     INTEGER COV, GP, GSAVE1, G1, HC, HMI, HPI, HPM, I, IPIVI, IPIVK,
!    1        IP1, IRC, K, KIND, KL, L, M, MM1, MM1O2, PP1O2, QTR1,
!    2        RD1, STPI, STPM, STP0, WL, W0, W1
!     REAL(KIND=WP) :: DEL, HALF, NEGPT5, ONE, T, TWO, WK, ZERO
!
!/
!  ***  EXTERNAL SUBROUTINES  ***
!
!     EXTERNAL LINVRT, LITVMU, LIVMUL, LSQRT, LTSQAR, QRFACT,
!    1         VCOPY, VSCOPY
!
! LINVRT... INVERT LOWER TRIANGULAR MATRIX.
! LITVMU... APPLY INVERSE-TRANSPOSE OF COMPACT LOWER TRIANG. MATRIX.
! LIVMUL... APPLY INVERSE OF COMPACT LOWER TRIANG. MATRIX.
! LSQRT.... COMPUTE CHOLESKY FACTOR OF (LOWER TRINAG. OF) A SYM. MATRIX.
! LTSQAR... GIVEN LOWER TRIANG. MATRIX L, COMPUTE (L**T)*L.
! QRFACT... COMPUTE QR DECOMPOSITION OF A MATRIX.
! VCOPY.... COPY ONE VECTOR TO ANOTHER.
! VSCOPY... SET ALL ELEMENTS OF A VECTOR TO A SCALAR.
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER COVMAT, COVREQ, DELTA, DELTA0, DLTFDC, F, FX, G, H, IERR,
!    1        IPIVOT, IPIV0, KAGQT, KALM, LMAT, MODE, NFGCAL, QTR,
!    2        RD, RSAVE, SAVEI, SWITCH, TOOBIG, W, XMSAVE
!
     data half/0.5_wp/, negpt5/-0.5_wp/, one/1.0_wp/, two/2.0_wp/,&
     &     zero/0.0_wp/
!
     data covmat/26/, covreq/15/, delta/50/, delta0/44/,&
    &     dltfdc/40/, f/10/, fx/46/, g/28/, h/44/, ierr/32/,&
    &     ipivot/61/, ipiv0/60/, kagqt/35/, kalm/36/,&
    &     lmat/58/, mode/38/, nfgcal/7/, qtr/49/,&
    &     rd/51/, rsave/52/, savei/54/, switch/12/,&
     &     toobig/2/, w/59/, xmsave/49/
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
      cov = iv(lmat)
!
      covirc = 4
      kind = iv(covreq)
      m = iv(mode)
      if (m .gt. 0) go to 10
         iv(kagqt) = -1
         if (iv(kalm) .gt. 0) iv(kalm) = 0
         if (abs(kind) .ge. 3) go to 300
         v(fx) = v(f)
         k = iv(rsave)
         call vcopy(n, v(k), r)
 10   if (m .gt. p) go to 200
      if (kind .lt. 0) go to 100
!
!  ***  COMPUTE FINITE-DIFFERENCE HESSIAN USING BOTH FUNCTION AND
!  ***  GRADIENT VALUES.
!
      gsave1 = iv(w) + p
      g1 = iv(g)
      if (m .gt. 0) go to 15
!        ***  FIRST CALL ON COVCLC.  SET GSAVE = G, TAKE FIRST STEP  ***
         call vcopy(p, v(gsave1), v(g1))
         iv(switch) = iv(nfgcal)
         go to 80
!
 15   del = v(delta)
      x(m) = v(xmsave)
      if (iv(toobig) .eq. 0) go to 30
!
!     ***  HANDLE OVERSIZE V(DELTA)  ***
!
         if (del*x(m) .gt. zero) go to 20
!             ***  WE ALREADY TRIED SHRINKING V(DELTA), SO QUIT  ***
              iv(covmat) = -2
              go to 190
!
!        ***  TRY SHRINKING V(DELTA)  ***
 20      del = negpt5 * del
         go to 90
!
 30   cov = iv(lmat)
      gp = g1 + p - 1
!
!  ***  SET  G = (G - GSAVE)/DEL  ***
!
      do i = g1, gp
         v(i) = (v(i) - v(gsave1)) / del
         gsave1 = gsave1 + 1
      enddo
!
!  ***  ADD G AS NEW COL. TO FINITE-DIFF. HESSIAN MATRIX  ***
!
      k = cov + m*(m-1)/2
      l = k + m - 2
      if ( m .eq. 1) go to 60
!
!  ***  SET  H(I,M) = 0.5 * (H(I,M) + G(I))  FOR I = 1 TO M-1  ***
!
      do i = k, l
         v(i) = half * (v(i) + v(g1))
         g1 = g1 + 1
      enddo
!
!  ***  ADD  H(I,M) = G(I)  FOR I = M TO P  ***
!
 60   l = l + 1
      do i = m, p
         v(l) = v(g1)
         l = l + i
         g1 = g1 + 1
      enddo
!
 80   m = m + 1
      iv(mode) = m
      if (m .gt. p) go to 190
!
!  ***  CHOOSE NEXT FINITE-DIFFERENCE STEP, RETURN TO GET G THERE  ***
!
      del = v(delta0) * max(one/d(m), abs(x(m)))
      if (x(m) .lt. zero) del = -del
      v(xmsave) = x(m)
 90   x(m) = x(m) + del
      v(delta) = del
      covirc = 2
      go to 999
!
!  ***  COMPUTE FINITE-DIFFERENCE HESSIAN USING FUNCTION VALUES ONLY.
!
 100  stp0 = iv(w) + p - 1
      mm1 = m - 1
      mm1o2 = m*mm1/2
      if (m .gt. 0) go to 105
!        ***  FIRST CALL ON COVCLC.  ***
         iv(savei) = 0
         go to 180
!
 105  i = iv(savei)
      if (i .gt. 0) go to 160
      if (iv(toobig) .eq. 0) go to 120
!
!     ***  HANDLE OVERSIZE STEP  ***
!
         stpm = stp0 + m
         del = v(stpm)
         if (del*x(xmsave) .gt. zero) go to 110
!             ***  WE ALREADY TRIED SHRINKING THE STEP, SO QUIT  ***
              iv(covmat) = -2
              go to 999
!
!        ***  TRY SHRINKING THE STEP  ***
 110     del = negpt5 * del
         x(m) = x(xmsave) + del
         v(stpm) = del
         covirc = 1
         go to 999
!
!  ***  SAVE F(X + STP(M)*E(M)) IN H(P,M)  ***
!
 120  pp1o2 = p * (p-1) / 2
      cov = iv(lmat)
      hpm = cov + pp1o2 + mm1
      v(hpm) = v(f)
!
!  ***  START COMPUTING ROW M OF THE FINITE-DIFFERENCE HESSIAN H.  ***
!
      hmi = cov + mm1o2
      if (mm1 .eq. 0) go to 140
      hpi = cov + pp1o2
      do i = 1, mm1
         v(hmi) = v(fx) - (v(f) + v(hpi))
         hmi = hmi + 1
         hpi = hpi + 1
      enddo
 140  v(hmi) = v(f) - two*v(fx)
!
!  ***  COMPUTE FUNCTION VALUES NEEDED TO COMPLETE ROW M OF H.  ***
!
      i = 1
!
 150  iv(savei) = i
      stpi = stp0 + i
      v(delta) = x(i)
      x(i) = x(i) + v(stpi)
      if (i .eq. m) x(i) = v(xmsave) - v(stpi)
      covirc = 1
      go to 999
!
 160  x(i) = v(delta)
      if (iv(toobig) .eq. 0) go to 170
!        ***  PUNT IN THE EVENT OF AN OVERSIZE STEP  ***
         iv(covmat) = -2
         go to 999
!
!  ***  FINISH COMPUTING H(M,I)  ***
!
 170  stpi = stp0 + i
      hmi = cov + mm1o2 + i - 1
      stpm = stp0 + m
      v(hmi) = (v(hmi) + v(f)) / (v(stpi)*v(stpm))
      i = i + 1
      if (i .le. m) go to 150
      iv(savei) = 0
      x(m) = v(xmsave)
!
 180  m = m + 1
      iv(mode) = m
      if (m .gt. p) go to 190
!
!  ***  PREPARE TO COMPUTE ROW M OF THE FINITE-DIFFERENCE HESSIAN H.
!  ***  COMPUTE M-TH STEP SIZE STP(M), THEN RETURN TO OBTAIN
!  ***  F(X + STP(M)*E(M)), WHERE E(M) = M-TH STD. UNIT VECTOR.
!
      del = v(dltfdc) * max(one/d(m), abs(x(m)))
      if (x(m) .lt. zero) del = -del
      v(xmsave) = x(m)
      x(m) = x(m) + del
      stpm = stp0 + m
      v(stpm) = del
      covirc = 1
      go to 999
!
!  ***  RESTORE R, V(F), ETC.  ***
!
 190  k = iv(rsave)
      call vcopy(n, r, v(k))
      v(f) = v(fx)
      if (kind .lt. 0) go to 200
         iv(nfgcal) = iv(switch)
         qtr1 = iv(qtr)
         call vcopy(n, v(qtr1), r)
         if (iv(covmat) .lt. 0) go to 999
         covirc = 3
         go to 999
!
 200  cov = iv(lmat)
!
!  ***  THE COMPLETE FINITE-DIFF. HESSIAN IS NOW STORED AT V(COV).   ***
!  ***  USE IT TO COMPUTE THE REQUESTED COVARIANCE MATRIX.           ***
!
!     ***  COMPUTE CHOLESKY FACTOR C OF H = C*(C**T)  ***
!     ***  AND STORE IT AT V(HC).  ***
!
      hc = cov
      if (abs(kind) .eq. 2) go to 210
         hc = abs(iv(h))
         iv(h) = -hc
 210  call lsqrt(1, p, v(hc), v(cov), irc)
      iv(covmat) = -1
      if (irc .ne. 0) go to 999
!
      w1 = iv(w) + p
      if (abs(kind) .gt. 1) go to 350
!
!  ***  COVARIANCE = SCALE * H**-1 * (J**T * J) * H**-1  ***
!
      call vscopy(p*(p+1)/2, v(cov), zero)
      havej = iv(kalm) .eq. (-1)
!     ***  HAVEJ = .TRUE. MEANS J IS IN ITS ORIGINAL FORM, WHILE
!     ***  HAVEJ = .FALSE. MEANS QRFACT HAS BEEN APPLIED TO J.
!
      m = p
      if (havej) m = n
      w0 = w1 - 1
      rd1 = iv(rd)
      do 290 i = 1, m
         if (havej) go to 240
!
!        ***  SET W = IPIVOT * (ROW I OF R MATRIX FROM QRFACT).  ***
!
              call vscopy(p, v(w1), zero)
              ipivi = ipiv0 + i
              l = w0 + iv(ipivi)
              v(l) = v(rd1)
              rd1 = rd1 + 1
              if (i .eq. p) go to 260
              ip1 = i + 1
              do 230 k = ip1, p
                   ipivk = ipiv0 + k
                   l = w0 + iv(ipivk)
                   v(l) = j(i,k)
 230               continue
              go to 260
!
!        ***  SET W = (ROW I OF J).  ***
!
 240     l = w0
         do 250 k = 1, p
              l = l + 1
              v(l) = j(i,k)
 250          continue
!
!        ***  SET W = H**-1 * W.  ***
!
 260     call livmul(p, v(w1), v(hc), v(w1))
         call litvmu(p, v(w1), v(hc), v(w1))
!
!        ***  ADD  W * W**T  TO COVARIANCE MATRIX.  ***
!
         kl = cov
         do 280 k = 1, p
              l = w0 + k
              wk = v(l)
              do 270 l = 1, k
                   wl = w0 + l
                   v(kl) = v(kl)  +  wk * v(wl)
                   kl = kl + 1
 270               continue
 280          continue
 290     continue
      go to 380
!
!  ***  COVARIANCE = SCALE * (J**T * J)**-1.  ***
!
 300  rd1 = iv(rd)
      if (iv(kalm) .ne. (-1)) go to 310
!
!        ***  APPLY QRFACT TO J  ***
!
         qtr1 = iv(qtr)
         call vcopy(n, v(qtr1), r)
         w1 = iv(w) + p
        call qrfact(nn, n, p, j, v(rd1), iv(ipivot), iv(ierr), 0,&
     &               v(w1))
         iv(kalm) = -2
 310  iv(covmat) = -1
      if (iv(ierr) .ne. 0) go to 999
      cov = iv(lmat)
      hc = abs(iv(h))
      iv(h) = -hc
!
!     ***  SET HC = (R MATRIX FROM QRFACT).  ***
!
      l = hc
      do 340 i = 1, p
         if (i .gt. 1) call vcopy(i-1, v(l), j(1,i))
         l = l + i - 1
         v(l) = v(rd1)
         l = l + 1
         rd1 = rd1 + 1
 340     continue
!
!  ***  THE CHOLESKY FACTOR C OF THE UNSCALED INVERSE COVARIANCE MATRIX
!  ***  (OR PERMUTATION THEREOF) IS STORED AT V(HC).
!
!  ***  SET C = C**-1.
!
 350  call linvrt(p, v(hc), v(hc))
!
!  ***  SET C = C**T * C.
!
      call ltsqar(p, v(hc), v(hc))
!
      if (hc .eq. cov) go to 380
!
!     ***  C = PERMUTED, UNSCALED COVARIANCE.
!     ***  SET COV = IPIVOT * C * IPIVOT**T.
!
         do i = 1, p
              m = ipiv0 + i
              ipivi = iv(m)
              kl = cov-1 + ipivi*(ipivi-1)/2
              do k = 1, i
                   m = ipiv0 + k
                   ipivk = iv(m)
                   l = kl + ipivk
                  if (ipivk .gt. ipivi)&
     &                       l = l + (ipivk-ipivi)*(ipivk+ipivi-3)/2
                   v(l) = v(hc)
                   hc = hc + 1
              enddo
         enddo
!
 380  continue
      iv(covmat) = cov
!
!  ***  APPLY SCALE FACTOR = (RESID. SUM OF SQUARES) / MAX(1,N-P).
!
      t = v(f) / (half * max(1,n-p))
      k = cov - 1 + p*(p+1)/2
      do i = cov, k
         v(i) = t * v(i)
      enddo
!
 999  return
      end subroutine covclc
!LSVMIN
      real(kind=wp) function lsvmin(p, l, x, y)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  ESTIMATE SMALLEST SING. VALUE OF PACKED LOWER TRIANG. MATRIX L
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   p
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   l(1),x(p),y(p)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   b,half,one,psj,r9973,sminus,splus,t,xminus,xplus,zero
     integer&
     &   i,ii,ix,j,j0,ji,jj,jjj,jm1,pplus1
!
!  EXTERNAL FUNCTIONS
!      real(kind=wp) ::
!     &   v2norm
!      external v2norm
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,mod
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER P
!     REAL(KIND=WP) :: L(1), X(P), Y(P)
!     DIMENSION L(P*(P+1)/2)
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  ***  PURPOSE  ***
!
!     THIS FUNCTION RETURNS A GOOD OVER-ESTIMATE OF THE SMALLEST
!     SINGULAR VALUE OF THE PACKED LOWER TRIANGULAR MATRIX L.
!
!  ***  PARAMETER DESCRIPTION  ***
!
!  P (IN)  = THE ORDER OF L.  L IS A  P X P  LOWER TRIANGULAR MATRIX.
!  L (IN)  = ARRAY HOLDING THE ELEMENTS OF  L  IN ROW ORDER, I.E.
!             L(1,1), L(2,1), L(2,2), L(3,1), L(3,2), L(3,3), ETC.
!  X (OUT) IF LSVMIN RETURNS A POSITIVE VALUE, THEN X IS A NORMALIZED
!             APPROXIMATE LEFT SINGULAR VECTOR CORRESPONDING TO THE
!             SMALLEST SINGULAR VALUE.  THIS APPROXIMATION MAY BE VERY
!             CRUDE.  IF LSVMIN RETURNS ZERO, THEN SOME COMPONENTS OF X
!             ARE ZERO AND THE REST RETAIN THEIR INPUT VALUES.
!  Y (OUT) IF LSVMIN RETURNS A POSITIVE VALUE, THEN Y = (L**-1)*X IS AN
!             UNNORMALIZED APPROXIMATE RIGHT SINGULAR VECTOR CORRESPOND-
!             ING TO THE SMALLEST SINGULAR VALUE.  THIS APPROXIMATION
!             MAY BE CRUDE.  IF LSVMIN RETURNS ZERO, THEN Y RETAINS ITS
!             INPUT VALUE.  THE CALLER MAY PASS THE SAME VECTOR FOR X
!             AND Y (NONSTANDARD FORTRAN USAGE), IN WHICH CASE Y OVER-
!             WRITES X (FOR NONZERO LSVMIN RETURNS).
!
!  ***  APPLICATION AND USAGE RESTRICTIONS  ***
!
!     THERE ARE NO USAGE RESTRICTIONS.
!
!  ***  ALGORITHM NOTES  ***
!
!     THE ALGORITHM IS BASED ON (1), WITH THE ADDITIONAL PROVISION THAT
!     LSVMIN = 0 IS RETURNED IF THE SMALLEST DIAGONAL ELEMENT OF L
!     (IN MAGNITUDE) IS NOT MORE THAN THE UNIT ROUNDOFF TIMES THE
!     LARGEST.  THE ALGORITHM USES A RANDOM NUMBER GENERATOR PROPOSED
!     IN (4), WHICH PASSES THE SPECTRAL TEST WITH FLYING COLORS -- SEE
!     (2) AND (3).
!
!  ***  SUBROUTINES AND FUNCTIONS CALLED  ***
!
!        V2NORM - FUNCTION, RETURNS THE 2-NORM OF A VECTOR.
!
!  ***  REFERENCES  ***
!
!     (1) CLINE, A., MOLER, C., STEWART, G., AND WILKINSON, J.H.(1977),
!         AN ESTIMATE FOR THE CONDITION NUMBER OF A MATRIX, REPORT
!         TM-310, APPLIED MATH. DIV., ARGONNE NATIONAL LABORATORY.
!
!     (2) HOAGLIN, D.C. (1976), THEORETICAL PROPERTIES OF CONGRUENTIAL
!         RANDOM-NUMBER GENERATORS --  AN EMPIRICAL VIEW,
!         MEMORANDUM NS-340, DEPT. OF STATISTICS, HARVARD UNIV.
!
!     (3) KNUTH, D.E. (1969), THE ART OF COMPUTER PROGRAMMING, VOL. 2
!         (SEMINUMERICAL ALGORITHMS), ADDISON-WESLEY, READING, MASS.
!
!     (4) SMITH, C.S. (1971), MULTIPLICATIVE PSEUDO-RANDOM NUMBER
!         GENERATORS WITH PRIME MODULUS, J. ASSOC. COMPUT. MACH. 18,
!         PP. 586-593.
!
!  ***  HISTORY  ***
!
!     DESIGNED AND CODED BY DAVID M GAY (WINTER 1977/SUMMER 1978).
!
!  ***  GENERAL  ***
!
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!     MCS-7600324, DCR75-10143, 76-14311DSS, AND MCS76-11989.
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER I, II, IX, J, JI, JJ, JJJ, JM1, J0, PPLUS1
!     REAL(KIND=WP) :: B, PSJ, SMINUS, SPLUS, T, XMINUS, XPLUS
!
!  ***  CONSTANTS  ***
!
!     REAL(KIND=WP) :: HALF, ONE, R9973, ZERO
!
!/
!  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***
!
!     EXTERNAL V2NORM
!     REAL(KIND=WP) :: V2NORM
!
      data ix/2/
      data half/0.5_wp/, one/1.0_wp/, r9973/9973.0_wp/, zero/0.0_wp/
!
!  ***  BODY  ***
!
!  ***  FIRST CHECK WHETHER TO RETURN LSVMIN = 0 AND INITIALIZE X  ***
!
      ii = 0
      do 10 i = 1, p
         x(i) = zero
         ii = ii + i
         if (l(ii) .eq. zero) go to 300
 10      continue
      if (mod(ix, 9973) .eq. 0) ix = 2
      pplus1 = p + 1
!
!  ***  SOLVE (L**T)*X = B, WHERE THE COMPONENTS OF B HAVE RANDOMLY
!  ***  CHOSEN MAGNITUDES IN (.5,1) WITH SIGNS CHOSEN TO MAKE X LARGE.
!
!     DO J = P TO 1 BY -1...
      do 100 jjj = 1, p
         j = pplus1 - jjj
!       ***  DETERMINE X(J) IN THIS ITERATION. NOTE FOR I = 1,2,...,J
!       ***  THAT X(I) HOLDS THE CURRENT PARTIAL SUM FOR ROW I.
         ix = mod(3432*ix, 9973)
         b = half*(one + ix/r9973)
         xplus = (b - x(j))
         xminus = (-b - x(j))
         splus = abs(xplus)
         sminus = abs(xminus)
         jm1 = j - 1
         j0 = j*jm1/2
         jj = j0 + j
         xplus = xplus/l(jj)
         xminus = xminus/l(jj)
         if (jm1 .eq. 0) go to 30
         do 20 i = 1, jm1
              ji = j0 + i
              splus = splus + abs(x(i) + l(ji)*xplus)
              sminus = sminus + abs(x(i) + l(ji)*xminus)
 20           continue
 30      if (sminus .gt. splus) xplus = xminus
         x(j) = xplus
!       ***  UPDATE PARTIAL SUMS  ***
         if (jm1 .eq. 0) go to 100
         do 40 i = 1, jm1
              ji = j0 + i
              x(i) = x(i) + l(ji)*xplus
 40           continue
 100     continue
!
!  ***  NORMALIZE X  ***
!
      t = one/v2norm(p, x)
      do 110 i = 1, p
 110     x(i) = t*x(i)
!
!  ***  SOLVE L*Y = X AND RETURN SVMIN = 1/TWONORM(Y)  ***
!
      do 200 j = 1, p
         psj = zero
         jm1 = j - 1
         j0 = j*jm1/2
         if (jm1 .eq. 0) go to 130
         do 120 i = 1, jm1
              ji = j0 + i
              psj = psj + l(ji)*y(i)
 120          continue
 130     jj = j0 + j
         y(j) = (x(j) - psj)/l(jj)
 200     continue
!
      lsvmin = one/v2norm(p, y)
      go to 999
!
 300  lsvmin = zero
 999  return
      end function lsvmin
!DOTPRD
      real(kind=wp) function dotprd(p, x, y)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  RETURN THE INNER PRODUCT OF THE P-VECTORS X AND Y.  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   p
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   x(*),y(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   one,sqteta,t,zero
     integer&
     &   i
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max
!
!     INTEGER P
!     REAL(KIND=WP) :: X(*), Y(*)
!
!     INTEGER I
!     REAL(KIND=WP) :: ONE, SQTETA, T, ZERO
!/+
!     REAL(KIND=WP) :: MAX, ABS
!/
!
!  ***  RMDCON(2) RETURNS A MACHINE-DEPENDENT CONSTANT, SQTETA, WHICH
!  ***  IS SLIGHTLY LARGER THAN THE SMALLEST POSITIVE NUMBER THAT
!  ***  CAN BE SQUARED WITHOUT UNDERFLOWING.
!
      data one/1.0_wp/, sqteta/0.0_wp/, zero/0.0_wp/
!
      dotprd = zero
      if (p .le. 0) go to 999
      if (sqteta .eq. zero) sqteta = rmdcon(2,typ=0.0_wp)
      do 20 i = 1, p
         t = max(abs(x(i)), abs(y(i)))
         if (t .gt. one) go to 10
         if (t .lt. sqteta) go to 20
         t = (x(i)/sqteta)*y(i)
         if (abs(t) .lt. sqteta) go to 20
 10      dotprd = dotprd + x(i)*y(i)
 20   continue
!
 999  return
      end function dotprd
!MADJ
      subroutine madj(n, p, x, nf, j, uiparm, urparm, ufparm)
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer n,nf,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: j(n,p),urparm(:),x(p)
      integer uiparm(:)
!
!  SUBROUTINE ARGUMENTS
      external ufparm
!
!  INTRINSIC FUNCTIONS
      intrinsic cos,sin
!
      j(1,1) = 2.0_wp*x(1) + x(2)
      j(1,2) = 2.0_wp*x(2) + x(1)
      j(2,1) = cos(x(1))
      j(2,2) = 0.0_wp
      j(3,1) = 0.0_wp
      j(3,2) = -sin(x(2))

      end subroutine madj
!VAXPY
      subroutine vaxpy(p, w, a, x, y)
!
!  ***  SET W = A*X + Y  --  W, X, Y = P-VECTORS, A = SCALAR  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      real(kind=wp) :: a
      integer p
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: w(*),x(*),y(*)
!
!  LOCAL SCALARS
      integer i
!
!
      do i = 1, p
         w(i) = a*x(i) + y(i)
      enddo

      end subroutine vaxpy
!RPTMUL
      subroutine rptmul(func, ipivot, j, nn, p, rd, x, y, z)
!
!  ***  FUNC = 1... SET  Y = RMAT * (PERM**T) * X.
!  ***  FUNC = 2... SET  Y = PERM * (RMAT**T) * RMAT * (PERM**T) * X.
!  ***  FUNC = 3... SET  Y = PERM * (RMAT**T) X.
!
!
!  ***  PERM = MATRIX WHOSE I-TH COL. IS THE IPIVOT(I)-TH UNIT VECTOR.
!  ***  RMAT IS THE UPPER TRIANGULAR MATRIX WHOSE STRICT UPPER TRIANGLE
!  ***       IS STORED IN  J  AND WHOSE DIAGONAL IS STORED IN RD.
!  ***  Z IS A SCRATCH VECTOR.
!  ***  X AND Y MAY SHARE STORAGE.
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   func,nn,p
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   j(nn,p),rd(p),x(p),y(p),z(p)
     integer&
     &   ipivot(p)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   zk
     integer&
     &   i,im1,k,km1
!
!  EXTERNAL FUNCTIONS
!      real(kind=wp) ::
!     &   dotprd
!      external dotprd
!
!
!-----------------------------------------------------------------------
!
      if (func .gt. 2) go to 50
!
!  ***  FIRST SET  Z = (PERM**T) * X  ***
!
      do 10 i = 1, p
         k = ipivot(i)
         z(i) = x(k)
 10      continue
!
!  ***  NOW SET  Y = RMAT * Z  ***
!
      y(1) = z(1) * rd(1)
      if (p .le. 1) go to 40
      do 30 k = 2, p
         km1 = k - 1
         zk = z(k)
         do 20 i = 1, km1
 20           y(i) = y(i) + j(i,k)*zk
         y(k) = zk*rd(k)
 30      continue
!
 40   if (func .le. 1) go to 999
      go to 70
!
 50   do 60 i = 1, p
 60      y(i) = x(i)
!
!  ***  SET  Z = (RMAT**T) * Y  ***
!
 70   z(1) = y(1) * rd(1)
      if (p .eq. 1) go to 90
      do 80 i = 2, p
         im1 = i - 1
         z(i) = y(i)*rd(i) + dotprd(im1, j(1,i), y)
 80      continue
!
!  ***  NOW SET  Y = PERM * Z  ***
!
 90   do 100 i = 1, p
         k = ipivot(i)
         y(k) = z(i)
 100     continue
!
 999  return

      end subroutine rptmul
!SLVMUL
      subroutine slvmul(p, y, s, x)
!
!  ***  SET  Y = S * X,  S = P X P SYMMETRIC MATRIX.  ***
!  ***  LOWER TRIANGLE OF  S  STORED ROWWISE.         ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   p
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   s(1),x(p),y(p)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xi
     integer&
     &   i,im1,j,k
!
!  EXTERNAL FUNCTIONS
!      real(kind=wp) ::
!     &   dotprd
!      external dotprd
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER P
!     REAL(KIND=WP) :: S(1), X(P), Y(P)
!     DIMENSION S(P*(P+1)/2)
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER I, IM1, J, K
!     REAL(KIND=WP) :: XI
!
!  ***  EXTERNAL FUNCTION  ***
!
!     EXTERNAL DOTPRD
!     REAL(KIND=WP) :: DOTPRD
!
!-----------------------------------------------------------------------
!
      j = 1
      do 10 i = 1, p
         y(i) = dotprd(i, s(j), x)
         j = j + i
 10      continue
!
      if (p .le. 1) go to 999
      j = 1
      do 40 i = 2, p
         xi = x(i)
         im1 = i - 1
         j = j + 1
         do 30 k = 1, im1
              y(k) = y(k) + s(j)*xi
              j = j + 1
 30           continue
 40      continue
!
 999  return

      end subroutine slvmul
!LTSQAR
      subroutine ltsqar(n, a, l)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!  ***  SET A TO LOWER TRIANGLE OF (L**T) * L  ***
!
!  ***  L = N X N LOWER TRIANG. MATRIX STORED ROWWISE.  ***
!  ***  A IS ALSO STORED ROWWISE AND MAY SHARE STORAGE WITH L.  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   a(*),l(*)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   lii,lj
     integer&
     &   i,i1,ii,iim1,j,k,m
!
!     INTEGER N
!     REAL(KIND=WP) :: A(1), L(1)
!     DIMENSION A(N*(N+1)/2), L(N*(N+1)/2)
!
!     INTEGER I, II, IIM1, I1, J, K, M
!     REAL(KIND=WP) :: LII, LJ
!
      ii = 0
      do 50 i = 1, n
         i1 = ii + 1
         ii = ii + i
         m = 1
         if (i .eq. 1) go to 30
         iim1 = ii - 1
         do 20 j = i1, iim1
              lj = l(j)
              do 10 k = i1, j
                   a(m) = a(m) + lj*l(k)
                   m = m + 1
 10                continue
 20           continue
 30      lii = l(ii)
         do 40 j = i1, ii
 40           a(j) = lii * l(j)
 50      continue
!
      end subroutine ltsqar
!LITVMU
      subroutine litvmu(n, x, l, y)
!
!  ***  SOLVE  (L**T)*X = Y,  WHERE  L  IS AN  N X N  LOWER TRIANGULAR
!  ***  MATRIX STORED COMPACTLY BY ROWS.  X AND Y MAY OCCUPY THE SAME
!  ***  STORAGE.  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   l(1),x(n),y(n)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   xi,zero
     integer&
     &   i,i0,ii,ij,im1,j,np1
!
      data zero/0.0_wp/
!
      do 10 i = 1, n
 10      x(i) = y(i)
      np1 = n + 1
      i0 = n*(n+1)/2
      do 30 ii = 1, n
         i = np1 - ii
         xi = x(i)/l(i0)
         x(i) = xi
         if (i .le. 1) go to 999
         i0 = i0 - i
         if (xi .eq. zero) go to 30
         im1 = i - 1
         do 20 j = 1, im1
              ij = i0 + j
              x(j) = x(j) - xi*l(ij)
 20           continue
 30      continue
 999  return
      end subroutine litvmu
!GQTSTP
      subroutine gqtstp(d, dig, dihdi, ka, l, p, step, v, w)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  *** COMPUTE GOLDFELD-QUANDT-TROTTER STEP BY MORE-HEBDEN TECHNIQUE ***
!  ***  (NL2SOL VERSION 2.2)  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   ka,p
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   d(p),dig(p),dihdi(1),l(1),step(p),v(21),w(1)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
    &   aki,akk,alphak,delta,dgxfac,dst,epsfac,epso6,four,half,kappa,&
    &   lk,negone,oldphi,one,p001,phi,phimax,phimin,psifac,rad,root,&
     &   si,six,sk,sw,t,t1,three,two,twopsi,uk,wi,zero
     integer&
    &   dggdmx,dgnorm,diag,diag0,dst0,dstnrm,dstsav,emax,emin,&
    &   epslon,gtstep,i,im1,inc,irc,j,k,k1,kalim,lk0,nreduc,&
    &   phipin,phmnfc,phmxfc,preduc,q,q0,rad0,radius,stppar,uk0,x,&
     &   x0
     logical&
     &   restrt
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!      real(kind=wp) ::
!     &   dotprd,lsvmin,v2norm
!      external dotprd,lsvmin,v2norm
!
!  EXTERNAL SUBROUTINES
!      external litvmu,livmul,lsqrt
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max,min,sqrt
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER KA, P
!     REAL(KIND=WP) :: D(P), DIG(P), DIHDI(1), L(1), V(21), STEP(P),
!    1                 W(1)
!     DIMENSION DIHDI(P*(P+1)/2), L(P*(P+1)/2), W(4*P+7)
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  ***  PURPOSE  ***
!
!        GIVEN THE (COMPACTLY STORED) LOWER TRIANGLE OF A SCALED
!     HESSIAN (APPROXIMATION) AND A NONZERO SCALED GRADIENT VECTOR,
!     THIS SUBROUTINE COMPUTES A GOLDFELD-QUANDT-TROTTER STEP OF
!     APPROXIMATE LENGTH V(RADIUS) BY THE MORE-HEBDEN TECHNIQUE.  IN
!     OTHER WORDS, STEP IS COMPUTED TO (APPROXIMATELY) MINIMIZE
!     PSI(STEP) = (G**T)*STEP + 0.5*(STEP**T)*H*STEP  SUCH THAT THE
!     2-NORM OF D*STEP IS AT MOST (APPROXIMATELY) V(RADIUS), WHERE
!     G  IS THE GRADIENT,  H  IS THE HESSIAN, AND  D  IS A DIAGONAL
!     SCALE MATRIX WHOSE DIAGONAL IS STORED IN THE PARAMETER D.
!     (GQTSTP ASSUMES  DIG = D**-1 * G  AND  DIHDI = D**-1 * H * D**-1.)
!     IF G = 0, HOWEVER, STEP = 0 IS RETURNED (EVEN AT A SADDLE POINT).
!
!  ***  PARAMETER DESCRIPTION  ***
!
!     D (IN)  = THE SCALE VECTOR, I.E. THE DIAGONAL OF THE SCALE
!              MATRIX  D  MENTIONED ABOVE UNDER PURPOSE.
!   DIG (IN)  = THE SCALED GRADIENT VECTOR, D**-1 * G.  IF G = 0, THEN
!              STEP = 0  AND  V(STPPAR) = 0  ARE RETURNED.
! DIHDI (IN)  = LOWER TRIANGLE OF THE SCALED HESSIAN (APPROXIMATION),
!              I.E., D**-1 * H * D**-1, STORED COMPACTLY BY ROWS., I.E.,
!              IN THE ORDER (1,1), (2,1), (2,2), (3,1), (3,2), ETC.
!    KA (I/O) = THE NUMBER OF HEBDEN ITERATIONS (SO FAR) TAKEN TO DETER-
!              MINE STEP.  KA .LT. 0 ON INPUT MEANS THIS IS THE FIRST
!              ATTEMPT TO DETERMINE STEP (FOR THE PRESENT DIG AND DIHDI)
!              -- KA IS INITIALIZED TO 0 IN THIS CASE.  OUTPUT WITH
!              KA = 0  (OR V(STPPAR) = 0)  MEANS  STEP = -(H**-1)*G.
!     L (I/O) = WORKSPACE OF LENGTH P*(P+1)/2 FOR CHOLESKY FACTORS.
!     P (IN)  = NUMBER OF PARAMETERS -- THE HESSIAN IS A  P X P  MATRIX.
!  STEP (I/O) = THE STEP COMPUTED.
!     V (I/O) CONTAINS VARIOUS CONSTANTS AND VARIABLES DESCRIBED BELOW.
!     W (I/O) = WORKSPACE OF LENGTH 4*P + 6.
!
!  ***  ENTRIES IN V  ***
!
! V(DGNORM) (I/O) = 2-NORM OF (D**-1)*G.
! V(DSTNRM) (OUTPUT) = 2-NORM OF D*STEP.
! V(DST0)   (I/O) = 2-NORM OF D*(H**-1)*G (FOR POS. DEF. H ONLY), OR
!             OVERESTIMATE OF SMALLEST EIGENVALUE OF (D**-1)*H*(D**-1).
! V(EPSLON) (IN)  = MAX. REL. ERROR ALLOWED FOR PSI(STEP).  FOR THE
!             STEP RETURNED, PSI(STEP) WILL EXCEED ITS OPTIMAL VALUE
!             BY LESS THAN -V(EPSLON)*PSI(STEP).  SUGGESTED VALUE = 0.1.
! V(GTSTEP) (OUT) = INNER PRODUCT BETWEEN G AND STEP.
! V(NREDUC) (OUT) = PSI(-(H**-1)*G) = PSI(NEWTON STEP)  (FOR POS. DEF.
!             H ONLY -- V(NREDUC) IS SET TO ZERO OTHERWISE).
! V(PHMNFC) (IN)  = TOL. (TOGETHER WITH V(PHMXFC)) FOR ACCEPTING STEP
!             (MORE*S SIGMA).  THE ERROR V(DSTNRM) - V(RADIUS) MUST LIE
!             BETWEEN V(PHMNFC)*V(RADIUS) AND V(PHMXFC)*V(RADIUS).
! V(PHMXFC) (IN)  (SEE V(PHMNFC).)
!             SUGGESTED VALUES -- V(PHMNFC) = -0.25, V(PHMXFC) = 0.5.
! V(PREDUC) (OUT) = PSI(STEP) = PREDICTED OBJ. FUNC. REDUCTION FOR STEP.
! V(RADIUS) (IN)  = RADIUS OF CURRENT (SCALED) TRUST REGION.
! V(RAD0)   (I/O) = VALUE OF V(RADIUS) FROM PREVIOUS CALL.
! V(STPPAR) (I/O) IS NORMALLY THE MARQUARDT PARAMETER, I.E. THE ALPHA
!             DESCRIBED BELOW UNDER ALGORITHM NOTES.  IF H + ALPHA*D**2
!             (SEE ALGORITHM NOTES) IS (NEARLY) SINGULAR, HOWEVER,
!             THEN V(STPPAR) = -ALPHA.
!
!  ***  USAGE NOTES  ***
!
!     IF IT IS DESIRED TO RECOMPUTE STEP USING A DIFFERENT VALUE OF
!     V(RADIUS), THEN THIS ROUTINE MAY BE RESTARTED BY CALLING IT
!     WITH ALL PARAMETERS UNCHANGED EXCEPT V(RADIUS).  (THIS EXPLAINS
!     WHY STEP AND W ARE LISTED AS I/O).  ON AN INTIIAL CALL (ONE WITH
!     KA .LT. 0), STEP AND W NEED NOT BE INITIALIZED AND ONLY COMPO-
!     NENTS V(EPSLON), V(STPPAR), V(PHMNFC), V(PHMXFC), V(RADIUS), AND
!     V(RAD0) OF V MUST BE INITIALIZED.  TO COMPUTE STEP FROM A SADDLE
!     POINT (WHERE THE TRUE GRADIENT VANISHES AND H HAS A NEGATIVE
!     EIGENVALUE), A NONZERO G WITH SMALL COMPONENTS SHOULD BE PASSED.
!
!  ***  APPLICATION AND USAGE RESTRICTIONS  ***
!
!     THIS ROUTINE IS CALLED AS PART OF THE NL2SOL (NONLINEAR LEAST-
!     SQUARES) PACKAGE (REF. 1), BUT IT COULD BE USED IN SOLVING ANY
!     UNCONSTRAINED MINIMIZATION PROBLEM.
!
!  ***  ALGORITHM NOTES  ***
!
!        THE DESIRED G-Q-T STEP (REF. 2, 3, 4) SATISFIES
!     (H + ALPHA*D**2)*STEP = -G  FOR SOME NONNEGATIVE ALPHA SUCH THAT
!     H + ALPHA*D**2 IS POSITIVE SEMIDEFINITE.  ALPHA AND STEP ARE
!     COMPUTED BY A SCHEME ANALOGOUS TO THE ONE DESCRIBED IN REF. 5.
!     ESTIMATES OF THE SMALLEST AND LARGEST EIGENVALUES OF THE HESSIAN
!     ARE OBTAINED FROM THE GERSCHGORIN CIRCLE THEOREM ENHANCED BY A
!     SIMPLE FORM OF THE SCALING DESCRIBED IN REF. 6.  CASES IN WHICH
!     H + ALPHA*D**2 IS NEARLY (OR EXACTLY) SINGULAR ARE HANDLED BY
!     THE TECHNIQUE DISCUSSED IN REF. 2.  IN THESE CASES, A STEP OF
!     (EXACT) LENGTH V(RADIUS) IS RETURNED FOR WHICH PSI(STEP) EXCEEDS
!     ITS OPTIMAL VALUE BY LESS THAN -V(EPSLON)*PSI(STEP).
!
!  ***  FUNCTIONS AND SUBROUTINES CALLED  ***
!
! DOTPRD - RETURNS INNER PRODUCT OF TWO VECTORS.
! LITVMU - APPLIES INVERSE-TRANSPOSE OF COMPACT LOWER TRIANG. MATRIX.
! LIVMUL - APPLIES INVERSE OF COMPACT LOWER TRIANG. MATRIX.
! LSQRT  - FINDS CHOLESKY FACTOR (OF COMPACTLY STORED LOWER TRIANG.).
! LSVMIN - RETURNS APPROX. TO MIN. SING. VALUE OF LOWER TRIANG. MATRIX.
! RMDCON - RETURNS MACHINE-DEPENDENT CONSTANTS.
! V2NORM - RETURNS 2-NORM OF A VECTOR.
!
!  ***  REFERENCES  ***
!
! 1.  DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1980), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, (SUBMITTED TO ACM
!             TRANS. MATH. SOFTWARE).
! 2.  GAY, D.M. (1979), COMPUTING OPTIMAL ELLIPTICALLY CONSTRAINED
!             STEPS, MRC TECH. SUMMARY REPORT NO. 2013, MATH. RESEARCH
!             CENTER, UNIV. OF WISCONSIN-MADISON.
! 3.  GOLDFELD, S.M., QUANDT, R.E., AND TROTTER, H.F. (1966),
!             MAXIMIZATION BY QUADRATIC HILL-CLIMBING, ECONOMETRICA 34,
!             PP. 541-551.
! 4.  HEBDEN, M.D. (1973), AN ALGORITHM FOR MINIMIZATION USING EXACT
!             SECOND DERIVATIVES, REPORT T.P. 515, THEORETICAL PHYSICS
!             DIV., A.E.R.E. HARWELL, OXON., ENGLAND.
! 5.  MORE, J.J. (1978), THE LEVENBERG-MARQUARDT ALGORITHM, IMPLEMEN-
!             TATION AND THEORY, PP.105-116 OF SPRINGER LECTURE NOTES
!             IN MATHEMATICS NO. 630, EDITED BY G.A. WATSON, SPRINGER-
!             VERLAG, BERLIN AND NEW YORK.
! 6.  VARGA, R.S. (1965), MINIMAL GERSCHGORIN SETS, PACIFIC J. MATH. 15,
!             PP. 719-729.
!
!  ***  GENERAL  ***
!
!     CODED BY DAVID M. GAY.
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!     MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989, AND
!     MCS-7906671.
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  ***  LOCAL VARIABLES  ***
!
!     LOGICAL RESTRT
!     INTEGER DGGDMX, DIAG, DIAG0, DSTSAV, EMAX, EMIN, I, IM1, INC, IRC,
!    1        J, K, KALIM, K1, LK0, PHIPIN, Q, Q0, UK0, X, X0
!     REAL(KIND=WP) :: ALPHAK, AKI, AKK, DELTA, DST, EPSO6, LK,
!    1                 OLDPHI, PHI, PHIMAX, PHIMIN, PSIFAC, RAD,
!    2                 ROOT, SI, SK, SW, T, TWOPSI, T1, UK, WI
!
!     ***  CONSTANTS  ***
!     REAL(KIND=WP) :: DGXFAC, EPSFAC, FOUR, HALF, KAPPA, NEGONE, ONE,
!    1                 P001, SIX, THREE, TWO, ZERO
!
!/
!  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***
!
!     EXTERNAL DOTPRD, LITVMU, LIVMUL, LSQRT, LSVMIN, V2NORM
!     REAL(KIND=WP) :: DOTPRD, LSVMIN, V2NORM
!
!  ***  SUBSCRIPTS FOR V  ***
!
!     INTEGER DGNORM, DSTNRM, DST0, EPSLON, GTSTEP, STPPAR, NREDUC,
!    1        PHMNFC, PHMXFC, PREDUC, RADIUS, RAD0
     data dgnorm/1/, dstnrm/2/, dst0/3/, epslon/19/,&
    &     gtstep/4/, nreduc/6/, phmnfc/20/,&
    &     phmxfc/21/, preduc/7/, radius/8/,&
     &     rad0/9/, stppar/5/
!
     data dgxfac/0.0_wp/, epsfac/50.0_wp/, four/4.0_wp/, half/0.5_wp/,&
    &     kappa/2.0_wp/, negone/-1.0_wp/, one/1.0_wp/, p001/1.0e-3_wp/,&
     &     six/6.0_wp/, three/3.0_wp/, two/2.0_wp/, zero/0.0_wp/
!
!  ***  BODY  ***
!
!     ***  STORE LARGEST ABS. ENTRY IN (D**-1)*H*(D**-1) AT W(DGGDMX).
      dggdmx = p + 1
!     ***  STORE GERSCHGORIN OVER- AND UNDERESTIMATES OF THE LARGEST
!     ***  AND SMALLEST EIGENVALUES OF (D**-1)*H*(D**-1) AT W(EMAX)
!     ***  AND W(EMIN) RESPECTIVELY.
      emax = dggdmx + 1
      emin = emax + 1
!     ***  FOR USE IN RECOMPUTING STEP, THE FINAL VALUES OF LK, UK, DST,
!     ***  AND THE INVERSE DERIVATIVE OF MORE*S PHI AT 0 (FOR POS. DEF.
!     ***  H) ARE STORED IN W(LK0), W(UK0), W(DSTSAV), AND W(PHIPIN)
!     ***  RESPECTIVELY.
      uk = 0.0_wp
      phi = 0.0_wp
      dst = 0.0_wp
      alphak = 0.0_wp
      lk0 = emin + 1
      phipin = lk0 + 1
      uk0 = phipin + 1
      dstsav = uk0 + 1
!     ***  STORE DIAG OF (D**-1)*H*(D**-1) IN W(DIAG),...,W(DIAG0+P).
      diag0 = dstsav
      diag = diag0 + 1
!     ***  STORE -D*STEP IN W(Q),...,W(Q0+P).
      q0 = diag0 + p
      q = q0 + 1
      rad = v(radius)
!     ***  PHITOL = MAX. ERROR ALLOWED IN DST = V(DSTNRM) = 2-NORM OF
!     ***  D*STEP.
      phimax = v(phmxfc) * rad
      phimin = v(phmnfc) * rad
!     ***  EPSO6 AND PSIFAC ARE USED IN CHECKING FOR THE SPECIAL CASE
!     ***  OF (NEARLY) SINGULAR H + ALPHA*D**2 (SEE REF. 2).
     psifac = two * v(epslon) / (three * (four * (v(phmnfc) + one) *&
     &                       (kappa + one)  +  kappa  +  two) * rad**2)
!     ***  OLDPHI IS USED TO DETECT LIMITS OF NUMERICAL ACCURACY.  IF
!     ***  WE RECOMPUTE STEP AND IT DOES NOT CHANGE, THEN WE ACCEPT IT.
      oldphi = zero
      epso6 = v(epslon)/six
      irc = 0
      restrt = .false.
      kalim = ka + 50
!
!  ***  START OR RESTART, DEPENDING ON KA  ***
!
      if (ka .ge. 0) go to 310
!
!  ***  FRESH START  ***
!
      k = 0
      uk = negone
      ka = 0
      kalim = 50
!
!     ***  STORE DIAG(DIHDI) IN W(DIAG0+1),...,W(DIAG0+P)  ***
!
      j = 0
      do 20 i = 1, p
         j = j + i
         k1 = diag0 + i
         w(k1) = dihdi(j)
 20      continue
!
!     ***  DETERMINE W(DGGDMX), THE LARGEST ELEMENT OF DIHDI  ***
!
      t1 = zero
      j = p * (p + 1) / 2
      do 30 i = 1, j
         t = abs(dihdi(i))
         if (t1 .lt. t) t1 = t
 30      continue
      w(dggdmx) = t1
!
!  ***  TRY ALPHA = 0  ***
!
 40   call lsqrt(1, p, l, dihdi, irc)
      if (irc .eq. 0) go to 60
!        ***  INDEF. H -- UNDERESTIMATE SMALLEST EIGENVALUE, USE THIS
!        ***  ESTIMATE TO INITIALIZE LOWER BOUND LK ON ALPHA.
         j = irc*(irc+1)/2
         t = l(j)
         l(j) = one
         do 50 i = 1, irc
 50           w(i) = zero
         w(irc) = one
         call litvmu(irc, w, l, w)
         t1 = v2norm(irc, w)
         lk = -t / t1 / t1
         v(dst0) = -lk
         if (restrt) go to 210
         v(nreduc) = zero
         go to 70
!
!     ***  POSITIVE DEFINITE H -- COMPUTE UNMODIFIED NEWTON STEP.  ***
 60   lk = zero
      call livmul(p, w(q), l, dig)
      v(nreduc) = half * dotprd(p, w(q), w(q))
      call litvmu(p, w(q), l, w(q))
      dst = v2norm(p, w(q))
      v(dst0) = dst
      phi = dst - rad
      if (phi .le. phimax) go to 280
      if (restrt) go to 210
!
!  ***  PREPARE TO COMPUTE GERSCHGORIN ESTIMATES OF LARGEST (AND
!  ***  SMALLEST) EIGENVALUES.  ***
!
 70   v(dgnorm) = v2norm(p, dig)
      if (v(dgnorm) .eq. zero) go to 450
      k = 0
      do 100 i = 1, p
         wi = zero
         if (i .eq. 1) go to 90
         im1 = i - 1
         do 80 j = 1, im1
              k = k + 1
              t = abs(dihdi(k))
              wi = wi + t
              w(j) = w(j) + t
 80           continue
 90      w(i) = wi
         k = k + 1
 100     continue
!
!  ***  (UNDER-)ESTIMATE SMALLEST EIGENVALUE OF (D**-1)*H*(D**-1)  ***
!
      k = 1
      t1 = w(diag) - w(1)
      if (p .le. 1) go to 120
      do 110 i = 2, p
         j = diag0 + i
         t = w(j) - w(i)
         if (t .ge. t1) go to 110
              t1 = t
              k = i
 110     continue
!
 120  sk = w(k)
      j = diag0 + k
      akk = w(j)
      k1 = k*(k-1)/2 + 1
      inc = 1
      t = zero
      do 150 i = 1, p
         if (i .eq. k) go to 130
         aki = abs(dihdi(k1))
         si = w(i)
         j = diag0 + i
         t1 = half * (akk - w(j) + si - aki)
         t1 = t1 + sqrt(t1*t1 + sk*aki)
         if (t .lt. t1) t = t1
         if (i .lt. k) go to 140
 130     inc = i
 140     k1 = k1 + inc
 150     continue
!
      w(emin) = akk - t
      uk = v(dgnorm)/rad - w(emin)
!
!  ***  COMPUTE GERSCHGORIN (OVER-)ESTIMATE OF LARGEST EIGENVALUE  ***
!
      k = 1
      t1 = w(diag) + w(1)
      if (p .le. 1) go to 170
      do 160 i = 2, p
         j = diag0 + i
         t = w(j) + w(i)
         if (t .le. t1) go to 160
              t1 = t
              k = i
 160     continue
!
 170  sk = w(k)
      j = diag0 + k
      akk = w(j)
      k1 = k*(k-1)/2 + 1
      inc = 1
      t = zero
      do 200 i = 1, p
         if (i .eq. k) go to 180
         aki = abs(dihdi(k1))
         si = w(i)
         j = diag0 + i
         t1 = half * (w(j) + si - aki - akk)
         t1 = t1 + sqrt(t1*t1 + sk*aki)
         if (t .lt. t1) t = t1
         if (i .lt. k) go to 190
 180     inc = i
 190     k1 = k1 + inc
 200     continue
!
      w(emax) = akk + t
      lk = max(lk, v(dgnorm)/rad - w(emax))
!
!     ***  ALPHAK = CURRENT VALUE OF ALPHA (SEE ALG. NOTES ABOVE).  WE
!     ***  USE MORE*S SCHEME FOR INITIALIZING IT.
      alphak = abs(v(stppar)) * v(rad0)/rad
!
      if (irc .ne. 0) go to 210
!
!  ***  COMPUTE L0 FOR POSITIVE DEFINITE H  ***
!
      call livmul(p, w, l, w(q))
      t = v2norm(p, w)
      w(phipin) = dst / t / t
      lk = max(lk, phi*w(phipin))
!
!  ***  SAFEGUARD ALPHAK AND ADD ALPHAK*I TO (D**-1)*H*(D**-1)  ***
!
 210  ka = ka + 1
     if (-v(dst0) .ge. alphak .or. alphak .lt. lk .or. alphak .ge. uk)&
     &                      alphak = uk * max(p001, sqrt(lk/uk))
      k = 0
      do 220 i = 1, p
         k = k + i
         j = diag0 + i
         dihdi(k) = w(j) + alphak
 220     continue
!
!  ***  TRY COMPUTING CHOLESKY DECOMPOSITION  ***
!
      call lsqrt(1, p, l, dihdi, irc)
      if (irc .eq. 0) go to 250
!
!  ***  (D**-1)*H*(D**-1) + ALPHAK*I  IS INDEFINITE -- OVERESTIMATE
!  ***  SMALLEST EIGENVALUE FOR USE IN UPDATING LK  ***
!
      j = (irc*(irc+1))/2
      t = l(j)
      l(j) = one
      do 230 i = 1, irc
 230     w(i) = zero
      w(irc) = one
      call litvmu(irc, w, l, w)
      t1 = v2norm(irc, w)
      lk = alphak - t/t1/t1
      v(dst0) = -lk
      go to 210
!
!  ***  ALPHAK MAKES (D**-1)*H*(D**-1) POSITIVE DEFINITE.
!  ***  COMPUTE Q = -D*STEP, CHECK FOR CONVERGENCE.  ***
!
 250  call livmul(p, w(q), l, dig)
      call litvmu(p, w(q), l, w(q))
      dst = v2norm(p, w(q))
      phi = dst - rad
      if (phi .le. phimax .and. phi .ge. phimin) go to 290
      if (phi .eq. oldphi) go to 290
      oldphi = phi
      if (phi .gt. zero) go to 260
!        ***  CHECK FOR THE SPECIAL CASE OF  H + ALPHA*D**2  (NEARLY)
!        ***  SINGULAR.  DELTA IS .GE. THE SMALLEST EIGENVALUE OF
!        ***  (D**-1)*H*(D**-1) + ALPHAK*I.
         if (v(dst0) .gt. zero) go to 260
         delta = alphak + v(dst0)
         twopsi = alphak*dst*dst + dotprd(p, dig, w(q))
         if (delta .lt. psifac*twopsi) go to 270
!
!  ***  UNACCEPTABLE ALPHAK -- UPDATE LK, UK, ALPHAK  ***
!
 260  if (ka .ge. kalim) go to 290
      call livmul(p, w, l, w(q))
      t1 = v2norm(p, w)
!     ***  THE FOLLOWING MIN IS NECESSARY BECAUSE OF RESTARTS  ***
      if (phi .lt. zero) uk = min(uk, alphak)
      alphak = alphak  +  (phi/t1) * (dst/t1) * (dst/rad)
      lk = max(lk, alphak)
      go to 210
!
!  ***  DECIDE HOW TO HANDLE (NEARLY) SINGULAR H + ALPHA*D**2  ***
!
!     ***  IF NOT YET AVAILABLE, OBTAIN MACHINE DEPENDENT VALUE DGXFAC.
 270  if (dgxfac .eq. zero) dgxfac = epsfac * rmdcon(3,typ=0.0_wp)
!
!     ***  NOW DECIDE.  ***
      if (delta .gt. dgxfac*w(dggdmx)) go to 350
!        ***  DELTA IS SO SMALL WE CANNOT HANDLE THE SPECIAL CASE IN
!        ***  THE AVAILABLE ARITHMETIC.  ACCEPT STEP AS IT IS.
         go to 290
!
!  ***  ACCEPTABLE STEP ON FIRST TRY  ***
!
 280  alphak = zero
!
!  ***  SUCCESSFUL STEP IN GENERAL.  COMPUTE STEP = -(D**-1)*Q  ***
!
 290  do 300 i = 1, p
         j = q0 + i
         step(i) = -w(j)/d(i)
 300     continue
      v(gtstep) = -dotprd(p, dig, w(q))
      v(preduc) = half * (abs(alphak)*dst*dst - v(gtstep))
      go to 430
!
!
!  ***  RESTART WITH NEW RADIUS  ***
!
 310  if (v(dst0) .le. zero .or. v(dst0) - rad .gt. phimax) go to 330
!
!     ***  PREPARE TO RETURN NEWTON STEP  ***
!
         restrt = .true.
         ka = ka + 1
         k = 0
         do 320 i = 1, p
              k = k + i
              j = diag0 + i
              dihdi(k) = w(j)
 320          continue
         uk = negone
         go to 40
!
 330  if (ka .eq. 0) go to 60
!
      dst = w(dstsav)
      alphak = abs(v(stppar))
      phi = dst - rad
      t = v(dgnorm)/rad
      if (rad .gt. v(rad0)) go to 340
!
!        ***  SMALLER RADIUS  ***
         uk = t - w(emin)
         lk = zero
         if (alphak .gt. zero) lk = w(lk0)
         lk = max(lk, t - w(emax))
         if (v(dst0) .gt. zero) lk = max(lk, (v(dst0)-rad)*w(phipin))
         go to 260
!
!     ***  BIGGER RADIUS  ***
 340  uk = t - w(emin)
      if (alphak .gt. zero) uk = min(uk, w(uk0))
      lk = max(zero, -v(dst0), t - w(emax))
      if (v(dst0) .gt. zero) lk = max(lk, (v(dst0)-rad)*w(phipin))
      go to 260
!
!  ***  HANDLE (NEARLY) SINGULAR H + ALPHA*D**2  ***
!
!     ***  NEGATE ALPHAK TO INDICATE SPECIAL CASE  ***
 350  alphak = -alphak
!     ***  ALLOCATE STORAGE FOR SCRATCH VECTOR X  ***
      x0 = q0 + p
      x = x0 + 1
!
!  ***  USE INVERSE POWER METHOD WITH START FROM LSVMIN TO OBTAIN
!  ***  APPROXIMATE EIGENVECTOR CORRESPONDING TO SMALLEST EIGENVALUE
!  ***  OF (D**-1)*H*(D**-1).
!
      delta = kappa*delta
      t = lsvmin(p, l, w(x), w)
!
      k = 0
!     ***  NORMALIZE W  ***
 360  do 370 i = 1, p
 370     w(i) = t*w(i)
!     ***  COMPLETE CURRENT INV. POWER ITER. -- REPLACE W BY (L**-T)*W.
      call litvmu(p, w, l, w)
      t1 = one/v2norm(p, w)
      t = t1*t
      if (t .le. delta) go to 390
      if (k .gt. 30) go to 290
      k = k + 1
!     ***  START NEXT INV. POWER ITER. BY STORING NORMALIZED W IN X.
      do 380 i = 1, p
         j = x0 + i
         w(j) = t1*w(i)
 380     continue
!     ***  COMPUTE W = (L**-1)*X.
      call livmul(p, w, l, w(x))
      t = one/v2norm(p, w)
      go to 360
!
 390  do 400 i = 1, p
 400     w(i) = t1*w(i)
!
!  ***  NOW W IS THE DESIRED APPROXIMATE (UNIT) EIGENVECTOR AND
!  ***  T*X = ((D**-1)*H*(D**-1) + ALPHAK*I)*W.
!
      sw = dotprd(p, w(q), w)
      t1 = (rad + dst) * (rad - dst)
      root = sqrt(sw*sw + t1)
      if (sw .lt. zero) root = -root
      si = t1 / (sw + root)
!     ***  ACCEPT CURRENT STEP IF ADDING SI*W WOULD LEAD TO A
!     ***  FURTHER RELATIVE REDUCTION IN PSI OF LESS THAN V(EPSLON)/3.
      v(preduc) = half*twopsi
      t1 = zero
      t = si*(alphak*sw - half*si*(alphak + t*dotprd(p,w(x),w)))
      if (t .lt. epso6*twopsi) go to 410
         v(preduc) = v(preduc) + t
         dst = rad
         t1 = -si
 410  do 420 i = 1, p
         j = q0 + i
         w(j) = t1*w(i) - w(j)
         step(i) = w(j) / d(i)
 420     continue
      v(gtstep) = dotprd(p, dig, w(q))
!
!  ***  SAVE VALUES FOR USE IN A POSSIBLE RESTART  ***
!
 430  v(dstnrm) = dst
      v(stppar) = alphak
      w(lk0) = lk
      w(uk0) = uk
      v(rad0) = rad
      w(dstsav) = dst
!
!     ***  RESTORE DIAGONAL OF DIHDI  ***
!
      j = 0
      do 440 i = 1, p
         j = j + i
         k = diag0 + i
         dihdi(j) = w(k)
 440     continue
      go to 999
!
!  ***  SPECIAL CASE -- G = 0  ***
!
 450  v(stppar) = zero
      v(preduc) = zero
      v(dstnrm) = zero
      v(gtstep) = zero
      do 460 i = 1, p
 460     step(i) = zero
!
 999  return
!
      end subroutine gqtstp
!DUPDAT
      subroutine dupdat(d, iv, j, n, nn, p, v)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!  ***  UPDATE SCALE VECTOR D FOR NL2ITR (NL2SOL VERSION 2.2)  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   n,nn,p
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   d(p),j(nn,p),v(1)
     integer&
     &   iv(1)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   sii,t,vdfac,zero
     integer&
     &   d0,dfac,dtype,i,jtol0,jtoli,niter,s,s1
!
!  EXTERNAL FUNCTIONS
!      real(kind=wp) ::
!     &   v2norm
!      external v2norm
!
!  INTRINSIC FUNCTIONS
      intrinsic max,sqrt
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER IV(1), N, NN, P
!     REAL(KIND=WP) :: D(P), J(NN,P), V(1)
!     DIMENSION IV(*), V(*)
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER D0, I, JTOLI, S1
!     REAL(KIND=WP) :: SII, T, VDFAC
!
!     ***  CONSTANTS  ***
!     REAL(KIND=WP) :: ZERO
!
!/
!  ***  EXTERNAL FUNCTION  ***
!
!     EXTERNAL V2NORM
!     REAL(KIND=WP) :: V2NORM
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER DFAC, DTYPE, JTOL0, NITER, S
      data dfac/41/, dtype/16/, jtol0/86/, niter/31/, s/53/
!
      data zero/0.0_wp/
!
!-----------------------------------------------------------------------
!
      i = iv(dtype)
      if (i .eq. 1) go to 20
         if (iv(niter) .gt. 0) go to 999
!
 20   vdfac = v(dfac)
      d0 = jtol0 + p
      s1 = iv(s) - 1
      do 30 i = 1, p
         s1 = s1 + i
         sii = v(s1)
         t = v2norm(n, j(1,i))
         if (sii .gt. zero) t = sqrt(t*t + sii)
         jtoli = jtol0 + i
         d0 = d0 + 1
         if (t .lt. v(jtoli)) t = max(v(d0), v(jtoli))
         d(i) = max(vdfac*d(i), t)
 30      continue
!
 999  return
      end subroutine dupdat
!DFAULT
      subroutine dfault(iv, v)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!
!  VARIABLE DECLARATIONS
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   v(45)
     integer&
     &   iv(25)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   machep,mepcrt,one,sqteps,three
     integer&
    &   afctol,cosmin,covprt,covreq,d0init,decfac,delta0,dfac,&
    &   dinit,dltfdc,dltfdj,dtype,epslon,fuzz,incfac,inits,jtinit,&
    &   lmax0,mxfcal,mxiter,outlev,parprt,phmnfc,phmxfc,prunit,&
    &   rdfcmn,rdfcmx,rfctol,rlimit,solprt,statpr,tuner1,tuner2,&
     &   tuner3,tuner4,tuner5,x0prt,xctol,xftol
!
!  EXTERNAL FUNCTIONS
!     REAL(KIND=WP) :: RMDCON
!      integer
!     &   imdcon
!      external imdcon
!
!  INTRINSIC FUNCTIONS
      intrinsic max
!
!  ***  SUPPLY NL2SOL (VERSION 2.2) DEFAULT VALUES TO IV AND V  ***
!
!     INTEGER IV(25)
!     REAL(KIND=WP) :: V(45)
!/+
!     REAL(KIND=WP) :: MAX
!/
!     EXTERNAL IMDCON
!     INTEGER IMDCON
!
!     REAL(KIND=WP) :: MACHEP, MEPCRT, ONE, SQTEPS, THREE
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER AFCTOL, COSMIN, COVPRT, COVREQ, DECFAC, DELTA0, DFAC,
!    1        DINIT, DLTFDC, DLTFDJ, DTYPE, D0INIT, EPSLON, FUZZ,
!    2        INCFAC, INITS, JTINIT, LMAX0, MXFCAL, MXITER, OUTLEV,
!    3        PARPRT, PHMNFC, PHMXFC, PRUNIT, RDFCMN, RDFCMX,
!    4        RFCTOL, RLIMIT, SOLPRT, STATPR, TUNER1, TUNER2, TUNER3,
!    5        TUNER4, TUNER5, XCTOL, XFTOL, X0PRT
!
      data one/1.0_wp/, three/3.0_wp/
!
!  ***  IV SUBSCRIPT VALUES  ***
!
     data covprt/14/, covreq/15/, dtype/16/, inits/25/,&
    &     mxfcal/17/, mxiter/18/, outlev/19/,&
    &     parprt/20/, prunit/21/, solprt/22/,&
     &     statpr/23/, x0prt/24/
!
!  ***  V SUBSCRIPT VALUES  ***
!
     data afctol/31/, cosmin/43/, decfac/22/,&
    &     delta0/44/, dfac/41/, dinit/38/, dltfdc/40/,&
    &     dltfdj/36/, d0init/37/, epslon/19/, fuzz/45/,&
    &     incfac/23/, jtinit/39/, lmax0/35/, phmnfc/20/,&
    &     phmxfc/21/, rdfcmn/24/, rdfcmx/25/,&
    &     rfctol/32/, rlimit/42/, tuner1/26/,&
    &     tuner2/27/, tuner3/28/, tuner4/29/,&
     &     tuner5/30/, xctol/33/, xftol/34/
!
!-----------------------------------------------------------------------
!
      iv(1) = 12
      iv(covprt) = 1
      iv(covreq) = 1
      iv(dtype) = 1
      iv(inits) = 0
      iv(mxfcal) = 200
      iv(mxiter) = 150
      iv(outlev) = 1
      iv(parprt) = 1
      iv(prunit) = imdcon(1)
      iv(solprt) = 1
      iv(statpr) = 1
      iv(x0prt) = 1
!
      machep = rmdcon(3,typ=0.0_wp)
      v(afctol) = 1.0e-20_wp
      if (machep .gt. 1.0e-10_wp) v(afctol) = machep**2
      v(cosmin) = max(1.0e-6_wp, 1.0e2_wp * machep)
      v(decfac) = 0.5_wp
      sqteps = rmdcon(4,typ=0.0_wp)
      v(delta0) = sqteps
      v(dfac) = 0.6_wp
      v(dinit) = 0.0_wp
      mepcrt = machep ** (one/three)
      v(dltfdc) = mepcrt
      v(dltfdj) = sqteps
      v(d0init) = 1.0_wp
      v(epslon) = 0.1_wp
      v(fuzz) = 1.5_wp
      v(incfac) = 2.0_wp
      v(jtinit) = 1.0e-6_wp
      v(lmax0) = 100.0_wp
      v(phmnfc) = -0.1_wp
      v(phmxfc) = 0.1_wp
      v(rdfcmn) = 0.1_wp
      v(rdfcmx) = 4.0_wp
      v(rfctol) = max(1.0e-10_wp, mepcrt**2)
      v(rlimit) = rmdcon(5,typ=0.0_wp)
      v(tuner1) = 0.1_wp
      v(tuner2) = 1.0e-4_wp
      v(tuner3) = 0.75_wp
      v(tuner4) = 0.5_wp
      v(tuner5) = 0.75_wp
      v(xctol) = sqteps
      v(xftol) = 1.0e2_wp * machep

      end subroutine dfault
!RELDST
      real(kind=wp) function reldst(p, d, x, x0)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!  ***  COMPUTE AND RETURN RELATIVE DIFFERENCE BETWEEN X AND X0  ***
!  ***  NL2SOL VERSION 2.2  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     integer&
     &   p
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   d(p),x(p),x0(p)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   emax,t,xmax,zero
     integer&
     &   i
!
!  INTRINSIC FUNCTIONS
      intrinsic abs
!
      data zero/0.0_wp/
!
      emax = zero
      xmax = zero
      do 10 i = 1, p
         t = abs(d(i) * (x(i) - x0(i)))
         if (emax .lt. t) emax = t
         t = d(i) * (abs(x(i)) + abs(x0(i)))
         if (xmax .lt. t) xmax = t
 10      continue
      reldst = zero
      if (xmax .gt. zero) reldst = emax / xmax

      end function reldst
!SLUPDT
     subroutine slupdt(a, cosmin, p, size, step, u, w, wchmtd, wscale,&
     &                  y)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!  ***  UPDATE SYMMETRIC  A  SO THAT  A * STEP = Y  ***
!  ***  (LOWER TRIANGLE OF  A  STORED ROWWISE       ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
     real(kind=wp) ::&
     &   cosmin,size,wscale
     integer&
     &   p
!
!  ARRAY ARGUMENTS
     real(kind=wp) ::&
     &   a(1),step(p),u(p),w(p),wchmtd(p),y(p)
!
!  LOCAL SCALARS
     real(kind=wp) ::&
     &   denmin,half,one,sdotwm,t,ui,wi,zero
     integer&
     &   i,j,k
!
!  EXTERNAL FUNCTIONS
!      real(kind=wp) ::
!     &   dotprd,v2norm
!      external dotprd,v2norm
!
!  EXTERNAL SUBROUTINES
!      external slvmul
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,min
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER P
!     REAL(KIND=WP) :: A(1), COSMIN, SIZE, STEP(P), U(P), W(P),
!    1                 WCHMTD(P), WSCALE, Y(P)
!     DIMENSION A(P*(P+1)/2)
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER I, J, K
!     REAL(KIND=WP) :: DENMIN, SDOTWM, T, UI, WI
!
!     ***  CONSTANTS  ***
!     REAL(KIND=WP) :: HALF, ONE, ZERO
!
!/
!  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***
!
!     EXTERNAL DOTPRD, SLVMUL, V2NORM
!     REAL(KIND=WP) :: DOTPRD, V2NORM
!
      data half/0.5_wp/, one/1.0_wp/, zero/0.0_wp/
!
!-----------------------------------------------------------------------
!
      sdotwm = dotprd(p, step, wchmtd)
      denmin = cosmin * v2norm(p,step) * v2norm(p,wchmtd)
      wscale = one
      if (denmin .ne. zero) wscale = min(one, abs(sdotwm/denmin))
      t = zero
      if (sdotwm .ne. zero) t = wscale / sdotwm
      do 10 i = 1, p
 10      w(i) = t * wchmtd(i)
      call slvmul(p, u, a, step)
      t = half * (size * dotprd(p, step, u)  -  dotprd(p, step, y))
      do 20 i = 1, p
 20      u(i) = t*w(i) + y(i) - size*u(i)
!
!  ***  SET  A = A + U*(W**T) + W*(U**T)  ***
!
      k = 1
      do 40 i = 1, p
         ui = u(i)
         wi = w(i)
         do 30 j = 1, i
              a(k) = size*a(k) + ui*w(j) + wi*u(j)
              k = k + 1
 30           continue
 40      continue
!
      end subroutine slupdt

!ASSESS
      subroutine assess (d, iv, p, step, stlstg, v, x, x0)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!  ***  ASSESS CANDIDATE STEP (NL2SOL VERSION 2.2)  ***
!
!  ***  PURPOSE  ***
!
!        This subroutine is called by an unconstrained minimization
!     routine to assess the next candidate step.  It may recommend one
!     of several courses of action, such as accepting the step, recomputing
!     it using the same or a new quadratic model, or halting due
!     to convergence or false convergence.  See the return code listing
!     below.
!
!
!  Variable Declarations
!
!  SCALAR ARGUMENTS
      integer p
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: d(p),step(p),stlstg(p),v(*),x(p),x0(p)
      integer iv(*)
!
!  LOCAL SCALARS
      real(kind=wp) :: emax,gts,half,one,reldx1,rfac1,temp,two,xmax,zero
     integer&
    &   afctol,decfac,dst0,dstnrm,dstsav,f,f0,fdif,flstgd,gtslst,&
    &   gtstep,i,incfac,irc,lmax0,mlstgd,model,nfc,nfcall,nfgcal,&
    &   nreduc,plstgd,preduc,radfac,radinc,rdfcmn,rdfcmx,reldx,&
    &   restor,rfctol,stage,stglim,stppar,switch,toobig,tuner1,&
     &   tuner2,tuner3,xctol,xftol,xirc
      logical goodx
!
!  EXTERNAL FUNCTIONS
!      real(kind=wp),external :: reldst
!     real(kind=wp) :: mach
!
!  EXTERNAL SUBROUTINES
!      external vcopy
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,max
!
!--------------------------  PARAMETER USAGE  --------------------------
!
!     IV (I/O) INTEGER PARAMETER AND SCRATCH VECTOR -- SEE DESCRIPTION
!             BELOW OF IV VALUES REFERENCED.
!      D (IN)  SCALE VECTOR USED IN COMPUTING V(RELDX) -- SEE BELOW.
!      P (IN)  NUMBER OF PARAMETERS BEING OPTIMIZED.
!   STEP (I/O) ON INPUT, STEP IS THE STEP TO BE ASSESSED.  IT IS UN-
!             CHANGED ON OUTPUT UNLESS A PREVIOUS STEP ACHIEVED A
!             BETTER OBJECTIVE FUNCTION REDUCTION, IN WHICH CASE STLSTG
!             WILL HAVE BEEN COPIED TO STEP.
! STLSTG (I/O) WHEN ASSESS RECOMMENDS RECOMPUTING STEP EVEN THOUGH THE
!             CURRENT (OR A PREVIOUS) STEP YIELDS AN OBJECTIVE FUNC-
!             TION DECREASE, IT SAVES IN STLSTG THE STEP THAT GAVE THE
!             BEST FUNCTION REDUCTION SEEN SO FAR (IN THE CURRENT ITERA-
!             TION).  IF THE RECOMPUTED STEP YIELDS A LARGER FUNCTION
!             VALUE, THEN STEP IS RESTORED FROM STLSTG AND
!             X = X0 + STEP IS RECOMPUTED.
!      V (I/O) REAL(KIND=WP) PARAMETER AND SCRATCH VECTOR -- SEE DESCRIPTION
!             BELOW OF V VALUES REFERENCED.
!      X (I/O) ON INPUT, X = X0 + STEP IS THE POINT AT WHICH THE OBJEC-
!             TIVE FUNCTION HAS JUST BEEN EVALUATED.  IF AN EARLIER
!             STEP YIELDED A BIGGER FUNCTION DECREASE, THEN X IS
!             RESTORED TO THE CORRESPONDING EARLIER VALUE.  OTHERWISE,
!             IF THE CURRENT STEP DOES NOT GIVE ANY FUNCTION DECREASE,
!             THEN X IS RESTORED TO X0.
!     X0 (IN)  INITIAL OBJECTIVE FUNCTION PARAMETER VECTOR (AT THE
!             START OF THE CURRENT ITERATION).
!
!  ***  IV VALUES REFERENCED  ***
!
!    IV(IRC) (I/O) ON INPUT FOR THE FIRST STEP TRIED IN A NEW ITERATION,
!             IV(IRC) SHOULD BE SET TO 3 OR 4 (THE VALUE TO WHICH IT IS
!             SET WHEN STEP IS DEFINITELY TO BE ACCEPTED).  ON INPUT
!             AFTER STEP HAS BEEN RECOMPUTED, IV(IRC) SHOULD BE
!             UNCHANGED SINCE THE PREVIOUS RETURN OF ASSESS.
!                ON OUTPUT, IV(IRC) IS A RETURN CODE HAVING ONE OF THE
!             FOLLOWING VALUES...
!                  1 = SWITCH MODELS OR TRY SMALLER STEP.
!                  2 = SWITCH MODELS OR ACCEPT STEP.
!                  3 = ACCEPT STEP AND DETERMINE V(RADFAC) BY GRADIENT
!                       TESTS.
!                  4 = ACCEPT STEP, V(RADFAC) HAS BEEN DETERMINED.
!                  5 = RECOMPUTE STEP (USING THE SAME MODEL).
!                  6 = RECOMPUTE STEP WITH RADIUS = V(LMAX0) BUT DO NOT
!                       EVAULATE THE OBJECTIVE FUNCTION.
!                  7 = X-CONVERGENCE (SEE V(XCTOL)).
!                  8 = RELATIVE FUNCTION CONVERGENCE (SEE V(RFCTOL)).
!                  9 = BOTH X- AND RELATIVE FUNCTION CONVERGENCE.
!                 10 = ABSOLUTE FUNCTION CONVERGENCE (SEE V(AFCTOL)).
!                 11 = SINGULAR CONVERGENCE (SEE V(LMAX0)).
!                 12 = FALSE CONVERGENCE (SEE V(XFTOL)).
!                 13 = IV(IRC) WAS OUT OF RANGE ON INPUT.
!             RETURN CODE I HAS PRECDENCE OVER I+1 FOR I = 9, 10, 11.
! IV(MLSTGD) (I/O) SAVED VALUE OF IV(MODEL).
!  IV(MODEL) (I/O) ON INPUT, IV(MODEL) SHOULD BE AN INTEGER IDENTIFYING
!             THE CURRENT QUADRATIC MODEL OF THE OBJECTIVE FUNCTION.
!             IF A PREVIOUS STEP YIELDED A BETTER FUNCTION REDUCTION,
!             THEN IV(MODEL) WILL BE SET TO IV(MLSTGD) ON OUTPUT.
! IV(NFCALL) (IN)  INVOCATION COUNT FOR THE OBJECTIVE FUNCTION.
! IV(NFGCAL) (I/O) VALUE OF IV(NFCALL) AT STEP THAT GAVE THE BIGGEST
!             FUNCTION REDUCTION THIS ITERATION.  IV(NFGCAL) REMAINS
!             UNCHANGED UNTIL A FUNCTION REDUCTION IS OBTAINED.
! IV(RADINC) (I/O) THE NUMBER OF RADIUS INCREASES (OR MINUS THE NUMBER
!             OF DECREASES) SO FAR THIS ITERATION.
! IV(RESTOR) (OUT) SET TO 0 UNLESS X AND V(F) HAVE BEEN RESTORED, IN
!             WHICH CASE ASSESS SETS IV(RESTOR) = 1.
!  IV(STAGE) (I/O) COUNT OF THE NUMBER OF MODELS TRIED SO FAR IN THE
!             CURRENT ITERATION.
! IV(STGLIM) (IN)  MAXIMUM NUMBER OF MODELS TO CONSIDER.
! IV(SWITCH) (OUT) SET TO 0 UNLESS A NEW MODEL IS BEING TRIED AND IT
!             GIVES A SMALLER FUNCTION VALUE THAN THE PREVIOUS MODEL,
!             IN WHICH CASE ASSESS SETS IV(SWITCH) = 1.
! IV(TOOBIG) (IN)  IS NONZERO IF STEP WAS TOO BIG (E.G. IF IT CAUSED
!             OVERFLOW).
!   IV(XIRC) (I/O) VALUE THAT IV(IRC) WOULD HAVE IN THE ABSENCE OF
!             CONVERGENCE, FALSE CONVERGENCE, AND OVERSIZED STEPS.
!
!  ***  V VALUES REFERENCED  ***
!
! V(AFCTOL) (IN)  ABSOLUTE FUNCTION CONVERGENCE TOLERANCE.  IF THE
!             ABSOLUTE VALUE OF THE CURRENT FUNCTION VALUE V(F) IS LESS
!             THAN V(AFCTOL), THEN ASSESS RETURNS WITH IV(IRC) = 10.
! V(DECFAC) (IN)  FACTOR BY WHICH TO DECREASE RADIUS WHEN IV(TOOBIG) IS
!             NONZERO.
! V(DSTNRM) (IN)  THE 2-NORM OF D*STEP.
! V(DSTSAV) (I/O) VALUE OF V(DSTNRM) ON SAVED STEP.
!   V(DST0) (IN)  THE 2-NORM OF D TIMES THE NEWTON STEP (WHEN DEFINED,
!             I.E., FOR V(NREDUC) .GE. 0).
!      V(F) (I/O) ON BOTH INPUT AND OUTPUT, V(F) IS THE OBJECTIVE FUNC-
!             TION VALUE AT X.  IF X IS RESTORED TO A PREVIOUS VALUE,
!             THEN V(F) IS RESTORED TO THE CORRESPONDING VALUE.
!   V(FDIF) (OUT) THE FUNCTION REDUCTION V(F0) - V(F) (FOR THE OUTPUT
!             VALUE OF V(F) IF AN EARLIER STEP GAVE A BIGGER FUNCTION
!             DECREASE, AND FOR THE INPUT VALUE OF V(F) OTHERWISE).
! V(FLSTGD) (I/O) SAVED VALUE OF V(F).
!     V(F0) (IN)  OBJECTIVE FUNCTION VALUE AT START OF ITERATION.
! V(GTSLST) (I/O) VALUE OF V(GTSTEP) ON SAVED STEP.
! V(GTSTEP) (IN)  INNER PRODUCT BETWEEN STEP AND GRADIENT.
! V(INCFAC) (IN)  MINIMUM FACTOR BY WHICH TO INCREASE RADIUS.
!  V(LMAX0) (IN)  MAXIMUM REASONABLE STEP SIZE (AND INITIAL STEP BOUND).
!             IF THE ACTUAL FUNCTION DECREASE IS NO MORE THAN TWICE
!             WHAT WAS PREDICTED, IF A RETURN WITH IV(IRC) = 7, 8, 9,
!             OR 10 DOES NOT OCCUR, IF V(DSTNRM) .GT. V(LMAX0), AND IF
!             V(PREDUC) .LE. V(RFCTOL) * ABS(V(F0)), THEN ASSESS RE-
!             TURNS WITH IV(IRC) = 11.  IF SO DOING APPEARS WORTHWHILE,
!             THEN ASSESS REPEATS THIS TEST WITH V(PREDUC) COMPUTED FOR
!             A STEP OF LENGTH V(LMAX0) (BY A RETURN WITH IV(IRC) = 6).
! V(NREDUC) (I/O)  FUNCTION REDUCTION PREDICTED BY QUADRATIC MODEL FOR
!             NEWTON STEP.  IF ASSESS IS CALLED WITH IV(IRC) = 6, I.E.,
!             IF V(PREDUC) HAS BEEN COMPUTED WITH RADIUS = V(LMAX0) FOR
!             USE IN THE SINGULAR CONVERVENCE TEST, THEN V(NREDUC) IS
!             SET TO -V(PREDUC) BEFORE THE LATTER IS RESTORED.
! V(PLSTGD) (I/O) VALUE OF V(PREDUC) ON SAVED STEP.
! V(PREDUC) (I/O) FUNCTION REDUCTION PREDICTED BY QUADRATIC MODEL FOR
!             CURRENT STEP.
! V(RADFAC) (OUT) FACTOR TO BE USED IN DETERMINING THE NEW RADIUS,
!             WHICH SHOULD BE V(RADFAC)*DST, WHERE  DST  IS EITHER THE
!             OUTPUT VALUE OF V(DSTNRM) OR THE 2-NORM OF
!             DIAG(NEWD)*STEP  FOR THE OUTPUT VALUE OF STEP AND THE
!             UPDATED VERSION, NEWD, OF THE SCALE VECTOR D.  FOR
!             IV(IRC) = 3, V(RADFAC) = 1.0 IS RETURNED.
! V(RDFCMN) (IN)  MINIMUM VALUE FOR V(RADFAC) IN TERMS OF THE INPUT
!             VALUE OF V(DSTNRM) -- SUGGESTED VALUE = 0.1.
! V(RDFCMX) (IN)  MAXIMUM VALUE FOR V(RADFAC) -- SUGGESTED VALUE = 4.0.
!  V(RELDX) (OUT) SCALED RELATIVE CHANGE IN X CAUSED BY STEP, COMPUTED
!             BY FUNCTION  RELDST  AS
!                 MAX (D(I)*ABS(X(I)-X0(I)), 1 .LE. I .LE. P) /
!                    MAX (D(I)*(ABS(X(I))+ABS(X0(I))), 1 .LE. I .LE. P).
!             IF AN ACCEPTABLE STEP IS RETURNED, THEN V(RELDX) IS COM-
!             PUTED USING THE OUTPUT (POSSIBLY RESTORED) VALUES OF X
!             AND STEP.  OTHERWISE IT IS COMPUTED USING THE INPUT
!             VALUES.
! V(RFCTOL) (IN)  RELATIVE FUNCTION CONVERGENCE TOLERANCE.  IF THE
!             ACTUAL FUNCTION REDUCTION IS AT MOST TWICE WHAT WAS PRE-
!             DICTED AND  V(NREDUC) .LE. V(RFCTOL)*ABS(V(F0)),  THEN
!             ASSESS RETURNS WITH IV(IRC) = 8 OR 9.  SEE ALSO V(LMAX0).
! V(STPPAR) (IN)  MARQUARDT PARAMETER -- 0 MEANS FULL NEWTON STEP.
! V(TUNER1) (IN)  TUNING CONSTANT USED TO DECIDE IF THE FUNCTION
!             REDUCTION WAS MUCH LESS THAN EXPECTED.  SUGGESTED
!             VALUE = 0.1.
! V(TUNER2) (IN)  TUNING CONSTANT USED TO DECIDE IF THE FUNCTION
!             REDUCTION WAS LARGE ENOUGH TO ACCEPT STEP.  SUGGESTED
!             VALUE = 10**-4.
! V(TUNER3) (IN)  TUNING CONSTANT USED TO DECIDE IF THE RADIUS
!             SHOULD BE INCREASED.  SUGGESTED VALUE = 0.75.
!  V(XCTOL) (IN)  X-CONVERGENCE CRITERION.  IF STEP IS A NEWTON STEP
!             (V(STPPAR) = 0) HAVING V(RELDX) .LE. V(XCTOL) AND GIVING
!             AT MOST TWICE THE PREDICTED FUNCTION DECREASE, THEN
!             ASSESS RETURNS IV(IRC) = 7 OR 9.
!  V(XFTOL) (IN)  FALSE CONVERGENCE TOLERANCE.  IF STEP GAVE NO OR ONLY
!             A SMALL FUNCTION DECREASE AND V(RELDX) .LE. V(XFTOL),
!             THEN ASSESS RETURNS WITH IV(IRC) = 12.
!
!-------------------------------  NOTES  -------------------------------
!
!  ***  APPLICATION AND USAGE RESTRICTIONS  ***
!
!        THIS ROUTINE IS CALLED AS PART OF THE NL2SOL (NONLINEAR
!     LEAST-SQUARES) PACKAGE.  IT MAY BE USED IN ANY UNCONSTRAINED
!     MINIMIZATION SOLVER THAT USES DOGLEG, GOLDFELD-QUANDT-TROTTER,
!     OR LEVENBERG-MARQUARDT STEPS.
!
!  ***  ALGORITHM NOTES  ***
!
!        SEE (1) FOR FURTHER DISCUSSION OF THE ASSESSING AND MODEL
!     SWITCHING STRATEGIES.  WHILE NL2SOL CONSIDERS ONLY TWO MODELS,
!     ASSESS IS DESIGNED TO HANDLE ANY NUMBER OF MODELS.
!
!  ***  USAGE NOTES  ***
!
!        ON THE FIRST CALL OF AN ITERATION, ONLY THE I/O VARIABLES
!     STEP, X, IV(IRC), IV(MODEL), V(F), V(DSTNRM), V(GTSTEP), AND
!     V(PREDUC) NEED HAVE BEEN INITIALIZED.  BETWEEN CALLS, NO I/O
!     VALUES EXECPT STEP, X, IV(MODEL), V(F) AND THE STOPPING TOLER-
!     ANCES SHOULD BE CHANGED.
!        AFTER A RETURN FOR CONVERGENCE OR FALSE CONVERGENCE, ONE CAN
!     CHANGE THE STOPPING TOLERANCES AND CALL ASSESS AGAIN, IN WHICH
!     CASE THE STOPPING TESTS WILL BE REPEATED.
!
!  ***  REFERENCES  ***
!
!     (1) DENNIS, J.E., JR., GAY, D.M., AND WELSCH, R.E. (1980),
!        AN ADAPTIVE NONLINEAR LEAST-SQUARES ALGORITHM,
!        SUBMITTED TO ACM TRANS. MATH. SOFTWARE.
!
!     (2) POWELL, M.J.D. (1970)  A FORTRAN SUBROUTINE FOR SOLVING
!        SYSTEMS OF NONLINEAR ALGEBRAIC EQUATIONS, IN NUMERICAL
!        METHODS FOR NONLINEAR ALGEBRAIC EQUATIONS, EDITED BY
!        P. RABINOWITZ, GORDON AND BREACH, LONDON.
!
!  ***  HISTORY  ***
!
!        JOHN DENNIS DESIGNED MUCH OF THIS ROUTINE, STARTING WITH
!     IDEAS IN (2). ROY WELSCH SUGGESTED THE MODEL SWITCHING STRATEGY.
!        DAVID GAY AND STEPHEN PETERS CAST THIS SUBROUTINE INTO A MORE
!     PORTABLE FORM (WINTER 1977), AND DAVID GAY CAST IT INTO ITS
!     PRESENT FORM (FALL 1978).
!
!  ***  GENERAL  ***
!
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!     MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989, AND
!     MCS-7906671.
!
!------------------------  EXTERNAL QUANTITIES  ------------------------
!
!  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***
!
!     EXTERNAL RELDST, VCOPY
!     REAL(KIND=WP) :: RELDST
!
! VCOPY.... COPIES ONE VECTOR TO ANOTHER.
!
!/
!  ***  NO COMMON BLOCKS  ***
!
!--------------------------  LOCAL VARIABLES  --------------------------
!
!     LOGICAL GOODX
!     INTEGER I, NFC
!     REAL(KIND=WP) :: EMAX, GTS, HALF, ONE, RELDX1, RFAC1,
!    +                 TEMP, TWO, XMAX, ZERO
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER AFCTOL, DECFAC, DSTNRM, DSTSAV, DST0, F, FDIF, FLSTGD, F0,
!    1        GTSLST, GTSTEP, INCFAC, IRC, LMAX0, MLSTGD, MODEL, NFCALL,
!    2        NFGCAL, NREDUC, PLSTGD, PREDUC, RADFAC, RADINC, RDFCMN,
!    3        RDFCMX, RELDX, RESTOR, RFCTOL, STAGE, STGLIM, STPPAR,
!    4        SWITCH, TOOBIG, TUNER1, TUNER2, TUNER3, XCTOL, XFTOL,
!    5        XIRC
!
!  ***  DATA INITIALIZATIONS  ***
!
      data half/0.5_wp/, one/1.0_wp/, two/2.0_wp/, zero/0.0_wp/
!
     data irc/3/, mlstgd/4/, model/5/, nfcall/6/,&
    &     nfgcal/7/, radinc/8/, restor/9/, stage/10/,&
     &     stglim/11/, switch/12/, toobig/2/, xirc/13/
     data afctol/31/, decfac/22/, dstnrm/2/, dst0/3/,&
    &     dstsav/18/, f/10/, fdif/11/, flstgd/12/, f0/13/,&
    &     gtslst/14/, gtstep/4/, incfac/23/,&
    &     lmax0/35/, nreduc/6/, plstgd/15/, preduc/7/,&
    &     radfac/16/, rdfcmn/24/, rdfcmx/25/,&
    &     reldx/17/, rfctol/32/, stppar/5/, tuner1/26/,&
     &     tuner2/27/, tuner3/28/, xctol/33/, xftol/34/
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
      nfc = iv(nfcall)
      iv(switch) = 0
      iv(restor) = 0
      rfac1 = one
      goodx = .true.
      i = iv(irc)
     if (i .ge. 1 .and. i .le. 12)&
     &             go to (20,30,10,10,40,360,290,290,290,290,290,140), i
         iv(irc) = 13
         go to 999
!
!  ***  INITIALIZE FOR NEW ITERATION  ***
!
 10   iv(stage) = 1
      iv(radinc) = 0
      v(flstgd) = v(f0)
      if (iv(toobig) .eq. 0) go to 90
         iv(stage) = -1
         iv(xirc) = i
         go to 60
!
!  ***  STEP WAS RECOMPUTED WITH NEW MODEL OR SMALLER RADIUS  ***
!  ***  FIRST DECIDE WHICH  ***
!
 20   if (iv(model) .ne. iv(mlstgd)) go to 30
!        ***  OLD MODEL RETAINED, SMALLER RADIUS TRIED  ***
!        ***  DO NOT CONSIDER ANY MORE NEW MODELS THIS ITERATION  ***
         iv(stage) = iv(stglim)
         iv(radinc) = -1
         go to 90
!
!  ***  A NEW MODEL IS BEING TRIED.  DECIDE WHETHER TO KEEP IT.  ***
!
 30   iv(stage) = iv(stage) + 1
!
!     ***  NOW WE ADD THE POSSIBILTIY THAT STEP WAS RECOMPUTED WITH  ***
!     ***  THE SAME MODEL, PERHAPS BECAUSE OF AN OVERSIZED STEP.     ***
!
 40   if (iv(stage) .gt. 0) go to 50
!
!        ***  STEP WAS RECOMPUTED BECAUSE IT WAS TOO BIG.  ***
!
         if (iv(toobig) .ne. 0) go to 60
!
!        ***  RESTORE IV(STAGE) AND PICK UP WHERE WE LEFT OFF.  ***
!
         iv(stage) = -iv(stage)
         i = iv(xirc)
         go to (20, 30, 90, 90, 70), i
!
 50   if (iv(toobig) .eq. 0) go to 70
!
!  ***  HANDLE OVERSIZE STEP  ***
!
      if (iv(radinc) .gt. 0) go to 80
         iv(stage) = -iv(stage)
         iv(xirc) = iv(irc)
!
 60      v(radfac) = v(decfac)
         iv(radinc) = iv(radinc) - 1
         iv(irc) = 5
         go to 999
!
 70   if (v(f) .lt. v(flstgd)) go to 90
!
!     *** THE NEW STEP IS A LOSER.  RESTORE OLD MODEL.  ***
!
      if (iv(model) .eq. iv(mlstgd)) go to 80
         iv(model) = iv(mlstgd)
         iv(switch) = 1
!
!     ***  RESTORE STEP, ETC. ONLY IF A PREVIOUS STEP DECREASED V(F).
!
 80   if (v(flstgd) .ge. v(f0)) go to 90
         iv(restor) = 1
         v(f) = v(flstgd)
         v(preduc) = v(plstgd)
         v(gtstep) = v(gtslst)
         if (iv(switch) .eq. 0) rfac1 = v(dstnrm) / v(dstsav)
         v(dstnrm) = v(dstsav)
         nfc = iv(nfgcal)
         goodx = .false.
!
!
!  ***  COMPUTE RELATIVE CHANGE IN X BY CURRENT STEP  ***
!
 90   reldx1 = reldst(p, d, x, x0)
!
!  ***  RESTORE X AND STEP IF NECESSARY  ***
!
      if (goodx) go to 105
      do 100 i = 1, p
         step(i) = stlstg(i)
         x(i) = x0(i) + stlstg(i)
 100     continue
!
 105  v(fdif) = v(f0) - v(f)
      temp = 0.0
      if (v(preduc).gt.mach(1)/v(tuner2)) temp = v(tuner2) * v(preduc)
      if (v(fdif).gt.temp) go to 120
!
!        ***  NO (OR ONLY A TRIVIAL) FUNCTION DECREASE
!        ***  -- SO TRY NEW MODEL OR SMALLER RADIUS
!
         v(reldx) = reldx1
         if (v(f) .lt. v(f0)) go to 110
              iv(mlstgd) = iv(model)
              v(flstgd) = v(f)
              v(f) = v(f0)
              call vcopy(p, x, x0)
              iv(restor) = 1
              go to 115
 110     iv(nfgcal) = nfc
 115     iv(irc) = 1
         if (iv(stage) .lt. iv(stglim)) go to 130
              iv(irc) = 5
              iv(radinc) = iv(radinc) - 1
              go to 130
!
!  ***  NONTRIVIAL FUNCTION DECREASE ACHIEVED  ***
!
 120  iv(nfgcal) = nfc
      rfac1 = one
      if (goodx) v(reldx) = reldx1
      v(dstsav) = v(dstnrm)
      if (v(fdif) .gt. v(preduc)*v(tuner1)) go to 200
!
!  ***  DECREASE WAS MUCH LESS THAN PREDICTED -- EITHER CHANGE MODELS
!  ***  OR ACCEPT STEP WITH DECREASED RADIUS.
!
      if (iv(stage) .ge. iv(stglim)) go to 125
!        ***  CONSIDER SWITCHING MODELS  ***
         iv(irc) = 2
         go to 130
!
!     ***  ACCEPT STEP WITH DECREASED RADIUS  ***
!
 125  iv(irc) = 4
!
!  ***  SET V(RADFAC) TO FLETCHER*S DECREASE FACTOR  ***
!
 130  iv(xirc) = iv(irc)
      emax = v(gtstep) + v(fdif)
      v(radfac) = half * rfac1
     if (emax .lt. v(gtstep)) v(radfac) = rfac1 * max(v(rdfcmn),&
     &                                           half * v(gtstep)/emax)
!
!  ***  DO FALSE CONVERGENCE TEST  ***
!
 140  if (v(reldx) .le. v(xftol)) go to 160
         iv(irc) = iv(xirc)
         if (v(f) .lt. v(f0)) go to 230
              go to 300
!
 160  iv(irc) = 12
      go to 310
!
!  ***  HANDLE GOOD FUNCTION DECREASE  ***
!
 200  if (v(fdif) .lt. (-v(tuner3) * v(gtstep))) go to 260
!
!     ***  INCREASING RADIUS LOOKS WORTHWHILE.  SEE IF WE JUST
!     ***  RECOMPUTED STEP WITH A DECREASED RADIUS OR RESTORED STEP
!     ***  AFTER RECOMPUTING IT WITH A LARGER RADIUS.
!
      if (iv(radinc) .lt. 0) go to 260
      if (iv(restor) .eq. 1) go to 260
!
!        ***  WE DID NOT.  TRY A LONGER STEP UNLESS THIS WAS A NEWTON
!        ***  STEP.
!
         v(radfac) = v(rdfcmx)
         gts = v(gtstep)
        if (v(fdif) .lt. (half/v(radfac) - one) * gts)&
     &            v(radfac) = max(v(incfac), half*gts/(gts + v(fdif)))
         iv(irc) = 4
         if (v(stppar) .eq. zero) go to 300
!             ***  STEP WAS NOT A NEWTON STEP.  RECOMPUTE IT WITH
!             ***  A LARGER RADIUS.
              iv(irc) = 5
              iv(radinc) = iv(radinc) + 1
!
!  ***  SAVE VALUES CORRESPONDING TO GOOD STEP  ***
!
 230  v(flstgd) = v(f)
      iv(mlstgd) = iv(model)
      call vcopy(p, stlstg, step)
      v(dstsav) = v(dstnrm)
      iv(nfgcal) = nfc
      v(plstgd) = v(preduc)
      v(gtslst) = v(gtstep)
      go to 300
!
!  ***  ACCEPT STEP WITH RADIUS UNCHANGED  ***
!
 260  v(radfac) = one
      iv(irc) = 3
      go to 300
!
!  ***  COME HERE FOR A RESTART AFTER CONVERGENCE  ***
!
 290  iv(irc) = iv(xirc)
      if (v(dstsav) .ge. zero) go to 310
         iv(irc) = 12
         go to 310
!
!  ***  PERFORM CONVERGENCE TESTS  ***
!
 300  iv(xirc) = iv(irc)
 310  if (abs(v(f)) .lt. v(afctol)) iv(irc) = 10
      if (half * v(fdif) .gt. v(preduc)) go to 999
      emax = 0.0
     if (abs(v(f0)).gt.mach(1)/v(rfctol))&
     &   emax = v(rfctol) * abs(v(f0))
     if (v(dstnrm) .gt. v(lmax0) .and. v(preduc) .le. emax)&
     &                       iv(irc) = 11
      if (v(dst0) .lt. zero) go to 320
      i = 0
     if ((v(nreduc) .gt. zero .and. v(nreduc) .le. emax) .or.&
     &    (v(nreduc) .eq. zero .and. v(preduc) .eq. zero))  i = 2
      if (v(stppar) .eq. zero .and. v(reldx) .le. v(xctol)) i = i + 1
      if (i .gt. 0) iv(irc) = i + 6
!
!  ***  CONSIDER RECOMPUTING STEP OF LENGTH V(LMAX0) FOR SINGULAR
!  ***  CONVERGENCE TEST.
!
 320  if (abs(iv(irc)-3) .gt. 1 .and. iv(irc) .ne. 12) go to 999
      if (v(dstnrm) .gt. v(lmax0)) go to 330
         if (v(preduc) .ge. emax) go to 999
              if (v(dst0) .lt. zero) go to 340
                   if (half * v(dst0) .le. v(lmax0)) go to 999
                        go to 340
 330  if (half * v(dstnrm) .le. v(lmax0)) go to 999
      xmax = v(lmax0) / v(dstnrm)
      if (xmax * (two - xmax) * v(preduc) .ge. emax) go to 999
 340  if (v(nreduc) .lt. zero) go to 370
!
!  ***  RECOMPUTE V(PREDUC) FOR USE IN SINGULAR CONVERGENCE TEST  ***
!
      v(gtslst) = v(gtstep)
      v(dstsav) = v(dstnrm)
      if (iv(irc) .eq. 12) v(dstsav) = -v(dstsav)
      v(plstgd) = v(preduc)
      iv(irc) = 6
      call vcopy(p, stlstg, step)
      go to 999
!
!  ***  PERFORM SINGULAR CONVERGENCE TEST WITH RECOMPUTED V(PREDUC)  ***
!
 360  v(gtstep) = v(gtslst)
      v(dstnrm) = abs(v(dstsav))
      call vcopy(p, step, stlstg)
      iv(irc) = iv(xirc)
      if (v(dstsav) .le. zero) iv(irc) = 12
      v(nreduc) = -v(preduc)
      v(preduc) = v(plstgd)
 370  if (-v(nreduc) .le. v(rfctol) * abs(v(f0))) iv(irc) = 11
!
 999  return
!
!  ***  LAST CARD OF ASSESS FOLLOWS  ***
      end
!NL2ITR
!     subroutine nl2itr (d(p), iv(*), j(nn,p), n, nn, p, r(n), v(*), x(p))
      subroutine nl2itr (d, iv, j, n, nn, p, r, v, x)
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!  ***  CARRY OUT NL2SOL (NONLINEAR LEAST-SQUARES) ITERATIONS  ***
!  ***  (NL2SOL VERSION 2.2)  ***
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer n,nn,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: d(p),j(nn,p),r(n),v(*),x(p)
      integer iv(*)
!
!  LOCAL SCALARS
      real(kind=wp) :: e,half,negone,one,rdof1,sttsst,t,t1,zero
     integer&
    &   cnvcod,cosmin,covmat,covprt,covreq,d0init,dgnorm,dig,dig1,&
    &   dinit,dstnrm,dtype,dummy,f,f0,fdif,fuzz,g,g01,g1,gtstep,h,&
    &   h0,h1,i,ierr,im1,incfac,inits,ipiv0,ipiv1,ipivi,ipivk,&
    &   ipivot,ipk,irc,jtinit,jtol1,k,kagqt,kalm,km1,l,lky,lky1,&
    &   lmat,lmat1,lmax0,lstgst,m,mode,model,mxfcal,mxiter,nfcall,&
    &   nfcov,nfgcal,ngcall,ngcov,niter,nvsave,phmxfc,pp1o2,&
    &   preduc,qtr,qtr1,rad0,radfac,radinc,radius,rd,rd0,rd1,rdk,&
    &   restor,rlimit,rsave,rsave1,s,s1,size,smh,sstep,step,step1,&
    &   stglim,stlstg,stpmod,stppar,sused,switch,temp1,temp2,&
     &   toobig,tuner4,tuner5,vsave1,w,w1,wscale,x0,x01,xirc
!
!  EXTERNAL FUNCTIONS
!      real(kind=wp) :: dotprd,v2norm
!      logical stopx
!      external dotprd,v2norm,stopx
!
!  EXTERNAL SUBROUTINES
!      external assess,covclc,dupdat,gqtstp,itsmry,lmstep,parchk,qapply,
!     &   qrfact,rptmul,slupdt,slvmul,vaxpy,vcopy,vscopy
!
!  INTRINSIC FUNCTIONS
      intrinsic abs,sqrt
!
!  ***  PARAMETER DECLARATIONS  ***
!
!     INTEGER IV(1), N, NN, P
!     REAL(KIND=WP) :: D(P), J(NN,P), R(N), V(1), X(P)
!     DIMENSION IV(60+P), V(93 + 2*N + P*(3*P+31)/2)
!
!
!--------------------------  PARAMETER USAGE  --------------------------
!
! D.... SCALE VECTOR.
! IV... INTEGER VALUE ARRAY.
! J.... N BY P JACOBIAN MATRIX (LEAD DIMENSION NN).
! N.... NUMBER OF OBSERVATIONS (COMPONENTS IN R).
! NN... LEAD DIMENSION OF J.
! P.... NUMBER OF PARAMETERS (COMPONENTS IN X).
! R.... RESIDUAL VECTOR.
! V.... FLOATING-POINT VALUE ARRAY.
! X.... PARAMETER VECTOR.
!
!  ***  DISCUSSION  ***
!
!        PARAMETERS IV, N, P, V, AND X ARE THE SAME AS THE CORRESPOND-
!     ING ONES TO NL2SOL (WHICH SEE), EXCEPT THAT V CAN BE SHORTER
!     (SINCE THE PART OF V THAT NL2SOL USES FOR STORING D, J, AND R IS
!     NOT NEEDED).  MOREOVER, COMPARED WITH NL2SOL, IV(1) MAY HAVE THE
!     TWO ADDITIONAL OUTPUT VALUES 1 AND 2, WHICH ARE EXPLAINED BELOW,
!     AS IS THE USE OF IV(TOOBIG) AND IV(NFGCAL).  THE VALUES IV(D),
!     IV(J), AND IV(R), WHICH ARE OUTPUT VALUES FROM NL2SOL (AND
!     NL2SNO), ARE NOT REFERENCED BY NL2ITR OR THE SUBROUTINES IT CALLS.
!        ON A FRESH START, I.E., A CALL ON NL2ITR WITH IV(1) = 0 OR 12,
!     NL2ITR ASSUMES THAT R = R(X), THE RESIDUAL AT X, AND J = J(X),
!     THE CORRESPONDING JACOBIAN MATRIX OF R AT X.
!
! IV(1) = 1 MEANS THE CALLER SHOULD SET R TO R(X), THE RESIDUAL AT X,
!             AND CALL NL2ITR AGAIN, HAVING CHANGED NONE OF THE OTHER
!             PARAMETERS.  AN EXCEPTION OCCURS IF R CANNOT BE EVALUATED
!             AT X (E.G. IF R WOULD OVERFLOW), WHICH MAY HAPPEN BECAUSE
!             OF AN OVERSIZED STEP.  IN THIS CASE THE CALLER SHOULD SET
!             IV(TOOBIG) = IV(2) TO 1, WHICH WILL CAUSE NL2ITR TO IG-
!             NORE R AND TRY A SMALLER STEP.  THE PARAMETER NF THAT
!             NL2SOL PASSES TO CALCR (FOR POSSIBLE USE BY CALCJ) IS A
!             COPY OF IV(NFCALL) = IV(6).
! IV(1) = 2 MEANS THE CALLER SHOULD SET J TO J(X), THE JACOBIAN MATRIX
!             OF R AT X, AND CALL NL2ITR AGAIN.  THE CALLER MAY CHANGE
!             D AT THIS TIME, BUT SHOULD NOT CHANGE ANY OF THE OTHER
!             PARAMETERS.  THE PARAMETER NF THAT NL2SOL PASSES TO
!             CALCJ IS IV(NFGCAL) = IV(7).  IF J CANNOT BE EVALUATED
!             AT X, THEN THE CALLER MAY SET IV(NFGCAL) TO 0, IN WHICH
!             CASE NL2ITR WILL RETURN WITH IV(1) = 15.
!
!  ***  GENERAL  ***
!
!     CODED BY DAVID M. GAY.
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!
!     MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989, AND
!     MCS-7906671.
!        (SEE NL2SOL FOR REFERENCES.)
!
!+++++++++++++++++++++++++++  DECLARATIONS  ++++++++++++++++++++++++++++
!
!  ***  LOCAL VARIABLES  ***
!
!     INTEGER DUMMY, DIG1, G1, G01, H0, H1, I, IM1, IPIVI, IPIVK, IPIV1,
!    1        IPK, K, KM1, L, LKY1, LMAT1, LSTGST, M, PP1O2, QTR1,
!    2        RDK, RD0, RD1, RSAVE1, SMH, SSTEP, STEP1, STPMOD, S1,
!    3        TEMP1, TEMP2, W1, X01
!     REAL(KIND=WP) :: E, RDOF1, STTSST, T, T1
!
!     ***  CONSTANTS  ***
!
!     REAL(KIND=WP) :: HALF, NEGONE, ONE, ZERO
!
!/
!  ***  EXTERNAL FUNCTIONS AND SUBROUTINES  ***
!
!     EXTERNAL ASSESS, COVCLC, DOTPRD, DUPDAT, GQTSTP, ITSMRY, LMSTEP,
!    1         PARCHK, QAPPLY, QRFACT, RPTMUL, SLUPDT, SLVMUL, STOPX,
!    2         VAXPY, VCOPY, VSCOPY, V2NORM
!     LOGICAL STOPX
!     REAL(KIND=WP) :: DOTPRD, V2NORM
!
! ASSESS... ASSESSES CANDIDATE STEP.
! COVCLC... COMPUTES COVARIANCE MATRIX.
! DOTPRD... RETURNS INNER PRODUCT OF TWO VECTORS.
! DUPDAT... UPDATES SCALE VECTOR D.
! GQTSTP... COMPUTES GOLDFELD-QUANDT-TROTTER STEP (AUGMENTED MODEL).
! ITSMRY... PRINTS ITERATION SUMMARY AND INFO ABOUT INITIAL AND FINAL X.
! LMSTEP... COMPUTES LEVENBERG-MARQUARDT STEP (GAUSS-NEWTON MODEL).
! PARCHK... CHECKS VALIDITY OF INPUT IV AND V VALUES.
! QAPPLY... APPLIES ORTHOGONAL MATRIX Q FROM QRFACT TO A VECTOR.
! QRFACT... COMPUTES QR DECOMPOSITION OF A MATRIX VIA HOUSEHOLDER TRANS.
! RPTMUL... MULTIPLIES VECTOR BY THE R MATRIX (AND/OR ITS TRANSPOSE)
!             STORED BY QRFACT.
! SLUPDT... PERFORMS QUASI-NEWTON UPDATE ON COMPACTLY STORED LOWER TRI-
!             ANGLE OF A SYMMETRIC MATRIX.
! STOPX.... RETURNS .TRUE. IF THE BREAK KEY HAS BEEN PRESSED.
! VAXPY.... COMPUTES SCALAR TIMES ONE VECTOR PLUS ANOTHER.
! VCOPY.... COPIES ONE VECTOR TO ANOTHER.
! VSCOPY... SETS ALL ELEMENTS OF A VECTOR TO A SCALAR.
! V2NORM... RETURNS THE 2-NORM OF A VECTOR.
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER CNVCOD, COSMIN, COVMAT, COVPRT, COVREQ, DGNORM, DIG,
!    1        DINIT, DSTNRM, DTYPE, D0INIT, F, FDIF, FUZZ,
!    2        F0, G, GTSTEP, H, IERR, INCFAC, INITS, IPIVOT, IPIV0, IRC,
!    3        JTINIT, JTOL1, KAGQT, KALM, LKY, LMAT, LMAX0, MODE, MODEL,
!    4        MXFCAL, MXITER, NFCALL, NFGCAL, NFCOV, NGCOV, NGCALL,
!    5        NITER, NVSAVE, PHMXFC, PREDUC, QTR, RADFAC, RADINC,
!    6        RADIUS, RAD0, RD, RESTOR, RLIMIT, RSAVE, S, SIZE, STEP,
!    7        STGLIM, STLSTG, STPPAR, SUSED, SWITCH, TOOBIG, TUNER4,
!    8        TUNER5, VSAVE1, W, WSCALE, XIRC, X0
!
!  ***  IV SUBSCRIPT VALUES  ***
!
     data cnvcod/34/, covmat/26/, covprt/14/,&
    &     covreq/15/, dig/43/, dtype/16/, g/28/, h/44/,&
    &     ierr/32/, inits/25/, ipivot/61/, ipiv0/60/,&
    &     irc/3/, kagqt/35/, kalm/36/, lky/37/, lmat/58/,&
    &     mode/38/, model/5/, mxfcal/17/, mxiter/18/,&
    &     nfcall/6/, nfgcal/7/, nfcov/40/, ngcov/41/,&
    &     ngcall/30/, niter/31/, qtr/49/,&
    &     radinc/8/, rd/51/, restor/9/, rsave/52/, s/53/,&
    &     step/55/, stglim/11/, stlstg/56/, sused/57/,&
     &     switch/12/, toobig/2/, w/59/, xirc/13/, x0/60/
!
!  ***  V SUBSCRIPT VALUES  ***
!
     data cosmin/43/, dgnorm/1/, dinit/38/, dstnrm/2/,&
    &     d0init/37/, f/10/, fdif/11/, fuzz/45/,&
    &     f0/13/, gtstep/4/, incfac/23/,&
    &     jtinit/39/, jtol1/87/, lmax0/35/,&
    &     nvsave/9/, phmxfc/21/, preduc/7/,&
    &     radfac/16/, radius/8/, rad0/9/, rlimit/42/,&
    &     size/47/, stppar/5/, tuner4/29/, tuner5/30/,&
     &     vsave1/78/, wscale/48/
!
!
      data half/0.5_wp/, negone/-1.0_wp/, one/1.0_wp/, zero/0.0_wp/
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
      i = iv(1)
      if (i .eq. 1) go to 20
      if (i .eq. 2) go to 50
!
!  ***  CHECK VALIDITY OF IV AND V INPUT VALUES  ***
!
!     ***  NOTE -- IF IV(1) = 0, THEN PARCHK CALLS DFAULT(IV, V)  ***
      call parchk(iv, n, nn, p, v)
      i = iv(1) - 2
      if (i .gt. 10) go to 999
      go to (350, 350, 350, 350, 350, 350, 195, 160, 195, 10), i
!
!  ***  INITIALIZATION AND STORAGE ALLOCATION  ***
!
 10   iv(niter) = 0
      iv(nfcall) = 1
      iv(ngcall) = 1
      iv(nfgcal) = 1
      iv(mode) = -1
      iv(stglim) = 2
      iv(toobig) = 0
      iv(cnvcod) = 0
      iv(covmat) = 0
      iv(nfcov) = 0
      iv(ngcov) = 0
      iv(kalm) = -1
      iv(radinc) = 0
      iv(s) = jtol1 + 2*p
      pp1o2 = p * (p + 1) / 2
      iv(x0) = iv(s) + pp1o2
      iv(step) = iv(x0) + p
      iv(stlstg) = iv(step) + p
      iv(dig) = iv(stlstg) + p
      iv(g) = iv(dig) + p
      iv(lky) = iv(g) + p
      iv(rd) = iv(lky) + p
      iv(rsave) = iv(rd) + p
      iv(qtr) = iv(rsave) + n
      iv(h) = iv(qtr) + n
      iv(w) = iv(h) + pp1o2
      iv(lmat) = iv(w) + 4*p + 7
!     +++ LENGTH OF W = P*(P+9)/2 + 7.  LMAT IS CONTAINED IN W.
      if (v(dinit) .ge. zero) call vscopy(p, d, v(dinit))
      if (v(jtinit) .gt. zero) call vscopy(p, v(jtol1), v(jtinit))
      i = jtol1 + p
      if (v(d0init) .gt. zero) call vscopy(p, v(i), v(d0init))
      v(rad0) = zero
      v(stppar) = zero
      v(radius) = v(lmax0) / (one + v(phmxfc))
!
!  ***  SET INITIAL MODEL AND S MATRIX  ***
!
      iv(model) = 1
      if (iv(inits) .eq. 2) iv(model) = 2
      s1 = iv(s)
      if (iv(inits) .eq. 0) call vscopy(pp1o2, v(s1), zero)
!
!  ***  COMPUTE FUNCTION VALUE (HALF THE SUM OF SQUARES)  ***
!
 20   t = v2norm(n, r)
      if (t .gt. v(rlimit)) iv(toobig) = 1
      if (iv(toobig) .ne. 0) go to 30
      v(f) = 0.0
      if (t.gt.sqrt(mach(1))) v(f) = half * t**2
 30   if (iv(mode)) 40, 350, 730
!
 40   if (iv(toobig) .eq. 0) go to 60
         iv(1) = 13
         go to 900
!
!  ***  MAKE SURE JACOBIAN COULD BE COMPUTED  ***
!
 50   if (iv(nfgcal) .ne. 0) go to 60
         iv(1) = 15
         go to 900
!
!  ***  COMPUTE GRADIENT  ***
!
 60   iv(kalm) = -1
      g1 = iv(g)
      do 70 i = 1, p
         v(g1) = dotprd(n, r, j(1,i))
         g1 = g1 + 1
 70      continue
      if (iv(mode) .gt. 0) go to 710
!
!  ***  UPDATE D AND MAKE COPIES OF R FOR POSSIBLE USE LATER  ***
!
      if (iv(dtype) .gt. 0) call dupdat(d, iv, j, n, nn, p, v)
      rsave1 = iv(rsave)
      call vcopy(n, v(rsave1), r)
      qtr1 = iv(qtr)
      call vcopy(n, v(qtr1), r)
!
!  ***  COMPUTE  D**-1 * GRADIENT  ***
!
      g1 = iv(g)
      dig1 = iv(dig)
      k = dig1
      do 80 i = 1, p
         v(k) = v(g1) / d(i)
         k = k + 1
         g1 = g1 + 1
 80      continue
      v(dgnorm) = v2norm(p, v(dig1))
!
      if (iv(cnvcod) .ne. 0) go to 700
      if (iv(mode) .eq. 0) go to 570
      iv(mode) = 0
!
!
!-----------------------------  MAIN LOOP  -----------------------------
!
!
!  ***  PRINT ITERATION SUMMARY, CHECK ITERATION LIMIT  ***
!
 150  call itsmry(d, iv, p, v, x)
 160  k = iv(niter)
      if (k .lt. iv(mxiter)) go to 170
         iv(1) = 10
         go to 900
 170  iv(niter) = k + 1
!
!  ***  UPDATE RADIUS  ***
!
      if (k .eq. 0) go to 185
      step1 = iv(step)
      do 180 i = 1, p
         v(step1) = d(i) * v(step1)
         step1 = step1 + 1
 180     continue
      step1 = iv(step)
      v(radius) = v(radfac) * v2norm(p, v(step1))
!
!  ***  INITIALIZE FOR START OF NEXT ITERATION  ***
!
 185  x01 = iv(x0)
      v(f0) = v(f)
      iv(kagqt) = -1
      iv(irc) = 4
      iv(h) = -abs(iv(h))
      iv(sused) = iv(model)
!
!     ***  COPY X TO X0  ***
!
      call vcopy(p, v(x01), x)
!
!  ***  CHECK STOPX AND FUNCTION EVALUATION LIMIT  ***
!
 190  if (.not. stopx(dummy)) go to 200
         iv(1) = 11
         go to 205
!
!     ***  COME HERE WHEN RESTARTING AFTER FUNC. EVAL. LIMIT OR STOPX.
!
 195  if (v(f) .ge. v(f0)) go to 200
         v(radfac) = one
         k = iv(niter)
         go to 170
!
 200  if (iv(nfcall) .lt. iv(mxfcal) + iv(nfcov)) go to 210
         iv(1) = 9
 205     if (v(f) .ge. v(f0)) go to 900
!
!        ***  IN CASE OF STOPX OR FUNCTION EVALUATION LIMIT WITH
!        ***  IMPROVED V(F), EVALUATE THE GRADIENT AT X.
!
              iv(cnvcod) = iv(1)
              go to 560
!
!. . . . . . . . . . . . .  COMPUTE CANDIDATE STEP  . . . . . . . . . .
!
 210  step1 = iv(step)
      w1 = iv(w)
      if (iv(model) .eq. 2) go to 240
!
!  ***  COMPUTE LEVENBERG-MARQUARDT STEP  ***
!
         qtr1 = iv(qtr)
         if (iv(kalm) .ge. 0) go to 215
              rd1 = iv(rd)
             if (-1 .eq. iv(kalm)) call qrfact(nn, n, p, j, v(rd1),&
     &                                   iv(ipivot), iv(ierr), 0, v(w1))
              call qapply(nn, n, p, j, v(qtr1), iv(ierr))
 215     h1 = iv(h)
         if (h1 .gt. 0) go to 230
!
!        ***  COPY R MATRIX TO H  ***
!
              h1 = -h1
              iv(h) = h1
              k = h1
              rd1 = iv(rd)
              v(k) = v(rd1)
              if (p .eq. 1) go to 230
              do 220 i = 2, p
                   call vcopy(i-1, v(k+1), j(1,i))
                   k = k + i
                   rd1 = rd1 + 1
                   v(k) = v(rd1)
 220               continue
!
 230     g1 = iv(g)
        call lmstep(d, v(g1), iv(ierr), iv(ipivot), iv(kalm), p,&
     &               v(qtr1), v(h1), v(step1), v, v(w1))
         go to 310
!
!  ***  COMPUTE GOLDFELD-QUANDT-TROTTER STEP (AUGMENTED MODEL)  ***
!
 240  if (iv(h) .gt. 0) go to 300
!
!     ***  SET H TO  D**-1 * ( (J**T)*J + S) ) * D**-1.  ***
!
         h1 = -iv(h)
         iv(h) = h1
         s1 = iv(s)
         if (iv(kalm) .ge. 0) go to 270
!
!        ***  J IS IN ITS ORIGINAL FORM  ***
!
              do 260 i = 1, p
                   t = one / d(i)
                   do 250 k = 1, i
                        v(h1) = t*(dotprd(n,j(1,i),j(1,k))+v(s1)) / d(k)
                        h1 = h1 + 1
                        s1 = s1 + 1
 250                    continue
 260               continue
              go to 300
!
!  ***  LMSTEP HAS APPLIED QRFACT TO J  ***
!
 270     smh = s1 - h1
         h0 = h1 - 1
         ipiv1 = iv(ipivot)
         t1 = one / d(ipiv1)
         rd0 = iv(rd) - 1
         rdof1 = v(rd0 + 1)
         do 290 i = 1, p
              l = ipiv0 + i
              ipivi = iv(l)
              h1 = h0 + ipivi*(ipivi-1)/2
              l = h1 + ipivi
              m = l + smh
!             ***  V(L) = H(IPIVOT(I), IPIVOT(I))  ***
!             ***  V(M) = S(IPIVOT(I), IPIVOT(I))  ***
              t = one / d(ipivi)
              rdk = rd0 + i
              e = v(rdk)**2
              if (i .gt. 1) e = e + dotprd(i-1, j(1,i), j(1,i))
              v(l) = (e + v(m)) * t**2
              if (i .eq. 1) go to 290
              l = h1 + ipiv1
             if (ipivi .lt. ipiv1) l = l +&
     &                               ((ipiv1-ipivi)*(ipiv1+ipivi-3))/2
              m = l + smh
!             ***  V(L) = H(IPIVOT(I), IPIVOT(1))  ***
!             ***  V(M) = S(IPIVOT(I), IPIVOT(1))  ***
              v(l) = t * (rdof1 * j(1,i)  +  v(m)) * t1
              if (i .eq. 2) go to 290
              im1 = i - 1
              do 280 k = 2, im1
                   ipk = ipiv0 + k
                   ipivk = iv(ipk)
                   l = h1 + ipivk
                  if (ipivi .lt. ipivk) l = l +&
     &                               ((ipivk-ipivi)*(ipivk+ipivi-3))/2
                   m = l + smh
!                  ***  V(L) = H(IPIVOT(I), IPIVOT(K))  ***
!                  ***  V(M) = S(IPIVOT(I), IPIVOT(K))  ***
                   km1 = k - 1
                   rdk = rd0 + k
                  v(l) = t * (dotprd(km1, j(1,i), j(1,k)) +&
     &                            v(rdk)*j(k,i) + v(m)) / d(ipivk)
 280               continue
 290          continue
!
!  ***  COMPUTE ACTUAL GOLDFELD-QUANDT-TROTTER STEP  ***
!
 300  h1 = iv(h)
      dig1 = iv(dig)
      lmat1 = iv(lmat)
     call gqtstp(d, v(dig1), v(h1), iv(kagqt), v(lmat1), p, v(step1),&
     &            v, v(w1))
!
!
!  ***  COMPUTE R(X0 + STEP)  ***
!
 310  if (iv(irc) .eq. 6) go to 350
      x01 = iv(x0)
      step1 = iv(step)
      call vaxpy(p, x, one, v(step1), v(x01))
      iv(nfcall) = iv(nfcall) + 1
      iv(1) = 1
      iv(toobig) = 0
      go to 999
!
!. . . . . . . . . . . . .  ASSESS CANDIDATE STEP  . . . . . . . . . . .
!
 350  step1 = iv(step)
      lstgst = iv(stlstg)
      x01 = iv(x0)
      call assess(d, iv, p, v(step1), v(lstgst), v, x, v(x01))
!
!  ***  IF NECESSARY, SWITCH MODELS AND/OR RESTORE R  ***
!
      if (iv(switch) .eq. 0) go to 360
         iv(h) = -abs(iv(h))
         iv(sused) = iv(sused) + 2
         call vcopy(nvsave, v, v(vsave1))
 360  if (iv(restor) .eq. 0) go to 390
         rsave1 = iv(rsave)
         call vcopy(n, r, v(rsave1))
 390  l = iv(irc) - 4
      stpmod = iv(model)
      if (l .gt. 0) go to (410,440,450,450,450,450,450,450,640,570), l
!
!  ***  DECIDE WHETHER TO CHANGE MODELS  ***
!
      e = v(preduc) - v(fdif)
      sstep = iv(lky)
      s1 = iv(s)
      call slvmul(p, v(sstep), v(s1), v(step1))
      sttsst = half * dotprd(p, v(step1), v(sstep))
      if (iv(model) .eq. 1) sttsst = -sttsst
      if (abs(e + sttsst) * v(fuzz) .ge. abs(e)) go to 400
!
!     ***  SWITCH MODELS  ***
!
         iv(model) = 3 - iv(model)
         if (iv(model) .eq. 1) iv(kagqt) = -1
         if (iv(model) .eq. 2 .and. iv(kalm) .gt. 0) iv(kalm) = 0
         if (-2 .lt. l) go to 480
              iv(h) = -abs(iv(h))
              iv(sused) = iv(sused) + 2
              call vcopy(nvsave, v(vsave1), v)
              go to 420
!
 400  if (-3 .lt. l) go to 480
!
!     ***  RECOMPUTE STEP WITH DECREASED RADIUS  ***
!
         v(radius) = v(radfac) * v(dstnrm)
         go to 190
!
!  ***  RECOMPUTE STEP, SAVING V VALUES AND R IF NECESSARY  ***
!
 410  v(radius) = v(radfac) * v(dstnrm)
 420  if (v(f) .ge. v(f0)) go to 190
      rsave1 = iv(rsave)
      call vcopy(n, v(rsave1), r)
      go to 190
!
!  ***  COMPUTE STEP OF LENGTH V(LMAX0) FOR SINGULAR CONVERGENCE TEST
!
 440  v(radius) = v(lmax0)
      go to 210
!
!  ***  CONVERGENCE OR FALSE CONVERGENCE  ***
!
 450  iv(cnvcod) = l
      if (v(f) .ge. v(f0)) go to 700
         if (iv(xirc) .eq. 14) go to 700
              iv(xirc) = 14
!
!. . . . . . . . . . . .  PROCESS ACCEPTABLE STEP  . . . . . . . . . . .
!
 480  iv(covmat) = 0
!
!  ***  SET  LKY = (J(X0)**T) * R(X)  ***
!
      lky1 = iv(lky)
      if (iv(kalm) .ge. 0) go to 500
!
!     ***  JACOBIAN HAS NOT BEEN MODIFIED  ***
!
         do 490 i = 1, p
              v(lky1) = dotprd(n, j(1,i), r)
              lky1 = lky1 + 1
 490          continue
         go to 510
!
!  ***  QRFACT HAS BEEN APPLIED TO J.  STORE COPY OF R IN QTR AND  ***
!  ***  APPLY Q TO IT.                                             ***
!
 500  qtr1 = iv(qtr)
      call vcopy(n, v(qtr1), r)
      call qapply(nn, n, p, j, v(qtr1), iv(ierr))
!
!  ***  MULTIPLY TOP P-VECTOR IN QTR BY PERMUTED UPPER TRIANGLE    ***
!  ***  STORED BY QRFACT IN J AND RD.                              ***
!
      rd1 = iv(rd)
      temp1 = iv(stlstg)
     call rptmul(3, iv(ipivot), j, nn, p, v(rd1), v(qtr1), v(lky1),&
     &            v(temp1))
!
!  ***  SEE WHETHER TO SET V(RADFAC) BY GRADIENT TESTS  ***
!
 510  if (iv(irc) .ne. 3) go to 560
         step1 = iv(step)
         temp1 = iv(stlstg)
         temp2 = iv(x0)
!
!     ***  SET  TEMP1 = HESSIAN * STEP  FOR USE IN GRADIENT TESTS  ***
!
         if (stpmod .eq. 2) go to 530
!
!        ***  STEP COMPUTED USING GAUSS-NEWTON MODEL  ***
!        ***  -- QRFACT HAS BEEN APPLIED TO J         ***
!
              rd1 = iv(rd)
             call rptmul(2, iv(ipivot), j, nn, p, v(rd1),&
     &                    v(step1), v(temp1), v(temp2))
              go to 560
!
!     ***  STEP COMPUTED USING AUGMENTED MODEL  ***
!
 530     h1 = iv(h)
         k = temp2
         do 540 i = 1, p
              v(k) = d(i) * v(step1)
              k = k + 1
              step1 = step1 + 1
 540          continue
         call slvmul(p, v(temp1), v(h1), v(temp2))
         do 550 i = 1, p
              v(temp1) = d(i) * v(temp1)
              temp1 = temp1 + 1
 550          continue
!
!  ***  SAVE OLD GRADIENT AND COMPUTE NEW ONE  ***
!
 560  iv(ngcall) = iv(ngcall) + 1
      g1 = iv(g)
      g01 = iv(w)
      call vcopy(p, v(g01), v(g1))
      iv(1) = 2
      go to 999
!
!  ***  INITIALIZATIONS -- G0 = G - G0, ETC.  ***
!
 570  g01 = iv(w)
      g1 = iv(g)
      call vaxpy(p, v(g01), negone, v(g01), v(g1))
      step1 = iv(step)
      temp1 = iv(stlstg)
      temp2 = iv(x0)
      if (iv(irc) .ne. 3) go to 600
!
!  ***  SET V(RADFAC) BY GRADIENT TESTS  ***
!
!     ***  SET  TEMP1 = D**-1 * (HESSIAN * STEP  +  (G(X0) - G(X)))  ***
!
         k = temp1
         l = g01
         do 580 i = 1, p
              v(k) = (v(k) - v(l)) / d(i)
              k = k + 1
              l = l + 1
 580          continue
!
!        ***  DO GRADIENT TESTS  ***
!
         if (v2norm(p, v(temp1)) .le. v(dgnorm) * v(tuner4))  go to 590
             if (dotprd(p, v(g1), v(step1))&
     &                  .ge. v(gtstep) * v(tuner5))  go to 600
 590               v(radfac) = v(incfac)
!
!  ***  FINISH COMPUTING LKY = ((J(X) - J(X0))**T) * R  ***
!
!     ***  CURRENTLY LKY = (J(X0)**T) * R  ***
!
 600  lky1 = iv(lky)
      call vaxpy(p, v(lky1), negone, v(lky1), v(g1))
!
!  ***  DETERMINE SIZING FACTOR V(SIZE)  ***
!
!     ***  SET TEMP1 = S * STEP  ***
      s1 = iv(s)
      call slvmul(p, v(temp1), v(s1), v(step1))
!
      t1 = abs(dotprd(p, v(step1), v(temp1)))
      t = abs(dotprd(p, v(step1), v(lky1)))
      v(size) = one
      if (t .lt. t1) v(size) = t / t1
!
!  ***  UPDATE S  ***
!
     call slupdt(v(s1), v(cosmin), p, v(size), v(step1), v(temp1),&
     &            v(temp2), v(g01), v(wscale), v(lky1))
      iv(1) = 2
      go to 150
!
!. . . . . . . . . . . . . .  MISC. DETAILS  . . . . . . . . . . . . . .
!
!  ***  BAD PARAMETERS TO ASSESS  ***
!
 640  iv(1) = 14
      go to 900
!
!  ***  CONVERGENCE OBTAINED -- COMPUTE COVARIANCE MATRIX IF DESIRED ***
!
 700  if (iv(covreq) .eq. 0 .and. iv(covprt) .eq. 0) go to 760
      if (iv(covmat) .ne. 0) go to 760
      if (iv(cnvcod) .ge. 7) go to 760
      iv(mode) = 0
 710  call covclc(i, d, iv, j, n, nn, p, r, v, x)
      go to (720, 720, 740, 750), i
 720  iv(nfcov) = iv(nfcov) + 1
      iv(nfcall) = iv(nfcall) + 1
      iv(restor) = i
      iv(1) = 1
      go to 999
!
 730  if (iv(restor) .eq. 1 .or. iv(toobig) .ne. 0) go to 710
      iv(nfgcal) = iv(nfcall)
 740  iv(ngcov) = iv(ngcov) + 1
      iv(ngcall) = iv(ngcall) + 1
      iv(1) = 2
      go to 999
!
 750  iv(mode) = 0
      if (iv(niter) .eq. 0) iv(mode) = -1
!
 760  iv(1) = iv(cnvcod)
      iv(cnvcod) = 0
!
!  ***  PRINT SUMMARY OF FINAL ITERATION AND OTHER REQUESTED ITEMS  ***
!
 900  call itsmry(d, iv, p, v, x)
!
 999  return
!
!  ***  LAST CARD OF NL2ITR FOLLOWS  ***
      end
!NL2SOL
     subroutine nl2sol(n, p, x, calcr, calcj, iv, v, uiparm, urparm, ufparm)
!
!  ***  MINIMIZE NONLINEAR SUM OF SQUARES USING ANALYTIC JACOBIAN  ***
!  ***  (NL2SOL VERSION 2.2)  ***
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer n,p
!
!  ARRAY ARGUMENTS
      real(kind=wp) :: urparm(:),v(:),x(p)
      integer iv(:),uiparm(:)
!
!  SUBROUTINE ARGUMENTS
      external calcj,calcr,ufparm
!
!  LOCAL SCALARS
      integer d,d1,j,j1,nf,nfcall,nfgcal,r,r1,toobig
      logical strted
!
!  EXTERNAL SUBROUTINES
!      external itsmry,nl2itr
!
!
!     INTEGER N, P, IV(:), UIPARM(:)
!     REAL(KIND=WP) :: X(P), V(1), URPARM(1)
!     DIMENSION IV(60+P),  V(93 + N*P + 3*N + P*(3*P+33)/2)
!
!  ***  PURPOSE  ***
!
!        GIVEN A P-VECTOR X OF PARAMETERS, CALCR COMPUTES AN N-VECTOR
!     R = R(X) OF RESIDUALS CORRESPONDING TO X.  (R(X) PROBABLY ARISES
!     FROM A NONLINEAR MODEL INVOLVING P PARAMETERS AND N OBSERVATIONS.)
!     THIS ROUTINE INTERACTS WITH NL2ITR TO SEEK A PARAMETER VECTOR X
!     THAT MINIMIZES THE SUM OF THE SQUARES OF (THE COMPONENTS OF) R(X),
!     I.E., THAT MINIMIZES THE SUM-OF-SQUARES FUNCTION
!     F(X) = (R(X)**T) * R(X) / 2.  R(X) IS ASSUMED TO BE A TWICE CONTINUOUSLY
!     DIFFERENTIABLE FUNCTION OF X.
!
!--------------------------  PARAMETER USAGE  --------------------------
!
! N........ (INPUT) THE NUMBER OF OBSERVATIONS, I.E., THE NUMBER OF
!                  COMPONENTS IN R(X).  N MUST BE .GE. P.
! P........ (INPUT) THE NUMBER OF PARAMETERS (COMPONENTS IN X).  P MUST
!                  BE POSITIVE.
! X........ (INPUT/OUTPUT).  ON INPUT, X IS AN INITIAL GUESS AT THE
!                  DESIRED PARAMETER ESTIMATE.  ON OUTPUT, X CONTAINS
!                  THE BEST PARAMETER ESTIMATE FOUND.
! CALCR.... (INPUT) A SUBROUTINE WHICH, GIVEN X, COMPUTES R(X).  CALCR
!                  MUST BE DECLARED EXTERNAL IN THE CALLING PROGRAM.
!                  IT IS INVOKED BY
!                       CALL CALCR(N,P,X,NF,R,UIPARM,URPARM,UFPARM)
!                  WHEN CALCR IS CALLED, NF IS THE INVOCATION COUNT
!                  FOR CALCR.  IT IS INCLUDED FOR POSSIBLE USE WITH
!                  CALCJ.  IF X IS OUT OF BOUNDS (E.G. IF IT WOULD
!                  CAUSE OVERFLOW IN COMPUTING R(X)), THEN CALCR SHOULD
!                  SET NF TO 0.  THIS WILL CAUSE A SHORTER STEP TO BE
!                  ATTEMPTED.  THE OTHER PARAMETERS ARE AS DESCRIBED
!                  ABOVE AND BELOW.  CALCR SHOULD NOT CHANGE N, P, OR X.
! CALCJ.... (INPUT) A SUBROUTINE WHICH, GIVEN X, COMPUTES THE JACOBIAN
!                  MATRIX J OF R AT X, I.E., THE N BY P MATRIX WHOSE
!                  (I,K) ENTRY IS THE PARTIAL DERIVATIVE OF THE I-TH
!                  COMPONENT OF R WITH RESPECT TO X(K).  CALCJ MUST BE
!                  DECLARED EXTERNAL IN THE CALLING PROGRAM.  IT IS
!                  INVOKED BY
!                       CALL CALCJ(N,P,X,NF,J,UIPARM,URPARM,UFPARM)
!                  NF IS THE INVOCATION COUNT FOR CALCR AT THE TIME
!                  R(X) WAS EVALUATED.  THE X PASSED TO CALCJ IS
!                  USUALLY THE ONE PASSED TO CALCR ON EITHER ITS MOST
!                  RECENT INVOCATION OR THE ONE PRIOR TO IT.  IF CALCR
!                  SAVES INTERMEDIATE RESULTS FOR USE BY CALCJ, THEN IT
!                  IS POSSIBLE TO TELL FROM NF WHETHER THEY ARE VALID
!                  FOR THE CURRENT X (OR WHICH COPY IS VALID IF TWO
!                  COPIES ARE KEPT).  IF J CANNOT BE COMPUTED AT X,
!                  THEN CALCJ SHOULD SET NF TO 0.  IN THIS CASE, NL2SOL
!                  WILL RETURN WITH IV(1) = 15.  THE OTHER PARAMETERS
!                  TO CALCJ ARE AS DESCRIBED ABOVE AND BELOW.  CALCJ
!                  SHOULD NOT CHANGE N, P, OR X.
! IV....... (INPUT/OUTPUT) AN INTEGER VALUE ARRAY OF LENGTH AT LEAST
!                  60 + P THAT HELPS CONTROL THE NL2SOL ALGORITHM AND
!                  THAT IS USED TO STORE VARIOUS INTERMEDIATE QUANTITIES.
!                  OF PARTICULAR INTEREST ARE THE INITIALIZATION/
!                  RETURN CODE IV(1) AND THE ENTRIES IN IV THAT CONTROL
!                  PRINTING AND LIMIT THE NUMBER OF ITERATIONS AND FUNCTION
!                  EVALUATIONS.  SEE THE SECTION ON IV INPUT
!                  VALUES BELOW.
! V........ (INPUT/OUTPUT) A FLOATING-POINT VALUE ARRAY OF LENGTH AT
!                  LEAST 93 + N*P + 3*N + P*(3*P+33) THAT HELPS CONTROL
!                  THE NL2SOL ALGORITHM AND THAT IS USED TO STORE
!                  VARIOUS INTERMEDIATE QUANTITIES.  OF PARTICULAR INTEREST
!                  ARE THE ENTRIES IN V THAT LIMIT THE LENGTH OF
!                  THE FIRST STEP ATTEMPTED (LMAX0), SPECIFY CONVERGENCE
!                  TOLERANCES (AFCTOL, RFCTOL, XCTOL, XFTOL),
!                  AND HELP CHOOSE THE STEP SIZE USED IN COMPUTING THE
!                  COVARIANCE MATRIX (DELTA0).  SEE THE SECTION ON
!                  (SELECTED) V INPUT VALUES BELOW.
! UIPARM... (INPUT) USER INTEGER PARAMETER ARRAY PASSED WITHOUT CHANGE
!                  TO CALCR AND CALCJ.
! URPARM... (INPUT) USER FLOATING-POINT PARAMETER ARRAY PASSED WITHOUT
!                  CHANGE TO CALCR AND CALCJ.
! UFPARM... (INPUT) USER EXTERNAL SUBROUTINE OR FUNCTION PASSED WITHOUT
!                  CHANGE TO CALCR AND CALCJ.
!
!  ***  IV INPUT VALUES (FROM SUBROUTINE DFAULT)  ***
!
! IV(1)...  ON INPUT, IV(1) SHOULD HAVE A VALUE BETWEEN 0 AND 12......
!             0 AND 12 MEAN THIS IS A FRESH START.  0 MEANS THAT
!             DFAULT(IV, V) IS TO BE CALLED TO PROVIDE ALL DEFAULT
!             VALUES TO IV AND V.  12 (THE VALUE THAT DFAULT ASSIGNS TO
!             IV(1)) MEANS THE CALLER HAS ALREADY CALLED DFAULT(IV, V)
!             AND HAS POSSIBLY CHANGED SOME IV AND/OR V ENTRIES TO NON-
!             DEFAULT VALUES.  DEFAULT = 12.
! IV(COVPRT)... IV(14) = 1 MEANS PRINT A COVARIANCE MATRIX AT THE SOLUTION.
!             (THIS MATRIX IS COMPUTED JUST BEFORE A RETURN WITH
!             IV(1) = 3, 4, 5, 6.)
!             IV(COVPRT) = 0 MEANS SKIP THIS PRINTING.  DEFAULT = 1.
! IV(COVREQ)... IV(15) = NONZERO MEANS COMPUTE A COVARIANCE MATRIX
!             JUST BEFORE A RETURN WITH IV(1) = 3, 4, 5, 6.  IN
!             THIS CASE, AN APPROXIMATE COVARIANCE MATRIX IS OBTAINED
!             IN ONE OF SEVERAL WAYS.  LET K = ABS(IV(COVREQ)) AND LET
!             SCALE = 2*F(X)/MAX(1,N-P),  WHERE 2*F(X) IS THE RESIDUAL
!             SUM OF SQUARES.  IF K = 1 OR 2, THEN A FINITE-DIFFERENCE
!             HESSIAN APPROXIMATION H IS OBTAINED.  IF H IS POSITIVE
!             DEFINITE (OR, FOR K = 3, IF THE JACOBIAN MATRIX J AT X
!             IS NONSINGULAR), THEN ONE OF THE FOLLOWING IS COMPUTED...
!                  K = 1....  SCALE * H**-1 * (J**T * J) * H**-1.
!                  K = 2....  SCALE * H**-1.
!                  K = 3....  SCALE * (J**T * J)**-1.
!             (J**T IS THE TRANSPOSE OF J, WHILE **-1 MEANS INVERSE.)
!             IF IV(COVREQ) IS POSITIVE, THEN BOTH FUNCTION AND GRADIENT
!             VALUES (CALLS ON CALCR AND CALCJ) ARE USED IN COMPUTING
!             H (WITH STEP SIZES DETERMINED USING V(DELTA0) --
!             SEE BELOW), WHILE IF IV(COVREQ) IS NEGATIVE, THEN ONLY
!             FUNCTION VALUES (CALLS ON CALCR) ARE USED (WITH STEP
!             SIZES DETERMINED USING V(DLTFDC) -- SEE BELOW).  IF
!             IV(COVREQ) = 0, THEN NO ATTEMPT IS MADE TO COMPUTE A
!             COVARIANCE MATRIX (UNLESS IV(COVPRT) = 1, IN WHICH CASE
!             IV(COVREQ) = 1 IS ASSUMED).  SEE IV(COVMAT) BELOW.
!             DEFAULT = 1.
! IV(DTYPE).... IV(16) TELLS HOW THE SCALE VECTOR D (SEE REF. 1) SHOULD
!             BE CHOSEN.  IV(DTYPE) .GE. 1 MEANS CHOOSE D AS DESCRIBED
!             BELOW WITH V(DFAC).  IV(DTYPE) .LE. 0 MEANS THE CALLER
!             HAS CHOSEN D AND HAS STORED IT IN V STARTING AT
!             V(94 + 2*N + P*(3*P + 31)/2).  DEFAULT = 1.
! IV(INITS).... IV(25) TELLS HOW THE S MATRIX (SEE REF. 1) SHOULD BE
!             INITIALIZED.  0 MEANS INITIALIZE S TO 0 (AND START WITH
!             THE GAUSS-NEWTON MODEL).  1 AND 2 MEAN THAT THE CALLER
!             HAS STORED THE LOWER TRIANGLE OF THE INITIAL S ROWWISE IN
!             V STARTING AT V(87+2*P).  IV(INITS) = 1 MEANS START WITH
!             THE GAUSS-NEWTON MODEL, WHILE IV(INITS) = 2 MEANS START
!             WITH THE AUGMENTED MODEL (SEE REF. 1).  DEFAULT = 0.
! IV(MXFCAL)... IV(17) GIVES THE MAXIMUM NUMBER OF FUNCTION EVALUATIONS
!             (CALLS ON CALCR, EXCLUDING THOSE USED TO COMPUTE THE
!             COVARIANCE MATRIX) ALLOWED.  IF THIS NUMBER DOES NOT SUFFICE,
!             THEN NL2SOL RETURNS WITH IV(1) = 9.  DEFAULT = 200.
! IV(MXITER)... IV(18) GIVES THE MAXIMUM NUMBER OF ITERATIONS ALLOWED.
!             IT ALSO INDIRECTLY LIMITS THE NUMBER OF GRADIENT EVALUATIONS
!             (CALLS ON CALCJ, EXCLUDING THOSE USED TO COMPUTE
!             THE COVARIANCE MATRIX) TO IV(MXITER) + 1.  IF IV(MXITER)
!             ITERATIONS DO NOT SUFFICE, THEN NL2SOL RETURNS WITH
!             IV(1) = 10.  DEFAULT = 150.
! IV(OUTLEV)... IV(19) CONTROLS THE NUMBER AND LENGTH OF ITERATION SUMMARY
!             LINES PRINTED (BY ITSMRY).  IV(OUTLEV) = 0 MEANS DO
!             NOT PRINT ANY SUMMARY LINES.  OTHERWISE, PRINT A SUMMARY
!             LINE AFTER EACH ABS(IV(OUTLEV)) ITERATIONS.  IF IV(OUTLEV)
!             IS POSITIVE, THEN SUMMARY LINES OF LENGTH 117 (PLUS CARRIAGE
!             CONTROL) ARE PRINTED, INCLUDING THE FOLLOWING...  THE
!             ITERATION AND FUNCTION EVALUATION COUNTS, CURRENT FUNCTION
!             VALUE (V(F) = HALF THE SUM OF SQUARES), RELATIVE
!             DIFFERENCE IN FUNCTION VALUES ACHIEVED BY THE LATEST STEP
!             (I.E., RELDF = (F0-V(F))/F0, WHERE F0 IS THE FUNCTION
!             VALUE FROM THE PREVIOUS ITERATION), THE RELATIVE FUNCTION
!             REDUCTION PREDICTED FOR THE STEP JUST TAKEN (I.E.,
!             PRELDF = V(PREDUC) / F0, WHERE V(PREDUC) IS DESCRIBED
!             BELOW), THE SCALED RELATIVE CHANGE IN X (SEE V(RELDX)
!             BELOW), THE MODELS USED IN THE CURRENT ITERATION (G =
!             GAUSS-NEWTON, S=AUGMENTED), THE MARQUARDT PARAMETER
!             STPPAR USED IN COMPUTING THE LAST STEP, THE SIZING FACTOR
!             USED IN UPDATING S, THE 2-NORM OF THE SCALE VECTOR D
!             TIMES THE STEP JUST TAKEN (SEE REF. 1), AND NPRELDF, I.E.,
!             V(NREDUC)/F0, WHERE V(NREDUC) IS DESCRIBED BELOW -- IF
!             NPRELDF IS POSITIVE, THEN IT IS THE RELATIVE FUNCTION
!             REDUCTION PREDICTED FOR A NEWTON STEP (ONE WITH
!             STPPAR = 0).  IF NPRELDF IS ZERO, EITHER THE GRADIENT
!             VANISHES (AS DOES PRELDF) OR ELSE THE AUGMENTED MODEL
!             IS BEING USED AND ITS HESSIAN IS INDEFINITE (WITH PRELDF
!             POSITIVE).  IF NPRELDF IS NEGATIVE, THEN IT IS THE NEGATIVE
!             OF THE RELATIVE FUNCTION REDUCTION PREDICTED FOR A STEP
!             COMPUTED WITH STEP BOUND V(LMAX0) FOR USE IN TESTING FOR
!             SINGULAR CONVERGENCE.
!                  IF IV(OUTLEV) IS NEGATIVE, THEN LINES OF MAXIMUM
!             LENGTH 79 (OR 55 IS IV(COVPRT) = 0) ARE PRINTED, INCLUDING
!             ONLY THE FIRST 6 ITEMS LISTED ABOVE (THROUGH RELDX).
!             DEFAULT = 1.
! IV(PARPRT)... IV(20) = 1 MEANS PRINT ANY NONDEFAULT V VALUES ON A
!             FRESH START OR ANY CHANGED V VALUES ON A RESTART.
!             IV(PARPRT) = 0 MEANS SKIP THIS PRINTING.  DEFAULT = 1.
! IV(PRUNIT)... IV(21) IS THE OUTPUT UNIT NUMBER ON WHICH ALL PRINTING
!             IS DONE.  IV(PRUNIT) = 0 MEANS SUPPRESS ALL PRINTING.
!             (SETTING IV(PRUNIT) TO 0 IS THE ONLY WAY TO SUPPRESS THE
!             ONE-LINE TERMINATION REASON MESSAGE PRINTED BY ITSMRY.)
!             DEFAULT = STANDARD OUTPUT UNIT (UNIT 6 ON MOST SYSTEMS).
! IV(SOLPRT)... IV(22) = 1 MEANS PRINT OUT THE VALUE OF X RETURNED (AS
!             WELL AS THE CORRESPONDING GRADIENT AND SCALE VECTOR D).
!             IV(SOLPRT) = 0 MEANS SKIP THIS PRINTING.  DEFAULT = 1.
! IV(STATPR)... IV(23) = 1 MEANS PRINT SUMMARY STATISTICS UPON RETURNING.
!             THESE CONSIST OF THE FUNCTION VALUE (HALF THE SUM
!             OF SQUARES) AT X, V(RELDX) (SEE BELOW), THE NUMBER OF
!             FUNCTION AND GRADIENT EVALUATIONS (CALLS ON CALCR AND
!             CALCJ RESPECTIVELY, EXCLUDING ANY CALLS USED TO COMPUTE
!             THE COVARIANCE), THE RELATIVE FUNCTION REDUCTIONS PREDICTED
!             FOR THE LAST STEP TAKEN AND FOR A NEWTON STEP (OR PERHAPS
!             A STEP BOUNDED BY V(LMAX0) -- SEE THE DESCRIPTIONS
!             OF PRELDF AND NPRELDF UNDER IV(OUTLEV) ABOVE), AND (IF AN
!             ATTEMPT WAS MADE TO COMPUTE THE COVARIANCE) THE NUMBER OF
!             CALLS ON CALCR AND CALCJ USED IN TRYING TO COMPUTE THE
!             COVARIANCE.  IV(STATPR) = 0 MEANS SKIP THIS PRINTING.
!             DEFAULT = 1.
! IV(X0PRT).... IV(24) = 1 MEANS PRINT THE INITIAL X AND SCALE VECTOR D
!             (ON A FRESH START ONLY).  IV(X0PRT) = 0 MEANS SKIP THIS
!             PRINTING.  DEFAULT = 1.
!
!  ***  (SELECTED) IV OUTPUT VALUES  ***
!
! IV(1)........ ON OUTPUT, IV(1) IS A RETURN CODE....
!             3 = X-CONVERGENCE.  THE SCALED RELATIVE DIFFERENCE BETWEEN
!                  THE CURRENT PARAMETER VECTOR X AND A LOCALLY
!                  OPTIMAL PARAMETER VECTOR IS VERY LIKELY AT MOST
!                  V(XCTOL).
!             4 = RELATIVE FUNCTION CONVERGENCE.  THE RELATIVE DIFFERENCE
!                  BETWEEN THE CURRENT FUNCTION VALUE AND ITS LOCALLY
!                  OPTIMAL VALUE IS VERY LIKELY AT MOST V(RFCTOL).
!             5 = BOTH X- AND RELATIVE FUNCTION CONVERGENCE (I.E., THE
!                  CONDITIONS FOR IV(1) = 3 AND IV(1) = 4 BOTH HOLD).
!             6 = ABSOLUTE FUNCTION CONVERGENCE.  THE CURRENT FUNCTION
!                  VALUE IS AT MOST V(AFCTOL) IN ABSOLUTE VALUE.
!             7 = SINGULAR CONVERGENCE.  THE HESSIAN NEAR THE CURRENT
!                  ITERATE APPEARS TO BE SINGULAR OR NEARLY SO, AND A
!                  STEP OF LENGTH AT MOST V(LMAX0) IS UNLIKELY TO YIELD
!                  A RELATIVE FUNCTION DECREASE OF MORE THAN V(RFCTOL).
!             8 = FALSE CONVERGENCE.  THE ITERATES APPEAR TO BE CONVERGING
!                  TO A NONCRITICAL POINT.  THIS MAY MEAN THAT THE
!                  CONVERGENCE TOLERANCES (V(AFCTOL), V(RFCTOL),
!                  V(XCTOL)) ARE TOO SMALL FOR THE ACCURACY TO WHICH
!                  THE FUNCTION AND GRADIENT ARE BEING COMPUTED, THAT
!                  THERE IS AN ERROR IN COMPUTING THE GRADIENT, OR THAT
!                  THE FUNCTION OR GRADIENT IS DISCONTINUOUS NEAR X.
!             9 = FUNCTION EVALUATION LIMIT REACHED WITHOUT OTHER CONVERGENCE
!                  (SEE IV(MXFCAL)).
!            10 = ITERATION LIMIT REACHED WITHOUT OTHER CONVERGENCE
!                  (SEE IV(MXITER)).
!            11 = STOPX RETURNED .TRUE. (EXTERNAL INTERUPT).  SEE THE
!                  USAGE NOTES BELOW.
!            13 = F(X) CANNOT BE COMPUTED AT THE INITIAL X.
!            14 = BAD PARAMETERS PASSED TO ASSESS (WHICH SHOULD NOT
!                  OCCUR).
!            15 = THE JACOBIAN COULD NOT BE COMPUTED AT X (SEE CALCJ
!                  ABOVE).
!            16 = N OR P (OR PARAMETER NN TO NL2ITR) OUT OF RANGE --
!                  P .LE. 0 OR N .LT. P OR NN .LT. N.
!            17 = RESTART ATTEMPTED WITH N OR P (OR PAR. NN TO NL2ITR)
!                  CHANGED.
!            18 = IV(INITS) IS OUT OF RANGE.
!            19...45 = V(IV(1)-18) IS OUT OF RANGE.
!            50 = IV(1) WAS OUT OF RANGE.
!            87...(86+P) = JTOL(IV(1)-86) (I.E., V(IV(1)) IS NOT
!                  POSITIVE (SEE V(DFAC) BELOW).
! IV(COVMAT)... IV(26) TELLS WHETHER A COVARIANCE MATRIX WAS COMPUTED.
!             IF (IV(COVMAT) IS POSITIVE, THEN THE LOWER TRIANGLE OF
!             THE COVARIANCE MATRIX IS STORED ROWWISE IN V STARTING AT
!             V(IV(COVMAT)).  IF IV(COVMAT) = 0, THEN NO ATTEMPT WAS
!             MADE TO COMPUTE THE COVARIANCE.  IF IV(COVMAT) = -1,
!             THEN THE FINITE-DIFFERENCE HESSIAN WAS INDEFINITE.  AND
!             AND IF IV(COVMAT) = -2, THEN A SUCCESSFUL FINITE-DIFFERENCING
!             STEP COULD NOT BE FOUND FOR SOME COMPONENT OF X
!             (I.E., CALCR SET NF TO 0 FOR EACH OF TWO TRIAL STEPS).
!             NOTE THAT IV(COVMAT) IS RESET TO 0 AFTER EACH SUCCESSFUL
!             STEP, SO IF SUCH A STEP IS TAKEN AFTER A RESTART, THEN
!             THE COVARIANCE MATRIX WILL BE RECOMPUTED.
! IV(D)........ IV(27) IS THE STARTING SUBSCRIPT IN V OF THE CURRENT
!             SCALE VECTOR D.
! IV(G)........ IV(28) IS THE STARTING SUBSCRIPT IN V OF THE CURRENT
!             LEAST-SQUARES GRADIENT VECTOR (J**T)*R.
! IV(NFCALL)... IV(6) IS THE NUMBER OF CALLS SO FAR MADE ON CALCR (I.E.,
!             FUNCTION EVALUATIONS, INCLUDING THOSE USED IN COMPUTING
!             THE COVARIANCE).
! IV(NFCOV).... IV(40) IS THE NUMBER OF CALLS MADE ON CALCR WHEN
!             TRYING TO COMPUTE COVARIANCE MATRICES.
! IV(NGCALL)... IV(30) IS THE NUMBER OF GRADIENT EVALUATIONS (CALLS ON
!             CALCJ) SO FAR DONE (INCLUDING THOSE USED FOR COMPUTING
!             THE COVARIANCE).
! IV(NGCOV).... IV(41) IS THE NUMBER OF CALLS MADE ON CALCJ WHEN
!             TRYING TO COMPUTE COVARIANCE MATRICES.
! IV(NITER).... IV(31) IS THE NUMBER OF ITERATIONS PERFORMED.
! IV(R)........ IV(50) IS THE STARTING SUBSCRIPT IN V OF THE RESIDUAL
!             VECTOR R CORRESPONDING TO X.
!
!  ***  (SELECTED) V INPUT VALUES (FROM SUBROUTINE DFAULT)  ***
!
! V(AFCTOL)... V(31) IS THE ABSOLUTE FUNCTION CONVERGENCE TOLERANCE.
!             IF NL2SOL FINDS A POINT WHERE THE FUNCTION VALUE (HALF
!             THE SUM OF SQUARES) IS LESS THAN V(AFCTOL), AND IF NL2SOL
!             DOES NOT RETURN WITH IV(1) = 3, 4, OR 5, THEN IT RETURNS
!             WITH IV(1) = 6.  DEFAULT = MAX(10**-20, MACHEP**2), WHERE
!             MACHEP IS THE UNIT ROUNDOFF.
! V(DELTA0)... V(44) IS A FACTOR USED IN CHOOSING THE FINITE-DIFFERENCE
!             STEP SIZE USED IN COMPUTING THE COVARIANCE MATRIX WHEN
!             IV(COVREQ) = 1 OR 2.  FOR COMPONENT I, STEP SIZE
!                  V(DELTA0) * MAX(ABS(X(I)), 1/D(I)) * SIGN(X(I))
!             IS USED, WHERE D IS THE CURRENT SCALE VECTOR (SEE REF. 1).
!             (IF THIS STEP RESULTS IN CALCR SETTING NF TO 0, THEN -0.5
!             TIMES THIS STEP IS ALSO TRIED.)  DEFAULT = MACHEP**0.5,
!             WHERE MACHEP IS THE UNIT ROUNDOFF.
! V(DFAC)..... V(41) AND THE D0 AND JTOL ARRAYS (SEE V(D0INIT) AND
!             V(JTINIT)) ARE USED IN UPDATING THE SCALE VECTOR D WHEN
!             IV(DTYPE) .GT. 0.  (D IS INITIALIZED ACCORDING TO
!             V(DINIT).)  LET D1(I) =
!               MAX(SQRT(JCNORM(I)**2 + MAX(S(I,I),0)), V(DFAC)*D(I)),
!             WHERE JCNORM(I) IS THE 2-NORM OF THE I-TH COLUMN OF THE
!             CURRENT JACOBIAN MATRIX AND S IS THE S MATRIX OF REF. 1.
!             IF IV(DTYPE) = 1, THEN D(I) IS SET TO D1(I) UNLESS
!             D1(I) .LT. JTOL(I), IN WHICH CASE D(I) IS SET TO
!                                MAX(D0(I), JTOL(I)).
!             IF IV(DTYPE) .GE. 2, THEN D IS UPDATED DURING THE FIRST
!             ITERATION AS FOR IV(DTYPE) = 1 (AFTER ANY INITIALIZATION
!             DUE TO V(DINIT)) AND IS LEFT UNCHANGED THEREAFTER.
!             DEFAULT = 0.6.
! V(DINIT).... V(38), IF NONNEGATIVE, IS THE VALUE TO WHICH THE SCALE
!             VECTOR D IS INITIALIZED.  DEFAULT = 0.
! V(DLTFDC)... V(40) HELPS CHOOSE THE STEP SIZE USED WHEN COMPUTING THE
!             COVARIANCE MATRIX WHEN IV(COVREQ) = -1 OR -2.  FOR
!             DIFFERENCES INVOLVING X(I), THE STEP SIZE FIRST TRIED IS
!                       V(DLTFDC) * MAX(ABS(X(I)), 1/D(I)),
!             WHERE D IS THE CURRENT SCALE VECTOR (SEE REF. 1).  (IF
!             THIS STEP IS TOO BIG THE FIRST TIME IT IS TRIED, I.E., IF
!             CALCR SETS NF TO 0, THEN -0.5 TIMES THIS STEP IS ALSO
!             TRIED.)  DEFAULT = MACHEP**(1/3), WHERE MACHEP IS THE
!             UNIT ROUNDOFF.
! V(D0INIT)... V(37), IF POSITIVE, IS THE VALUE TO WHICH ALL COMPONENTS
!             OF THE D0 VECTOR (SEE V(DFAC)) ARE INITIALIZED.  IF
!             V(DFAC) = 0, THEN IT IS ASSUMED THAT THE CALLER HAS
!             STORED D0 IN V STARTING AT V(P+87).  DEFAULT = 1.0.
! V(JTINIT)... V(39), IF POSITIVE, IS THE VALUE TO WHICH ALL COMPONENTS
!             OF THE JTOL ARRAY (SEE V(DFAC)) ARE INITIALIZED.  IF
!             V(JTINIT) = 0, THEN IT IS ASSUMED THAT THE CALLER HAS
!             STORED JTOL IN V STARTING AT V(87).  DEFAULT = 10**-6.
! V(LMAX0).... V(35) GIVES THE MAXIMUM 2-NORM ALLOWED FOR D TIMES THE
!             VERY FIRST STEP THAT NL2SOL ATTEMPTS.  IT IS ALSO USED
!             IN TESTING FOR SINGULAR CONVERGENCE -- IF THE FUNCTION
!             REDUCTION PREDICTED FOR A STEP OF LENGTH BOUNDED BY
!             V(LMAX0) IS AT MOST V(RFCTOL) * ABS(F0), WHERE  F0  IS
!             THE FUNCTION VALUE AT THE START OF THE CURRENT ITERATION,
!             AND IF NL2SOL DOES NOT RETURN WITH IV(1) = 3, 4, 5, OR 6,
!             THEN IT RETURNS WITH IV(1) = 7.    DEFAULT = 100.
! V(RFCTOL)... V(32) IS THE RELATIVE FUNCTION CONVERGENCE TOLERANCE.
!             IF THE CURRENT MODEL PREDICTS A MAXIMUM POSSIBLE FUNCTION
!             REDUCTION (SEE V(NREDUC)) OF AT MOST V(RFCTOL)*ABS(F0) AT
!             THE START OF THE CURRENT ITERATION, WHERE  F0  IS THE
!             THEN CURRENT FUNCTION VALUE, AND IF THE LAST STEP ATTEMPTED
!             ACHIEVED NO MORE THAN TWICE THE PREDICTED FUNCTION
!             DECREASE, THEN NL2SOL RETURNS WITH IV(1) = 4 (OR 5).
!             DEFAULT = MAX(10**-10, MACHEP**(2/3)), WHERE MACHEP IS
!             THE UNIT ROUNDOFF.
! V(TUNER1)... V(26) HELPS DECIDE WHEN TO CHECK FOR FALSE CONVERGENCE
!             AND TO CONSIDER SWITCHING MODELS.  THIS IS DONE IF THE
!             ACTUAL FUNCTION DECREASE FROM THE CURRENT STEP IS NO MORE
!             THAN V(TUNER1) TIMES ITS PREDICTED VALUE.  DEFAULT = 0.1.
! V(XCTOL).... V(33) IS THE X-CONVERGENCE TOLERANCE.  IF A NEWTON STEP
!             (SEE V(NREDUC)) IS TRIED THAT HAS V(RELDX) .LE. V(XCTOL)
!             AND IF THIS STEP YIELDS AT MOST TWICE THE PREDICTED FUNCTION
!             DECREASE, THEN NL2SOL RETURNS WITH IV(1) = 3 (OR 5).
!             (SEE THE DESCRIPTION OF V(RELDX) BELOW.)
!             DEFAULT = MACHEP**0.5, WHERE MACHEP IS THE UNIT ROUNDOFF.
! V(XFTOL).... V(34) IS THE FALSE CONVERGENCE TOLERANCE.  IF A STEP IS
!             TRIED THAT GIVES NO MORE THAN V(TUNER1) TIMES THE PREDICTED
!             FUNCTION DECREASE AND THAT HAS V(RELDX) .LE. V(XFTOL),
!             AND IF NL2SOL DOES NOT RETURN WITH IV(1) = 3, 4, 5, 6, OR
!             7, THEN IT RETURNS WITH IV(1) = 8.  (SEE THE DESCRIPTION
!             OF V(RELDX) BELOW.)  DEFAULT = 100*MACHEP, WHERE
!             MACHEP IS THE UNIT ROUNDOFF.
! V(*)........ DFAULT SUPPLIES TO V A NUMBER OF TUNING CONSTANTS, WITH
!             WHICH IT SHOULD ORDINARILY BE UNNECESSARY TO TINKER.  SEE
!             VERSION 2.2 OF THE NL2SOL USAGE SUMMARY (WHICH IS AN
!             APPENDIX TO REF. 1).
!
!  ***  (SELECTED) V OUTPUT VALUES  ***
!
! V(DGNORM)... V(1) IS THE 2-NORM OF (D**-1)*G, WHERE G IS THE MOST RECENTLY
!             COMPUTED GRADIENT AND D IS THE CORRESPONDING SCALE
!             VECTOR.
! V(DSTNRM)... V(2) IS THE 2-NORM OF D*STEP, WHERE STEP IS THE MOST RECENTLY
!             COMPUTED STEP AND D IS THE CURRENT SCALE VECTOR.
! V(F)........ V(10) IS THE CURRENT FUNCTION VALUE (HALF THE SUM OF
!             SQUARES).
! V(F0)....... V(13) IS THE FUNCTION VALUE AT THE START OF THE CURRENT
!             ITERATION.
! V(NREDUC)... V(6), IF POSITIVE, IS THE MAXIMUM FUNCTION REDUCTION
!             POSSIBLE ACCORDING TO THE CURRENT MODEL, I.E., THE FUNCTION
!             REDUCTION PREDICTED FOR A NEWTON STEP (I.E.,
!             STEP = -H**-1 * G,  WHERE  G = (J**T) * R  IS THE CURRENT
!             GRADIENT AND H IS THE CURRENT HESSIAN APPROXIMATION --
!             H = (J**T)*J  FOR THE GAUSS-NEWTON MODEL AND
!             H = (J**T)*J + S  FOR THE AUGMENTED MODEL).
!                  V(NREDUC) = ZERO MEANS H IS NOT POSITIVE DEFINITE.
!                  IF V(NREDUC) IS NEGATIVE, THEN IT IS THE NEGATIVE OF
!             THE FUNCTION REDUCTION PREDICTED FOR A STEP COMPUTED WITH
!             A STEP BOUND OF V(LMAX0) FOR USE IN TESTING FOR SINGULAR
!             CONVERGENCE.
! V(PREDUC)... V(7) IS THE FUNCTION REDUCTION PREDICTED (BY THE CURRENT
!             QUADRATIC MODEL) FOR THE CURRENT STEP.  THIS (DIVIDED BY
!             V(F0)) IS USED IN TESTING FOR RELATIVE FUNCTION
!             CONVERGENCE.
! V(RELDX).... V(17) IS THE SCALED RELATIVE CHANGE IN X CAUSED BY THE
!             CURRENT STEP, COMPUTED AS
!                  MAX(ABS(D(I)*(X(I)-X0(I)), 1 .LE. I .LE. P) /
!                     MAX(D(I)*(ABS(X(I))+ABS(X0(I))), 1 .LE. I .LE. P),
!             WHERE X = X0 + STEP.
!
!-------------------------------  NOTES  -------------------------------
!
!  ***  ALGORITHM NOTES  ***
!
!     SEE REF. 1 FOR A DESCRIPTION OF THE ALGORITHM USED.
!     ON PROBLEMS WHICH ARE NATURALLY WELL SCALED, BETTER PERFORMANCE
!     MAY BE OBTAINED BY SETTING V(D0INIT) = 1.0 AND IV(DTYPE) = 0,
!     WHICH WILL CAUSE THE SCALE VECTOR D TO BE SET TO ALL ONES.
!
!  ***  USAGE NOTES  ***
!
!        AFTER A RETURN WITH IV(1) .LE. 11, IT IS POSSIBLE TO RESTART,
!     I.E., TO CHANGE SOME OF THE IV AND V INPUT VALUES DESCRIBED ABOVE
!     AND CONTINUE THE ALGORITHM FROM THE POINT WHERE IT WAS INTERRUPTED.
!     IV(1) SHOULD NOT BE CHANGED, NOR SHOULD ANY ENTRIES OF IV
!     AND V OTHER THAN THE INPUT VALUES (THOSE SUPPLIED BY DFAULT).
!        THOSE WHO DO NOT WISH TO WRITE A CALCJ WHICH COMPUTES THE JACOBIAN
!     MATRIX ANALYTICALLY SHOULD CALL NL2SNO RATHER THAN NL2SOL.
!     NL2SNO USES FINITE DIFFERENCES TO COMPUTE AN APPROXIMATE JACOBIAN.
!        THOSE WHO WOULD PREFER TO PROVIDE R AND J (THE RESIDUAL AND
!     JACOBIAN) BY REVERSE COMMUNICATION RATHER THAN BY WRITING SUBROUTINES
!     CALCR AND CALCJ MAY CALL ON NL2ITR DIRECTLY.  SEE THE COMMENTS
!     AT THE BEGINNING OF NL2ITR.
!        THOSE WHO USE NL2SOL INTERACTIVELY MAY WISH TO SUPPLY THEIR
!     OWN STOPX FUNCTION, WHICH SHOULD RETURN .TRUE. IF THE BREAK KEY
!     HAS BEEN PRESSED SINCE STOPX WAS LAST INVOKED.  THIS MAKES IT POSSIBLE
!     TO EXTERNALLY INTERRUPT NL2SOL (WHICH WILL RETURN WITH
!     IV(1) = 11 IF STOPX RETURNS .TRUE.).
!        STORAGE FOR J IS ALLOCATED AT THE END OF V.  THUS THE CALLER
!     MAY MAKE V LONGER THAN SPECIFIED ABOVE AND MAY ALLOW CALCJ TO USE
!     ELEMENTS OF J BEYOND THE FIRST N*P AS SCRATCH STORAGE.
!
!  ***  PORTABILITY NOTES  ***
!
!        THE NL2SOL DISTRIBUTION TAPE CONTAINS BOTH SINGLE- AND DOUBLE-
!     PRECISION VERSIONS OF THE NL2SOL SOURCE CODE, SO IT SHOULD BE
!     UNNECESSARY TO CHANGE PRECISIONS.
!        ONLY THE FUNCTIONS IMDCON AND RMDCON CONTAIN MACHINE-DEPENDENT
!     CONSTANTS.  TO CHANGE FROM ONE MACHINE TO ANOTHER, IT SHOULD
!     SUFFICE TO CHANGE THE (FEW) RELEVANT LINES IN THESE FUNCTIONS.
!
!  ***  REFERENCES  ***
!
! 1.  DENNIS, J.E., GAY, D.M., AND WELSCH, R.E. (1980), AN ADAPTIVE
!             NONLINEAR LEAST-SQUARES ALGORITHM, SUBMITTED TO ACM TRANS.
!             MATH. SOFTWARE.
!
!  ***  GENERAL  ***
!
!     CODED BY DAVID M. GAY (WINTER 1979 - WINTER 1980).
!     THIS SUBROUTINE WAS WRITTEN IN CONNECTION WITH RESEARCH
!     SUPPORTED BY THE NATIONAL SCIENCE FOUNDATION UNDER GRANTS
!     MCS-7600324, DCR75-10143, 76-14311DSS, MCS76-11989, AND
!     MCS-7906671.
!
!----------------------------  DECLARATIONS  ---------------------------
!
!     EXTERNAL ITSMRY, NL2ITR
! ITSMRY... PRINTS ITERATION SUMMARY AND INFO ABOUT INITIAL AND FINAL X.
! NL2ITR... REVERSE-COMMUNICATION ROUTINE THAT CARRIES OUT NL2SOL ALGORITHM.
!
!     LOGICAL STRTED
!     INTEGER D1, J1, NF, R1
!
!  ***  SUBSCRIPTS FOR IV AND V  ***
!
!     INTEGER D, J, NFCALL, NFGCAL, R, TOOBIG
!
!  ***  IV SUBSCRIPT VALUES  ***
!
      data nfcall/6/, nfgcal/7/, toobig/2/
!
!  ***  V SUBSCRIPT VALUES  ***
!
      data d/27/, j/33/, r/50/
!
!+++++++++++++++++++++++++++++++  BODY  ++++++++++++++++++++++++++++++++
!
      d1 = 94 + 2*n + p*(3*p + 31)/2
      iv(d) = d1
      r1 = d1 + p
      iv(r) = r1
      j1 = r1 + n
      iv(j) = j1
      strted = .true.
      if (iv(1) .ne. 0 .and. iv(1) .ne. 12) go to 40
         strted = .false.
         iv(nfcall) = 1
         iv(nfgcal) = 1
!
 10   nf = iv(nfcall)
      call calcr(n, p, x, nf, v(r1), uiparm, urparm, ufparm)
      if (strted) go to 20
         if (nf .gt. 0) go to 30
              iv(1) = 13
              go to 60
!
 20   if (nf .le. 0) iv(toobig) = 1
      go to 40
!
 30   call calcj(n, p, x, iv(nfgcal), v(j1), uiparm, urparm, ufparm)
      if (iv(nfgcal) .eq. 0) go to 50
      strted = .true.
!
!          nl2itr(d(p),  iv(*), j(nn,p), n, nn, p, r(n),  v(*), x(p))
 40   call nl2itr(v(d1), iv,    v(j1),   n, n,  p, v(r1), v,    x)
      if (iv(1) - 2) 10, 30, 999
!
 50   iv(1) = 15
 60   call itsmry(v(d1), iv, p, v, x)
!
 999  return
!  ***  LAST CARD OF NL2SOL FOLLOWS  ***
      end
!RMDCON
      real(kind=wp) function rmdcon(k,typ)
      real(kind=wp),intent(in) :: typ
!
!     LATEST REVISION  -  03/15/90  (JRD)
!
!
!  VARIABLE DECLARATIONS
!
!  SCALAR ARGUMENTS
      integer k
!
!  LOCAL SCALARS
      real(kind=wp) :: big,eta,machep,one001,pt999
!
!  EXTERNAL FUNCTIONS
!     real(kind=wp) :: mach
!
!  INTRINSIC FUNCTIONS
      intrinsic sqrt
!
!
!  ***  RETURN MACHINE DEPENDENT CONSTANTS USED BY NL2SOL  ***
!
! +++  COMMENTS BELOW CONTAIN DATA STATEMENTS FOR VARIOUS MACHINES.  +++
! +++  TO CONVERT TO ANOTHER MACHINE, PLACE A C IN COLUMN 1 OF THE   +++
! +++  DATA STATEMENT LINE(S) THAT CORRESPOND TO THE CURRENT MACHINE +++
! +++  AND REMOVE THE C FROM COLUMN 1 OF THE DATA STATEMENT LINE(S)  +++
! +++  THAT CORRESPOND TO THE NEW MACHINE.                           +++
!
!     INTEGER K
!
!  ***  THE CONSTANT RETURNED DEPENDS ON K...
!
!  ***        K = 1... SMALLEST POS. ETA SUCH THAT -ETA EXISTS.
!  ***        K = 2... SQUARE ROOT OF 1.001*ETA.
!  ***        K = 3... UNIT ROUNDOFF = SMALLEST POS. NO. MACHEP SUCH
!  ***                 THAT 1 + MACHEP .GT. 1 .AND. 1 - MACHEP .LT. 1.
!  ***        K = 4... SQUARE ROOT OF 0.999*MACHEP.
!  ***        K = 5... SQUARE ROOT OF 0.999*BIG (SEE K = 6).
!  ***        K = 6... LARGEST MACHINE NO. BIG SUCH THAT -BIG EXISTS.
!
!
      data one001/1.001_wp/, pt999/0.999_wp/
!
      big = mach(2)
      eta = mach(1)
      machep = mach(4)
!
!-------------------------------  BODY  --------------------------------
!
      go to (10, 20, 30, 40, 50, 60), k
!
 10   rmdcon = eta
      go to 999
!
 20   rmdcon = sqrt(one001*eta)
      go to 999
!
 30   rmdcon = machep
      go to 999
!
 40   rmdcon = sqrt(pt999*machep)
      go to 999
!
 50   rmdcon = sqrt(pt999*big)
      go to 999
!
 60   rmdcon = big
!
 999  return
!  ***  LAST CARD OF RMDCON FOLLOWS  ***
      end

      end module M_starpac_s
